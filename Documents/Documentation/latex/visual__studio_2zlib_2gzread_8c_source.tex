\hypertarget{visual__studio_2zlib_2gzread_8c_source}{}\section{visual\+\_\+studio/zlib/gzread.c}
\label{visual__studio_2zlib_2gzread_8c_source}\index{gzread.\+c@{gzread.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* gzread.c -- zlib functions for reading gzip files}
00002 \textcolor{comment}{ * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ */}
00005 
00006 \textcolor{preprocessor}{#include "gzguts.h"}
00007 
00008 \textcolor{comment}{/* Local functions */}
00009 local \textcolor{keywordtype}{int} gz\_load OF((gz\_statep, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *, \textcolor{keywordtype}{unsigned}, \textcolor{keywordtype}{unsigned} *));
00010 local \textcolor{keywordtype}{int} gz\_avail OF((gz\_statep));
00011 local \textcolor{keywordtype}{int} gz\_look OF((gz\_statep));
00012 local \textcolor{keywordtype}{int} gz\_decomp OF((gz\_statep));
00013 local \textcolor{keywordtype}{int} gz\_fetch OF((gz\_statep));
00014 local \textcolor{keywordtype}{int} gz\_skip OF((gz\_statep, z\_off64\_t));
00015 local z\_size\_t gz\_read OF((gz\_statep, voidp, z\_size\_t));
00016 
00017 \textcolor{comment}{/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from}
00018 \textcolor{comment}{   state->fd, and update state->eof, state->err, and state->msg as appropriate.}
00019 \textcolor{comment}{   This function needs to loop on read(), since read() is not guaranteed to}
00020 \textcolor{comment}{   read the number of bytes requested, depending on the type of descriptor. */}
00021 local \textcolor{keywordtype}{int} gz\_load(\hyperlink{structstate}{state}, buf, len, have)
00022     gz\_statep \hyperlink{structstate}{state};
00023     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf;
00024     \textcolor{keywordtype}{unsigned} len;
00025     \textcolor{keywordtype}{unsigned} *have;
00026 \{
00027     \textcolor{keywordtype}{int} ret;
00028     \textcolor{keywordtype}{unsigned} \textcolor{keyword}{get}, max = ((unsigned)-1 >> 2) + 1;
00029 
00030     *have = 0;
00031     \textcolor{keywordflow}{do} \{
00032         \textcolor{keyword}{get} = len - *have;
00033         \textcolor{keywordflow}{if} (\textcolor{keyword}{get} > max)
00034             \textcolor{keyword}{get} = max;
00035         ret = read(state->fd, buf + *have, \textcolor{keyword}{get});
00036         \textcolor{keywordflow}{if} (ret <= 0)
00037             \textcolor{keywordflow}{break};
00038         *have += (unsigned)ret;
00039     \} \textcolor{keywordflow}{while} (*have < len);
00040     \textcolor{keywordflow}{if} (ret < 0) \{
00041         gz\_error(state, Z\_ERRNO, zstrerror());
00042         \textcolor{keywordflow}{return} -1;
00043     \}
00044     \textcolor{keywordflow}{if} (ret == 0)
00045         state->eof = 1;
00046     \textcolor{keywordflow}{return} 0;
00047 \}
00048 
00049 \textcolor{comment}{/* Load up input buffer and set eof flag if last data loaded -- return -1 on}
00050 \textcolor{comment}{   error, 0 otherwise.  Note that the eof flag is set when the end of the input}
00051 \textcolor{comment}{   file is reached, even though there may be unused data in the buffer.  Once}
00052 \textcolor{comment}{   that data has been used, no more attempts will be made to read the file.}
00053 \textcolor{comment}{   If strm->avail\_in != 0, then the current data is moved to the beginning of}
00054 \textcolor{comment}{   the input buffer, and then the remainder of the buffer is loaded with the}
00055 \textcolor{comment}{   available data from the input file. */}
00056 local \textcolor{keywordtype}{int} gz\_avail(state)
00057     gz\_statep state;
00058 \{
00059     \textcolor{keywordtype}{unsigned} got;
00060     z\_streamp strm = &(state->strm);
00061 
00062     \textcolor{keywordflow}{if} (state->err != Z\_OK && state->err != Z\_BUF\_ERROR)
00063         \textcolor{keywordflow}{return} -1;
00064     \textcolor{keywordflow}{if} (state->eof == 0) \{
00065         \textcolor{keywordflow}{if} (strm->avail\_in) \{       \textcolor{comment}{/* copy what's there to the start */}
00066             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = state->in;
00067             \textcolor{keywordtype}{unsigned} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *q = strm->next\_in;
00068             \textcolor{keywordtype}{unsigned} n = strm->avail\_in;
00069             \textcolor{keywordflow}{do} \{
00070                 *p++ = *q++;
00071             \} \textcolor{keywordflow}{while} (--n);
00072         \}
00073         \textcolor{keywordflow}{if} (gz\_load(state, state->in + strm->avail\_in,
00074                     state->size - strm->avail\_in, &got) == -1)
00075             \textcolor{keywordflow}{return} -1;
00076         strm->avail\_in += got;
00077         strm->next\_in = state->in;
00078     \}
00079     \textcolor{keywordflow}{return} 0;
00080 \}
00081 
00082 \textcolor{comment}{/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.}
00083 \textcolor{comment}{   If this is the first time in, allocate required memory.  state->how will be}
00084 \textcolor{comment}{   left unchanged if there is no more input data available, will be set to COPY}
00085 \textcolor{comment}{   if there is no gzip header and direct copying will be performed, or it will}
00086 \textcolor{comment}{   be set to GZIP for decompression.  If direct copying, then leftover input}
00087 \textcolor{comment}{   data from the input buffer will be copied to the output buffer.  In that}
00088 \textcolor{comment}{   case, all further file reads will be directly to either the output buffer or}
00089 \textcolor{comment}{   a user buffer.  If decompressing, the inflate state will be initialized.}
00090 \textcolor{comment}{   gz\_look() will return 0 on success or -1 on failure. */}
00091 local \textcolor{keywordtype}{int} gz\_look(state)
00092     gz\_statep state;
00093 \{
00094     z\_streamp strm = &(state->strm);
00095 
00096     \textcolor{comment}{/* allocate read buffers and inflate memory */}
00097     \textcolor{keywordflow}{if} (state->size == 0) \{
00098         \textcolor{comment}{/* allocate buffers */}
00099         state->in = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(state->want);
00100         state->out = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(state->want << 1);
00101         \textcolor{keywordflow}{if} (state->in == NULL || state->out == NULL) \{
00102             free(state->out);
00103             free(state->in);
00104             gz\_error(state, Z\_MEM\_ERROR, \textcolor{stringliteral}{"out of memory"});
00105             \textcolor{keywordflow}{return} -1;
00106         \}
00107         state->size = state->want;
00108 
00109         \textcolor{comment}{/* allocate inflate memory */}
00110         state->strm.zalloc = Z\_NULL;
00111         state->strm.zfree = Z\_NULL;
00112         state->strm.opaque = Z\_NULL;
00113         state->strm.avail\_in = 0;
00114         state->strm.next\_in = Z\_NULL;
00115         \textcolor{keywordflow}{if} (inflateInit2(&(state->strm), 15 + 16) != Z\_OK) \{    \textcolor{comment}{/* gunzip */}
00116             free(state->out);
00117             free(state->in);
00118             state->size = 0;
00119             gz\_error(state, Z\_MEM\_ERROR, \textcolor{stringliteral}{"out of memory"});
00120             \textcolor{keywordflow}{return} -1;
00121         \}
00122     \}
00123 
00124     \textcolor{comment}{/* get at least the magic bytes in the input buffer */}
00125     \textcolor{keywordflow}{if} (strm->avail\_in < 2) \{
00126         \textcolor{keywordflow}{if} (gz\_avail(state) == -1)
00127             \textcolor{keywordflow}{return} -1;
00128         \textcolor{keywordflow}{if} (strm->avail\_in == 0)
00129             \textcolor{keywordflow}{return} 0;
00130     \}
00131 
00132     \textcolor{comment}{/* look for gzip magic bytes -- if there, do gzip decoding (note: there is}
00133 \textcolor{comment}{       a logical dilemma here when considering the case of a partially written}
00134 \textcolor{comment}{       gzip file, to wit, if a single 31 byte is written, then we cannot tell}
00135 \textcolor{comment}{       whether this is a single-byte file, or just a partially written gzip}
00136 \textcolor{comment}{       file -- for here we assume that if a gzip file is being written, then}
00137 \textcolor{comment}{       the header will be written in a single operation, so that reading a}
00138 \textcolor{comment}{       single byte is sufficient indication that it is not a gzip file) */}
00139     \textcolor{keywordflow}{if} (strm->avail\_in > 1 &&
00140             strm->next\_in[0] == 31 && strm->next\_in[1] == 139) \{
00141         inflateReset(strm);
00142         state->how = GZIP;
00143         state->direct = 0;
00144         \textcolor{keywordflow}{return} 0;
00145     \}
00146 
00147     \textcolor{comment}{/* no gzip header -- if we were decoding gzip before, then this is trailing}
00148 \textcolor{comment}{       garbage.  Ignore the trailing garbage and finish. */}
00149     \textcolor{keywordflow}{if} (state->direct == 0) \{
00150         strm->avail\_in = 0;
00151         state->eof = 1;
00152         state->x.have = 0;
00153         \textcolor{keywordflow}{return} 0;
00154     \}
00155 
00156     \textcolor{comment}{/* doing raw i/o, copy any leftover input to output -- this assumes that}
00157 \textcolor{comment}{       the output buffer is larger than the input buffer, which also assures}
00158 \textcolor{comment}{       space for gzungetc() */}
00159     state->x.next = state->out;
00160     \textcolor{keywordflow}{if} (strm->avail\_in) \{
00161         memcpy(state->x.next, strm->next\_in, strm->avail\_in);
00162         state->x.have = strm->avail\_in;
00163         strm->avail\_in = 0;
00164     \}
00165     state->how = COPY;
00166     state->direct = 1;
00167     \textcolor{keywordflow}{return} 0;
00168 \}
00169 
00170 \textcolor{comment}{/* Decompress from input to the provided next\_out and avail\_out in the state.}
00171 \textcolor{comment}{   On return, state->x.have and state->x.next point to the just decompressed}
00172 \textcolor{comment}{   data.  If the gzip stream completes, state->how is reset to LOOK to look for}
00173 \textcolor{comment}{   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0}
00174 \textcolor{comment}{   on success, -1 on failure. */}
00175 local \textcolor{keywordtype}{int} gz\_decomp(state)
00176     gz\_statep state;
00177 \{
00178     \textcolor{keywordtype}{int} ret = Z\_OK;
00179     \textcolor{keywordtype}{unsigned} had;
00180     z\_streamp strm = &(state->strm);
00181 
00182     \textcolor{comment}{/* fill output buffer up to end of deflate stream */}
00183     had = strm->avail\_out;
00184     \textcolor{keywordflow}{do} \{
00185         \textcolor{comment}{/* get more input for inflate() */}
00186         \textcolor{keywordflow}{if} (strm->avail\_in == 0 && gz\_avail(state) == -1)
00187             \textcolor{keywordflow}{return} -1;
00188         \textcolor{keywordflow}{if} (strm->avail\_in == 0) \{
00189             gz\_error(state, Z\_BUF\_ERROR, \textcolor{stringliteral}{"unexpected end of file"});
00190             \textcolor{keywordflow}{break};
00191         \}
00192 
00193         \textcolor{comment}{/* decompress and handle errors */}
00194         ret = inflate(strm, Z\_NO\_FLUSH);
00195         \textcolor{keywordflow}{if} (ret == Z\_STREAM\_ERROR || ret == Z\_NEED\_DICT) \{
00196             gz\_error(state, Z\_STREAM\_ERROR,
00197                      \textcolor{stringliteral}{"internal error: inflate stream corrupt"});
00198             \textcolor{keywordflow}{return} -1;
00199         \}
00200         \textcolor{keywordflow}{if} (ret == Z\_MEM\_ERROR) \{
00201             gz\_error(state, Z\_MEM\_ERROR, \textcolor{stringliteral}{"out of memory"});
00202             \textcolor{keywordflow}{return} -1;
00203         \}
00204         \textcolor{keywordflow}{if} (ret == Z\_DATA\_ERROR) \{              \textcolor{comment}{/* deflate stream invalid */}
00205             gz\_error(state, Z\_DATA\_ERROR,
00206                      strm->msg == NULL ? \textcolor{stringliteral}{"compressed data error"} : strm->msg);
00207             \textcolor{keywordflow}{return} -1;
00208         \}
00209     \} \textcolor{keywordflow}{while} (strm->avail\_out && ret != Z\_STREAM\_END);
00210 
00211     \textcolor{comment}{/* update available output */}
00212     state->x.have = had - strm->avail\_out;
00213     state->x.next = strm->next\_out - state->x.have;
00214 
00215     \textcolor{comment}{/* if the gzip stream completed successfully, look for another */}
00216     \textcolor{keywordflow}{if} (ret == Z\_STREAM\_END)
00217         state->how = LOOK;
00218 
00219     \textcolor{comment}{/* good decompression */}
00220     \textcolor{keywordflow}{return} 0;
00221 \}
00222 
00223 \textcolor{comment}{/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.}
00224 \textcolor{comment}{   Data is either copied from the input file or decompressed from the input}
00225 \textcolor{comment}{   file depending on state->how.  If state->how is LOOK, then a gzip header is}
00226 \textcolor{comment}{   looked for to determine whether to copy or decompress.  Returns -1 on error,}
00227 \textcolor{comment}{   otherwise 0.  gz\_fetch() will leave state->how as COPY or GZIP unless the}
00228 \textcolor{comment}{   end of the input file has been reached and all data has been processed.  */}
00229 local \textcolor{keywordtype}{int} gz\_fetch(state)
00230     gz\_statep state;
00231 \{
00232     z\_streamp strm = &(state->strm);
00233 
00234     \textcolor{keywordflow}{do} \{
00235         \textcolor{keywordflow}{switch}(state->how) \{
00236         \textcolor{keywordflow}{case} LOOK:      \textcolor{comment}{/* -> LOOK, COPY (only if never GZIP), or GZIP */}
00237             \textcolor{keywordflow}{if} (gz\_look(state) == -1)
00238                 \textcolor{keywordflow}{return} -1;
00239             \textcolor{keywordflow}{if} (state->how == LOOK)
00240                 \textcolor{keywordflow}{return} 0;
00241             \textcolor{keywordflow}{break};
00242         \textcolor{keywordflow}{case} COPY:      \textcolor{comment}{/* -> COPY */}
00243             \textcolor{keywordflow}{if} (gz\_load(state, state->out, state->size << 1, &(state->x.have))
00244                     == -1)
00245                 \textcolor{keywordflow}{return} -1;
00246             state->x.next = state->out;
00247             \textcolor{keywordflow}{return} 0;
00248         \textcolor{keywordflow}{case} GZIP:      \textcolor{comment}{/* -> GZIP or LOOK (if end of gzip stream) */}
00249             strm->avail\_out = state->size << 1;
00250             strm->next\_out = state->out;
00251             \textcolor{keywordflow}{if} (gz\_decomp(state) == -1)
00252                 \textcolor{keywordflow}{return} -1;
00253         \}
00254     \} \textcolor{keywordflow}{while} (state->x.have == 0 && (!state->eof || strm->avail\_in));
00255     \textcolor{keywordflow}{return} 0;
00256 \}
00257 
00258 \textcolor{comment}{/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */}
00259 local \textcolor{keywordtype}{int} gz\_skip(state, len)
00260     gz\_statep state;
00261     z\_off64\_t len;
00262 \{
00263     \textcolor{keywordtype}{unsigned} n;
00264 
00265     \textcolor{comment}{/* skip over len bytes or reach end-of-file, whichever comes first */}
00266     \textcolor{keywordflow}{while} (len)
00267         \textcolor{comment}{/* skip over whatever is in output buffer */}
00268         \textcolor{keywordflow}{if} (state->x.have) \{
00269             n = GT\_OFF(state->x.have) || (z\_off64\_t)state->x.have > len ?
00270                 (\textcolor{keywordtype}{unsigned})len : state->x.have;
00271             state->x.have -= n;
00272             state->x.next += n;
00273             state->x.pos += n;
00274             len -= n;
00275         \}
00276 
00277         \textcolor{comment}{/* output buffer empty -- return if we're at the end of the input */}
00278         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (state->eof && state->strm.avail\_in == 0)
00279             \textcolor{keywordflow}{break};
00280 
00281         \textcolor{comment}{/* need more data to skip -- load up output buffer */}
00282         \textcolor{keywordflow}{else} \{
00283             \textcolor{comment}{/* get more output, looking for header if required */}
00284             \textcolor{keywordflow}{if} (gz\_fetch(state) == -1)
00285                 \textcolor{keywordflow}{return} -1;
00286         \}
00287     \textcolor{keywordflow}{return} 0;
00288 \}
00289 
00290 \textcolor{comment}{/* Read len bytes into buf from file, or less than len up to the end of the}
00291 \textcolor{comment}{   input.  Return the number of bytes read.  If zero is returned, either the}
00292 \textcolor{comment}{   end of file was reached, or there was an error.  state->err must be}
00293 \textcolor{comment}{   consulted in that case to determine which. */}
00294 local z\_size\_t gz\_read(state, buf, len)
00295     gz\_statep state;
00296     voidp buf;
00297     z\_size\_t len;
00298 \{
00299     z\_size\_t got;
00300     \textcolor{keywordtype}{unsigned} n;
00301 
00302     \textcolor{comment}{/* if len is zero, avoid unnecessary operations */}
00303     \textcolor{keywordflow}{if} (len == 0)
00304         \textcolor{keywordflow}{return} 0;
00305 
00306     \textcolor{comment}{/* process a skip request */}
00307     \textcolor{keywordflow}{if} (state->seek) \{
00308         state->seek = 0;
00309         \textcolor{keywordflow}{if} (gz\_skip(state, state->skip) == -1)
00310             \textcolor{keywordflow}{return} 0;
00311     \}
00312 
00313     \textcolor{comment}{/* get len bytes to buf, or less than len if at the end */}
00314     got = 0;
00315     \textcolor{keywordflow}{do} \{
00316         \textcolor{comment}{/* set n to the maximum amount of len that fits in an unsigned int */}
00317         n = -1;
00318         \textcolor{keywordflow}{if} (n > len)
00319             n = len;
00320 
00321         \textcolor{comment}{/* first just try copying data from the output buffer */}
00322         \textcolor{keywordflow}{if} (state->x.have) \{
00323             \textcolor{keywordflow}{if} (state->x.have < n)
00324                 n = state->x.have;
00325             memcpy(buf, state->x.next, n);
00326             state->x.next += n;
00327             state->x.have -= n;
00328         \}
00329 
00330         \textcolor{comment}{/* output buffer empty -- return if we're at the end of the input */}
00331         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (state->eof && state->strm.avail\_in == 0) \{
00332             state->past = 1;        \textcolor{comment}{/* tried to read past end */}
00333             \textcolor{keywordflow}{break};
00334         \}
00335 
00336         \textcolor{comment}{/* need output data -- for small len or new stream load up our output}
00337 \textcolor{comment}{           buffer */}
00338         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (state->how == LOOK || n < (state->size << 1)) \{
00339             \textcolor{comment}{/* get more output, looking for header if required */}
00340             \textcolor{keywordflow}{if} (gz\_fetch(state) == -1)
00341                 \textcolor{keywordflow}{return} 0;
00342             \textcolor{keywordflow}{continue};       \textcolor{comment}{/* no progress yet -- go back to copy above */}
00343             \textcolor{comment}{/* the copy above assures that we will leave with space in the}
00344 \textcolor{comment}{               output buffer, allowing at least one gzungetc() to succeed */}
00345         \}
00346 
00347         \textcolor{comment}{/* large len -- read directly into user buffer */}
00348         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (state->how == COPY) \{      \textcolor{comment}{/* read directly */}
00349             \textcolor{keywordflow}{if} (gz\_load(state, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)buf, n, &n) == -1)
00350                 \textcolor{keywordflow}{return} 0;
00351         \}
00352 
00353         \textcolor{comment}{/* large len -- decompress directly into user buffer */}
00354         \textcolor{keywordflow}{else} \{  \textcolor{comment}{/* state->how == GZIP */}
00355             state->strm.avail\_out = n;
00356             state->strm.next\_out = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)buf;
00357             \textcolor{keywordflow}{if} (gz\_decomp(state) == -1)
00358                 \textcolor{keywordflow}{return} 0;
00359             n = state->x.have;
00360             state->x.have = 0;
00361         \}
00362 
00363         \textcolor{comment}{/* update progress */}
00364         len -= n;
00365         buf = (\textcolor{keywordtype}{char} *)buf + n;
00366         got += n;
00367         state->x.pos += n;
00368     \} \textcolor{keywordflow}{while} (len);
00369 
00370     \textcolor{comment}{/* return number of bytes read into user buffer */}
00371     \textcolor{keywordflow}{return} got;
00372 \}
00373 
00374 \textcolor{comment}{/* -- see zlib.h -- */}
00375 \textcolor{keywordtype}{int} ZEXPORT gzread(\hyperlink{structfile}{file}, buf, len)
00376     \hyperlink{structgz_file__s}{gzFile} \hyperlink{structfile}{file};
00377     voidp buf;
00378     \textcolor{keywordtype}{unsigned} len;
00379 \{
00380     gz\_statep state;
00381 
00382     \textcolor{comment}{/* get internal structure */}
00383     \textcolor{keywordflow}{if} (file == NULL)
00384         \textcolor{keywordflow}{return} -1;
00385     state = (gz\_statep)file;
00386 
00387     \textcolor{comment}{/* check that we're reading and that there's no (serious) error */}
00388     \textcolor{keywordflow}{if} (state->mode != GZ\_READ ||
00389             (state->err != Z\_OK && state->err != Z\_BUF\_ERROR))
00390         \textcolor{keywordflow}{return} -1;
00391 
00392     \textcolor{comment}{/* since an int is returned, make sure len fits in one, otherwise return}
00393 \textcolor{comment}{       with an error (this avoids a flaw in the interface) */}
00394     \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{int})len < 0) \{
00395         gz\_error(state, Z\_STREAM\_ERROR, \textcolor{stringliteral}{"request does not fit in an int"});
00396         \textcolor{keywordflow}{return} -1;
00397     \}
00398 
00399     \textcolor{comment}{/* read len or fewer bytes to buf */}
00400     len = gz\_read(state, buf, len);
00401 
00402     \textcolor{comment}{/* check for an error */}
00403     \textcolor{keywordflow}{if} (len == 0 && state->err != Z\_OK && state->err != Z\_BUF\_ERROR)
00404         \textcolor{keywordflow}{return} -1;
00405 
00406     \textcolor{comment}{/* return the number of bytes read (this is assured to fit in an int) */}
00407     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{int})len;
00408 \}
00409 
00410 \textcolor{comment}{/* -- see zlib.h -- */}
00411 z\_size\_t ZEXPORT gzfread(buf, size, nitems, file)
00412     voidp buf;
00413     z\_size\_t size;
00414     z\_size\_t nitems;
00415     \hyperlink{structgz_file__s}{gzFile} file;
00416 \{
00417     z\_size\_t len;
00418     gz\_statep state;
00419 
00420     \textcolor{comment}{/* get internal structure */}
00421     \textcolor{keywordflow}{if} (file == NULL)
00422         \textcolor{keywordflow}{return} 0;
00423     state = (gz\_statep)file;
00424 
00425     \textcolor{comment}{/* check that we're reading and that there's no (serious) error */}
00426     \textcolor{keywordflow}{if} (state->mode != GZ\_READ ||
00427             (state->err != Z\_OK && state->err != Z\_BUF\_ERROR))
00428         \textcolor{keywordflow}{return} 0;
00429 
00430     \textcolor{comment}{/* compute bytes to read -- error on overflow */}
00431     len = nitems * size;
00432     \textcolor{keywordflow}{if} (size && len / size != nitems) \{
00433         gz\_error(state, Z\_STREAM\_ERROR, \textcolor{stringliteral}{"request does not fit in a size\_t"});
00434         \textcolor{keywordflow}{return} 0;
00435     \}
00436 
00437     \textcolor{comment}{/* read len or fewer bytes to buf, return the number of full items read */}
00438     \textcolor{keywordflow}{return} len ? gz\_read(state, buf, len) / size : 0;
00439 \}
00440 
00441 \textcolor{comment}{/* -- see zlib.h -- */}
00442 \textcolor{preprocessor}{#ifdef Z\_PREFIX\_SET}
00443 \textcolor{preprocessor}{#  undef z\_gzgetc}
00444 \textcolor{preprocessor}{#else}
00445 \textcolor{preprocessor}{#  undef gzgetc}
00446 \textcolor{preprocessor}{#endif}
00447 \textcolor{keywordtype}{int} ZEXPORT gzgetc(file)
00448     \hyperlink{structgz_file__s}{gzFile} file;
00449 \{
00450     \textcolor{keywordtype}{int} ret;
00451     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[1];
00452     gz\_statep state;
00453 
00454     \textcolor{comment}{/* get internal structure */}
00455     \textcolor{keywordflow}{if} (file == NULL)
00456         \textcolor{keywordflow}{return} -1;
00457     state = (gz\_statep)file;
00458 
00459     \textcolor{comment}{/* check that we're reading and that there's no (serious) error */}
00460     \textcolor{keywordflow}{if} (state->mode != GZ\_READ ||
00461         (state->err != Z\_OK && state->err != Z\_BUF\_ERROR))
00462         \textcolor{keywordflow}{return} -1;
00463 
00464     \textcolor{comment}{/* try output buffer (no need to check for skip request) */}
00465     \textcolor{keywordflow}{if} (state->x.have) \{
00466         state->x.have--;
00467         state->x.pos++;
00468         \textcolor{keywordflow}{return} *(state->x.next)++;
00469     \}
00470 
00471     \textcolor{comment}{/* nothing there -- try gz\_read() */}
00472     ret = gz\_read(state, buf, 1);
00473     \textcolor{keywordflow}{return} ret < 1 ? -1 : buf[0];
00474 \}
00475 
00476 \textcolor{keywordtype}{int} ZEXPORT gzgetc\_(file)
00477 \hyperlink{structgz_file__s}{gzFile} file;
00478 \{
00479     \textcolor{keywordflow}{return} gzgetc(file);
00480 \}
00481 
00482 \textcolor{comment}{/* -- see zlib.h -- */}
00483 \textcolor{keywordtype}{int} ZEXPORT gzungetc(c, file)
00484     \textcolor{keywordtype}{int} c;
00485     \hyperlink{structgz_file__s}{gzFile} file;
00486 \{
00487     gz\_statep state;
00488 
00489     \textcolor{comment}{/* get internal structure */}
00490     \textcolor{keywordflow}{if} (file == NULL)
00491         \textcolor{keywordflow}{return} -1;
00492     state = (gz\_statep)file;
00493 
00494     \textcolor{comment}{/* check that we're reading and that there's no (serious) error */}
00495     \textcolor{keywordflow}{if} (state->mode != GZ\_READ ||
00496         (state->err != Z\_OK && state->err != Z\_BUF\_ERROR))
00497         \textcolor{keywordflow}{return} -1;
00498 
00499     \textcolor{comment}{/* process a skip request */}
00500     \textcolor{keywordflow}{if} (state->seek) \{
00501         state->seek = 0;
00502         \textcolor{keywordflow}{if} (gz\_skip(state, state->skip) == -1)
00503             \textcolor{keywordflow}{return} -1;
00504     \}
00505 
00506     \textcolor{comment}{/* can't push EOF */}
00507     \textcolor{keywordflow}{if} (c < 0)
00508         \textcolor{keywordflow}{return} -1;
00509 
00510     \textcolor{comment}{/* if output buffer empty, put byte at end (allows more pushing) */}
00511     \textcolor{keywordflow}{if} (state->x.have == 0) \{
00512         state->x.have = 1;
00513         state->x.next = state->out + (state->size << 1) - 1;
00514         state->x.next[0] = (\textcolor{keywordtype}{unsigned} char)c;
00515         state->x.pos--;
00516         state->past = 0;
00517         \textcolor{keywordflow}{return} c;
00518     \}
00519 
00520     \textcolor{comment}{/* if no room, give up (must have already done a gzungetc()) */}
00521     \textcolor{keywordflow}{if} (state->x.have == (state->size << 1)) \{
00522         gz\_error(state, Z\_DATA\_ERROR, \textcolor{stringliteral}{"out of room to push characters"});
00523         \textcolor{keywordflow}{return} -1;
00524     \}
00525 
00526     \textcolor{comment}{/* slide output data if needed and insert byte before existing data */}
00527     \textcolor{keywordflow}{if} (state->x.next == state->out) \{
00528         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *src = state->out + state->x.have;
00529         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *dest = state->out + (state->size << 1);
00530         \textcolor{keywordflow}{while} (src > state->out)
00531             *--dest = *--src;
00532         state->x.next = dest;
00533     \}
00534     state->x.have++;
00535     state->x.next--;
00536     state->x.next[0] = (\textcolor{keywordtype}{unsigned} char)c;
00537     state->x.pos--;
00538     state->past = 0;
00539     \textcolor{keywordflow}{return} c;
00540 \}
00541 
00542 \textcolor{comment}{/* -- see zlib.h -- */}
00543 \textcolor{keywordtype}{char} * ZEXPORT gzgets(file, buf, len)
00544     \hyperlink{structgz_file__s}{gzFile} file;
00545     \textcolor{keywordtype}{char} *buf;
00546     \textcolor{keywordtype}{int} len;
00547 \{
00548     \textcolor{keywordtype}{unsigned} left, n;
00549     \textcolor{keywordtype}{char} *str;
00550     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eol;
00551     gz\_statep state;
00552 
00553     \textcolor{comment}{/* check parameters and get internal structure */}
00554     \textcolor{keywordflow}{if} (file == NULL || buf == NULL || len < 1)
00555         \textcolor{keywordflow}{return} NULL;
00556     state = (gz\_statep)file;
00557 
00558     \textcolor{comment}{/* check that we're reading and that there's no (serious) error */}
00559     \textcolor{keywordflow}{if} (state->mode != GZ\_READ ||
00560         (state->err != Z\_OK && state->err != Z\_BUF\_ERROR))
00561         \textcolor{keywordflow}{return} NULL;
00562 
00563     \textcolor{comment}{/* process a skip request */}
00564     \textcolor{keywordflow}{if} (state->seek) \{
00565         state->seek = 0;
00566         \textcolor{keywordflow}{if} (gz\_skip(state, state->skip) == -1)
00567             \textcolor{keywordflow}{return} NULL;
00568     \}
00569 
00570     \textcolor{comment}{/* copy output bytes up to new line or len - 1, whichever comes first --}
00571 \textcolor{comment}{       append a terminating zero to the string (we don't check for a zero in}
00572 \textcolor{comment}{       the contents, let the user worry about that) */}
00573     str = buf;
00574     left = (unsigned)len - 1;
00575     \textcolor{keywordflow}{if} (left) \textcolor{keywordflow}{do} \{
00576         \textcolor{comment}{/* assure that something is in the output buffer */}
00577         \textcolor{keywordflow}{if} (state->x.have == 0 && gz\_fetch(state) == -1)
00578             \textcolor{keywordflow}{return} NULL;                \textcolor{comment}{/* error */}
00579         \textcolor{keywordflow}{if} (state->x.have == 0) \{       \textcolor{comment}{/* end of file */}
00580             state->past = 1;            \textcolor{comment}{/* read past end */}
00581             \textcolor{keywordflow}{break};                      \textcolor{comment}{/* return what we have */}
00582         \}
00583 
00584         \textcolor{comment}{/* look for end-of-line in current output buffer */}
00585         n = state->x.have > left ? left : state->x.have;
00586         eol = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)memchr(state->x.next, \textcolor{charliteral}{'\(\backslash\)n'}, n);
00587         \textcolor{keywordflow}{if} (eol != NULL)
00588             n = (unsigned)(eol - state->x.next) + 1;
00589 
00590         \textcolor{comment}{/* copy through end-of-line, or remainder if not found */}
00591         memcpy(buf, state->x.next, n);
00592         state->x.have -= n;
00593         state->x.next += n;
00594         state->x.pos += n;
00595         left -= n;
00596         buf += n;
00597     \} \textcolor{keywordflow}{while} (left && eol == NULL);
00598 
00599     \textcolor{comment}{/* return terminated string, or if nothing, end of file */}
00600     \textcolor{keywordflow}{if} (buf == str)
00601         \textcolor{keywordflow}{return} NULL;
00602     buf[0] = 0;
00603     \textcolor{keywordflow}{return} str;
00604 \}
00605 
00606 \textcolor{comment}{/* -- see zlib.h -- */}
00607 \textcolor{keywordtype}{int} ZEXPORT gzdirect(file)
00608     \hyperlink{structgz_file__s}{gzFile} file;
00609 \{
00610     gz\_statep state;
00611 
00612     \textcolor{comment}{/* get internal structure */}
00613     \textcolor{keywordflow}{if} (file == NULL)
00614         \textcolor{keywordflow}{return} 0;
00615     state = (gz\_statep)file;
00616 
00617     \textcolor{comment}{/* if the state is not known, but we can find out, then do so (this is}
00618 \textcolor{comment}{       mainly for right after a gzopen() or gzdopen()) */}
00619     \textcolor{keywordflow}{if} (state->mode == GZ\_READ && state->how == LOOK && state->x.have == 0)
00620         (void)gz\_look(state);
00621 
00622     \textcolor{comment}{/* return 1 if transparent, 0 if processing a gzip stream */}
00623     \textcolor{keywordflow}{return} state->direct;
00624 \}
00625 
00626 \textcolor{comment}{/* -- see zlib.h -- */}
00627 \textcolor{keywordtype}{int} ZEXPORT gzclose\_r(file)
00628     \hyperlink{structgz_file__s}{gzFile} file;
00629 \{
00630     \textcolor{keywordtype}{int} ret, err;
00631     gz\_statep state;
00632 
00633     \textcolor{comment}{/* get internal structure */}
00634     \textcolor{keywordflow}{if} (file == NULL)
00635         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00636     state = (gz\_statep)file;
00637 
00638     \textcolor{comment}{/* check that we're reading */}
00639     \textcolor{keywordflow}{if} (state->mode != GZ\_READ)
00640         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00641 
00642     \textcolor{comment}{/* free memory and close file */}
00643     \textcolor{keywordflow}{if} (state->size) \{
00644         inflateEnd(&(state->strm));
00645         free(state->out);
00646         free(state->in);
00647     \}
00648     err = state->err == Z\_BUF\_ERROR ? Z\_BUF\_ERROR : Z\_OK;
00649     gz\_error(state, Z\_OK, NULL);
00650     free(state->path);
00651     ret = close(state->fd);
00652     free(state);
00653     \textcolor{keywordflow}{return} ret ? Z\_ERRNO : err;
00654 \}
\end{DoxyCode}
