\hypertarget{eigen_2_eigen_2src_2_core_2_ref_8h_source}{}\section{eigen/\+Eigen/src/\+Core/\+Ref.h}
\label{eigen_2_eigen_2src_2_core_2_ref_8h_source}\index{Ref.\+h@{Ref.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_REF\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_REF\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_PlainObjectType, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_Str\textcolor{keywordtype}{id}eType>
\Hypertarget{eigen_2_eigen_2src_2_core_2_ref_8h_source_l00018}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_ref_3_01___plain_object_type_00_01___options_00_01___stride_type_01_4_01_4}{00018} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}<\_PlainObjectType, \_Options, \_StrideType> >
00019   : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<Map<\_PlainObjectType, \_Options, \_StrideType> >
00020 \{
00021   \textcolor{keyword}{typedef} \_PlainObjectType PlainObjectType;
00022   \textcolor{keyword}{typedef} \_StrideType StrideType;
00023   \textcolor{keyword}{enum} \{
00024     Options = \_Options,
00025     Flags = \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<Map<\_PlainObjectType, \_Options, \_StrideType>}
       >::Flags | NestByRefBit,
00026     Alignment = \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<Map<\_PlainObjectType, \_Options, \_StrideType>}
       >::Alignment
00027   \};
00028 
\Hypertarget{eigen_2_eigen_2src_2_core_2_ref_8h_source_l00029}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_ref_3_01___plain_object_type_00_01___options_00_01___stride_type_01_4_01_4_1_1match}{00029}   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{struct }match \{
00030     \textcolor{keyword}{enum} \{
00031       HasDirectAccess = \hyperlink{struct_eigen_1_1internal_1_1has__direct__access}{internal::has\_direct\_access<Derived>::ret},
00032       StorageOrderMatch = PlainObjectType::IsVectorAtCompileTime || Derived::IsVectorAtCompileTime || ((
      PlainObjectType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==(Derived::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})),
00033       InnerStrideMatch = \textcolor{keywordtype}{int}(StrideType::InnerStrideAtCompileTime)==int(\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic})
00034                       || int(StrideType::InnerStrideAtCompileTime)==int(Derived::InnerStrideAtCompileTime)
00035                       || (int(StrideType::InnerStrideAtCompileTime)==0 && int(
      Derived::InnerStrideAtCompileTime)==1),
00036       OuterStrideMatch = Derived::IsVectorAtCompileTime
00037                       || \textcolor{keywordtype}{int}(StrideType::OuterStrideAtCompileTime)==int(\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}) || int(
      StrideType::OuterStrideAtCompileTime)==int(Derived::OuterStrideAtCompileTime),
00038       \textcolor{comment}{// NOTE, this indirection of evaluator<Derived>::Alignment is needed}
00039       \textcolor{comment}{// to workaround a very strange bug in MSVC related to the instantiation}
00040       \textcolor{comment}{// of has\_*ary\_operator in evaluator<CwiseNullaryOp>.}
00041       \textcolor{comment}{// This line is surprisingly very sensitive. For instance, simply adding parenthesis}
00042       \textcolor{comment}{// as "DerivedAlignment = (int(evaluator<Derived>::Alignment))," will make MSVC fail...}
00043       DerivedAlignment = int(\hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<Derived>::Alignment}),
00044       AlignmentMatch = (int(\hyperlink{struct_eigen_1_1internal_1_1traits}{traits<PlainObjectType>::Alignment})==int(
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned})) || (DerivedAlignment >= \textcolor{keywordtype}{int}(Alignment)), \textcolor{comment}{// FIXME the first condition is not very
       clear, it should be replaced by the required alignment}
00045       ScalarTypeMatch = 
      \hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<typename PlainObjectType::Scalar, typename Derived::Scalar>::value}
      ,
00046       MatchAtCompileTime = HasDirectAccess && StorageOrderMatch && InnerStrideMatch && OuterStrideMatch && 
      AlignmentMatch && ScalarTypeMatch
00047     \};
00048     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::conditional<MatchAtCompileTime,internal::true\_type,internal::false\_type>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{type};
00049   \};
00050   
00051 \};
00052 
00053 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_ref_8h_source_l00054}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_ref_base_3_01_derived_01_4_01_4}{00054} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_ref_base}{RefBase}<Derived> > : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<Derived> \{\};
00055 
00056 \}
00057 
\Hypertarget{eigen_2_eigen_2src_2_core_2_ref_8h_source_l00058}\hyperlink{class_eigen_1_1_ref_base}{00058} \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_ref_base}{RefBase}
00059  : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_map_base}{MapBase}<Derived>
00060 \{
00061   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::PlainObjectType} 
      PlainObjectType;
00062   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::StrideType} StrideType;
00063 
00064 \textcolor{keyword}{public}:
00065 
00066   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_map_base}{MapBase<Derived>} \hyperlink{class_eigen_1_1_map_base}{Base};
00067   EIGEN\_DENSE\_PUBLIC\_INTERFACE(\hyperlink{class_eigen_1_1_ref_base}{RefBase})
00068 
00069   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} innerStride()\textcolor{keyword}{ const}
00070 \textcolor{keyword}{  }\{
00071     \textcolor{keywordflow}{return} StrideType::InnerStrideAtCompileTime != 0 ? m\_stride.inner() : 1;
00072   \}
00073 
00074   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerStride()\textcolor{keyword}{ const}
00075 \textcolor{keyword}{  }\{
00076     \textcolor{keywordflow}{return} StrideType::OuterStrideAtCompileTime != 0 ? m\_stride.outer()
00077          : IsVectorAtCompileTime ? this->size()
00078          : int(Flags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} ? this->cols()
00079          : this->rows();
00080   \}
00081 
00082   EIGEN\_DEVICE\_FUNC \hyperlink{class_eigen_1_1_ref_base}{RefBase}()
00083     : Base(0,RowsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}?0:RowsAtCompileTime,ColsAtCompileTime==
      \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}?0:ColsAtCompileTime),
00084       \textcolor{comment}{// Stride<> does not allow default ctor for Dynamic strides, so let' initialize it with dummy values:}
00085       m\_stride(StrideType::OuterStrideAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}?0:StrideType::OuterStrideAtCompileTime,
00086                StrideType::InnerStrideAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}?0:StrideType::InnerStrideAtCompileTime)
00087   \{\}
00088   
00089   EIGEN\_INHERIT\_ASSIGNMENT\_OPERATORS(RefBase)
00090 
00091 \textcolor{keyword}{protected}:
00092 
00093   \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module}{Stride<StrideType::OuterStrideAtCompileTime,StrideType::InnerStrideAtCompileTime>}
       \hyperlink{group___core___module}{StrideBase};
00094 
00095   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Expression>
00096   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} construct(Expression& expr)
00097   \{
00098     \textcolor{keywordflow}{if}(PlainObjectType::RowsAtCompileTime==1)
00099     \{
00100       eigen\_assert(expr.rows()==1 || expr.cols()==1);
00101       ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(expr.data(), 1, expr.size());
00102     \}
00103     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(PlainObjectType::ColsAtCompileTime==1)
00104     \{
00105       eigen\_assert(expr.rows()==1 || expr.cols()==1);
00106       ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(expr.data(), expr.size(), 1);
00107     \}
00108     else
00109       ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(expr.data(), expr.rows(), expr.cols());
00110     
00111     \textcolor{keywordflow}{if}(Expression::IsVectorAtCompileTime && (!PlainObjectType::IsVectorAtCompileTime) && ((
      Expression::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})!=(PlainObjectType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})))
00112       ::new (&m\_stride) StrideBase(expr.innerStride(), StrideType::InnerStrideAtCompileTime==0?0:1);
00113     else
00114       ::new (&m\_stride) StrideBase(StrideType::OuterStrideAtCompileTime==0?0:expr.outerStride(),
00115                                    StrideType::InnerStrideAtCompileTime==0?0:expr.innerStride());    
00116   \}
00117 
00118   StrideBase m\_stride;
00119 \};
00120 
\Hypertarget{eigen_2_eigen_2src_2_core_2_ref_8h_source_l00190}\hyperlink{group___core___module}{00190} \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}eType> \textcolor{keyword}{class }\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}
00191   : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_ref_base}{RefBase}<Ref<PlainObjectType, Options, StrideType> >
00192 \{
00193   \textcolor{keyword}{private}:
00194     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Ref>} \hyperlink{struct_eigen_1_1internal_1_1traits}{Traits};
00195     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00196     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase<Derived>}& expr,
00197                                  \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1enable__if}{internal::enable\_if}<\textcolor{keywordtype}{bool}(Traits::template 
      match<Derived>::MatchAtCompileTime),Derived>::type* = 0);
00198   \textcolor{keyword}{public}:
00199 
00200     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_ref_base}{RefBase<Ref>} \hyperlink{class_eigen_1_1_ref_base}{Base};
00201     EIGEN\_DENSE\_PUBLIC\_INTERFACE(Ref)
00202 
00203 
00204     \textcolor{preprocessor}{#ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00205     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00206     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Ref(\hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase<Derived>}& expr,
00207                                  \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1enable__if}{internal::enable\_if}<\textcolor{keywordtype}{bool}(Traits::template 
      match<Derived>::MatchAtCompileTime),Derived>::type* = 0)
00208     \{
00209       EIGEN\_STATIC\_ASSERT(\textcolor{keywordtype}{bool}(Traits::template match<Derived>::MatchAtCompileTime), 
      STORAGE\_LAYOUT\_DOES\_NOT\_MATCH);
00210       Base::construct(expr.derived());
00211     \}
00212     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00213     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Ref(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_dense_base}{DenseBase<Derived>}& expr,
00214                                  \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1enable__if}{internal::enable\_if}<\textcolor{keywordtype}{bool}(Traits::template 
      match<Derived>::MatchAtCompileTime),Derived>::type* = 0)
00215     \textcolor{preprocessor}{#else}
00216 
00217     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00218     \textcolor{keyword}{inline} Ref(\hyperlink{group___core___module_class_eigen_1_1_dense_base}{DenseBase<Derived>}& expr)
00219     \textcolor{preprocessor}{#endif}
00220     \{
00221       EIGEN\_STATIC\_ASSERT(\textcolor{keywordtype}{bool}(\hyperlink{struct_eigen_1_1internal_1_1is__lvalue}{internal::is\_lvalue<Derived>::value}), 
      THIS\_EXPRESSION\_IS\_NOT\_A\_LVALUE\_\_IT\_IS\_READ\_ONLY);
00222       EIGEN\_STATIC\_ASSERT(\textcolor{keywordtype}{bool}(Traits::template match<Derived>::MatchAtCompileTime), 
      STORAGE\_LAYOUT\_DOES\_NOT\_MATCH);
00223       EIGEN\_STATIC\_ASSERT(!Derived::IsPlainObjectBase,THIS\_EXPRESSION\_IS\_NOT\_A\_LVALUE\_\_IT\_IS\_READ\_ONLY);
00224       Base::construct(expr.const\_cast\_derived());
00225     \}
00226 
00227     EIGEN\_INHERIT\_ASSIGNMENT\_OPERATORS(Ref)
00228 
00229 \};
00230 
00231 \textcolor{comment}{// this is the const ref version}
\Hypertarget{eigen_2_eigen_2src_2_core_2_ref_8h_source_l00232}\hyperlink{class_eigen_1_1_ref_3_01const_01_t_plain_object_type_00_01_options_00_01_stride_type_01_4}{00232} \textcolor{keyword}{template}<\textcolor{keyword}{typename} TPlainObjectType, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}eType> \textcolor{keyword}{class }\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}<const TPlainObjectType, 
      Options, StrideType>
00233   : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_ref_base}{RefBase}<Ref<const TPlainObjectType, Options, StrideType> >
00234 \{
00235     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Ref>} \hyperlink{struct_eigen_1_1internal_1_1traits}{Traits};
00236   \textcolor{keyword}{public}:
00237 
00238     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_ref_base}{RefBase<Ref>} \hyperlink{class_eigen_1_1_ref_base}{Base};
00239     EIGEN\_DENSE\_PUBLIC\_INTERFACE(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref})
00240 
00241     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00242     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_dense_base}{DenseBase<Derived>}& expr,
00243                                  \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1enable__if}{internal::enable\_if}<\textcolor{keywordtype}{bool}(Traits::template 
      match<Derived>::ScalarTypeMatch),Derived>::type* = 0)
00244     \{
00245 \textcolor{comment}{//      std::cout << match\_helper<Derived>::HasDirectAccess << "," <<
       match\_helper<Derived>::OuterStrideMatch << "," << match\_helper<Derived>::InnerStrideMatch << "\(\backslash\)n";}
00246 \textcolor{comment}{//      std::cout << int(StrideType::OuterStrideAtCompileTime) << " - " <<
       int(Derived::OuterStrideAtCompileTime) << "\(\backslash\)n";}
00247 \textcolor{comment}{//      std::cout << int(StrideType::InnerStrideAtCompileTime) << " - " <<
       int(Derived::InnerStrideAtCompileTime) << "\(\backslash\)n";}
00248       construct(expr.derived(), \textcolor{keyword}{typename} Traits::template match<Derived>::type());
00249     \}
00250 
00251     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}& other) : Base(other) \{
00252       \textcolor{comment}{// copy constructor shall not copy the m\_object, to avoid unnecessary malloc and copy}
00253     \}
00254 
00255     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherRef>
00256     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Ref(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1_ref_base}{RefBase<OtherRef>}& other) \{
00257       construct(other.derived(), \textcolor{keyword}{typename} Traits::template match<OtherRef>::type());
00258     \}
00259 
00260   \textcolor{keyword}{protected}:
00261 
00262     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Expression>
00263     EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} construct(\textcolor{keyword}{const} Expression& expr,\hyperlink{struct_eigen_1_1internal_1_1true__type}{internal::true\_type})
00264     \{
00265       Base::construct(expr);
00266     \}
00267 
00268     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Expression>
00269     EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} construct(\textcolor{keyword}{const} Expression& expr, 
      \hyperlink{struct_eigen_1_1internal_1_1false__type}{internal::false\_type})
00270     \{
00271       internal::call\_assignment\_no\_alias(m\_object,expr,
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<Scalar,Scalar>}());
00272       Base::construct(m\_object);
00273     \}
00274 
00275   \textcolor{keyword}{protected}:
00276     TPlainObjectType m\_object;
00277 \};
00278 
00279 \} \textcolor{comment}{// end namespace Eigen}
00280 
00281 \textcolor{preprocessor}{#endif // EIGEN\_REF\_H}
\end{DoxyCode}
