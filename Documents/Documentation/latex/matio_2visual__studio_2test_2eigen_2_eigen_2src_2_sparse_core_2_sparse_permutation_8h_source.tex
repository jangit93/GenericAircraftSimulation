\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_permutation_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+Core/\+Sparse\+Permutation.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_permutation_8h_source}\index{Sparse\+Permutation.\+h@{Sparse\+Permutation.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSE\_PERMUTATION\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SPARSE\_PERMUTATION\_H}
00012 
00013 \textcolor{comment}{// This file implements sparse * permutation products}
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00016 
00017 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00018 
00019 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType, \textcolor{keywordtype}{int} S\textcolor{keywordtype}{id}e, \textcolor{keywordtype}{bool} Transposed>
00020 \textcolor{keyword}{struct }permutation\_matrix\_product<ExpressionType, Side, Transposed, SparseShape>
00021 \{
00022     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} nested\_eval<ExpressionType, 1>::type MatrixType;
00023     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<MatrixType>::type MatrixTypeCleaned;
00024 
00025     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixTypeCleaned::Scalar Scalar;
00026     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixTypeCleaned::StorageIndex StorageIndex;
00027 
00028     \textcolor{keyword}{enum} \{
00029       SrcStorageOrder = MatrixTypeCleaned::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} ? 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},
00030       MoveOuter = SrcStorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? Side==\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4}{OnTheLeft} : Side==
      \hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b}{OnTheRight}
00031     \};
00032     
00033     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::conditional<MoveOuter,
00034         SparseMatrix<Scalar,SrcStorageOrder,StorageIndex>,
00035         SparseMatrix<Scalar,int(SrcStorageOrder)==RowMajor?ColMajor:RowMajor,StorageIndex> >::type 
      ReturnType;
00036 
00037     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest,\textcolor{keyword}{typename} PermutationType>
00038     \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(Dest& dst, \textcolor{keyword}{const} PermutationType& perm, \textcolor{keyword}{const} ExpressionType& xpr)
00039     \{
00040       MatrixType mat(xpr);
00041       \textcolor{keywordflow}{if}(MoveOuter)
00042       \{
00043         SparseMatrix<Scalar,SrcStorageOrder,StorageIndex> tmp(mat.rows(), mat.cols());
00044         Matrix<StorageIndex,Dynamic,1> sizes(mat.outerSize());
00045         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<mat.outerSize(); ++j)
00046         \{
00047           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} jp = perm.indices().coeff(j);
00048           sizes[((Side==\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4}{OnTheLeft}) ^ Transposed) ? jp : j] = StorageIndex(mat.innerVector(((Side==
      \hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b}{OnTheRight}) ^ Transposed) ? jp : j).nonZeros());
00049         \}
00050         tmp.reserve(sizes);
00051         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<mat.outerSize(); ++j)
00052         \{
00053           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} jp = perm.indices().coeff(j);
00054           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} jsrc = ((Side==\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b}{OnTheRight}) ^ Transposed) ? jp : j;
00055           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} jdst = ((Side==\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4}{OnTheLeft}) ^ Transposed) ? jp : j;
00056           \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} MatrixTypeCleaned::InnerIterator it(mat,jsrc); it; ++it)
00057             tmp.insertByOuterInner(jdst,it.index()) = it.value();
00058         \}
00059         dst = tmp;
00060       \}
00061       \textcolor{keywordflow}{else}
00062       \{
00063         SparseMatrix<Scalar,int(SrcStorageOrder)==RowMajor?ColMajor:RowMajor,StorageIndex> tmp(mat.rows(), 
      mat.cols());
00064         Matrix<StorageIndex,Dynamic,1> sizes(tmp.outerSize());
00065         sizes.setZero();
00066         PermutationMatrix<Dynamic,Dynamic,StorageIndex> perm\_cpy;
00067         \textcolor{keywordflow}{if}((Side==\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4}{OnTheLeft}) ^ Transposed)
00068           perm\_cpy = perm;
00069         \textcolor{keywordflow}{else}
00070           perm\_cpy = perm.transpose();
00071 
00072         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<mat.outerSize(); ++j)
00073           \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} MatrixTypeCleaned::InnerIterator it(mat,j); it; ++it)
00074             sizes[perm\_cpy.indices().coeff(it.index())]++;
00075         tmp.reserve(sizes);
00076         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<mat.outerSize(); ++j)
00077           \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} MatrixTypeCleaned::InnerIterator it(mat,j); it; ++it)
00078             tmp.insertByOuterInner(perm\_cpy.indices().coeff(it.index()),j) = it.value();
00079         dst = tmp;
00080       \}
00081     \}
00082 \};
00083 
00084 \}
00085 
00086 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00087 
00088 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} ProductTag> \textcolor{keyword}{struct }product\_promote\_storage\_type<Sparse,             PermutationStorage, 
      ProductTag> \{ \textcolor{keyword}{typedef} Sparse ret; \};
00089 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} ProductTag> \textcolor{keyword}{struct }product\_promote\_storage\_type<PermutationStorage, Sparse,             
      ProductTag> \{ \textcolor{keyword}{typedef} Sparse ret; \};
00090 
00091 \textcolor{comment}{// TODO, the following two overloads are only needed to define the right temporary type through }
00092 \textcolor{comment}{// typename traits<permutation\_sparse\_matrix\_product<Rhs,Lhs,OnTheRight,false> >::ReturnType}
00093 \textcolor{comment}{// whereas it should be correctly handled by traits<Product<> >::PlainObject}
00094 
00095 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductTag>
00096 \textcolor{keyword}{struct }product\_evaluator<Product<Lhs, Rhs, AliasFreeProduct>, ProductTag, PermutationShape, SparseShape>
00097   : \textcolor{keyword}{public} evaluator<typename permutation\_matrix\_product<Rhs,OnTheLeft,false,SparseShape>::ReturnType>
00098 \{
00099   \textcolor{keyword}{typedef} Product<Lhs, Rhs, AliasFreeProduct> XprType;
00100   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} permutation\_matrix\_product<Rhs,OnTheLeft,false,SparseShape>::ReturnType PlainObject;
00101   \textcolor{keyword}{typedef} evaluator<PlainObject> Base;
00102 
00103   \textcolor{keyword}{enum} \{
00104     Flags = Base::Flags | \hyperlink{group__flags_gaa34e83bae46a8eeae4e69ebe3aaecbed}{EvalBeforeNestingBit}
00105   \};
00106 
00107   \textcolor{keyword}{explicit} product\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00108     : m\_result(xpr.rows(), xpr.cols())
00109   \{
00110     ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(m\_result);
00111     generic\_product\_impl<Lhs, Rhs, PermutationShape, SparseShape, ProductTag>::evalTo(m\_result, xpr.lhs(), 
      xpr.rhs());
00112   \}
00113 
00114 protected:
00115   PlainObject m\_result;
00116 \};
00117 
00118 template<typename Lhs, typename Rhs, \textcolor{keywordtype}{int} ProductTag>
00119 struct product\_evaluator<Product<Lhs, Rhs, AliasFreeProduct>, ProductTag, SparseShape, PermutationShape >
00120   : public evaluator<typename permutation\_matrix\_product<Lhs,\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b}{OnTheRight},false,SparseShape>::
      ReturnType>
00121 \{
00122   \textcolor{keyword}{typedef} Product<Lhs, Rhs, AliasFreeProduct> XprType;
00123   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} permutation\_matrix\_product<Lhs,OnTheRight,false,SparseShape>::ReturnType PlainObject;
00124   \textcolor{keyword}{typedef} evaluator<PlainObject> Base;
00125 
00126   \textcolor{keyword}{enum} \{
00127     Flags = Base::Flags | \hyperlink{group__flags_gaa34e83bae46a8eeae4e69ebe3aaecbed}{EvalBeforeNestingBit}
00128   \};
00129 
00130   \textcolor{keyword}{explicit} product\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00131     : m\_result(xpr.rows(), xpr.cols())
00132   \{
00133     ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(m\_result);
00134     generic\_product\_impl<Lhs, Rhs, SparseShape, PermutationShape, ProductTag>::evalTo(m\_result, xpr.lhs(), 
      xpr.rhs());
00135   \}
00136 
00137 protected:
00138   PlainObject m\_result;
00139 \};
00140 
00141 \} \textcolor{comment}{// end namespace internal}
00142 
00145 template<typename SparseDerived, typename PermDerived>
00146 inline const Product<SparseDerived, PermDerived, AliasFreeProduct>
00147 operator*(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)
00148 \{ \textcolor{keywordflow}{return} Product<SparseDerived, PermDerived, AliasFreeProduct>(matrix.derived(), perm.derived()); \}
00149 
00152 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseDerived, \textcolor{keyword}{typename} PermDerived>
00153 \textcolor{keyword}{inline} \textcolor{keyword}{const} Product<PermDerived, SparseDerived, AliasFreeProduct>
00154 operator*( \textcolor{keyword}{const} PermutationBase<PermDerived>& perm, \textcolor{keyword}{const} SparseMatrixBase<SparseDerived>& matrix)
00155 \{ \textcolor{keywordflow}{return}  Product<PermDerived, SparseDerived, AliasFreeProduct>(perm.derived(), matrix.derived()); \}
00156 
00157 
00160 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseDerived, \textcolor{keyword}{typename} PermutationType>
00161 \textcolor{keyword}{inline} \textcolor{keyword}{const} Product<SparseDerived, Inverse<PermutationType>, AliasFreeProduct>
00162 operator*(\textcolor{keyword}{const} SparseMatrixBase<SparseDerived>& matrix, \textcolor{keyword}{const} InverseImpl<PermutationType,
       PermutationStorage>& tperm)
00163 \{
00164   \textcolor{keywordflow}{return} Product<SparseDerived, Inverse<PermutationType>, AliasFreeProduct>(matrix.derived(), tperm.derived
      ());
00165 \}
00166 
00169 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseDerived, \textcolor{keyword}{typename} PermutationType>
00170 \textcolor{keyword}{inline} \textcolor{keyword}{const} Product<Inverse<PermutationType>, SparseDerived, AliasFreeProduct>
00171 operator*(\textcolor{keyword}{const} InverseImpl<PermutationType,PermutationStorage>& tperm, \textcolor{keyword}{const} 
      SparseMatrixBase<SparseDerived>& matrix)
00172 \{
00173   \textcolor{keywordflow}{return} Product<Inverse<PermutationType>, SparseDerived, AliasFreeProduct>(tperm.derived(), matrix.derived
      ());
00174 \}
00175 
00176 \} \textcolor{comment}{// end namespace Eigen}
00177 
00178 \textcolor{preprocessor}{#endif // EIGEN\_SPARSE\_SELFADJOINTVIEW\_H}
\end{DoxyCode}
