\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_c_x_x11_meta_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/util/\+C\+X\+X11\+Meta.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_c_x_x11_meta_8h_source}\index{C\+X\+X11\+Meta.\+h@{C\+X\+X11\+Meta.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2013 Christian Seiler <christian@iwakd.de>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11META\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11META\_H}
00012 
00013 \textcolor{preprocessor}{#include <vector>}
00014 \textcolor{preprocessor}{#include "EmulateArray.h"}
00015 
00016 \textcolor{comment}{// Emulate the cxx11 functionality that we need if the compiler doesn't support it.}
00017 \textcolor{comment}{// Visual studio 2015 doesn't advertise itself as cxx11 compliant, although it}
00018 \textcolor{comment}{// supports enough of the standard for our needs}
00019 \textcolor{preprocessor}{#if \_\_cplusplus > 199711L || EIGEN\_COMP\_MSVC >= 1900}
00020 
00021 \textcolor{preprocessor}{#include "CXX11Workarounds.h"}
00022 
00023 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00024 
00025 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00026 
00033 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... tt>
00034 \textcolor{keyword}{struct }type\_list \{ constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} count = \textcolor{keyword}{sizeof}...(tt); \};
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} t, \textcolor{keyword}{typename}... tt>
00037 \textcolor{keyword}{struct }type\_list<t, tt...> \{ constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} count = \textcolor{keyword}{sizeof}...(tt) + 1; \textcolor{keyword}{typedef} t first\_type; \};
00038 
00039 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... nn>
00040 \textcolor{keyword}{struct }numeric\_list \{ constexpr \textcolor{keyword}{static} std::size\_t count = \textcolor{keyword}{sizeof}...(nn); \};
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} n, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... nn>
00043 \textcolor{keyword}{struct }numeric\_list<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, n, nn...> \{ constexpr \textcolor{keyword}{static} std::size\_t count = \textcolor{keyword}{sizeof}...(nn) + 1; constexpr \textcolor{keyword}{
      static} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} first\_value = n; \};
00044 
00045 \textcolor{comment}{/* numeric list constructors}
00046 \textcolor{comment}{ *}
00047 \textcolor{comment}{ * equivalencies:}
00048 \textcolor{comment}{ *     constructor                                              result}
00049 \textcolor{comment}{ *     typename gen\_numeric\_list<int, 5>::type                  numeric\_list<int, 0,1,2,3,4>}
00050 \textcolor{comment}{ *     typename gen\_numeric\_list\_reversed<int, 5>::type         numeric\_list<int, 4,3,2,1,0>}
00051 \textcolor{comment}{ *     typename gen\_numeric\_list\_swapped\_pair<int, 5,1,2>::type numeric\_list<int, 0,2,1,3,4>}
00052 \textcolor{comment}{ *     typename gen\_numeric\_list\_repeated<int, 0, 5>::type      numeric\_list<int, 0,0,0,0,0>}
00053 \textcolor{comment}{ */}
00054 
00055 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, std::size\_t n, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} start = 0, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... ii> \textcolor{keyword}{struct }gen\_numeric\_list                     : 
      gen\_numeric\_list<T, n-1, start, start + n-1, ii...> \{\};
00056 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} start, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... ii>                    \textcolor{keyword}{struct }gen\_numeric\_list<
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, 0, start, ii...> \{ \textcolor{keyword}{typedef} numeric\_list<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, ii...> type; \};
00057 
00058 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, std::size\_t n, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} start = 0, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... ii> \textcolor{keyword}{struct }gen\_numeric\_list\_reversed              
             : gen\_numeric\_list\_reversed<T, n-1, start, ii..., start + n-1> \{\};
00059 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} start, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... ii>                    \textcolor{keyword}{struct }gen\_numeric\_list\_reversed<
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, 0, start, ii...> \{ \textcolor{keyword}{typedef} numeric\_list<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, ii...> type; \};
00060 
00061 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, std::size\_t n, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} a, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} b, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} start = 0, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... ii> \textcolor{keyword}{struct }
      gen\_numeric\_list\_swapped\_pair                           : gen\_numeric\_list\_swapped\_pair<T, n-1, a, b, start, (start + n-1) == a ? b : (
      (start + n-1) == b ? a : (start + n-1)), ii...> \{\};
00062 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} a, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} b, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} start, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... ii>                    \textcolor{keyword}{struct }
      gen\_numeric\_list\_swapped\_pair<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, 0, a, b, start, ii...> \{ \textcolor{keyword}{typedef} numeric\_list<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, ii...> type; \};
00063 
00064 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, std::size\_t n, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} V, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... nn> \textcolor{keyword}{struct }gen\_numeric\_list\_repeated                 : 
      gen\_numeric\_list\_repeated<T, n-1, V, V, nn...> \{\};
00065 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} V, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... nn>                \textcolor{keyword}{struct }gen\_numeric\_list\_repeated<
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, 0, V, nn...> \{ \textcolor{keyword}{typedef} numeric\_list<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, nn...> type; \};
00066 
00067 \textcolor{comment}{/* list manipulation: concatenate */}
00068 
00069 \textcolor{keyword}{template}<\textcolor{keyword}{class} a, \textcolor{keyword}{class} b> \textcolor{keyword}{struct }concat;
00070 
00071 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... as, \textcolor{keyword}{typename}... bs> \textcolor{keyword}{struct }concat<type\_list<as...>,       type\_list<bs...>>        \{ \textcolor{keyword}{
      typedef} type\_list<as..., bs...> type; \};
00072 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... as, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... bs>   \textcolor{keyword}{struct }concat<numeric\_list<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, as...>, numeric\_list<
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, bs...> > \{ \textcolor{keyword}{typedef} numeric\_list<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, as..., bs...> type; \};
00073 
00074 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... p> \textcolor{keyword}{struct }mconcat;
00075 \textcolor{keyword}{template}<\textcolor{keyword}{typename} a>                             \textcolor{keyword}{struct }mconcat<a>           \{ \textcolor{keyword}{typedef} a type; \};
00076 \textcolor{keyword}{template}<\textcolor{keyword}{typename} a, \textcolor{keyword}{typename} b>                 \textcolor{keyword}{struct }mconcat<a, b>        : concat<a, b> \{\};
00077 \textcolor{keyword}{template}<\textcolor{keyword}{typename} a, \textcolor{keyword}{typename} b, \textcolor{keyword}{typename}... cs> \textcolor{keyword}{struct }mconcat<a, b, cs...> : concat<a, typename mconcat<b
      , cs...>::type> \{\};
00078 
00079 \textcolor{comment}{/* list manipulation: extract slices */}
00080 
00081 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n, \textcolor{keyword}{typename} x> \textcolor{keyword}{struct }take;
00082 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n, \textcolor{keyword}{typename} a, \textcolor{keyword}{typename}... as> \textcolor{keyword}{struct }take<n, type\_list<a, as...>> : concat<type\_list<a>, type
      name take<n-1, type\_list<as...>>::type> \{\};
00083 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n>                             \textcolor{keyword}{struct }take<n, type\_list<>>         \{ \textcolor{keyword}{typedef} type\_list<> type;
       \};
00084 \textcolor{keyword}{template}<\textcolor{keyword}{typename} a, \textcolor{keyword}{typename}... as>        \textcolor{keyword}{struct }take<0, type\_list<a, as...>> \{ \textcolor{keyword}{typedef} type\_list<> type;
       \};
00085 \textcolor{keyword}{template}<>                                  \textcolor{keyword}{struct }take<0, type\_list<>>         \{ \textcolor{keyword}{typedef} type\_list<> type;
       \};
00086 
00087 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \textcolor{keywordtype}{int} n, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} a, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... as> \textcolor{keyword}{struct }take<n, numeric\_list<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, a, as...>> : concat<numeric\_li
      st<T, a>, typename take<n-1, numeric\_list<T, as...>>::type> \{\};
00088 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} n>               \textcolor{keyword}{struct }take<n, numeric\_list<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}>>           \{ \textcolor{keyword}{typedef} 
      numeric\_list<T> type; \};
00089 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} a, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... as>        \textcolor{keyword}{struct }take<0, numeric\_list<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, a, as...>> \{ \textcolor{keyword}{typedef} 
      numeric\_list<T> type; \};
00090 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>                      \textcolor{keyword}{struct }take<0, numeric\_list<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}>>           \{ \textcolor{keyword}{typedef} 
      numeric\_list<T> type; \};
00091 
00092 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \textcolor{keywordtype}{int} n, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}... ii>      \textcolor{keyword}{struct }h\_skip\_helper\_numeric;
00093 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \textcolor{keywordtype}{int} n, T i, T... ii> \textcolor{keyword}{struct }h\_skip\_helper\_numeric<T, n, i, ii...> : 
      h\_skip\_helper\_numeric<T, n-1, ii...> \{\};
00094 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, T i, T... ii>        \textcolor{keyword}{struct }h\_skip\_helper\_numeric<T, 0, i, ii...> \{ \textcolor{keyword}{typedef} 
      numeric\_list<T, i, ii...> type; \};
00095 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} n>               \textcolor{keyword}{struct }h\_skip\_helper\_numeric<T, n>           \{ \textcolor{keyword}{typedef} 
      numeric\_list<T> type; \};
00096 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>                      \textcolor{keyword}{struct }h\_skip\_helper\_numeric<T, 0>           \{ \textcolor{keyword}{typedef} 
      numeric\_list<T> type; \};
00097 
00098 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n, \textcolor{keyword}{typename}... tt>             \textcolor{keyword}{struct }h\_skip\_helper\_type;
00099 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n, \textcolor{keyword}{typename} t, \textcolor{keyword}{typename}... tt> \textcolor{keyword}{struct }h\_skip\_helper\_type<n, t, tt...> : h\_skip\_helper\_type<n-1
      , tt...> \{\};
00100 \textcolor{keyword}{template}<\textcolor{keyword}{typename} t, \textcolor{keyword}{typename}... tt>        \textcolor{keyword}{struct }h\_skip\_helper\_type<0, t, tt...> \{ \textcolor{keyword}{typedef} type\_list<t, 
      tt...> type; \};
00101 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n>                             \textcolor{keyword}{struct }h\_skip\_helper\_type<n>           \{ \textcolor{keyword}{typedef} type\_list<> 
      type; \};
00102 \textcolor{keyword}{template}<>                                  \textcolor{keyword}{struct }h\_skip\_helper\_type<0>           \{ \textcolor{keyword}{typedef} type\_list<> 
      type; \};
00103 
00104 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n>
00105 \textcolor{keyword}{struct }h\_skip \{
00106   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, T... ii>
00107   constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{typename} h\_skip\_helper\_numeric<T, n, ii...>::type helper(numeric\_list<T, ii...>) 
      \{ \textcolor{keywordflow}{return} \textcolor{keyword}{typename} h\_skip\_helper\_numeric<T, n, ii...>::type(); \}
00108   \textcolor{keyword}{template}<\textcolor{keyword}{typename}... tt>
00109   constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{typename} h\_skip\_helper\_type<n, tt...>::type helper(type\_list<tt...>) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{
      typename} h\_skip\_helper\_type<n, tt...>::type(); \}
00110 \};
00111 
00112 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n, \textcolor{keyword}{typename} a> \textcolor{keyword}{struct }skip \{ \textcolor{keyword}{typedef} decltype(h\_skip<n>::helper(a())) type; \};
00113 
00114 template<\textcolor{keywordtype}{int} start, \textcolor{keywordtype}{int} count, typename a> struct slice : take<count, typename skip<start, a>::type> \{\};
00115 
00116 \textcolor{comment}{/* list manipulation: retrieve single element from list */}
00117 
00118 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n, \textcolor{keyword}{typename} x> \textcolor{keyword}{struct }get;
00119 
00120 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n, \textcolor{keyword}{typename} a, \textcolor{keyword}{typename}... as>               \textcolor{keyword}{struct }get<n, type\_list<a, as...>>   : get<n-1, t
      ype\_list<as...>> \{\};
00121 \textcolor{keyword}{template}<\textcolor{keyword}{typename} a, \textcolor{keyword}{typename}... as>                      \textcolor{keyword}{struct }get<0, type\_list<a, as...>>   \{ \textcolor{keyword}{typedef} a 
      type; \};
00122 
00123 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} n, T a, T... as>                        \textcolor{keyword}{struct }get<n, numeric\_list<T, a, as...>>  
       : get<n-1, numeric\_list<T, as...>> \{\};
00124 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, T a, T... as>                               \textcolor{keyword}{struct }get<0, numeric\_list<T, a, as...>>  
       \{ constexpr \textcolor{keyword}{static} T value = a; \};
00125 
00126 \textcolor{comment}{/* always get type, regardless of dummy; good for parameter pack expansion */}
00127 
00128 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, T dummy, \textcolor{keyword}{typename} t> \textcolor{keyword}{struct }id\_numeric  \{ \textcolor{keyword}{typedef} t type; \};
00129 \textcolor{keyword}{template}<\textcolor{keyword}{typename} dummy, \textcolor{keyword}{typename} t>      \textcolor{keyword}{struct }id\_type     \{ \textcolor{keyword}{typedef} t type; \};
00130 
00131 \textcolor{comment}{/* equality checking, flagged version */}
00132 
00133 \textcolor{keyword}{template}<\textcolor{keyword}{typename} a, \textcolor{keyword}{typename} b> \textcolor{keyword}{struct }is\_same\_gf : is\_same<a, b> \{ constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} global\_flags = 0;
       \};
00134 
00135 \textcolor{comment}{/* apply\_op to list */}
00136 
00137 \textcolor{keyword}{template}<
00138   \textcolor{keywordtype}{bool} from\_left, \textcolor{comment}{// false}
00139   \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{class }op,
00140   \textcolor{keyword}{typename} additional\_param,
00141   \textcolor{keyword}{typename}... values
00142 >
00143 \textcolor{keyword}{struct }h\_apply\_op\_helper                                        \{ \textcolor{keyword}{typedef} type\_list<typename op<values,
       additional\_param>::type...> type; \};
00144 \textcolor{keyword}{template}<
00145   \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{class }op,
00146   \textcolor{keyword}{typename} additional\_param,
00147   \textcolor{keyword}{typename}... values
00148 >
00149 \textcolor{keyword}{struct }h\_apply\_op\_helper<true, op, additional\_param, values...> \{ \textcolor{keyword}{typedef} type\_list<typename
       op<additional\_param, values>::type...> type; \};
00150 
00151 \textcolor{keyword}{template}<
00152   \textcolor{keywordtype}{bool} from\_left,
00153   \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{class }op,
00154   \textcolor{keyword}{typename} additional\_param
00155 >
00156 \textcolor{keyword}{struct }h\_apply\_op
00157 \{
00158   \textcolor{keyword}{template}<\textcolor{keyword}{typename}... values>
00159   constexpr \textcolor{keyword}{static} \textcolor{keyword}{typename} h\_apply\_op\_helper<from\_left, op, additional\_param, values...>::type helper(
      type\_list<values...>)
00160   \{ \textcolor{keywordflow}{return} \textcolor{keyword}{typename} h\_apply\_op\_helper<from\_left, op, additional\_param, values...>::type(); \}
00161 \};
00162 
00163 \textcolor{keyword}{template}<
00164   \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{class }op,
00165   \textcolor{keyword}{typename} additional\_param,
00166   \textcolor{keyword}{typename} a
00167 >
00168 \textcolor{keyword}{struct }apply\_op\_from\_left \{ \textcolor{keyword}{typedef} decltype(h\_apply\_op<true, op, additional\_param>::helper(a())) type; \};
00169 
00170 template<
00171   template<typename, typename> class op,
00172   typename additional\_param,
00173   typename a
00174 >
00175 struct apply\_op\_from\_right \{ \textcolor{keyword}{typedef} decltype(h\_apply\_op<false, op, additional\_param>::helper(a())) type; \}
      ;
00176 
00177 \textcolor{comment}{/* see if an element is in a list */}
00178 
00179 template<
00180   template<typename, typename> class test,
00181   typename check\_against,
00182   typename h\_list,
00183   \textcolor{keywordtype}{bool} last\_check\_positive = false
00184 >
00185 struct contained\_in\_list;
00186 
00187 template<
00188   template<typename, typename> class test,
00189   typename check\_against,
00190   typename h\_list
00191 >
00192 struct contained\_in\_list<test, check\_against, h\_list, true>
00193 \{
00194   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{true};
00195 \};
00196 
00197 \textcolor{keyword}{template}<
00198   \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{class }test,
00199   \textcolor{keyword}{typename} check\_against,
00200   \textcolor{keyword}{typename} a,
00201   \textcolor{keyword}{typename}... as
00202 >
00203 \textcolor{keyword}{struct }contained\_in\_list<test, check\_against, type\_list<a, as...>, false> : contained\_in\_list<test, check\_a
      gainst, type\_list<as...>, test<check\_against, a>::value> \{\};
00204 
00205 \textcolor{keyword}{template}<
00206   \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{class }test,
00207   \textcolor{keyword}{typename} check\_against
00208   EIGEN\_TPL\_PP\_SPEC\_HACK\_DEFC(\textcolor{keyword}{typename}, empty)
00209 >
00210 \textcolor{keyword}{struct }contained\_in\_list<test, check\_against, type\_list<EIGEN\_TPL\_PP\_SPEC\_HACK\_USE(empty)>, false> \{ 
      constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false}; \};
00211 
00212 \textcolor{comment}{/* see if an element is in a list and check for global flags */}
00213 
00214 \textcolor{keyword}{template}<
00215   \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{class }test,
00216   \textcolor{keyword}{typename} check\_against,
00217   \textcolor{keyword}{typename} h\_list,
00218   \textcolor{keywordtype}{int} default\_flags = 0,
00219   \textcolor{keywordtype}{bool} last\_check\_positive = \textcolor{keyword}{false},
00220   \textcolor{keywordtype}{int} last\_check\_flags = default\_flags
00221 >
00222 \textcolor{keyword}{struct }contained\_in\_list\_gf;
00223 
00224 \textcolor{keyword}{template}<
00225   \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{class }test,
00226   \textcolor{keyword}{typename} check\_against,
00227   \textcolor{keyword}{typename} h\_list,
00228   \textcolor{keywordtype}{int} default\_flags,
00229   \textcolor{keywordtype}{int} last\_check\_flags
00230 >
00231 \textcolor{keyword}{struct }contained\_in\_list\_gf<test, check\_against, h\_list, default\_flags, true, last\_check\_flags>
00232 \{
00233   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{true};
00234   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} global\_flags = last\_check\_flags;
00235 \};
00236 
00237 \textcolor{keyword}{template}<
00238   \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{class }test,
00239   \textcolor{keyword}{typename} check\_against,
00240   \textcolor{keyword}{typename} a,
00241   \textcolor{keyword}{typename}... as,
00242   \textcolor{keywordtype}{int} default\_flags,
00243   \textcolor{keywordtype}{int} last\_check\_flags
00244 >
00245 \textcolor{keyword}{struct }contained\_in\_list\_gf<test, check\_against, type\_list<a, as...>, default\_flags, false, 
      last\_check\_flags> : contained\_in\_list\_gf<test, check\_against, type\_list<as...>, default\_flags, test<check\_against, a>::valu
      e, test<check\_against, a>::global\_flags> \{\};
00246 
00247 \textcolor{keyword}{template}<
00248   \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{class }test,
00249   \textcolor{keyword}{typename} check\_against
00250   EIGEN\_TPL\_PP\_SPEC\_HACK\_DEFC(\textcolor{keyword}{typename}, empty),
00251   \textcolor{keywordtype}{int} default\_flags,
00252   \textcolor{keywordtype}{int} last\_check\_flags
00253 >
00254 \textcolor{keyword}{struct }contained\_in\_list\_gf<test, check\_against, type\_list<EIGEN\_TPL\_PP\_SPEC\_HACK\_USE(empty)>, 
      default\_flags, false, last\_check\_flags> \{ constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false}; constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} global\_flags = 
      default\_flags; \};
00255 
00256 \textcolor{comment}{/* generic reductions */}
00257 
00258 \textcolor{keyword}{template}<
00259   \textcolor{keyword}{typename} Reducer,
00260   \textcolor{keyword}{typename}... Ts
00261 > \textcolor{keyword}{struct }reduce;
00262 
00263 \textcolor{keyword}{template}<
00264   \textcolor{keyword}{typename} Reducer
00265 > \textcolor{keyword}{struct }reduce<Reducer>
00266 \{
00267   constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} run() \{ \textcolor{keywordflow}{return} Reducer::Identity; \}
00268 \};
00269 
00270 \textcolor{keyword}{template}<
00271   \textcolor{keyword}{typename} Reducer,
00272   \textcolor{keyword}{typename} A
00273 > \textcolor{keyword}{struct }reduce<Reducer, A>
00274 \{
00275   constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} A run(A a) \{ \textcolor{keywordflow}{return} a; \}
00276 \};
00277 
00278 \textcolor{keyword}{template}<
00279   \textcolor{keyword}{typename} Reducer,
00280   \textcolor{keyword}{typename} A,
00281   \textcolor{keyword}{typename}... Ts
00282 > \textcolor{keyword}{struct }reduce<Reducer, A, Ts...>
00283 \{
00284   constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a, Ts... ts) -> decltype(Reducer::run(a, reduce<Reducer, Ts...>::run(
      ts...))) \{
00285     \textcolor{keywordflow}{return} Reducer::run(a, reduce<Reducer, Ts...>::run(ts...));
00286   \}
00287 \};
00288 
00289 \textcolor{comment}{/* generic binary operations */}
00290 
00291 \textcolor{keyword}{struct }sum\_op           \{
00292   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> EIGEN\_DEVICE\_FUNC constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a, B b) -> decltype
      (a + b)   \{ \textcolor{keywordflow}{return} a + b;   \}
00293   \textcolor{keyword}{static} constexpr \textcolor{keywordtype}{int} Identity = 0;
00294 \};
00295 \textcolor{keyword}{struct }product\_op       \{
00296   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> EIGEN\_DEVICE\_FUNC constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a, B b) -> decltype
      (a * b)   \{ \textcolor{keywordflow}{return} a * b;   \}
00297   \textcolor{keyword}{static} constexpr \textcolor{keywordtype}{int} Identity = 1;
00298 \};
00299 
00300 \textcolor{keyword}{struct }logical\_and\_op   \{ \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a, B b) -> 
      decltype(a && b)  \{ \textcolor{keywordflow}{return} a && b;  \} \};
00301 \textcolor{keyword}{struct }logical\_or\_op    \{ \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a, B b) -> 
      decltype(a || b)  \{ \textcolor{keywordflow}{return} a || b;  \} \};
00302 
00303 \textcolor{keyword}{struct }equal\_op         \{ \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a, B b) -> 
      decltype(a == b)  \{ \textcolor{keywordflow}{return} a == b;  \} \};
00304 \textcolor{keyword}{struct }not\_equal\_op     \{ \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a, B b) -> 
      decltype(a != b)  \{ \textcolor{keywordflow}{return} a != b;  \} \};
00305 \textcolor{keyword}{struct }lesser\_op        \{ \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a, B b) -> 
      decltype(a < b)   \{ \textcolor{keywordflow}{return} a < b;   \} \};
00306 \textcolor{keyword}{struct }lesser\_equal\_op  \{ \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a, B b) -> 
      decltype(a <= b)  \{ \textcolor{keywordflow}{return} a <= b;  \} \};
00307 \textcolor{keyword}{struct }greater\_op       \{ \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a, B b) -> 
      decltype(a > b)   \{ \textcolor{keywordflow}{return} a > b;   \} \};
00308 \textcolor{keyword}{struct }greater\_equal\_op \{ \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a, B b) -> 
      decltype(a >= b)  \{ \textcolor{keywordflow}{return} a >= b;  \} \};
00309 
00310 \textcolor{comment}{/* generic unary operations */}
00311 
00312 \textcolor{keyword}{struct }not\_op                \{ \textcolor{keyword}{template}<\textcolor{keyword}{typename} A> constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a) -> decltype(!a)  
          \{ \textcolor{keywordflow}{return} !a;      \} \};
00313 \textcolor{keyword}{struct }negation\_op           \{ \textcolor{keyword}{template}<\textcolor{keyword}{typename} A> constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a) -> decltype(-a)  
          \{ \textcolor{keywordflow}{return} -a;      \} \};
00314 \textcolor{keyword}{struct }greater\_equal\_zero\_op \{ \textcolor{keyword}{template}<\textcolor{keyword}{typename} A> constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(A a) -> decltype(a >= 
      0)  \{ \textcolor{keywordflow}{return} a >= 0;  \} \};
00315 
00316 
00317 \textcolor{comment}{/* reductions for lists */}
00318 
00319 \textcolor{comment}{// using auto -> return value spec makes ICC 13.0 and 13.1 crash here, so we have to hack it}
00320 \textcolor{comment}{// together in front... (13.0 doesn't work with array\_prod/array\_reduce/... anyway, but 13.1}
00321 \textcolor{comment}{// does...}
00322 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Ts>
00323 constexpr \textcolor{keyword}{inline} decltype(reduce<product\_op, Ts...>::run((*((Ts*)0))...)) arg\_prod(Ts... ts)
00324 \{
00325   \textcolor{keywordflow}{return} reduce<product\_op, Ts...>::run(ts...);
00326 \}
00327 
00328 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Ts>
00329 constexpr \textcolor{keyword}{inline} decltype(reduce<sum\_op, Ts...>::run((*((Ts*)0))...)) arg\_sum(Ts... ts)
00330 \{
00331   \textcolor{keywordflow}{return} reduce<sum\_op, Ts...>::run(ts...);
00332 \}
00333 
00334 \textcolor{comment}{/* reverse arrays */}
00335 
00336 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Array, \textcolor{keywordtype}{int}... n>
00337 constexpr \textcolor{keyword}{inline} Array h\_array\_reverse(Array arr, numeric\_list<int, n...>)
00338 \{
00339   \textcolor{keywordflow}{return} \{\{array\_get<\textcolor{keyword}{sizeof}...(n) - n - 1>(arr)...\}\};
00340 \}
00341 
00342 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>
00343 constexpr \textcolor{keyword}{inline} array<T, N> array\_reverse(array<T, N> arr)
00344 \{
00345   \textcolor{keywordflow}{return} h\_array\_reverse(arr, \textcolor{keyword}{typename} gen\_numeric\_list<int, N>::type());
00346 \}
00347 
00348 
00349 \textcolor{comment}{/* generic array reductions */}
00350 
00351 \textcolor{comment}{// can't reuse standard reduce() interface above because Intel's Compiler}
00352 \textcolor{comment}{// *really* doesn't like it, so we just reimplement the stuff}
00353 \textcolor{comment}{// (start from N - 1 and work down to 0 because specialization for}
00354 \textcolor{comment}{// n == N - 1 also doesn't work in Intel's compiler, so it goes into}
00355 \textcolor{comment}{// an infinite loop)}
00356 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} T, std::size\_t N, std::size\_t n = N - 1>
00357 \textcolor{keyword}{struct }h\_array\_reduce \{
00358   EIGEN\_DEVICE\_FUNC constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{auto} run(array<T, N> arr, T identity) -> decltype(Reducer::run(
      h\_array\_reduce<Reducer, T, N, n - 1>::run(arr, identity), array\_get<n>(arr)))
00359   \{
00360     \textcolor{keywordflow}{return} Reducer::run(h\_array\_reduce<Reducer, T, N, n - 1>::run(arr, identity), array\_get<n>(arr));
00361   \}
00362 \};
00363 
00364 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>
00365 \textcolor{keyword}{struct }h\_array\_reduce<Reducer, T, N, 0>
00366 \{
00367   EIGEN\_DEVICE\_FUNC constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} T run(\textcolor{keyword}{const} array<T, N>& arr, T)
00368   \{
00369     \textcolor{keywordflow}{return} array\_get<0>(arr);
00370   \}
00371 \};
00372 
00373 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} T>
00374 \textcolor{keyword}{struct }h\_array\_reduce<Reducer, T, 0>
00375 \{
00376   EIGEN\_DEVICE\_FUNC constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} T run(\textcolor{keyword}{const} array<T, 0>&, T identity)
00377   \{
00378     \textcolor{keywordflow}{return} identity;
00379   \}
00380 \};
00381 
00382 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>
00383 EIGEN\_DEVICE\_FUNC constexpr \textcolor{keyword}{inline} \textcolor{keyword}{auto} array\_reduce(\textcolor{keyword}{const} array<T, N>& arr, T identity) -> decltype(
      h\_array\_reduce<Reducer, T, N>::run(arr, identity))
00384 \{
00385   \textcolor{keywordflow}{return} h\_array\_reduce<Reducer, T, N>::run(arr, identity);
00386 \}
00387 
00388 \textcolor{comment}{/* standard array reductions */}
00389 
00390 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>
00391 EIGEN\_DEVICE\_FUNC constexpr \textcolor{keyword}{inline} \textcolor{keyword}{auto} array\_sum(\textcolor{keyword}{const} array<T, N>& arr) -> decltype(array\_reduce<sum\_op,
       T, N>(arr, static\_cast<T>(0)))
00392 \{
00393   \textcolor{keywordflow}{return} array\_reduce<sum\_op, T, N>(arr, \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(0));
00394 \}
00395 
00396 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>
00397 EIGEN\_DEVICE\_FUNC constexpr \textcolor{keyword}{inline} \textcolor{keyword}{auto} array\_prod(\textcolor{keyword}{const} array<T, N>& arr) -> decltype(
      array\_reduce<product\_op, T, N>(arr, static\_cast<T>(1)))
00398 \{
00399   \textcolor{keywordflow}{return} array\_reduce<product\_op, T, N>(arr, \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(1));
00400 \}
00401 
00402 \textcolor{keyword}{template}<\textcolor{keyword}{typename} t>
00403 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE t array\_prod(\textcolor{keyword}{const} std::vector<t>& a) \{
00404   eigen\_assert(a.size() > 0);
00405   t prod = 1;
00406   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < a.size(); ++i) \{ prod *= a[i]; \}
00407   \textcolor{keywordflow}{return} prod;
00408 \}
00409 
00410 \textcolor{comment}{/* zip an array */}
00411 
00412 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B, std::size\_t N, \textcolor{keywordtype}{int}... n>
00413 constexpr \textcolor{keyword}{inline} array<decltype(Op::run(A(), B())),N> h\_array\_zip(array<A, N> a, array<B, N> b, 
      numeric\_list<int, n...>)
00414 \{
00415   \textcolor{keywordflow}{return} array<decltype(Op::run(A(), B())),N>\{\{ Op::run(array\_get<n>(a), array\_get<n>(b))... \}\};
00416 \}
00417 
00418 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B, std::\textcolor{keywordtype}{size\_t} N>
00419 constexpr \textcolor{keyword}{inline} array<decltype(Op::run(A(), B())),N> array\_zip(array<A, N> a, array<B, N> b)
00420 \{
00421   \textcolor{keywordflow}{return} h\_array\_zip<Op>(a, b, \textcolor{keyword}{typename} gen\_numeric\_list<int, N>::type());
00422 \}
00423 
00424 \textcolor{comment}{/* zip an array and reduce the result */}
00425 
00426 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B, std::size\_t N, \textcolor{keywordtype}{int}... n>
00427 constexpr \textcolor{keyword}{inline} \textcolor{keyword}{auto} h\_array\_zip\_and\_reduce(array<A, N> a, array<B, N> b, numeric\_list<int, n...>) -> 
      decltype(reduce<Reducer, \textcolor{keyword}{typename} id\_numeric<\textcolor{keywordtype}{int},n,decltype(Op::run(A(), B()))>::type...>::run(Op::run(
      array\_get<n>(a), array\_get<n>(b))...))
00428 \{
00429   \textcolor{keywordflow}{return} reduce<Reducer, typename id\_numeric<int,n,decltype(Op::run(A(), B()))>::type...>::run(Op::run(
      array\_get<n>(a), array\_get<n>(b))...);
00430 \}
00431 
00432 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B, std::\textcolor{keywordtype}{size\_t} N>
00433 constexpr \textcolor{keyword}{inline} \textcolor{keyword}{auto} array\_zip\_and\_reduce(array<A, N> a, array<B, N> b) -> decltype(
      h\_array\_zip\_and\_reduce<Reducer, Op, A, B, N>(a, b, \textcolor{keyword}{typename} gen\_numeric\_list<int, N>::type()))
00434 \{
00435   \textcolor{keywordflow}{return} h\_array\_zip\_and\_reduce<Reducer, Op, A, B, N>(a, b, \textcolor{keyword}{typename} gen\_numeric\_list<int, N>::type());
00436 \}
00437 
00438 \textcolor{comment}{/* apply stuff to an array */}
00439 
00440 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, std::size\_t N, \textcolor{keywordtype}{int}... n>
00441 constexpr \textcolor{keyword}{inline} array<decltype(Op::run(A())),N> h\_array\_apply(array<A, N> a, numeric\_list<int, n...>)
00442 \{
00443   \textcolor{keywordflow}{return} array<decltype(Op::run(A())),N>\{\{ Op::run(array\_get<n>(a))... \}\};
00444 \}
00445 
00446 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, std::\textcolor{keywordtype}{size\_t} N>
00447 constexpr \textcolor{keyword}{inline} array<decltype(Op::run(A())),N> array\_apply(array<A, N> a)
00448 \{
00449   \textcolor{keywordflow}{return} h\_array\_apply<Op>(a, \textcolor{keyword}{typename} gen\_numeric\_list<int, N>::type());
00450 \}
00451 
00452 \textcolor{comment}{/* apply stuff to an array and reduce */}
00453 
00454 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, std::size\_t N, \textcolor{keywordtype}{int}... n>
00455 constexpr \textcolor{keyword}{inline} \textcolor{keyword}{auto} h\_array\_apply\_and\_reduce(array<A, N> arr, numeric\_list<int, n...>) -> decltype(reduce
      <Reducer, \textcolor{keyword}{typename} id\_numeric<\textcolor{keywordtype}{int},n,decltype(Op::run(A()))>::type...>::run(Op::run(array\_get<n>(arr))...))
00456 \{
00457   \textcolor{keywordflow}{return} reduce<Reducer, typename id\_numeric<int,n,decltype(Op::run(A()))>::type...>::run(Op::run(
      array\_get<n>(arr))...);
00458 \}
00459 
00460 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, std::\textcolor{keywordtype}{size\_t} N>
00461 constexpr \textcolor{keyword}{inline} \textcolor{keyword}{auto} array\_apply\_and\_reduce(array<A, N> a) -> decltype(h\_array\_apply\_and\_reduce<Reducer,
       Op, A, N>(a, \textcolor{keyword}{typename} gen\_numeric\_list<int, N>::type()))
00462 \{
00463   \textcolor{keywordflow}{return} h\_array\_apply\_and\_reduce<Reducer, Op, A, N>(a, \textcolor{keyword}{typename} gen\_numeric\_list<int, N>::type());
00464 \}
00465 
00466 \textcolor{comment}{/* repeat a value n times (and make an array out of it}
00467 \textcolor{comment}{ * usage:}
00468 \textcolor{comment}{ *   array<int, 16> = repeat<16>(42);}
00469 \textcolor{comment}{ */}
00470 
00471 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n>
00472 \textcolor{keyword}{struct }h\_repeat
00473 \{
00474   \textcolor{keyword}{template}<\textcolor{keyword}{typename} t, \textcolor{keywordtype}{int}... ii>
00475   constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} array<t, n> run(t v, numeric\_list<int, ii...>)
00476   \{
00477     \textcolor{keywordflow}{return} \{\{ \textcolor{keyword}{typename} id\_numeric<int, ii, t>::type(v)... \}\};
00478   \}
00479 \};
00480 
00481 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n, \textcolor{keyword}{typename} t>
00482 constexpr array<t, n> repeat(t v) \{ \textcolor{keywordflow}{return} h\_repeat<n>::run(v, \textcolor{keyword}{typename} gen\_numeric\_list<int, n>::type()); 
      \}
00483 
00484 \textcolor{comment}{/* instantiate a class by a C-style array */}
00485 \textcolor{keyword}{template}<\textcolor{keyword}{class }InstType, \textcolor{keyword}{typename} ArrType, std::size\_t N, \textcolor{keywordtype}{bool} Reverse, \textcolor{keyword}{typename}... Ps>
00486 \textcolor{keyword}{struct }h\_instantiate\_by\_c\_array;
00487 
00488 \textcolor{keyword}{template}<\textcolor{keyword}{class }InstType, \textcolor{keyword}{typename} ArrType, std::size\_t N, \textcolor{keyword}{typename}... Ps>
00489 \textcolor{keyword}{struct }h\_instantiate\_by\_c\_array<InstType, ArrType, N, false, Ps...>
00490 \{
00491   \textcolor{keyword}{static} InstType run(ArrType* arr, Ps... args)
00492   \{
00493     \textcolor{keywordflow}{return} h\_instantiate\_by\_c\_array<InstType, ArrType, N - 1, false, Ps..., ArrType>::run(arr + 1, args...,
       arr[0]);
00494   \}
00495 \};
00496 
00497 \textcolor{keyword}{template}<\textcolor{keyword}{class }InstType, \textcolor{keyword}{typename} ArrType, std::size\_t N, \textcolor{keyword}{typename}... Ps>
00498 \textcolor{keyword}{struct }h\_instantiate\_by\_c\_array<InstType, ArrType, N, true, Ps...>
00499 \{
00500   \textcolor{keyword}{static} InstType run(ArrType* arr, Ps... args)
00501   \{
00502     \textcolor{keywordflow}{return} h\_instantiate\_by\_c\_array<InstType, ArrType, N - 1, false, ArrType, Ps...>::run(arr + 1, arr[0], 
      args...);
00503   \}
00504 \};
00505 
00506 \textcolor{keyword}{template}<\textcolor{keyword}{class }InstType, \textcolor{keyword}{typename} ArrType, \textcolor{keyword}{typename}... Ps>
00507 \textcolor{keyword}{struct }h\_instantiate\_by\_c\_array<InstType, ArrType, 0, false, Ps...>
00508 \{
00509   \textcolor{keyword}{static} InstType run(ArrType* arr, Ps... args)
00510   \{
00511     (void)arr;
00512     \textcolor{keywordflow}{return} InstType(args...);
00513   \}
00514 \};
00515 
00516 \textcolor{keyword}{template}<\textcolor{keyword}{class }InstType, \textcolor{keyword}{typename} ArrType, \textcolor{keyword}{typename}... Ps>
00517 \textcolor{keyword}{struct }h\_instantiate\_by\_c\_array<InstType, ArrType, 0, true, Ps...>
00518 \{
00519   \textcolor{keyword}{static} InstType run(ArrType* arr, Ps... args)
00520   \{
00521     (void)arr;
00522     \textcolor{keywordflow}{return} InstType(args...);
00523   \}
00524 \};
00525 
00526 \textcolor{keyword}{template}<\textcolor{keyword}{class} InstType, \textcolor{keyword}{typename} ArrType, std::\textcolor{keywordtype}{size\_t} N, \textcolor{keywordtype}{bool} Reverse = false>
00527 InstType instantiate\_by\_c\_array(ArrType* arr)
00528 \{
00529   \textcolor{keywordflow}{return} h\_instantiate\_by\_c\_array<InstType, ArrType, N, Reverse>::run(arr);
00530 \}
00531 
00532 \} \textcolor{comment}{// end namespace internal}
00533 
00534 \} \textcolor{comment}{// end namespace Eigen}
00535 
00536 \textcolor{preprocessor}{#else // Non C++11, fallback to emulation mode}
00537 
00538 \textcolor{preprocessor}{#include "EmulateCXX11Meta.h"}
00539 
00540 \textcolor{preprocessor}{#endif}
00541 
00542 \textcolor{preprocessor}{#endif // EIGEN\_CXX11META\_H}
\end{DoxyCode}
