\hypertarget{eigen_2_eigen_2src_2_core_2arch_2_c_u_d_a_2_complex_8h_source}{}\section{eigen/\+Eigen/src/\+Core/arch/\+C\+U\+D\+A/\+Complex.h}
\label{eigen_2_eigen_2src_2_core_2arch_2_c_u_d_a_2_complex_8h_source}\index{Complex.\+h@{Complex.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_COMPLEX\_CUDA\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_COMPLEX\_CUDA\_H}
00012 
00013 \textcolor{comment}{// clang-format off}
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00016 
00017 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00018 
00019 \textcolor{preprocessor}{#if defined(\_\_CUDACC\_\_) && defined(EIGEN\_USE\_GPU)}
00020 
00021 \textcolor{comment}{// Many std::complex methods such as operator+, operator-, operator* and}
00022 \textcolor{comment}{// operator/ are not constexpr. Due to this, clang does not treat them as device}
00023 \textcolor{comment}{// functions and thus Eigen functors making use of these operators fail to}
00024 \textcolor{comment}{// compile. Here, we manually specialize these functors for complex types when}
00025 \textcolor{comment}{// building for CUDA to avoid non-constexpr methods.}
00026 
00027 \textcolor{comment}{// Sum}
00028 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }scalar\_sum\_op<const \hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<T>, const std::complex<T> > : 
      binary\_op\_base<const std::complex<T>, const std::complex<T> > \{
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> result\_type;
00030 
00031   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_sum\_op)
00032   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE std::complex<T> operator() (\textcolor{keyword}{const} std::complex<T>& a, \textcolor{keyword}{const} 
      std::complex<T>& b)\textcolor{keyword}{ const }\{
00033     \textcolor{keywordflow}{return} std::complex<T>(numext::real(a) + numext::real(b),
00034                            numext::imag(a) + numext::imag(b));
00035   \}
00036 \};
00037 
00038 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }scalar\_sum\_op<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<T>, std::complex<T> > : scalar\_sum\_op<cons
      t std::complex<T>, const std::complex<T> > \{\};
00039 
00040 
00041 \textcolor{comment}{// Difference}
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }scalar\_difference\_op<const std::\hyperlink{structcomplex}{complex}<T>, const std::complex<T> >  : 
      binary\_op\_base<const std::complex<T>, const std::complex<T> > \{
00043   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> result\_type;
00044 
00045   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_difference\_op)
00046   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE std::complex<T> operator() (\textcolor{keyword}{const} std::complex<T>& a, \textcolor{keyword}{const} 
      std::complex<T>& b)\textcolor{keyword}{ const }\{
00047     \textcolor{keywordflow}{return} std::complex<T>(numext::real(a) - numext::real(b),
00048                            numext::imag(a) - numext::imag(b));
00049   \}
00050 \};
00051 
00052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }scalar\_difference\_op<std::\hyperlink{structcomplex}{complex}<T>, std::complex<T> > : 
      scalar\_difference\_op<const std::complex<T>, const std::complex<T> > \{\};
00053 
00054 
00055 \textcolor{comment}{// Product}
00056 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }scalar\_product\_op<const std::\hyperlink{structcomplex}{complex}<T>, const std::complex<T> >  : 
      binary\_op\_base<const std::complex<T>, const std::complex<T> > \{
00057   \textcolor{keyword}{enum} \{
00058     Vectorizable = packet\_traits<std::complex<T>>::HasMul
00059   \};
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> result\_type;
00061 
00062   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_product\_op)
00063   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE std::complex<T> operator() (\textcolor{keyword}{const} std::complex<T>& a, \textcolor{keyword}{const} 
      std::complex<T>& b)\textcolor{keyword}{ const }\{
00064     \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} a\_real = numext::real(a);
00065     \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} a\_imag = numext::imag(a);
00066     \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} b\_real = numext::real(b);
00067     \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} b\_imag = numext::imag(b);
00068     \textcolor{keywordflow}{return} std::complex<T>(a\_real * b\_real - a\_imag * b\_imag,
00069                            a\_real * b\_imag + a\_imag * b\_real);
00070   \}
00071 \};
00072 
00073 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }scalar\_product\_op<std::\hyperlink{structcomplex}{complex}<T>, std::complex<T> > : scalar\_product\_op
      <const std::complex<T>, const std::complex<T> > \{\};
00074 
00075 
00076 \textcolor{comment}{// Quotient}
00077 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }scalar\_quotient\_op<const std::\hyperlink{structcomplex}{complex}<T>, const std::complex<T> > : 
      binary\_op\_base<const std::complex<T>, const std::complex<T> > \{
00078   \textcolor{keyword}{enum} \{
00079     Vectorizable = packet\_traits<std::complex<T>>::HasDiv
00080   \};
00081   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<T> result\_type;
00082 
00083   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_quotient\_op)
00084   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE std::complex<T> operator() (\textcolor{keyword}{const} std::complex<T>& a, \textcolor{keyword}{const} 
      std::complex<T>& b)\textcolor{keyword}{ const }\{
00085     \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} a\_real = numext::real(a);
00086     \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} a\_imag = numext::imag(a);
00087     \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} b\_real = numext::real(b);
00088     \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} b\_imag = numext::imag(b);
00089     \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} norm = \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}(1) / (b\_real * b\_real + b\_imag * b\_imag);
00090     \textcolor{keywordflow}{return} std::complex<T>((a\_real * b\_real + a\_imag * b\_imag) * norm,
00091                            (a\_imag * b\_real - a\_real * b\_imag) * norm);
00092   \}
00093 \};
00094 
00095 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }scalar\_quotient\_op<std::\hyperlink{structcomplex}{complex}<T>, std::complex<T> > : 
      scalar\_quotient\_op<const std::complex<T>, const std::complex<T> > \{\};
00096 
00097 \textcolor{preprocessor}{#endif}
00098 
00099 \} \textcolor{comment}{// end namespace internal}
00100 
00101 \} \textcolor{comment}{// end namespace Eigen}
00102 
00103 \textcolor{preprocessor}{#endif // EIGEN\_COMPLEX\_CUDA\_H}
\end{DoxyCode}
