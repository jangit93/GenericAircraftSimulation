\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_cholmod_support_2_cholmod_support_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Cholmod\+Support/\+Cholmod\+Support.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_cholmod_support_2_cholmod_support_8h_source}\index{Cholmod\+Support.\+h@{Cholmod\+Support.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CHOLMODSUPPORT\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CHOLMODSUPPORT\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }cholmod\_configure\_matrix;
00018 
00019 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }cholmod\_configure\_matrix<double> \{
00020   \textcolor{keyword}{template}<\textcolor{keyword}{typename} CholmodType>
00021   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(CholmodType& mat) \{
00022     mat.xtype = CHOLMOD\_REAL;
00023     mat.dtype = CHOLMOD\_DOUBLE;
00024   \}
00025 \};
00026 
00027 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }cholmod\_configure\_matrix<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<double> > \{
00028   \textcolor{keyword}{template}<\textcolor{keyword}{typename} CholmodType>
00029   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(CholmodType& mat) \{
00030     mat.xtype = CHOLMOD\_COMPLEX;
00031     mat.dtype = CHOLMOD\_DOUBLE;
00032   \}
00033 \};
00034 
00035 \textcolor{comment}{// Other scalar types are not yet suppotred by Cholmod}
00036 \textcolor{comment}{// template<> struct cholmod\_configure\_matrix<float> \{}
00037 \textcolor{comment}{//   template<typename CholmodType>}
00038 \textcolor{comment}{//   static void run(CholmodType& mat) \{}
00039 \textcolor{comment}{//     mat.xtype = CHOLMOD\_REAL;}
00040 \textcolor{comment}{//     mat.dtype = CHOLMOD\_SINGLE;}
00041 \textcolor{comment}{//   \}}
00042 \textcolor{comment}{// \};}
00043 \textcolor{comment}{//}
00044 \textcolor{comment}{// template<> struct cholmod\_configure\_matrix<std::complex<float> > \{}
00045 \textcolor{comment}{//   template<typename CholmodType>}
00046 \textcolor{comment}{//   static void run(CholmodType& mat) \{}
00047 \textcolor{comment}{//     mat.xtype = CHOLMOD\_COMPLEX;}
00048 \textcolor{comment}{//     mat.dtype = CHOLMOD\_SINGLE;}
00049 \textcolor{comment}{//   \}}
00050 \textcolor{comment}{// \};}
00051 
00052 \} \textcolor{comment}{// namespace internal}
00053 
00057 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex>
00058 cholmod\_sparse \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(Ref<SparseMatrix<\_Scalar,\_Options,\_StorageIndex> > mat)
00059 \{
00060   cholmod\_sparse res;
00061   res.nzmax   = mat.nonZeros();
00062   res.nrow    = mat.rows();
00063   res.ncol    = mat.cols();
00064   res.p       = mat.outerIndexPtr();
00065   res.i       = mat.innerIndexPtr();
00066   res.x       = mat.valuePtr();
00067   res.z       = 0;
00068   res.sorted  = 1;
00069   \textcolor{keywordflow}{if}(mat.isCompressed())
00070   \{
00071     res.packed  = 1;
00072     res.nz = 0;
00073   \}
00074   \textcolor{keywordflow}{else}
00075   \{
00076     res.packed  = 0;
00077     res.nz = mat.innerNonZeroPtr();
00078   \}
00079 
00080   res.dtype   = 0;
00081   res.stype   = -1;
00082   
00083   \textcolor{keywordflow}{if} (internal::is\_same<\_StorageIndex,int>::value)
00084   \{
00085     res.itype = CHOLMOD\_INT;
00086   \}
00087   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (internal::is\_same<\_StorageIndex,long>::value)
00088   \{
00089     res.itype = CHOLMOD\_LONG;
00090   \}
00091   \textcolor{keywordflow}{else}
00092   \{
00093     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Index type not supported yet"});
00094   \}
00095 
00096   \textcolor{comment}{// setup res.xtype}
00097   internal::cholmod\_configure\_matrix<\_Scalar>::run(res);
00098   
00099   res.stype = 0;
00100   
00101   \textcolor{keywordflow}{return} res;
00102 \}
00103 
00104 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_Index>
00105 \textcolor{keyword}{const} cholmod\_sparse \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(\textcolor{keyword}{const} SparseMatrix<\_Scalar,\_Options,\_Index>& mat)
00106 \{
00107   cholmod\_sparse res = \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(Ref<SparseMatrix<\_Scalar,\_Options,\_Index> >(mat.
      const\_cast\_derived()));
00108   \textcolor{keywordflow}{return} res;
00109 \}
00110 
00111 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_Index>
00112 \textcolor{keyword}{const} cholmod\_sparse \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(\textcolor{keyword}{const} SparseVector<\_Scalar,\_Options,\_Index>& mat)
00113 \{
00114   cholmod\_sparse res = \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(Ref<SparseMatrix<\_Scalar,\_Options,\_Index> >(mat.
      const\_cast\_derived()));
00115   \textcolor{keywordflow}{return} res;
00116 \}
00117 
00120 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_Index, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} UpLo>
00121 cholmod\_sparse \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(\textcolor{keyword}{const} SparseSelfAdjointView<\textcolor{keyword}{const} 
      SparseMatrix<\_Scalar,\_Options,\_Index>, UpLo>& mat)
00122 \{
00123   cholmod\_sparse res = \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(Ref<SparseMatrix<\_Scalar,\_Options,\_Index> >(mat.matrix().
      const\_cast\_derived()));
00124   
00125   \textcolor{keywordflow}{if}(UpLo==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}) res.stype =  1;
00126   \textcolor{keywordflow}{if}(UpLo==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) res.stype = -1;
00127 
00128   \textcolor{keywordflow}{return} res;
00129 \}
00130 
00133 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00134 cholmod\_dense \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(MatrixBase<Derived>& mat)
00135 \{
00136   EIGEN\_STATIC\_ASSERT((internal::traits<Derived>::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==0,
      THIS\_METHOD\_IS\_ONLY\_FOR\_COLUMN\_MAJOR\_MATRICES);
00137   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00138 
00139   cholmod\_dense res;
00140   res.nrow   = mat.rows();
00141   res.ncol   = mat.cols();
00142   res.nzmax  = res.nrow * res.ncol;
00143   res.d      = Derived::IsVectorAtCompileTime ? mat.derived().size() : mat.derived().outerStride();
00144   res.x      = (\textcolor{keywordtype}{void}*)(mat.derived().data());
00145   res.z      = 0;
00146 
00147   internal::cholmod\_configure\_matrix<Scalar>::run(res);
00148 
00149   \textcolor{keywordflow}{return} res;
00150 \}
00151 
00154 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Flags, \textcolor{keyword}{typename} StorageIndex>
00155 MappedSparseMatrix<Scalar,Flags,StorageIndex> \hyperlink{namespace_eigen_af13cf1742b9a7a03703e8e5393bb6f86}{viewAsEigen}(cholmod\_sparse& cm)
00156 \{
00157   \textcolor{keywordflow}{return} MappedSparseMatrix<Scalar,Flags,StorageIndex>
00158          (cm.nrow, cm.ncol, \textcolor{keyword}{static\_cast<}StorageIndex*\textcolor{keyword}{>}(cm.p)[cm.ncol],
00159           static\_cast<StorageIndex*>(cm.p), \textcolor{keyword}{static\_cast<}StorageIndex*\textcolor{keyword}{>}(cm.i),static\_cast<Scalar*>(cm.x) );
00160 \}
00161 
00162 \textcolor{keyword}{enum} CholmodMode \{
00163   CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt
00164 \};
00165 
00166 
00172 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} \_UpLo, \textcolor{keyword}{typename} Derived>
00173 \textcolor{keyword}{class }CholmodBase : \textcolor{keyword}{public} SparseSolverBase<Derived>
00174 \{
00175   \textcolor{keyword}{protected}:
00176     \textcolor{keyword}{typedef} SparseSolverBase<Derived> Base;
00177     \textcolor{keyword}{using} Base::derived;
00178     \textcolor{keyword}{using} Base::m\_isInitialized;
00179   \textcolor{keyword}{public}:
00180     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00181     \textcolor{keyword}{enum} \{ UpLo = \_UpLo \};
00182     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00183     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00184     \textcolor{keyword}{typedef} MatrixType CholMatrixType;
00185     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00186     \textcolor{keyword}{enum} \{
00187       ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00188       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
00189     \};
00190 
00191   \textcolor{keyword}{public}:
00192 
00193     CholmodBase()
00194       : m\_cholmodFactor(0), m\_info(\hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success}), m\_factorizationIsOk(false), m\_analysisIsOk(false)
00195     \{
00196       EIGEN\_STATIC\_ASSERT((internal::is\_same<double,RealScalar>::value), 
      CHOLMOD\_SUPPORTS\_DOUBLE\_PRECISION\_ONLY);
00197       m\_shiftOffset[0] = m\_shiftOffset[1] = 0.0;
00198       cholmod\_start(&m\_cholmod);
00199     \}
00200 
00201     \textcolor{keyword}{explicit} CholmodBase(\textcolor{keyword}{const} MatrixType& matrix)
00202       : m\_cholmodFactor(0), m\_info(\hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success}), m\_factorizationIsOk(false), m\_analysisIsOk(false)
00203     \{
00204       EIGEN\_STATIC\_ASSERT((internal::is\_same<double,RealScalar>::value), 
      CHOLMOD\_SUPPORTS\_DOUBLE\_PRECISION\_ONLY);
00205       m\_shiftOffset[0] = m\_shiftOffset[1] = 0.0;
00206       cholmod\_start(&m\_cholmod);
00207       compute(matrix);
00208     \}
00209 
00210     ~CholmodBase()
00211     \{
00212       \textcolor{keywordflow}{if}(m\_cholmodFactor)
00213         cholmod\_free\_factor(&m\_cholmodFactor, &m\_cholmod);
00214       cholmod\_finish(&m\_cholmod);
00215     \}
00216     
00217     \textcolor{keyword}{inline} StorageIndex cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::convert\_index<StorageIndex, Index>(m\_cholmodFactor
      ->n); \}
00218     \textcolor{keyword}{inline} StorageIndex rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::convert\_index<StorageIndex, Index>(m\_cholmodFactor
      ->n); \}
00219     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_cholmod_support_2_cholmod_support_8h_source_l00225}\hyperlink{class_eigen_1_1_cholmod_base_ada4cc43c64767d186fcb8997440cc753}{00225}     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} \hyperlink{class_eigen_1_1_cholmod_base_ada4cc43c64767d186fcb8997440cc753}{info}()\textcolor{keyword}{ const}
00226 \textcolor{keyword}{    }\{
00227       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"Decomposition is not initialized."});
00228       \textcolor{keywordflow}{return} m\_info;
00229     \}
00230 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_cholmod_support_2_cholmod_support_8h_source_l00232}\hyperlink{class_eigen_1_1_cholmod_base_abaf5be01b1e3035a4de0b19f5b63549e}{00232}     Derived& \hyperlink{class_eigen_1_1_cholmod_base_abaf5be01b1e3035a4de0b19f5b63549e}{compute}(\textcolor{keyword}{const} MatrixType& matrix)
00233     \{
00234       analyzePattern(matrix);
00235       factorize(matrix);
00236       \textcolor{keywordflow}{return} derived();
00237     \}
00238     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_cholmod_support_2_cholmod_support_8h_source_l00245}\hyperlink{class_eigen_1_1_cholmod_base_a5ac967e9f4ccfc43ca9e610b89232c24}{00245}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_cholmod_base_a5ac967e9f4ccfc43ca9e610b89232c24}{analyzePattern}(\textcolor{keyword}{const} MatrixType& matrix)
00246     \{
00247       \textcolor{keywordflow}{if}(m\_cholmodFactor)
00248       \{
00249         cholmod\_free\_factor(&m\_cholmodFactor, &m\_cholmod);
00250         m\_cholmodFactor = 0;
00251       \}
00252       cholmod\_sparse \hyperlink{group___core___module_class_eigen_1_1_matrix}{A} = \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(matrix.template selfadjointView<UpLo>());
00253       m\_cholmodFactor = cholmod\_analyze(&A, &m\_cholmod);
00254       
00255       this->m\_isInitialized = \textcolor{keyword}{true};
00256       this->m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00257       m\_analysisIsOk = \textcolor{keyword}{true};
00258       m\_factorizationIsOk = \textcolor{keyword}{false};
00259     \}
00260     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_cholmod_support_2_cholmod_support_8h_source_l00267}\hyperlink{class_eigen_1_1_cholmod_base_a5bd9c9ec4d1c15f202a6c66b5e9ef37b}{00267}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_cholmod_base_a5bd9c9ec4d1c15f202a6c66b5e9ef37b}{factorize}(\textcolor{keyword}{const} MatrixType& matrix)
00268     \{
00269       eigen\_assert(m\_analysisIsOk && \textcolor{stringliteral}{"You must first call analyzePattern()"});
00270       cholmod\_sparse \hyperlink{group___core___module_class_eigen_1_1_matrix}{A} = \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(matrix.template selfadjointView<UpLo>());
00271       cholmod\_factorize\_p(&A, m\_shiftOffset, 0, 0, m\_cholmodFactor, &m\_cholmod);
00272 
00273       \textcolor{comment}{// If the factorization failed, minor is the column at which it did. On success minor == n.}
00274       this->m\_info = (m\_cholmodFactor->minor == m\_cholmodFactor->n ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} : 
      \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue});
00275       m\_factorizationIsOk = \textcolor{keyword}{true};
00276     \}
00277     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_cholmod_support_2_cholmod_support_8h_source_l00280}\hyperlink{class_eigen_1_1_cholmod_base_a6a85bf52d6aa480240a64f277d7f96c6}{00280}     cholmod\_common& \hyperlink{class_eigen_1_1_cholmod_base_a6a85bf52d6aa480240a64f277d7f96c6}{cholmod}() \{ \textcolor{keywordflow}{return} m\_cholmod; \}
00281     
00282 \textcolor{preprocessor}{    #ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00283 
00284     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs,\textcolor{keyword}{typename} Dest>
00285     \textcolor{keywordtype}{void} \_solve\_impl(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>} &b, \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>} &dest)\textcolor{keyword}{ const}
00286 \textcolor{keyword}{    }\{
00287       eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"The decomposition is not in a valid state for solving, you must
       first call either compute() or symbolic()/numeric()"});
00288       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = m\_cholmodFactor->n;
00289       EIGEN\_UNUSED\_VARIABLE(size);
00290       eigen\_assert(size==b.rows());
00291       
00292       \textcolor{comment}{// Cholmod needs column-major stoarge without inner-stride, which corresponds to the default behavior
       of Ref.}
00293       \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const Matrix<typename Rhs::Scalar,Dynamic,Dynamic,ColMajor>}
       > b\_ref(b.derived());
00294 
00295       cholmod\_dense b\_cd = \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(b\_ref);
00296       cholmod\_dense* x\_cd = cholmod\_solve(CHOLMOD\_A, m\_cholmodFactor, &b\_cd, &m\_cholmod);
00297       \textcolor{keywordflow}{if}(!x\_cd)
00298       \{
00299         this->m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00300         \textcolor{keywordflow}{return};
00301       \}
00302       \textcolor{comment}{// TODO optimize this copy by swapping when possible (be careful with alignment, etc.)}
00303       dest = \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Dest::RowsAtCompileTime,Dest::ColsAtCompileTime>::Map}
      (reinterpret\_cast<Scalar*>(x\_cd->x),b.rows(),b.cols());
00304       cholmod\_free\_dense(&x\_cd, &m\_cholmod);
00305     \}
00306     
00308     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsDerived, \textcolor{keyword}{typename} DestDerived>
00309     \textcolor{keywordtype}{void} \_solve\_impl(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<RhsDerived>} &b, 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<DestDerived>} &dest)\textcolor{keyword}{ const}
00310 \textcolor{keyword}{    }\{
00311       eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"The decomposition is not in a valid state for solving, you must
       first call either compute() or symbolic()/numeric()"});
00312       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = m\_cholmodFactor->n;
00313       EIGEN\_UNUSED\_VARIABLE(size);
00314       eigen\_assert(size==b.\hyperlink{group___sparse_core___module_a1944e9fa9ce7937bfc3a87b2cb94371f}{rows}());
00315 
00316       \textcolor{comment}{// note: cs stands for Cholmod Sparse}
00317       
      \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<SparseMatrix<typename RhsDerived::Scalar,ColMajor,typename RhsDerived::StorageIndex>}
       > b\_ref(b.const\_cast\_derived());
00318       cholmod\_sparse b\_cs = \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(b\_ref);
00319       cholmod\_sparse* x\_cs = cholmod\_spsolve(CHOLMOD\_A, m\_cholmodFactor, &b\_cs, &m\_cholmod);
00320       \textcolor{keywordflow}{if}(!x\_cs)
00321       \{
00322         this->m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00323         \textcolor{keywordflow}{return};
00324       \}
00325       \textcolor{comment}{// TODO optimize this copy by swapping when possible (be careful with alignment, etc.)}
00326       dest.derived() = viewAsEigen<typename DestDerived::Scalar,ColMajor,typename
       DestDerived::StorageIndex>(*x\_cs);
00327       cholmod\_free\_sparse(&x\_cs, &m\_cholmod);
00328     \}
00329 \textcolor{preprocessor}{    #endif // EIGEN\_PARSED\_BY\_DOXYGEN}
00330     
00331     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_cholmod_support_2_cholmod_support_8h_source_l00341}\hyperlink{class_eigen_1_1_cholmod_base_a886fc102723ca7bde4ac7162dfd72f5d}{00341}     Derived& \hyperlink{class_eigen_1_1_cholmod_base_a886fc102723ca7bde4ac7162dfd72f5d}{setShift}(\textcolor{keyword}{const} RealScalar& offset)
00342     \{
00343       m\_shiftOffset[0] = double(offset);
00344       \textcolor{keywordflow}{return} derived();
00345     \}
00346     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_cholmod_support_2_cholmod_support_8h_source_l00348}\hyperlink{class_eigen_1_1_cholmod_base_ab4ffb4a9735ad7e81a01d5789ce96547}{00348}     Scalar \hyperlink{class_eigen_1_1_cholmod_base_ab4ffb4a9735ad7e81a01d5789ce96547}{determinant}()\textcolor{keyword}{ const}
00349 \textcolor{keyword}{    }\{
00350       \textcolor{keyword}{using} std::exp;
00351       \textcolor{keywordflow}{return} exp(logDeterminant());
00352     \}
00353 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_cholmod_support_2_cholmod_support_8h_source_l00355}\hyperlink{class_eigen_1_1_cholmod_base_a597f7839a39604af18a8741a0d8c46bf}{00355}     Scalar \hyperlink{class_eigen_1_1_cholmod_base_a597f7839a39604af18a8741a0d8c46bf}{logDeterminant}()\textcolor{keyword}{ const}
00356 \textcolor{keyword}{    }\{
00357       \textcolor{keyword}{using} std::log;
00358       \textcolor{keyword}{using} numext::real;
00359       eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"The decomposition is not in a valid state for solving, you must
       first call either compute() or symbolic()/numeric()"});
00360 
00361       RealScalar logDet = 0;
00362       Scalar *x = \textcolor{keyword}{static\_cast<}Scalar*\textcolor{keyword}{>}(m\_cholmodFactor->x);
00363       \textcolor{keywordflow}{if} (m\_cholmodFactor->is\_super)
00364       \{
00365         \textcolor{comment}{// Supernodal factorization stored as a packed list of dense column-major blocs,}
00366         \textcolor{comment}{// as described by the following structure:}
00367 
00368         \textcolor{comment}{// super[k] == index of the first column of the j-th super node}
00369         StorageIndex *super = \textcolor{keyword}{static\_cast<}StorageIndex*\textcolor{keyword}{>}(m\_cholmodFactor->super);
00370         \textcolor{comment}{// pi[k] == offset to the description of row indices}
00371         StorageIndex *pi = \textcolor{keyword}{static\_cast<}StorageIndex*\textcolor{keyword}{>}(m\_cholmodFactor->pi);
00372         \textcolor{comment}{// px[k] == offset to the respective dense block}
00373         StorageIndex *px = \textcolor{keyword}{static\_cast<}StorageIndex*\textcolor{keyword}{>}(m\_cholmodFactor->px);
00374 
00375         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nb\_super\_nodes = m\_cholmodFactor->nsuper;
00376         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k < nb\_super\_nodes; ++k)
00377         \{
00378           StorageIndex ncols = super[k + 1] - super[k];
00379           StorageIndex nrows = pi[k + 1] - pi[k];
00380 
00381           \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Array<Scalar,1,Dynamic>}, 0, 
      \hyperlink{class_eigen_1_1_inner_stride}{InnerStride<>} > sk(x + px[k], ncols, \hyperlink{class_eigen_1_1_inner_stride}{InnerStride<>}(nrows+1));
00382           logDet += sk.real().log().sum();
00383         \}
00384       \}
00385       \textcolor{keywordflow}{else}
00386       \{
00387         \textcolor{comment}{// Simplicial factorization stored as standard CSC matrix.}
00388         StorageIndex *p = \textcolor{keyword}{static\_cast<}StorageIndex*\textcolor{keyword}{>}(m\_cholmodFactor->p);
00389         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = m\_cholmodFactor->n;
00390         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<size; ++k)
00391           logDet += \hyperlink{structlog}{log}(real( x[p[k]] ));
00392       \}
00393       \textcolor{keywordflow}{if} (m\_cholmodFactor->is\_ll)
00394         logDet *= 2.0;
00395       \textcolor{keywordflow}{return} logDet;
00396     \};
00397 
00398     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Stream>
00399     \textcolor{keywordtype}{void} dumpMemory(Stream& \textcolor{comment}{/*s*/})
00400     \{\}
00401     
00402   \textcolor{keyword}{protected}:
00403     \textcolor{keyword}{mutable} cholmod\_common m\_cholmod;
00404     cholmod\_factor* m\_cholmodFactor;
00405     \textcolor{keywordtype}{double} m\_shiftOffset[2];
00406     \textcolor{keyword}{mutable} \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} m\_info;
00407     \textcolor{keywordtype}{int} m\_factorizationIsOk;
00408     \textcolor{keywordtype}{int} m\_analysisIsOk;
00409 \};
00410 
00433 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} \_UpLo = Lower>
00434 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_cholmod_simplicial_l_l_t}{CholmodSimplicialLLT} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_cholmod_base}{CholmodBase}<\_MatrixType, \_UpLo, CholmodS
      implicialLLT<\_MatrixType, \_UpLo> >
00435 \{
00436     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_cholmod_base}{CholmodBase<\_MatrixType, \_UpLo, CholmodSimplicialLLT>}
       Base;
00437     \textcolor{keyword}{using} Base::m\_cholmod;
00438     
00439   \textcolor{keyword}{public}:
00440     
00441     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00442     
00443     \hyperlink{class_eigen_1_1_cholmod_simplicial_l_l_t}{CholmodSimplicialLLT}() : Base() \{ \hyperlink{structinit}{init}(); \}
00444 
00445     \hyperlink{class_eigen_1_1_cholmod_simplicial_l_l_t}{CholmodSimplicialLLT}(\textcolor{keyword}{const} MatrixType& matrix) : Base()
00446     \{
00447       \hyperlink{structinit}{init}();
00448       this->compute(matrix);
00449     \}
00450 
00451     ~\hyperlink{class_eigen_1_1_cholmod_simplicial_l_l_t}{CholmodSimplicialLLT}() \{\}
00452   \textcolor{keyword}{protected}:
00453     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}()
00454     \{
00455       m\_cholmod.final\_asis = 0;
00456       m\_cholmod.supernodal = CHOLMOD\_SIMPLICIAL;
00457       m\_cholmod.final\_ll = 1;
00458     \}
00459 \};
00460 
00461 
00484 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} \_UpLo = Lower>
00485 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_cholmod_simplicial_l_d_l_t}{CholmodSimplicialLDLT} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_cholmod_base}{CholmodBase}<\_MatrixType, \_UpLo, Cholmo
      dSimplicialLDLT<\_MatrixType, \_UpLo> >
00486 \{
00487     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_cholmod_base}{CholmodBase<\_MatrixType, \_UpLo, CholmodSimplicialLDLT>}
       Base;
00488     \textcolor{keyword}{using} Base::m\_cholmod;
00489     
00490   \textcolor{keyword}{public}:
00491     
00492     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00493     
00494     \hyperlink{class_eigen_1_1_cholmod_simplicial_l_d_l_t}{CholmodSimplicialLDLT}() : Base() \{ \hyperlink{structinit}{init}(); \}
00495 
00496     \hyperlink{class_eigen_1_1_cholmod_simplicial_l_d_l_t}{CholmodSimplicialLDLT}(\textcolor{keyword}{const} MatrixType& matrix) : Base()
00497     \{
00498       \hyperlink{structinit}{init}();
00499       this->compute(matrix);
00500     \}
00501 
00502     ~\hyperlink{class_eigen_1_1_cholmod_simplicial_l_d_l_t}{CholmodSimplicialLDLT}() \{\}
00503   \textcolor{keyword}{protected}:
00504     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}()
00505     \{
00506       m\_cholmod.final\_asis = 1;
00507       m\_cholmod.supernodal = CHOLMOD\_SIMPLICIAL;
00508     \}
00509 \};
00510 
00533 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} \_UpLo = Lower>
00534 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_cholmod_supernodal_l_l_t}{CholmodSupernodalLLT} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_cholmod_base}{CholmodBase}<\_MatrixType, \_UpLo, CholmodS
      upernodalLLT<\_MatrixType, \_UpLo> >
00535 \{
00536     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_cholmod_base}{CholmodBase<\_MatrixType, \_UpLo, CholmodSupernodalLLT>}
       Base;
00537     \textcolor{keyword}{using} Base::m\_cholmod;
00538     
00539   \textcolor{keyword}{public}:
00540     
00541     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00542     
00543     \hyperlink{class_eigen_1_1_cholmod_supernodal_l_l_t}{CholmodSupernodalLLT}() : Base() \{ \hyperlink{structinit}{init}(); \}
00544 
00545     \hyperlink{class_eigen_1_1_cholmod_supernodal_l_l_t}{CholmodSupernodalLLT}(\textcolor{keyword}{const} MatrixType& matrix) : Base()
00546     \{
00547       \hyperlink{structinit}{init}();
00548       this->compute(matrix);
00549     \}
00550 
00551     ~\hyperlink{class_eigen_1_1_cholmod_supernodal_l_l_t}{CholmodSupernodalLLT}() \{\}
00552   \textcolor{keyword}{protected}:
00553     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}()
00554     \{
00555       m\_cholmod.final\_asis = 1;
00556       m\_cholmod.supernodal = CHOLMOD\_SUPERNODAL;
00557     \}
00558 \};
00559 
00584 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} \_UpLo = Lower>
00585 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_cholmod_decomposition}{CholmodDecomposition} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_cholmod_base}{CholmodBase}<\_MatrixType, \_UpLo, CholmodD
      ecomposition<\_MatrixType, \_UpLo> >
00586 \{
00587     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_cholmod_base}{CholmodBase<\_MatrixType, \_UpLo, CholmodDecomposition>}
       Base;
00588     \textcolor{keyword}{using} Base::m\_cholmod;
00589     
00590   \textcolor{keyword}{public}:
00591     
00592     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00593     
00594     \hyperlink{class_eigen_1_1_cholmod_decomposition}{CholmodDecomposition}() : Base() \{ \hyperlink{structinit}{init}(); \}
00595 
00596     \hyperlink{class_eigen_1_1_cholmod_decomposition}{CholmodDecomposition}(\textcolor{keyword}{const} MatrixType& matrix) : Base()
00597     \{
00598       \hyperlink{structinit}{init}();
00599       this->compute(matrix);
00600     \}
00601 
00602     ~\hyperlink{class_eigen_1_1_cholmod_decomposition}{CholmodDecomposition}() \{\}
00603     
00604     \textcolor{keywordtype}{void} setMode(CholmodMode mode)
00605     \{
00606       \textcolor{keywordflow}{switch}(mode)
00607       \{
00608         \textcolor{keywordflow}{case} CholmodAuto:
00609           m\_cholmod.final\_asis = 1;
00610           m\_cholmod.supernodal = CHOLMOD\_AUTO;
00611           \textcolor{keywordflow}{break};
00612         \textcolor{keywordflow}{case} CholmodSimplicialLLt:
00613           m\_cholmod.final\_asis = 0;
00614           m\_cholmod.supernodal = CHOLMOD\_SIMPLICIAL;
00615           m\_cholmod.final\_ll = 1;
00616           \textcolor{keywordflow}{break};
00617         \textcolor{keywordflow}{case} CholmodSupernodalLLt:
00618           m\_cholmod.final\_asis = 1;
00619           m\_cholmod.supernodal = CHOLMOD\_SUPERNODAL;
00620           \textcolor{keywordflow}{break};
00621         \textcolor{keywordflow}{case} CholmodLDLt:
00622           m\_cholmod.final\_asis = 1;
00623           m\_cholmod.supernodal = CHOLMOD\_SIMPLICIAL;
00624           \textcolor{keywordflow}{break};
00625         \textcolor{keywordflow}{default}:
00626           \textcolor{keywordflow}{break};
00627       \}
00628     \}
00629   \textcolor{keyword}{protected}:
00630     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}()
00631     \{
00632       m\_cholmod.final\_asis = 1;
00633       m\_cholmod.supernodal = CHOLMOD\_AUTO;
00634     \}
00635 \};
00636 
00637 \} \textcolor{comment}{// end namespace Eigen}
00638 
00639 \textcolor{preprocessor}{#endif // EIGEN\_CHOLMODSUPPORT\_H}
\end{DoxyCode}
