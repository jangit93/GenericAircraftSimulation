\hypertarget{eigen_2unsupported_2test_2_f_f_t_w_8cpp_source}{}\section{eigen/unsupported/test/\+F\+F\+TW.cpp}
\label{eigen_2unsupported_2test_2_f_f_t_w_8cpp_source}\index{F\+F\+T\+W.\+cpp@{F\+F\+T\+W.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Mark Borgerding mark a borgerding net}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 \textcolor{preprocessor}{#include <unsupported/Eigen/FFT>}
00012 
00013 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> 
00014 std::complex<T> RandomCpx() \{ \textcolor{keywordflow}{return} std::complex<T>( (\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})(rand()/(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})RAND\_MAX - .5), (
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})(rand()/(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})RAND\_MAX - .5) ); \}
00015 
00016 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00017 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00018 
00019 
00020 \textcolor{keyword}{template} < \textcolor{keyword}{typename} T>
00021 \hyperlink{structcomplex}{complex<long double>}  promote(\hyperlink{structcomplex}{complex<T>} x) \{ \textcolor{keywordflow}{return} 
      \hyperlink{structcomplex}{complex<long double>}((\textcolor{keywordtype}{long} double)x.real(),(\textcolor{keywordtype}{long} double)x.imag()); \}
00022 
00023 \hyperlink{structcomplex}{complex<long double>}  promote(\textcolor{keywordtype}{float} x) \{ \textcolor{keywordflow}{return} 
      \hyperlink{structcomplex}{complex<long double>}((\textcolor{keywordtype}{long} double)x); \}
00024 \hyperlink{structcomplex}{complex<long double>}  promote(\textcolor{keywordtype}{double} x) \{ \textcolor{keywordflow}{return} 
      \hyperlink{structcomplex}{complex<long double>}((\textcolor{keywordtype}{long} double)x); \}
00025 \hyperlink{structcomplex}{complex<long double>}  promote(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} x) \{ \textcolor{keywordflow}{return} 
      \hyperlink{structcomplex}{complex<long double>}((\textcolor{keywordtype}{long} double)x); \}
00026     
00027 
00028     \textcolor{keyword}{template} <\textcolor{keyword}{typename} VT1,\textcolor{keyword}{typename} VT2>
00029     \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} fft\_rmse( \textcolor{keyword}{const} VT1 & fftbuf,\textcolor{keyword}{const} VT2 & timebuf)
00030     \{
00031         \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} totalpower=0;
00032         \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} difpower=0;
00033         \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} pi = acos((\textcolor{keywordtype}{long} \textcolor{keywordtype}{double})-1 );
00034         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} k0=0;k0<(size\_t)fftbuf.size();++k0) \{
00035             \hyperlink{structcomplex}{complex<long double>} acc = 0;
00036             \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} phinc = (\textcolor{keywordtype}{long} double)(-2.)*k0* pi / timebuf.size();
00037             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} k1=0;k1<(size\_t)timebuf.size();++k1) \{
00038                 acc +=  promote( timebuf[k1] ) * exp( \hyperlink{structcomplex}{complex<long double>}(0,k1*phinc) 
      );
00039             \}
00040             totalpower += numext::abs2(acc);
00041             \hyperlink{structcomplex}{complex<long double>} x = promote(fftbuf[k0]); 
00042             \hyperlink{structcomplex}{complex<long double>} dif = acc - x;
00043             difpower += numext::abs2(dif);
00044             \textcolor{comment}{//cerr << k0 << "\(\backslash\)t" << acc << "\(\backslash\)t" <<  x << "\(\backslash\)t" << sqrt(numext::abs2(dif)) << endl;}
00045         \}
00046         cerr << \textcolor{stringliteral}{"rmse:"} << sqrt(difpower/totalpower) << endl;
00047         \textcolor{keywordflow}{return} sqrt(difpower/totalpower);
00048     \}
00049 
00050     \textcolor{keyword}{template} <\textcolor{keyword}{typename} VT1,\textcolor{keyword}{typename} VT2>
00051     \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} dif\_rmse( \textcolor{keyword}{const} VT1 buf1,\textcolor{keyword}{const} VT2 buf2)
00052     \{
00053         \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} totalpower=0;
00054         \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} difpower=0;
00055         \textcolor{keywordtype}{size\_t} n = (min)( buf1.size(),buf2.size() );
00056         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} k=0;k<n;++k) \{
00057             totalpower += (\textcolor{keywordtype}{long} double)((numext::abs2( buf1[k] ) + numext::abs2(buf2[k]) )/2);
00058             difpower += (\textcolor{keywordtype}{long} double)(numext::abs2(buf1[k] - buf2[k]));
00059         \}
00060         \textcolor{keywordflow}{return} sqrt(difpower/totalpower);
00061     \}
00062 
00063 \textcolor{keyword}{enum} \{ StdVectorContainer, EigenVectorContainer \};
00064 
\Hypertarget{eigen_2unsupported_2test_2_f_f_t_w_8cpp_source_l00065}\hyperlink{struct_vector_type}{00065} \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Container, \textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }\hyperlink{struct_vector_type}{VectorType};
00066 
\Hypertarget{eigen_2unsupported_2test_2_f_f_t_w_8cpp_source_l00067}\hyperlink{struct_vector_type_3_01_std_vector_container_00_01_scalar_01_4}{00067} \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }\hyperlink{struct_vector_type}{VectorType}<StdVectorContainer,Scalar>
00068 \{
00069   \textcolor{keyword}{typedef} vector<Scalar> type;
00070 \};
00071 
\Hypertarget{eigen_2unsupported_2test_2_f_f_t_w_8cpp_source_l00072}\hyperlink{struct_vector_type_3_01_eigen_vector_container_00_01_scalar_01_4}{00072} \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }\hyperlink{struct_vector_type}{VectorType}<EigenVectorContainer,Scalar>
00073 \{
00074   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} \hyperlink{group___core___module}{type};
00075 \};
00076 
00077 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} Container, \textcolor{keyword}{typename} T>
00078 \textcolor{keywordtype}{void} test\_scalar\_generic(\textcolor{keywordtype}{int} nfft)
00079 \{
00080     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} FFT<T>::Complex Complex;
00081     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} FFT<T>::Scalar Scalar;
00082     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_vector_type}{VectorType<Container,Scalar>::type} ScalarVector;
00083     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_vector_type}{VectorType<Container,Complex>::type} ComplexVector;
00084 
00085     FFT<T> fft;
00086     ScalarVector tbuf(nfft);
00087     ComplexVector freqBuf;
00088     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0;k<nfft;++k)
00089         tbuf[k]= (\hyperlink{group___sparse_core___module}{T})( rand()/(double)RAND\_MAX - .5);
00090 
00091     \textcolor{comment}{// make sure it DOESN'T give the right full spectrum answer}
00092     \textcolor{comment}{// if we've asked for half-spectrum}
00093     fft.SetFlag(fft.HalfSpectrum );
00094     fft.fwd( freqBuf,tbuf);
00095     VERIFY((\textcolor{keywordtype}{size\_t})freqBuf.size() == (size\_t)( (nfft>>1)+1) );
00096     VERIFY( \hyperlink{group___sparse_core___module}{T}(fft\_rmse(freqBuf,tbuf)) < test\_precision<T>()  );\textcolor{comment}{// gross check}
00097 
00098     fft.ClearFlag(fft.HalfSpectrum );
00099     fft.fwd( freqBuf,tbuf);
00100     VERIFY( (\textcolor{keywordtype}{size\_t})freqBuf.size() == (size\_t)nfft);
00101     VERIFY( \hyperlink{group___sparse_core___module}{T}(fft\_rmse(freqBuf,tbuf)) < test\_precision<T>()  );\textcolor{comment}{// gross check}
00102 
00103     \textcolor{keywordflow}{if} (nfft&1)
00104         \textcolor{keywordflow}{return}; \textcolor{comment}{// odd FFTs get the wrong size inverse FFT}
00105 
00106     ScalarVector tbuf2;
00107     fft.inv( tbuf2 , freqBuf);
00108     VERIFY( \hyperlink{group___sparse_core___module}{T}(dif\_rmse(tbuf,tbuf2)) < test\_precision<T>()  );\textcolor{comment}{// gross check}
00109 
00110 
00111     \textcolor{comment}{// verify that the Unscaled flag takes effect}
00112     ScalarVector tbuf3;
00113     fft.SetFlag(fft.Unscaled);
00114 
00115     fft.inv( tbuf3 , freqBuf);
00116 
00117     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0;k<nfft;++k)
00118         tbuf3[k] *= \hyperlink{group___sparse_core___module}{T}(1./nfft);
00119 
00120 
00121     \textcolor{comment}{//for (size\_t i=0;i<(size\_t) tbuf.size();++i)}
00122     \textcolor{comment}{//    cout << "freqBuf=" << freqBuf[i] << " in2=" << tbuf3[i] << " -  in=" << tbuf[i] << " => " <<
       (tbuf3[i] - tbuf[i] ) <<  endl;}
00123 
00124     VERIFY( \hyperlink{group___sparse_core___module}{T}(dif\_rmse(tbuf,tbuf3)) < test\_precision<T>()  );\textcolor{comment}{// gross check}
00125 
00126     \textcolor{comment}{// verify that ClearFlag works}
00127     fft.ClearFlag(fft.Unscaled);
00128     fft.inv( tbuf2 , freqBuf);
00129     VERIFY( \hyperlink{group___sparse_core___module}{T}(dif\_rmse(tbuf,tbuf2)) < test\_precision<T>()  );\textcolor{comment}{// gross check}
00130 \}
00131 
00132 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00133 \textcolor{keywordtype}{void} test\_scalar(\textcolor{keywordtype}{int} nfft)
00134 \{
00135   test\_scalar\_generic<StdVectorContainer,T>(nfft);
00136   \textcolor{comment}{//test\_scalar\_generic<EigenVectorContainer,T>(nfft);}
00137 \}
00138 
00139 
00140 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} Container, \textcolor{keyword}{typename} T>
00141 \textcolor{keywordtype}{void} test\_complex\_generic(\textcolor{keywordtype}{int} nfft)
00142 \{
00143     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} FFT<T>::Complex Complex;
00144     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_vector_type}{VectorType<Container,Complex>::type} ComplexVector;
00145 
00146     FFT<T> fft;
00147 
00148     ComplexVector inbuf(nfft);
00149     ComplexVector outbuf;
00150     ComplexVector buf3;
00151     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0;k<nfft;++k)
00152         inbuf[k]= Complex( (\hyperlink{group___sparse_core___module}{T})(rand()/(\textcolor{keywordtype}{double})RAND\_MAX - .5), (\hyperlink{group___sparse_core___module}{T})(rand()/(\textcolor{keywordtype}{double})RAND\_MAX - .5) );
00153     fft.fwd( outbuf , inbuf);
00154 
00155     VERIFY( \hyperlink{group___sparse_core___module}{T}(fft\_rmse(outbuf,inbuf)) < test\_precision<T>()  );\textcolor{comment}{// gross check}
00156     fft.inv( buf3 , outbuf);
00157 
00158     VERIFY( \hyperlink{group___sparse_core___module}{T}(dif\_rmse(inbuf,buf3)) < test\_precision<T>()  );\textcolor{comment}{// gross check}
00159 
00160     \textcolor{comment}{// verify that the Unscaled flag takes effect}
00161     ComplexVector buf4;
00162     fft.SetFlag(fft.Unscaled);
00163     fft.inv( buf4 , outbuf);
00164     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0;k<nfft;++k)
00165         buf4[k] *= \hyperlink{group___sparse_core___module}{T}(1./nfft);
00166     VERIFY( \hyperlink{group___sparse_core___module}{T}(dif\_rmse(inbuf,buf4)) < test\_precision<T>()  );\textcolor{comment}{// gross check}
00167 
00168     \textcolor{comment}{// verify that ClearFlag works}
00169     fft.ClearFlag(fft.Unscaled);
00170     fft.inv( buf3 , outbuf);
00171     VERIFY( \hyperlink{group___sparse_core___module}{T}(dif\_rmse(inbuf,buf3)) < test\_precision<T>()  );\textcolor{comment}{// gross check}
00172 \}
00173 
00174 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00175 \textcolor{keywordtype}{void} test\_complex(\textcolor{keywordtype}{int} nfft)
00176 \{
00177   test\_complex\_generic<StdVectorContainer,T>(nfft);
00178   test\_complex\_generic<EigenVectorContainer,T>(nfft);
00179 \}
00180 \textcolor{comment}{/*}
00181 \textcolor{comment}{template <typename T,int nrows,int ncols>}
00182 \textcolor{comment}{void test\_complex2d()}
00183 \textcolor{comment}{\{}
00184 \textcolor{comment}{    typedef typename Eigen::FFT<T>::Complex Complex;}
00185 \textcolor{comment}{    FFT<T> fft;}
00186 \textcolor{comment}{    Eigen::Matrix<Complex,nrows,ncols> src,src2,dst,dst2;}
00187 \textcolor{comment}{}
00188 \textcolor{comment}{    src = Eigen::Matrix<Complex,nrows,ncols>::Random();}
00189 \textcolor{comment}{    //src =  Eigen::Matrix<Complex,nrows,ncols>::Identity();}
00190 \textcolor{comment}{}
00191 \textcolor{comment}{    for (int k=0;k<ncols;k++) \{}
00192 \textcolor{comment}{        Eigen::Matrix<Complex,nrows,1> tmpOut;}
00193 \textcolor{comment}{        fft.fwd( tmpOut,src.col(k) );}
00194 \textcolor{comment}{        dst2.col(k) = tmpOut;}
00195 \textcolor{comment}{    \}}
00196 \textcolor{comment}{}
00197 \textcolor{comment}{    for (int k=0;k<nrows;k++) \{}
00198 \textcolor{comment}{        Eigen::Matrix<Complex,1,ncols> tmpOut;}
00199 \textcolor{comment}{        fft.fwd( tmpOut,  dst2.row(k) );}
00200 \textcolor{comment}{        dst2.row(k) = tmpOut;}
00201 \textcolor{comment}{    \}}
00202 \textcolor{comment}{}
00203 \textcolor{comment}{    fft.fwd2(dst.data(),src.data(),ncols,nrows);}
00204 \textcolor{comment}{    fft.inv2(src2.data(),dst.data(),ncols,nrows);}
00205 \textcolor{comment}{    VERIFY( (src-src2).norm() < test\_precision<T>() );}
00206 \textcolor{comment}{    VERIFY( (dst-dst2).norm() < test\_precision<T>() );}
00207 \textcolor{comment}{\}}
00208 \textcolor{comment}{*/}
00209 
00210 
00211 \textcolor{keywordtype}{void} test\_return\_by\_value(\textcolor{keywordtype}{int} len)
00212 \{
00213     VectorXf in;
00214     VectorXf in1;
00215     in.setRandom( len );
00216     VectorXcf out1,out2;
00217     FFT<float> fft;
00218 
00219     fft.SetFlag(fft.HalfSpectrum );
00220 
00221     fft.fwd(out1,in);
00222     out2 = fft.fwd(in);
00223     VERIFY( (out1-out2).norm() < test\_precision<float>() );
00224     in1 = fft.inv(out1);
00225     VERIFY( (in1-in).norm() < test\_precision<float>() );
00226 \}
00227 
00228 \textcolor{keywordtype}{void} test\_FFTW()
00229 \{
00230   CALL\_SUBTEST( test\_return\_by\_value(32) );
00231   \textcolor{comment}{//CALL\_SUBTEST( ( test\_complex2d<float,4,8> () ) ); CALL\_SUBTEST( ( test\_complex2d<double,4,8> () ) );}
00232   \textcolor{comment}{//CALL\_SUBTEST( ( test\_complex2d<long double,4,8> () ) );}
00233   CALL\_SUBTEST( test\_complex<float>(32) ); CALL\_SUBTEST( test\_complex<double>(32) ); 
00234   CALL\_SUBTEST( test\_complex<float>(256) ); CALL\_SUBTEST( test\_complex<double>(256) ); 
00235   CALL\_SUBTEST( test\_complex<float>(3*8) ); CALL\_SUBTEST( test\_complex<double>(3*8) ); 
00236   CALL\_SUBTEST( test\_complex<float>(5*32) ); CALL\_SUBTEST( test\_complex<double>(5*32) ); 
00237   CALL\_SUBTEST( test\_complex<float>(2*3*4) ); CALL\_SUBTEST( test\_complex<double>(2*3*4) ); 
00238   CALL\_SUBTEST( test\_complex<float>(2*3*4*5) ); CALL\_SUBTEST( test\_complex<double>(2*3*4*5) ); 
00239   CALL\_SUBTEST( test\_complex<float>(2*3*4*5*7) ); CALL\_SUBTEST( test\_complex<double>(2*3*4*5*7) ); 
00240 
00241   CALL\_SUBTEST( test\_scalar<float>(32) ); CALL\_SUBTEST( test\_scalar<double>(32) ); 
00242   CALL\_SUBTEST( test\_scalar<float>(45) ); CALL\_SUBTEST( test\_scalar<double>(45) ); 
00243   CALL\_SUBTEST( test\_scalar<float>(50) ); CALL\_SUBTEST( test\_scalar<double>(50) ); 
00244   CALL\_SUBTEST( test\_scalar<float>(256) ); CALL\_SUBTEST( test\_scalar<double>(256) ); 
00245   CALL\_SUBTEST( test\_scalar<float>(2*3*4*5*7) ); CALL\_SUBTEST( test\_scalar<double>(2*3*4*5*7) ); 
00246   
00247 \textcolor{preprocessor}{  #ifdef EIGEN\_HAS\_FFTWL}
00248   CALL\_SUBTEST( test\_complex<long double>(32) );
00249   CALL\_SUBTEST( test\_complex<long double>(256) );
00250   CALL\_SUBTEST( test\_complex<long double>(3*8) );
00251   CALL\_SUBTEST( test\_complex<long double>(5*32) );
00252   CALL\_SUBTEST( test\_complex<long double>(2*3*4) );
00253   CALL\_SUBTEST( test\_complex<long double>(2*3*4*5) );
00254   CALL\_SUBTEST( test\_complex<long double>(2*3*4*5*7) );
00255   
00256   CALL\_SUBTEST( test\_scalar<long double>(32) );
00257   CALL\_SUBTEST( test\_scalar<long double>(45) );
00258   CALL\_SUBTEST( test\_scalar<long double>(50) );
00259   CALL\_SUBTEST( test\_scalar<long double>(256) );
00260   CALL\_SUBTEST( test\_scalar<long double>(2*3*4*5*7) );
00261 \textcolor{preprocessor}{  #endif}
00262 \}
\end{DoxyCode}
