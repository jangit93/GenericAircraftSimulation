\hypertarget{eigen_2test_2redux_8cpp_source}{}\section{eigen/test/redux.cpp}
\label{eigen_2test_2redux_8cpp_source}\index{redux.\+cpp@{redux.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#define TEST\_ENABLE\_TEMPORARY\_TRACKING}
00012 
00013 \textcolor{preprocessor}{#include "main.h"}
00014 
00015 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} matrixRedux(\textcolor{keyword}{const} MatrixType& m)
00016 \{
00017   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00018   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00019   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00020 
00021   Index rows = m.rows();
00022   Index cols = m.cols();
00023 
00024   MatrixType m1 = MatrixType::Random(rows, cols);
00025 
00026   \textcolor{comment}{// The entries of m1 are uniformly distributed in [0,1], so m1.prod() is very small. This may lead to
       test}
00027   \textcolor{comment}{// failures if we underflow into denormals. Thus, we scale so that entries are close to 1.}
00028   MatrixType m1\_for\_prod = MatrixType::Ones(rows, cols) + RealScalar(0.2) * m1;
00029 
00030   VERIFY\_IS\_MUCH\_SMALLER\_THAN(MatrixType::Zero(rows, cols).sum(), Scalar(1));
00031   VERIFY\_IS\_APPROX(MatrixType::Ones(rows, cols).sum(), Scalar(\textcolor{keywordtype}{float}(rows*cols))); \textcolor{comment}{// the float() here to
       shut up excessive MSVC warning about int->complex conversion being lossy}
00032   Scalar s(0), p(1), minc(numext::real(m1.coeff(0))), maxc(numext::real(m1.coeff(0)));
00033   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < cols; j++)
00034   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < rows; i++)
00035   \{
00036     s += m1(i,j);
00037     p *= m1\_for\_prod(i,j);
00038     minc = (std::min)(numext::real(minc), numext::real(m1(i,j)));
00039     maxc = (std::max)(numext::real(maxc), numext::real(m1(i,j)));
00040   \}
00041   \textcolor{keyword}{const} Scalar mean = s/Scalar(RealScalar(rows*cols));
00042 
00043   VERIFY\_IS\_APPROX(m1.sum(), s);
00044   VERIFY\_IS\_APPROX(m1.mean(), mean);
00045   VERIFY\_IS\_APPROX(m1\_for\_prod.prod(), p);
00046   VERIFY\_IS\_APPROX(m1.real().minCoeff(), numext::real(minc));
00047   VERIFY\_IS\_APPROX(m1.real().maxCoeff(), numext::real(maxc));
00048 
00049   \textcolor{comment}{// test slice vectorization assuming assign is ok}
00050   Index r0 = internal::random<Index>(0,rows-1);
00051   Index c0 = internal::random<Index>(0,cols-1);
00052   Index r1 = internal::random<Index>(r0+1,rows)-r0;
00053   Index c1 = internal::random<Index>(c0+1,cols)-c0;
00054   VERIFY\_IS\_APPROX(m1.block(r0,c0,r1,c1).sum(), m1.block(r0,c0,r1,c1).eval().sum());
00055   VERIFY\_IS\_APPROX(m1.block(r0,c0,r1,c1).mean(), m1.block(r0,c0,r1,c1).eval().mean());
00056   VERIFY\_IS\_APPROX(m1\_for\_prod.block(r0,c0,r1,c1).prod(), m1\_for\_prod.block(r0,c0,r1,c1).eval().prod());
00057   VERIFY\_IS\_APPROX(m1.block(r0,c0,r1,c1).real().minCoeff(), m1.block(r0,c0,r1,c1).real().eval().minCoeff())
      ;
00058   VERIFY\_IS\_APPROX(m1.block(r0,c0,r1,c1).real().maxCoeff(), m1.block(r0,c0,r1,c1).real().eval().maxCoeff())
      ;
00059 
00060   \textcolor{comment}{// regression for bug 1090}
00061   \textcolor{keyword}{const} \textcolor{keywordtype}{int} R1 = MatrixType::RowsAtCompileTime>=2 ? MatrixType::RowsAtCompileTime/2 : 6;
00062   \textcolor{keyword}{const} \textcolor{keywordtype}{int} C1 = MatrixType::ColsAtCompileTime>=2 ? MatrixType::ColsAtCompileTime/2 : 6;
00063   \textcolor{keywordflow}{if}(R1<=rows-r0 && C1<=cols-c0)
00064   \{
00065     VERIFY\_IS\_APPROX( (m1.template block<R1,C1>(r0,c0).sum()), m1.block(r0,c0,R1,C1).sum() );
00066   \}
00067   
00068   \textcolor{comment}{// test empty objects}
00069   VERIFY\_IS\_APPROX(m1.block(r0,c0,0,0).sum(),   Scalar(0));
00070   VERIFY\_IS\_APPROX(m1.block(r0,c0,0,0).prod(),  Scalar(1));
00071 
00072   \textcolor{comment}{// test nesting complex expression}
00073   VERIFY\_EVALUATION\_COUNT( (m1.matrix()*m1.matrix().transpose()).sum(), (MatrixType::IsVectorAtCompileTime 
      && MatrixType::SizeAtCompileTime!=1 ? 0 : 1) );
00074   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, MatrixType::RowsAtCompileTime>}
       m2(rows,rows);
00075   m2.setRandom();
00076   VERIFY\_EVALUATION\_COUNT( ((m1.matrix()*m1.matrix().transpose())+m2).sum(),(
      MatrixType::IsVectorAtCompileTime && MatrixType::SizeAtCompileTime!=1 ? 0 : 1));
00077 \}
00078 
00079 \textcolor{keyword}{template}<\textcolor{keyword}{typename} VectorType> \textcolor{keywordtype}{void} vectorRedux(\textcolor{keyword}{const} \hyperlink{struct_vector_type}{VectorType}& w)
00080 \{
00081   \textcolor{keyword}{using} std::abs;
00082   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::Index Index;
00083   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::Scalar Scalar;
00084   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00085   Index size = w.size();
00086 
00087   \hyperlink{struct_vector_type}{VectorType} v = VectorType::Random(size);
00088   \hyperlink{struct_vector_type}{VectorType} v\_for\_prod = VectorType::Ones(size) + Scalar(0.2) * v; \textcolor{comment}{// see comment above
       declaration of m1\_for\_prod}
00089 
00090   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 1; i < size; i++)
00091   \{
00092     Scalar s(0), p(1);
00093     RealScalar minc(numext::real(v.coeff(0))), maxc(numext::real(v.coeff(0)));
00094     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < i; j++)
00095     \{
00096       s += v[j];
00097       p *= v\_for\_prod[j];
00098       minc = (std::min)(minc, numext::real(v[j]));
00099       maxc = (std::max)(maxc, numext::real(v[j]));
00100     \}
00101     VERIFY\_IS\_MUCH\_SMALLER\_THAN(abs(s - v.head(i).sum()), Scalar(1));
00102     VERIFY\_IS\_APPROX(p, v\_for\_prod.head(i).prod());
00103     VERIFY\_IS\_APPROX(minc, v.real().head(i).minCoeff());
00104     VERIFY\_IS\_APPROX(maxc, v.real().head(i).maxCoeff());
00105   \}
00106 
00107   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size-1; i++)
00108   \{
00109     Scalar s(0), p(1);
00110     RealScalar minc(numext::real(v.coeff(i))), maxc(numext::real(v.coeff(i)));
00111     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = i; j < size; j++)
00112     \{
00113       s += v[j];
00114       p *= v\_for\_prod[j];
00115       minc = (std::min)(minc, numext::real(v[j]));
00116       maxc = (std::max)(maxc, numext::real(v[j]));
00117     \}
00118     VERIFY\_IS\_MUCH\_SMALLER\_THAN(abs(s - v.tail(size-i).sum()), Scalar(1));
00119     VERIFY\_IS\_APPROX(p, v\_for\_prod.tail(size-i).prod());
00120     VERIFY\_IS\_APPROX(minc, v.real().tail(size-i).minCoeff());
00121     VERIFY\_IS\_APPROX(maxc, v.real().tail(size-i).maxCoeff());
00122   \}
00123 
00124   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size/2; i++)
00125   \{
00126     Scalar s(0), p(1);
00127     RealScalar minc(numext::real(v.coeff(i))), maxc(numext::real(v.coeff(i)));
00128     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = i; j < size-i; j++)
00129     \{
00130       s += v[j];
00131       p *= v\_for\_prod[j];
00132       minc = (std::min)(minc, numext::real(v[j]));
00133       maxc = (std::max)(maxc, numext::real(v[j]));
00134     \}
00135     VERIFY\_IS\_MUCH\_SMALLER\_THAN(abs(s - v.segment(i, size-2*i).sum()), Scalar(1));
00136     VERIFY\_IS\_APPROX(p, v\_for\_prod.segment(i, size-2*i).prod());
00137     VERIFY\_IS\_APPROX(minc, v.real().segment(i, size-2*i).minCoeff());
00138     VERIFY\_IS\_APPROX(maxc, v.real().segment(i, size-2*i).maxCoeff());
00139   \}
00140   
00141   \textcolor{comment}{// test empty objects}
00142   VERIFY\_IS\_APPROX(v.head(0).sum(),   Scalar(0));
00143   VERIFY\_IS\_APPROX(v.tail(0).prod(),  Scalar(1));
00144   VERIFY\_RAISES\_ASSERT(v.head(0).mean());
00145   VERIFY\_RAISES\_ASSERT(v.head(0).minCoeff());
00146   VERIFY\_RAISES\_ASSERT(v.head(0).maxCoeff());
00147 \}
00148 
00149 \textcolor{keywordtype}{void} test\_redux()
00150 \{
00151   \textcolor{comment}{// the max size cannot be too large, otherwise reduxion operations obviously generate large errors.}
00152   \textcolor{keywordtype}{int} maxsize = (std::min)(100,EIGEN\_TEST\_MAX\_SIZE);
00153   TEST\_SET\_BUT\_UNUSED\_VARIABLE(maxsize);
00154   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00155     CALL\_SUBTEST\_1( matrixRedux(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00156     CALL\_SUBTEST\_1( matrixRedux(\hyperlink{group___core___module_class_eigen_1_1_array}{Array<float, 1, 1>}()) );
00157     CALL\_SUBTEST\_2( matrixRedux(Matrix2f()) );
00158     CALL\_SUBTEST\_2( matrixRedux(Array2f()) );
00159     CALL\_SUBTEST\_2( matrixRedux(Array22f()) );
00160     CALL\_SUBTEST\_3( matrixRedux(Matrix4d()) );
00161     CALL\_SUBTEST\_3( matrixRedux(Array4d()) );
00162     CALL\_SUBTEST\_3( matrixRedux(Array44d()) );
00163     CALL\_SUBTEST\_4( matrixRedux(MatrixXcf(internal::random<int>(1,maxsize), internal::random<int>(1,maxsize
      ))) );
00164     CALL\_SUBTEST\_4( matrixRedux(ArrayXXcf(internal::random<int>(1,maxsize), internal::random<int>(1,maxsize
      ))) );
00165     CALL\_SUBTEST\_5( matrixRedux(MatrixXd (internal::random<int>(1,maxsize), internal::random<int>(1,maxsize
      ))) );
00166     CALL\_SUBTEST\_5( matrixRedux(ArrayXXd (internal::random<int>(1,maxsize), internal::random<int>(1,maxsize
      ))) );
00167     CALL\_SUBTEST\_6( matrixRedux(MatrixXi (internal::random<int>(1,maxsize), internal::random<int>(1,maxsize
      ))) );
00168     CALL\_SUBTEST\_6( matrixRedux(ArrayXXi (internal::random<int>(1,maxsize), internal::random<int>(1,maxsize
      ))) );
00169   \}
00170   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00171     CALL\_SUBTEST\_7( vectorRedux(Vector4f()) );
00172     CALL\_SUBTEST\_7( vectorRedux(Array4f()) );
00173     CALL\_SUBTEST\_5( vectorRedux(VectorXd(internal::random<int>(1,maxsize))) );
00174     CALL\_SUBTEST\_5( vectorRedux(ArrayXd(internal::random<int>(1,maxsize))) );
00175     CALL\_SUBTEST\_8( vectorRedux(VectorXf(internal::random<int>(1,maxsize))) );
00176     CALL\_SUBTEST\_8( vectorRedux(ArrayXf(internal::random<int>(1,maxsize))) );
00177   \}
00178 \}
\end{DoxyCode}
