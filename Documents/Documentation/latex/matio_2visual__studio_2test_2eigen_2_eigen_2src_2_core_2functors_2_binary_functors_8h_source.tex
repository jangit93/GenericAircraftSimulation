\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/functors/\+Binary\+Functors.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source}\index{Binary\+Functors.\+h@{Binary\+Functors.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_BINARY\_FUNCTORS\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_BINARY\_FUNCTORS\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{comment}{//---------- associative binary functors ----------}
00018 
00019 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Arg1, \textcolor{keyword}{typename} Arg2>
00020 \textcolor{keyword}{struct }binary\_op\_base
00021 \{
00022   \textcolor{keyword}{typedef} Arg1 first\_argument\_type;
00023   \textcolor{keyword}{typedef} Arg2 second\_argument\_type;
00024 \};
00025 
00031 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00032 \textcolor{keyword}{struct }scalar\_sum\_op : binary\_op\_base<LhsScalar,RhsScalar>
00033 \{
00034   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_sum\_op>::ReturnType result\_type;
00035 \textcolor{preprocessor}{#ifndef EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN}
00036   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_sum\_op)
00037 \textcolor{preprocessor}{#else}
00038   scalar\_sum\_op() \{
00039     EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN
00040   \}
00041 \textcolor{preprocessor}{#endif}
00042   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a + b; \}
00043   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00044   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{const} Packet& b)\textcolor{keyword}{ const}
00045 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::padd(a,b); \}
00046   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00047   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type predux(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const}
00048 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::predux(a); \}
00049 \};
00050 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00051 \textcolor{keyword}{struct }functor\_traits<scalar\_sum\_op<LhsScalar,RhsScalar> > \{
00052   \textcolor{keyword}{enum} \{
00053     Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)/2, \textcolor{comment}{// rough estimate!}
00054     PacketAccess = is\_same<LhsScalar,RhsScalar>::value && packet\_traits<LhsScalar>::HasAdd && 
      packet\_traits<RhsScalar>::HasAdd
00055     \textcolor{comment}{// TODO vectorize mixed sum}
00056   \};
00057 \};
00058 
00064 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }scalar\_sum\_op<bool,bool> : scalar\_sum\_op<int,int> \{
00065   EIGEN\_DEPRECATED
00066   scalar\_sum\_op() \{\}
00067 \};
00068 
00069 
00075 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00076 \textcolor{keyword}{struct }scalar\_product\_op  : binary\_op\_base<LhsScalar,RhsScalar>
00077 \{
00078   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_product\_op>::ReturnType result\_type;
00079 \textcolor{preprocessor}{#ifndef EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN}
00080   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_product\_op)
00081 \textcolor{preprocessor}{#else}
00082   scalar\_product\_op() \{
00083     EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN
00084   \}
00085 \textcolor{preprocessor}{#endif}
00086   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a * b; \}
00087   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00088   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{const} Packet& b)\textcolor{keyword}{ const}
00089 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pmul(a,b); \}
00090   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00091   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type predux(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const}
00092 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::predux\_mul(a); \}
00093 \};
00094 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00095 \textcolor{keyword}{struct }functor\_traits<scalar\_product\_op<LhsScalar,RhsScalar> > \{
00096   \textcolor{keyword}{enum} \{
00097     Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost)/2, \textcolor{comment}{// rough estimate!}
00098     PacketAccess = is\_same<LhsScalar,RhsScalar>::value && packet\_traits<LhsScalar>::HasMul && 
      packet\_traits<RhsScalar>::HasMul
00099     \textcolor{comment}{// TODO vectorize mixed product}
00100   \};
00101 \};
00102 
00108 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00109 \textcolor{keyword}{struct }scalar\_conj\_product\_op  : binary\_op\_base<LhsScalar,RhsScalar>
00110 \{
00111 
00112   \textcolor{keyword}{enum} \{
00113     Conj = NumTraits<LhsScalar>::IsComplex
00114   \};
00115   
00116   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_conj\_product\_op>::ReturnType result\_type
      ;
00117   
00118   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_conj\_product\_op)
00119   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const}
00120 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} conj\_helper<LhsScalar,RhsScalar,Conj,false>().pmul(a,b); \}
00121   
00122   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00123   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{const} Packet& b)\textcolor{keyword}{ const}
00124 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} conj\_helper<Packet,Packet,Conj,false>().pmul(a,b); \}
00125 \};
00126 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00127 \textcolor{keyword}{struct }functor\_traits<scalar\_conj\_product\_op<LhsScalar,RhsScalar> > \{
00128   \textcolor{keyword}{enum} \{
00129     Cost = NumTraits<LhsScalar>::MulCost,
00130     PacketAccess = internal::is\_same<LhsScalar, RhsScalar>::value && packet\_traits<LhsScalar>::HasMul
00131   \};
00132 \};
00133 
00139 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00140 \textcolor{keyword}{struct }scalar\_min\_op : binary\_op\_base<LhsScalar,RhsScalar>
00141 \{
00142   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_min\_op>::ReturnType result\_type;
00143   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_min\_op)
00144   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::mini(a, b); \}
00145   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00146   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{const} Packet& b)\textcolor{keyword}{ const}
00147 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pmin(a,b); \}
00148   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00149   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type predux(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const}
00150 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::predux\_min(a); \}
00151 \};
00152 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00153 \textcolor{keyword}{struct }functor\_traits<scalar\_min\_op<LhsScalar,RhsScalar> > \{
00154   \textcolor{keyword}{enum} \{
00155     Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)/2,
00156     PacketAccess = internal::is\_same<LhsScalar, RhsScalar>::value && packet\_traits<LhsScalar>::HasMin
00157   \};
00158 \};
00159 
00165 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00166 \textcolor{keyword}{struct }scalar\_max\_op  : binary\_op\_base<LhsScalar,RhsScalar>
00167 \{
00168   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_max\_op>::ReturnType result\_type;
00169   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_max\_op)
00170   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::maxi(a, b); \}
00171   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00172   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{const} Packet& b)\textcolor{keyword}{ const}
00173 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pmax(a,b); \}
00174   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00175   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type predux(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const}
00176 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::predux\_max(a); \}
00177 \};
00178 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00179 \textcolor{keyword}{struct }functor\_traits<scalar\_max\_op<LhsScalar,RhsScalar> > \{
00180   \textcolor{keyword}{enum} \{
00181     Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)/2,
00182     PacketAccess = internal::is\_same<LhsScalar, RhsScalar>::value && packet\_traits<LhsScalar>::HasMax
00183   \};
00184 \};
00185 
00190 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, ComparisonName cmp> \textcolor{keyword}{struct }scalar\_cmp\_op;
00191 
00192 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, ComparisonName cmp>
00193 \textcolor{keyword}{struct }functor\_traits<scalar\_cmp\_op<LhsScalar,RhsScalar, cmp> > \{
00194   \textcolor{keyword}{enum} \{
00195     Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)/2,
00196     PacketAccess = \textcolor{keyword}{false}
00197   \};
00198 \};
00199 
00200 \textcolor{keyword}{template}<ComparisonName Cmp, \textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
00201 \textcolor{keyword}{struct }result\_of<scalar\_cmp\_op<LhsScalar, RhsScalar, Cmp>(LhsScalar,RhsScalar)> \{
00202   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} type;
00203 \};
00204 
00205 
00206 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
00207 \textcolor{keyword}{struct }scalar\_cmp\_op<LhsScalar,RhsScalar, cmp\_EQ> : binary\_op\_base<LhsScalar,RhsScalar>
00208 \{
00209   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00210   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_cmp\_op)
00211   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} a==b;\}
00212 \};
00213 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
00214 \textcolor{keyword}{struct }scalar\_cmp\_op<LhsScalar,RhsScalar, cmp\_LT> : binary\_op\_base<LhsScalar,RhsScalar>
00215 \{
00216   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00217   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_cmp\_op)
00218   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} a<b;\}
00219 \};
00220 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
00221 \textcolor{keyword}{struct }scalar\_cmp\_op<LhsScalar,RhsScalar, cmp\_LE> : binary\_op\_base<LhsScalar,RhsScalar>
00222 \{
00223   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00224   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_cmp\_op)
00225   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} a<=b;\}
00226 \};
00227 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
00228 \textcolor{keyword}{struct }scalar\_cmp\_op<LhsScalar,RhsScalar, cmp\_GT> : binary\_op\_base<LhsScalar,RhsScalar>
00229 \{
00230   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00231   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_cmp\_op)
00232   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} a>b;\}
00233 \};
00234 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
00235 \textcolor{keyword}{struct }scalar\_cmp\_op<LhsScalar,RhsScalar, cmp\_GE> : binary\_op\_base<LhsScalar,RhsScalar>
00236 \{
00237   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00238   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_cmp\_op)
00239   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} a>=b;\}
00240 \};
00241 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
00242 \textcolor{keyword}{struct }scalar\_cmp\_op<LhsScalar,RhsScalar, cmp\_UNORD> : binary\_op\_base<LhsScalar,RhsScalar>
00243 \{
00244   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00245   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_cmp\_op)
00246   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} !(a<=b || b<=a);\}
00247 \};
00248 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
00249 \textcolor{keyword}{struct }scalar\_cmp\_op<LhsScalar,RhsScalar, cmp\_NEQ> : binary\_op\_base<LhsScalar,RhsScalar>
00250 \{
00251   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00252   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_cmp\_op)
00253   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} a!=b;\}
00254 \};
00255 
00256 
00262 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00263 \textcolor{keyword}{struct }scalar\_hypot\_op<Scalar,Scalar> : binary\_op\_base<Scalar,Scalar>
00264 \{
00265   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_hypot\_op)
00266 \textcolor{comment}{//   typedef typename NumTraits<Scalar>::Real result\_type;}
00267   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& \_x, \textcolor{keyword}{const} Scalar& \_y)\textcolor{keyword}{ const}
00268 \textcolor{keyword}{  }\{
00269     EIGEN\_USING\_STD\_MATH(sqrt)
00270     Scalar p, qp;
00271     \textcolor{keywordflow}{if}(\_x>\_y)
00272     \{
00273       p = \_x;
00274       qp = \_y / p;
00275     \}
00276     \textcolor{keywordflow}{else}
00277     \{
00278       p = \_y;
00279       qp = \_x / p;
00280     \}
00281     \textcolor{keywordflow}{return} p * sqrt(Scalar(1) + qp*qp);
00282   \}
00283 \};
00284 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00285 \textcolor{keyword}{struct }functor\_traits<scalar\_hypot\_op<Scalar,Scalar> > \{
00286   \textcolor{keyword}{enum}
00287   \{
00288     Cost = 3 * NumTraits<Scalar>::AddCost +
00289            2 * NumTraits<Scalar>::MulCost +
00290            2 * scalar\_div\_cost<Scalar,false>::value,
00291     PacketAccess = \textcolor{keyword}{false}
00292   \};
00293 \};
00294 
00298 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Exponent>
00299 \textcolor{keyword}{struct }scalar\_pow\_op  : binary\_op\_base<Scalar,Exponent>
00300 \{
00301   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<Scalar,Exponent,scalar\_pow\_op>::ReturnType result\_type;
00302 \textcolor{preprocessor}{#ifndef EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN}
00303   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_pow\_op)
00304 \textcolor{preprocessor}{#else}
00305   scalar\_pow\_op() \{
00306     \textcolor{keyword}{typedef} Scalar LhsScalar;
00307     \textcolor{keyword}{typedef} Exponent RhsScalar;
00308     EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN
00309   \}
00310 \textcolor{preprocessor}{#endif}
00311   EIGEN\_DEVICE\_FUNC
00312   \textcolor{keyword}{inline} result\_type operator() (\textcolor{keyword}{const} Scalar& a, \textcolor{keyword}{const} Exponent& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::pow(a, b); \}
00313 \};
00314 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Exponent>
00315 \textcolor{keyword}{struct }functor\_traits<scalar\_pow\_op<Scalar,Exponent> > \{
00316   \textcolor{keyword}{enum} \{ Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = \textcolor{keyword}{false} \};
00317 \};
00318 
00319 
00320 
00321 \textcolor{comment}{//---------- non associative binary functors ----------}
00322 
00328 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00329 \textcolor{keyword}{struct }scalar\_difference\_op : binary\_op\_base<LhsScalar,RhsScalar>
00330 \{
00331   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_difference\_op>::ReturnType result\_type;
00332 \textcolor{preprocessor}{#ifndef EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN}
00333   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_difference\_op)
00334 \textcolor{preprocessor}{#else}
00335   scalar\_difference\_op() \{
00336     EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN
00337   \}
00338 \textcolor{preprocessor}{#endif}
00339   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a - b; \}
00340   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00341   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{const} Packet& b)\textcolor{keyword}{ const}
00342 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::psub(a,b); \}
00343 \};
00344 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00345 \textcolor{keyword}{struct }functor\_traits<scalar\_difference\_op<LhsScalar,RhsScalar> > \{
00346   \textcolor{keyword}{enum} \{
00347     Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)/2,
00348     PacketAccess = is\_same<LhsScalar,RhsScalar>::value && packet\_traits<LhsScalar>::HasSub && 
      packet\_traits<RhsScalar>::HasSub
00349   \};
00350 \};
00351 
00357 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00358 \textcolor{keyword}{struct }scalar\_quotient\_op  : binary\_op\_base<LhsScalar,RhsScalar>
00359 \{
00360   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_quotient\_op>::ReturnType result\_type;
00361 \textcolor{preprocessor}{#ifndef EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN}
00362   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_quotient\_op)
00363 \textcolor{preprocessor}{#else}
00364   scalar\_quotient\_op() \{
00365     EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN
00366   \}
00367 \textcolor{preprocessor}{#endif}
00368   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a / b; \}
00369   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00370   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{const} Packet& b)\textcolor{keyword}{ const}
00371 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pdiv(a,b); \}
00372 \};
00373 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
00374 \textcolor{keyword}{struct }functor\_traits<scalar\_quotient\_op<LhsScalar,RhsScalar> > \{
00375   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} scalar\_quotient\_op<LhsScalar,RhsScalar>::result\_type result\_type;
00376   \textcolor{keyword}{enum} \{
00377     PacketAccess = is\_same<LhsScalar,RhsScalar>::value && packet\_traits<LhsScalar>::HasDiv && 
      packet\_traits<RhsScalar>::HasDiv,
00378     Cost = scalar\_div\_cost<result\_type,PacketAccess>::value
00379   \};
00380 \};
00381 
00382 
00383 
00389 \textcolor{keyword}{struct }scalar\_boolean\_and\_op \{
00390   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_boolean\_and\_op)
00391   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator() (\textcolor{keyword}{const} \textcolor{keywordtype}{bool}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a && 
      b; \}
00392 \};
00393 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }functor\_traits<scalar\_boolean\_and\_op> \{
00394   \textcolor{keyword}{enum} \{
00395     Cost = NumTraits<bool>::AddCost,
00396     PacketAccess = \textcolor{keyword}{false}
00397   \};
00398 \};
00399 
00405 \textcolor{keyword}{struct }scalar\_boolean\_or\_op \{
00406   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_boolean\_or\_op)
00407   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator() (\textcolor{keyword}{const} \textcolor{keywordtype}{bool}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a || 
      b; \}
00408 \};
00409 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }functor\_traits<scalar\_boolean\_or\_op> \{
00410   \textcolor{keyword}{enum} \{
00411     Cost = NumTraits<bool>::AddCost,
00412     PacketAccess = \textcolor{keyword}{false}
00413   \};
00414 \};
00415 
00421 \textcolor{keyword}{struct }scalar\_boolean\_xor\_op \{
00422   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_boolean\_xor\_op)
00423   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator() (\textcolor{keyword}{const} \textcolor{keywordtype}{bool}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a ^ b
      ; \}
00424 \};
00425 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }functor\_traits<scalar\_boolean\_xor\_op> \{
00426   \textcolor{keyword}{enum} \{
00427     Cost = NumTraits<bool>::AddCost,
00428     PacketAccess = \textcolor{keyword}{false}
00429   \};
00430 \};
00431 
00432 
00433 
00434 \textcolor{comment}{//---------- binary functors bound to a constant, thus appearing as a unary functor ----------}
00435 
00436 \textcolor{comment}{// The following two classes permits to turn any binary functor into a unary one with one argument bound to
       a constant value.}
00437 \textcolor{comment}{// They are analogues to std::binder1st/binder2nd but with the following differences:}
00438 \textcolor{comment}{//  - they are compatible with packetOp}
00439 \textcolor{comment}{//  - they are portable across C++ versions (the std::binder* are deprecated in C++11)}
00440 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp> \textcolor{keyword}{struct }bind1st\_op : BinaryOp \{
00441 
00442   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BinaryOp::first\_argument\_type  first\_argument\_type;
00443   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BinaryOp::second\_argument\_type second\_argument\_type;
00444   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BinaryOp::result\_type          result\_type;
00445 
00446   bind1st\_op(\textcolor{keyword}{const} first\_argument\_type &val) : m\_value(val) \{\}
00447 
00448   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} second\_argument\_type& b)\textcolor{keyword}{ const }
      \{ \textcolor{keywordflow}{return} BinaryOp::operator()(m\_value,b); \}
00449 
00450   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00451   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& b)\textcolor{keyword}{ const}
00452 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} BinaryOp::packetOp(internal::pset1<Packet>(m\_value), b); \}
00453 
00454   first\_argument\_type m\_value;
00455 \};
00456 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp> \textcolor{keyword}{struct }functor\_traits<bind1st\_op<BinaryOp> > : functor\_traits<BinaryOp> \{\};
00457 
00458 
00459 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp> \textcolor{keyword}{struct }bind2nd\_op : BinaryOp \{
00460 
00461   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BinaryOp::first\_argument\_type  first\_argument\_type;
00462   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BinaryOp::second\_argument\_type second\_argument\_type;
00463   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BinaryOp::result\_type          result\_type;
00464 
00465   bind2nd\_op(\textcolor{keyword}{const} second\_argument\_type &val) : m\_value(val) \{\}
00466 
00467   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} first\_argument\_type& a)\textcolor{keyword}{ const }\{
       \textcolor{keywordflow}{return} BinaryOp::operator()(a,m\_value); \}
00468 
00469   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00470   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const}
00471 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} BinaryOp::packetOp(a,internal::pset1<Packet>(m\_value)); \}
00472 
00473   second\_argument\_type m\_value;
00474 \};
00475 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp> \textcolor{keyword}{struct }functor\_traits<bind2nd\_op<BinaryOp> > : functor\_traits<BinaryOp> \{\};
00476 
00477 
00478 \} \textcolor{comment}{// end namespace internal}
00479 
00480 \} \textcolor{comment}{// end namespace Eigen}
00481 
00482 \textcolor{preprocessor}{#endif // EIGEN\_BINARY\_FUNCTORS\_H}
\end{DoxyCode}
