\hypertarget{eigen_2_eigen_2src_2_geometry_2_umeyama_8h_source}{}\section{eigen/\+Eigen/src/\+Geometry/\+Umeyama.h}
\label{eigen_2_eigen_2src_2_geometry_2_umeyama_8h_source}\index{Umeyama.\+h@{Umeyama.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Hauke Heibel <hauke.heibel@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_UMEYAMA\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_UMEYAMA\_H}
00012 
00013 \textcolor{comment}{// This file requires the user to include }
00014 \textcolor{comment}{// * Eigen/Core}
00015 \textcolor{comment}{// * Eigen/LU }
00016 \textcolor{comment}{// * Eigen/SVD}
00017 \textcolor{comment}{// * Eigen/Array}
00018 
00019 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00020 
00021 \textcolor{preprocessor}{#ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00022 
00023 \textcolor{comment}{// These helpers are required since it allows to use mixed types as parameters}
00024 \textcolor{comment}{// for the Umeyama. The problem with mixed parameters is that the return type}
00025 \textcolor{comment}{// cannot trivially be deduced when float and double types are mixed.}
00026 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00027 
00028 \textcolor{comment}{// Compile time return type deduction for different MatrixBase types.}
00029 \textcolor{comment}{// Different means here different alignment and parameters but the same underlying}
00030 \textcolor{comment}{// real scalar type.}
00031 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} OtherMatrixType>
\Hypertarget{eigen_2_eigen_2src_2_geometry_2_umeyama_8h_source_l00032}\hyperlink{struct_eigen_1_1internal_1_1umeyama__transform__matrix__type}{00032} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1umeyama__transform__matrix__type}{umeyama\_transform\_matrix\_type}
00033 \{
00034   \textcolor{keyword}{enum} \{
00035     MinRowsAtCompileTime = EIGEN\_SIZE\_MIN\_PREFER\_DYNAMIC(MatrixType::RowsAtCompileTime, 
      OtherMatrixType::RowsAtCompileTime),
00036 
00037     \textcolor{comment}{// When possible we want to choose some small fixed size value since the result}
00038     \textcolor{comment}{// is likely to fit on the stack. So here, EIGEN\_SIZE\_MIN\_PREFER\_DYNAMIC is not what we want.}
00039     HomogeneousDimension = int(MinRowsAtCompileTime) == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} ? \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} : int(
      MinRowsAtCompileTime)+1
00040   \};
00041 
00042   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<typename traits<MatrixType>::Scalar},
00043     HomogeneousDimension,
00044     HomogeneousDimension,
00045     \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a28d63c0dd8560827162decfd898804f4}{AutoAlign} | (\hyperlink{struct_eigen_1_1internal_1_1traits}{traits<MatrixType>::Flags} & 
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}),
00046     HomogeneousDimension,
00047     HomogeneousDimension
00048   > \hyperlink{group___core___module_class_eigen_1_1_matrix}{type};
00049 \};
00050 
00051 \}
00052 
00053 \textcolor{preprocessor}{#endif}
00054 
00093 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>
00094 \textcolor{keyword}{typename} \hyperlink{group___core___module_class_eigen_1_1_matrix}{internal::umeyama\_transform\_matrix\_type<Derived, OtherDerived>::type}
\Hypertarget{eigen_2_eigen_2src_2_geometry_2_umeyama_8h_source_l00095}\hyperlink{group___geometry___module_ga033d6550c1fc82e232f2b4c380c19a54}{00095} \hyperlink{group___geometry___module_ga033d6550c1fc82e232f2b4c380c19a54}{umeyama}(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& src, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<OtherDerived>}& dst, \textcolor{keywordtype}{bool} with\_scaling = \textcolor{keyword}{true})
00096 \{
00097   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{internal::umeyama\_transform\_matrix\_type<Derived, OtherDerived>::type}
       TransformationMatrixType;
00098   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<TransformationMatrixType>::Scalar}
       Scalar;
00099   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00100 
00101   EIGEN\_STATIC\_ASSERT(!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsComplex}, NUMERIC\_TYPE\_MUST\_BE\_REAL)
00102   EIGEN\_STATIC\_ASSERT((\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same}<Scalar, \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<OtherDerived>::Scalar}>::value),
00103     
      YOU\_MIXED\_DIFFERENT\_NUMERIC\_TYPES\_\_YOU\_NEED\_TO\_USE\_THE\_CAST\_METHOD\_OF\_MATRIXBASE\_TO\_CAST\_NUMERIC\_TYPES\_EXPLICITLY)
00104 
00105   \textcolor{keyword}{enum} \{ Dimension = EIGEN\_SIZE\_MIN\_PREFER\_DYNAMIC(Derived::RowsAtCompileTime, 
      OtherDerived::RowsAtCompileTime) \};
00106 
00107   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dimension, 1>} \hyperlink{struct_vector_type}{VectorType};
00108   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dimension, Dimension>} MatrixType;
00109   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_class_eigen_1_1_matrix}{internal::plain\_matrix\_type\_row\_major<Derived>::type}
       RowMajorMatrixType;
00110 
00111   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m = src.rows(); \textcolor{comment}{// dimension}
00112   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = src.cols(); \textcolor{comment}{// number of measurements}
00113 
00114   \textcolor{comment}{// required for demeaning ...}
00115   \textcolor{keyword}{const} RealScalar one\_over\_n = RealScalar(1) / \textcolor{keyword}{static\_cast<}RealScalar\textcolor{keyword}{>}(n);
00116 
00117   \textcolor{comment}{// computation of mean}
00118   \textcolor{keyword}{const} VectorType src\_mean = src.\hyperlink{group___core___module_af9662cd704ffc16c5b88c7b2d331576f}{rowwise}().sum() * one\_over\_n;
00119   \textcolor{keyword}{const} VectorType dst\_mean = dst.\hyperlink{group___core___module_af9662cd704ffc16c5b88c7b2d331576f}{rowwise}().sum() * one\_over\_n;
00120 
00121   \textcolor{comment}{// demeaning of src and dst points}
00122   \textcolor{keyword}{const} RowMajorMatrixType src\_demean = src.\hyperlink{group___core___module_a978724c07b70cb9b8fdef67a4de08788}{colwise}() - src\_mean;
00123   \textcolor{keyword}{const} RowMajorMatrixType dst\_demean = dst.\hyperlink{group___core___module_a978724c07b70cb9b8fdef67a4de08788}{colwise}() - dst\_mean;
00124 
00125   \textcolor{comment}{// Eq. (36)-(37)}
00126   \textcolor{keyword}{const} Scalar src\_var = src\_demean.rowwise().squaredNorm().sum() * one\_over\_n;
00127 
00128   \textcolor{comment}{// Eq. (38)}
00129   \textcolor{keyword}{const} MatrixType sigma = one\_over\_n * dst\_demean * src\_demean.transpose();
00130 
00131   \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD<MatrixType>} svd(sigma, \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a2b4f91ca5859a4159dbfe8090043817f}{ComputeFullU} | 
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a52c6f7e80bbf9a42297c88f700245b51}{ComputeFullV});
00132 
00133   \textcolor{comment}{// Initialize the resulting transformation with an identity matrix...}
00134   TransformationMatrixType Rt = TransformationMatrixType::Identity(m+1,m+1);
00135 
00136   \textcolor{comment}{// Eq. (39)}
00137   VectorType S = VectorType::Ones(m);
00138 
00139   \textcolor{keywordflow}{if}  ( svd.\hyperlink{group___s_v_d___module_afc7fe1546b0f6e1801b86f22f5664cb8}{matrixU}().determinant() * svd.\hyperlink{group___s_v_d___module_a245a453b5e7347f737295c23133238c4}{matrixV}().determinant() < 0 )
00140     S(m-1) = -1;
00141 
00142   \textcolor{comment}{// Eq. (40) and (43)}
00143   Rt.block(0,0,m,m).noalias() = svd.\hyperlink{group___s_v_d___module_afc7fe1546b0f6e1801b86f22f5664cb8}{matrixU}() * S.asDiagonal() * svd.
      \hyperlink{group___s_v_d___module_a245a453b5e7347f737295c23133238c4}{matrixV}().transpose();
00144 
00145   \textcolor{keywordflow}{if} (with\_scaling)
00146   \{
00147     \textcolor{comment}{// Eq. (42)}
00148     \textcolor{keyword}{const} Scalar c = Scalar(1)/src\_var * svd.\hyperlink{group___s_v_d___module_a4e7bac123570c348f7ed6be909e1e474}{singularValues}().dot(S);
00149 
00150     \textcolor{comment}{// Eq. (41)}
00151     Rt.col(m).head(m) = dst\_mean;
00152     Rt.col(m).head(m).noalias() -= c*Rt.topLeftCorner(m,m)*src\_mean;
00153     Rt.block(0,0,m,m) *= c;
00154   \}
00155   \textcolor{keywordflow}{else}
00156   \{
00157     Rt.col(m).head(m) = dst\_mean;
00158     Rt.col(m).head(m).noalias() -= Rt.topLeftCorner(m,m)*src\_mean;
00159   \}
00160 
00161   \textcolor{keywordflow}{return} Rt;
00162 \}
00163 
00164 \} \textcolor{comment}{// end namespace Eigen}
00165 
00166 \textcolor{preprocessor}{#endif // EIGEN\_UMEYAMA\_H}
\end{DoxyCode}
