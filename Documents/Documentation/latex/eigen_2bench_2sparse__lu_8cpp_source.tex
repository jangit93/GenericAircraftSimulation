\hypertarget{eigen_2bench_2sparse__lu_8cpp_source}{}\section{eigen/bench/sparse\+\_\+lu.cpp}
\label{eigen_2bench_2sparse__lu_8cpp_source}\index{sparse\+\_\+lu.\+cpp@{sparse\+\_\+lu.\+cpp}}

\begin{DoxyCode}
00001 
00002 \textcolor{comment}{// g++ -I.. sparse\_lu.cpp -O3 -g0 -I /usr/include/superlu/ -lsuperlu -lgfortran -DSIZE=1000 -DDENSITY=.05
       && ./a.out}
00003 
00004 \textcolor{preprocessor}{#define EIGEN\_SUPERLU\_SUPPORT}
00005 \textcolor{preprocessor}{#define EIGEN\_UMFPACK\_SUPPORT}
00006 \textcolor{preprocessor}{#include <Eigen/Sparse>}
00007 
00008 \textcolor{preprocessor}{#define NOGMM}
00009 \textcolor{preprocessor}{#define NOMTL}
00010 
00011 \textcolor{preprocessor}{#ifndef SIZE}
00012 \textcolor{preprocessor}{#define SIZE 10}
00013 \textcolor{preprocessor}{#endif}
00014 
00015 \textcolor{preprocessor}{#ifndef DENSITY}
00016 \textcolor{preprocessor}{#define DENSITY 0.01}
00017 \textcolor{preprocessor}{#endif}
00018 
00019 \textcolor{preprocessor}{#ifndef REPEAT}
00020 \textcolor{preprocessor}{#define REPEAT 1}
00021 \textcolor{preprocessor}{#endif}
00022 
00023 \textcolor{preprocessor}{#include "BenchSparseUtil.h"}
00024 
00025 \textcolor{preprocessor}{#ifndef MINDENSITY}
00026 \textcolor{preprocessor}{#define MINDENSITY 0.0004}
00027 \textcolor{preprocessor}{#endif}
00028 
00029 \textcolor{preprocessor}{#ifndef NBTRIES}
00030 \textcolor{preprocessor}{#define NBTRIES 10}
00031 \textcolor{preprocessor}{#endif}
00032 
00033 \textcolor{preprocessor}{#define BENCH(X) \(\backslash\)}
00034 \textcolor{preprocessor}{  timer.reset(); \(\backslash\)}
00035 \textcolor{preprocessor}{  for (int \_j=0; \_j<NBTRIES; ++\_j) \{ \(\backslash\)}
00036 \textcolor{preprocessor}{    timer.start(); \(\backslash\)}
00037 \textcolor{preprocessor}{    for (int \_k=0; \_k<REPEAT; ++\_k) \{ \(\backslash\)}
00038 \textcolor{preprocessor}{        X  \(\backslash\)}
00039 \textcolor{preprocessor}{  \} timer.stop(); \}}
00040 
00041 \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} \hyperlink{group___core___module}{VectorX};
00042 
00043 \textcolor{preprocessor}{#include <Eigen/LU>}
00044 
00045 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Backend>
00046 \textcolor{keywordtype}{void} doEigen(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* name, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{EigenSparseMatrix}& sm1, \textcolor{keyword}{const} 
      \hyperlink{group___core___module}{VectorX}& b, \hyperlink{group___core___module}{VectorX}& x, \textcolor{keywordtype}{int} flags = 0)
00047 \{
00048   std::cout << name << \textcolor{stringliteral}{"..."} << std::flush;
00049   \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} timer; timer.start();
00050   \hyperlink{group___sparse_l_u___module_class_eigen_1_1_sparse_l_u}{SparseLU<EigenSparseMatrix,Backend>} lu(sm1, flags);
00051   timer.stop();
00052   \textcolor{keywordflow}{if} (lu.succeeded())
00053     std::cout << \textcolor{stringliteral}{":\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00054   \textcolor{keywordflow}{else}
00055   \{
00056     std::cout << \textcolor{stringliteral}{":\(\backslash\)t FAILED"} << endl;
00057     \textcolor{keywordflow}{return};
00058   \}
00059 
00060   \textcolor{keywordtype}{bool} ok;
00061   timer.reset(); timer.start();
00062   ok = lu.solve(b,&x);
00063   timer.stop();
00064   \textcolor{keywordflow}{if} (ok)
00065     std::cout << \textcolor{stringliteral}{"  solve:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00066   \textcolor{keywordflow}{else}
00067     std::cout << \textcolor{stringliteral}{"  solve:\(\backslash\)t"} << \textcolor{stringliteral}{" FAILED"} << endl;
00068 
00069   \textcolor{comment}{//std::cout << x.transpose() << "\(\backslash\)n";}
00070 \}
00071 
00072 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[])
00073 \{
00074   \textcolor{keywordtype}{int} rows = SIZE;
00075   \textcolor{keywordtype}{int} cols = SIZE;
00076   \textcolor{keywordtype}{float} density = DENSITY;
00077   \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} timer;
00078 
00079   \hyperlink{group___core___module}{VectorX} b = VectorX::Random(cols);
00080   \hyperlink{group___core___module}{VectorX} x = VectorX::Random(cols);
00081 
00082   \textcolor{keywordtype}{bool} densedone = \textcolor{keyword}{false};
00083 
00084   \textcolor{comment}{//for (float density = DENSITY; density>=MINDENSITY; density*=0.5)}
00085 \textcolor{comment}{//   float density = 0.5;}
00086   \{
00087     \hyperlink{group___sparse_core___module}{EigenSparseMatrix} sm1(rows, cols);
00088     fillMatrix(density, rows, cols, sm1);
00089 
00090     \textcolor{comment}{// dense matrices}
00091 \textcolor{preprocessor}{    #ifdef DENSEMATRIX}
00092     \textcolor{keywordflow}{if} (!densedone)
00093     \{
00094       densedone = \textcolor{keyword}{true};
00095       std::cout << \textcolor{stringliteral}{"Eigen Dense\(\backslash\)t"} << density*100 << \textcolor{stringliteral}{"%\(\backslash\)n"};
00096       \hyperlink{group___core___module}{DenseMatrix} m1(rows,cols);
00097       eiToDense(sm1, m1);
00098 
00099       \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} timer;
00100       timer.start();
00101       \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU<DenseMatrix>} lu(m1);
00102       timer.stop();
00103       std::cout << \textcolor{stringliteral}{"Eigen/dense:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00104 
00105       timer.reset();
00106       timer.start();
00107       lu.solve(b,&x);
00108       timer.stop();
00109       std::cout << \textcolor{stringliteral}{"  solve:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00110 \textcolor{comment}{//       std::cout << b.transpose() << "\(\backslash\)n";}
00111 \textcolor{comment}{//       std::cout << x.transpose() << "\(\backslash\)n";}
00112     \}
00113 \textcolor{preprocessor}{    #endif}
00114 
00115 \textcolor{preprocessor}{    #ifdef EIGEN\_UMFPACK\_SUPPORT}
00116     x.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00117     doEigen<Eigen::UmfPack>(\textcolor{stringliteral}{"Eigen/UmfPack (auto)"}, sm1, b, x, 0);
00118 \textcolor{preprocessor}{    #endif}
00119 
00120 \textcolor{preprocessor}{    #ifdef EIGEN\_SUPERLU\_SUPPORT}
00121     x.setZero();
00122     doEigen<Eigen::SuperLU>(\textcolor{stringliteral}{"Eigen/SuperLU (nat)"}, sm1, b, x, 
      \hyperlink{group___ordering_methods___module_class_eigen_1_1_natural_ordering}{Eigen::NaturalOrdering});
00123 \textcolor{comment}{//     doEigen<Eigen::SuperLU>("Eigen/SuperLU (MD AT+A)", sm1, b, x, Eigen::MinimumDegree\_AT\_PLUS\_A);}
00124 \textcolor{comment}{//     doEigen<Eigen::SuperLU>("Eigen/SuperLU (MD ATA)", sm1, b, x, Eigen::MinimumDegree\_ATA);}
00125     doEigen<Eigen::SuperLU>(\textcolor{stringliteral}{"Eigen/SuperLU (COLAMD)"}, sm1, b, x, Eigen::ColApproxMinimumDegree);
00126 \textcolor{preprocessor}{    #endif}
00127 
00128   \}
00129 
00130   \textcolor{keywordflow}{return} 0;
00131 \}
00132 
\end{DoxyCode}
