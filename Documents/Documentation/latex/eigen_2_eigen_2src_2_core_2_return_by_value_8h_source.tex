\hypertarget{eigen_2_eigen_2src_2_core_2_return_by_value_8h_source}{}\section{eigen/\+Eigen/src/\+Core/\+Return\+By\+Value.h}
\label{eigen_2_eigen_2src_2_core_2_return_by_value_8h_source}\index{Return\+By\+Value.\+h@{Return\+By\+Value.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2009-2010 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_RETURNBYVALUE\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_RETURNBYVALUE\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00017 
00018 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_return_by_value_8h_source_l00019}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_return_by_value_3_01_derived_01_4_01_4}{00019} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue}<Derived> >
00020   : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<typename traits<Derived>::ReturnType>
00021 \{
00022   \textcolor{keyword}{enum} \{
00023     \textcolor{comment}{// We're disabling the DirectAccess because e.g. the constructor of}
00024     \textcolor{comment}{// the Block-with-DirectAccess expression requires to have a coeffRef method.}
00025     \textcolor{comment}{// Also, we don't want to have to implement the stride stuff.}
00026     Flags = (\hyperlink{struct_eigen_1_1internal_1_1traits}{traits<typename traits<Derived>::ReturnType}>::Flags
00027              | \hyperlink{group__flags_gaa34e83bae46a8eeae4e69ebe3aaecbed}{EvalBeforeNestingBit}) & ~\hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit}
00028   \};
00029 \};
00030 
00031 \textcolor{comment}{/* The ReturnByValue object doesn't even have a coeff() method.}
00032 \textcolor{comment}{ * So the only way that nesting it in an expression can work, is by evaluating it into a plain matrix.}
00033 \textcolor{comment}{ * So internal::nested always gives the plain return matrix type.}
00034 \textcolor{comment}{ *}
00035 \textcolor{comment}{ * FIXME: I don't understand why we need this specialization: isn't this taken care of by the
       EvalBeforeNestingBit ??}
00036 \textcolor{comment}{ * Answer: EvalBeforeNestingBit should be deprecated since we have the evaluators}
00037 \textcolor{comment}{ */}
00038 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived,\textcolor{keywordtype}{int} n,\textcolor{keyword}{typename} PlainObject>
\Hypertarget{eigen_2_eigen_2src_2_core_2_return_by_value_8h_source_l00039}\hyperlink{struct_eigen_1_1internal_1_1nested__eval_3_01_return_by_value_3_01_derived_01_4_00_01n_00_01_plain_object_01_4}{00039} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested__eval}{nested\_eval}<\hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue}<Derived>, n, PlainObject>
00040 \{
00041   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<Derived>::ReturnType} type;
00042 \};
00043 
00044 \} \textcolor{comment}{// end namespace internal}
00045 
\Hypertarget{eigen_2_eigen_2src_2_core_2_return_by_value_8h_source_l00050}\hyperlink{group___core___module}{00050} \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }\hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue}
00051   : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1internal_1_1dense__xpr__base}{internal::dense\_xpr\_base}< ReturnByValue<Derived> >::type, 
      \hyperlink{class_eigen_1_1internal_1_1no__assignment__operator}{internal::no\_assignment\_operator}
00052 \{
00053   \textcolor{keyword}{public}:
00054     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::ReturnType} ReturnType;
00055 
00056     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1dense__xpr__base}{internal::dense\_xpr\_base<ReturnByValue>::type}
       Base;
00057     EIGEN\_DENSE\_PUBLIC\_INTERFACE(\hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue})
00058 
00059     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00060     EIGEN\_DEVICE\_FUNC
00061     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} evalTo(Dest& dst)\textcolor{keyword}{ const}
00062 \textcolor{keyword}{    }\{ \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Derived*\textcolor{keyword}{>}(\textcolor{keyword}{this})->evalTo(dst); \}
00063     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Derived*\textcolor{keyword}{>}(\textcolor{keyword}{this})->rows(); \}
00064     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Derived*\textcolor{keyword}{>}(\textcolor{keyword}{this})->cols(); \}
00065 
00066 \textcolor{preprocessor}{#ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00067 \textcolor{preprocessor}{#define Unusable
       YOU\_ARE\_TRYING\_TO\_ACCESS\_A\_SINGLE\_COEFFICIENT\_IN\_A\_SPECIAL\_EXPRESSION\_WHERE\_THAT\_IS\_NOT\_ALLOWED\_BECAUSE\_THAT\_WOULD\_BE\_INEFFICIENT}
\Hypertarget{eigen_2_eigen_2src_2_core_2_return_by_value_8h_source_l00068}\hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{00068}     \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}\{
00069       \hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}&) \{\}
00070       \hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}& operator=(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}&) \{\textcolor{keywordflow}{return} *\textcolor{keyword}{this};\}
00071     \};
00072     \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}& coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index})\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }
      \hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}*\textcolor{keyword}{>}(\textcolor{keyword}{this}); \}
00073     \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}& coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index})\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }
      \hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}*\textcolor{keyword}{>}(\textcolor{keyword}{this}); \}
00074     \hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}) \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}\hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}*\textcolor{keyword}{>}(\textcolor{keyword}{this}); \}
00075     \hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}) \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}
      \hyperlink{class_eigen_1_1_return_by_value_1_1_unusable}{Unusable}*\textcolor{keyword}{>}(\textcolor{keyword}{this}); \}
00076 \textcolor{preprocessor}{#undef Unusable}
00077 \textcolor{preprocessor}{#endif}
00078 \};
00079 
00080 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00081 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00082 Derived& \hyperlink{group___core___module_a581a7a353bd007b5352f11688e3bc5fa}{DenseBase<Derived>::operator=}(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue<OtherDerived>}& other)
00083 \{
00084   other.evalTo(derived());
00085   \textcolor{keywordflow}{return} derived();
00086 \}
00087 
00088 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00089 
00090 \textcolor{comment}{// Expression is evaluated in a temporary; default implementation of Assignment is bypassed so that}
00091 \textcolor{comment}{// when a ReturnByValue expression is assigned, the evaluator is not constructed.}
00092 \textcolor{comment}{// TODO: Finalize port to new regime; ReturnByValue should not exist in the expression world}
00093   
00094 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_return_by_value_8h_source_l00095}\hyperlink{struct_eigen_1_1internal_1_1evaluator_3_01_return_by_value_3_01_derived_01_4_01_4}{00095} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator}<\hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue}<Derived> >
00096   : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator}<typename internal::traits<Derived>::ReturnType>
00097 \{
00098   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue<Derived>} \hyperlink{group___core___module_class_eigen_1_1_return_by_value}{XprType};
00099   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::ReturnType} PlainObject;
00100   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<PlainObject>} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{Base};
00101   
00102   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator}(\textcolor{keyword}{const} XprType& xpr)
00103     : m\_result(xpr.rows(), xpr.cols())
00104   \{
00105     ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(m\_result);
00106     xpr.evalTo(m\_result);
00107   \}
00108 
00109 \textcolor{keyword}{protected}:
00110   PlainObject m\_result;
00111 \};
00112 
00113 \} \textcolor{comment}{// end namespace internal}
00114 
00115 \} \textcolor{comment}{// end namespace Eigen}
00116 
00117 \textcolor{preprocessor}{#endif // EIGEN\_RETURNBYVALUE\_H}
\end{DoxyCode}
