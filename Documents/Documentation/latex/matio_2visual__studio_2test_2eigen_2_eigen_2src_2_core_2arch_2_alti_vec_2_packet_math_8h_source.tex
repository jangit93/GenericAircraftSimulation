\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_alti_vec_2_packet_math_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/arch/\+Alti\+Vec/\+Packet\+Math.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_alti_vec_2_packet_math_8h_source}\index{Packet\+Math.\+h@{Packet\+Math.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2016 Konstantinos Margaritis <markos@freevec.org>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_PACKET\_MATH\_ALTIVEC\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_PACKET\_MATH\_ALTIVEC\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{preprocessor}{#ifndef EIGEN\_CACHEFRIENDLY\_PRODUCT\_THRESHOLD}
00018 \textcolor{preprocessor}{#define EIGEN\_CACHEFRIENDLY\_PRODUCT\_THRESHOLD 4}
00019 \textcolor{preprocessor}{#endif}
00020 
00021 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD}
00022 \textcolor{preprocessor}{#define EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD}
00023 \textcolor{preprocessor}{#endif}
00024 
00025 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_SINGLE\_INSTRUCTION\_CJMADD}
00026 \textcolor{preprocessor}{#define EIGEN\_HAS\_SINGLE\_INSTRUCTION\_CJMADD}
00027 \textcolor{preprocessor}{#endif}
00028 
00029 \textcolor{comment}{// NOTE Altivec has 32 registers, but Eigen only accepts a value of 8 or 16}
00030 \textcolor{preprocessor}{#ifndef EIGEN\_ARCH\_DEFAULT\_NUMBER\_OF\_REGISTERS}
00031 \textcolor{preprocessor}{#define EIGEN\_ARCH\_DEFAULT\_NUMBER\_OF\_REGISTERS  32}
00032 \textcolor{preprocessor}{#endif}
00033 
00034 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{float}          Packet4f;
00035 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{int}            Packet4i;
00036 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}   Packet4ui;
00037 \textcolor{keyword}{typedef} \_\_vector \_\_bool \textcolor{keywordtype}{int}     Packet4bi;
00038 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{short} \textcolor{keywordtype}{int}      Packet8i;
00039 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}  Packet16uc;
00040 
00041 \textcolor{comment}{// We don't want to write the same code all the time, but we need to reuse the constants}
00042 \textcolor{comment}{// and it doesn't really work to declare them global, so we define macros instead}
00043 
00044 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_FAST\_Packet4f(NAME,X) \(\backslash\)}
00045 \textcolor{preprocessor}{  Packet4f p4f\_##NAME = reinterpret\_cast<Packet4f>(vec\_splat\_s32(X))}
00046 
00047 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_FAST\_Packet4i(NAME,X) \(\backslash\)}
00048 \textcolor{preprocessor}{  Packet4i p4i\_##NAME = vec\_splat\_s32(X)}
00049 
00050 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet4f(NAME,X) \(\backslash\)}
00051 \textcolor{preprocessor}{  Packet4f p4f\_##NAME = pset1<Packet4f>(X)}
00052 
00053 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet4i(NAME,X) \(\backslash\)}
00054 \textcolor{preprocessor}{  Packet4i p4i\_##NAME = pset1<Packet4i>(X)}
00055 
00056 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet2d(NAME,X) \(\backslash\)}
00057 \textcolor{preprocessor}{  Packet2d p2d\_##NAME = pset1<Packet2d>(X)}
00058 
00059 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet2l(NAME,X) \(\backslash\)}
00060 \textcolor{preprocessor}{  Packet2l p2l\_##NAME = pset1<Packet2l>(X)}
00061 
00062 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(NAME,X) \(\backslash\)}
00063 \textcolor{preprocessor}{  const Packet4f p4f\_##NAME = reinterpret\_cast<Packet4f>(pset1<Packet4i>(X))}
00064 
00065 \textcolor{preprocessor}{#define DST\_CHAN 1}
00066 \textcolor{preprocessor}{#define DST\_CTRL(size, count, stride) (((size) << 24) | ((count) << 16) | (stride))}
00067 
00068 
00069 \textcolor{comment}{// These constants are endian-agnostic}
00070 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_FAST\_Packet4f(ZERO, 0); \textcolor{comment}{//\{ 0.0, 0.0, 0.0, 0.0\}}
00071 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_FAST\_Packet4i(ZERO, 0); \textcolor{comment}{//\{ 0, 0, 0, 0,\}}
00072 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_FAST\_Packet4i(ONE,1); \textcolor{comment}{//\{ 1, 1, 1, 1\}}
00073 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_FAST\_Packet4i(MINUS16,-16); \textcolor{comment}{//\{ -16, -16, -16, -16\}}
00074 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_FAST\_Packet4i(MINUS1,-1); \textcolor{comment}{//\{ -1, -1, -1, -1\}}
00075 \textcolor{keyword}{static} Packet4f p4f\_MZERO = (Packet4f) vec\_sl((Packet4ui)p4i\_MINUS1, (Packet4ui)p4i\_MINUS1); \textcolor{comment}{//\{
       0x80000000, 0x80000000, 0x80000000, 0x80000000\}}
00076 \textcolor{preprocessor}{#ifndef \_\_VSX\_\_}
00077 \textcolor{keyword}{static} Packet4f p4f\_ONE = vec\_ctf(p4i\_ONE, 0); \textcolor{comment}{//\{ 1.0, 1.0, 1.0, 1.0\}}
00078 \textcolor{preprocessor}{#endif}
00079 
00080 \textcolor{keyword}{static} Packet4f p4f\_COUNTDOWN = \{ 0.0, 1.0, 2.0, 3.0 \};
00081 \textcolor{keyword}{static} Packet4i p4i\_COUNTDOWN = \{ 0, 1, 2, 3 \};
00082 
00083 \textcolor{keyword}{static} Packet16uc p16uc\_REVERSE32 = \{ 12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3 \};
00084 \textcolor{keyword}{static} Packet16uc p16uc\_DUPLICATE32\_HI = \{ 0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7 \};
00085 
00086 \textcolor{comment}{// Mask alignment}
00087 \textcolor{preprocessor}{#ifdef \_\_PPC64\_\_}
00088 \textcolor{preprocessor}{#define \_EIGEN\_MASK\_ALIGNMENT   0xfffffffffffffff0}
00089 \textcolor{preprocessor}{#else}
00090 \textcolor{preprocessor}{#define \_EIGEN\_MASK\_ALIGNMENT   0xfffffff0}
00091 \textcolor{preprocessor}{#endif}
00092 
00093 \textcolor{preprocessor}{#define \_EIGEN\_ALIGNED\_PTR(x)   ((std::ptrdiff\_t)(x) & \_EIGEN\_MASK\_ALIGNMENT)}
00094 
00095 \textcolor{comment}{// Handle endianness properly while loading constants}
00096 \textcolor{comment}{// Define global static constants:}
00097 \textcolor{preprocessor}{#ifdef \_BIG\_ENDIAN}
00098 \textcolor{keyword}{static} Packet16uc p16uc\_FORWARD = vec\_lvsl(0, (\textcolor{keywordtype}{float}*)0);
00099 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00100 \textcolor{keyword}{static} Packet16uc p16uc\_REVERSE64 = \{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 \};
00101 \textcolor{preprocessor}{#endif}
00102 \textcolor{keyword}{static} Packet16uc p16uc\_PSET32\_WODD   = vec\_sld((Packet16uc) vec\_splat((Packet4ui)p16uc\_FORWARD, 0), (
      Packet16uc) vec\_splat((Packet4ui)p16uc\_FORWARD, 2), 8);\textcolor{comment}{//\{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 \};}
00103 \textcolor{keyword}{static} Packet16uc p16uc\_PSET32\_WEVEN  = vec\_sld(p16uc\_DUPLICATE32\_HI, (Packet16uc) vec\_splat((Packet4ui)
      p16uc\_FORWARD, 3), 8);\textcolor{comment}{//\{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 \};}
00104 \textcolor{keyword}{static} Packet16uc p16uc\_HALF64\_0\_16 = vec\_sld((Packet16uc)p4i\_ZERO, vec\_splat((Packet16uc) vec\_abs(
      p4i\_MINUS16), 3), 8);      \textcolor{comment}{//\{ 0,0,0,0, 0,0,0,0, 16,16,16,16, 16,16,16,16\};}
00105 \textcolor{preprocessor}{#else}
00106 \textcolor{keyword}{static} Packet16uc p16uc\_FORWARD = p16uc\_REVERSE32; 
00107 \textcolor{keyword}{static} Packet16uc p16uc\_REVERSE64 = \{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 \};
00108 \textcolor{keyword}{static} Packet16uc p16uc\_PSET32\_WODD = vec\_sld((Packet16uc) vec\_splat((Packet4ui)p16uc\_FORWARD, 1), (
      Packet16uc) vec\_splat((Packet4ui)p16uc\_FORWARD, 3), 8);\textcolor{comment}{//\{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 \};}
00109 \textcolor{keyword}{static} Packet16uc p16uc\_PSET32\_WEVEN = vec\_sld((Packet16uc) vec\_splat((Packet4ui)p16uc\_FORWARD, 0), (
      Packet16uc) vec\_splat((Packet4ui)p16uc\_FORWARD, 2), 8);\textcolor{comment}{//\{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 \};}
00110 \textcolor{keyword}{static} Packet16uc p16uc\_HALF64\_0\_16 = vec\_sld(vec\_splat((Packet16uc) vec\_abs(p4i\_MINUS16), 0), (Packet16uc)
      p4i\_ZERO, 8);      \textcolor{comment}{//\{ 0,0,0,0, 0,0,0,0, 16,16,16,16, 16,16,16,16\};}
00111 \textcolor{preprocessor}{#endif // \_BIG\_ENDIAN}
00112 
00113 \textcolor{keyword}{static} Packet16uc p16uc\_PSET64\_HI = (Packet16uc) vec\_mergeh((Packet4ui)p16uc\_PSET32\_WODD, (Packet4ui)
      p16uc\_PSET32\_WEVEN);     \textcolor{comment}{//\{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 \};}
00114 \textcolor{keyword}{static} Packet16uc p16uc\_PSET64\_LO = (Packet16uc) vec\_mergel((Packet4ui)p16uc\_PSET32\_WODD, (Packet4ui)
      p16uc\_PSET32\_WEVEN);     \textcolor{comment}{//\{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 \};}
00115 \textcolor{keyword}{static} Packet16uc p16uc\_TRANSPOSE64\_HI = p16uc\_PSET64\_HI + p16uc\_HALF64\_0\_16;                              
                 \textcolor{comment}{//\{ 0,1,2,3, 4,5,6,7, 16,17,18,19, 20,21,22,23\};}
00116 \textcolor{keyword}{static} Packet16uc p16uc\_TRANSPOSE64\_LO = p16uc\_PSET64\_LO + p16uc\_HALF64\_0\_16;                              
                 \textcolor{comment}{//\{ 8,9,10,11, 12,13,14,15, 24,25,26,27, 28,29,30,31\};}
00117 
00118 \textcolor{keyword}{static} Packet16uc p16uc\_COMPLEX32\_REV = vec\_sld(p16uc\_REVERSE32, p16uc\_REVERSE32, 8);                      
                         \textcolor{comment}{//\{ 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11 \};}
00119 
00120 \textcolor{preprocessor}{#ifdef \_BIG\_ENDIAN}
00121 \textcolor{keyword}{static} Packet16uc p16uc\_COMPLEX32\_REV2 = vec\_sld(p16uc\_FORWARD, p16uc\_FORWARD, 8);                         
                         \textcolor{comment}{//\{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 \};}
00122 \textcolor{preprocessor}{#else}
00123 \textcolor{keyword}{static} Packet16uc p16uc\_COMPLEX32\_REV2 = vec\_sld(p16uc\_PSET64\_HI, p16uc\_PSET64\_LO, 8);                     
                             \textcolor{comment}{//\{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 \};}
00124 \textcolor{preprocessor}{#endif // \_BIG\_ENDIAN}
00125 
00126 \textcolor{preprocessor}{#if EIGEN\_HAS\_BUILTIN(\_\_builtin\_prefetch) || EIGEN\_COMP\_GNUC}
00127 \textcolor{preprocessor}{  #define EIGEN\_PPC\_PREFETCH(ADDR) \_\_builtin\_prefetch(ADDR);}
00128 \textcolor{preprocessor}{#else}
00129 \textcolor{preprocessor}{  #define EIGEN\_PPC\_PREFETCH(ADDR) asm( "   dcbt [%[addr]]\(\backslash\)n" :: [addr] "r" (ADDR) : "cc" );}
00130 \textcolor{preprocessor}{#endif}
00131 
00132 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<float>  : default\_packet\_traits
00133 \{
00134   \textcolor{keyword}{typedef} Packet4f type;
00135   \textcolor{keyword}{typedef} Packet4f half;
00136   \textcolor{keyword}{enum} \{
00137     Vectorizable = 1,
00138     AlignedOnScalar = 1,
00139     size=4,
00140     HasHalfPacket = 1,
00141 
00142     HasAdd  = 1,
00143     HasSub  = 1,
00144     HasMul  = 1,
00145     HasDiv  = 1,
00146     HasMin  = 1,
00147     HasMax  = 1,
00148     HasAbs  = 1,
00149     HasSin  = 0,
00150     HasCos  = 0,
00151     HasLog  = 0,
00152     HasExp  = 1,
00153 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00154     HasSqrt = 1,
00155 \textcolor{preprocessor}{#if !EIGEN\_COMP\_CLANG}
00156     HasRsqrt = 1,
00157 \textcolor{preprocessor}{#else}
00158     HasRsqrt = 0,
00159 \textcolor{preprocessor}{#endif}
00160 \textcolor{preprocessor}{#else}
00161     HasSqrt = 0,
00162     HasRsqrt = 0,
00163 \textcolor{preprocessor}{#endif}
00164     HasRound = 1,
00165     HasFloor = 1,
00166     HasCeil = 1,
00167     HasNegate = 1,
00168     HasBlend = 1
00169   \};
00170 \};
00171 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<int>    : default\_packet\_traits
00172 \{
00173   \textcolor{keyword}{typedef} Packet4i type;
00174   \textcolor{keyword}{typedef} Packet4i half;
00175   \textcolor{keyword}{enum} \{
00176     Vectorizable = 1,
00177     AlignedOnScalar = 1,
00178     size = 4,
00179     HasHalfPacket = 0,
00180 
00181     HasAdd  = 1,
00182     HasSub  = 1,
00183     HasMul  = 1,
00184     HasDiv  = 0,
00185     HasBlend = 1
00186   \};
00187 \};
00188 
00189 
00190 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet4f> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{float}  type; \textcolor{keyword}{enum} \{size=4, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet4f half; \};
00191 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet4i> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{int}    type; \textcolor{keyword}{enum} \{size=4, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet4i half; \};
00192 
00193 \textcolor{keyword}{inline} std::ostream & operator <<(std::ostream & s, \textcolor{keyword}{const} Packet16uc & v)
00194 \{
00195   \textcolor{keyword}{union }\{
00196     Packet16uc   v;
00197     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} n[16];
00198   \} vt;
00199   vt.v = v;
00200   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i< 16; i++)
00201     s << (\textcolor{keywordtype}{int})vt.n[i] << \textcolor{stringliteral}{", "};
00202   \textcolor{keywordflow}{return} s;
00203 \}
00204 
00205 \textcolor{keyword}{inline} std::ostream & operator <<(std::ostream & s, \textcolor{keyword}{const} Packet4f & v)
00206 \{
00207   \textcolor{keyword}{union }\{
00208     Packet4f   v;
00209     \textcolor{keywordtype}{float} n[4];
00210   \} vt;
00211   vt.v = v;
00212   s << vt.n[0] << \textcolor{stringliteral}{", "} << vt.n[1] << \textcolor{stringliteral}{", "} << vt.n[2] << \textcolor{stringliteral}{", "} << vt.n[3];
00213   \textcolor{keywordflow}{return} s;
00214 \}
00215 
00216 \textcolor{keyword}{inline} std::ostream & operator <<(std::ostream & s, \textcolor{keyword}{const} Packet4i & v)
00217 \{
00218   \textcolor{keyword}{union }\{
00219     Packet4i   v;
00220     \textcolor{keywordtype}{int} n[4];
00221   \} vt;
00222   vt.v = v;
00223   s << vt.n[0] << \textcolor{stringliteral}{", "} << vt.n[1] << \textcolor{stringliteral}{", "} << vt.n[2] << \textcolor{stringliteral}{", "} << vt.n[3];
00224   \textcolor{keywordflow}{return} s;
00225 \}
00226 
00227 \textcolor{keyword}{inline} std::ostream & operator <<(std::ostream & s, \textcolor{keyword}{const} Packet4ui & v)
00228 \{
00229   \textcolor{keyword}{union }\{
00230     Packet4ui   v;
00231     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n[4];
00232   \} vt;
00233   vt.v = v;
00234   s << vt.n[0] << \textcolor{stringliteral}{", "} << vt.n[1] << \textcolor{stringliteral}{", "} << vt.n[2] << \textcolor{stringliteral}{", "} << vt.n[3];
00235   \textcolor{keywordflow}{return} s;
00236 \}
00237 
00238 \textcolor{comment}{// Need to define them first or we get specialization after instantiation errors}
00239 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pload<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}* from)
00240 \{
00241   EIGEN\_DEBUG\_ALIGNED\_LOAD
00242 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00243   \textcolor{keywordflow}{return} vec\_vsx\_ld(0, from);
00244 \textcolor{preprocessor}{#else}
00245   \textcolor{keywordflow}{return} vec\_ld(0, from);
00246 \textcolor{preprocessor}{#endif}
00247 \}
00248 
00249 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pload<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*     from)
00250 \{
00251   EIGEN\_DEBUG\_ALIGNED\_LOAD
00252 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00253   \textcolor{keywordflow}{return} vec\_vsx\_ld(0, from);
00254 \textcolor{preprocessor}{#else}
00255   \textcolor{keywordflow}{return} vec\_ld(0, from);
00256 \textcolor{preprocessor}{#endif}
00257 \}
00258 
00259 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<float>(\textcolor{keywordtype}{float}*   to, \textcolor{keyword}{const} Packet4f& from)
00260 \{
00261   EIGEN\_DEBUG\_ALIGNED\_STORE
00262 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00263   vec\_vsx\_st(from, 0, to);
00264 \textcolor{preprocessor}{#else}
00265   vec\_st(from, 0, to);
00266 \textcolor{preprocessor}{#endif}
00267 \}
00268 
00269 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<int>(\textcolor{keywordtype}{int}*       to, \textcolor{keyword}{const} Packet4i& from)
00270 \{
00271   EIGEN\_DEBUG\_ALIGNED\_STORE
00272 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00273   vec\_vsx\_st(from, 0, to);
00274 \textcolor{preprocessor}{#else}
00275   vec\_st(from, 0, to);
00276 \textcolor{preprocessor}{#endif}
00277 \}
00278 
00279 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pset1<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}&  from) \{
00280   Packet4f v = \{from, from, from, from\};
00281   \textcolor{keywordflow}{return} v;
00282 \}
00283 
00284 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pset1<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}&    from)   \{
00285   Packet4i v = \{from, from, from, from\};
00286   \textcolor{keywordflow}{return} v;
00287 \}
00288 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00289 pbroadcast4<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float} *a,
00290                       Packet4f& a0, Packet4f& a1, Packet4f& a2, Packet4f& a3)
00291 \{
00292   a3 = pload<Packet4f>(a);
00293   a0 = vec\_splat(a3, 0);
00294   a1 = vec\_splat(a3, 1);
00295   a2 = vec\_splat(a3, 2);
00296   a3 = vec\_splat(a3, 3);
00297 \}
00298 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00299 pbroadcast4<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int} *a,
00300                       Packet4i& a0, Packet4i& a1, Packet4i& a2, Packet4i& a3)
00301 \{
00302   a3 = pload<Packet4i>(a);
00303   a0 = vec\_splat(a3, 0);
00304   a1 = vec\_splat(a3, 1);
00305   a2 = vec\_splat(a3, 2);
00306   a3 = vec\_splat(a3, 3);
00307 \}
00308 
00309 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet4f pgather<float, Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}* from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00310 \{
00311   \textcolor{keywordtype}{float} EIGEN\_ALIGN16 af[4];
00312   af[0] = from[0*stride];
00313   af[1] = from[1*stride];
00314   af[2] = from[2*stride];
00315   af[3] = from[3*stride];
00316  \textcolor{keywordflow}{return} pload<Packet4f>(af);
00317 \}
00318 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet4i pgather<int, Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}* from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00319 \{
00320   \textcolor{keywordtype}{int} EIGEN\_ALIGN16 ai[4];
00321   ai[0] = from[0*stride];
00322   ai[1] = from[1*stride];
00323   ai[2] = from[2*stride];
00324   ai[3] = from[3*stride];
00325  \textcolor{keywordflow}{return} pload<Packet4i>(ai);
00326 \}
00327 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<float, Packet4f>(\textcolor{keywordtype}{float}* to, \textcolor{keyword}{const} Packet4f& from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00328 \{
00329   \textcolor{keywordtype}{float} EIGEN\_ALIGN16 af[4];
00330   pstore<float>(af, from);
00331   to[0*stride] = af[0];
00332   to[1*stride] = af[1];
00333   to[2*stride] = af[2];
00334   to[3*stride] = af[3];
00335 \}
00336 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<int, Packet4i>(\textcolor{keywordtype}{int}* to, \textcolor{keyword}{const} Packet4i& from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00337 \{
00338   \textcolor{keywordtype}{int} EIGEN\_ALIGN16 ai[4];
00339   pstore<int>((\textcolor{keywordtype}{int} *)ai, from);
00340   to[0*stride] = ai[0];
00341   to[1*stride] = ai[1];
00342   to[2*stride] = ai[2];
00343   to[3*stride] = ai[3];
00344 \}
00345 
00346 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f plset<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}& a) \{ \textcolor{keywordflow}{return} pset1<Packet4f>(a) + 
      p4f\_COUNTDOWN; \}
00347 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i plset<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}& a)   \{ \textcolor{keywordflow}{return} pset1<Packet4i>(a) + 
      p4i\_COUNTDOWN; \}
00348 
00349 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f padd<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} a + b
      ; \}
00350 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i padd<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} a + b
      ; \}
00351 
00352 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f psub<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} a - b
      ; \}
00353 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i psub<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} a - b
      ; \}
00354 
00355 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pnegate(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordflow}{return} p4f\_ZERO - a; \}
00356 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pnegate(\textcolor{keyword}{const} Packet4i& a) \{ \textcolor{keywordflow}{return} p4i\_ZERO - a; \}
00357 
00358 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pconj(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordflow}{return} a; \}
00359 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pconj(\textcolor{keyword}{const} Packet4i& a) \{ \textcolor{keywordflow}{return} a; \}
00360 
00361 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pmul<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      vec\_madd(a,b, p4f\_MZERO); \}
00362 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pmul<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} a * b
      ; \}
00363 
00364 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pdiv<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b)
00365 \{
00366 \textcolor{preprocessor}{#ifndef \_\_VSX\_\_  // VSX actually provides a div instruction}
00367   Packet4f t, y\_0, y\_1;
00368 
00369   \textcolor{comment}{// Altivec does not offer a divide instruction, we have to do a reciprocal approximation}
00370   y\_0 = vec\_re(b);
00371 
00372   \textcolor{comment}{// Do one Newton-Raphson iteration to get the needed accuracy}
00373   t   = vec\_nmsub(y\_0, b, p4f\_ONE);
00374   y\_1 = vec\_madd(y\_0, t, y\_0);
00375 
00376   \textcolor{keywordflow}{return} vec\_madd(a, y\_1, p4f\_MZERO);
00377 \textcolor{preprocessor}{#else}
00378   \textcolor{keywordflow}{return} vec\_div(a, b);
00379 \textcolor{preprocessor}{#endif}
00380 \}
00381 
00382 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pdiv<Packet4i>(\textcolor{keyword}{const} Packet4i& \textcolor{comment}{/*a*/}, \textcolor{keyword}{const} Packet4i& \textcolor{comment}{/*b*/})
00383 \{ eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"packet integer division are not supported by AltiVec"});
00384   \textcolor{keywordflow}{return} pset1<Packet4i>(0);
00385 \}
00386 
00387 \textcolor{comment}{// for some weird raisons, it has to be overloaded for packet of integers}
00388 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pmadd(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b, \textcolor{keyword}{const} Packet4f& c) \{ \textcolor{keywordflow}{
      return} vec\_madd(a,b,c); \}
00389 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pmadd(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b, \textcolor{keyword}{const} Packet4i& c) \{ \textcolor{keywordflow}{
      return} a*b + c; \}
00390 
00391 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pmin<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      vec\_min(a, b); \}
00392 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pmin<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      vec\_min(a, b); \}
00393 
00394 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pmax<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      vec\_max(a, b); \}
00395 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pmax<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      vec\_max(a, b); \}
00396 
00397 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pand<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      vec\_and(a, b); \}
00398 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pand<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      vec\_and(a, b); \}
00399 
00400 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f por<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} vec\_or
      (a, b); \}
00401 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i por<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} vec\_or
      (a, b); \}
00402 
00403 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pxor<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      vec\_xor(a, b); \}
00404 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pxor<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      vec\_xor(a, b); \}
00405 
00406 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pandnot<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      vec\_and(a, vec\_nor(b, b)); \}
00407 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pandnot<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      vec\_and(a, vec\_nor(b, b)); \}
00408 
00409 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pround<Packet4f>(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordflow}{return} vec\_round(a); \}
00410 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pceil<Packet4f>(\textcolor{keyword}{const}  Packet4f& a) \{ \textcolor{keywordflow}{return} vec\_ceil(a); \}
00411 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pfloor<Packet4f>(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordflow}{return} vec\_floor(a); \}
00412 
00413 \textcolor{preprocessor}{#ifdef \_BIG\_ENDIAN}
00414 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f ploadu<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}* from)
00415 \{
00416   EIGEN\_DEBUG\_ALIGNED\_LOAD
00417   Packet16uc MSQ, LSQ;
00418   Packet16uc mask;
00419   MSQ = vec\_ld(0, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)from);          \textcolor{comment}{// most significant quadword}
00420   LSQ = vec\_ld(15, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)from);         \textcolor{comment}{// least significant quadword}
00421   mask = vec\_lvsl(0, from);                        \textcolor{comment}{// create the permute mask}
00422   \textcolor{keywordflow}{return} (Packet4f) vec\_perm(MSQ, LSQ, mask);           \textcolor{comment}{// align the data}
00423 
00424 \}
00425 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i ploadu<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}* from)
00426 \{
00427   EIGEN\_DEBUG\_ALIGNED\_LOAD
00428   \textcolor{comment}{// Taken from http://developer.apple.com/hardwaredrivers/ve/alignment.html}
00429   Packet16uc MSQ, LSQ;
00430   Packet16uc mask;
00431   MSQ = vec\_ld(0, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)from);          \textcolor{comment}{// most significant quadword}
00432   LSQ = vec\_ld(15, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)from);         \textcolor{comment}{// least significant quadword}
00433   mask = vec\_lvsl(0, from);                        \textcolor{comment}{// create the permute mask}
00434   \textcolor{keywordflow}{return} (Packet4i) vec\_perm(MSQ, LSQ, mask);    \textcolor{comment}{// align the data}
00435 \}
00436 \textcolor{preprocessor}{#else}
00437 \textcolor{comment}{// We also need ot redefine little endian loading of Packet4i/Packet4f using VSX}
00438 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i ploadu<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}* from)
00439 \{
00440   EIGEN\_DEBUG\_UNALIGNED\_LOAD
00441   \textcolor{keywordflow}{return} (Packet4i) vec\_vsx\_ld((\textcolor{keywordtype}{long})from & 15, (\textcolor{keyword}{const} \textcolor{keywordtype}{int}*) \_EIGEN\_ALIGNED\_PTR(from));
00442 \}
00443 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f ploadu<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}* from)
00444 \{
00445   EIGEN\_DEBUG\_UNALIGNED\_LOAD
00446   \textcolor{keywordflow}{return} (Packet4f) vec\_vsx\_ld((\textcolor{keywordtype}{long})from & 15, (\textcolor{keyword}{const} \textcolor{keywordtype}{float}*) \_EIGEN\_ALIGNED\_PTR(from));
00447 \}
00448 \textcolor{preprocessor}{#endif}
00449 
00450 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f ploaddup<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}*   from)
00451 \{
00452   Packet4f p;
00453   \textcolor{keywordflow}{if}((std::ptrdiff\_t(from) % 16) == 0)  p = pload<Packet4f>(from);
00454   \textcolor{keywordflow}{else}                                  p = ploadu<Packet4f>(from);
00455   \textcolor{keywordflow}{return} vec\_perm(p, p, p16uc\_DUPLICATE32\_HI);
00456 \}
00457 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i ploaddup<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*     from)
00458 \{
00459   Packet4i p;
00460   \textcolor{keywordflow}{if}((std::ptrdiff\_t(from) % 16) == 0)  p = pload<Packet4i>(from);
00461   \textcolor{keywordflow}{else}                                  p = ploadu<Packet4i>(from);
00462   \textcolor{keywordflow}{return} vec\_perm(p, p, p16uc\_DUPLICATE32\_HI);
00463 \}
00464 
00465 \textcolor{preprocessor}{#ifdef \_BIG\_ENDIAN}
00466 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<float>(\textcolor{keywordtype}{float}*  to, \textcolor{keyword}{const} Packet4f& from)
00467 \{
00468   EIGEN\_DEBUG\_UNALIGNED\_STORE
00469   \textcolor{comment}{// Taken from http://developer.apple.com/hardwaredrivers/ve/alignment.html}
00470   \textcolor{comment}{// Warning: not thread safe!}
00471   Packet16uc MSQ, LSQ, edges;
00472   Packet16uc edgeAlign, align;
00473 
00474   MSQ = vec\_ld(0, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)to);                     \textcolor{comment}{// most significant quadword}
00475   LSQ = vec\_ld(15, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)to);                    \textcolor{comment}{// least significant quadword}
00476   edgeAlign = vec\_lvsl(0, to);                              \textcolor{comment}{// permute map to extract edges}
00477   edges=vec\_perm(LSQ,MSQ,edgeAlign);                        \textcolor{comment}{// extract the edges}
00478   align = vec\_lvsr( 0, to );                                \textcolor{comment}{// permute map to misalign data}
00479   MSQ = vec\_perm(edges,(Packet16uc)from,align);             \textcolor{comment}{// misalign the data (MSQ)}
00480   LSQ = vec\_perm((Packet16uc)from,edges,align);             \textcolor{comment}{// misalign the data (LSQ)}
00481   vec\_st( LSQ, 15, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)to );                   \textcolor{comment}{// Store the LSQ part first}
00482   vec\_st( MSQ, 0, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)to );                    \textcolor{comment}{// Store the MSQ part}
00483 \}
00484 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<int>(\textcolor{keywordtype}{int}*      to, \textcolor{keyword}{const} Packet4i& from)
00485 \{
00486   EIGEN\_DEBUG\_UNALIGNED\_STORE
00487   \textcolor{comment}{// Taken from http://developer.apple.com/hardwaredrivers/ve/alignment.html}
00488   \textcolor{comment}{// Warning: not thread safe!}
00489   Packet16uc MSQ, LSQ, edges;
00490   Packet16uc edgeAlign, align;
00491 
00492   MSQ = vec\_ld(0, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)to);                     \textcolor{comment}{// most significant quadword}
00493   LSQ = vec\_ld(15, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)to);                    \textcolor{comment}{// least significant quadword}
00494   edgeAlign = vec\_lvsl(0, to);                              \textcolor{comment}{// permute map to extract edges}
00495   edges=vec\_perm(LSQ, MSQ, edgeAlign);                      \textcolor{comment}{// extract the edges}
00496   align = vec\_lvsr( 0, to );                                \textcolor{comment}{// permute map to misalign data}
00497   MSQ = vec\_perm(edges, (Packet16uc) from, align);          \textcolor{comment}{// misalign the data (MSQ)}
00498   LSQ = vec\_perm((Packet16uc) from, edges, align);          \textcolor{comment}{// misalign the data (LSQ)}
00499   vec\_st( LSQ, 15, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)to );                   \textcolor{comment}{// Store the LSQ part first}
00500   vec\_st( MSQ, 0, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)to );                    \textcolor{comment}{// Store the MSQ part}
00501 \}
00502 \textcolor{preprocessor}{#else}
00503 \textcolor{comment}{// We also need ot redefine little endian loading of Packet4i/Packet4f using VSX}
00504 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<int>(\textcolor{keywordtype}{int}*       to, \textcolor{keyword}{const} Packet4i& from)
00505 \{
00506   EIGEN\_DEBUG\_ALIGNED\_STORE
00507   vec\_vsx\_st(from, (\textcolor{keywordtype}{long})to & 15, (\textcolor{keywordtype}{int}*) \_EIGEN\_ALIGNED\_PTR(to));
00508 \}
00509 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<float>(\textcolor{keywordtype}{float}*   to, \textcolor{keyword}{const} Packet4f& from)
00510 \{
00511   EIGEN\_DEBUG\_ALIGNED\_STORE
00512   vec\_vsx\_st(from, (\textcolor{keywordtype}{long})to & 15, (\textcolor{keywordtype}{float}*) \_EIGEN\_ALIGNED\_PTR(to));
00513 \}
00514 \textcolor{preprocessor}{#endif}
00515 
00516 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<float>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}* addr)    \{ EIGEN\_PPC\_PREFETCH(addr); \}
00517 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<int>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*     addr)    \{ EIGEN\_PPC\_PREFETCH(addr); \}
00518 
00519 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float}  pfirst<Packet4f>(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordtype}{float} EIGEN\_ALIGN16 x; vec\_ste(
      a, 0, &x); \textcolor{keywordflow}{return} x; \}
00520 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int}    pfirst<Packet4i>(\textcolor{keyword}{const} Packet4i& a) \{ \textcolor{keywordtype}{int}   EIGEN\_ALIGN16 x; vec\_ste(
      a, 0, &x); \textcolor{keywordflow}{return} x; \}
00521 
00522 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f preverse(\textcolor{keyword}{const} Packet4f& a)
00523 \{
00524   \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}Packet4f\textcolor{keyword}{>}(vec\_perm(reinterpret\_cast<Packet16uc>(a), reinterpret\_cast<Packet16uc>(
      a), p16uc\_REVERSE32));
00525 \}
00526 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i preverse(\textcolor{keyword}{const} Packet4i& a)
00527 \{
00528   \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}Packet4i\textcolor{keyword}{>}(vec\_perm(reinterpret\_cast<Packet16uc>(a), reinterpret\_cast<Packet16uc>(
      a), p16uc\_REVERSE32)); \}
00529 
00530 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pabs(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordflow}{return} vec\_abs(a); \}
00531 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pabs(\textcolor{keyword}{const} Packet4i& a) \{ \textcolor{keywordflow}{return} vec\_abs(a); \}
00532 
00533 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00534 \{
00535   Packet4f b, sum;
00536   b   = vec\_sld(a, a, 8);
00537   sum = a + b;
00538   b   = vec\_sld(sum, sum, 4);
00539   sum += b;
00540   \textcolor{keywordflow}{return} pfirst(sum);
00541 \}
00542 
00543 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f preduxp<Packet4f>(\textcolor{keyword}{const} Packet4f* vecs)
00544 \{
00545   Packet4f v[4], sum[4];
00546 
00547   \textcolor{comment}{// It's easier and faster to transpose then add as columns}
00548   \textcolor{comment}{// Check: http://www.freevec.org/function/matrix\_4x4\_transpose\_floats for explanation}
00549   \textcolor{comment}{// Do the transpose, first set of moves}
00550   v[0] = vec\_mergeh(vecs[0], vecs[2]);
00551   v[1] = vec\_mergel(vecs[0], vecs[2]);
00552   v[2] = vec\_mergeh(vecs[1], vecs[3]);
00553   v[3] = vec\_mergel(vecs[1], vecs[3]);
00554   \textcolor{comment}{// Get the resulting vectors}
00555   sum[0] = vec\_mergeh(v[0], v[2]);
00556   sum[1] = vec\_mergel(v[0], v[2]);
00557   sum[2] = vec\_mergeh(v[1], v[3]);
00558   sum[3] = vec\_mergel(v[1], v[3]);
00559 
00560   \textcolor{comment}{// Now do the summation:}
00561   \textcolor{comment}{// Lines 0+1}
00562   sum[0] = sum[0] + sum[1];
00563   \textcolor{comment}{// Lines 2+3}
00564   sum[1] = sum[2] + sum[3];
00565   \textcolor{comment}{// Add the results}
00566   sum[0] = sum[0] + sum[1];
00567 
00568   \textcolor{keywordflow}{return} sum[0];
00569 \}
00570 
00571 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00572 \{
00573   Packet4i sum;
00574   sum = vec\_sums(a, p4i\_ZERO);
00575 \textcolor{preprocessor}{#ifdef \_BIG\_ENDIAN}
00576   sum = vec\_sld(sum, p4i\_ZERO, 12);
00577 \textcolor{preprocessor}{#else}
00578   sum = vec\_sld(p4i\_ZERO, sum, 4);
00579 \textcolor{preprocessor}{#endif}
00580   \textcolor{keywordflow}{return} pfirst(sum);
00581 \}
00582 
00583 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i preduxp<Packet4i>(\textcolor{keyword}{const} Packet4i* vecs)
00584 \{
00585   Packet4i v[4], sum[4];
00586 
00587   \textcolor{comment}{// It's easier and faster to transpose then add as columns}
00588   \textcolor{comment}{// Check: http://www.freevec.org/function/matrix\_4x4\_transpose\_floats for explanation}
00589   \textcolor{comment}{// Do the transpose, first set of moves}
00590   v[0] = vec\_mergeh(vecs[0], vecs[2]);
00591   v[1] = vec\_mergel(vecs[0], vecs[2]);
00592   v[2] = vec\_mergeh(vecs[1], vecs[3]);
00593   v[3] = vec\_mergel(vecs[1], vecs[3]);
00594   \textcolor{comment}{// Get the resulting vectors}
00595   sum[0] = vec\_mergeh(v[0], v[2]);
00596   sum[1] = vec\_mergel(v[0], v[2]);
00597   sum[2] = vec\_mergeh(v[1], v[3]);
00598   sum[3] = vec\_mergel(v[1], v[3]);
00599 
00600   \textcolor{comment}{// Now do the summation:}
00601   \textcolor{comment}{// Lines 0+1}
00602   sum[0] = sum[0] + sum[1];
00603   \textcolor{comment}{// Lines 2+3}
00604   sum[1] = sum[2] + sum[3];
00605   \textcolor{comment}{// Add the results}
00606   sum[0] = sum[0] + sum[1];
00607 
00608   \textcolor{keywordflow}{return} sum[0];
00609 \}
00610 
00611 \textcolor{comment}{// Other reduction functions:}
00612 \textcolor{comment}{// mul}
00613 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux\_mul<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00614 \{
00615   Packet4f prod;
00616   prod = pmul(a, vec\_sld(a, a, 8));
00617   \textcolor{keywordflow}{return} pfirst(pmul(prod, vec\_sld(prod, prod, 4)));
00618 \}
00619 
00620 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux\_mul<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00621 \{
00622   EIGEN\_ALIGN16 \textcolor{keywordtype}{int} aux[4];
00623   pstore(aux, a);
00624   \textcolor{keywordflow}{return} aux[0] * aux[1] * aux[2] * aux[3];
00625 \}
00626 
00627 \textcolor{comment}{// min}
00628 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux\_min<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00629 \{
00630   Packet4f b, res;
00631   b = vec\_min(a, vec\_sld(a, a, 8));
00632   res = vec\_min(b, vec\_sld(b, b, 4));
00633   \textcolor{keywordflow}{return} pfirst(res);
00634 \}
00635 
00636 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux\_min<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00637 \{
00638   Packet4i b, res;
00639   b = vec\_min(a, vec\_sld(a, a, 8));
00640   res = vec\_min(b, vec\_sld(b, b, 4));
00641   \textcolor{keywordflow}{return} pfirst(res);
00642 \}
00643 
00644 \textcolor{comment}{// max}
00645 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux\_max<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00646 \{
00647   Packet4f b, res;
00648   b = vec\_max(a, vec\_sld(a, a, 8));
00649   res = vec\_max(b, vec\_sld(b, b, 4));
00650   \textcolor{keywordflow}{return} pfirst(res);
00651 \}
00652 
00653 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux\_max<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00654 \{
00655   Packet4i b, res;
00656   b = vec\_max(a, vec\_sld(a, a, 8));
00657   res = vec\_max(b, vec\_sld(b, b, 4));
00658   \textcolor{keywordflow}{return} pfirst(res);
00659 \}
00660 
00661 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00662 \textcolor{keyword}{struct }palign\_impl<Offset,Packet4f>
00663 \{
00664   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet4f& first, \textcolor{keyword}{const} Packet4f& second)
00665   \{
00666 \textcolor{preprocessor}{#ifdef \_BIG\_ENDIAN}
00667     \textcolor{keywordflow}{switch} (Offset % 4) \{
00668     \textcolor{keywordflow}{case} 1:
00669       first = vec\_sld(first, second, 4); \textcolor{keywordflow}{break};
00670     \textcolor{keywordflow}{case} 2:
00671       first = vec\_sld(first, second, 8); \textcolor{keywordflow}{break};
00672     \textcolor{keywordflow}{case} 3:
00673       first = vec\_sld(first, second, 12); \textcolor{keywordflow}{break};
00674     \}
00675 \textcolor{preprocessor}{#else}
00676     \textcolor{keywordflow}{switch} (Offset % 4) \{
00677     \textcolor{keywordflow}{case} 1:
00678       first = vec\_sld(second, first, 12); \textcolor{keywordflow}{break};
00679     \textcolor{keywordflow}{case} 2:
00680       first = vec\_sld(second, first, 8); \textcolor{keywordflow}{break};
00681     \textcolor{keywordflow}{case} 3:
00682       first = vec\_sld(second, first, 4); \textcolor{keywordflow}{break};
00683     \}
00684 \textcolor{preprocessor}{#endif}
00685   \}
00686 \};
00687 
00688 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00689 \textcolor{keyword}{struct }palign\_impl<Offset,Packet4i>
00690 \{
00691   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet4i& first, \textcolor{keyword}{const} Packet4i& second)
00692   \{
00693 \textcolor{preprocessor}{#ifdef \_BIG\_ENDIAN}
00694     \textcolor{keywordflow}{switch} (Offset % 4) \{
00695     \textcolor{keywordflow}{case} 1:
00696       first = vec\_sld(first, second, 4); \textcolor{keywordflow}{break};
00697     \textcolor{keywordflow}{case} 2:
00698       first = vec\_sld(first, second, 8); \textcolor{keywordflow}{break};
00699     \textcolor{keywordflow}{case} 3:
00700       first = vec\_sld(first, second, 12); \textcolor{keywordflow}{break};
00701     \}
00702 \textcolor{preprocessor}{#else}
00703     \textcolor{keywordflow}{switch} (Offset % 4) \{
00704     \textcolor{keywordflow}{case} 1:
00705       first = vec\_sld(second, first, 12); \textcolor{keywordflow}{break};
00706     \textcolor{keywordflow}{case} 2:
00707       first = vec\_sld(second, first, 8); \textcolor{keywordflow}{break};
00708     \textcolor{keywordflow}{case} 3:
00709       first = vec\_sld(second, first, 4); \textcolor{keywordflow}{break};
00710     \}
00711 \textcolor{preprocessor}{#endif}
00712   \}
00713 \};
00714 
00715 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00716 ptranspose(PacketBlock<Packet4f,4>& kernel) \{
00717   Packet4f t0, t1, t2, t3;
00718   t0 = vec\_mergeh(kernel.packet[0], kernel.packet[2]);
00719   t1 = vec\_mergel(kernel.packet[0], kernel.packet[2]);
00720   t2 = vec\_mergeh(kernel.packet[1], kernel.packet[3]);
00721   t3 = vec\_mergel(kernel.packet[1], kernel.packet[3]);
00722   kernel.packet[0] = vec\_mergeh(t0, t2);
00723   kernel.packet[1] = vec\_mergel(t0, t2);
00724   kernel.packet[2] = vec\_mergeh(t1, t3);
00725   kernel.packet[3] = vec\_mergel(t1, t3);
00726 \}
00727 
00728 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00729 ptranspose(PacketBlock<Packet4i,4>& kernel) \{
00730   Packet4i t0, t1, t2, t3;
00731   t0 = vec\_mergeh(kernel.packet[0], kernel.packet[2]);
00732   t1 = vec\_mergel(kernel.packet[0], kernel.packet[2]);
00733   t2 = vec\_mergeh(kernel.packet[1], kernel.packet[3]);
00734   t3 = vec\_mergel(kernel.packet[1], kernel.packet[3]);
00735   kernel.packet[0] = vec\_mergeh(t0, t2);
00736   kernel.packet[1] = vec\_mergel(t0, t2);
00737   kernel.packet[2] = vec\_mergeh(t1, t3);
00738   kernel.packet[3] = vec\_mergel(t1, t3);
00739 \}
00740 
00741 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pblend(\textcolor{keyword}{const} Selector<4>& ifPacket, \textcolor{keyword}{const} Packet4i& thenPacket, \textcolor{keyword}{
      const} Packet4i& elsePacket) \{
00742   Packet4ui select = \{ ifPacket.select[0], ifPacket.select[1], ifPacket.select[2], ifPacket.select[3] \};
00743   Packet4ui mask = \textcolor{keyword}{reinterpret\_cast<}Packet4ui\textcolor{keyword}{>}(vec\_cmpeq(reinterpret\_cast<Packet4ui>(select), 
      reinterpret\_cast<Packet4ui>(p4i\_ONE)));
00744   \textcolor{keywordflow}{return} vec\_sel(elsePacket, thenPacket, mask);
00745 \}
00746 
00747 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pblend(\textcolor{keyword}{const} Selector<4>& ifPacket, \textcolor{keyword}{const} Packet4f& thenPacket, \textcolor{keyword}{
      const} Packet4f& elsePacket) \{
00748   Packet4ui select = \{ ifPacket.select[0], ifPacket.select[1], ifPacket.select[2], ifPacket.select[3] \};
00749   Packet4ui mask = \textcolor{keyword}{reinterpret\_cast<}Packet4ui\textcolor{keyword}{>}(vec\_cmpeq(reinterpret\_cast<Packet4ui>(select), 
      reinterpret\_cast<Packet4ui>(p4i\_ONE)));
00750   \textcolor{keywordflow}{return} vec\_sel(elsePacket, thenPacket, mask);
00751 \}
00752 
00753 
00754 \textcolor{comment}{//---------- double ----------}
00755 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00756 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{double}              Packet2d;
00757 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}  Packet2ul;
00758 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}           Packet2l;
00759 \textcolor{preprocessor}{#if EIGEN\_COMP\_CLANG}
00760 \textcolor{keyword}{typedef} Packet2ul                    Packet2bl;
00761 \textcolor{preprocessor}{#else}
00762 \textcolor{keyword}{typedef} \_\_vector \_\_bool \textcolor{keywordtype}{long}         Packet2bl;
00763 \textcolor{preprocessor}{#endif}
00764 
00765 \textcolor{keyword}{static} Packet2l  p2l\_ONE  = \{ 1, 1 \};
00766 \textcolor{keyword}{static} Packet2l  p2l\_ZERO = \textcolor{keyword}{reinterpret\_cast<}Packet2l\textcolor{keyword}{>}(p4i\_ZERO);
00767 \textcolor{keyword}{static} Packet2d  p2d\_ONE  = \{ 1.0, 1.0 \}; 
00768 \textcolor{keyword}{static} Packet2d  p2d\_ZERO = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(p4f\_ZERO);
00769 \textcolor{keyword}{static} Packet2d  p2d\_MZERO = \{ -0.0, -0.0 \};
00770 
00771 \textcolor{preprocessor}{#ifdef \_BIG\_ENDIAN}
00772 \textcolor{keyword}{static} Packet2d p2d\_COUNTDOWN = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4f>(p2d\_ZERO), 
      reinterpret\_cast<Packet4f>(p2d\_ONE), 8));
00773 \textcolor{preprocessor}{#else}
00774 \textcolor{keyword}{static} Packet2d p2d\_COUNTDOWN = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4f>(p2d\_ONE), 
      reinterpret\_cast<Packet4f>(p2d\_ZERO), 8));
00775 \textcolor{preprocessor}{#endif}
00776 
00777 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} index> Packet2d vec\_splat\_dbl(Packet2d& a);
00778 
00779 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d vec\_splat\_dbl<0>(Packet2d& a)
00780 \{
00781   \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_perm(a, a, p16uc\_PSET64\_HI));
00782 \}
00783 
00784 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d vec\_splat\_dbl<1>(Packet2d& a)
00785 \{
00786   \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_perm(a, a, p16uc\_PSET64\_LO));
00787 \}
00788 
00789 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<double> : default\_packet\_traits
00790 \{
00791   \textcolor{keyword}{typedef} Packet2d type;
00792   \textcolor{keyword}{typedef} Packet2d half;
00793   \textcolor{keyword}{enum} \{
00794     Vectorizable = 1,
00795     AlignedOnScalar = 1,
00796     size=2,
00797     HasHalfPacket = 1,
00798 
00799     HasAdd  = 1,
00800     HasSub  = 1,
00801     HasMul  = 1,
00802     HasDiv  = 1,
00803     HasMin  = 1,
00804     HasMax  = 1,
00805     HasAbs  = 1,
00806     HasSin  = 0,
00807     HasCos  = 0,
00808     HasLog  = 0,
00809     HasExp  = 1,
00810     HasSqrt = 1,
00811     HasRsqrt = 1,
00812     HasRound = 1,
00813     HasFloor = 1,
00814     HasCeil = 1,
00815     HasNegate = 1,
00816     HasBlend = 1
00817   \};
00818 \};
00819 
00820 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet2d> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{double} type; \textcolor{keyword}{enum} \{size=2, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet2d half; \};
00821 
00822 \textcolor{keyword}{inline} std::ostream & operator <<(std::ostream & s, \textcolor{keyword}{const} Packet2l & v)
00823 \{
00824   \textcolor{keyword}{union }\{
00825     Packet2l   v;
00826     int64\_t n[2];
00827   \} vt;
00828   vt.v = v;
00829   s << vt.n[0] << \textcolor{stringliteral}{", "} << vt.n[1];
00830   \textcolor{keywordflow}{return} s;
00831 \}
00832 
00833 \textcolor{keyword}{inline} std::ostream & operator <<(std::ostream & s, \textcolor{keyword}{const} Packet2d & v)
00834 \{
00835   \textcolor{keyword}{union }\{
00836     Packet2d   v;
00837     \textcolor{keywordtype}{double} n[2];
00838   \} vt;
00839   vt.v = v;
00840   s << vt.n[0] << \textcolor{stringliteral}{", "} << vt.n[1];
00841   \textcolor{keywordflow}{return} s;
00842 \}
00843 
00844 \textcolor{comment}{// Need to define them first or we get specialization after instantiation errors}
00845 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pload<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* from)
00846 \{
00847   EIGEN\_DEBUG\_ALIGNED\_LOAD
00848 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00849   \textcolor{keywordflow}{return} vec\_vsx\_ld(0, from);
00850 \textcolor{preprocessor}{#else}
00851   \textcolor{keywordflow}{return} vec\_ld(0, from);
00852 \textcolor{preprocessor}{#endif}
00853 \}
00854 
00855 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<double>(\textcolor{keywordtype}{double}*   to, \textcolor{keyword}{const} Packet2d& from)
00856 \{
00857   EIGEN\_DEBUG\_ALIGNED\_STORE
00858 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00859   vec\_vsx\_st(from, 0, to);
00860 \textcolor{preprocessor}{#else}
00861   vec\_st(from, 0, to);
00862 \textcolor{preprocessor}{#endif}
00863 \}
00864 
00865 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pset1<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}&  from) \{
00866   Packet2d v = \{from, from\};
00867   \textcolor{keywordflow}{return} v;
00868 \}
00869 
00870 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00871 pbroadcast4<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double} *a,
00872                       Packet2d& a0, Packet2d& a1, Packet2d& a2, Packet2d& a3)
00873 \{
00874   a1 = pload<Packet2d>(a);
00875   a0 = vec\_splat\_dbl<0>(a1);
00876   a1 = vec\_splat\_dbl<1>(a1);
00877   a3 = pload<Packet2d>(a+2);
00878   a2 = vec\_splat\_dbl<0>(a3);
00879   a3 = vec\_splat\_dbl<1>(a3);
00880 \}
00881 
00882 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet2d pgather<double, Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00883 \{
00884   \textcolor{keywordtype}{double} EIGEN\_ALIGN16 af[2];
00885   af[0] = from[0*stride];
00886   af[1] = from[1*stride];
00887  \textcolor{keywordflow}{return} pload<Packet2d>(af);
00888 \}
00889 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<double, Packet2d>(\textcolor{keywordtype}{double}* to, \textcolor{keyword}{const} Packet2d& from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00890 \{
00891   \textcolor{keywordtype}{double} EIGEN\_ALIGN16 af[2];
00892   pstore<double>(af, from);
00893   to[0*stride] = af[0];
00894   to[1*stride] = af[1];
00895 \}
00896 
00897 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d plset<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& a) \{ \textcolor{keywordflow}{return} pset1<Packet2d>(a) + 
      p2d\_COUNTDOWN; \}
00898 
00899 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d padd<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} a + b
      ; \}
00900 
00901 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d psub<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} a - b
      ; \}
00902 
00903 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pnegate(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} p2d\_ZERO - a; \}
00904 
00905 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pconj(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} a; \}
00906 
00907 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pmul<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      vec\_madd(a,b,p2d\_MZERO); \}
00908 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pdiv<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      vec\_div(a,b); \}
00909 
00910 \textcolor{comment}{// for some weird raisons, it has to be overloaded for packet of integers}
00911 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pmadd(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b, \textcolor{keyword}{const} Packet2d& c) \{ \textcolor{keywordflow}{
      return} vec\_madd(a, b, c); \}
00912 
00913 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pmin<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      vec\_min(a, b); \}
00914 
00915 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pmax<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      vec\_max(a, b); \}
00916 
00917 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pand<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      vec\_and(a, b); \}
00918 
00919 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d por<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} vec\_or
      (a, b); \}
00920 
00921 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pxor<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      vec\_xor(a, b); \}
00922 
00923 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pandnot<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      vec\_and(a, vec\_nor(b, b)); \}
00924 
00925 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pround<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} vec\_round(a); \}
00926 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pceil<Packet2d>(\textcolor{keyword}{const}  Packet2d& a) \{ \textcolor{keywordflow}{return} vec\_ceil(a); \}
00927 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pfloor<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} vec\_floor(a); \}
00928 
00929 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d ploadu<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* from)
00930 \{
00931   EIGEN\_DEBUG\_ALIGNED\_LOAD
00932   \textcolor{keywordflow}{return} (Packet2d) vec\_vsx\_ld((\textcolor{keywordtype}{long})from & 15, (\textcolor{keyword}{const} \textcolor{keywordtype}{double}*) \_EIGEN\_ALIGNED\_PTR(from));
00933 \}
00934 
00935 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d ploaddup<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}*   from)
00936 \{
00937   Packet2d p;
00938   \textcolor{keywordflow}{if}((std::ptrdiff\_t(from) % 16) == 0)  p = pload<Packet2d>(from);
00939   \textcolor{keywordflow}{else}                                  p = ploadu<Packet2d>(from);
00940   \textcolor{keywordflow}{return} vec\_splat\_dbl<0>(p);
00941 \}
00942 
00943 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<double>(\textcolor{keywordtype}{double}*  to, \textcolor{keyword}{const} Packet2d& from)
00944 \{
00945   EIGEN\_DEBUG\_ALIGNED\_STORE
00946   vec\_vsx\_st((Packet4f)from, (\textcolor{keywordtype}{long})to & 15, (\textcolor{keywordtype}{float}*) \_EIGEN\_ALIGNED\_PTR(to));
00947 \}
00948 
00949 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<double>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* addr) \{ EIGEN\_PPC\_PREFETCH(addr); \}
00950 
00951 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double}  pfirst<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordtype}{double} EIGEN\_ALIGN16 x[2]; 
      pstore<double>(x, a); \textcolor{keywordflow}{return} x[0]; \}
00952 
00953 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d preverse(\textcolor{keyword}{const} Packet2d& a)
00954 \{
00955   \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_perm(reinterpret\_cast<Packet16uc>(a), reinterpret\_cast<Packet16uc>(
      a), p16uc\_REVERSE64));
00956 \}
00957 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pabs(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} vec\_abs(a); \}
00958 
00959 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux<Packet2d>(\textcolor{keyword}{const} Packet2d& a)
00960 \{
00961   Packet2d b, sum;
00962   b   = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4f>(a), reinterpret\_cast<Packet4f>(a), 8)
      );
00963   sum = a + b;
00964   \textcolor{keywordflow}{return} pfirst<Packet2d>(sum);
00965 \}
00966 
00967 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d preduxp<Packet2d>(\textcolor{keyword}{const} Packet2d* vecs)
00968 \{
00969   Packet2d v[2], sum;
00970   v[0] = vecs[0] + \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4f>(vecs[0]), 
      reinterpret\_cast<Packet4f>(vecs[0]), 8));
00971   v[1] = vecs[1] + \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4f>(vecs[1]), 
      reinterpret\_cast<Packet4f>(vecs[1]), 8));
00972  
00973 \textcolor{preprocessor}{#ifdef \_BIG\_ENDIAN}
00974   sum = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4f>(v[0]), reinterpret\_cast<Packet4f>(v[1
      ]), 8));
00975 \textcolor{preprocessor}{#else}
00976   sum = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4f>(v[1]), reinterpret\_cast<Packet4f>(v[0
      ]), 8));
00977 \textcolor{preprocessor}{#endif}
00978 
00979   \textcolor{keywordflow}{return} sum;
00980 \}
00981 \textcolor{comment}{// Other reduction functions:}
00982 \textcolor{comment}{// mul}
00983 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux\_mul<Packet2d>(\textcolor{keyword}{const} Packet2d& a)
00984 \{
00985   \textcolor{keywordflow}{return} pfirst(pmul(a, reinterpret\_cast<Packet2d>(vec\_sld(reinterpret\_cast<Packet4ui>(a), 
      reinterpret\_cast<Packet4ui>(a), 8))));
00986 \}
00987 
00988 \textcolor{comment}{// min}
00989 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux\_min<Packet2d>(\textcolor{keyword}{const} Packet2d& a)
00990 \{
00991   \textcolor{keywordflow}{return} pfirst(pmin(a, reinterpret\_cast<Packet2d>(vec\_sld(reinterpret\_cast<Packet4ui>(a), 
      reinterpret\_cast<Packet4ui>(a), 8))));
00992 \}
00993 
00994 \textcolor{comment}{// max}
00995 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux\_max<Packet2d>(\textcolor{keyword}{const} Packet2d& a)
00996 \{
00997   \textcolor{keywordflow}{return} pfirst(pmax(a, reinterpret\_cast<Packet2d>(vec\_sld(reinterpret\_cast<Packet4ui>(a), 
      reinterpret\_cast<Packet4ui>(a), 8))));
00998 \}
00999 
01000 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
01001 \textcolor{keyword}{struct }palign\_impl<Offset,Packet2d>
01002 \{
01003   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet2d& first, \textcolor{keyword}{const} Packet2d& second)
01004   \{
01005     \textcolor{keywordflow}{if} (Offset == 1)
01006 \textcolor{preprocessor}{#ifdef \_BIG\_ENDIAN}
01007       first = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4ui>(first), 
      reinterpret\_cast<Packet4ui>(second), 8));
01008 \textcolor{preprocessor}{#else}
01009       first = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4ui>(second), 
      reinterpret\_cast<Packet4ui>(first), 8));
01010 \textcolor{preprocessor}{#endif}
01011   \}
01012 \};
01013 
01014 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
01015 ptranspose(PacketBlock<Packet2d,2>& kernel) \{
01016   Packet2d t0, t1;
01017   t0 = vec\_perm(kernel.packet[0], kernel.packet[1], p16uc\_TRANSPOSE64\_HI);
01018   t1 = vec\_perm(kernel.packet[0], kernel.packet[1], p16uc\_TRANSPOSE64\_LO);
01019   kernel.packet[0] = t0;
01020   kernel.packet[1] = t1;
01021 \}
01022 
01023 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pblend(\textcolor{keyword}{const} Selector<2>& ifPacket, \textcolor{keyword}{const} Packet2d& thenPacket, \textcolor{keyword}{
      const} Packet2d& elsePacket) \{
01024   Packet2l select = \{ ifPacket.select[0], ifPacket.select[1] \};
01025   Packet2bl mask = vec\_cmpeq(reinterpret\_cast<Packet2d>(select), reinterpret\_cast<Packet2d>(p2l\_ONE));
01026   \textcolor{keywordflow}{return} vec\_sel(elsePacket, thenPacket, mask);
01027 \}
01028 \textcolor{preprocessor}{#endif // \_\_VSX\_\_}
01029 \} \textcolor{comment}{// end namespace internal}
01030 
01031 \} \textcolor{comment}{// end namespace Eigen}
01032 
01033 \textcolor{preprocessor}{#endif // EIGEN\_PACKET\_MATH\_ALTIVEC\_H}
\end{DoxyCode}
