\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_layout_swap_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Layout\+Swap.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_layout_swap_8h_source}\index{Tensor\+Layout\+Swap.\+h@{Tensor\+Layout\+Swap.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_LAYOUT\_SWAP\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_LAYOUT\_SWAP\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00037 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00038 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
00039 \textcolor{keyword}{struct }traits<TensorLayoutSwapOp<XprType> > : \textcolor{keyword}{public} traits<XprType>
00040 \{
00041   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00042   \textcolor{keyword}{typedef} traits<XprType> XprTraits;
00043   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00044   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00045   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00046   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<Nested>::type \_Nested;
00047   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = traits<XprType>::NumDimensions;
00048   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = (traits<XprType>::Layout == \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) ? 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor};
00049 \};
00050 
00051 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
00052 \textcolor{keyword}{struct }eval<TensorLayoutSwapOp<XprType>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00053 \{
00054   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorLayoutSwapOp<XprType>& type;
00055 \};
00056 
00057 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
00058 \textcolor{keyword}{struct }nested<TensorLayoutSwapOp<XprType>, 1, typename eval<TensorLayoutSwapOp<XprType> >::type>
00059 \{
00060   \textcolor{keyword}{typedef} TensorLayoutSwapOp<XprType> type;
00061 \};
00062 
00063 \}  \textcolor{comment}{// end namespace internal}
00064 
00065 
00066 
00067 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
00068 \textcolor{keyword}{class }TensorLayoutSwapOp : \textcolor{keyword}{public} TensorBase<TensorLayoutSwapOp<XprType>, WriteAccessors>
00069 \{
00070   \textcolor{keyword}{public}:
00071   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorLayoutSwapOp>::Scalar}
       Scalar;
00072   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00073   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<typename XprType::CoeffReturnType>::type CoeffReturnType;
00074   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorLayoutSwapOp>::type}
       Nested;
00075   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorLayoutSwapOp>::StorageKind}
       StorageKind;
00076   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorLayoutSwapOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00077 
00078   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorLayoutSwapOp(\textcolor{keyword}{const} XprType& expr)
00079       : m\_xpr(expr) \{\}
00080 
00081     EIGEN\_DEVICE\_FUNC
00082     \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type&
00083     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00084 
00085     EIGEN\_DEVICE\_FUNC
00086     EIGEN\_STRONG\_INLINE TensorLayoutSwapOp& operator = (\textcolor{keyword}{const} TensorLayoutSwapOp& other)
00087     \{
00088       \textcolor{keyword}{typedef} TensorAssignOp<TensorLayoutSwapOp, const TensorLayoutSwapOp> Assign;
00089       Assign assign(*\textcolor{keyword}{this}, other);
00090       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00091       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00092     \}
00093 
00094     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00095     EIGEN\_DEVICE\_FUNC
00096     EIGEN\_STRONG\_INLINE TensorLayoutSwapOp& operator = (\textcolor{keyword}{const} OtherDerived& other)
00097     \{
00098       \textcolor{keyword}{typedef} TensorAssignOp<TensorLayoutSwapOp, const OtherDerived> Assign;
00099       Assign assign(*\textcolor{keyword}{this}, other);
00100       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00101       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00102     \}
00103 
00104   \textcolor{keyword}{protected}:
00105     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00106 \};
00107 
00108 
00109 \textcolor{comment}{// Eval as rvalue}
00110 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00111 \textcolor{keyword}{struct }TensorEvaluator<const TensorLayoutSwapOp<ArgType>, Device>
00112 \{
00113   \textcolor{keyword}{typedef} TensorLayoutSwapOp<ArgType> XprType;
00114   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00115   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::array\_size<typename TensorEvaluator<ArgType, Device>::Dimensions>
      ::value;
00116   \textcolor{keyword}{typedef} DSizes<Index, NumDims> Dimensions;
00117 
00118   \textcolor{keyword}{enum} \{
00119     IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,
00120     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00121     Layout = (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(TensorEvaluator<ArgType, Device>::Layout) == static\_cast<int>(
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},
00122     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00123     RawAccess = TensorEvaluator<ArgType, Device>::RawAccess
00124   \};
00125 
00126   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00127       : m\_impl(op.expression(), device)
00128   \{
00129     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i) \{
00130       m\_dimensions[i] = m\_impl.dimensions()[NumDims-1-i];
00131     \}
00132   \}
00133 
00134   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00135   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00136   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00137 
00138   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00139 
00140   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(CoeffReturnType* data) \{
00141     \textcolor{keywordflow}{return} m\_impl.evalSubExprsIfNeeded(data);
00142   \}
00143   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00144     m\_impl.cleanup();
00145   \}
00146 
00147   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00148 \textcolor{keyword}{  }\{
00149     \textcolor{keywordflow}{return} m\_impl.coeff(index);
00150   \}
00151 
00152   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00153   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00154 \textcolor{keyword}{  }\{
00155     \textcolor{keywordflow}{return} m\_impl.template packet<LoadMode>(index);
00156   \}
00157 
00158   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorOpCost costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00159     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized);
00160   \}
00161 
00162   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_impl.data(); \}
00163 
00164   \textcolor{keyword}{const} TensorEvaluator<ArgType, Device>& impl()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_impl; \}
00165 
00166  \textcolor{keyword}{protected}:
00167   TensorEvaluator<ArgType, Device> m\_impl;
00168   Dimensions m\_dimensions;
00169 \};
00170 
00171 
00172 \textcolor{comment}{// Eval as lvalue}
00173 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00174   \textcolor{keyword}{struct }TensorEvaluator<TensorLayoutSwapOp<ArgType>, Device>
00175   : \textcolor{keyword}{public} TensorEvaluator<const TensorLayoutSwapOp<ArgType>, Device>
00176 \{
00177   \textcolor{keyword}{typedef} TensorEvaluator<const TensorLayoutSwapOp<ArgType>, Device> Base;
00178   \textcolor{keyword}{typedef} TensorLayoutSwapOp<ArgType> XprType;
00179 
00180   \textcolor{keyword}{enum} \{
00181     IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,
00182     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00183     Layout = (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(TensorEvaluator<ArgType, Device>::Layout) == static\_cast<int>(
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},
00184     CoordAccess = \textcolor{keyword}{false}  \textcolor{comment}{// to be implemented}
00185   \};
00186 
00187   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00188     : Base(op, device)
00189   \{ \}
00190 
00191   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00192   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00193   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00194   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00195 
00196   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType& coeffRef(Index index)
00197   \{
00198     \textcolor{keywordflow}{return} this->m\_impl.coeffRef(index);
00199   \}
00200   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} StoreMode> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00201   \textcolor{keywordtype}{void} writePacket(Index index, \textcolor{keyword}{const} PacketReturnType& x)
00202   \{
00203     this->m\_impl.template writePacket<StoreMode>(index, x);
00204   \}
00205 \};
00206 
00207 \} \textcolor{comment}{// end namespace Eigen}
00208 
00209 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_LAYOUT\_SWAP\_H}
\end{DoxyCode}
