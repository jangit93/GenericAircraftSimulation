\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_real_q_z_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Eigenvalues/\+Real\+QZ.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_real_q_z_8h_source}\index{Real\+Q\+Z.\+h@{Real\+Q\+Z.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Alexey Korepanov <kaikaikai@yandex.ru>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_REAL\_QZ\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_REAL\_QZ\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00057   \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType> \textcolor{keyword}{class }RealQZ
00058   \{
00059     \textcolor{keyword}{public}:
00060       \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00061       \textcolor{keyword}{enum} \{
00062         RowsAtCompileTime = MatrixType::RowsAtCompileTime,
00063         ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00064         Options = MatrixType::Options,
00065         MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
00066         MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
00067       \};
00068       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00069       \textcolor{keyword}{typedef} std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_real_q_z_8h_source_l00070}\hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{00070}       \textcolor{keyword}{typedef} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Eigen::Index} \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index}; 
00071 
00072       \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module}{Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1>}
       \hyperlink{group___core___module}{EigenvalueType};
00073       \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module}{Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1>}
       \hyperlink{group___core___module}{ColumnVectorType};
00074 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_real_q_z_8h_source_l00086}\hyperlink{group___eigenvalues___module_ad8fb9235870a8361a2fdd8dcc2e80d01}{00086}       \textcolor{keyword}{explicit} \hyperlink{group___eigenvalues___module_ad8fb9235870a8361a2fdd8dcc2e80d01}{RealQZ}(Index size = RowsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} ? 1 : RowsAtCompileTime) :
00087         m\_S(size, size),
00088         m\_T(size, size),
00089         m\_Q(size, size),
00090         m\_Z(size, size),
00091         m\_workspace(size*2),
00092         m\_maxIters(400),
00093         m\_isInitialized(false)
00094         \{ \}
00095 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_real_q_z_8h_source_l00104}\hyperlink{group___eigenvalues___module_ac6e41c839f8dae31c9a3906ea7540119}{00104}       \hyperlink{group___eigenvalues___module_ac6e41c839f8dae31c9a3906ea7540119}{RealQZ}(\textcolor{keyword}{const} MatrixType& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, \textcolor{keyword}{const} MatrixType& \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, \textcolor{keywordtype}{bool} computeQZ = \textcolor{keyword}{true}) :
00105         m\_S(A.rows(),A.cols()),
00106         m\_T(A.rows(),A.cols()),
00107         m\_Q(A.rows(),A.cols()),
00108         m\_Z(A.rows(),A.cols()),
00109         m\_workspace(A.rows()*2),
00110         m\_maxIters(400),
00111         m\_isInitialized(false) \{
00112           \hyperlink{group___eigenvalues___module_a2b6847964d9f1903193cc3e67c196849}{compute}(A, B, computeQZ);
00113         \}
00114 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_real_q_z_8h_source_l00119}\hyperlink{group___eigenvalues___module_a212bc2f69ea4eff830fde70e209e40fb}{00119}       \textcolor{keyword}{const} MatrixType& \hyperlink{group___eigenvalues___module_a212bc2f69ea4eff830fde70e209e40fb}{matrixQ}()\textcolor{keyword}{ const }\{
00120         eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"RealQZ is not initialized."});
00121         eigen\_assert(m\_computeQZ && \textcolor{stringliteral}{"The matrices Q and Z have not been computed during the QZ
       decomposition."});
00122         \textcolor{keywordflow}{return} m\_Q;
00123       \}
00124 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_real_q_z_8h_source_l00129}\hyperlink{group___eigenvalues___module_a19a116383f11423179b4d8f316da6f67}{00129}       \textcolor{keyword}{const} MatrixType& \hyperlink{group___eigenvalues___module_a19a116383f11423179b4d8f316da6f67}{matrixZ}()\textcolor{keyword}{ const }\{
00130         eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"RealQZ is not initialized."});
00131         eigen\_assert(m\_computeQZ && \textcolor{stringliteral}{"The matrices Q and Z have not been computed during the QZ
       decomposition."});
00132         \textcolor{keywordflow}{return} m\_Z;
00133       \}
00134 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_real_q_z_8h_source_l00139}\hyperlink{group___eigenvalues___module_ad24d7bf534afb55adaef00f00846adaf}{00139}       \textcolor{keyword}{const} MatrixType& \hyperlink{group___eigenvalues___module_ad24d7bf534afb55adaef00f00846adaf}{matrixS}()\textcolor{keyword}{ const }\{
00140         eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"RealQZ is not initialized."});
00141         \textcolor{keywordflow}{return} m\_S;
00142       \}
00143 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_real_q_z_8h_source_l00148}\hyperlink{group___eigenvalues___module_a8dc963d8ea2a17df9d8d718e9e34d06f}{00148}       \textcolor{keyword}{const} MatrixType& \hyperlink{group___eigenvalues___module_a8dc963d8ea2a17df9d8d718e9e34d06f}{matrixT}()\textcolor{keyword}{ const }\{
00149         eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"RealQZ is not initialized."});
00150         \textcolor{keywordflow}{return} m\_T;
00151       \}
00152 
00160       \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_q_z}{RealQZ}& \hyperlink{group___eigenvalues___module_a2b6847964d9f1903193cc3e67c196849}{compute}(\textcolor{keyword}{const} MatrixType& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, \textcolor{keyword}{const} MatrixType& \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, \textcolor{keywordtype}{bool} computeQZ = \textcolor{keyword}{true});
00161 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_real_q_z_8h_source_l00166}\hyperlink{group___eigenvalues___module_a36bd77afed89f3f5c110a715e69e4c64}{00166}       \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} \hyperlink{group___eigenvalues___module_a36bd77afed89f3f5c110a715e69e4c64}{info}()\textcolor{keyword}{ const}
00167 \textcolor{keyword}{      }\{
00168         eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"RealQZ is not initialized."});
00169         \textcolor{keywordflow}{return} m\_info;
00170       \}
00171 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_real_q_z_8h_source_l00174}\hyperlink{group___eigenvalues___module_afbecc6d0ab1de42be9db79428da48ab6}{00174}       Index \hyperlink{group___eigenvalues___module_afbecc6d0ab1de42be9db79428da48ab6}{iterations}()\textcolor{keyword}{ const}
00175 \textcolor{keyword}{      }\{
00176         eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"RealQZ is not initialized."});
00177         \textcolor{keywordflow}{return} m\_global\_iter;
00178       \}
00179 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_real_q_z_8h_source_l00183}\hyperlink{group___eigenvalues___module_a30ae65666b1757e4a2b6a28eaec12226}{00183}       \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_q_z}{RealQZ}& \hyperlink{group___eigenvalues___module_a30ae65666b1757e4a2b6a28eaec12226}{setMaxIterations}(Index maxIters)
00184       \{
00185         m\_maxIters = maxIters;
00186         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00187       \}
00188 
00189     \textcolor{keyword}{private}:
00190 
00191       MatrixType m\_S, m\_T, m\_Q, m\_Z;
00192       \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} m\_workspace;
00193       \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} m\_info;
00194       Index m\_maxIters;
00195       \textcolor{keywordtype}{bool} m\_isInitialized;
00196       \textcolor{keywordtype}{bool} m\_computeQZ;
00197       Scalar m\_normOfT, m\_normOfS;
00198       Index m\_global\_iter;
00199 
00200       \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,3,1>} \hyperlink{group___core___module}{Vector3s};
00201       \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,2,1>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Vector2s};
00202       \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,2,2>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix2s};
00203       \textcolor{keyword}{typedef} \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<Scalar>} \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JRs};
00204 
00205       \textcolor{keywordtype}{void} hessenbergTriangular();
00206       \textcolor{keywordtype}{void} computeNorms();
00207       Index findSmallSubdiagEntry(Index iu);
00208       Index findSmallDiagEntry(Index f, Index l);
00209       \textcolor{keywordtype}{void} splitOffTwoRows(Index i);
00210       \textcolor{keywordtype}{void} pushDownZero(Index z, Index f, Index l);
00211       \textcolor{keywordtype}{void} step(Index f, Index l, Index iter);
00212 
00213   \}; \textcolor{comment}{// RealQZ}
00214 
00216   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00217     \textcolor{keywordtype}{void} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_q_z}{RealQZ<MatrixType>::hessenbergTriangular}()
00218     \{
00219 
00220       \textcolor{keyword}{const} \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} dim = m\_S.cols();
00221 
00222       \textcolor{comment}{// perform QR decomposition of T, overwrite T with R, save Q}
00223       \hyperlink{group___q_r___module}{HouseholderQR<MatrixType>} qrT(m\_T);
00224       m\_T = qrT.\hyperlink{group___q_r___module_ae837f2fb30099212c53b3042c7d699c9}{matrixQR}();
00225       m\_T.template triangularView<StrictlyLower>().setZero();
00226       m\_Q = qrT.\hyperlink{group___q_r___module_affd506c10ef2d25f56e7b1f9f25ff885}{householderQ}();
00227       \textcolor{comment}{// overwrite S with Q* S}
00228       m\_S.applyOnTheLeft(m\_Q.adjoint());
00229       \textcolor{comment}{// init Z as Identity}
00230       \textcolor{keywordflow}{if} (m\_computeQZ)
00231         m\_Z = MatrixType::Identity(dim,dim);
00232       \textcolor{comment}{// reduce S to upper Hessenberg with Givens rotations}
00233       \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} j=0; j<=dim-3; j++) \{
00234         \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} i=dim-1; i>=j+2; i--) \{
00235           \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JRs} G;
00236           \textcolor{comment}{// kill S(i,j)}
00237           \textcolor{keywordflow}{if}(m\_S.coeff(i,j) != 0)
00238           \{
00239             G.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(m\_S.coeff(i-1,j), m\_S.coeff(i,j), &m\_S.coeffRef(i-1, j));
00240             m\_S.coeffRef(i,j) = Scalar(0.0);
00241             m\_S.rightCols(dim-j-1).applyOnTheLeft(i-1,i,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00242             m\_T.rightCols(dim-i+1).applyOnTheLeft(i-1,i,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00243             \textcolor{comment}{// update Q}
00244             \textcolor{keywordflow}{if} (m\_computeQZ)
00245               m\_Q.applyOnTheRight(i-1,i,G);
00246           \}
00247           \textcolor{comment}{// kill T(i,i-1)}
00248           \textcolor{keywordflow}{if}(m\_T.coeff(i,i-1)!=Scalar(0))
00249           \{
00250             G.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(m\_T.coeff(i,i), m\_T.coeff(i,i-1), &m\_T.coeffRef(i,i));
00251             m\_T.coeffRef(i,i-1) = Scalar(0.0);
00252             m\_S.applyOnTheRight(i,i-1,G);
00253             m\_T.topRows(i).applyOnTheRight(i,i-1,G);
00254             \textcolor{comment}{// update Z}
00255             \textcolor{keywordflow}{if} (m\_computeQZ)
00256               m\_Z.applyOnTheLeft(i,i-1,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00257           \}
00258         \}
00259       \}
00260     \}
00261 
00263   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00264     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_q_z}{RealQZ<MatrixType>::computeNorms}()
00265     \{
00266       \textcolor{keyword}{const} \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} size = m\_S.cols();
00267       m\_normOfS = Scalar(0.0);
00268       m\_normOfT = Scalar(0.0);
00269       \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} j = 0; j < size; ++j)
00270       \{
00271         m\_normOfS += m\_S.col(j).segment(0, (std::min)(size,j+2)).cwiseAbs().sum();
00272         m\_normOfT += m\_T.row(j).segment(j, size - j).cwiseAbs().sum();
00273       \}
00274     \}
00275 
00276 
00278   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00279     \textcolor{keyword}{inline} \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_q_z}{RealQZ<MatrixType>::findSmallSubdiagEntry}(
      \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} iu)
00280     \{
00281       \textcolor{keyword}{using} std::abs;
00282       \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} res = iu;
00283       \textcolor{keywordflow}{while} (res > 0)
00284       \{
00285         Scalar s = abs(m\_S.coeff(res-1,res-1)) + abs(m\_S.coeff(res,res));
00286         \textcolor{keywordflow}{if} (s == Scalar(0.0))
00287           s = m\_normOfS;
00288         \textcolor{keywordflow}{if} (abs(m\_S.coeff(res,res-1)) < \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}() * s)
00289           \textcolor{keywordflow}{break};
00290         res--;
00291       \}
00292       \textcolor{keywordflow}{return} res;
00293     \}
00294 
00296   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00297     \textcolor{keyword}{inline} \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_q_z}{RealQZ<MatrixType>::findSmallDiagEntry}(
      \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} f, \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} l)
00298     \{
00299       \textcolor{keyword}{using} std::abs;
00300       \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} res = l;
00301       \textcolor{keywordflow}{while} (res >= f) \{
00302         \textcolor{keywordflow}{if} (abs(m\_T.coeff(res,res)) <= \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}() * m\_normOfT)
00303           \textcolor{keywordflow}{break};
00304         res--;
00305       \}
00306       \textcolor{keywordflow}{return} res;
00307     \}
00308 
00310   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00311     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_q_z}{RealQZ<MatrixType>::splitOffTwoRows}(
      \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} i)
00312     \{
00313       \textcolor{keyword}{using} std::abs;
00314       \textcolor{keyword}{using} std::sqrt;
00315       \textcolor{keyword}{const} \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} dim=m\_S.cols();
00316       \textcolor{keywordflow}{if} (abs(m\_S.coeff(i+1,i))==Scalar(0))
00317         \textcolor{keywordflow}{return};
00318       \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} j = findSmallDiagEntry(i,i+1);
00319       \textcolor{keywordflow}{if} (j==i-1)
00320       \{
00321         \textcolor{comment}{// block of (S T^\{-1\})}
00322         \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix2s} STi = m\_T.template block<2,2>(i,i).\textcolor{keyword}{template} triangularView<Upper>().
00323           \textcolor{keyword}{template} solve<OnTheRight>(m\_S.template block<2,2>(i,i));
00324         Scalar p = Scalar(0.5)*(STi(0,0)-STi(1,1));
00325         Scalar q = p*p + STi(1,0)*STi(0,1);
00326         \textcolor{keywordflow}{if} (q>=0) \{
00327           Scalar z = sqrt(q);
00328           \textcolor{comment}{// one QR-like iteration for ABi - lambda I}
00329           \textcolor{comment}{// is enough - when we know exact eigenvalue in advance,}
00330           \textcolor{comment}{// convergence is immediate}
00331           \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JRs} G;
00332           \textcolor{keywordflow}{if} (p>=0)
00333             G.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(p + z, STi(1,0));
00334           \textcolor{keywordflow}{else}
00335             G.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(p - z, STi(1,0));
00336           m\_S.rightCols(dim-i).applyOnTheLeft(i,i+1,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00337           m\_T.rightCols(dim-i).applyOnTheLeft(i,i+1,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00338           \textcolor{comment}{// update Q}
00339           \textcolor{keywordflow}{if} (m\_computeQZ)
00340             m\_Q.applyOnTheRight(i,i+1,G);
00341 
00342           G.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(m\_T.coeff(i+1,i+1), m\_T.coeff(i+1,i));
00343           m\_S.topRows(i+2).applyOnTheRight(i+1,i,G);
00344           m\_T.topRows(i+2).applyOnTheRight(i+1,i,G);
00345           \textcolor{comment}{// update Z}
00346           \textcolor{keywordflow}{if} (m\_computeQZ)
00347             m\_Z.applyOnTheLeft(i+1,i,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00348 
00349           m\_S.coeffRef(i+1,i) = Scalar(0.0);
00350           m\_T.coeffRef(i+1,i) = Scalar(0.0);
00351         \}
00352       \}
00353       \textcolor{keywordflow}{else}
00354       \{
00355         pushDownZero(j,i,i+1);
00356       \}
00357     \}
00358 
00360   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00361     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_q_z}{RealQZ<MatrixType>::pushDownZero}(
      \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} z, \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} f, \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} l)
00362     \{
00363       \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JRs} G;
00364       \textcolor{keyword}{const} \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} dim = m\_S.cols();
00365       \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} zz=z; zz<l; zz++)
00366       \{
00367         \textcolor{comment}{// push 0 down}
00368         \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} firstColS = zz>f ? (zz-1) : zz;
00369         G.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(m\_T.coeff(zz, zz+1), m\_T.coeff(zz+1, zz+1));
00370         m\_S.rightCols(dim-firstColS).applyOnTheLeft(zz,zz+1,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00371         m\_T.rightCols(dim-zz).applyOnTheLeft(zz,zz+1,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00372         m\_T.coeffRef(zz+1,zz+1) = Scalar(0.0);
00373         \textcolor{comment}{// update Q}
00374         \textcolor{keywordflow}{if} (m\_computeQZ)
00375           m\_Q.applyOnTheRight(zz,zz+1,G);
00376         \textcolor{comment}{// kill S(zz+1, zz-1)}
00377         \textcolor{keywordflow}{if} (zz>f)
00378         \{
00379           G.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(m\_S.coeff(zz+1, zz), m\_S.coeff(zz+1,zz-1));
00380           m\_S.topRows(zz+2).applyOnTheRight(zz, zz-1,G);
00381           m\_T.topRows(zz+1).applyOnTheRight(zz, zz-1,G);
00382           m\_S.coeffRef(zz+1,zz-1) = Scalar(0.0);
00383           \textcolor{comment}{// update Z}
00384           \textcolor{keywordflow}{if} (m\_computeQZ)
00385             m\_Z.applyOnTheLeft(zz,zz-1,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00386         \}
00387       \}
00388       \textcolor{comment}{// finally kill S(l,l-1)}
00389       G.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(m\_S.coeff(l,l), m\_S.coeff(l,l-1));
00390       m\_S.applyOnTheRight(l,l-1,G);
00391       m\_T.applyOnTheRight(l,l-1,G);
00392       m\_S.coeffRef(l,l-1)=Scalar(0.0);
00393       \textcolor{comment}{// update Z}
00394       \textcolor{keywordflow}{if} (m\_computeQZ)
00395         m\_Z.applyOnTheLeft(l,l-1,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00396     \}
00397 
00399   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00400     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_q_z}{RealQZ<MatrixType>::step}(\hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} f, 
      \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} l, \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} iter)
00401     \{
00402       \textcolor{keyword}{using} std::abs;
00403       \textcolor{keyword}{const} \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} dim = m\_S.cols();
00404 
00405       \textcolor{comment}{// x, y, z}
00406       Scalar x, y, z;
00407       \textcolor{keywordflow}{if} (iter==10)
00408       \{
00409         \textcolor{comment}{// Wilkinson ad hoc shift}
00410         \textcolor{keyword}{const} Scalar
00411           a11=m\_S.coeff(f+0,f+0), a12=m\_S.coeff(f+0,f+1),
00412           a21=m\_S.coeff(f+1,f+0), a22=m\_S.coeff(f+1,f+1), a32=m\_S.coeff(f+2,f+1),
00413           b12=m\_T.coeff(f+0,f+1),
00414           b11i=Scalar(1.0)/m\_T.coeff(f+0,f+0),
00415           b22i=Scalar(1.0)/m\_T.coeff(f+1,f+1),
00416           a87=m\_S.coeff(l-1,l-2),
00417           a98=m\_S.coeff(l-0,l-1),
00418           b77i=Scalar(1.0)/m\_T.coeff(l-2,l-2),
00419           b88i=Scalar(1.0)/m\_T.coeff(l-1,l-1);
00420         Scalar ss = abs(a87*b77i) + abs(a98*b88i),
00421                lpl = Scalar(1.5)*ss,
00422                ll = ss*ss;
00423         x = ll + a11*a11*b11i*b11i - lpl*a11*b11i + a12*a21*b11i*b22i
00424           - a11*a21*b12*b11i*b11i*b22i;
00425         y = a11*a21*b11i*b11i - lpl*a21*b11i + a21*a22*b11i*b22i 
00426           - a21*a21*b12*b11i*b11i*b22i;
00427         z = a21*a32*b11i*b22i;
00428       \}
00429       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (iter==16)
00430       \{
00431         \textcolor{comment}{// another exceptional shift}
00432         x = m\_S.coeff(f,f)/m\_T.coeff(f,f)-m\_S.coeff(l,l)/m\_T.coeff(l,l) + m\_S.coeff(l,l-1)*m\_T.coeff(l-1,l)
       /
00433           (m\_T.coeff(l-1,l-1)*m\_T.coeff(l,l));
00434         y = m\_S.coeff(f+1,f)/m\_T.coeff(f,f);
00435         z = 0;
00436       \}
00437       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (iter>23 && !(iter%8))
00438       \{
00439         \textcolor{comment}{// extremely exceptional shift}
00440         x = internal::random<Scalar>(-1.0,1.0);
00441         y = internal::random<Scalar>(-1.0,1.0);
00442         z = internal::random<Scalar>(-1.0,1.0);
00443       \}
00444       \textcolor{keywordflow}{else}
00445       \{
00446         \textcolor{comment}{// Compute the shifts: (x,y,z,0...) = (AB^-1 - l1 I) (AB^-1 - l2 I) e1}
00447         \textcolor{comment}{// where l1 and l2 are the eigenvalues of the 2x2 matrix C = U V^-1 where}
00448         \textcolor{comment}{// U and V are 2x2 bottom right sub matrices of A and B. Thus:}
00449         \textcolor{comment}{//  = AB^-1AB^-1 + l1 l2 I - (l1+l2)(AB^-1)}
00450         \textcolor{comment}{//  = AB^-1AB^-1 + det(M) - tr(M)(AB^-1)}
00451         \textcolor{comment}{// Since we are only interested in having x, y, z with a correct ratio, we have:}
00452         \textcolor{keyword}{const} Scalar
00453           a11 = m\_S.coeff(f,f),     a12 = m\_S.coeff(f,f+1),
00454           a21 = m\_S.coeff(f+1,f),   a22 = m\_S.coeff(f+1,f+1),
00455                                     a32 = m\_S.coeff(f+2,f+1),
00456 
00457           a88 = m\_S.coeff(l-1,l-1), a89 = m\_S.coeff(l-1,l),
00458           a98 = m\_S.coeff(l,l-1),   a99 = m\_S.coeff(l,l),
00459 
00460           b11 = m\_T.coeff(f,f),     b12 = m\_T.coeff(f,f+1),
00461                                     b22 = m\_T.coeff(f+1,f+1),
00462 
00463           b88 = m\_T.coeff(l-1,l-1), b89 = m\_T.coeff(l-1,l),
00464                                     b99 = m\_T.coeff(l,l);
00465 
00466         x = ( (a88/b88 - a11/b11)*(a99/b99 - a11/b11) - (a89/b99)*(a98/b88) + (a98/b88)*(b89/b99)*(a11/b11)
       ) * (b11/a21)
00467           + a12/b22 - (a11/b11)*(b12/b22);
00468         y = (a22/b22-a11/b11) - (a21/b11)*(b12/b22) - (a88/b88-a11/b11) - (a99/b99-a11/b11) + (a98/b88)*(
      b89/b99);
00469         z = a32/b22;
00470       \}
00471 
00472       \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JRs} G;
00473 
00474       \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} k=f; k<=l-2; k++)
00475       \{
00476         \textcolor{comment}{// variables for Householder reflections}
00477         \hyperlink{group___core___module_class_eigen_1_1_matrix}{Vector2s} essential2;
00478         Scalar tau, beta;
00479 
00480         \hyperlink{group___core___module}{Vector3s} hr(x,y,z);
00481 
00482         \textcolor{comment}{// Q\_k to annihilate S(k+1,k-1) and S(k+2,k-1)}
00483         hr.makeHouseholderInPlace(tau, beta);
00484         essential2 = hr.template bottomRows<2>();
00485         \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} fc=(std::max)(k-1,\hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index}(0));  \textcolor{comment}{// first col to update}
00486         m\_S.template middleRows<3>(k).rightCols(dim-fc).applyHouseholderOnTheLeft(essential2, tau, 
      m\_workspace.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}());
00487         m\_T.template middleRows<3>(k).rightCols(dim-fc).applyHouseholderOnTheLeft(essential2, tau, 
      m\_workspace.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}());
00488         \textcolor{keywordflow}{if} (m\_computeQZ)
00489           m\_Q.template middleCols<3>(k).applyHouseholderOnTheRight(essential2, tau, m\_workspace.
      \hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}());
00490         \textcolor{keywordflow}{if} (k>f)
00491           m\_S.coeffRef(k+2,k-1) = m\_S.coeffRef(k+1,k-1) = Scalar(0.0);
00492 
00493         \textcolor{comment}{// Z\_\{k1\} to annihilate T(k+2,k+1) and T(k+2,k)}
00494         hr << m\_T.coeff(k+2,k+2),m\_T.coeff(k+2,k),m\_T.coeff(k+2,k+1);
00495         hr.makeHouseholderInPlace(tau, beta);
00496         essential2 = hr.template bottomRows<2>();
00497         \{
00498           \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} lr = (std::min)(k+4,dim); \textcolor{comment}{// last row to update}
00499           \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<Scalar,Dynamic,1>} > tmp(m\_workspace.
      \hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(),lr);
00500           \textcolor{comment}{// S}
00501           tmp = m\_S.template middleCols<2>(k).topRows(lr) * essential2;
00502           tmp += m\_S.col(k+2).head(lr);
00503           m\_S.col(k+2).head(lr) -= tau*tmp;
00504           m\_S.template middleCols<2>(k).topRows(lr) -= (tau*tmp) * essential2.adjoint();
00505           \textcolor{comment}{// T}
00506           tmp = m\_T.template middleCols<2>(k).topRows(lr) * essential2;
00507           tmp += m\_T.col(k+2).head(lr);
00508           m\_T.col(k+2).head(lr) -= tau*tmp;
00509           m\_T.template middleCols<2>(k).topRows(lr) -= (tau*tmp) * essential2.adjoint();
00510         \}
00511         \textcolor{keywordflow}{if} (m\_computeQZ)
00512         \{
00513           \textcolor{comment}{// Z}
00514           \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<Scalar,1,Dynamic>} > tmp(m\_workspace.
      \hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(),dim);
00515           tmp = essential2.adjoint()*(m\_Z.template middleRows<2>(k));
00516           tmp += m\_Z.row(k+2);
00517           m\_Z.row(k+2) -= tau*tmp;
00518           m\_Z.template middleRows<2>(k) -= essential2 * (tau*tmp);
00519         \}
00520         m\_T.coeffRef(k+2,k) = m\_T.coeffRef(k+2,k+1) = Scalar(0.0);
00521 
00522         \textcolor{comment}{// Z\_\{k2\} to annihilate T(k+1,k)}
00523         G.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(m\_T.coeff(k+1,k+1), m\_T.coeff(k+1,k));
00524         m\_S.applyOnTheRight(k+1,k,G);
00525         m\_T.applyOnTheRight(k+1,k,G);
00526         \textcolor{comment}{// update Z}
00527         \textcolor{keywordflow}{if} (m\_computeQZ)
00528           m\_Z.applyOnTheLeft(k+1,k,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00529         m\_T.coeffRef(k+1,k) = Scalar(0.0);
00530 
00531         \textcolor{comment}{// update x,y,z}
00532         x = m\_S.coeff(k+1,k);
00533         y = m\_S.coeff(k+2,k);
00534         \textcolor{keywordflow}{if} (k < l-2)
00535           z = m\_S.coeff(k+3,k);
00536       \} \textcolor{comment}{// loop over k}
00537 
00538       \textcolor{comment}{// Q\_\{n-1\} to annihilate y = S(l,l-2)}
00539       G.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(x,y);
00540       m\_S.applyOnTheLeft(l-1,l,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00541       m\_T.applyOnTheLeft(l-1,l,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00542       \textcolor{keywordflow}{if} (m\_computeQZ)
00543         m\_Q.applyOnTheRight(l-1,l,G);
00544       m\_S.coeffRef(l,l-2) = Scalar(0.0);
00545 
00546       \textcolor{comment}{// Z\_\{n-1\} to annihilate T(l,l-1)}
00547       G.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(m\_T.coeff(l,l),m\_T.coeff(l,l-1));
00548       m\_S.applyOnTheRight(l,l-1,G);
00549       m\_T.applyOnTheRight(l,l-1,G);
00550       \textcolor{keywordflow}{if} (m\_computeQZ)
00551         m\_Z.applyOnTheLeft(l,l-1,G.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00552       m\_T.coeffRef(l,l-1) = Scalar(0.0);
00553     \}
00554 
00555   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00556     \hyperlink{group___eigenvalues___module}{RealQZ<MatrixType>}& \hyperlink{group___eigenvalues___module_a2b6847964d9f1903193cc3e67c196849}{RealQZ<MatrixType>::compute}(\textcolor{keyword}{const} 
      MatrixType& A\_in, \textcolor{keyword}{const} MatrixType& B\_in, \textcolor{keywordtype}{bool} computeQZ)
00557     \{
00558 
00559       \textcolor{keyword}{const} \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} dim = A\_in.cols();
00560 
00561       eigen\_assert (A\_in.rows()==dim && A\_in.cols()==dim 
00562           && B\_in.rows()==dim && B\_in.cols()==dim 
00563           && \textcolor{stringliteral}{"Need square matrices of the same dimension"});
00564 
00565       m\_isInitialized = \textcolor{keyword}{true};
00566       m\_computeQZ = computeQZ;
00567       m\_S = A\_in; m\_T = B\_in;
00568       m\_workspace.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(dim*2);
00569       m\_global\_iter = 0;
00570 
00571       \textcolor{comment}{// entrance point: hessenberg triangular decomposition}
00572       hessenbergTriangular();
00573       \textcolor{comment}{// compute L1 vector norms of T, S into m\_normOfS, m\_normOfT}
00574       computeNorms();
00575 
00576       \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} l = dim-1, 
00577             f, 
00578             local\_iter = 0;
00579 
00580       \textcolor{keywordflow}{while} (l>0 && local\_iter<m\_maxIters)
00581       \{
00582         f = findSmallSubdiagEntry(l);
00583         \textcolor{comment}{// now rows and columns f..l (including) decouple from the rest of the problem}
00584         \textcolor{keywordflow}{if} (f>0) m\_S.coeffRef(f,f-1) = Scalar(0.0);
00585         \textcolor{keywordflow}{if} (f == l) \textcolor{comment}{// One root found}
00586         \{
00587           l--;
00588           local\_iter = 0;
00589         \}
00590         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (f == l-1) \textcolor{comment}{// Two roots found}
00591         \{
00592           splitOffTwoRows(f);
00593           l -= 2;
00594           local\_iter = 0;
00595         \}
00596         \textcolor{keywordflow}{else} \textcolor{comment}{// No convergence yet}
00597         \{
00598           \textcolor{comment}{// if there's zero on diagonal of T, we can isolate an eigenvalue with Givens rotations}
00599           \hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} z = findSmallDiagEntry(f,l);
00600           \textcolor{keywordflow}{if} (z>=f)
00601           \{
00602             \textcolor{comment}{// zero found}
00603             pushDownZero(z,f,l);
00604           \}
00605           \textcolor{keywordflow}{else}
00606           \{
00607             \textcolor{comment}{// We are sure now that S.block(f,f, l-f+1,l-f+1) is underuced upper-Hessenberg }
00608             \textcolor{comment}{// and T.block(f,f, l-f+1,l-f+1) is invertible uper-triangular, which allows to}
00609             \textcolor{comment}{// apply a QR-like iteration to rows and columns f..l.}
00610             step(f,l, local\_iter);
00611             local\_iter++;
00612             m\_global\_iter++;
00613           \}
00614         \}
00615       \}
00616       \textcolor{comment}{// check if we converged before reaching iterations limit}
00617       m\_info = (local\_iter<m\_maxIters) ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} : \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence};
00618 
00619       \textcolor{comment}{// For each non triangular 2x2 diagonal block of S,}
00620       \textcolor{comment}{//    reduce the respective 2x2 diagonal block of T to positive diagonal form using 2x2 SVD.}
00621       \textcolor{comment}{// This step is not mandatory for QZ, but it does help further extraction of
       eigenvalues/eigenvectors,}
00622       \textcolor{comment}{// and is in par with Lapack/Matlab QZ.}
00623       \textcolor{keywordflow}{if}(m\_info==\hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success})
00624       \{
00625         \textcolor{keywordflow}{for}(\hyperlink{group___eigenvalues___module_a6201e534e901b5f4e66f72c176b534a3}{Index} i=0; i<dim-1; ++i)
00626         \{
00627           \textcolor{keywordflow}{if}(m\_S.coeff(i+1, i) != Scalar(0))
00628           \{
00629             \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<Scalar>} j\_left, j\_right;
00630             internal::real\_2x2\_jacobi\_svd(m\_T, i, i+1, &j\_left, &j\_right);
00631 
00632             \textcolor{comment}{// Apply resulting Jacobi rotations}
00633             m\_S.applyOnTheLeft(i,i+1,j\_left);
00634             m\_S.applyOnTheRight(i,i+1,j\_right);
00635             m\_T.applyOnTheLeft(i,i+1,j\_left);
00636             m\_T.applyOnTheRight(i,i+1,j\_right);
00637             m\_T(i+1,i) = m\_T(i,i+1) = Scalar(0);
00638 
00639             \textcolor{keywordflow}{if}(m\_computeQZ) \{
00640               m\_Q.applyOnTheRight(i,i+1,j\_left.\hyperlink{group___jacobi___module_ab40e9cdc4582593511e57ee896e055a2}{transpose}());
00641               m\_Z.applyOnTheLeft(i,i+1,j\_right.\hyperlink{group___jacobi___module_ab40e9cdc4582593511e57ee896e055a2}{transpose}());
00642             \}
00643 
00644             i++;
00645           \}
00646         \}
00647       \}
00648 
00649       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00650     \} \textcolor{comment}{// end compute}
00651 
00652 \} \textcolor{comment}{// end namespace Eigen}
00653 
00654 \textcolor{preprocessor}{#endif //EIGEN\_REAL\_QZ}
\end{DoxyCode}
