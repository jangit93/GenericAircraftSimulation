\hypertarget{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source}{}\section{eigen/\+Eigen/src/\+Umf\+Pack\+Support/\+Umf\+Pack\+Support.h}
\label{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source}\index{Umf\+Pack\+Support.\+h@{Umf\+Pack\+Support.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2011 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_UMFPACKSUPPORT\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_UMFPACKSUPPORT\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{comment}{/* TODO extract L, extract U, compute det, etc... */}
00016 
00017 \textcolor{comment}{// generic double/complex<double> wrapper functions:}
00018 
00019 
00020 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} umfpack\_defaults(\textcolor{keywordtype}{double} control[UMFPACK\_CONTROL], \textcolor{keywordtype}{double})
00021 \{ umfpack\_di\_defaults(control); \}
00022 
00023 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} umfpack\_defaults(\textcolor{keywordtype}{double} control[UMFPACK\_CONTROL], std::complex<double>)
00024 \{ umfpack\_zi\_defaults(control); \}
00025 
00026 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} umfpack\_report\_info(\textcolor{keywordtype}{double} control[UMFPACK\_CONTROL], \textcolor{keywordtype}{double} info[UMFPACK\_INFO], \textcolor{keywordtype}{double})
00027 \{ umfpack\_di\_report\_info(control, info);\}
00028 
00029 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} umfpack\_report\_info(\textcolor{keywordtype}{double} control[UMFPACK\_CONTROL], \textcolor{keywordtype}{double} info[UMFPACK\_INFO], 
      std::complex<double>)
00030 \{ umfpack\_zi\_report\_info(control, info);\}
00031 
00032 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} umfpack\_report\_status(\textcolor{keywordtype}{double} control[UMFPACK\_CONTROL], \textcolor{keywordtype}{int} status, \textcolor{keywordtype}{double})
00033 \{ umfpack\_di\_report\_status(control, status);\}
00034 
00035 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} umfpack\_report\_status(\textcolor{keywordtype}{double} control[UMFPACK\_CONTROL], \textcolor{keywordtype}{int} status, std::complex<double>)
00036 \{ umfpack\_zi\_report\_status(control, status);\}
00037 
00038 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} umfpack\_report\_control(\textcolor{keywordtype}{double} control[UMFPACK\_CONTROL], \textcolor{keywordtype}{double})
00039 \{ umfpack\_di\_report\_control(control);\}
00040 
00041 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} umfpack\_report\_control(\textcolor{keywordtype}{double} control[UMFPACK\_CONTROL], std::complex<double>)
00042 \{ umfpack\_zi\_report\_control(control);\}
00043 
00044 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} umfpack\_free\_numeric(\textcolor{keywordtype}{void} **Numeric, \textcolor{keywordtype}{double})
00045 \{ umfpack\_di\_free\_numeric(Numeric); *Numeric = 0; \}
00046 
00047 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} umfpack\_free\_numeric(\textcolor{keywordtype}{void} **Numeric, std::complex<double>)
00048 \{ umfpack\_zi\_free\_numeric(Numeric); *Numeric = 0; \}
00049 
00050 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} umfpack\_free\_symbolic(\textcolor{keywordtype}{void} **Symbolic, \textcolor{keywordtype}{double})
00051 \{ umfpack\_di\_free\_symbolic(Symbolic); *Symbolic = 0; \}
00052 
00053 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} umfpack\_free\_symbolic(\textcolor{keywordtype}{void} **Symbolic, std::complex<double>)
00054 \{ umfpack\_zi\_free\_symbolic(Symbolic); *Symbolic = 0; \}
00055 
00056 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} umfpack\_symbolic(\textcolor{keywordtype}{int} n\_row,\textcolor{keywordtype}{int} n\_col,
00057                             \textcolor{keyword}{const} \textcolor{keywordtype}{int} Ap[], \textcolor{keyword}{const} \textcolor{keywordtype}{int} Ai[], \textcolor{keyword}{const} \textcolor{keywordtype}{double} Ax[], \textcolor{keywordtype}{void} **Symbolic,
00058                             \textcolor{keyword}{const} \textcolor{keywordtype}{double} Control [UMFPACK\_CONTROL], \textcolor{keywordtype}{double} Info [UMFPACK\_INFO])
00059 \{
00060   \textcolor{keywordflow}{return} umfpack\_di\_symbolic(n\_row,n\_col,Ap,Ai,Ax,Symbolic,Control,Info);
00061 \}
00062 
00063 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} umfpack\_symbolic(\textcolor{keywordtype}{int} n\_row,\textcolor{keywordtype}{int} n\_col,
00064                             \textcolor{keyword}{const} \textcolor{keywordtype}{int} Ap[], \textcolor{keyword}{const} \textcolor{keywordtype}{int} Ai[], \textcolor{keyword}{const} std::complex<double> Ax[], \textcolor{keywordtype}{void} **
      Symbolic,
00065                             \textcolor{keyword}{const} \textcolor{keywordtype}{double} Control [UMFPACK\_CONTROL], \textcolor{keywordtype}{double} Info [UMFPACK\_INFO])
00066 \{
00067   \textcolor{keywordflow}{return} umfpack\_zi\_symbolic(n\_row,n\_col,Ap,Ai,&numext::real\_ref(Ax[0]),0,Symbolic,Control,Info);
00068 \}
00069 
00070 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} umfpack\_numeric( \textcolor{keyword}{const} \textcolor{keywordtype}{int} Ap[], \textcolor{keyword}{const} \textcolor{keywordtype}{int} Ai[], \textcolor{keyword}{const} \textcolor{keywordtype}{double} Ax[],
00071                             \textcolor{keywordtype}{void} *Symbolic, \textcolor{keywordtype}{void} **Numeric,
00072                             \textcolor{keyword}{const} \textcolor{keywordtype}{double} Control[UMFPACK\_CONTROL],\textcolor{keywordtype}{double} Info [UMFPACK\_INFO])
00073 \{
00074   \textcolor{keywordflow}{return} umfpack\_di\_numeric(Ap,Ai,Ax,Symbolic,Numeric,Control,Info);
00075 \}
00076 
00077 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} umfpack\_numeric( \textcolor{keyword}{const} \textcolor{keywordtype}{int} Ap[], \textcolor{keyword}{const} \textcolor{keywordtype}{int} Ai[], \textcolor{keyword}{const} std::complex<double> Ax[],
00078                             \textcolor{keywordtype}{void} *Symbolic, \textcolor{keywordtype}{void} **Numeric,
00079                             \textcolor{keyword}{const} \textcolor{keywordtype}{double} Control[UMFPACK\_CONTROL],\textcolor{keywordtype}{double} Info [UMFPACK\_INFO])
00080 \{
00081   \textcolor{keywordflow}{return} umfpack\_zi\_numeric(Ap,Ai,&numext::real\_ref(Ax[0]),0,Symbolic,Numeric,Control,Info);
00082 \}
00083 
00084 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} umfpack\_solve( \textcolor{keywordtype}{int} sys, \textcolor{keyword}{const} \textcolor{keywordtype}{int} Ap[], \textcolor{keyword}{const} \textcolor{keywordtype}{int} Ai[], \textcolor{keyword}{const} \textcolor{keywordtype}{double} Ax[],
00085                           \textcolor{keywordtype}{double} X[], \textcolor{keyword}{const} \textcolor{keywordtype}{double} B[], \textcolor{keywordtype}{void} *Numeric,
00086                           \textcolor{keyword}{const} \textcolor{keywordtype}{double} Control[UMFPACK\_CONTROL], \textcolor{keywordtype}{double} Info[UMFPACK\_INFO])
00087 \{
00088   \textcolor{keywordflow}{return} umfpack\_di\_solve(sys,Ap,Ai,Ax,X,B,Numeric,Control,Info);
00089 \}
00090 
00091 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} umfpack\_solve( \textcolor{keywordtype}{int} sys, \textcolor{keyword}{const} \textcolor{keywordtype}{int} Ap[], \textcolor{keyword}{const} \textcolor{keywordtype}{int} Ai[], \textcolor{keyword}{const} std::complex<double> Ax[],
00092                           std::complex<double> X[], \textcolor{keyword}{const} std::complex<double> B[], \textcolor{keywordtype}{void} *Numeric,
00093                           \textcolor{keyword}{const} \textcolor{keywordtype}{double} Control[UMFPACK\_CONTROL], \textcolor{keywordtype}{double} Info[UMFPACK\_INFO])
00094 \{
00095   \textcolor{keywordflow}{return} umfpack\_zi\_solve(sys,Ap,Ai,&numext::real\_ref(Ax[0]),0,&numext::real\_ref(X[0]),0,&numext::real\_ref(
      B[0]),0,Numeric,Control,Info);
00096 \}
00097 
00098 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} umfpack\_get\_lunz(\textcolor{keywordtype}{int} *lnz, \textcolor{keywordtype}{int} *unz, \textcolor{keywordtype}{int} *n\_row, \textcolor{keywordtype}{int} *n\_col, \textcolor{keywordtype}{int} *nz\_udiag, \textcolor{keywordtype}{void} *Numeric, \textcolor{keywordtype}{
      double})
00099 \{
00100   \textcolor{keywordflow}{return} umfpack\_di\_get\_lunz(lnz,unz,n\_row,n\_col,nz\_udiag,Numeric);
00101 \}
00102 
00103 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} umfpack\_get\_lunz(\textcolor{keywordtype}{int} *lnz, \textcolor{keywordtype}{int} *unz, \textcolor{keywordtype}{int} *n\_row, \textcolor{keywordtype}{int} *n\_col, \textcolor{keywordtype}{int} *nz\_udiag, \textcolor{keywordtype}{void} *Numeric, 
      std::complex<double>)
00104 \{
00105   \textcolor{keywordflow}{return} umfpack\_zi\_get\_lunz(lnz,unz,n\_row,n\_col,nz\_udiag,Numeric);
00106 \}
00107 
00108 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} umfpack\_get\_numeric(\textcolor{keywordtype}{int} Lp[], \textcolor{keywordtype}{int} Lj[], \textcolor{keywordtype}{double} Lx[], \textcolor{keywordtype}{int} Up[], \textcolor{keywordtype}{int} Ui[], \textcolor{keywordtype}{double} Ux[],
00109                                \textcolor{keywordtype}{int} P[], \textcolor{keywordtype}{int} Q[], \textcolor{keywordtype}{double} Dx[], \textcolor{keywordtype}{int} *do\_recip, \textcolor{keywordtype}{double} Rs[], \textcolor{keywordtype}{void} *Numeric)
00110 \{
00111   \textcolor{keywordflow}{return} umfpack\_di\_get\_numeric(Lp,Lj,Lx,Up,Ui,Ux,P,Q,Dx,do\_recip,Rs,Numeric);
00112 \}
00113 
00114 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} umfpack\_get\_numeric(\textcolor{keywordtype}{int} Lp[], \textcolor{keywordtype}{int} Lj[], std::complex<double> Lx[], \textcolor{keywordtype}{int} Up[], \textcolor{keywordtype}{int} Ui[], 
      std::complex<double> Ux[],
00115                                \textcolor{keywordtype}{int} P[], \textcolor{keywordtype}{int} Q[], std::complex<double> Dx[], \textcolor{keywordtype}{int} *do\_recip, \textcolor{keywordtype}{double} Rs[], \textcolor{keywordtype}{
      void} *Numeric)
00116 \{
00117   \textcolor{keywordtype}{double}& lx0\_real = numext::real\_ref(Lx[0]);
00118   \textcolor{keywordtype}{double}& ux0\_real = numext::real\_ref(Ux[0]);
00119   \textcolor{keywordtype}{double}& dx0\_real = numext::real\_ref(Dx[0]);
00120   \textcolor{keywordflow}{return} umfpack\_zi\_get\_numeric(Lp,Lj,Lx?&lx0\_real:0,0,Up,Ui,Ux?&ux0\_real:0,0,P,Q,
00121                                 Dx?&dx0\_real:0,0,do\_recip,Rs,Numeric);
00122 \}
00123 
00124 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} umfpack\_get\_determinant(\textcolor{keywordtype}{double} *Mx, \textcolor{keywordtype}{double} *Ex, \textcolor{keywordtype}{void} *NumericHandle, \textcolor{keywordtype}{double} User\_Info [
      UMFPACK\_INFO])
00125 \{
00126   \textcolor{keywordflow}{return} umfpack\_di\_get\_determinant(Mx,Ex,NumericHandle,User\_Info);
00127 \}
00128 
00129 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} umfpack\_get\_determinant(std::complex<double> *Mx, \textcolor{keywordtype}{double} *Ex, \textcolor{keywordtype}{void} *NumericHandle, \textcolor{keywordtype}{double} 
      User\_Info [UMFPACK\_INFO])
00130 \{
00131   \textcolor{keywordtype}{double}& mx\_real = numext::real\_ref(*Mx);
00132   \textcolor{keywordflow}{return} umfpack\_zi\_get\_determinant(&mx\_real,0,Ex,NumericHandle,User\_Info);
00133 \}
00134 
00135 
00151 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
\Hypertarget{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source_l00152}\hyperlink{class_eigen_1_1_umf_pack_l_u}{00152} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_umf_pack_l_u}{UmfPackLU} : \textcolor{keyword}{public} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase}<UmfPackLU<\_MatrixType> >
00153 \{
00154   \textcolor{keyword}{protected}:
00155     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase<UmfPackLU<\_MatrixType>} > 
      \hyperlink{group___sparse_core___module}{Base};
00156     \textcolor{keyword}{using} Base::m\_isInitialized;
00157   \textcolor{keyword}{public}:
00158     \textcolor{keyword}{using} Base::\_solve\_impl;
00159     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00160     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00161     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00162     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00163     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} \hyperlink{group___core___module}{Vector};
00164     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<int, 1, MatrixType::ColsAtCompileTime>} 
      \hyperlink{group___core___module}{IntRowVectorType};
00165     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<int, MatrixType::RowsAtCompileTime, 1>} 
      \hyperlink{group___core___module}{IntColVectorType};
00166     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar>} \hyperlink{group___sparse_core___module}{LUMatrixType};
00167     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar,ColMajor,int>} 
      \hyperlink{group___sparse_core___module}{UmfpackMatrixType};
00168     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Ref<const UmfpackMatrixType, StandardCompressedFormat>}
       \hyperlink{group___core___module}{UmfpackMatrixRef};
00169     \textcolor{keyword}{enum} \{
00170       ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00171       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
00172     \};
00173 
00174   \textcolor{keyword}{public}:
00175 
00176     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Array<double, UMFPACK\_CONTROL, 1>} 
      \hyperlink{group___core___module}{UmfpackControl};
00177     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Array<double, UMFPACK\_INFO, 1>} 
      \hyperlink{group___core___module}{UmfpackInfo};
00178 
00179     \hyperlink{class_eigen_1_1_umf_pack_l_u}{UmfPackLU}()
00180       : m\_dummy(0,0), mp\_matrix(m\_dummy)
00181     \{
00182       \hyperlink{structinit}{init}();
00183     \}
00184 
00185     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputMatrixType>
00186     \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1_umf_pack_l_u}{UmfPackLU}(\textcolor{keyword}{const} InputMatrixType& matrix)
00187       : mp\_matrix(matrix)
00188     \{
00189       \hyperlink{structinit}{init}();
00190       \hyperlink{class_eigen_1_1_umf_pack_l_u_a05fb2b5717ebd67e46b83439721ceee7}{compute}(matrix);
00191     \}
00192 
00193     ~\hyperlink{class_eigen_1_1_umf_pack_l_u}{UmfPackLU}()
00194     \{
00195       \textcolor{keywordflow}{if}(m\_symbolic) umfpack\_free\_symbolic(&m\_symbolic,Scalar());
00196       \textcolor{keywordflow}{if}(m\_numeric)  umfpack\_free\_numeric(&m\_numeric,Scalar());
00197     \}
00198 
00199     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} mp\_matrix.rows(); \}
00200     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} mp\_matrix.cols(); \}
00201 
\Hypertarget{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source_l00207}\hyperlink{class_eigen_1_1_umf_pack_l_u_a68738a0d99c67316877706f98b033402}{00207}     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} \hyperlink{class_eigen_1_1_umf_pack_l_u_a68738a0d99c67316877706f98b033402}{info}()\textcolor{keyword}{ const}
00208 \textcolor{keyword}{    }\{
00209       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"Decomposition is not initialized."});
00210       \textcolor{keywordflow}{return} m\_info;
00211     \}
00212 
00213     \textcolor{keyword}{inline} \textcolor{keyword}{const} LUMatrixType& matrixL()\textcolor{keyword}{ const}
00214 \textcolor{keyword}{    }\{
00215       \textcolor{keywordflow}{if} (m\_extractedDataAreDirty) extractData();
00216       \textcolor{keywordflow}{return} m\_l;
00217     \}
00218 
00219     \textcolor{keyword}{inline} \textcolor{keyword}{const} LUMatrixType& matrixU()\textcolor{keyword}{ const}
00220 \textcolor{keyword}{    }\{
00221       \textcolor{keywordflow}{if} (m\_extractedDataAreDirty) extractData();
00222       \textcolor{keywordflow}{return} m\_u;
00223     \}
00224 
00225     \textcolor{keyword}{inline} \textcolor{keyword}{const} IntColVectorType& permutationP()\textcolor{keyword}{ const}
00226 \textcolor{keyword}{    }\{
00227       \textcolor{keywordflow}{if} (m\_extractedDataAreDirty) extractData();
00228       \textcolor{keywordflow}{return} m\_p;
00229     \}
00230 
00231     \textcolor{keyword}{inline} \textcolor{keyword}{const} IntRowVectorType& permutationQ()\textcolor{keyword}{ const}
00232 \textcolor{keyword}{    }\{
00233       \textcolor{keywordflow}{if} (m\_extractedDataAreDirty) extractData();
00234       \textcolor{keywordflow}{return} m\_q;
00235     \}
00236 
00241     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputMatrixType>
\Hypertarget{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source_l00242}\hyperlink{class_eigen_1_1_umf_pack_l_u_a05fb2b5717ebd67e46b83439721ceee7}{00242}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_umf_pack_l_u_a05fb2b5717ebd67e46b83439721ceee7}{compute}(\textcolor{keyword}{const} InputMatrixType& matrix)
00243     \{
00244       \textcolor{keywordflow}{if}(m\_symbolic) umfpack\_free\_symbolic(&m\_symbolic,Scalar());
00245       \textcolor{keywordflow}{if}(m\_numeric)  umfpack\_free\_numeric(&m\_numeric,Scalar());
00246       grab(matrix.derived());
00247       analyzePattern\_impl();
00248       factorize\_impl();
00249     \}
00250 
00257     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputMatrixType>
\Hypertarget{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source_l00258}\hyperlink{class_eigen_1_1_umf_pack_l_u_ac7ea28b2017d6b26b7b08497f294e5e6}{00258}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_umf_pack_l_u_ac7ea28b2017d6b26b7b08497f294e5e6}{analyzePattern}(\textcolor{keyword}{const} InputMatrixType& matrix)
00259     \{
00260       \textcolor{keywordflow}{if}(m\_symbolic) umfpack\_free\_symbolic(&m\_symbolic,Scalar());
00261       \textcolor{keywordflow}{if}(m\_numeric)  umfpack\_free\_numeric(&m\_numeric,Scalar());
00262 
00263       grab(matrix.derived());
00264 
00265       analyzePattern\_impl();
00266     \}
00267 
\Hypertarget{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source_l00273}\hyperlink{class_eigen_1_1_umf_pack_l_u_a822fa9d82754269c379dc4ce17920b0a}{00273}     \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \hyperlink{class_eigen_1_1_umf_pack_l_u_a822fa9d82754269c379dc4ce17920b0a}{umfpackFactorizeReturncode}()\textcolor{keyword}{ const}
00274 \textcolor{keyword}{    }\{
00275       eigen\_assert(m\_numeric && \textcolor{stringliteral}{"UmfPackLU: you must first call factorize()"});
00276       \textcolor{keywordflow}{return} m\_fact\_errorCode;
00277     \}
00278 
\Hypertarget{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source_l00285}\hyperlink{class_eigen_1_1_umf_pack_l_u_ae83d178202f3d44c1789c1c93842bf2e}{00285}     \textcolor{keyword}{inline} \textcolor{keyword}{const} UmfpackControl& \hyperlink{class_eigen_1_1_umf_pack_l_u_ae83d178202f3d44c1789c1c93842bf2e}{umfpackControl}()\textcolor{keyword}{ const}
00286 \textcolor{keyword}{    }\{
00287       \textcolor{keywordflow}{return} m\_control;
00288     \}
00289 
\Hypertarget{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source_l00296}\hyperlink{class_eigen_1_1_umf_pack_l_u_a679bd267a0407d4ca985d97f0b864101}{00296}     \textcolor{keyword}{inline} UmfpackControl& \hyperlink{class_eigen_1_1_umf_pack_l_u_a679bd267a0407d4ca985d97f0b864101}{umfpackControl}()
00297     \{
00298       \textcolor{keywordflow}{return} m\_control;
00299     \}
00300 
00307     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputMatrixType>
\Hypertarget{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source_l00308}\hyperlink{class_eigen_1_1_umf_pack_l_u_a1471bf890503e743c45d75cc02a5345d}{00308}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_umf_pack_l_u_a1471bf890503e743c45d75cc02a5345d}{factorize}(\textcolor{keyword}{const} InputMatrixType& matrix)
00309     \{
00310       eigen\_assert(m\_analysisIsOk && \textcolor{stringliteral}{"UmfPackLU: you must first call analyzePattern()"});
00311       \textcolor{keywordflow}{if}(m\_numeric)
00312         umfpack\_free\_numeric(&m\_numeric,Scalar());
00313 
00314       grab(matrix.derived());
00315 
00316       factorize\_impl();
00317     \}
00318 
\Hypertarget{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source_l00323}\hyperlink{class_eigen_1_1_umf_pack_l_u_ac6ff58ef8eb8221e6af87de750d6619b}{00323}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_umf_pack_l_u_ac6ff58ef8eb8221e6af87de750d6619b}{umfpackReportControl}()
00324     \{
00325       umfpack\_report\_control(m\_control.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(), Scalar());
00326     \}
00327 
\Hypertarget{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source_l00332}\hyperlink{class_eigen_1_1_umf_pack_l_u_afad062dfc49ca6d2d19d534b3f8f8d28}{00332}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_umf_pack_l_u_afad062dfc49ca6d2d19d534b3f8f8d28}{umfpackReportInfo}()
00333     \{
00334       eigen\_assert(m\_analysisIsOk && \textcolor{stringliteral}{"UmfPackLU: you must first call analyzePattern()"});
00335       umfpack\_report\_info(m\_control.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(), m\_umfpackInfo.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(), Scalar());
00336     \}
00337 
\Hypertarget{eigen_2_eigen_2src_2_umf_pack_support_2_umf_pack_support_8h_source_l00342}\hyperlink{class_eigen_1_1_umf_pack_l_u_a82497bbf75d995a6d4ae7e9191f79525}{00342}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_umf_pack_l_u_a82497bbf75d995a6d4ae7e9191f79525}{umfpackReportStatus}() \{
00343       eigen\_assert(m\_analysisIsOk && \textcolor{stringliteral}{"UmfPackLU: you must first call analyzePattern()"});
00344       umfpack\_report\_status(m\_control.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(), m\_fact\_errorCode, Scalar());
00345     \}
00346 
00348     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BDerived,\textcolor{keyword}{typename} XDerived>
00349     \textcolor{keywordtype}{bool} \_solve\_impl(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<BDerived>} &b, 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<XDerived>} &x) \textcolor{keyword}{const};
00350 
00351     Scalar determinant() \textcolor{keyword}{const};
00352 
00353     \textcolor{keywordtype}{void} extractData() \textcolor{keyword}{const};
00354 
00355   \textcolor{keyword}{protected}:
00356 
00357     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}()
00358     \{
00359       m\_info                  = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434}{InvalidInput};
00360       m\_isInitialized         = \textcolor{keyword}{false};
00361       m\_numeric               = 0;
00362       m\_symbolic              = 0;
00363       m\_extractedDataAreDirty = \textcolor{keyword}{true};
00364 
00365       umfpack\_defaults(m\_control.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(), Scalar());
00366     \}
00367 
00368     \textcolor{keywordtype}{void} analyzePattern\_impl()
00369     \{
00370       m\_fact\_errorCode = umfpack\_symbolic(internal::convert\_index<int>(mp\_matrix.rows()),
00371                                           internal::convert\_index<int>(mp\_matrix.cols()),
00372                                           mp\_matrix.outerIndexPtr(), mp\_matrix.innerIndexPtr(), mp\_matrix.
      valuePtr(),
00373                                           &m\_symbolic, m\_control.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(), m\_umfpackInfo.
      \hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}());
00374 
00375       m\_isInitialized = \textcolor{keyword}{true};
00376       m\_info = m\_fact\_errorCode ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434}{InvalidInput} : \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00377       m\_analysisIsOk = \textcolor{keyword}{true};
00378       m\_factorizationIsOk = \textcolor{keyword}{false};
00379       m\_extractedDataAreDirty = \textcolor{keyword}{true};
00380     \}
00381 
00382     \textcolor{keywordtype}{void} factorize\_impl()
00383     \{
00384 
00385       m\_fact\_errorCode = umfpack\_numeric(mp\_matrix.outerIndexPtr(), mp\_matrix.innerIndexPtr(), mp\_matrix.
      valuePtr(),
00386                                          m\_symbolic, &m\_numeric, m\_control.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(), m\_umfpackInfo.
      \hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}());
00387 
00388       m\_info = m\_fact\_errorCode == UMFPACK\_OK ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} : \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00389       m\_factorizationIsOk = \textcolor{keyword}{true};
00390       m\_extractedDataAreDirty = \textcolor{keyword}{true};
00391     \}
00392 
00393     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixDerived>
00394     \textcolor{keywordtype}{void} grab(\textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<MatrixDerived>} &\hyperlink{group___core___module_class_eigen_1_1_matrix}{A})
00395     \{
00396       mp\_matrix.~UmfpackMatrixRef();
00397       ::new (&mp\_matrix) UmfpackMatrixRef(A.\hyperlink{group___core___module_a324b16961a11d2ecfd2d1b7dd7946545}{derived}());
00398     \}
00399 
00400     \textcolor{keywordtype}{void} grab(\textcolor{keyword}{const} UmfpackMatrixRef &A)
00401     \{
00402       \textcolor{keywordflow}{if}(&(A.derived()) != &mp\_matrix)
00403       \{
00404         mp\_matrix.~UmfpackMatrixRef();
00405         ::new (&mp\_matrix) UmfpackMatrixRef(A);
00406       \}
00407     \}
00408 
00409     \textcolor{comment}{// cached data to reduce reallocation, etc.}
00410     \textcolor{keyword}{mutable} LUMatrixType m\_l;
00411     \textcolor{keywordtype}{int} m\_fact\_errorCode;
00412     UmfpackControl m\_control;
00413     \textcolor{keyword}{mutable} UmfpackInfo m\_umfpackInfo;
00414 
00415     \textcolor{keyword}{mutable} LUMatrixType m\_u;
00416     \textcolor{keyword}{mutable} IntColVectorType m\_p;
00417     \textcolor{keyword}{mutable} IntRowVectorType m\_q;
00418 
00419     UmfpackMatrixType m\_dummy;
00420     UmfpackMatrixRef mp\_matrix;
00421 
00422     \textcolor{keywordtype}{void}* m\_numeric;
00423     \textcolor{keywordtype}{void}* m\_symbolic;
00424 
00425     \textcolor{keyword}{mutable} \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} m\_info;
00426     \textcolor{keywordtype}{int} m\_factorizationIsOk;
00427     \textcolor{keywordtype}{int} m\_analysisIsOk;
00428     \textcolor{keyword}{mutable} \textcolor{keywordtype}{bool} m\_extractedDataAreDirty;
00429 
00430   \textcolor{keyword}{private}:
00431     \hyperlink{class_eigen_1_1_umf_pack_l_u}{UmfPackLU}(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1_umf_pack_l_u}{UmfPackLU}& ) \{ \}
00432 \};
00433 
00434 
00435 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00436 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_umf_pack_l_u}{UmfPackLU<MatrixType>::extractData}()\textcolor{keyword}{ const}
00437 \textcolor{keyword}{}\{
00438   \textcolor{keywordflow}{if} (m\_extractedDataAreDirty)
00439   \{
00440     \textcolor{comment}{// get size of the data}
00441     \textcolor{keywordtype}{int} lnz, unz, rows, cols, nz\_udiag;
00442     umfpack\_get\_lunz(&lnz, &unz, &rows, &cols, &nz\_udiag, m\_numeric, Scalar());
00443 
00444     \textcolor{comment}{// allocate data}
00445     m\_l.\hyperlink{group___sparse_core___module_af88551f30202341b7cc24cfadabdec5c}{resize}(rows,(std::min)(rows,cols));
00446     m\_l.resizeNonZeros(lnz);
00447 
00448     m\_u.\hyperlink{group___sparse_core___module_af88551f30202341b7cc24cfadabdec5c}{resize}((std::min)(rows,cols),cols);
00449     m\_u.resizeNonZeros(unz);
00450 
00451     m\_p.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(rows);
00452     m\_q.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(cols);
00453 
00454     \textcolor{comment}{// extract}
00455     umfpack\_get\_numeric(m\_l.\hyperlink{group___sparse_core___module_a75506964d86d6badb32d0b4917acf2e2}{outerIndexPtr}(), m\_l.\hyperlink{group___sparse_core___module_ae7b804bd39745156d20ca1611a296b67}{innerIndexPtr}(), m\_l.
      \hyperlink{group___sparse_core___module_a9d4354d3f4d121d764bbed33cac05329}{valuePtr}(),
00456                         m\_u.\hyperlink{group___sparse_core___module_a75506964d86d6badb32d0b4917acf2e2}{outerIndexPtr}(), m\_u.\hyperlink{group___sparse_core___module_ae7b804bd39745156d20ca1611a296b67}{innerIndexPtr}(), m\_u.
      \hyperlink{group___sparse_core___module_a9d4354d3f4d121d764bbed33cac05329}{valuePtr}(),
00457                         m\_p.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(), m\_q.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(), 0, 0, 0, m\_numeric);
00458 
00459     m\_extractedDataAreDirty = \textcolor{keyword}{false};
00460   \}
00461 \}
00462 
00463 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00464 \textcolor{keyword}{typename} UmfPackLU<MatrixType>::Scalar \hyperlink{class_eigen_1_1_umf_pack_l_u}{UmfPackLU<MatrixType>::determinant}
      ()\textcolor{keyword}{ const}
00465 \textcolor{keyword}{}\{
00466   Scalar det;
00467   umfpack\_get\_determinant(&det, 0, m\_numeric, 0);
00468   \textcolor{keywordflow}{return} det;
00469 \}
00470 
00471 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00472 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BDerived,\textcolor{keyword}{typename} XDerived>
00473 \textcolor{keywordtype}{bool} \hyperlink{class_eigen_1_1_umf_pack_l_u}{UmfPackLU<MatrixType>::\_solve\_impl}(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<BDerived>} &b, \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<XDerived>} &x)\textcolor{keyword}{ const}
00474 \textcolor{keyword}{}\{
00475   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rhsCols = b.cols();
00476   eigen\_assert((BDerived::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==0 && \textcolor{stringliteral}{"UmfPackLU backend does not support non
       col-major rhs yet"});
00477   eigen\_assert((XDerived::Flags&RowMajorBit)==0 && \textcolor{stringliteral}{"UmfPackLU backend does not support non col-major result
       yet"});
00478   eigen\_assert(b.derived().data() != x.derived().data() && \textcolor{stringliteral}{" Umfpack does not support inplace solve"});
00479 
00480   \textcolor{keywordtype}{int} errorCode;
00481   Scalar* x\_ptr = 0;
00482   \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} x\_tmp;
00483   \textcolor{keywordflow}{if}(x.innerStride()!=1)
00484   \{
00485     x\_tmp.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(x.rows());
00486     x\_ptr = x\_tmp.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}();
00487   \}
00488   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<rhsCols; ++j)
00489   \{
00490     \textcolor{keywordflow}{if}(x.innerStride()==1)
00491       x\_ptr = &x.\hyperlink{group___core___module_a469583ed90462820888344e63ebe1a80}{col}(j).coeffRef(0);
00492     errorCode = umfpack\_solve(UMFPACK\_A,
00493         mp\_matrix.outerIndexPtr(), mp\_matrix.innerIndexPtr(), mp\_matrix.valuePtr(),
00494         x\_ptr, &b.const\_cast\_derived().\hyperlink{group___core___module_a469583ed90462820888344e63ebe1a80}{col}(j).coeffRef(0), m\_numeric, m\_control.
      \hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(), m\_umfpackInfo.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}());
00495     \textcolor{keywordflow}{if}(x.innerStride()!=1)
00496       x.\hyperlink{group___core___module_a469583ed90462820888344e63ebe1a80}{col}(j) = x\_tmp;
00497     \textcolor{keywordflow}{if} (errorCode!=0)
00498       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00499   \}
00500 
00501   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00502 \}
00503 
00504 \} \textcolor{comment}{// end namespace Eigen}
00505 
00506 \textcolor{preprocessor}{#endif // EIGEN\_UMFPACKSUPPORT\_H}
\end{DoxyCode}
