\hypertarget{eigen_2_eigen_2src_2_eigenvalues_2_real_schur_8h_source}{}\section{eigen/\+Eigen/src/\+Eigenvalues/\+Real\+Schur.h}
\label{eigen_2_eigen_2src_2_eigenvalues_2_real_schur_8h_source}\index{Real\+Schur.\+h@{Real\+Schur.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2010,2012 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_REAL\_SCHUR\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_REAL\_SCHUR\_H}
00013 
00014 \textcolor{preprocessor}{#include "./HessenbergDecomposition.h"}
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00017 
\Hypertarget{eigen_2_eigen_2src_2_eigenvalues_2_real_schur_8h_source_l00054}\hyperlink{group___eigenvalues___module}{00054} \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType> \textcolor{keyword}{class }\hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur}
00055 \{
00056   \textcolor{keyword}{public}:
00057     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00058     \textcolor{keyword}{enum} \{
00059       RowsAtCompileTime = MatrixType::RowsAtCompileTime,
00060       ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00061       Options = MatrixType::Options,
00062       MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
00063       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
00064     \};
00065     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00066     \textcolor{keyword}{typedef} std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;
\Hypertarget{eigen_2_eigen_2src_2_eigenvalues_2_real_schur_8h_source_l00067}\hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{00067}     \textcolor{keyword}{typedef} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Eigen::Index} \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index}; 
00068 
00069     \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module}{Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1>}
       \hyperlink{group___core___module}{EigenvalueType};
00070     \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module}{Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1>}
       \hyperlink{group___core___module}{ColumnVectorType};
00071 
\Hypertarget{eigen_2_eigen_2src_2_eigenvalues_2_real_schur_8h_source_l00083}\hyperlink{group___eigenvalues___module_a826c83e2f1d4c8332606a14ea121ff5f}{00083}     \textcolor{keyword}{explicit} \hyperlink{group___eigenvalues___module_a826c83e2f1d4c8332606a14ea121ff5f}{RealSchur}(Index size = RowsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} ? 1 : RowsAtCompileTime)
00084             : m\_matT(size, size),
00085               m\_matU(size, size),
00086               m\_workspaceVector(size),
00087               m\_hess(size),
00088               m\_isInitialized(false),
00089               m\_matUisUptodate(false),
00090               m\_maxIters(-1)
00091     \{ \}
00092 
00103     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>
\Hypertarget{eigen_2_eigen_2src_2_eigenvalues_2_real_schur_8h_source_l00104}\hyperlink{group___eigenvalues___module_afef4d3dc5a493aca2760c20b34337016}{00104}     \textcolor{keyword}{explicit} \hyperlink{group___eigenvalues___module_afef4d3dc5a493aca2760c20b34337016}{RealSchur}(\textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<InputType>}& matrix, \textcolor{keywordtype}{bool} computeU = \textcolor{keyword}{
      true})
00105             : m\_matT(matrix.rows(),matrix.cols()),
00106               m\_matU(matrix.rows(),matrix.cols()),
00107               m\_workspaceVector(matrix.rows()),
00108               m\_hess(matrix.rows()),
00109               m\_isInitialized(false),
00110               m\_matUisUptodate(false),
00111               m\_maxIters(-1)
00112     \{
00113       \hyperlink{group___eigenvalues___module_a60caf9ffad11d728ea458c4dd36d0a98}{compute}(matrix.\hyperlink{group___core___module_a324b16961a11d2ecfd2d1b7dd7946545}{derived}(), computeU);
00114     \}
00115 
\Hypertarget{eigen_2_eigen_2src_2_eigenvalues_2_real_schur_8h_source_l00127}\hyperlink{group___eigenvalues___module_a85622ccbecff99c8933d21f0a22b22bb}{00127}     \textcolor{keyword}{const} MatrixType& \hyperlink{group___eigenvalues___module_a85622ccbecff99c8933d21f0a22b22bb}{matrixU}()\textcolor{keyword}{ const}
00128 \textcolor{keyword}{    }\{
00129       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"RealSchur is not initialized."});
00130       eigen\_assert(m\_matUisUptodate && \textcolor{stringliteral}{"The matrix U has not been computed during the RealSchur
       decomposition."});
00131       \textcolor{keywordflow}{return} m\_matU;
00132     \}
00133 
\Hypertarget{eigen_2_eigen_2src_2_eigenvalues_2_real_schur_8h_source_l00144}\hyperlink{group___eigenvalues___module_abb78996b43b8642a5f507415730445cb}{00144}     \textcolor{keyword}{const} MatrixType& \hyperlink{group___eigenvalues___module_abb78996b43b8642a5f507415730445cb}{matrixT}()\textcolor{keyword}{ const}
00145 \textcolor{keyword}{    }\{
00146       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"RealSchur is not initialized."});
00147       \textcolor{keywordflow}{return} m\_matT;
00148     \}
00149   
00169     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>
00170     \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur}& \hyperlink{group___eigenvalues___module_a60caf9ffad11d728ea458c4dd36d0a98}{compute}(\textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<InputType>}& matrix, \textcolor{keywordtype}{bool} 
      computeU = \textcolor{keyword}{true});
00171 
00189     \textcolor{keyword}{template}<\textcolor{keyword}{typename} HessMatrixType, \textcolor{keyword}{typename} OrthMatrixType>
00190     \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur}& \hyperlink{group___eigenvalues___module_ac4acc917dcaddefae5f35acd2c536d65}{computeFromHessenberg}(\textcolor{keyword}{const} HessMatrixType& matrixH, \textcolor{keyword}{const} 
      OrthMatrixType& matrixQ,  \textcolor{keywordtype}{bool} computeU);
\Hypertarget{eigen_2_eigen_2src_2_eigenvalues_2_real_schur_8h_source_l00195}\hyperlink{group___eigenvalues___module_a386fd2b1a3a8401eca7183ac074deec8}{00195}     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} \hyperlink{group___eigenvalues___module_a386fd2b1a3a8401eca7183ac074deec8}{info}()\textcolor{keyword}{ const}
00196 \textcolor{keyword}{    }\{
00197       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"RealSchur is not initialized."});
00198       \textcolor{keywordflow}{return} m\_info;
00199     \}
00200 
\Hypertarget{eigen_2_eigen_2src_2_eigenvalues_2_real_schur_8h_source_l00206}\hyperlink{group___eigenvalues___module_ad189e8776ee20a12046694f98b354322}{00206}     \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur}& \hyperlink{group___eigenvalues___module_ad189e8776ee20a12046694f98b354322}{setMaxIterations}(Index maxIters)
00207     \{
00208       m\_maxIters = maxIters;
00209       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00210     \}
00211 
\Hypertarget{eigen_2_eigen_2src_2_eigenvalues_2_real_schur_8h_source_l00213}\hyperlink{group___eigenvalues___module_a99453076a9617a6af353b5b1f3220c25}{00213}     Index \hyperlink{group___eigenvalues___module_a99453076a9617a6af353b5b1f3220c25}{getMaxIterations}()
00214     \{
00215       \textcolor{keywordflow}{return} m\_maxIters;
00216     \}
00217 
\Hypertarget{eigen_2_eigen_2src_2_eigenvalues_2_real_schur_8h_source_l00223}\hyperlink{group___eigenvalues___module_ab42163ff22cd3ad98aa2bde39b4bbc79}{00223}     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} \hyperlink{group___eigenvalues___module_ab42163ff22cd3ad98aa2bde39b4bbc79}{m\_maxIterationsPerRow} = 40;
00224 
00225   \textcolor{keyword}{private}:
00226     
00227     MatrixType m\_matT;
00228     MatrixType m\_matU;
00229     ColumnVectorType m\_workspaceVector;
00230     \hyperlink{group___eigenvalues___module}{HessenbergDecomposition<MatrixType>} m\_hess;
00231     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} m\_info;
00232     \textcolor{keywordtype}{bool} m\_isInitialized;
00233     \textcolor{keywordtype}{bool} m\_matUisUptodate;
00234     Index m\_maxIters;
00235 
00236     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,3,1>} \hyperlink{group___core___module}{Vector3s};
00237 
00238     Scalar computeNormOfT();
00239     Index findSmallSubdiagEntry(Index iu);
00240     \textcolor{keywordtype}{void} splitOffTwoRows(Index iu, \textcolor{keywordtype}{bool} computeU, \textcolor{keyword}{const} Scalar& exshift);
00241     \textcolor{keywordtype}{void} computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo);
00242     \textcolor{keywordtype}{void} initFrancisQRStep(Index il, Index iu, \textcolor{keyword}{const} Vector3s& shiftInfo, Index& im, Vector3s& 
      firstHouseholderVector);
00243     \textcolor{keywordtype}{void} performFrancisQRStep(Index il, Index im, Index iu, \textcolor{keywordtype}{bool} computeU, \textcolor{keyword}{const} Vector3s& 
      firstHouseholderVector, Scalar* workspace);
00244 \};
00245 
00246 
00247 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00248 \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>
00249 \hyperlink{group___eigenvalues___module}{RealSchur<MatrixType>}& \hyperlink{group___eigenvalues___module_a60caf9ffad11d728ea458c4dd36d0a98}{RealSchur<MatrixType>::compute}(\textcolor{keyword}{
      const} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<InputType>}& matrix, \textcolor{keywordtype}{bool} computeU)
00250 \{
00251   \textcolor{keyword}{const} Scalar considerAsZero = (std::numeric\_limits<Scalar>::min)();
00252 
00253   eigen\_assert(matrix.\hyperlink{group___core___module_a7b0b45c7351847696c911ce8aa2abbdb}{cols}() == matrix.\hyperlink{group___core___module_a8141320ba8df384426c298b32b000d8e}{rows}());
00254   \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} maxIters = m\_maxIters;
00255   \textcolor{keywordflow}{if} (maxIters == -1)
00256     maxIters = \hyperlink{group___eigenvalues___module_ab42163ff22cd3ad98aa2bde39b4bbc79}{m\_maxIterationsPerRow} * matrix.\hyperlink{group___core___module_a8141320ba8df384426c298b32b000d8e}{rows}();
00257 
00258   Scalar scale = matrix.\hyperlink{group___core___module_a324b16961a11d2ecfd2d1b7dd7946545}{derived}().cwiseAbs().maxCoeff();
00259   \textcolor{keywordflow}{if}(scale<considerAsZero)
00260   \{
00261     m\_matT.setZero(matrix.\hyperlink{group___core___module_a8141320ba8df384426c298b32b000d8e}{rows}(),matrix.\hyperlink{group___core___module_a7b0b45c7351847696c911ce8aa2abbdb}{cols}());
00262     \textcolor{keywordflow}{if}(computeU)
00263       m\_matU.setIdentity(matrix.\hyperlink{group___core___module_a8141320ba8df384426c298b32b000d8e}{rows}(),matrix.\hyperlink{group___core___module_a7b0b45c7351847696c911ce8aa2abbdb}{cols}());
00264     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00265     m\_isInitialized = \textcolor{keyword}{true};
00266     m\_matUisUptodate = computeU;
00267     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00268   \}
00269 
00270   \textcolor{comment}{// Step 1. Reduce to Hessenberg form}
00271   m\_hess.\hyperlink{group___eigenvalues___module_a239a6fd42c57aab3c0b048c47fde3004}{compute}(matrix.\hyperlink{group___core___module_a324b16961a11d2ecfd2d1b7dd7946545}{derived}()/scale);
00272 
00273   \textcolor{comment}{// Step 2. Reduce to real Schur form  }
00274   \hyperlink{group___eigenvalues___module_ac4acc917dcaddefae5f35acd2c536d65}{computeFromHessenberg}(m\_hess.\hyperlink{group___eigenvalues___module_a8e781d2e22a2304647bcf0ae913cc8ea}{matrixH}(), m\_hess.
      \hyperlink{group___eigenvalues___module_a346441e4902a58d43d698ac3da6ff791}{matrixQ}(), computeU);
00275 
00276   m\_matT *= scale;
00277   
00278   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00279 \}
00280 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00281 \textcolor{keyword}{template}<\textcolor{keyword}{typename} HessMatrixType, \textcolor{keyword}{typename} OrthMatrixType>
00282 \hyperlink{group___eigenvalues___module}{RealSchur<MatrixType>}& 
      \hyperlink{group___eigenvalues___module_ac4acc917dcaddefae5f35acd2c536d65}{RealSchur<MatrixType>::computeFromHessenberg}(\textcolor{keyword}{const} 
      HessMatrixType& matrixH, \textcolor{keyword}{const} OrthMatrixType& matrixQ,  \textcolor{keywordtype}{bool} computeU)
00283 \{
00284   \textcolor{keyword}{using} std::abs;
00285 
00286   m\_matT = matrixH;
00287   \textcolor{keywordflow}{if}(computeU)
00288     m\_matU = matrixQ;
00289   
00290   \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} maxIters = m\_maxIters;
00291   \textcolor{keywordflow}{if} (maxIters == -1)
00292     maxIters = \hyperlink{group___eigenvalues___module_ab42163ff22cd3ad98aa2bde39b4bbc79}{m\_maxIterationsPerRow} * matrixH.rows();
00293   m\_workspaceVector.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(m\_matT.cols());
00294   Scalar* workspace = &m\_workspaceVector.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(0);
00295 
00296   \textcolor{comment}{// The matrix m\_matT is divided in three parts. }
00297   \textcolor{comment}{// Rows 0,...,il-1 are decoupled from the rest because m\_matT(il,il-1) is zero. }
00298   \textcolor{comment}{// Rows il,...,iu is the part we are working on (the active window).}
00299   \textcolor{comment}{// Rows iu+1,...,end are already brought in triangular form.}
00300   \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} iu = m\_matT.cols() - 1;
00301   \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} iter = 0;      \textcolor{comment}{// iteration count for current eigenvalue}
00302   \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} totalIter = 0; \textcolor{comment}{// iteration count for whole matrix}
00303   Scalar exshift(0);   \textcolor{comment}{// sum of exceptional shifts}
00304   Scalar norm = computeNormOfT();
00305 
00306   \textcolor{keywordflow}{if}(norm!=0)
00307   \{
00308     \textcolor{keywordflow}{while} (iu >= 0)
00309     \{
00310       \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} il = findSmallSubdiagEntry(iu);
00311 
00312       \textcolor{comment}{// Check for convergence}
00313       \textcolor{keywordflow}{if} (il == iu) \textcolor{comment}{// One root found}
00314       \{
00315         m\_matT.coeffRef(iu,iu) = m\_matT.coeff(iu,iu) + exshift;
00316         \textcolor{keywordflow}{if} (iu > 0)
00317           m\_matT.coeffRef(iu, iu-1) = Scalar(0);
00318         iu--;
00319         iter = 0;
00320       \}
00321       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (il == iu-1) \textcolor{comment}{// Two roots found}
00322       \{
00323         splitOffTwoRows(iu, computeU, exshift);
00324         iu -= 2;
00325         iter = 0;
00326       \}
00327       \textcolor{keywordflow}{else} \textcolor{comment}{// No convergence yet}
00328       \{
00329         \textcolor{comment}{// The firstHouseholderVector vector has to be initialized to something to get rid of a silly GCC
       warning (-O1 -Wall -DNDEBUG )}
00330         \hyperlink{group___core___module}{Vector3s} firstHouseholderVector(0,0,0), shiftInfo;
00331         computeShift(iu, iter, exshift, shiftInfo);
00332         iter = iter + 1;
00333         totalIter = totalIter + 1;
00334         \textcolor{keywordflow}{if} (totalIter > maxIters) \textcolor{keywordflow}{break};
00335         \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} im;
00336         initFrancisQRStep(il, iu, shiftInfo, im, firstHouseholderVector);
00337         performFrancisQRStep(il, im, iu, computeU, firstHouseholderVector, workspace);
00338       \}
00339     \}
00340   \}
00341   \textcolor{keywordflow}{if}(totalIter <= maxIters)
00342     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00343   \textcolor{keywordflow}{else}
00344     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence};
00345 
00346   m\_isInitialized = \textcolor{keyword}{true};
00347   m\_matUisUptodate = computeU;
00348   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00349 \}
00350 
00352 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00353 \textcolor{keyword}{inline} \textcolor{keyword}{typename} MatrixType::Scalar \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur<MatrixType>::computeNormOfT}
      ()
00354 \{
00355   \textcolor{keyword}{const} \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} size = m\_matT.cols();
00356   \textcolor{comment}{// FIXME to be efficient the following would requires a triangular reduxion code}
00357   \textcolor{comment}{// Scalar norm = m\_matT.upper().cwiseAbs().sum() }
00358   \textcolor{comment}{//               + m\_matT.bottomLeftCorner(size-1,size-1).diagonal().cwiseAbs().sum();}
00359   Scalar norm(0);
00360   \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} j = 0; j < size; ++j)
00361     norm += m\_matT.col(j).segment(0, (std::min)(size,j+2)).cwiseAbs().sum();
00362   \textcolor{keywordflow}{return} norm;
00363 \}
00364 
00366 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00367 \textcolor{keyword}{inline} \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur<MatrixType>::findSmallSubdiagEntry}(
      \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} iu)
00368 \{
00369   \textcolor{keyword}{using} std::abs;
00370   \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} res = iu;
00371   \textcolor{keywordflow}{while} (res > 0)
00372   \{
00373     Scalar s = abs(m\_matT.coeff(res-1,res-1)) + abs(m\_matT.coeff(res,res));
00374     \textcolor{keywordflow}{if} (abs(m\_matT.coeff(res,res-1)) <= \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}() * s)
00375       \textcolor{keywordflow}{break};
00376     res--;
00377   \}
00378   \textcolor{keywordflow}{return} res;
00379 \}
00380 
00382 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00383 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur<MatrixType>::splitOffTwoRows}(
      \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} iu, \textcolor{keywordtype}{bool} computeU, \textcolor{keyword}{const} Scalar& exshift)
00384 \{
00385   \textcolor{keyword}{using} std::sqrt;
00386   \textcolor{keyword}{using} std::abs;
00387   \textcolor{keyword}{const} \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} size = m\_matT.cols();
00388 
00389   \textcolor{comment}{// The eigenvalues of the 2x2 matrix [a b; c d] are }
00390   \textcolor{comment}{// trace +/- sqrt(discr/4) where discr = tr^2 - 4*det, tr = a + d, det = ad - bc}
00391   Scalar p = Scalar(0.5) * (m\_matT.coeff(iu-1,iu-1) - m\_matT.coeff(iu,iu));
00392   Scalar q = p * p + m\_matT.coeff(iu,iu-1) * m\_matT.coeff(iu-1,iu);   \textcolor{comment}{// q = tr^2 / 4 - det = discr/4}
00393   m\_matT.coeffRef(iu,iu) += exshift;
00394   m\_matT.coeffRef(iu-1,iu-1) += exshift;
00395 
00396   \textcolor{keywordflow}{if} (q >= Scalar(0)) \textcolor{comment}{// Two real eigenvalues}
00397   \{
00398     Scalar z = sqrt(abs(q));
00399     \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<Scalar>} rot;
00400     \textcolor{keywordflow}{if} (p >= Scalar(0))
00401       rot.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(p + z, m\_matT.coeff(iu, iu-1));
00402     \textcolor{keywordflow}{else}
00403       rot.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(p - z, m\_matT.coeff(iu, iu-1));
00404 
00405     m\_matT.rightCols(size-iu+1).applyOnTheLeft(iu-1, iu, rot.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00406     m\_matT.topRows(iu+1).applyOnTheRight(iu-1, iu, rot);
00407     m\_matT.coeffRef(iu, iu-1) = Scalar(0); 
00408     \textcolor{keywordflow}{if} (computeU)
00409       m\_matU.applyOnTheRight(iu-1, iu, rot);
00410   \}
00411 
00412   \textcolor{keywordflow}{if} (iu > 1) 
00413     m\_matT.coeffRef(iu-1, iu-2) = Scalar(0);
00414 \}
00415 
00417 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00418 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur<MatrixType>::computeShift}(
      \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} iu, \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} iter, Scalar& exshift, \hyperlink{group___core___module}{Vector3s}& shiftInfo)
00419 \{
00420   \textcolor{keyword}{using} std::sqrt;
00421   \textcolor{keyword}{using} std::abs;
00422   shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(0) = m\_matT.coeff(iu,iu);
00423   shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(1) = m\_matT.coeff(iu-1,iu-1);
00424   shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(2) = m\_matT.coeff(iu,iu-1) * m\_matT.coeff(iu-1,iu);
00425 
00426   \textcolor{comment}{// Wilkinson's original ad hoc shift}
00427   \textcolor{keywordflow}{if} (iter == 10)
00428   \{
00429     exshift += shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(0);
00430     \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} i = 0; i <= iu; ++i)
00431       m\_matT.coeffRef(i,i) -= shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(0);
00432     Scalar s = abs(m\_matT.coeff(iu,iu-1)) + abs(m\_matT.coeff(iu-1,iu-2));
00433     shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(0) = Scalar(0.75) * s;
00434     shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(1) = Scalar(0.75) * s;
00435     shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(2) = Scalar(-0.4375) * s * s;
00436   \}
00437 
00438   \textcolor{comment}{// MATLAB's new ad hoc shift}
00439   \textcolor{keywordflow}{if} (iter == 30)
00440   \{
00441     Scalar s = (shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(1) - shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(0)) / Scalar(2.0);
00442     s = s * s + shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(2);
00443     \textcolor{keywordflow}{if} (s > Scalar(0))
00444     \{
00445       s = sqrt(s);
00446       \textcolor{keywordflow}{if} (shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(1) < shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(0))
00447         s = -s;
00448       s = s + (shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(1) - shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(0)) / Scalar(2.0);
00449       s = shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(0) - shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(2) / s;
00450       exshift += s;
00451       \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} i = 0; i <= iu; ++i)
00452         m\_matT.coeffRef(i,i) -= s;
00453       shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_ac8dea1df3d92b752cc683ff42abf6f9b}{setConstant}(Scalar(0.964));
00454     \}
00455   \}
00456 \}
00457 
00459 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00460 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur<MatrixType>::initFrancisQRStep}(
      \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} il, \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} iu, \textcolor{keyword}{const} \hyperlink{group___core___module}{Vector3s}& shiftInfo, \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index}& im, 
      \hyperlink{group___core___module}{Vector3s}& firstHouseholderVector)
00461 \{
00462   \textcolor{keyword}{using} std::abs;
00463   \hyperlink{group___core___module}{Vector3s}& v = firstHouseholderVector; \textcolor{comment}{// alias to save typing}
00464 
00465   \textcolor{keywordflow}{for} (im = iu-2; im >= il; --im)
00466   \{
00467     \textcolor{keyword}{const} Scalar Tmm = m\_matT.coeff(im,im);
00468     \textcolor{keyword}{const} Scalar r = shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(0) - Tmm;
00469     \textcolor{keyword}{const} Scalar s = shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(1) - Tmm;
00470     v.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(0) = (r * s - shiftInfo.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(2)) / m\_matT.coeff(im+1,im) + m\_matT.coeff(im,im+
      1);
00471     v.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(1) = m\_matT.coeff(im+1,im+1) - Tmm - r - s;
00472     v.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(2) = m\_matT.coeff(im+2,im+1);
00473     \textcolor{keywordflow}{if} (im == il) \{
00474       \textcolor{keywordflow}{break};
00475     \}
00476     \textcolor{keyword}{const} Scalar lhs = m\_matT.coeff(im,im-1) * (abs(v.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(1)) + abs(v.
      \hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(2)));
00477     \textcolor{keyword}{const} Scalar rhs = v.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(0) * (abs(m\_matT.coeff(im-1,im-1)) + abs(Tmm) + abs(m\_matT.coeff(im+1,
      im+1)));
00478     \textcolor{keywordflow}{if} (abs(lhs) < \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}() * rhs)
00479       \textcolor{keywordflow}{break};
00480   \}
00481 \}
00482 
00484 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00485 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur<MatrixType>::performFrancisQRStep}(
      \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} il, \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} im, \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} iu, \textcolor{keywordtype}{bool} computeU, \textcolor{keyword}{const} \hyperlink{group___core___module}{Vector3s}& firstHouseholderVector,
       Scalar* workspace)
00486 \{
00487   eigen\_assert(im >= il);
00488   eigen\_assert(im <= iu-2);
00489 
00490   \textcolor{keyword}{const} \hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} size = m\_matT.cols();
00491 
00492   \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} k = im; k <= iu-2; ++k)
00493   \{
00494     \textcolor{keywordtype}{bool} firstIteration = (k == im);
00495 
00496     \hyperlink{group___core___module}{Vector3s} v;
00497     \textcolor{keywordflow}{if} (firstIteration)
00498       v = firstHouseholderVector;
00499     \textcolor{keywordflow}{else}
00500       v = m\_matT.template block<3,1>(k,k-1);
00501 
00502     Scalar tau, beta;
00503     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, 2, 1>} ess;
00504     v.makeHouseholder(ess, tau, beta);
00505     
00506     \textcolor{keywordflow}{if} (beta != Scalar(0)) \textcolor{comment}{// if v is not zero}
00507     \{
00508       \textcolor{keywordflow}{if} (firstIteration && k > il)
00509         m\_matT.coeffRef(k,k-1) = -m\_matT.coeff(k,k-1);
00510       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!firstIteration)
00511         m\_matT.coeffRef(k,k-1) = beta;
00512 
00513       \textcolor{comment}{// These Householder transformations form the O(n^3) part of the algorithm}
00514       m\_matT.block(k, k, 3, size-k).applyHouseholderOnTheLeft(ess, tau, workspace);
00515       m\_matT.block(0, k, (std::min)(iu,k+3) + 1, 3).applyHouseholderOnTheRight(ess, tau, workspace);
00516       \textcolor{keywordflow}{if} (computeU)
00517         m\_matU.block(0, k, size, 3).applyHouseholderOnTheRight(ess, tau, workspace);
00518     \}
00519   \}
00520 
00521   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, 2, 1>} v = m\_matT.template block<2,1>(iu-1, iu-2);
00522   Scalar tau, beta;
00523   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, 1, 1>} ess;
00524   v.makeHouseholder(ess, tau, beta);
00525 
00526   \textcolor{keywordflow}{if} (beta != Scalar(0)) \textcolor{comment}{// if v is not zero}
00527   \{
00528     m\_matT.coeffRef(iu-1, iu-2) = beta;
00529     m\_matT.block(iu-1, iu-1, 2, size-iu+1).applyHouseholderOnTheLeft(ess, tau, workspace);
00530     m\_matT.block(0, iu-1, iu+1, 2).applyHouseholderOnTheRight(ess, tau, workspace);
00531     \textcolor{keywordflow}{if} (computeU)
00532       m\_matU.block(0, iu-1, size, 2).applyHouseholderOnTheRight(ess, tau, workspace);
00533   \}
00534 
00535   \textcolor{comment}{// clean up pollution due to round-off errors}
00536   \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a8bd4653e2d9569a44ecc95e746422d3f}{Index} i = im+2; i <= iu; ++i)
00537   \{
00538     m\_matT.coeffRef(i,i-2) = Scalar(0);
00539     \textcolor{keywordflow}{if} (i > im+2)
00540       m\_matT.coeffRef(i,i-3) = Scalar(0);
00541   \}
00542 \}
00543 
00544 \} \textcolor{comment}{// end namespace Eigen}
00545 
00546 \textcolor{preprocessor}{#endif // EIGEN\_REAL\_SCHUR\_H}
\end{DoxyCode}
