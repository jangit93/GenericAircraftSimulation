\hypertarget{matio_2visual__studio_2test_2eigen_2test_2array__for__matrix_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/array\+\_\+for\+\_\+matrix.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2array__for__matrix_8cpp_source}\index{array\+\_\+for\+\_\+matrix.\+cpp@{array\+\_\+for\+\_\+matrix.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} array\_for\_matrix(\textcolor{keyword}{const} MatrixType& m)
00013 \{
00014   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00015   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00016   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, 1>} 
      ColVectorType;
00017   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, 1, MatrixType::ColsAtCompileTime>} 
      RowVectorType; 
00018 
00019   Index rows = m.rows();
00020   Index cols = m.cols();
00021 
00022   MatrixType m1 = MatrixType::Random(rows, cols),
00023              m2 = MatrixType::Random(rows, cols),
00024              m3(rows, cols);
00025 
00026   ColVectorType cv1 = ColVectorType::Random(rows);
00027   RowVectorType rv1 = RowVectorType::Random(cols);
00028   
00029   Scalar  s1 = internal::random<Scalar>(),
00030           s2 = internal::random<Scalar>();
00031           
00032   \textcolor{comment}{// scalar addition}
00033   VERIFY\_IS\_APPROX(m1.array() + s1, s1 + m1.array());
00034   VERIFY\_IS\_APPROX((m1.array() + s1).matrix(), MatrixType::Constant(rows,cols,s1) + m1);
00035   VERIFY\_IS\_APPROX(((m1*Scalar(2)).\hyperlink{class_eigen_1_1array}{array}() - s2).matrix(), (m1+m1) - MatrixType::Constant(rows,cols,s2
      ) );
00036   m3 = m1;
00037   m3.array() += s2;
00038   VERIFY\_IS\_APPROX(m3, (m1.array() + s2).matrix());
00039   m3 = m1;
00040   m3.array() -= s1;
00041   VERIFY\_IS\_APPROX(m3, (m1.array() - s1).matrix());
00042 
00043   \textcolor{comment}{// reductions}
00044   VERIFY\_IS\_MUCH\_SMALLER\_THAN(m1.colwise().sum().sum() - m1.sum(), m1.squaredNorm());
00045   VERIFY\_IS\_MUCH\_SMALLER\_THAN(m1.rowwise().sum().sum() - m1.sum(), m1.squaredNorm());
00046   VERIFY\_IS\_MUCH\_SMALLER\_THAN(m1.colwise().sum() + m2.colwise().sum() - (m1+m2).colwise().sum(), (m1+m2).
      squaredNorm());
00047   VERIFY\_IS\_MUCH\_SMALLER\_THAN(m1.rowwise().sum() - m2.rowwise().sum() - (m1-m2).rowwise().sum(), (m1-m2).
      squaredNorm());
00048   VERIFY\_IS\_APPROX(m1.colwise().sum(), m1.colwise().redux(internal::scalar\_sum\_op<Scalar,Scalar>()));
00049 
00050   \textcolor{comment}{// vector-wise ops}
00051   m3 = m1;
00052   VERIFY\_IS\_APPROX(m3.colwise() += cv1, m1.colwise() + cv1);
00053   m3 = m1;
00054   VERIFY\_IS\_APPROX(m3.colwise() -= cv1, m1.colwise() - cv1);
00055   m3 = m1;
00056   VERIFY\_IS\_APPROX(m3.rowwise() += rv1, m1.rowwise() + rv1);
00057   m3 = m1;
00058   VERIFY\_IS\_APPROX(m3.rowwise() -= rv1, m1.rowwise() - rv1);
00059   
00060   \textcolor{comment}{// empty objects}
00061   VERIFY\_IS\_APPROX(m1.block(0,0,0,cols).colwise().sum(),  RowVectorType::Zero(cols));
00062   VERIFY\_IS\_APPROX(m1.block(0,0,rows,0).rowwise().prod(), ColVectorType::Ones(rows));
00063   
00064   \textcolor{comment}{// verify the const accessors exist}
00065   \textcolor{keyword}{const} Scalar& ref\_m1 = m.matrix().array().coeffRef(0);
00066   \textcolor{keyword}{const} Scalar& ref\_m2 = m.matrix().array().coeffRef(0,0);
00067   \textcolor{keyword}{const} Scalar& ref\_a1 = m.array().matrix().coeffRef(0);
00068   \textcolor{keyword}{const} Scalar& ref\_a2 = m.array().matrix().coeffRef(0,0);
00069   VERIFY(&ref\_a1 == &ref\_m1);
00070   VERIFY(&ref\_a2 == &ref\_m2);
00071 
00072   \textcolor{comment}{// Check write accessors:}
00073   m1.array().coeffRef(0,0) = 1;
00074   VERIFY\_IS\_APPROX(m1(0,0),Scalar(1));
00075   m1.array()(0,0) = 2;
00076   VERIFY\_IS\_APPROX(m1(0,0),Scalar(2));
00077   m1.array().matrix().coeffRef(0,0) = 3;
00078   VERIFY\_IS\_APPROX(m1(0,0),Scalar(3));
00079   m1.array().matrix()(0,0) = 4;
00080   VERIFY\_IS\_APPROX(m1(0,0),Scalar(4));
00081 \}
00082 
00083 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} comparisons(\textcolor{keyword}{const} MatrixType& m)
00084 \{
00085   \textcolor{keyword}{using} std::abs;
00086   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index Index;
00087   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00088   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00089 
00090   Index rows = m.rows();
00091   Index cols = m.cols();
00092 
00093   Index r = internal::random<Index>(0, rows-1),
00094         c = internal::random<Index>(0, cols-1);
00095 
00096   MatrixType m1 = MatrixType::Random(rows, cols),
00097              m2 = MatrixType::Random(rows, cols),
00098              m3(rows, cols);
00099 
00100   VERIFY(((m1.array() + Scalar(1)) > m1.array()).all());
00101   VERIFY(((m1.array() - Scalar(1)) < m1.array()).all());
00102   \textcolor{keywordflow}{if} (rows*cols>1)
00103   \{
00104     m3 = m1;
00105     m3(r,c) += 1;
00106     VERIFY(! (m1.array() < m3.array()).all() );
00107     VERIFY(! (m1.array() > m3.array()).all() );
00108   \}
00109 
00110   \textcolor{comment}{// comparisons to scalar}
00111   VERIFY( (m1.array() != (m1(r,c)+1) ).any() );
00112   VERIFY( (m1.array() > (m1(r,c)-1) ).any() );
00113   VERIFY( (m1.array() < (m1(r,c)+1) ).any() );
00114   VERIFY( (m1.array() == m1(r,c) ).any() );
00115   VERIFY( m1.cwiseEqual(m1(r,c)).any() );
00116 
00117   \textcolor{comment}{// test Select}
00118   VERIFY\_IS\_APPROX( (m1.array()<m2.array()).select(m1,m2), m1.cwiseMin(m2) );
00119   VERIFY\_IS\_APPROX( (m1.array()>m2.array()).select(m1,m2), m1.cwiseMax(m2) );
00120   Scalar mid = (m1.cwiseAbs().minCoeff() + m1.cwiseAbs().maxCoeff())/Scalar(2);
00121   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<cols; ++j)
00122   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<rows; ++i)
00123     m3(i,j) = abs(m1(i,j))<mid ? 0 : m1(i,j);
00124   VERIFY\_IS\_APPROX( (m1.array().abs()<MatrixType::Constant(rows,cols,mid).array())
00125                         .select(MatrixType::Zero(rows,cols),m1), m3);
00126   \textcolor{comment}{// shorter versions:}
00127   VERIFY\_IS\_APPROX( (m1.array().abs()<MatrixType::Constant(rows,cols,mid).array())
00128                         .select(0,m1), m3);
00129   VERIFY\_IS\_APPROX( (m1.array().abs()>=MatrixType::Constant(rows,cols,mid).array())
00130                         .select(m1,0), m3);
00131   \textcolor{comment}{// even shorter version:}
00132   VERIFY\_IS\_APPROX( (m1.array().abs()<mid).select(0,m1), m3);
00133 
00134   \textcolor{comment}{// count}
00135   VERIFY(((m1.array().abs()+1)>RealScalar(0.1)).count() == rows*cols);
00136 
00137   \textcolor{comment}{// and/or}
00138   VERIFY( ((m1.array()<RealScalar(0)).matrix() && (m1.array()>RealScalar(0)).matrix()).count() == 0);
00139   VERIFY( ((m1.array()<RealScalar(0)).matrix() || (m1.array()>=RealScalar(0)).matrix()).count() == rows*
      cols);
00140   RealScalar a = m1.cwiseAbs().mean();
00141   VERIFY( ((m1.array()<-a).matrix() || (m1.array()>a).matrix()).count() == (m1.cwiseAbs().array()>a).count(
      ));
00142 
00143   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<typename MatrixType::Index, Dynamic, 1>} 
      VectorOfIndices;
00144 
00145   \textcolor{comment}{// TODO allows colwise/rowwise for array}
00146   VERIFY\_IS\_APPROX(((m1.array().abs()+1)>RealScalar(0.1)).matrix().colwise().count(), 
      VectorOfIndices::Constant(cols,rows).transpose());
00147   VERIFY\_IS\_APPROX(((m1.array().abs()+1)>RealScalar(0.1)).matrix().rowwise().count(), 
      VectorOfIndices::Constant(rows, cols));
00148 \}
00149 
00150 \textcolor{keyword}{template}<\textcolor{keyword}{typename} VectorType> \textcolor{keywordtype}{void} lpNorm(\textcolor{keyword}{const} \hyperlink{struct_vector_type}{VectorType}& v)
00151 \{
00152   \textcolor{keyword}{using} std::sqrt;
00153   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::RealScalar RealScalar;
00154   \hyperlink{struct_vector_type}{VectorType} u = VectorType::Random(v.size());
00155 
00156   \textcolor{keywordflow}{if}(v.size()==0)
00157   \{
00158     VERIFY\_IS\_APPROX(u.template lpNorm<Infinity>(), RealScalar(0));
00159     VERIFY\_IS\_APPROX(u.template lpNorm<1>(), RealScalar(0));
00160     VERIFY\_IS\_APPROX(u.template lpNorm<2>(), RealScalar(0));
00161     VERIFY\_IS\_APPROX(u.template lpNorm<5>(), RealScalar(0));
00162   \}
00163   \textcolor{keywordflow}{else}
00164   \{
00165     VERIFY\_IS\_APPROX(u.template lpNorm<Infinity>(), u.cwiseAbs().maxCoeff());
00166   \}
00167 
00168   VERIFY\_IS\_APPROX(u.template lpNorm<1>(), u.cwiseAbs().sum());
00169   VERIFY\_IS\_APPROX(u.template lpNorm<2>(), sqrt(u.array().abs().square().sum()));
00170   VERIFY\_IS\_APPROX(numext::pow(u.template lpNorm<5>(), \textcolor{keyword}{typename} VectorType::RealScalar(5)), u.array().abs()
      .pow(5).sum());
00171 \}
00172 
00173 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} cwise\_min\_max(\textcolor{keyword}{const} MatrixType& m)
00174 \{
00175   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index Index;
00176   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00177 
00178   Index rows = m.rows();
00179   Index cols = m.cols();
00180 
00181   MatrixType m1 = MatrixType::Random(rows, cols);
00182 
00183   \textcolor{comment}{// min/max with array}
00184   Scalar maxM1 = m1.maxCoeff();
00185   Scalar minM1 = m1.minCoeff();
00186 
00187   VERIFY\_IS\_APPROX(MatrixType::Constant(rows,cols, minM1), m1.cwiseMin(MatrixType::Constant(rows,cols, 
      minM1)));
00188   VERIFY\_IS\_APPROX(m1, m1.cwiseMin(MatrixType::Constant(rows,cols, maxM1)));
00189 
00190   VERIFY\_IS\_APPROX(MatrixType::Constant(rows,cols, maxM1), m1.cwiseMax(MatrixType::Constant(rows,cols, 
      maxM1)));
00191   VERIFY\_IS\_APPROX(m1, m1.cwiseMax(MatrixType::Constant(rows,cols, minM1)));
00192 
00193   \textcolor{comment}{// min/max with scalar input}
00194   VERIFY\_IS\_APPROX(MatrixType::Constant(rows,cols, minM1), m1.cwiseMin( minM1));
00195   VERIFY\_IS\_APPROX(m1, m1.cwiseMin(maxM1));
00196   VERIFY\_IS\_APPROX(-m1, (-m1).cwiseMin(-minM1));
00197   VERIFY\_IS\_APPROX(-m1.array(), ((-m1).\hyperlink{class_eigen_1_1array}{array}().min)( -minM1));
00198 
00199   VERIFY\_IS\_APPROX(MatrixType::Constant(rows,cols, maxM1), m1.cwiseMax( maxM1));
00200   VERIFY\_IS\_APPROX(m1, m1.cwiseMax(minM1));
00201   VERIFY\_IS\_APPROX(-m1, (-m1).cwiseMax(-maxM1));
00202   VERIFY\_IS\_APPROX(-m1.array(), ((-m1).\hyperlink{class_eigen_1_1array}{array}().max)(-maxM1));
00203 
00204   VERIFY\_IS\_APPROX(MatrixType::Constant(rows,cols, minM1).\hyperlink{class_eigen_1_1array}{array}(), (m1.array().min)( minM1));
00205   VERIFY\_IS\_APPROX(m1.array(), (m1.array().min)( maxM1));
00206 
00207   VERIFY\_IS\_APPROX(MatrixType::Constant(rows,cols, maxM1).\hyperlink{class_eigen_1_1array}{array}(), (m1.array().max)( maxM1));
00208   VERIFY\_IS\_APPROX(m1.array(), (m1.array().max)( minM1));
00209 
00210 \}
00211 
00212 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixTraits> \textcolor{keywordtype}{void} resize(\textcolor{keyword}{const} MatrixTraits& t)
00213 \{
00214   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixTraits::Index Index;
00215   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixTraits::Scalar Scalar;
00216   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} MatrixType;
00217   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,Dynamic,Dynamic>} Array2DType;
00218   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} \hyperlink{struct_vector_type}{VectorType};
00219   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,Dynamic,1>} Array1DType;
00220 
00221   Index rows = t.rows(), cols = t.cols();
00222 
00223   MatrixType m(rows,cols);
00224   VectorType v(rows);
00225   Array2DType a2(rows,cols);
00226   Array1DType a1(rows);
00227 
00228   m.array().resize(rows+1,cols+1);
00229   VERIFY(m.rows()==rows+1 && m.cols()==cols+1);
00230   a2.matrix().resize(rows+1,cols+1);
00231   VERIFY(a2.rows()==rows+1 && a2.cols()==cols+1);
00232   v.array().resize(cols);
00233   VERIFY(v.size()==cols);
00234   a1.matrix().resize(cols);
00235   VERIFY(a1.size()==cols);
00236 \}
00237 
00238 \textcolor{keyword}{template}<\textcolor{keywordtype}{int}>
00239 \textcolor{keywordtype}{void} regression\_bug\_654()
00240 \{
00241   ArrayXf a = RowVectorXf(3);
00242   VectorXf v = \hyperlink{group___core___module_class_eigen_1_1_array}{Array<float,1,Dynamic>}(3);
00243 \}
00244 
00245 \textcolor{comment}{// Check propagation of LvalueBit through Array/Matrix-Wrapper}
00246 \textcolor{keyword}{template}<\textcolor{keywordtype}{int}>
00247 \textcolor{keywordtype}{void} regrrssion\_bug\_1410()
00248 \{
00249   \textcolor{keyword}{const} Matrix4i \hyperlink{group___core___module_class_eigen_1_1_matrix}{M};
00250   \textcolor{keyword}{const} Array4i \hyperlink{group___core___module_class_eigen_1_1_matrix}{A};
00251   \hyperlink{group___core___module_class_eigen_1_1_array_wrapper}{ArrayWrapper<const Matrix4i>} MA = M.array();
00252   MA.\hyperlink{group___core___module_a4ea11afe36c7962c706caa93decd1380}{row}(0);
00253   \hyperlink{group___core___module_class_eigen_1_1_matrix_wrapper}{MatrixWrapper<const Array4i>} AM = A.matrix();
00254   AM.\hyperlink{group___core___module_a4ea11afe36c7962c706caa93decd1380}{row}(0);
00255 
00256   VERIFY((internal::traits<\hyperlink{group___core___module_class_eigen_1_1_array_wrapper}{ArrayWrapper<const Matrix4i>} >::Flags&
      \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit})==0);
00257   VERIFY((internal::traits<\hyperlink{group___core___module_class_eigen_1_1_matrix_wrapper}{MatrixWrapper<const Array4i>} >::Flags&
      \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit})==0);
00258 
00259   VERIFY((internal::traits<\hyperlink{group___core___module_class_eigen_1_1_array_wrapper}{ArrayWrapper<Matrix4i>} >::Flags&
      \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit})==LvalueBit);
00260   VERIFY((internal::traits<\hyperlink{group___core___module_class_eigen_1_1_matrix_wrapper}{MatrixWrapper<Array4i>} >::Flags&
      \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit})==LvalueBit);
00261 \}
00262 
00263 \textcolor{keywordtype}{void} test\_array\_for\_matrix()
00264 \{
00265   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00266     CALL\_SUBTEST\_1( array\_for\_matrix(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00267     CALL\_SUBTEST\_2( array\_for\_matrix(Matrix2f()) );
00268     CALL\_SUBTEST\_3( array\_for\_matrix(Matrix4d()) );
00269     CALL\_SUBTEST\_4( array\_for\_matrix(MatrixXcf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00270     CALL\_SUBTEST\_5( array\_for\_matrix(MatrixXf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00271     CALL\_SUBTEST\_6( array\_for\_matrix(MatrixXi(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00272   \}
00273   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00274     CALL\_SUBTEST\_1( comparisons(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00275     CALL\_SUBTEST\_2( comparisons(Matrix2f()) );
00276     CALL\_SUBTEST\_3( comparisons(Matrix4d()) );
00277     CALL\_SUBTEST\_5( comparisons(MatrixXf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00278     CALL\_SUBTEST\_6( comparisons(MatrixXi(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00279   \}
00280   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00281     CALL\_SUBTEST\_1( cwise\_min\_max(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00282     CALL\_SUBTEST\_2( cwise\_min\_max(Matrix2f()) );
00283     CALL\_SUBTEST\_3( cwise\_min\_max(Matrix4d()) );
00284     CALL\_SUBTEST\_5( cwise\_min\_max(MatrixXf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00285     CALL\_SUBTEST\_6( cwise\_min\_max(MatrixXi(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00286   \}
00287   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00288     CALL\_SUBTEST\_1( lpNorm(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00289     CALL\_SUBTEST\_2( lpNorm(Vector2f()) );
00290     CALL\_SUBTEST\_7( lpNorm(Vector3d()) );
00291     CALL\_SUBTEST\_8( lpNorm(Vector4f()) );
00292     CALL\_SUBTEST\_5( lpNorm(VectorXf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00293     CALL\_SUBTEST\_4( lpNorm(VectorXcf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00294   \}
00295   CALL\_SUBTEST\_5( lpNorm(VectorXf(0)) );
00296   CALL\_SUBTEST\_4( lpNorm(VectorXcf(0)) );
00297   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00298     CALL\_SUBTEST\_4( resize(MatrixXcf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), internal::random<int>(1,
      EIGEN\_TEST\_MAX\_SIZE))) );
00299     CALL\_SUBTEST\_5( resize(MatrixXf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), internal::random<int>(1,
      EIGEN\_TEST\_MAX\_SIZE))) );
00300     CALL\_SUBTEST\_6( resize(MatrixXi(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), internal::random<int>(1,
      EIGEN\_TEST\_MAX\_SIZE))) );
00301   \}
00302   CALL\_SUBTEST\_6( regression\_bug\_654<0>() );
00303   CALL\_SUBTEST\_6( regrrssion\_bug\_1410<0>() );
00304 \}
\end{DoxyCode}
