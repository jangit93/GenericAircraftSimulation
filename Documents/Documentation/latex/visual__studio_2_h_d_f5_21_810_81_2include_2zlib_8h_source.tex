\hypertarget{visual__studio_2_h_d_f5_21_810_81_2include_2zlib_8h_source}{}\section{visual\+\_\+studio/\+H\+D\+F5/1.10.1/include/zlib.h}
\label{visual__studio_2_h_d_f5_21_810_81_2include_2zlib_8h_source}\index{zlib.\+h@{zlib.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* zlib.h -- interface of the 'zlib' general purpose compression library}
00002 \textcolor{comment}{  version 1.2.8, April 28th, 2013}
00003 \textcolor{comment}{}
00004 \textcolor{comment}{  Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler}
00005 \textcolor{comment}{}
00006 \textcolor{comment}{  This software is provided 'as-is', without any express or implied}
00007 \textcolor{comment}{  warranty.  In no event will the authors be held liable for any damages}
00008 \textcolor{comment}{  arising from the use of this software.}
00009 \textcolor{comment}{}
00010 \textcolor{comment}{  Permission is granted to anyone to use this software for any purpose,}
00011 \textcolor{comment}{  including commercial applications, and to alter it and redistribute it}
00012 \textcolor{comment}{  freely, subject to the following restrictions:}
00013 \textcolor{comment}{}
00014 \textcolor{comment}{  1. The origin of this software must not be misrepresented; you must not}
00015 \textcolor{comment}{     claim that you wrote the original software. If you use this software}
00016 \textcolor{comment}{     in a product, an acknowledgment in the product documentation would be}
00017 \textcolor{comment}{     appreciated but is not required.}
00018 \textcolor{comment}{  2. Altered source versions must be plainly marked as such, and must not be}
00019 \textcolor{comment}{     misrepresented as being the original software.}
00020 \textcolor{comment}{  3. This notice may not be removed or altered from any source distribution.}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{  Jean-loup Gailly        Mark Adler}
00023 \textcolor{comment}{  jloup@gzip.org          madler@alumni.caltech.edu}
00024 \textcolor{comment}{}
00025 \textcolor{comment}{}
00026 \textcolor{comment}{  The data format used by the zlib library is described by RFCs (Request for}
00027 \textcolor{comment}{  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950}
00028 \textcolor{comment}{  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).}
00029 \textcolor{comment}{*/}
00030 
00031 \textcolor{preprocessor}{#ifndef ZLIB\_H}
00032 \textcolor{preprocessor}{#define ZLIB\_H}
00033 
00034 \textcolor{preprocessor}{#include "zconf.h"}
00035 
00036 \textcolor{preprocessor}{#ifdef \_\_cplusplus}
00037 \textcolor{keyword}{extern} \textcolor{stringliteral}{"C"} \{
00038 \textcolor{preprocessor}{#endif}
00039 
00040 \textcolor{preprocessor}{#define ZLIB\_VERSION "1.2.8"}
00041 \textcolor{preprocessor}{#define ZLIB\_VERNUM 0x1280}
00042 \textcolor{preprocessor}{#define ZLIB\_VER\_MAJOR 1}
00043 \textcolor{preprocessor}{#define ZLIB\_VER\_MINOR 2}
00044 \textcolor{preprocessor}{#define ZLIB\_VER\_REVISION 8}
00045 \textcolor{preprocessor}{#define ZLIB\_VER\_SUBREVISION 0}
00046 
00047 \textcolor{comment}{/*}
00048 \textcolor{comment}{    The 'zlib' compression library provides in-memory compression and}
00049 \textcolor{comment}{  decompression functions, including integrity checks of the uncompressed data.}
00050 \textcolor{comment}{  This version of the library supports only one compression method (deflation)}
00051 \textcolor{comment}{  but other algorithms will be added later and will have the same stream}
00052 \textcolor{comment}{  interface.}
00053 \textcolor{comment}{}
00054 \textcolor{comment}{    Compression can be done in a single step if the buffers are large enough,}
00055 \textcolor{comment}{  or can be done by repeated calls of the compression function.  In the latter}
00056 \textcolor{comment}{  case, the application must provide more input and/or consume the output}
00057 \textcolor{comment}{  (providing more output space) before each call.}
00058 \textcolor{comment}{}
00059 \textcolor{comment}{    The compressed data format used by default by the in-memory functions is}
00060 \textcolor{comment}{  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped}
00061 \textcolor{comment}{  around a deflate stream, which is itself documented in RFC 1951.}
00062 \textcolor{comment}{}
00063 \textcolor{comment}{    The library also supports reading and writing files in gzip (.gz) format}
00064 \textcolor{comment}{  with an interface similar to that of stdio using the functions that start}
00065 \textcolor{comment}{  with "gz".  The gzip format is different from the zlib format.  gzip is a}
00066 \textcolor{comment}{  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.}
00067 \textcolor{comment}{}
00068 \textcolor{comment}{    This library can optionally read and write gzip streams in memory as well.}
00069 \textcolor{comment}{}
00070 \textcolor{comment}{    The zlib format was designed to be compact and fast for use in memory}
00071 \textcolor{comment}{  and on communications channels.  The gzip format was designed for single-}
00072 \textcolor{comment}{  file compression on file systems, has a larger header than zlib to maintain}
00073 \textcolor{comment}{  directory information, and uses a different, slower check method than zlib.}
00074 \textcolor{comment}{}
00075 \textcolor{comment}{    The library does not install any signal handler.  The decoder checks}
00076 \textcolor{comment}{  the consistency of the compressed data, so the library should never crash}
00077 \textcolor{comment}{  even in case of corrupted input.}
00078 \textcolor{comment}{*/}
00079 
00080 \textcolor{keyword}{typedef} voidpf (*alloc\_func) OF((voidpf opaque, uInt items, uInt size));
00081 \textcolor{keyword}{typedef} void   (*free\_func)  OF((voidpf opaque, voidpf address));
00082 
00083 \textcolor{keyword}{struct }\hyperlink{structinternal__state}{internal\_state};
00084 
00085 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structz__stream__s}{z\_stream\_s} \{
00086     z\_const Bytef *next\_in;     \textcolor{comment}{/* next input byte */}
00087     uInt     avail\_in;  \textcolor{comment}{/* number of bytes available at next\_in */}
00088     uLong    total\_in;  \textcolor{comment}{/* total number of input bytes read so far */}
00089 
00090     Bytef    *next\_out; \textcolor{comment}{/* next output byte should be put there */}
00091     uInt     avail\_out; \textcolor{comment}{/* remaining free space at next\_out */}
00092     uLong    total\_out; \textcolor{comment}{/* total number of bytes output so far */}
00093 
00094     z\_const \textcolor{keywordtype}{char} *msg;  \textcolor{comment}{/* last error message, NULL if no error */}
00095     \textcolor{keyword}{struct }\hyperlink{structinternal__state}{internal\_state} FAR *\hyperlink{structstate}{state}; \textcolor{comment}{/* not visible by applications */}
00096 
00097     alloc\_func zalloc;  \textcolor{comment}{/* used to allocate the internal state */}
00098     free\_func  zfree;   \textcolor{comment}{/* used to free the internal state */}
00099     voidpf     opaque;  \textcolor{comment}{/* private data object passed to zalloc and zfree */}
00100 
00101     \textcolor{keywordtype}{int}     data\_type;  \textcolor{comment}{/* best guess about the data type: binary or text */}
00102     uLong   adler;      \textcolor{comment}{/* adler32 value of the uncompressed data */}
00103     uLong   reserved;   \textcolor{comment}{/* reserved for future use */}
00104 \} \hyperlink{structz__stream__s}{z\_stream};
00105 
00106 \textcolor{keyword}{typedef} \hyperlink{structz__stream__s}{z\_stream} FAR *z\_streamp;
00107 
00108 \textcolor{comment}{/*}
00109 \textcolor{comment}{     gzip header information passed to and from zlib routines.  See RFC 1952}
00110 \textcolor{comment}{  for more details on the meanings of these fields.}
00111 \textcolor{comment}{*/}
00112 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structgz__header__s}{gz\_header\_s} \{
00113     \textcolor{keywordtype}{int}     text;       \textcolor{comment}{/* true if compressed data believed to be text */}
00114     uLong   time;       \textcolor{comment}{/* modification time */}
00115     \textcolor{keywordtype}{int}     xflags;     \textcolor{comment}{/* extra flags (not used when writing a gzip file) */}
00116     \textcolor{keywordtype}{int}     os;         \textcolor{comment}{/* operating system */}
00117     Bytef   *extra;     \textcolor{comment}{/* pointer to extra field or Z\_NULL if none */}
00118     uInt    extra\_len;  \textcolor{comment}{/* extra field length (valid if extra != Z\_NULL) */}
00119     uInt    extra\_max;  \textcolor{comment}{/* space at extra (only when reading header) */}
00120     Bytef   *name;      \textcolor{comment}{/* pointer to zero-terminated file name or Z\_NULL */}
00121     uInt    name\_max;   \textcolor{comment}{/* space at name (only when reading header) */}
00122     Bytef   *comment;   \textcolor{comment}{/* pointer to zero-terminated comment or Z\_NULL */}
00123     uInt    comm\_max;   \textcolor{comment}{/* space at comment (only when reading header) */}
00124     \textcolor{keywordtype}{int}     hcrc;       \textcolor{comment}{/* true if there was or will be a header crc */}
00125     \textcolor{keywordtype}{int}     done;       \textcolor{comment}{/* true when done reading gzip header (not used}
00126 \textcolor{comment}{                           when writing a gzip file) */}
00127 \} \hyperlink{structgz__header__s}{gz\_header};
00128 
00129 \textcolor{keyword}{typedef} \hyperlink{structgz__header__s}{gz\_header} FAR *gz\_headerp;
00130 
00131 \textcolor{comment}{/*}
00132 \textcolor{comment}{     The application must update next\_in and avail\_in when avail\_in has dropped}
00133 \textcolor{comment}{   to zero.  It must update next\_out and avail\_out when avail\_out has dropped}
00134 \textcolor{comment}{   to zero.  The application must initialize zalloc, zfree and opaque before}
00135 \textcolor{comment}{   calling the init function.  All other fields are set by the compression}
00136 \textcolor{comment}{   library and must not be updated by the application.}
00137 \textcolor{comment}{}
00138 \textcolor{comment}{     The opaque value provided by the application will be passed as the first}
00139 \textcolor{comment}{   parameter for calls of zalloc and zfree.  This can be useful for custom}
00140 \textcolor{comment}{   memory management.  The compression library attaches no meaning to the}
00141 \textcolor{comment}{   opaque value.}
00142 \textcolor{comment}{}
00143 \textcolor{comment}{     zalloc must return Z\_NULL if there is not enough memory for the object.}
00144 \textcolor{comment}{   If zlib is used in a multi-threaded application, zalloc and zfree must be}
00145 \textcolor{comment}{   thread safe.}
00146 \textcolor{comment}{}
00147 \textcolor{comment}{     On 16-bit systems, the functions zalloc and zfree must be able to allocate}
00148 \textcolor{comment}{   exactly 65536 bytes, but will not be required to allocate more than this if}
00149 \textcolor{comment}{   the symbol MAXSEG\_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers}
00150 \textcolor{comment}{   returned by zalloc for objects of exactly 65536 bytes *must* have their}
00151 \textcolor{comment}{   offset normalized to zero.  The default allocation function provided by this}
00152 \textcolor{comment}{   library ensures this (see zutil.c).  To reduce memory requirements and avoid}
00153 \textcolor{comment}{   any allocation of 64K objects, at the expense of compression ratio, compile}
00154 \textcolor{comment}{   the library with -DMAX\_WBITS=14 (see zconf.h).}
00155 \textcolor{comment}{}
00156 \textcolor{comment}{     The fields total\_in and total\_out can be used for statistics or progress}
00157 \textcolor{comment}{   reports.  After compression, total\_in holds the total size of the}
00158 \textcolor{comment}{   uncompressed data and may be saved for use in the decompressor (particularly}
00159 \textcolor{comment}{   if the decompressor wants to decompress everything in a single step).}
00160 \textcolor{comment}{*/}
00161 
00162                         \textcolor{comment}{/* constants */}
00163 
00164 \textcolor{preprocessor}{#define Z\_NO\_FLUSH      0}
00165 \textcolor{preprocessor}{#define Z\_PARTIAL\_FLUSH 1}
00166 \textcolor{preprocessor}{#define Z\_SYNC\_FLUSH    2}
00167 \textcolor{preprocessor}{#define Z\_FULL\_FLUSH    3}
00168 \textcolor{preprocessor}{#define Z\_FINISH        4}
00169 \textcolor{preprocessor}{#define Z\_BLOCK         5}
00170 \textcolor{preprocessor}{#define Z\_TREES         6}
00171 \textcolor{comment}{/* Allowed flush values; see deflate() and inflate() below for details */}
00172 
00173 \textcolor{preprocessor}{#define Z\_OK            0}
00174 \textcolor{preprocessor}{#define Z\_STREAM\_END    1}
00175 \textcolor{preprocessor}{#define Z\_NEED\_DICT     2}
00176 \textcolor{preprocessor}{#define Z\_ERRNO        (-1)}
00177 \textcolor{preprocessor}{#define Z\_STREAM\_ERROR (-2)}
00178 \textcolor{preprocessor}{#define Z\_DATA\_ERROR   (-3)}
00179 \textcolor{preprocessor}{#define Z\_MEM\_ERROR    (-4)}
00180 \textcolor{preprocessor}{#define Z\_BUF\_ERROR    (-5)}
00181 \textcolor{preprocessor}{#define Z\_VERSION\_ERROR (-6)}
00182 \textcolor{comment}{/* Return codes for the compression/decompression functions. Negative values}
00183 \textcolor{comment}{ * are errors, positive values are used for special but normal events.}
00184 \textcolor{comment}{ */}
00185 
00186 \textcolor{preprocessor}{#define Z\_NO\_COMPRESSION         0}
00187 \textcolor{preprocessor}{#define Z\_BEST\_SPEED             1}
00188 \textcolor{preprocessor}{#define Z\_BEST\_COMPRESSION       9}
00189 \textcolor{preprocessor}{#define Z\_DEFAULT\_COMPRESSION  (-1)}
00190 \textcolor{comment}{/* compression levels */}
00191 
00192 \textcolor{preprocessor}{#define Z\_FILTERED            1}
00193 \textcolor{preprocessor}{#define Z\_HUFFMAN\_ONLY        2}
00194 \textcolor{preprocessor}{#define Z\_RLE                 3}
00195 \textcolor{preprocessor}{#define Z\_FIXED               4}
00196 \textcolor{preprocessor}{#define Z\_DEFAULT\_STRATEGY    0}
00197 \textcolor{comment}{/* compression strategy; see deflateInit2() below for details */}
00198 
00199 \textcolor{preprocessor}{#define Z\_BINARY   0}
00200 \textcolor{preprocessor}{#define Z\_TEXT     1}
00201 \textcolor{preprocessor}{#define Z\_ASCII    Z\_TEXT   }\textcolor{comment}{/* for compatibility with 1.2.2 and earlier */}\textcolor{preprocessor}{}
00202 \textcolor{preprocessor}{#define Z\_UNKNOWN  2}
00203 \textcolor{comment}{/* Possible values of the data\_type field (though see inflate()) */}
00204 
00205 \textcolor{preprocessor}{#define Z\_DEFLATED   8}
00206 \textcolor{comment}{/* The deflate compression method (the only one supported in this version) */}
00207 
00208 \textcolor{preprocessor}{#define Z\_NULL  0  }\textcolor{comment}{/* for initializing zalloc, zfree, opaque */}\textcolor{preprocessor}{}
00209 
00210 \textcolor{preprocessor}{#define zlib\_version zlibVersion()}
00211 \textcolor{comment}{/* for compatibility with versions < 1.0.2 */}
00212 
00213 
00214                         \textcolor{comment}{/* basic functions */}
00215 
00216 ZEXTERN \textcolor{keyword}{const} \textcolor{keywordtype}{char} * ZEXPORT zlibVersion OF((\textcolor{keywordtype}{void}));
00217 \textcolor{comment}{/* The application can compare zlibVersion and ZLIB\_VERSION for consistency.}
00218 \textcolor{comment}{   If the first character differs, the library code actually used is not}
00219 \textcolor{comment}{   compatible with the zlib.h header file used by the application.  This check}
00220 \textcolor{comment}{   is automatically made by deflateInit and inflateInit.}
00221 \textcolor{comment}{ */}
00222 
00223 \textcolor{comment}{/*}
00224 \textcolor{comment}{ZEXTERN int ZEXPORT deflateInit OF((z\_streamp strm, int level));}
00225 \textcolor{comment}{}
00226 \textcolor{comment}{     Initializes the internal stream state for compression.  The fields}
00227 \textcolor{comment}{   zalloc, zfree and opaque must be initialized before by the caller.  If}
00228 \textcolor{comment}{   zalloc and zfree are set to Z\_NULL, deflateInit updates them to use default}
00229 \textcolor{comment}{   allocation functions.}
00230 \textcolor{comment}{}
00231 \textcolor{comment}{     The compression level must be Z\_DEFAULT\_COMPRESSION, or between 0 and 9:}
00232 \textcolor{comment}{   1 gives best speed, 9 gives best compression, 0 gives no compression at all}
00233 \textcolor{comment}{   (the input data is simply copied a block at a time).  Z\_DEFAULT\_COMPRESSION}
00234 \textcolor{comment}{   requests a default compromise between speed and compression (currently}
00235 \textcolor{comment}{   equivalent to level 6).}
00236 \textcolor{comment}{}
00237 \textcolor{comment}{     deflateInit returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough}
00238 \textcolor{comment}{   memory, Z\_STREAM\_ERROR if level is not a valid compression level, or}
00239 \textcolor{comment}{   Z\_VERSION\_ERROR if the zlib library version (zlib\_version) is incompatible}
00240 \textcolor{comment}{   with the version assumed by the caller (ZLIB\_VERSION).  msg is set to null}
00241 \textcolor{comment}{   if there is no error message.  deflateInit does not perform any compression:}
00242 \textcolor{comment}{   this will be done by deflate().}
00243 \textcolor{comment}{*/}
00244 
00245 
00246 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflate OF((z\_streamp strm, \textcolor{keywordtype}{int} flush));
00247 \textcolor{comment}{/*}
00248 \textcolor{comment}{    deflate compresses as much data as possible, and stops when the input}
00249 \textcolor{comment}{  buffer becomes empty or the output buffer becomes full.  It may introduce}
00250 \textcolor{comment}{  some output latency (reading input without producing any output) except when}
00251 \textcolor{comment}{  forced to flush.}
00252 \textcolor{comment}{}
00253 \textcolor{comment}{    The detailed semantics are as follows.  deflate performs one or both of the}
00254 \textcolor{comment}{  following actions:}
00255 \textcolor{comment}{}
00256 \textcolor{comment}{  - Compress more input starting at next\_in and update next\_in and avail\_in}
00257 \textcolor{comment}{    accordingly.  If not all input can be processed (because there is not}
00258 \textcolor{comment}{    enough room in the output buffer), next\_in and avail\_in are updated and}
00259 \textcolor{comment}{    processing will resume at this point for the next call of deflate().}
00260 \textcolor{comment}{}
00261 \textcolor{comment}{  - Provide more output starting at next\_out and update next\_out and avail\_out}
00262 \textcolor{comment}{    accordingly.  This action is forced if the parameter flush is non zero.}
00263 \textcolor{comment}{    Forcing flush frequently degrades the compression ratio, so this parameter}
00264 \textcolor{comment}{    should be set only when necessary (in interactive applications).  Some}
00265 \textcolor{comment}{    output may be provided even if flush is not set.}
00266 \textcolor{comment}{}
00267 \textcolor{comment}{    Before the call of deflate(), the application should ensure that at least}
00268 \textcolor{comment}{  one of the actions is possible, by providing more input and/or consuming more}
00269 \textcolor{comment}{  output, and updating avail\_in or avail\_out accordingly; avail\_out should}
00270 \textcolor{comment}{  never be zero before the call.  The application can consume the compressed}
00271 \textcolor{comment}{  output when it wants, for example when the output buffer is full (avail\_out}
00272 \textcolor{comment}{  == 0), or after each call of deflate().  If deflate returns Z\_OK and with}
00273 \textcolor{comment}{  zero avail\_out, it must be called again after making room in the output}
00274 \textcolor{comment}{  buffer because there might be more output pending.}
00275 \textcolor{comment}{}
00276 \textcolor{comment}{    Normally the parameter flush is set to Z\_NO\_FLUSH, which allows deflate to}
00277 \textcolor{comment}{  decide how much data to accumulate before producing output, in order to}
00278 \textcolor{comment}{  maximize compression.}
00279 \textcolor{comment}{}
00280 \textcolor{comment}{    If the parameter flush is set to Z\_SYNC\_FLUSH, all pending output is}
00281 \textcolor{comment}{  flushed to the output buffer and the output is aligned on a byte boundary, so}
00282 \textcolor{comment}{  that the decompressor can get all input data available so far.  (In}
00283 \textcolor{comment}{  particular avail\_in is zero after the call if enough output space has been}
00284 \textcolor{comment}{  provided before the call.) Flushing may degrade compression for some}
00285 \textcolor{comment}{  compression algorithms and so it should be used only when necessary.  This}
00286 \textcolor{comment}{  completes the current deflate block and follows it with an empty stored block}
00287 \textcolor{comment}{  that is three bits plus filler bits to the next byte, followed by four bytes}
00288 \textcolor{comment}{  (00 00 ff ff).}
00289 \textcolor{comment}{}
00290 \textcolor{comment}{    If flush is set to Z\_PARTIAL\_FLUSH, all pending output is flushed to the}
00291 \textcolor{comment}{  output buffer, but the output is not aligned to a byte boundary.  All of the}
00292 \textcolor{comment}{  input data so far will be available to the decompressor, as for Z\_SYNC\_FLUSH.}
00293 \textcolor{comment}{  This completes the current deflate block and follows it with an empty fixed}
00294 \textcolor{comment}{  codes block that is 10 bits long.  This assures that enough bytes are output}
00295 \textcolor{comment}{  in order for the decompressor to finish the block before the empty fixed code}
00296 \textcolor{comment}{  block.}
00297 \textcolor{comment}{}
00298 \textcolor{comment}{    If flush is set to Z\_BLOCK, a deflate block is completed and emitted, as}
00299 \textcolor{comment}{  for Z\_SYNC\_FLUSH, but the output is not aligned on a byte boundary, and up to}
00300 \textcolor{comment}{  seven bits of the current block are held to be written as the next byte after}
00301 \textcolor{comment}{  the next deflate block is completed.  In this case, the decompressor may not}
00302 \textcolor{comment}{  be provided enough bits at this point in order to complete decompression of}
00303 \textcolor{comment}{  the data provided so far to the compressor.  It may need to wait for the next}
00304 \textcolor{comment}{  block to be emitted.  This is for advanced applications that need to control}
00305 \textcolor{comment}{  the emission of deflate blocks.}
00306 \textcolor{comment}{}
00307 \textcolor{comment}{    If flush is set to Z\_FULL\_FLUSH, all output is flushed as with}
00308 \textcolor{comment}{  Z\_SYNC\_FLUSH, and the compression state is reset so that decompression can}
00309 \textcolor{comment}{  restart from this point if previous compressed data has been damaged or if}
00310 \textcolor{comment}{  random access is desired.  Using Z\_FULL\_FLUSH too often can seriously degrade}
00311 \textcolor{comment}{  compression.}
00312 \textcolor{comment}{}
00313 \textcolor{comment}{    If deflate returns with avail\_out == 0, this function must be called again}
00314 \textcolor{comment}{  with the same value of the flush parameter and more output space (updated}
00315 \textcolor{comment}{  avail\_out), until the flush is complete (deflate returns with non-zero}
00316 \textcolor{comment}{  avail\_out).  In the case of a Z\_FULL\_FLUSH or Z\_SYNC\_FLUSH, make sure that}
00317 \textcolor{comment}{  avail\_out is greater than six to avoid repeated flush markers due to}
00318 \textcolor{comment}{  avail\_out == 0 on return.}
00319 \textcolor{comment}{}
00320 \textcolor{comment}{    If the parameter flush is set to Z\_FINISH, pending input is processed,}
00321 \textcolor{comment}{  pending output is flushed and deflate returns with Z\_STREAM\_END if there was}
00322 \textcolor{comment}{  enough output space; if deflate returns with Z\_OK, this function must be}
00323 \textcolor{comment}{  called again with Z\_FINISH and more output space (updated avail\_out) but no}
00324 \textcolor{comment}{  more input data, until it returns with Z\_STREAM\_END or an error.  After}
00325 \textcolor{comment}{  deflate has returned Z\_STREAM\_END, the only possible operations on the stream}
00326 \textcolor{comment}{  are deflateReset or deflateEnd.}
00327 \textcolor{comment}{}
00328 \textcolor{comment}{    Z\_FINISH can be used immediately after deflateInit if all the compression}
00329 \textcolor{comment}{  is to be done in a single step.  In this case, avail\_out must be at least the}
00330 \textcolor{comment}{  value returned by deflateBound (see below).  Then deflate is guaranteed to}
00331 \textcolor{comment}{  return Z\_STREAM\_END.  If not enough output space is provided, deflate will}
00332 \textcolor{comment}{  not return Z\_STREAM\_END, and it must be called again as described above.}
00333 \textcolor{comment}{}
00334 \textcolor{comment}{    deflate() sets strm->adler to the adler32 checksum of all input read}
00335 \textcolor{comment}{  so far (that is, total\_in bytes).}
00336 \textcolor{comment}{}
00337 \textcolor{comment}{    deflate() may update strm->data\_type if it can make a good guess about}
00338 \textcolor{comment}{  the input data type (Z\_BINARY or Z\_TEXT).  In doubt, the data is considered}
00339 \textcolor{comment}{  binary.  This field is only for information purposes and does not affect the}
00340 \textcolor{comment}{  compression algorithm in any manner.}
00341 \textcolor{comment}{}
00342 \textcolor{comment}{    deflate() returns Z\_OK if some progress has been made (more input}
00343 \textcolor{comment}{  processed or more output produced), Z\_STREAM\_END if all input has been}
00344 \textcolor{comment}{  consumed and all output has been produced (only when flush is set to}
00345 \textcolor{comment}{  Z\_FINISH), Z\_STREAM\_ERROR if the stream state was inconsistent (for example}
00346 \textcolor{comment}{  if next\_in or next\_out was Z\_NULL), Z\_BUF\_ERROR if no progress is possible}
00347 \textcolor{comment}{  (for example avail\_in or avail\_out was zero).  Note that Z\_BUF\_ERROR is not}
00348 \textcolor{comment}{  fatal, and deflate() can be called again with more input and more output}
00349 \textcolor{comment}{  space to continue compressing.}
00350 \textcolor{comment}{*/}
00351 
00352 
00353 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateEnd OF((z\_streamp strm));
00354 \textcolor{comment}{/*}
00355 \textcolor{comment}{     All dynamically allocated data structures for this stream are freed.}
00356 \textcolor{comment}{   This function discards any unprocessed input and does not flush any pending}
00357 \textcolor{comment}{   output.}
00358 \textcolor{comment}{}
00359 \textcolor{comment}{     deflateEnd returns Z\_OK if success, Z\_STREAM\_ERROR if the}
00360 \textcolor{comment}{   stream state was inconsistent, Z\_DATA\_ERROR if the stream was freed}
00361 \textcolor{comment}{   prematurely (some input or output was discarded).  In the error case, msg}
00362 \textcolor{comment}{   may be set but then points to a static string (which must not be}
00363 \textcolor{comment}{   deallocated).}
00364 \textcolor{comment}{*/}
00365 
00366 
00367 \textcolor{comment}{/*}
00368 \textcolor{comment}{ZEXTERN int ZEXPORT inflateInit OF((z\_streamp strm));}
00369 \textcolor{comment}{}
00370 \textcolor{comment}{     Initializes the internal stream state for decompression.  The fields}
00371 \textcolor{comment}{   next\_in, avail\_in, zalloc, zfree and opaque must be initialized before by}
00372 \textcolor{comment}{   the caller.  If next\_in is not Z\_NULL and avail\_in is large enough (the}
00373 \textcolor{comment}{   exact value depends on the compression method), inflateInit determines the}
00374 \textcolor{comment}{   compression method from the zlib header and allocates all data structures}
00375 \textcolor{comment}{   accordingly; otherwise the allocation will be deferred to the first call of}
00376 \textcolor{comment}{   inflate.  If zalloc and zfree are set to Z\_NULL, inflateInit updates them to}
00377 \textcolor{comment}{   use default allocation functions.}
00378 \textcolor{comment}{}
00379 \textcolor{comment}{     inflateInit returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough}
00380 \textcolor{comment}{   memory, Z\_VERSION\_ERROR if the zlib library version is incompatible with the}
00381 \textcolor{comment}{   version assumed by the caller, or Z\_STREAM\_ERROR if the parameters are}
00382 \textcolor{comment}{   invalid, such as a null pointer to the structure.  msg is set to null if}
00383 \textcolor{comment}{   there is no error message.  inflateInit does not perform any decompression}
00384 \textcolor{comment}{   apart from possibly reading the zlib header if present: actual decompression}
00385 \textcolor{comment}{   will be done by inflate().  (So next\_in and avail\_in may be modified, but}
00386 \textcolor{comment}{   next\_out and avail\_out are unused and unchanged.) The current implementation}
00387 \textcolor{comment}{   of inflateInit() does not process any header information -- that is deferred}
00388 \textcolor{comment}{   until inflate() is called.}
00389 \textcolor{comment}{*/}
00390 
00391 
00392 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflate OF((z\_streamp strm, \textcolor{keywordtype}{int} flush));
00393 \textcolor{comment}{/*}
00394 \textcolor{comment}{    inflate decompresses as much data as possible, and stops when the input}
00395 \textcolor{comment}{  buffer becomes empty or the output buffer becomes full.  It may introduce}
00396 \textcolor{comment}{  some output latency (reading input without producing any output) except when}
00397 \textcolor{comment}{  forced to flush.}
00398 \textcolor{comment}{}
00399 \textcolor{comment}{  The detailed semantics are as follows.  inflate performs one or both of the}
00400 \textcolor{comment}{  following actions:}
00401 \textcolor{comment}{}
00402 \textcolor{comment}{  - Decompress more input starting at next\_in and update next\_in and avail\_in}
00403 \textcolor{comment}{    accordingly.  If not all input can be processed (because there is not}
00404 \textcolor{comment}{    enough room in the output buffer), next\_in is updated and processing will}
00405 \textcolor{comment}{    resume at this point for the next call of inflate().}
00406 \textcolor{comment}{}
00407 \textcolor{comment}{  - Provide more output starting at next\_out and update next\_out and avail\_out}
00408 \textcolor{comment}{    accordingly.  inflate() provides as much output as possible, until there is}
00409 \textcolor{comment}{    no more input data or no more space in the output buffer (see below about}
00410 \textcolor{comment}{    the flush parameter).}
00411 \textcolor{comment}{}
00412 \textcolor{comment}{    Before the call of inflate(), the application should ensure that at least}
00413 \textcolor{comment}{  one of the actions is possible, by providing more input and/or consuming more}
00414 \textcolor{comment}{  output, and updating the next\_* and avail\_* values accordingly.  The}
00415 \textcolor{comment}{  application can consume the uncompressed output when it wants, for example}
00416 \textcolor{comment}{  when the output buffer is full (avail\_out == 0), or after each call of}
00417 \textcolor{comment}{  inflate().  If inflate returns Z\_OK and with zero avail\_out, it must be}
00418 \textcolor{comment}{  called again after making room in the output buffer because there might be}
00419 \textcolor{comment}{  more output pending.}
00420 \textcolor{comment}{}
00421 \textcolor{comment}{    The flush parameter of inflate() can be Z\_NO\_FLUSH, Z\_SYNC\_FLUSH, Z\_FINISH,}
00422 \textcolor{comment}{  Z\_BLOCK, or Z\_TREES.  Z\_SYNC\_FLUSH requests that inflate() flush as much}
00423 \textcolor{comment}{  output as possible to the output buffer.  Z\_BLOCK requests that inflate()}
00424 \textcolor{comment}{  stop if and when it gets to the next deflate block boundary.  When decoding}
00425 \textcolor{comment}{  the zlib or gzip format, this will cause inflate() to return immediately}
00426 \textcolor{comment}{  after the header and before the first block.  When doing a raw inflate,}
00427 \textcolor{comment}{  inflate() will go ahead and process the first block, and will return when it}
00428 \textcolor{comment}{  gets to the end of that block, or when it runs out of data.}
00429 \textcolor{comment}{}
00430 \textcolor{comment}{    The Z\_BLOCK option assists in appending to or combining deflate streams.}
00431 \textcolor{comment}{  Also to assist in this, on return inflate() will set strm->data\_type to the}
00432 \textcolor{comment}{  number of unused bits in the last byte taken from strm->next\_in, plus 64 if}
00433 \textcolor{comment}{  inflate() is currently decoding the last block in the deflate stream, plus}
00434 \textcolor{comment}{  128 if inflate() returned immediately after decoding an end-of-block code or}
00435 \textcolor{comment}{  decoding the complete header up to just before the first byte of the deflate}
00436 \textcolor{comment}{  stream.  The end-of-block will not be indicated until all of the uncompressed}
00437 \textcolor{comment}{  data from that block has been written to strm->next\_out.  The number of}
00438 \textcolor{comment}{  unused bits may in general be greater than seven, except when bit 7 of}
00439 \textcolor{comment}{  data\_type is set, in which case the number of unused bits will be less than}
00440 \textcolor{comment}{  eight.  data\_type is set as noted here every time inflate() returns for all}
00441 \textcolor{comment}{  flush options, and so can be used to determine the amount of currently}
00442 \textcolor{comment}{  consumed input in bits.}
00443 \textcolor{comment}{}
00444 \textcolor{comment}{    The Z\_TREES option behaves as Z\_BLOCK does, but it also returns when the}
00445 \textcolor{comment}{  end of each deflate block header is reached, before any actual data in that}
00446 \textcolor{comment}{  block is decoded.  This allows the caller to determine the length of the}
00447 \textcolor{comment}{  deflate block header for later use in random access within a deflate block.}
00448 \textcolor{comment}{  256 is added to the value of strm->data\_type when inflate() returns}
00449 \textcolor{comment}{  immediately after reaching the end of the deflate block header.}
00450 \textcolor{comment}{}
00451 \textcolor{comment}{    inflate() should normally be called until it returns Z\_STREAM\_END or an}
00452 \textcolor{comment}{  error.  However if all decompression is to be performed in a single step (a}
00453 \textcolor{comment}{  single call of inflate), the parameter flush should be set to Z\_FINISH.  In}
00454 \textcolor{comment}{  this case all pending input is processed and all pending output is flushed;}
00455 \textcolor{comment}{  avail\_out must be large enough to hold all of the uncompressed data for the}
00456 \textcolor{comment}{  operation to complete.  (The size of the uncompressed data may have been}
00457 \textcolor{comment}{  saved by the compressor for this purpose.) The use of Z\_FINISH is not}
00458 \textcolor{comment}{  required to perform an inflation in one step.  However it may be used to}
00459 \textcolor{comment}{  inform inflate that a faster approach can be used for the single inflate()}
00460 \textcolor{comment}{  call.  Z\_FINISH also informs inflate to not maintain a sliding window if the}
00461 \textcolor{comment}{  stream completes, which reduces inflate's memory footprint.  If the stream}
00462 \textcolor{comment}{  does not complete, either because not all of the stream is provided or not}
00463 \textcolor{comment}{  enough output space is provided, then a sliding window will be allocated and}
00464 \textcolor{comment}{  inflate() can be called again to continue the operation as if Z\_NO\_FLUSH had}
00465 \textcolor{comment}{  been used.}
00466 \textcolor{comment}{}
00467 \textcolor{comment}{     In this implementation, inflate() always flushes as much output as}
00468 \textcolor{comment}{  possible to the output buffer, and always uses the faster approach on the}
00469 \textcolor{comment}{  first call.  So the effects of the flush parameter in this implementation are}
00470 \textcolor{comment}{  on the return value of inflate() as noted below, when inflate() returns early}
00471 \textcolor{comment}{  when Z\_BLOCK or Z\_TREES is used, and when inflate() avoids the allocation of}
00472 \textcolor{comment}{  memory for a sliding window when Z\_FINISH is used.}
00473 \textcolor{comment}{}
00474 \textcolor{comment}{     If a preset dictionary is needed after this call (see inflateSetDictionary}
00475 \textcolor{comment}{  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary}
00476 \textcolor{comment}{  chosen by the compressor and returns Z\_NEED\_DICT; otherwise it sets}
00477 \textcolor{comment}{  strm->adler to the Adler-32 checksum of all output produced so far (that is,}
00478 \textcolor{comment}{  total\_out bytes) and returns Z\_OK, Z\_STREAM\_END or an error code as described}
00479 \textcolor{comment}{  below.  At the end of the stream, inflate() checks that its computed adler32}
00480 \textcolor{comment}{  checksum is equal to that saved by the compressor and returns Z\_STREAM\_END}
00481 \textcolor{comment}{  only if the checksum is correct.}
00482 \textcolor{comment}{}
00483 \textcolor{comment}{    inflate() can decompress and check either zlib-wrapped or gzip-wrapped}
00484 \textcolor{comment}{  deflate data.  The header type is detected automatically, if requested when}
00485 \textcolor{comment}{  initializing with inflateInit2().  Any information contained in the gzip}
00486 \textcolor{comment}{  header is not retained, so applications that need that information should}
00487 \textcolor{comment}{  instead use raw inflate, see inflateInit2() below, or inflateBack() and}
00488 \textcolor{comment}{  perform their own processing of the gzip header and trailer.  When processing}
00489 \textcolor{comment}{  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output}
00490 \textcolor{comment}{  producted so far.  The CRC-32 is checked against the gzip trailer.}
00491 \textcolor{comment}{}
00492 \textcolor{comment}{    inflate() returns Z\_OK if some progress has been made (more input processed}
00493 \textcolor{comment}{  or more output produced), Z\_STREAM\_END if the end of the compressed data has}
00494 \textcolor{comment}{  been reached and all uncompressed output has been produced, Z\_NEED\_DICT if a}
00495 \textcolor{comment}{  preset dictionary is needed at this point, Z\_DATA\_ERROR if the input data was}
00496 \textcolor{comment}{  corrupted (input stream not conforming to the zlib format or incorrect check}
00497 \textcolor{comment}{  value), Z\_STREAM\_ERROR if the stream structure was inconsistent (for example}
00498 \textcolor{comment}{  next\_in or next\_out was Z\_NULL), Z\_MEM\_ERROR if there was not enough memory,}
00499 \textcolor{comment}{  Z\_BUF\_ERROR if no progress is possible or if there was not enough room in the}
00500 \textcolor{comment}{  output buffer when Z\_FINISH is used.  Note that Z\_BUF\_ERROR is not fatal, and}
00501 \textcolor{comment}{  inflate() can be called again with more input and more output space to}
00502 \textcolor{comment}{  continue decompressing.  If Z\_DATA\_ERROR is returned, the application may}
00503 \textcolor{comment}{  then call inflateSync() to look for a good compression block if a partial}
00504 \textcolor{comment}{  recovery of the data is desired.}
00505 \textcolor{comment}{*/}
00506 
00507 
00508 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateEnd OF((z\_streamp strm));
00509 \textcolor{comment}{/*}
00510 \textcolor{comment}{     All dynamically allocated data structures for this stream are freed.}
00511 \textcolor{comment}{   This function discards any unprocessed input and does not flush any pending}
00512 \textcolor{comment}{   output.}
00513 \textcolor{comment}{}
00514 \textcolor{comment}{     inflateEnd returns Z\_OK if success, Z\_STREAM\_ERROR if the stream state}
00515 \textcolor{comment}{   was inconsistent.  In the error case, msg may be set but then points to a}
00516 \textcolor{comment}{   static string (which must not be deallocated).}
00517 \textcolor{comment}{*/}
00518 
00519 
00520                         \textcolor{comment}{/* Advanced functions */}
00521 
00522 \textcolor{comment}{/*}
00523 \textcolor{comment}{    The following functions are needed only in some special applications.}
00524 \textcolor{comment}{*/}
00525 
00526 \textcolor{comment}{/*}
00527 \textcolor{comment}{ZEXTERN int ZEXPORT deflateInit2 OF((z\_streamp strm,}
00528 \textcolor{comment}{                                     int  level,}
00529 \textcolor{comment}{                                     int  method,}
00530 \textcolor{comment}{                                     int  windowBits,}
00531 \textcolor{comment}{                                     int  memLevel,}
00532 \textcolor{comment}{                                     int  strategy));}
00533 \textcolor{comment}{}
00534 \textcolor{comment}{     This is another version of deflateInit with more compression options.  The}
00535 \textcolor{comment}{   fields next\_in, zalloc, zfree and opaque must be initialized before by the}
00536 \textcolor{comment}{   caller.}
00537 \textcolor{comment}{}
00538 \textcolor{comment}{     The method parameter is the compression method.  It must be Z\_DEFLATED in}
00539 \textcolor{comment}{   this version of the library.}
00540 \textcolor{comment}{}
00541 \textcolor{comment}{     The windowBits parameter is the base two logarithm of the window size}
00542 \textcolor{comment}{   (the size of the history buffer).  It should be in the range 8..15 for this}
00543 \textcolor{comment}{   version of the library.  Larger values of this parameter result in better}
00544 \textcolor{comment}{   compression at the expense of memory usage.  The default value is 15 if}
00545 \textcolor{comment}{   deflateInit is used instead.}
00546 \textcolor{comment}{}
00547 \textcolor{comment}{     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits}
00548 \textcolor{comment}{   determines the window size.  deflate() will then generate raw deflate data}
00549 \textcolor{comment}{   with no zlib header or trailer, and will not compute an adler32 check value.}
00550 \textcolor{comment}{}
00551 \textcolor{comment}{     windowBits can also be greater than 15 for optional gzip encoding.  Add}
00552 \textcolor{comment}{   16 to windowBits to write a simple gzip header and trailer around the}
00553 \textcolor{comment}{   compressed data instead of a zlib wrapper.  The gzip header will have no}
00554 \textcolor{comment}{   file name, no extra data, no comment, no modification time (set to zero), no}
00555 \textcolor{comment}{   header crc, and the operating system will be set to 255 (unknown).  If a}
00556 \textcolor{comment}{   gzip stream is being written, strm->adler is a crc32 instead of an adler32.}
00557 \textcolor{comment}{}
00558 \textcolor{comment}{     The memLevel parameter specifies how much memory should be allocated}
00559 \textcolor{comment}{   for the internal compression state.  memLevel=1 uses minimum memory but is}
00560 \textcolor{comment}{   slow and reduces compression ratio; memLevel=9 uses maximum memory for}
00561 \textcolor{comment}{   optimal speed.  The default value is 8.  See zconf.h for total memory usage}
00562 \textcolor{comment}{   as a function of windowBits and memLevel.}
00563 \textcolor{comment}{}
00564 \textcolor{comment}{     The strategy parameter is used to tune the compression algorithm.  Use the}
00565 \textcolor{comment}{   value Z\_DEFAULT\_STRATEGY for normal data, Z\_FILTERED for data produced by a}
00566 \textcolor{comment}{   filter (or predictor), Z\_HUFFMAN\_ONLY to force Huffman encoding only (no}
00567 \textcolor{comment}{   string match), or Z\_RLE to limit match distances to one (run-length}
00568 \textcolor{comment}{   encoding).  Filtered data consists mostly of small values with a somewhat}
00569 \textcolor{comment}{   random distribution.  In this case, the compression algorithm is tuned to}
00570 \textcolor{comment}{   compress them better.  The effect of Z\_FILTERED is to force more Huffman}
00571 \textcolor{comment}{   coding and less string matching; it is somewhat intermediate between}
00572 \textcolor{comment}{   Z\_DEFAULT\_STRATEGY and Z\_HUFFMAN\_ONLY.  Z\_RLE is designed to be almost as}
00573 \textcolor{comment}{   fast as Z\_HUFFMAN\_ONLY, but give better compression for PNG image data.  The}
00574 \textcolor{comment}{   strategy parameter only affects the compression ratio but not the}
00575 \textcolor{comment}{   correctness of the compressed output even if it is not set appropriately.}
00576 \textcolor{comment}{   Z\_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler}
00577 \textcolor{comment}{   decoder for special applications.}
00578 \textcolor{comment}{}
00579 \textcolor{comment}{     deflateInit2 returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough}
00580 \textcolor{comment}{   memory, Z\_STREAM\_ERROR if any parameter is invalid (such as an invalid}
00581 \textcolor{comment}{   method), or Z\_VERSION\_ERROR if the zlib library version (zlib\_version) is}
00582 \textcolor{comment}{   incompatible with the version assumed by the caller (ZLIB\_VERSION).  msg is}
00583 \textcolor{comment}{   set to null if there is no error message.  deflateInit2 does not perform any}
00584 \textcolor{comment}{   compression: this will be done by deflate().}
00585 \textcolor{comment}{*/}
00586 
00587 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateSetDictionary OF((z\_streamp strm,
00588                                              \textcolor{keyword}{const} Bytef *dictionary,
00589                                              uInt  dictLength));
00590 \textcolor{comment}{/*}
00591 \textcolor{comment}{     Initializes the compression dictionary from the given byte sequence}
00592 \textcolor{comment}{   without producing any compressed output.  When using the zlib format, this}
00593 \textcolor{comment}{   function must be called immediately after deflateInit, deflateInit2 or}
00594 \textcolor{comment}{   deflateReset, and before any call of deflate.  When doing raw deflate, this}
00595 \textcolor{comment}{   function must be called either before any call of deflate, or immediately}
00596 \textcolor{comment}{   after the completion of a deflate block, i.e. after all input has been}
00597 \textcolor{comment}{   consumed and all output has been delivered when using any of the flush}
00598 \textcolor{comment}{   options Z\_BLOCK, Z\_PARTIAL\_FLUSH, Z\_SYNC\_FLUSH, or Z\_FULL\_FLUSH.  The}
00599 \textcolor{comment}{   compressor and decompressor must use exactly the same dictionary (see}
00600 \textcolor{comment}{   inflateSetDictionary).}
00601 \textcolor{comment}{}
00602 \textcolor{comment}{     The dictionary should consist of strings (byte sequences) that are likely}
00603 \textcolor{comment}{   to be encountered later in the data to be compressed, with the most commonly}
00604 \textcolor{comment}{   used strings preferably put towards the end of the dictionary.  Using a}
00605 \textcolor{comment}{   dictionary is most useful when the data to be compressed is short and can be}
00606 \textcolor{comment}{   predicted with good accuracy; the data can then be compressed better than}
00607 \textcolor{comment}{   with the default empty dictionary.}
00608 \textcolor{comment}{}
00609 \textcolor{comment}{     Depending on the size of the compression data structures selected by}
00610 \textcolor{comment}{   deflateInit or deflateInit2, a part of the dictionary may in effect be}
00611 \textcolor{comment}{   discarded, for example if the dictionary is larger than the window size}
00612 \textcolor{comment}{   provided in deflateInit or deflateInit2.  Thus the strings most likely to be}
00613 \textcolor{comment}{   useful should be put at the end of the dictionary, not at the front.  In}
00614 \textcolor{comment}{   addition, the current implementation of deflate will use at most the window}
00615 \textcolor{comment}{   size minus 262 bytes of the provided dictionary.}
00616 \textcolor{comment}{}
00617 \textcolor{comment}{     Upon return of this function, strm->adler is set to the adler32 value}
00618 \textcolor{comment}{   of the dictionary; the decompressor may later use this value to determine}
00619 \textcolor{comment}{   which dictionary has been used by the compressor.  (The adler32 value}
00620 \textcolor{comment}{   applies to the whole dictionary even if only a subset of the dictionary is}
00621 \textcolor{comment}{   actually used by the compressor.) If a raw deflate was requested, then the}
00622 \textcolor{comment}{   adler32 value is not computed and strm->adler is not set.}
00623 \textcolor{comment}{}
00624 \textcolor{comment}{     deflateSetDictionary returns Z\_OK if success, or Z\_STREAM\_ERROR if a}
00625 \textcolor{comment}{   parameter is invalid (e.g.  dictionary being Z\_NULL) or the stream state is}
00626 \textcolor{comment}{   inconsistent (for example if deflate has already been called for this stream}
00627 \textcolor{comment}{   or if not at a block boundary for raw deflate).  deflateSetDictionary does}
00628 \textcolor{comment}{   not perform any compression: this will be done by deflate().}
00629 \textcolor{comment}{*/}
00630 
00631 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateCopy OF((z\_streamp dest,
00632                                     z\_streamp source));
00633 \textcolor{comment}{/*}
00634 \textcolor{comment}{     Sets the destination stream as a complete copy of the source stream.}
00635 \textcolor{comment}{}
00636 \textcolor{comment}{     This function can be useful when several compression strategies will be}
00637 \textcolor{comment}{   tried, for example when there are several ways of pre-processing the input}
00638 \textcolor{comment}{   data with a filter.  The streams that will be discarded should then be freed}
00639 \textcolor{comment}{   by calling deflateEnd.  Note that deflateCopy duplicates the internal}
00640 \textcolor{comment}{   compression state which can be quite large, so this strategy is slow and can}
00641 \textcolor{comment}{   consume lots of memory.}
00642 \textcolor{comment}{}
00643 \textcolor{comment}{     deflateCopy returns Z\_OK if success, Z\_MEM\_ERROR if there was not}
00644 \textcolor{comment}{   enough memory, Z\_STREAM\_ERROR if the source stream state was inconsistent}
00645 \textcolor{comment}{   (such as zalloc being Z\_NULL).  msg is left unchanged in both source and}
00646 \textcolor{comment}{   destination.}
00647 \textcolor{comment}{*/}
00648 
00649 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateReset OF((z\_streamp strm));
00650 \textcolor{comment}{/*}
00651 \textcolor{comment}{     This function is equivalent to deflateEnd followed by deflateInit,}
00652 \textcolor{comment}{   but does not free and reallocate all the internal compression state.  The}
00653 \textcolor{comment}{   stream will keep the same compression level and any other attributes that}
00654 \textcolor{comment}{   may have been set by deflateInit2.}
00655 \textcolor{comment}{}
00656 \textcolor{comment}{     deflateReset returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
00657 \textcolor{comment}{   stream state was inconsistent (such as zalloc or state being Z\_NULL).}
00658 \textcolor{comment}{*/}
00659 
00660 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateParams OF((z\_streamp strm,
00661                                       \textcolor{keywordtype}{int} level,
00662                                       \textcolor{keywordtype}{int} strategy));
00663 \textcolor{comment}{/*}
00664 \textcolor{comment}{     Dynamically update the compression level and compression strategy.  The}
00665 \textcolor{comment}{   interpretation of level and strategy is as in deflateInit2.  This can be}
00666 \textcolor{comment}{   used to switch between compression and straight copy of the input data, or}
00667 \textcolor{comment}{   to switch to a different kind of input data requiring a different strategy.}
00668 \textcolor{comment}{   If the compression level is changed, the input available so far is}
00669 \textcolor{comment}{   compressed with the old level (and may be flushed); the new level will take}
00670 \textcolor{comment}{   effect only at the next call of deflate().}
00671 \textcolor{comment}{}
00672 \textcolor{comment}{     Before the call of deflateParams, the stream state must be set as for}
00673 \textcolor{comment}{   a call of deflate(), since the currently available input may have to be}
00674 \textcolor{comment}{   compressed and flushed.  In particular, strm->avail\_out must be non-zero.}
00675 \textcolor{comment}{}
00676 \textcolor{comment}{     deflateParams returns Z\_OK if success, Z\_STREAM\_ERROR if the source}
00677 \textcolor{comment}{   stream state was inconsistent or if a parameter was invalid, Z\_BUF\_ERROR if}
00678 \textcolor{comment}{   strm->avail\_out was zero.}
00679 \textcolor{comment}{*/}
00680 
00681 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateTune OF((z\_streamp strm,
00682                                     \textcolor{keywordtype}{int} good\_length,
00683                                     \textcolor{keywordtype}{int} max\_lazy,
00684                                     \textcolor{keywordtype}{int} nice\_length,
00685                                     \textcolor{keywordtype}{int} max\_chain));
00686 \textcolor{comment}{/*}
00687 \textcolor{comment}{     Fine tune deflate's internal compression parameters.  This should only be}
00688 \textcolor{comment}{   used by someone who understands the algorithm used by zlib's deflate for}
00689 \textcolor{comment}{   searching for the best matching string, and even then only by the most}
00690 \textcolor{comment}{   fanatic optimizer trying to squeeze out the last compressed bit for their}
00691 \textcolor{comment}{   specific input data.  Read the deflate.c source code for the meaning of the}
00692 \textcolor{comment}{   max\_lazy, good\_length, nice\_length, and max\_chain parameters.}
00693 \textcolor{comment}{}
00694 \textcolor{comment}{     deflateTune() can be called after deflateInit() or deflateInit2(), and}
00695 \textcolor{comment}{   returns Z\_OK on success, or Z\_STREAM\_ERROR for an invalid deflate stream.}
00696 \textcolor{comment}{ */}
00697 
00698 ZEXTERN uLong ZEXPORT deflateBound OF((z\_streamp strm,
00699                                        uLong sourceLen));
00700 \textcolor{comment}{/*}
00701 \textcolor{comment}{     deflateBound() returns an upper bound on the compressed size after}
00702 \textcolor{comment}{   deflation of sourceLen bytes.  It must be called after deflateInit() or}
00703 \textcolor{comment}{   deflateInit2(), and after deflateSetHeader(), if used.  This would be used}
00704 \textcolor{comment}{   to allocate an output buffer for deflation in a single pass, and so would be}
00705 \textcolor{comment}{   called before deflate().  If that first deflate() call is provided the}
00706 \textcolor{comment}{   sourceLen input bytes, an output buffer allocated to the size returned by}
00707 \textcolor{comment}{   deflateBound(), and the flush value Z\_FINISH, then deflate() is guaranteed}
00708 \textcolor{comment}{   to return Z\_STREAM\_END.  Note that it is possible for the compressed size to}
00709 \textcolor{comment}{   be larger than the value returned by deflateBound() if flush options other}
00710 \textcolor{comment}{   than Z\_FINISH or Z\_NO\_FLUSH are used.}
00711 \textcolor{comment}{*/}
00712 
00713 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflatePending OF((z\_streamp strm,
00714                                        \textcolor{keywordtype}{unsigned} *pending,
00715                                        \textcolor{keywordtype}{int} *bits));
00716 \textcolor{comment}{/*}
00717 \textcolor{comment}{     deflatePending() returns the number of bytes and bits of output that have}
00718 \textcolor{comment}{   been generated, but not yet provided in the available output.  The bytes not}
00719 \textcolor{comment}{   provided would be due to the available output space having being consumed.}
00720 \textcolor{comment}{   The number of bits of output not provided are between 0 and 7, where they}
00721 \textcolor{comment}{   await more bits to join them in order to fill out a full byte.  If pending}
00722 \textcolor{comment}{   or bits are Z\_NULL, then those values are not set.}
00723 \textcolor{comment}{}
00724 \textcolor{comment}{     deflatePending returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
00725 \textcolor{comment}{   stream state was inconsistent.}
00726 \textcolor{comment}{ */}
00727 
00728 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflatePrime OF((z\_streamp strm,
00729                                      \textcolor{keywordtype}{int} bits,
00730                                      \textcolor{keywordtype}{int} value));
00731 \textcolor{comment}{/*}
00732 \textcolor{comment}{     deflatePrime() inserts bits in the deflate output stream.  The intent}
00733 \textcolor{comment}{   is that this function is used to start off the deflate output with the bits}
00734 \textcolor{comment}{   leftover from a previous deflate stream when appending to it.  As such, this}
00735 \textcolor{comment}{   function can only be used for raw deflate, and must be used before the first}
00736 \textcolor{comment}{   deflate() call after a deflateInit2() or deflateReset().  bits must be less}
00737 \textcolor{comment}{   than or equal to 16, and that many of the least significant bits of value}
00738 \textcolor{comment}{   will be inserted in the output.}
00739 \textcolor{comment}{}
00740 \textcolor{comment}{     deflatePrime returns Z\_OK if success, Z\_BUF\_ERROR if there was not enough}
00741 \textcolor{comment}{   room in the internal buffer to insert the bits, or Z\_STREAM\_ERROR if the}
00742 \textcolor{comment}{   source stream state was inconsistent.}
00743 \textcolor{comment}{*/}
00744 
00745 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateSetHeader OF((z\_streamp strm,
00746                                          gz\_headerp head));
00747 \textcolor{comment}{/*}
00748 \textcolor{comment}{     deflateSetHeader() provides gzip header information for when a gzip}
00749 \textcolor{comment}{   stream is requested by deflateInit2().  deflateSetHeader() may be called}
00750 \textcolor{comment}{   after deflateInit2() or deflateReset() and before the first call of}
00751 \textcolor{comment}{   deflate().  The text, time, os, extra field, name, and comment information}
00752 \textcolor{comment}{   in the provided gz\_header structure are written to the gzip header (xflag is}
00753 \textcolor{comment}{   ignored -- the extra flags are set according to the compression level).  The}
00754 \textcolor{comment}{   caller must assure that, if not Z\_NULL, name and comment are terminated with}
00755 \textcolor{comment}{   a zero byte, and that if extra is not Z\_NULL, that extra\_len bytes are}
00756 \textcolor{comment}{   available there.  If hcrc is true, a gzip header crc is included.  Note that}
00757 \textcolor{comment}{   the current versions of the command-line version of gzip (up through version}
00758 \textcolor{comment}{   1.3.x) do not support header crc's, and will report that it is a "multi-part}
00759 \textcolor{comment}{   gzip file" and give up.}
00760 \textcolor{comment}{}
00761 \textcolor{comment}{     If deflateSetHeader is not used, the default gzip header has text false,}
00762 \textcolor{comment}{   the time set to zero, and os set to 255, with no extra, name, or comment}
00763 \textcolor{comment}{   fields.  The gzip header is returned to the default state by deflateReset().}
00764 \textcolor{comment}{}
00765 \textcolor{comment}{     deflateSetHeader returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
00766 \textcolor{comment}{   stream state was inconsistent.}
00767 \textcolor{comment}{*/}
00768 
00769 \textcolor{comment}{/*}
00770 \textcolor{comment}{ZEXTERN int ZEXPORT inflateInit2 OF((z\_streamp strm,}
00771 \textcolor{comment}{                                     int  windowBits));}
00772 \textcolor{comment}{}
00773 \textcolor{comment}{     This is another version of inflateInit with an extra parameter.  The}
00774 \textcolor{comment}{   fields next\_in, avail\_in, zalloc, zfree and opaque must be initialized}
00775 \textcolor{comment}{   before by the caller.}
00776 \textcolor{comment}{}
00777 \textcolor{comment}{     The windowBits parameter is the base two logarithm of the maximum window}
00778 \textcolor{comment}{   size (the size of the history buffer).  It should be in the range 8..15 for}
00779 \textcolor{comment}{   this version of the library.  The default value is 15 if inflateInit is used}
00780 \textcolor{comment}{   instead.  windowBits must be greater than or equal to the windowBits value}
00781 \textcolor{comment}{   provided to deflateInit2() while compressing, or it must be equal to 15 if}
00782 \textcolor{comment}{   deflateInit2() was not used.  If a compressed stream with a larger window}
00783 \textcolor{comment}{   size is given as input, inflate() will return with the error code}
00784 \textcolor{comment}{   Z\_DATA\_ERROR instead of trying to allocate a larger window.}
00785 \textcolor{comment}{}
00786 \textcolor{comment}{     windowBits can also be zero to request that inflate use the window size in}
00787 \textcolor{comment}{   the zlib header of the compressed stream.}
00788 \textcolor{comment}{}
00789 \textcolor{comment}{     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits}
00790 \textcolor{comment}{   determines the window size.  inflate() will then process raw deflate data,}
00791 \textcolor{comment}{   not looking for a zlib or gzip header, not generating a check value, and not}
00792 \textcolor{comment}{   looking for any check values for comparison at the end of the stream.  This}
00793 \textcolor{comment}{   is for use with other formats that use the deflate compressed data format}
00794 \textcolor{comment}{   such as zip.  Those formats provide their own check values.  If a custom}
00795 \textcolor{comment}{   format is developed using the raw deflate format for compressed data, it is}
00796 \textcolor{comment}{   recommended that a check value such as an adler32 or a crc32 be applied to}
00797 \textcolor{comment}{   the uncompressed data as is done in the zlib, gzip, and zip formats.  For}
00798 \textcolor{comment}{   most applications, the zlib format should be used as is.  Note that comments}
00799 \textcolor{comment}{   above on the use in deflateInit2() applies to the magnitude of windowBits.}
00800 \textcolor{comment}{}
00801 \textcolor{comment}{     windowBits can also be greater than 15 for optional gzip decoding.  Add}
00802 \textcolor{comment}{   32 to windowBits to enable zlib and gzip decoding with automatic header}
00803 \textcolor{comment}{   detection, or add 16 to decode only the gzip format (the zlib format will}
00804 \textcolor{comment}{   return a Z\_DATA\_ERROR).  If a gzip stream is being decoded, strm->adler is a}
00805 \textcolor{comment}{   crc32 instead of an adler32.}
00806 \textcolor{comment}{}
00807 \textcolor{comment}{     inflateInit2 returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough}
00808 \textcolor{comment}{   memory, Z\_VERSION\_ERROR if the zlib library version is incompatible with the}
00809 \textcolor{comment}{   version assumed by the caller, or Z\_STREAM\_ERROR if the parameters are}
00810 \textcolor{comment}{   invalid, such as a null pointer to the structure.  msg is set to null if}
00811 \textcolor{comment}{   there is no error message.  inflateInit2 does not perform any decompression}
00812 \textcolor{comment}{   apart from possibly reading the zlib header if present: actual decompression}
00813 \textcolor{comment}{   will be done by inflate().  (So next\_in and avail\_in may be modified, but}
00814 \textcolor{comment}{   next\_out and avail\_out are unused and unchanged.) The current implementation}
00815 \textcolor{comment}{   of inflateInit2() does not process any header information -- that is}
00816 \textcolor{comment}{   deferred until inflate() is called.}
00817 \textcolor{comment}{*/}
00818 
00819 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateSetDictionary OF((z\_streamp strm,
00820                                              \textcolor{keyword}{const} Bytef *dictionary,
00821                                              uInt  dictLength));
00822 \textcolor{comment}{/*}
00823 \textcolor{comment}{     Initializes the decompression dictionary from the given uncompressed byte}
00824 \textcolor{comment}{   sequence.  This function must be called immediately after a call of inflate,}
00825 \textcolor{comment}{   if that call returned Z\_NEED\_DICT.  The dictionary chosen by the compressor}
00826 \textcolor{comment}{   can be determined from the adler32 value returned by that call of inflate.}
00827 \textcolor{comment}{   The compressor and decompressor must use exactly the same dictionary (see}
00828 \textcolor{comment}{   deflateSetDictionary).  For raw inflate, this function can be called at any}
00829 \textcolor{comment}{   time to set the dictionary.  If the provided dictionary is smaller than the}
00830 \textcolor{comment}{   window and there is already data in the window, then the provided dictionary}
00831 \textcolor{comment}{   will amend what's there.  The application must insure that the dictionary}
00832 \textcolor{comment}{   that was used for compression is provided.}
00833 \textcolor{comment}{}
00834 \textcolor{comment}{     inflateSetDictionary returns Z\_OK if success, Z\_STREAM\_ERROR if a}
00835 \textcolor{comment}{   parameter is invalid (e.g.  dictionary being Z\_NULL) or the stream state is}
00836 \textcolor{comment}{   inconsistent, Z\_DATA\_ERROR if the given dictionary doesn't match the}
00837 \textcolor{comment}{   expected one (incorrect adler32 value).  inflateSetDictionary does not}
00838 \textcolor{comment}{   perform any decompression: this will be done by subsequent calls of}
00839 \textcolor{comment}{   inflate().}
00840 \textcolor{comment}{*/}
00841 
00842 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateGetDictionary OF((z\_streamp strm,
00843                                              Bytef *dictionary,
00844                                              uInt  *dictLength));
00845 \textcolor{comment}{/*}
00846 \textcolor{comment}{     Returns the sliding dictionary being maintained by inflate.  dictLength is}
00847 \textcolor{comment}{   set to the number of bytes in the dictionary, and that many bytes are copied}
00848 \textcolor{comment}{   to dictionary.  dictionary must have enough space, where 32768 bytes is}
00849 \textcolor{comment}{   always enough.  If inflateGetDictionary() is called with dictionary equal to}
00850 \textcolor{comment}{   Z\_NULL, then only the dictionary length is returned, and nothing is copied.}
00851 \textcolor{comment}{   Similary, if dictLength is Z\_NULL, then it is not set.}
00852 \textcolor{comment}{}
00853 \textcolor{comment}{     inflateGetDictionary returns Z\_OK on success, or Z\_STREAM\_ERROR if the}
00854 \textcolor{comment}{   stream state is inconsistent.}
00855 \textcolor{comment}{*/}
00856 
00857 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateSync OF((z\_streamp strm));
00858 \textcolor{comment}{/*}
00859 \textcolor{comment}{     Skips invalid compressed data until a possible full flush point (see above}
00860 \textcolor{comment}{   for the description of deflate with Z\_FULL\_FLUSH) can be found, or until all}
00861 \textcolor{comment}{   available input is skipped.  No output is provided.}
00862 \textcolor{comment}{}
00863 \textcolor{comment}{     inflateSync searches for a 00 00 FF FF pattern in the compressed data.}
00864 \textcolor{comment}{   All full flush points have this pattern, but not all occurrences of this}
00865 \textcolor{comment}{   pattern are full flush points.}
00866 \textcolor{comment}{}
00867 \textcolor{comment}{     inflateSync returns Z\_OK if a possible full flush point has been found,}
00868 \textcolor{comment}{   Z\_BUF\_ERROR if no more input was provided, Z\_DATA\_ERROR if no flush point}
00869 \textcolor{comment}{   has been found, or Z\_STREAM\_ERROR if the stream structure was inconsistent.}
00870 \textcolor{comment}{   In the success case, the application may save the current current value of}
00871 \textcolor{comment}{   total\_in which indicates where valid compressed data was found.  In the}
00872 \textcolor{comment}{   error case, the application may repeatedly call inflateSync, providing more}
00873 \textcolor{comment}{   input each time, until success or end of the input data.}
00874 \textcolor{comment}{*/}
00875 
00876 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateCopy OF((z\_streamp dest,
00877                                     z\_streamp source));
00878 \textcolor{comment}{/*}
00879 \textcolor{comment}{     Sets the destination stream as a complete copy of the source stream.}
00880 \textcolor{comment}{}
00881 \textcolor{comment}{     This function can be useful when randomly accessing a large stream.  The}
00882 \textcolor{comment}{   first pass through the stream can periodically record the inflate state,}
00883 \textcolor{comment}{   allowing restarting inflate at those points when randomly accessing the}
00884 \textcolor{comment}{   stream.}
00885 \textcolor{comment}{}
00886 \textcolor{comment}{     inflateCopy returns Z\_OK if success, Z\_MEM\_ERROR if there was not}
00887 \textcolor{comment}{   enough memory, Z\_STREAM\_ERROR if the source stream state was inconsistent}
00888 \textcolor{comment}{   (such as zalloc being Z\_NULL).  msg is left unchanged in both source and}
00889 \textcolor{comment}{   destination.}
00890 \textcolor{comment}{*/}
00891 
00892 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateReset OF((z\_streamp strm));
00893 \textcolor{comment}{/*}
00894 \textcolor{comment}{     This function is equivalent to inflateEnd followed by inflateInit,}
00895 \textcolor{comment}{   but does not free and reallocate all the internal decompression state.  The}
00896 \textcolor{comment}{   stream will keep attributes that may have been set by inflateInit2.}
00897 \textcolor{comment}{}
00898 \textcolor{comment}{     inflateReset returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
00899 \textcolor{comment}{   stream state was inconsistent (such as zalloc or state being Z\_NULL).}
00900 \textcolor{comment}{*/}
00901 
00902 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateReset2 OF((z\_streamp strm,
00903                                       \textcolor{keywordtype}{int} windowBits));
00904 \textcolor{comment}{/*}
00905 \textcolor{comment}{     This function is the same as inflateReset, but it also permits changing}
00906 \textcolor{comment}{   the wrap and window size requests.  The windowBits parameter is interpreted}
00907 \textcolor{comment}{   the same as it is for inflateInit2.}
00908 \textcolor{comment}{}
00909 \textcolor{comment}{     inflateReset2 returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
00910 \textcolor{comment}{   stream state was inconsistent (such as zalloc or state being Z\_NULL), or if}
00911 \textcolor{comment}{   the windowBits parameter is invalid.}
00912 \textcolor{comment}{*/}
00913 
00914 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflatePrime OF((z\_streamp strm,
00915                                      \textcolor{keywordtype}{int} bits,
00916                                      \textcolor{keywordtype}{int} value));
00917 \textcolor{comment}{/*}
00918 \textcolor{comment}{     This function inserts bits in the inflate input stream.  The intent is}
00919 \textcolor{comment}{   that this function is used to start inflating at a bit position in the}
00920 \textcolor{comment}{   middle of a byte.  The provided bits will be used before any bytes are used}
00921 \textcolor{comment}{   from next\_in.  This function should only be used with raw inflate, and}
00922 \textcolor{comment}{   should be used before the first inflate() call after inflateInit2() or}
00923 \textcolor{comment}{   inflateReset().  bits must be less than or equal to 16, and that many of the}
00924 \textcolor{comment}{   least significant bits of value will be inserted in the input.}
00925 \textcolor{comment}{}
00926 \textcolor{comment}{     If bits is negative, then the input stream bit buffer is emptied.  Then}
00927 \textcolor{comment}{   inflatePrime() can be called again to put bits in the buffer.  This is used}
00928 \textcolor{comment}{   to clear out bits leftover after feeding inflate a block description prior}
00929 \textcolor{comment}{   to feeding inflate codes.}
00930 \textcolor{comment}{}
00931 \textcolor{comment}{     inflatePrime returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
00932 \textcolor{comment}{   stream state was inconsistent.}
00933 \textcolor{comment}{*/}
00934 
00935 ZEXTERN \textcolor{keywordtype}{long} ZEXPORT inflateMark OF((z\_streamp strm));
00936 \textcolor{comment}{/*}
00937 \textcolor{comment}{     This function returns two values, one in the lower 16 bits of the return}
00938 \textcolor{comment}{   value, and the other in the remaining upper bits, obtained by shifting the}
00939 \textcolor{comment}{   return value down 16 bits.  If the upper value is -1 and the lower value is}
00940 \textcolor{comment}{   zero, then inflate() is currently decoding information outside of a block.}
00941 \textcolor{comment}{   If the upper value is -1 and the lower value is non-zero, then inflate is in}
00942 \textcolor{comment}{   the middle of a stored block, with the lower value equaling the number of}
00943 \textcolor{comment}{   bytes from the input remaining to copy.  If the upper value is not -1, then}
00944 \textcolor{comment}{   it is the number of bits back from the current bit position in the input of}
00945 \textcolor{comment}{   the code (literal or length/distance pair) currently being processed.  In}
00946 \textcolor{comment}{   that case the lower value is the number of bytes already emitted for that}
00947 \textcolor{comment}{   code.}
00948 \textcolor{comment}{}
00949 \textcolor{comment}{     A code is being processed if inflate is waiting for more input to complete}
00950 \textcolor{comment}{   decoding of the code, or if it has completed decoding but is waiting for}
00951 \textcolor{comment}{   more output space to write the literal or match data.}
00952 \textcolor{comment}{}
00953 \textcolor{comment}{     inflateMark() is used to mark locations in the input data for random}
00954 \textcolor{comment}{   access, which may be at bit positions, and to note those cases where the}
00955 \textcolor{comment}{   output of a code may span boundaries of random access blocks.  The current}
00956 \textcolor{comment}{   location in the input stream can be determined from avail\_in and data\_type}
00957 \textcolor{comment}{   as noted in the description for the Z\_BLOCK flush parameter for inflate.}
00958 \textcolor{comment}{}
00959 \textcolor{comment}{     inflateMark returns the value noted above or -1 << 16 if the provided}
00960 \textcolor{comment}{   source stream state was inconsistent.}
00961 \textcolor{comment}{*/}
00962 
00963 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateGetHeader OF((z\_streamp strm,
00964                                          gz\_headerp head));
00965 \textcolor{comment}{/*}
00966 \textcolor{comment}{     inflateGetHeader() requests that gzip header information be stored in the}
00967 \textcolor{comment}{   provided gz\_header structure.  inflateGetHeader() may be called after}
00968 \textcolor{comment}{   inflateInit2() or inflateReset(), and before the first call of inflate().}
00969 \textcolor{comment}{   As inflate() processes the gzip stream, head->done is zero until the header}
00970 \textcolor{comment}{   is completed, at which time head->done is set to one.  If a zlib stream is}
00971 \textcolor{comment}{   being decoded, then head->done is set to -1 to indicate that there will be}
00972 \textcolor{comment}{   no gzip header information forthcoming.  Note that Z\_BLOCK or Z\_TREES can be}
00973 \textcolor{comment}{   used to force inflate() to return immediately after header processing is}
00974 \textcolor{comment}{   complete and before any actual data is decompressed.}
00975 \textcolor{comment}{}
00976 \textcolor{comment}{     The text, time, xflags, and os fields are filled in with the gzip header}
00977 \textcolor{comment}{   contents.  hcrc is set to true if there is a header CRC.  (The header CRC}
00978 \textcolor{comment}{   was valid if done is set to one.) If extra is not Z\_NULL, then extra\_max}
00979 \textcolor{comment}{   contains the maximum number of bytes to write to extra.  Once done is true,}
00980 \textcolor{comment}{   extra\_len contains the actual extra field length, and extra contains the}
00981 \textcolor{comment}{   extra field, or that field truncated if extra\_max is less than extra\_len.}
00982 \textcolor{comment}{   If name is not Z\_NULL, then up to name\_max characters are written there,}
00983 \textcolor{comment}{   terminated with a zero unless the length is greater than name\_max.  If}
00984 \textcolor{comment}{   comment is not Z\_NULL, then up to comm\_max characters are written there,}
00985 \textcolor{comment}{   terminated with a zero unless the length is greater than comm\_max.  When any}
00986 \textcolor{comment}{   of extra, name, or comment are not Z\_NULL and the respective field is not}
00987 \textcolor{comment}{   present in the header, then that field is set to Z\_NULL to signal its}
00988 \textcolor{comment}{   absence.  This allows the use of deflateSetHeader() with the returned}
00989 \textcolor{comment}{   structure to duplicate the header.  However if those fields are set to}
00990 \textcolor{comment}{   allocated memory, then the application will need to save those pointers}
00991 \textcolor{comment}{   elsewhere so that they can be eventually freed.}
00992 \textcolor{comment}{}
00993 \textcolor{comment}{     If inflateGetHeader is not used, then the header information is simply}
00994 \textcolor{comment}{   discarded.  The header is always checked for validity, including the header}
00995 \textcolor{comment}{   CRC if present.  inflateReset() will reset the process to discard the header}
00996 \textcolor{comment}{   information.  The application would need to call inflateGetHeader() again to}
00997 \textcolor{comment}{   retrieve the header from the next gzip stream.}
00998 \textcolor{comment}{}
00999 \textcolor{comment}{     inflateGetHeader returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
01000 \textcolor{comment}{   stream state was inconsistent.}
01001 \textcolor{comment}{*/}
01002 
01003 \textcolor{comment}{/*}
01004 \textcolor{comment}{ZEXTERN int ZEXPORT inflateBackInit OF((z\_streamp strm, int windowBits,}
01005 \textcolor{comment}{                                        unsigned char FAR *window));}
01006 \textcolor{comment}{}
01007 \textcolor{comment}{     Initialize the internal stream state for decompression using inflateBack()}
01008 \textcolor{comment}{   calls.  The fields zalloc, zfree and opaque in strm must be initialized}
01009 \textcolor{comment}{   before the call.  If zalloc and zfree are Z\_NULL, then the default library-}
01010 \textcolor{comment}{   derived memory allocation routines are used.  windowBits is the base two}
01011 \textcolor{comment}{   logarithm of the window size, in the range 8..15.  window is a caller}
01012 \textcolor{comment}{   supplied buffer of that size.  Except for special applications where it is}
01013 \textcolor{comment}{   assured that deflate was used with small window sizes, windowBits must be 15}
01014 \textcolor{comment}{   and a 32K byte window must be supplied to be able to decompress general}
01015 \textcolor{comment}{   deflate streams.}
01016 \textcolor{comment}{}
01017 \textcolor{comment}{     See inflateBack() for the usage of these routines.}
01018 \textcolor{comment}{}
01019 \textcolor{comment}{     inflateBackInit will return Z\_OK on success, Z\_STREAM\_ERROR if any of}
01020 \textcolor{comment}{   the parameters are invalid, Z\_MEM\_ERROR if the internal state could not be}
01021 \textcolor{comment}{   allocated, or Z\_VERSION\_ERROR if the version of the library does not match}
01022 \textcolor{comment}{   the version of the header file.}
01023 \textcolor{comment}{*/}
01024 
01025 \textcolor{keyword}{typedef} unsigned (*in\_func) OF((\textcolor{keywordtype}{void} FAR *,
01026                                 z\_const \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR * FAR *));
01027 \textcolor{keyword}{typedef} int (*out\_func) OF((\textcolor{keywordtype}{void} FAR *, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *, \textcolor{keywordtype}{unsigned}));
01028 
01029 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateBack OF((z\_streamp strm,
01030                                     in\_func in, \textcolor{keywordtype}{void} FAR *in\_desc,
01031                                     out\_func out, \textcolor{keywordtype}{void} FAR *out\_desc));
01032 \textcolor{comment}{/*}
01033 \textcolor{comment}{     inflateBack() does a raw inflate with a single call using a call-back}
01034 \textcolor{comment}{   interface for input and output.  This is potentially more efficient than}
01035 \textcolor{comment}{   inflate() for file i/o applications, in that it avoids copying between the}
01036 \textcolor{comment}{   output and the sliding window by simply making the window itself the output}
01037 \textcolor{comment}{   buffer.  inflate() can be faster on modern CPUs when used with large}
01038 \textcolor{comment}{   buffers.  inflateBack() trusts the application to not change the output}
01039 \textcolor{comment}{   buffer passed by the output function, at least until inflateBack() returns.}
01040 \textcolor{comment}{}
01041 \textcolor{comment}{     inflateBackInit() must be called first to allocate the internal state}
01042 \textcolor{comment}{   and to initialize the state with the user-provided window buffer.}
01043 \textcolor{comment}{   inflateBack() may then be used multiple times to inflate a complete, raw}
01044 \textcolor{comment}{   deflate stream with each call.  inflateBackEnd() is then called to free the}
01045 \textcolor{comment}{   allocated state.}
01046 \textcolor{comment}{}
01047 \textcolor{comment}{     A raw deflate stream is one with no zlib or gzip header or trailer.}
01048 \textcolor{comment}{   This routine would normally be used in a utility that reads zip or gzip}
01049 \textcolor{comment}{   files and writes out uncompressed files.  The utility would decode the}
01050 \textcolor{comment}{   header and process the trailer on its own, hence this routine expects only}
01051 \textcolor{comment}{   the raw deflate stream to decompress.  This is different from the normal}
01052 \textcolor{comment}{   behavior of inflate(), which expects either a zlib or gzip header and}
01053 \textcolor{comment}{   trailer around the deflate stream.}
01054 \textcolor{comment}{}
01055 \textcolor{comment}{     inflateBack() uses two subroutines supplied by the caller that are then}
01056 \textcolor{comment}{   called by inflateBack() for input and output.  inflateBack() calls those}
01057 \textcolor{comment}{   routines until it reads a complete deflate stream and writes out all of the}
01058 \textcolor{comment}{   uncompressed data, or until it encounters an error.  The function's}
01059 \textcolor{comment}{   parameters and return types are defined above in the in\_func and out\_func}
01060 \textcolor{comment}{   typedefs.  inflateBack() will call in(in\_desc, &buf) which should return the}
01061 \textcolor{comment}{   number of bytes of provided input, and a pointer to that input in buf.  If}
01062 \textcolor{comment}{   there is no input available, in() must return zero--buf is ignored in that}
01063 \textcolor{comment}{   case--and inflateBack() will return a buffer error.  inflateBack() will call}
01064 \textcolor{comment}{   out(out\_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()}
01065 \textcolor{comment}{   should return zero on success, or non-zero on failure.  If out() returns}
01066 \textcolor{comment}{   non-zero, inflateBack() will return with an error.  Neither in() nor out()}
01067 \textcolor{comment}{   are permitted to change the contents of the window provided to}
01068 \textcolor{comment}{   inflateBackInit(), which is also the buffer that out() uses to write from.}
01069 \textcolor{comment}{   The length written by out() will be at most the window size.  Any non-zero}
01070 \textcolor{comment}{   amount of input may be provided by in().}
01071 \textcolor{comment}{}
01072 \textcolor{comment}{     For convenience, inflateBack() can be provided input on the first call by}
01073 \textcolor{comment}{   setting strm->next\_in and strm->avail\_in.  If that input is exhausted, then}
01074 \textcolor{comment}{   in() will be called.  Therefore strm->next\_in must be initialized before}
01075 \textcolor{comment}{   calling inflateBack().  If strm->next\_in is Z\_NULL, then in() will be called}
01076 \textcolor{comment}{   immediately for input.  If strm->next\_in is not Z\_NULL, then strm->avail\_in}
01077 \textcolor{comment}{   must also be initialized, and then if strm->avail\_in is not zero, input will}
01078 \textcolor{comment}{   initially be taken from strm->next\_in[0 ..  strm->avail\_in - 1].}
01079 \textcolor{comment}{}
01080 \textcolor{comment}{     The in\_desc and out\_desc parameters of inflateBack() is passed as the}
01081 \textcolor{comment}{   first parameter of in() and out() respectively when they are called.  These}
01082 \textcolor{comment}{   descriptors can be optionally used to pass any information that the caller-}
01083 \textcolor{comment}{   supplied in() and out() functions need to do their job.}
01084 \textcolor{comment}{}
01085 \textcolor{comment}{     On return, inflateBack() will set strm->next\_in and strm->avail\_in to}
01086 \textcolor{comment}{   pass back any unused input that was provided by the last in() call.  The}
01087 \textcolor{comment}{   return values of inflateBack() can be Z\_STREAM\_END on success, Z\_BUF\_ERROR}
01088 \textcolor{comment}{   if in() or out() returned an error, Z\_DATA\_ERROR if there was a format error}
01089 \textcolor{comment}{   in the deflate stream (in which case strm->msg is set to indicate the nature}
01090 \textcolor{comment}{   of the error), or Z\_STREAM\_ERROR if the stream was not properly initialized.}
01091 \textcolor{comment}{   In the case of Z\_BUF\_ERROR, an input or output error can be distinguished}
01092 \textcolor{comment}{   using strm->next\_in which will be Z\_NULL only if in() returned an error.  If}
01093 \textcolor{comment}{   strm->next\_in is not Z\_NULL, then the Z\_BUF\_ERROR was due to out() returning}
01094 \textcolor{comment}{   non-zero.  (in() will always be called before out(), so strm->next\_in is}
01095 \textcolor{comment}{   assured to be defined if out() returns non-zero.) Note that inflateBack()}
01096 \textcolor{comment}{   cannot return Z\_OK.}
01097 \textcolor{comment}{*/}
01098 
01099 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateBackEnd OF((z\_streamp strm));
01100 \textcolor{comment}{/*}
01101 \textcolor{comment}{     All memory allocated by inflateBackInit() is freed.}
01102 \textcolor{comment}{}
01103 \textcolor{comment}{     inflateBackEnd() returns Z\_OK on success, or Z\_STREAM\_ERROR if the stream}
01104 \textcolor{comment}{   state was inconsistent.}
01105 \textcolor{comment}{*/}
01106 
01107 ZEXTERN uLong ZEXPORT zlibCompileFlags OF((\textcolor{keywordtype}{void}));
01108 \textcolor{comment}{/* Return flags indicating compile-time options.}
01109 \textcolor{comment}{}
01110 \textcolor{comment}{    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:}
01111 \textcolor{comment}{     1.0: size of uInt}
01112 \textcolor{comment}{     3.2: size of uLong}
01113 \textcolor{comment}{     5.4: size of voidpf (pointer)}
01114 \textcolor{comment}{     7.6: size of z\_off\_t}
01115 \textcolor{comment}{}
01116 \textcolor{comment}{    Compiler, assembler, and debug options:}
01117 \textcolor{comment}{     8: DEBUG}
01118 \textcolor{comment}{     9: ASMV or ASMINF -- use ASM code}
01119 \textcolor{comment}{     10: ZLIB\_WINAPI -- exported functions use the WINAPI calling convention}
01120 \textcolor{comment}{     11: 0 (reserved)}
01121 \textcolor{comment}{}
01122 \textcolor{comment}{    One-time table building (smaller code, but not thread-safe if true):}
01123 \textcolor{comment}{     12: BUILDFIXED -- build static block decoding tables when needed}
01124 \textcolor{comment}{     13: DYNAMIC\_CRC\_TABLE -- build CRC calculation tables when needed}
01125 \textcolor{comment}{     14,15: 0 (reserved)}
01126 \textcolor{comment}{}
01127 \textcolor{comment}{    Library content (indicates missing functionality):}
01128 \textcolor{comment}{     16: NO\_GZCOMPRESS -- gz* functions cannot compress (to avoid linking}
01129 \textcolor{comment}{                          deflate code when not needed)}
01130 \textcolor{comment}{     17: NO\_GZIP -- deflate can't write gzip streams, and inflate can't detect}
01131 \textcolor{comment}{                    and decode gzip streams (to avoid linking crc code)}
01132 \textcolor{comment}{     18-19: 0 (reserved)}
01133 \textcolor{comment}{}
01134 \textcolor{comment}{    Operation variations (changes in library functionality):}
01135 \textcolor{comment}{     20: PKZIP\_BUG\_WORKAROUND -- slightly more permissive inflate}
01136 \textcolor{comment}{     21: FASTEST -- deflate algorithm with only one, lowest compression level}
01137 \textcolor{comment}{     22,23: 0 (reserved)}
01138 \textcolor{comment}{}
01139 \textcolor{comment}{    The sprintf variant used by gzprintf (zero is best):}
01140 \textcolor{comment}{     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format}
01141 \textcolor{comment}{     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!}
01142 \textcolor{comment}{     26: 0 = returns value, 1 = void -- 1 means inferred string length returned}
01143 \textcolor{comment}{}
01144 \textcolor{comment}{    Remainder:}
01145 \textcolor{comment}{     27-31: 0 (reserved)}
01146 \textcolor{comment}{ */}
01147 
01148 \textcolor{preprocessor}{#ifndef Z\_SOLO}
01149 
01150                         \textcolor{comment}{/* utility functions */}
01151 
01152 \textcolor{comment}{/*}
01153 \textcolor{comment}{     The following utility functions are implemented on top of the basic}
01154 \textcolor{comment}{   stream-oriented functions.  To simplify the interface, some default options}
01155 \textcolor{comment}{   are assumed (compression level and memory usage, standard memory allocation}
01156 \textcolor{comment}{   functions).  The source code of these utility functions can be modified if}
01157 \textcolor{comment}{   you need special options.}
01158 \textcolor{comment}{*/}
01159 
01160 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
01161                                  \textcolor{keyword}{const} Bytef *source, uLong sourceLen));
01162 \textcolor{comment}{/*}
01163 \textcolor{comment}{     Compresses the source buffer into the destination buffer.  sourceLen is}
01164 \textcolor{comment}{   the byte length of the source buffer.  Upon entry, destLen is the total size}
01165 \textcolor{comment}{   of the destination buffer, which must be at least the value returned by}
01166 \textcolor{comment}{   compressBound(sourceLen).  Upon exit, destLen is the actual size of the}
01167 \textcolor{comment}{   compressed buffer.}
01168 \textcolor{comment}{}
01169 \textcolor{comment}{     compress returns Z\_OK if success, Z\_MEM\_ERROR if there was not}
01170 \textcolor{comment}{   enough memory, Z\_BUF\_ERROR if there was not enough room in the output}
01171 \textcolor{comment}{   buffer.}
01172 \textcolor{comment}{*/}
01173 
01174 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
01175                                   \textcolor{keyword}{const} Bytef *source, uLong sourceLen,
01176                                   \textcolor{keywordtype}{int} level));
01177 \textcolor{comment}{/*}
01178 \textcolor{comment}{     Compresses the source buffer into the destination buffer.  The level}
01179 \textcolor{comment}{   parameter has the same meaning as in deflateInit.  sourceLen is the byte}
01180 \textcolor{comment}{   length of the source buffer.  Upon entry, destLen is the total size of the}
01181 \textcolor{comment}{   destination buffer, which must be at least the value returned by}
01182 \textcolor{comment}{   compressBound(sourceLen).  Upon exit, destLen is the actual size of the}
01183 \textcolor{comment}{   compressed buffer.}
01184 \textcolor{comment}{}
01185 \textcolor{comment}{     compress2 returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough}
01186 \textcolor{comment}{   memory, Z\_BUF\_ERROR if there was not enough room in the output buffer,}
01187 \textcolor{comment}{   Z\_STREAM\_ERROR if the level parameter is invalid.}
01188 \textcolor{comment}{*/}
01189 
01190 ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
01191 \textcolor{comment}{/*}
01192 \textcolor{comment}{     compressBound() returns an upper bound on the compressed size after}
01193 \textcolor{comment}{   compress() or compress2() on sourceLen bytes.  It would be used before a}
01194 \textcolor{comment}{   compress() or compress2() call to allocate the destination buffer.}
01195 \textcolor{comment}{*/}
01196 
01197 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
01198                                    \textcolor{keyword}{const} Bytef *source, uLong sourceLen));
01199 \textcolor{comment}{/*}
01200 \textcolor{comment}{     Decompresses the source buffer into the destination buffer.  sourceLen is}
01201 \textcolor{comment}{   the byte length of the source buffer.  Upon entry, destLen is the total size}
01202 \textcolor{comment}{   of the destination buffer, which must be large enough to hold the entire}
01203 \textcolor{comment}{   uncompressed data.  (The size of the uncompressed data must have been saved}
01204 \textcolor{comment}{   previously by the compressor and transmitted to the decompressor by some}
01205 \textcolor{comment}{   mechanism outside the scope of this compression library.) Upon exit, destLen}
01206 \textcolor{comment}{   is the actual size of the uncompressed buffer.}
01207 \textcolor{comment}{}
01208 \textcolor{comment}{     uncompress returns Z\_OK if success, Z\_MEM\_ERROR if there was not}
01209 \textcolor{comment}{   enough memory, Z\_BUF\_ERROR if there was not enough room in the output}
01210 \textcolor{comment}{   buffer, or Z\_DATA\_ERROR if the input data was corrupted or incomplete.  In}
01211 \textcolor{comment}{   the case where there is not enough room, uncompress() will fill the output}
01212 \textcolor{comment}{   buffer with the uncompressed data up to that point.}
01213 \textcolor{comment}{*/}
01214 
01215                         \textcolor{comment}{/* gzip file access functions */}
01216 
01217 \textcolor{comment}{/*}
01218 \textcolor{comment}{     This library supports reading and writing files in gzip (.gz) format with}
01219 \textcolor{comment}{   an interface similar to that of stdio, using the functions that start with}
01220 \textcolor{comment}{   "gz".  The gzip format is different from the zlib format.  gzip is a gzip}
01221 \textcolor{comment}{   wrapper, documented in RFC 1952, wrapped around a deflate stream.}
01222 \textcolor{comment}{*/}
01223 
01224 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structgz_file__s}{gzFile\_s} *\hyperlink{structgz_file__s}{gzFile};    \textcolor{comment}{/* semi-opaque gzip file descriptor */}
01225 
01226 \textcolor{comment}{/*}
01227 \textcolor{comment}{ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));}
01228 \textcolor{comment}{}
01229 \textcolor{comment}{     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as}
01230 \textcolor{comment}{   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or}
01231 \textcolor{comment}{   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only}
01232 \textcolor{comment}{   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'}
01233 \textcolor{comment}{   for fixed code compression as in "wb9F".  (See the description of}
01234 \textcolor{comment}{   deflateInit2 for more information about the strategy parameter.)  'T' will}
01235 \textcolor{comment}{   request transparent writing or appending with no compression and not using}
01236 \textcolor{comment}{   the gzip format.}
01237 \textcolor{comment}{}
01238 \textcolor{comment}{     "a" can be used instead of "w" to request that the gzip stream that will}
01239 \textcolor{comment}{   be written be appended to the file.  "+" will result in an error, since}
01240 \textcolor{comment}{   reading and writing to the same gzip file is not supported.  The addition of}
01241 \textcolor{comment}{   "x" when writing will create the file exclusively, which fails if the file}
01242 \textcolor{comment}{   already exists.  On systems that support it, the addition of "e" when}
01243 \textcolor{comment}{   reading or writing will set the flag to close the file on an execve() call.}
01244 \textcolor{comment}{}
01245 \textcolor{comment}{     These functions, as well as gzip, will read and decode a sequence of gzip}
01246 \textcolor{comment}{   streams in a file.  The append function of gzopen() can be used to create}
01247 \textcolor{comment}{   such a file.  (Also see gzflush() for another way to do this.)  When}
01248 \textcolor{comment}{   appending, gzopen does not test whether the file begins with a gzip stream,}
01249 \textcolor{comment}{   nor does it look for the end of the gzip streams to begin appending.  gzopen}
01250 \textcolor{comment}{   will simply append a gzip stream to the existing file.}
01251 \textcolor{comment}{}
01252 \textcolor{comment}{     gzopen can be used to read a file which is not in gzip format; in this}
01253 \textcolor{comment}{   case gzread will directly read from the file without decompression.  When}
01254 \textcolor{comment}{   reading, this will be detected automatically by looking for the magic two-}
01255 \textcolor{comment}{   byte gzip header.}
01256 \textcolor{comment}{}
01257 \textcolor{comment}{     gzopen returns NULL if the file could not be opened, if there was}
01258 \textcolor{comment}{   insufficient memory to allocate the gzFile state, or if an invalid mode was}
01259 \textcolor{comment}{   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).}
01260 \textcolor{comment}{   errno can be checked to determine if the reason gzopen failed was that the}
01261 \textcolor{comment}{   file could not be opened.}
01262 \textcolor{comment}{*/}
01263 
01264 ZEXTERN gzFile ZEXPORT gzdopen OF((\textcolor{keywordtype}{int} fd, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *mode));
01265 \textcolor{comment}{/*}
01266 \textcolor{comment}{     gzdopen associates a gzFile with the file descriptor fd.  File descriptors}
01267 \textcolor{comment}{   are obtained from calls like open, dup, creat, pipe or fileno (if the file}
01268 \textcolor{comment}{   has been previously opened with fopen).  The mode parameter is as in gzopen.}
01269 \textcolor{comment}{}
01270 \textcolor{comment}{     The next call of gzclose on the returned gzFile will also close the file}
01271 \textcolor{comment}{   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor}
01272 \textcolor{comment}{   fd.  If you want to keep fd open, use fd = dup(fd\_keep); gz = gzdopen(fd,}
01273 \textcolor{comment}{   mode);.  The duplicated descriptor should be saved to avoid a leak, since}
01274 \textcolor{comment}{   gzdopen does not close fd if it fails.  If you are using fileno() to get the}
01275 \textcolor{comment}{   file descriptor from a FILE *, then you will have to use dup() to avoid}
01276 \textcolor{comment}{   double-close()ing the file descriptor.  Both gzclose() and fclose() will}
01277 \textcolor{comment}{   close the associated file descriptor, so they need to have different file}
01278 \textcolor{comment}{   descriptors.}
01279 \textcolor{comment}{}
01280 \textcolor{comment}{     gzdopen returns NULL if there was insufficient memory to allocate the}
01281 \textcolor{comment}{   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not}
01282 \textcolor{comment}{   provided, or '+' was provided), or if fd is -1.  The file descriptor is not}
01283 \textcolor{comment}{   used until the next gz* read, write, seek, or close operation, so gzdopen}
01284 \textcolor{comment}{   will not detect if fd is invalid (unless fd is -1).}
01285 \textcolor{comment}{*/}
01286 
01287 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzbuffer OF((gzFile \hyperlink{structfile}{file}, \textcolor{keywordtype}{unsigned} size));
01288 \textcolor{comment}{/*}
01289 \textcolor{comment}{     Set the internal buffer size used by this library's functions.  The}
01290 \textcolor{comment}{   default buffer size is 8192 bytes.  This function must be called after}
01291 \textcolor{comment}{   gzopen() or gzdopen(), and before any other calls that read or write the}
01292 \textcolor{comment}{   file.  The buffer memory allocation is always deferred to the first read or}
01293 \textcolor{comment}{   write.  Two buffers are allocated, either both of the specified size when}
01294 \textcolor{comment}{   writing, or one of the specified size and the other twice that size when}
01295 \textcolor{comment}{   reading.  A larger buffer size of, for example, 64K or 128K bytes will}
01296 \textcolor{comment}{   noticeably increase the speed of decompression (reading).}
01297 \textcolor{comment}{}
01298 \textcolor{comment}{     The new buffer size also affects the maximum length for gzprintf().}
01299 \textcolor{comment}{}
01300 \textcolor{comment}{     gzbuffer() returns 0 on success, or -1 on failure, such as being called}
01301 \textcolor{comment}{   too late.}
01302 \textcolor{comment}{*/}
01303 
01304 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzsetparams OF((gzFile \hyperlink{structfile}{file}, \textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} strategy));
01305 \textcolor{comment}{/*}
01306 \textcolor{comment}{     Dynamically update the compression level or strategy.  See the description}
01307 \textcolor{comment}{   of deflateInit2 for the meaning of these parameters.}
01308 \textcolor{comment}{}
01309 \textcolor{comment}{     gzsetparams returns Z\_OK if success, or Z\_STREAM\_ERROR if the file was not}
01310 \textcolor{comment}{   opened for writing.}
01311 \textcolor{comment}{*/}
01312 
01313 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzread OF((gzFile \hyperlink{structfile}{file}, voidp buf, \textcolor{keywordtype}{unsigned} len));
01314 \textcolor{comment}{/*}
01315 \textcolor{comment}{     Reads the given number of uncompressed bytes from the compressed file.  If}
01316 \textcolor{comment}{   the input file is not in gzip format, gzread copies the given number of}
01317 \textcolor{comment}{   bytes into the buffer directly from the file.}
01318 \textcolor{comment}{}
01319 \textcolor{comment}{     After reaching the end of a gzip stream in the input, gzread will continue}
01320 \textcolor{comment}{   to read, looking for another gzip stream.  Any number of gzip streams may be}
01321 \textcolor{comment}{   concatenated in the input file, and will all be decompressed by gzread().}
01322 \textcolor{comment}{   If something other than a gzip stream is encountered after a gzip stream,}
01323 \textcolor{comment}{   that remaining trailing garbage is ignored (and no error is returned).}
01324 \textcolor{comment}{}
01325 \textcolor{comment}{     gzread can be used to read a gzip file that is being concurrently written.}
01326 \textcolor{comment}{   Upon reaching the end of the input, gzread will return with the available}
01327 \textcolor{comment}{   data.  If the error code returned by gzerror is Z\_OK or Z\_BUF\_ERROR, then}
01328 \textcolor{comment}{   gzclearerr can be used to clear the end of file indicator in order to permit}
01329 \textcolor{comment}{   gzread to be tried again.  Z\_OK indicates that a gzip stream was completed}
01330 \textcolor{comment}{   on the last gzread.  Z\_BUF\_ERROR indicates that the input file ended in the}
01331 \textcolor{comment}{   middle of a gzip stream.  Note that gzread does not return -1 in the event}
01332 \textcolor{comment}{   of an incomplete gzip stream.  This error is deferred until gzclose(), which}
01333 \textcolor{comment}{   will return Z\_BUF\_ERROR if the last gzread ended in the middle of a gzip}
01334 \textcolor{comment}{   stream.  Alternatively, gzerror can be used before gzclose to detect this}
01335 \textcolor{comment}{   case.}
01336 \textcolor{comment}{}
01337 \textcolor{comment}{     gzread returns the number of uncompressed bytes actually read, less than}
01338 \textcolor{comment}{   len for end of file, or -1 for error.}
01339 \textcolor{comment}{*/}
01340 
01341 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzwrite OF((gzFile \hyperlink{structfile}{file},
01342                                 voidpc buf, \textcolor{keywordtype}{unsigned} len));
01343 \textcolor{comment}{/*}
01344 \textcolor{comment}{     Writes the given number of uncompressed bytes into the compressed file.}
01345 \textcolor{comment}{   gzwrite returns the number of uncompressed bytes written or 0 in case of}
01346 \textcolor{comment}{   error.}
01347 \textcolor{comment}{*/}
01348 
01349 ZEXTERN \textcolor{keywordtype}{int} ZEXPORTVA gzprintf Z\_ARG((gzFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *format, ...));
01350 \textcolor{comment}{/*}
01351 \textcolor{comment}{     Converts, formats, and writes the arguments to the compressed file under}
01352 \textcolor{comment}{   control of the format string, as in fprintf.  gzprintf returns the number of}
01353 \textcolor{comment}{   uncompressed bytes actually written, or 0 in case of error.  The number of}
01354 \textcolor{comment}{   uncompressed bytes written is limited to 8191, or one less than the buffer}
01355 \textcolor{comment}{   size given to gzbuffer().  The caller should assure that this limit is not}
01356 \textcolor{comment}{   exceeded.  If it is exceeded, then gzprintf() will return an error (0) with}
01357 \textcolor{comment}{   nothing written.  In this case, there may also be a buffer overflow with}
01358 \textcolor{comment}{   unpredictable consequences, which is possible only if zlib was compiled with}
01359 \textcolor{comment}{   the insecure functions sprintf() or vsprintf() because the secure snprintf()}
01360 \textcolor{comment}{   or vsnprintf() functions were not available.  This can be determined using}
01361 \textcolor{comment}{   zlibCompileFlags().}
01362 \textcolor{comment}{*/}
01363 
01364 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzputs OF((gzFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s));
01365 \textcolor{comment}{/*}
01366 \textcolor{comment}{     Writes the given null-terminated string to the compressed file, excluding}
01367 \textcolor{comment}{   the terminating null character.}
01368 \textcolor{comment}{}
01369 \textcolor{comment}{     gzputs returns the number of characters written, or -1 in case of error.}
01370 \textcolor{comment}{*/}
01371 
01372 ZEXTERN \textcolor{keywordtype}{char} * ZEXPORT gzgets OF((gzFile \hyperlink{structfile}{file}, \textcolor{keywordtype}{char} *buf, \textcolor{keywordtype}{int} len));
01373 \textcolor{comment}{/*}
01374 \textcolor{comment}{     Reads bytes from the compressed file until len-1 characters are read, or a}
01375 \textcolor{comment}{   newline character is read and transferred to buf, or an end-of-file}
01376 \textcolor{comment}{   condition is encountered.  If any characters are read or if len == 1, the}
01377 \textcolor{comment}{   string is terminated with a null character.  If no characters are read due}
01378 \textcolor{comment}{   to an end-of-file or len < 1, then the buffer is left untouched.}
01379 \textcolor{comment}{}
01380 \textcolor{comment}{     gzgets returns buf which is a null-terminated string, or it returns NULL}
01381 \textcolor{comment}{   for end-of-file or in case of error.  If there was an error, the contents at}
01382 \textcolor{comment}{   buf are indeterminate.}
01383 \textcolor{comment}{*/}
01384 
01385 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzputc OF((gzFile \hyperlink{structfile}{file}, \textcolor{keywordtype}{int} c));
01386 \textcolor{comment}{/*}
01387 \textcolor{comment}{     Writes c, converted to an unsigned char, into the compressed file.  gzputc}
01388 \textcolor{comment}{   returns the value that was written, or -1 in case of error.}
01389 \textcolor{comment}{*/}
01390 
01391 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzgetc OF((gzFile \hyperlink{structfile}{file}));
01392 \textcolor{comment}{/*}
01393 \textcolor{comment}{     Reads one byte from the compressed file.  gzgetc returns this byte or -1}
01394 \textcolor{comment}{   in case of end of file or error.  This is implemented as a macro for speed.}
01395 \textcolor{comment}{   As such, it does not do all of the checking the other functions do.  I.e.}
01396 \textcolor{comment}{   it does not check to see if file is NULL, nor whether the structure file}
01397 \textcolor{comment}{   points to has been clobbered or not.}
01398 \textcolor{comment}{*/}
01399 
01400 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzungetc OF((\textcolor{keywordtype}{int} c, gzFile \hyperlink{structfile}{file}));
01401 \textcolor{comment}{/*}
01402 \textcolor{comment}{     Push one character back onto the stream to be read as the first character}
01403 \textcolor{comment}{   on the next read.  At least one character of push-back is allowed.}
01404 \textcolor{comment}{   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will}
01405 \textcolor{comment}{   fail if c is -1, and may fail if a character has been pushed but not read}
01406 \textcolor{comment}{   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the}
01407 \textcolor{comment}{   output buffer size of pushed characters is allowed.  (See gzbuffer above.)}
01408 \textcolor{comment}{   The pushed character will be discarded if the stream is repositioned with}
01409 \textcolor{comment}{   gzseek() or gzrewind().}
01410 \textcolor{comment}{*/}
01411 
01412 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzflush OF((gzFile \hyperlink{structfile}{file}, \textcolor{keywordtype}{int} flush));
01413 \textcolor{comment}{/*}
01414 \textcolor{comment}{     Flushes all pending output into the compressed file.  The parameter flush}
01415 \textcolor{comment}{   is as in the deflate() function.  The return value is the zlib error number}
01416 \textcolor{comment}{   (see function gzerror below).  gzflush is only permitted when writing.}
01417 \textcolor{comment}{}
01418 \textcolor{comment}{     If the flush parameter is Z\_FINISH, the remaining data is written and the}
01419 \textcolor{comment}{   gzip stream is completed in the output.  If gzwrite() is called again, a new}
01420 \textcolor{comment}{   gzip stream will be started in the output.  gzread() is able to read such}
01421 \textcolor{comment}{   concatented gzip streams.}
01422 \textcolor{comment}{}
01423 \textcolor{comment}{     gzflush should be called only when strictly necessary because it will}
01424 \textcolor{comment}{   degrade compression if called too often.}
01425 \textcolor{comment}{*/}
01426 
01427 \textcolor{comment}{/*}
01428 \textcolor{comment}{ZEXTERN z\_off\_t ZEXPORT gzseek OF((gzFile file,}
01429 \textcolor{comment}{                                   z\_off\_t offset, int whence));}
01430 \textcolor{comment}{}
01431 \textcolor{comment}{     Sets the starting position for the next gzread or gzwrite on the given}
01432 \textcolor{comment}{   compressed file.  The offset represents a number of bytes in the}
01433 \textcolor{comment}{   uncompressed data stream.  The whence parameter is defined as in lseek(2);}
01434 \textcolor{comment}{   the value SEEK\_END is not supported.}
01435 \textcolor{comment}{}
01436 \textcolor{comment}{     If the file is opened for reading, this function is emulated but can be}
01437 \textcolor{comment}{   extremely slow.  If the file is opened for writing, only forward seeks are}
01438 \textcolor{comment}{   supported; gzseek then compresses a sequence of zeroes up to the new}
01439 \textcolor{comment}{   starting position.}
01440 \textcolor{comment}{}
01441 \textcolor{comment}{     gzseek returns the resulting offset location as measured in bytes from}
01442 \textcolor{comment}{   the beginning of the uncompressed stream, or -1 in case of error, in}
01443 \textcolor{comment}{   particular if the file is opened for writing and the new starting position}
01444 \textcolor{comment}{   would be before the current position.}
01445 \textcolor{comment}{*/}
01446 
01447 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT    gzrewind OF((gzFile \hyperlink{structfile}{file}));
01448 \textcolor{comment}{/*}
01449 \textcolor{comment}{     Rewinds the given file. This function is supported only for reading.}
01450 \textcolor{comment}{}
01451 \textcolor{comment}{     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK\_SET)}
01452 \textcolor{comment}{*/}
01453 
01454 \textcolor{comment}{/*}
01455 \textcolor{comment}{ZEXTERN z\_off\_t ZEXPORT    gztell OF((gzFile file));}
01456 \textcolor{comment}{}
01457 \textcolor{comment}{     Returns the starting position for the next gzread or gzwrite on the given}
01458 \textcolor{comment}{   compressed file.  This position represents a number of bytes in the}
01459 \textcolor{comment}{   uncompressed data stream, and is zero when starting, even if appending or}
01460 \textcolor{comment}{   reading a gzip stream from the middle of a file using gzdopen().}
01461 \textcolor{comment}{}
01462 \textcolor{comment}{     gztell(file) is equivalent to gzseek(file, 0L, SEEK\_CUR)}
01463 \textcolor{comment}{*/}
01464 
01465 \textcolor{comment}{/*}
01466 \textcolor{comment}{ZEXTERN z\_off\_t ZEXPORT gzoffset OF((gzFile file));}
01467 \textcolor{comment}{}
01468 \textcolor{comment}{     Returns the current offset in the file being read or written.  This offset}
01469 \textcolor{comment}{   includes the count of bytes that precede the gzip stream, for example when}
01470 \textcolor{comment}{   appending or when using gzdopen() for reading.  When reading, the offset}
01471 \textcolor{comment}{   does not include as yet unused buffered input.  This information can be used}
01472 \textcolor{comment}{   for a progress indicator.  On error, gzoffset() returns -1.}
01473 \textcolor{comment}{*/}
01474 
01475 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzeof OF((gzFile \hyperlink{structfile}{file}));
01476 \textcolor{comment}{/*}
01477 \textcolor{comment}{     Returns true (1) if the end-of-file indicator has been set while reading,}
01478 \textcolor{comment}{   false (0) otherwise.  Note that the end-of-file indicator is set only if the}
01479 \textcolor{comment}{   read tried to go past the end of the input, but came up short.  Therefore,}
01480 \textcolor{comment}{   just like feof(), gzeof() may return false even if there is no more data to}
01481 \textcolor{comment}{   read, in the event that the last read request was for the exact number of}
01482 \textcolor{comment}{   bytes remaining in the input file.  This will happen if the input file size}
01483 \textcolor{comment}{   is an exact multiple of the buffer size.}
01484 \textcolor{comment}{}
01485 \textcolor{comment}{     If gzeof() returns true, then the read functions will return no more data,}
01486 \textcolor{comment}{   unless the end-of-file indicator is reset by gzclearerr() and the input file}
01487 \textcolor{comment}{   has grown since the previous end of file was detected.}
01488 \textcolor{comment}{*/}
01489 
01490 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzdirect OF((gzFile \hyperlink{structfile}{file}));
01491 \textcolor{comment}{/*}
01492 \textcolor{comment}{     Returns true (1) if file is being copied directly while reading, or false}
01493 \textcolor{comment}{   (0) if file is a gzip stream being decompressed.}
01494 \textcolor{comment}{}
01495 \textcolor{comment}{     If the input file is empty, gzdirect() will return true, since the input}
01496 \textcolor{comment}{   does not contain a gzip stream.}
01497 \textcolor{comment}{}
01498 \textcolor{comment}{     If gzdirect() is used immediately after gzopen() or gzdopen() it will}
01499 \textcolor{comment}{   cause buffers to be allocated to allow reading the file to determine if it}
01500 \textcolor{comment}{   is a gzip file.  Therefore if gzbuffer() is used, it should be called before}
01501 \textcolor{comment}{   gzdirect().}
01502 \textcolor{comment}{}
01503 \textcolor{comment}{     When writing, gzdirect() returns true (1) if transparent writing was}
01504 \textcolor{comment}{   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:}
01505 \textcolor{comment}{   gzdirect() is not needed when writing.  Transparent writing must be}
01506 \textcolor{comment}{   explicitly requested, so the application already knows the answer.  When}
01507 \textcolor{comment}{   linking statically, using gzdirect() will include all of the zlib code for}
01508 \textcolor{comment}{   gzip file reading and decompression, which may not be desired.)}
01509 \textcolor{comment}{*/}
01510 
01511 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT    gzclose OF((gzFile \hyperlink{structfile}{file}));
01512 \textcolor{comment}{/*}
01513 \textcolor{comment}{     Flushes all pending output if necessary, closes the compressed file and}
01514 \textcolor{comment}{   deallocates the (de)compression state.  Note that once file is closed, you}
01515 \textcolor{comment}{   cannot call gzerror with file, since its structures have been deallocated.}
01516 \textcolor{comment}{   gzclose must not be called more than once on the same file, just as free}
01517 \textcolor{comment}{   must not be called more than once on the same allocation.}
01518 \textcolor{comment}{}
01519 \textcolor{comment}{     gzclose will return Z\_STREAM\_ERROR if file is not valid, Z\_ERRNO on a}
01520 \textcolor{comment}{   file operation error, Z\_MEM\_ERROR if out of memory, Z\_BUF\_ERROR if the}
01521 \textcolor{comment}{   last read ended in the middle of a gzip stream, or Z\_OK on success.}
01522 \textcolor{comment}{*/}
01523 
01524 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzclose\_r OF((gzFile \hyperlink{structfile}{file}));
01525 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzclose\_w OF((gzFile \hyperlink{structfile}{file}));
01526 \textcolor{comment}{/*}
01527 \textcolor{comment}{     Same as gzclose(), but gzclose\_r() is only for use when reading, and}
01528 \textcolor{comment}{   gzclose\_w() is only for use when writing or appending.  The advantage to}
01529 \textcolor{comment}{   using these instead of gzclose() is that they avoid linking in zlib}
01530 \textcolor{comment}{   compression or decompression code that is not used when only reading or only}
01531 \textcolor{comment}{   writing respectively.  If gzclose() is used, then both compression and}
01532 \textcolor{comment}{   decompression code will be included the application when linking to a static}
01533 \textcolor{comment}{   zlib library.}
01534 \textcolor{comment}{*/}
01535 
01536 ZEXTERN \textcolor{keyword}{const} \textcolor{keywordtype}{char} * ZEXPORT gzerror OF((gzFile \hyperlink{structfile}{file}, \textcolor{keywordtype}{int} *errnum));
01537 \textcolor{comment}{/*}
01538 \textcolor{comment}{     Returns the error message for the last error which occurred on the given}
01539 \textcolor{comment}{   compressed file.  errnum is set to zlib error number.  If an error occurred}
01540 \textcolor{comment}{   in the file system and not in the compression library, errnum is set to}
01541 \textcolor{comment}{   Z\_ERRNO and the application may consult errno to get the exact error code.}
01542 \textcolor{comment}{}
01543 \textcolor{comment}{     The application must not modify the returned string.  Future calls to}
01544 \textcolor{comment}{   this function may invalidate the previously returned string.  If file is}
01545 \textcolor{comment}{   closed, then the string previously returned by gzerror will no longer be}
01546 \textcolor{comment}{   available.}
01547 \textcolor{comment}{}
01548 \textcolor{comment}{     gzerror() should be used to distinguish errors from end-of-file for those}
01549 \textcolor{comment}{   functions above that do not distinguish those cases in their return values.}
01550 \textcolor{comment}{*/}
01551 
01552 ZEXTERN \textcolor{keywordtype}{void} ZEXPORT gzclearerr OF((gzFile \hyperlink{structfile}{file}));
01553 \textcolor{comment}{/*}
01554 \textcolor{comment}{     Clears the error and end-of-file flags for file.  This is analogous to the}
01555 \textcolor{comment}{   clearerr() function in stdio.  This is useful for continuing to read a gzip}
01556 \textcolor{comment}{   file that is being written concurrently.}
01557 \textcolor{comment}{*/}
01558 
01559 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !Z\_SOLO */}\textcolor{preprocessor}{}
01560 
01561                         \textcolor{comment}{/* checksum functions */}
01562 
01563 \textcolor{comment}{/*}
01564 \textcolor{comment}{     These functions are not related to compression but are exported}
01565 \textcolor{comment}{   anyway because they might be useful in applications using the compression}
01566 \textcolor{comment}{   library.}
01567 \textcolor{comment}{*/}
01568 
01569 ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, \textcolor{keyword}{const} Bytef *buf, uInt len));
01570 \textcolor{comment}{/*}
01571 \textcolor{comment}{     Update a running Adler-32 checksum with the bytes buf[0..len-1] and}
01572 \textcolor{comment}{   return the updated checksum.  If buf is Z\_NULL, this function returns the}
01573 \textcolor{comment}{   required initial value for the checksum.}
01574 \textcolor{comment}{}
01575 \textcolor{comment}{     An Adler-32 checksum is almost as reliable as a CRC32 but can be computed}
01576 \textcolor{comment}{   much faster.}
01577 \textcolor{comment}{}
01578 \textcolor{comment}{   Usage example:}
01579 \textcolor{comment}{}
01580 \textcolor{comment}{     uLong adler = adler32(0L, Z\_NULL, 0);}
01581 \textcolor{comment}{}
01582 \textcolor{comment}{     while (read\_buffer(buffer, length) != EOF) \{}
01583 \textcolor{comment}{       adler = adler32(adler, buffer, length);}
01584 \textcolor{comment}{     \}}
01585 \textcolor{comment}{     if (adler != original\_adler) error();}
01586 \textcolor{comment}{*/}
01587 
01588 \textcolor{comment}{/*}
01589 \textcolor{comment}{ZEXTERN uLong ZEXPORT adler32\_combine OF((uLong adler1, uLong adler2,}
01590 \textcolor{comment}{                                          z\_off\_t len2));}
01591 \textcolor{comment}{}
01592 \textcolor{comment}{     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1}
01593 \textcolor{comment}{   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for}
01594 \textcolor{comment}{   each, adler1 and adler2.  adler32\_combine() returns the Adler-32 checksum of}
01595 \textcolor{comment}{   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note}
01596 \textcolor{comment}{   that the z\_off\_t type (like off\_t) is a signed integer.  If len2 is}
01597 \textcolor{comment}{   negative, the result has no meaning or utility.}
01598 \textcolor{comment}{*/}
01599 
01600 ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, \textcolor{keyword}{const} Bytef *buf, uInt len));
01601 \textcolor{comment}{/*}
01602 \textcolor{comment}{     Update a running CRC-32 with the bytes buf[0..len-1] and return the}
01603 \textcolor{comment}{   updated CRC-32.  If buf is Z\_NULL, this function returns the required}
01604 \textcolor{comment}{   initial value for the crc.  Pre- and post-conditioning (one's complement) is}
01605 \textcolor{comment}{   performed within this function so it shouldn't be done by the application.}
01606 \textcolor{comment}{}
01607 \textcolor{comment}{   Usage example:}
01608 \textcolor{comment}{}
01609 \textcolor{comment}{     uLong crc = crc32(0L, Z\_NULL, 0);}
01610 \textcolor{comment}{}
01611 \textcolor{comment}{     while (read\_buffer(buffer, length) != EOF) \{}
01612 \textcolor{comment}{       crc = crc32(crc, buffer, length);}
01613 \textcolor{comment}{     \}}
01614 \textcolor{comment}{     if (crc != original\_crc) error();}
01615 \textcolor{comment}{*/}
01616 
01617 \textcolor{comment}{/*}
01618 \textcolor{comment}{ZEXTERN uLong ZEXPORT crc32\_combine OF((uLong crc1, uLong crc2, z\_off\_t len2));}
01619 \textcolor{comment}{}
01620 \textcolor{comment}{     Combine two CRC-32 check values into one.  For two sequences of bytes,}
01621 \textcolor{comment}{   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were}
01622 \textcolor{comment}{   calculated for each, crc1 and crc2.  crc32\_combine() returns the CRC-32}
01623 \textcolor{comment}{   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and}
01624 \textcolor{comment}{   len2.}
01625 \textcolor{comment}{*/}
01626 
01627 
01628                         \textcolor{comment}{/* various hacks, don't look :) */}
01629 
01630 \textcolor{comment}{/* deflateInit and inflateInit are macros to allow checking the zlib version}
01631 \textcolor{comment}{ * and the compiler's view of z\_stream:}
01632 \textcolor{comment}{ */}
01633 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateInit\_ OF((z\_streamp strm, \textcolor{keywordtype}{int} level,
01634                                      \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version, \textcolor{keywordtype}{int} stream\_size));
01635 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateInit\_ OF((z\_streamp strm,
01636                                      \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version, \textcolor{keywordtype}{int} stream\_size));
01637 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateInit2\_ OF((z\_streamp strm, \textcolor{keywordtype}{int}  level, \textcolor{keywordtype}{int}  method,
01638                                       \textcolor{keywordtype}{int} windowBits, \textcolor{keywordtype}{int} memLevel,
01639                                       \textcolor{keywordtype}{int} strategy, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version,
01640                                       \textcolor{keywordtype}{int} stream\_size));
01641 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateInit2\_ OF((z\_streamp strm, \textcolor{keywordtype}{int}  windowBits,
01642                                       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version, \textcolor{keywordtype}{int} stream\_size));
01643 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateBackInit\_ OF((z\_streamp strm, \textcolor{keywordtype}{int} windowBits,
01644                                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *window,
01645                                          \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version,
01646                                          \textcolor{keywordtype}{int} stream\_size));
01647 \textcolor{preprocessor}{#define deflateInit(strm, level) \(\backslash\)}
01648 \textcolor{preprocessor}{        deflateInit\_((strm), (level), ZLIB\_VERSION, (int)sizeof(z\_stream))}
01649 \textcolor{preprocessor}{#define inflateInit(strm) \(\backslash\)}
01650 \textcolor{preprocessor}{        inflateInit\_((strm), ZLIB\_VERSION, (int)sizeof(z\_stream))}
01651 \textcolor{preprocessor}{#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \(\backslash\)}
01652 \textcolor{preprocessor}{        deflateInit2\_((strm),(level),(method),(windowBits),(memLevel),\(\backslash\)}
01653 \textcolor{preprocessor}{                      (strategy), ZLIB\_VERSION, (int)sizeof(z\_stream))}
01654 \textcolor{preprocessor}{#define inflateInit2(strm, windowBits) \(\backslash\)}
01655 \textcolor{preprocessor}{        inflateInit2\_((strm), (windowBits), ZLIB\_VERSION, \(\backslash\)}
01656 \textcolor{preprocessor}{                      (int)sizeof(z\_stream))}
01657 \textcolor{preprocessor}{#define inflateBackInit(strm, windowBits, window) \(\backslash\)}
01658 \textcolor{preprocessor}{        inflateBackInit\_((strm), (windowBits), (window), \(\backslash\)}
01659 \textcolor{preprocessor}{                      ZLIB\_VERSION, (int)sizeof(z\_stream))}
01660 
01661 \textcolor{preprocessor}{#ifndef Z\_SOLO}
01662 
01663 \textcolor{comment}{/* gzgetc() macro and its supporting function and exposed data structure.  Note}
01664 \textcolor{comment}{ * that the real internal state is much larger than the exposed structure.}
01665 \textcolor{comment}{ * This abbreviated structure exposes just enough for the gzgetc() macro.  The}
01666 \textcolor{comment}{ * user should not mess with these exposed elements, since their names or}
01667 \textcolor{comment}{ * behavior could change in the future, perhaps even capriciously.  They can}
01668 \textcolor{comment}{ * only be used by the gzgetc() macro.  You have been warned.}
01669 \textcolor{comment}{ */}
01670 \textcolor{keyword}{struct }\hyperlink{structgz_file__s}{gzFile\_s} \{
01671     \textcolor{keywordtype}{unsigned} have;
01672     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *next;
01673     z\_off64\_t pos;
01674 \};
01675 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzgetc\_ OF((gzFile \hyperlink{structfile}{file}));  \textcolor{comment}{/* backward compatibility */}
01676 \textcolor{preprocessor}{#ifdef Z\_PREFIX\_SET}
01677 \textcolor{preprocessor}{#  undef z\_gzgetc}
01678 \textcolor{preprocessor}{#  define z\_gzgetc(g) \(\backslash\)}
01679 \textcolor{preprocessor}{          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))}
01680 \textcolor{preprocessor}{#else}
01681 \textcolor{preprocessor}{#  define gzgetc(g) \(\backslash\)}
01682 \textcolor{preprocessor}{          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))}
01683 \textcolor{preprocessor}{#endif}
01684 
01685 \textcolor{comment}{/* provide 64-bit offset functions if \_LARGEFILE64\_SOURCE defined, and/or}
01686 \textcolor{comment}{ * change the regular functions to 64 bits if \_FILE\_OFFSET\_BITS is 64 (if}
01687 \textcolor{comment}{ * both are true, the application gets the *64 functions, and the regular}
01688 \textcolor{comment}{ * functions are changed to 64 bits) -- in case these are set on systems}
01689 \textcolor{comment}{ * without large file support, \_LFS64\_LARGEFILE must also be true}
01690 \textcolor{comment}{ */}
01691 \textcolor{preprocessor}{#ifdef Z\_LARGE64}
01692    ZEXTERN gzFile ZEXPORT gzopen64 OF((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *));
01693    ZEXTERN z\_off64\_t ZEXPORT gzseek64 OF((gzFile, z\_off64\_t, \textcolor{keywordtype}{int}));
01694    ZEXTERN z\_off64\_t ZEXPORT gztell64 OF((gzFile));
01695    ZEXTERN z\_off64\_t ZEXPORT gzoffset64 OF((gzFile));
01696    ZEXTERN uLong ZEXPORT adler32\_combine64 OF((uLong, uLong, z\_off64\_t));
01697    ZEXTERN uLong ZEXPORT crc32\_combine64 OF((uLong, uLong, z\_off64\_t));
01698 \textcolor{preprocessor}{#endif}
01699 
01700 \textcolor{preprocessor}{#if !defined(ZLIB\_INTERNAL) && defined(Z\_WANT64)}
01701 \textcolor{preprocessor}{#  ifdef Z\_PREFIX\_SET}
01702 \textcolor{preprocessor}{#    define z\_gzopen z\_gzopen64}
01703 \textcolor{preprocessor}{#    define z\_gzseek z\_gzseek64}
01704 \textcolor{preprocessor}{#    define z\_gztell z\_gztell64}
01705 \textcolor{preprocessor}{#    define z\_gzoffset z\_gzoffset64}
01706 \textcolor{preprocessor}{#    define z\_adler32\_combine z\_adler32\_combine64}
01707 \textcolor{preprocessor}{#    define z\_crc32\_combine z\_crc32\_combine64}
01708 \textcolor{preprocessor}{#  else}
01709 \textcolor{preprocessor}{#    define gzopen gzopen64}
01710 \textcolor{preprocessor}{#    define gzseek gzseek64}
01711 \textcolor{preprocessor}{#    define gztell gztell64}
01712 \textcolor{preprocessor}{#    define gzoffset gzoffset64}
01713 \textcolor{preprocessor}{#    define adler32\_combine adler32\_combine64}
01714 \textcolor{preprocessor}{#    define crc32\_combine crc32\_combine64}
01715 \textcolor{preprocessor}{#  endif}
01716 \textcolor{preprocessor}{#  ifndef Z\_LARGE64}
01717      ZEXTERN gzFile ZEXPORT gzopen64 OF((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *));
01718      ZEXTERN z\_off\_t ZEXPORT gzseek64 OF((gzFile, z\_off\_t, \textcolor{keywordtype}{int}));
01719      ZEXTERN z\_off\_t ZEXPORT gztell64 OF((gzFile));
01720      ZEXTERN z\_off\_t ZEXPORT gzoffset64 OF((gzFile));
01721      ZEXTERN uLong ZEXPORT adler32\_combine64 OF((uLong, uLong, z\_off\_t));
01722      ZEXTERN uLong ZEXPORT crc32\_combine64 OF((uLong, uLong, z\_off\_t));
01723 \textcolor{preprocessor}{#  endif}
01724 \textcolor{preprocessor}{#else}
01725    ZEXTERN gzFile ZEXPORT gzopen OF((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *));
01726    ZEXTERN z\_off\_t ZEXPORT gzseek OF((gzFile, z\_off\_t, \textcolor{keywordtype}{int}));
01727    ZEXTERN z\_off\_t ZEXPORT gztell OF((gzFile));
01728    ZEXTERN z\_off\_t ZEXPORT gzoffset OF((gzFile));
01729    ZEXTERN uLong ZEXPORT adler32\_combine OF((uLong, uLong, z\_off\_t));
01730    ZEXTERN uLong ZEXPORT crc32\_combine OF((uLong, uLong, z\_off\_t));
01731 \textcolor{preprocessor}{#endif}
01732 
01733 \textcolor{preprocessor}{#else }\textcolor{comment}{/* Z\_SOLO */}\textcolor{preprocessor}{}
01734 
01735    ZEXTERN uLong ZEXPORT adler32\_combine OF((uLong, uLong, z\_off\_t));
01736    ZEXTERN uLong ZEXPORT crc32\_combine OF((uLong, uLong, z\_off\_t));
01737 
01738 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !Z\_SOLO */}\textcolor{preprocessor}{}
01739 
01740 \textcolor{comment}{/* hack for buggy compilers */}
01741 \textcolor{preprocessor}{#if !defined(ZUTIL\_H) && !defined(NO\_DUMMY\_DECL)}
01742     \textcolor{keyword}{struct }\hyperlink{structinternal__state}{internal\_state} \{\textcolor{keywordtype}{int} dummy;\};
01743 \textcolor{preprocessor}{#endif}
01744 
01745 \textcolor{comment}{/* undocumented functions */}
01746 ZEXTERN \textcolor{keyword}{const} \textcolor{keywordtype}{char}   * ZEXPORT zError           OF((\textcolor{keywordtype}{int}));
01747 ZEXTERN \textcolor{keywordtype}{int}            ZEXPORT inflateSyncPoint OF((z\_streamp));
01748 ZEXTERN \textcolor{keyword}{const} z\_crc\_t FAR * ZEXPORT get\_crc\_table    OF((\textcolor{keywordtype}{void}));
01749 ZEXTERN \textcolor{keywordtype}{int}            ZEXPORT inflateUndermine OF((z\_streamp, \textcolor{keywordtype}{int}));
01750 ZEXTERN \textcolor{keywordtype}{int}            ZEXPORT inflateResetKeep OF((z\_streamp));
01751 ZEXTERN \textcolor{keywordtype}{int}            ZEXPORT deflateResetKeep OF((z\_streamp));
01752 \textcolor{preprocessor}{#if defined(\_WIN32) && !defined(Z\_SOLO)}
01753 ZEXTERN gzFile         ZEXPORT gzopen\_w OF((\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t} *path,
01754                                             \textcolor{keyword}{const} \textcolor{keywordtype}{char} *mode));
01755 \textcolor{preprocessor}{#endif}
01756 \textcolor{preprocessor}{#if defined(STDC) || defined(Z\_HAVE\_STDARG\_H)}
01757 \textcolor{preprocessor}{#  ifndef Z\_SOLO}
01758 ZEXTERN \textcolor{keywordtype}{int}            ZEXPORTVA gzvprintf Z\_ARG((gzFile \hyperlink{structfile}{file},
01759                                                   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *format,
01760                                                   va\_list va));
01761 \textcolor{preprocessor}{#  endif}
01762 \textcolor{preprocessor}{#endif}
01763 
01764 \textcolor{preprocessor}{#ifdef \_\_cplusplus}
01765 \}
01766 \textcolor{preprocessor}{#endif}
01767 
01768 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* ZLIB\_H */}\textcolor{preprocessor}{}
\end{DoxyCode}
