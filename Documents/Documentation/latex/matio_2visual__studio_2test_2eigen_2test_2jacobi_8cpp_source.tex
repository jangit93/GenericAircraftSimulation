\hypertarget{matio_2visual__studio_2test_2eigen_2test_2jacobi_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/jacobi.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2jacobi_8cpp_source}\index{jacobi.\+cpp@{jacobi.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#include "main.h"}
00012 \textcolor{preprocessor}{#include <Eigen/SVD>}
00013 
00014 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} JacobiScalar>
00015 \textcolor{keywordtype}{void} jacobi(\textcolor{keyword}{const} MatrixType& m = MatrixType())
00016 \{
00017   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00018   Index rows = m.rows();
00019   Index cols = m.cols();
00020 
00021   \textcolor{keyword}{enum} \{
00022     RowsAtCompileTime = MatrixType::RowsAtCompileTime,
00023     ColsAtCompileTime = MatrixType::ColsAtCompileTime
00024   \};
00025 
00026   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<JacobiScalar, 2, 1>} JacobiVector;
00027 
00028   \textcolor{keyword}{const} MatrixType a(MatrixType::Random(rows, cols));
00029 
00030   JacobiVector v = JacobiVector::Random().normalized();
00031   JacobiScalar c = v.x(), s = v.y();
00032   \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<JacobiScalar>} rot(c, s);
00033 
00034   \{
00035     Index p = internal::random<Index>(0, rows-1);
00036     Index q;
00037     \textcolor{keywordflow}{do} \{
00038       q = internal::random<Index>(0, rows-1);
00039     \} \textcolor{keywordflow}{while} (q == p);
00040 
00041     MatrixType b = a;
00042     b.applyOnTheLeft(p, q, rot);
00043     VERIFY\_IS\_APPROX(b.row(p), c * a.row(p) + numext::conj(s) * a.row(q));
00044     VERIFY\_IS\_APPROX(b.row(q), -s * a.row(p) + numext::conj(c) * a.row(q));
00045   \}
00046 
00047   \{
00048     Index p = internal::random<Index>(0, cols-1);
00049     Index q;
00050     \textcolor{keywordflow}{do} \{
00051       q = internal::random<Index>(0, cols-1);
00052     \} \textcolor{keywordflow}{while} (q == p);
00053 
00054     MatrixType b = a;
00055     b.applyOnTheRight(p, q, rot);
00056     VERIFY\_IS\_APPROX(b.col(p), c * a.col(p) - s * a.col(q));
00057     VERIFY\_IS\_APPROX(b.col(q), numext::conj(s) * a.col(p) + numext::conj(c) * a.col(q));
00058   \}
00059 \}
00060 
00061 \textcolor{keywordtype}{void} test\_jacobi()
00062 \{
00063   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00064     CALL\_SUBTEST\_1(( jacobi<Matrix3f, float>() ));
00065     CALL\_SUBTEST\_2(( jacobi<Matrix4d, double>() ));
00066     CALL\_SUBTEST\_3(( jacobi<Matrix4cf, float>() ));
00067     CALL\_SUBTEST\_3(( jacobi<Matrix4cf, std::complex<float> >() ));
00068 
00069     \textcolor{keywordtype}{int} r = internal::random<int>(2, internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE)/2),
00070         c = internal::random<int>(2, internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE)/2);
00071     CALL\_SUBTEST\_4(( jacobi<MatrixXf, float>(MatrixXf(r,c)) ));
00072     CALL\_SUBTEST\_5(( jacobi<MatrixXcd, double>(MatrixXcd(r,c)) ));
00073     CALL\_SUBTEST\_5(( jacobi<MatrixXcd, std::complex<double> >(MatrixXcd(r,c)) ));
00074     \textcolor{comment}{// complex<float> is really important to test as it is the only way to cover conjugation issues in
       certain unaligned paths}
00075     CALL\_SUBTEST\_6(( jacobi<MatrixXcf, float>(MatrixXcf(r,c)) ));
00076     CALL\_SUBTEST\_6(( jacobi<MatrixXcf, std::complex<float> >(MatrixXcf(r,c)) ));
00077     
00078     TEST\_SET\_BUT\_UNUSED\_VARIABLE(r);
00079     TEST\_SET\_BUT\_UNUSED\_VARIABLE(c);
00080   \}
00081 \}
\end{DoxyCode}
