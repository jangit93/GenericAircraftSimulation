\hypertarget{matio_2visual__studio_2test_2eigen_2test_2ref_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/ref.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2ref_8cpp_source}\index{ref.\+cpp@{ref.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 20013 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{comment}{// This unit test cannot be easily written to work with EIGEN\_DEFAULT\_TO\_ROW\_MAJOR}
00011 \textcolor{preprocessor}{#ifdef EIGEN\_DEFAULT\_TO\_ROW\_MAJOR}
00012 \textcolor{preprocessor}{#undef EIGEN\_DEFAULT\_TO\_ROW\_MAJOR}
00013 \textcolor{preprocessor}{#endif}
00014 
00015 \textcolor{preprocessor}{#define TEST\_ENABLE\_TEMPORARY\_TRACKING}
00016 
00017 \textcolor{preprocessor}{#include "main.h"}
00018 
00019 \textcolor{comment}{// test Ref.h}
00020 
00021 \textcolor{comment}{// Deal with i387 extended precision}
00022 \textcolor{preprocessor}{#if EIGEN\_ARCH\_i386 && !(EIGEN\_ARCH\_x86\_64)}
00023 
00024 \textcolor{preprocessor}{#if EIGEN\_COMP\_GNUC\_STRICT && EIGEN\_GNUC\_AT\_LEAST(4,4)}
00025 \textcolor{preprocessor}{#pragma GCC optimize ("-ffloat-store")}
00026 \textcolor{preprocessor}{#else}
00027 \textcolor{preprocessor}{#undef VERIFY\_IS\_EQUAL}
00028 \textcolor{preprocessor}{#define VERIFY\_IS\_EQUAL(X,Y) VERIFY\_IS\_APPROX(X,Y)}
00029 \textcolor{preprocessor}{#endif}
00030 
00031 \textcolor{preprocessor}{#endif}
00032 
00033 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} ref\_matrix(\textcolor{keyword}{const} MatrixType& m)
00034 \{
00035   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00036   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00037   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00038   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Dynamic,Dynamic,MatrixType::Options>}
       DynMatrixType;
00039   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<RealScalar,Dynamic,Dynamic,MatrixType::Options>}
       RealDynMatrixType;
00040   
00041   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<MatrixType>} RefMat;
00042   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<DynMatrixType>} RefDynMat;
00043   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const DynMatrixType>} ConstRefDynMat;
00044   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<RealDynMatrixType , 0, Stride<Dynamic,Dynamic>}
       > RefRealMatWithStride;
00045 
00046   Index rows = m.rows(), cols = m.cols();
00047   
00048   MatrixType  m1 = MatrixType::Random(rows, cols),
00049               m2 = m1;
00050   
00051   Index i = internal::random<Index>(0,rows-1);
00052   Index j = internal::random<Index>(0,cols-1);
00053   Index brows = internal::random<Index>(1,rows-i);
00054   Index bcols = internal::random<Index>(1,cols-j);
00055   
00056   RefMat rm0 = m1;
00057   VERIFY\_IS\_EQUAL(rm0, m1);
00058   RefDynMat rm1 = m1;
00059   VERIFY\_IS\_EQUAL(rm1, m1);
00060   RefDynMat rm2 = m1.block(i,j,brows,bcols);
00061   VERIFY\_IS\_EQUAL(rm2, m1.block(i,j,brows,bcols));
00062   rm2.setOnes();
00063   m2.block(i,j,brows,bcols).setOnes();
00064   VERIFY\_IS\_EQUAL(m1, m2);
00065   
00066   m2.block(i,j,brows,bcols).setRandom();
00067   rm2 = m2.block(i,j,brows,bcols);
00068   VERIFY\_IS\_EQUAL(m1, m2);
00069   
00070   ConstRefDynMat rm3 = m1.block(i,j,brows,bcols);
00071   m1.block(i,j,brows,bcols) *= 2;
00072   m2.block(i,j,brows,bcols) *= 2;
00073   VERIFY\_IS\_EQUAL(rm3, m2.block(i,j,brows,bcols));
00074   RefRealMatWithStride rm4 = m1.real();
00075   VERIFY\_IS\_EQUAL(rm4, m2.real());
00076   rm4.array() += 1;
00077   m2.real().array() += 1;
00078   VERIFY\_IS\_EQUAL(m1, m2);
00079 \}
00080 
00081 \textcolor{keyword}{template}<\textcolor{keyword}{typename} VectorType> \textcolor{keywordtype}{void} ref\_vector(\textcolor{keyword}{const} \hyperlink{struct_vector_type}{VectorType}& m)
00082 \{
00083   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::Index Index;
00084   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::Scalar Scalar;
00085   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::RealScalar RealScalar;
00086   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Dynamic,1,VectorType::Options>} 
      DynMatrixType;
00087   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Dynamic,Dynamic,ColMajor>} MatrixType;
00088   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<RealScalar,Dynamic,1,VectorType::Options>} 
      RealDynMatrixType;
00089   
00090   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<VectorType>} RefMat;
00091   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<DynMatrixType>} RefDynMat;
00092   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const DynMatrixType>} ConstRefDynMat;
00093   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<RealDynMatrixType , 0, InnerStride<>} > 
      RefRealMatWithStride;
00094   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<DynMatrixType , 0, InnerStride<>} > RefMatWithStride;
00095 
00096   Index size = m.size();
00097   
00098   \hyperlink{struct_vector_type}{VectorType}  v1 = VectorType::Random(size),
00099               v2 = v1;
00100   MatrixType mat1 = MatrixType::Random(size,size),
00101              mat2 = mat1,
00102              mat3 = MatrixType::Random(size,size);
00103   
00104   Index i = internal::random<Index>(0,size-1);
00105   Index bsize = internal::random<Index>(1,size-i);
00106   
00107   RefMat rm0 = v1;
00108   VERIFY\_IS\_EQUAL(rm0, v1);
00109   RefDynMat rv1 = v1;
00110   VERIFY\_IS\_EQUAL(rv1, v1);
00111   RefDynMat rv2 = v1.segment(i,bsize);
00112   VERIFY\_IS\_EQUAL(rv2, v1.segment(i,bsize));
00113   rv2.setOnes();
00114   v2.segment(i,bsize).setOnes();
00115   VERIFY\_IS\_EQUAL(v1, v2);
00116   
00117   v2.segment(i,bsize).setRandom();
00118   rv2 = v2.segment(i,bsize);
00119   VERIFY\_IS\_EQUAL(v1, v2);
00120   
00121   ConstRefDynMat rm3 = v1.segment(i,bsize);
00122   v1.segment(i,bsize) *= 2;
00123   v2.segment(i,bsize) *= 2;
00124   VERIFY\_IS\_EQUAL(rm3, v2.segment(i,bsize));
00125   
00126   RefRealMatWithStride rm4 = v1.real();
00127   VERIFY\_IS\_EQUAL(rm4, v2.real());
00128   rm4.array() += 1;
00129   v2.real().array() += 1;
00130   VERIFY\_IS\_EQUAL(v1, v2);
00131   
00132   RefMatWithStride rm5 = mat1.row(i).transpose();
00133   VERIFY\_IS\_EQUAL(rm5, mat1.row(i).transpose());
00134   rm5.array() += 1;
00135   mat2.row(i).array() += 1;
00136   VERIFY\_IS\_EQUAL(mat1, mat2);
00137   rm5.noalias() = rm4.transpose() * mat3;
00138   mat2.row(i) = v2.real().transpose() * mat3;
00139   VERIFY\_IS\_APPROX(mat1, mat2);
00140 \}
00141 
00142 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType> \textcolor{keywordtype}{void} check\_const\_correctness(\textcolor{keyword}{const} PlainObjectType&)
00143 \{
00144   \textcolor{comment}{// verify that ref-to-const don't have LvalueBit}
00145   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_class_eigen_1_1_transpose}{internal::add\_const<PlainObjectType>::type} 
      ConstPlainObjectType;
00146   VERIFY( !(internal::traits<\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<ConstPlainObjectType>} >::Flags & 
      \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit}) );
00147   VERIFY( !(internal::traits<\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<ConstPlainObjectType, Aligned>} >::Flags 
      & \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit}) );
00148   VERIFY( !(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<ConstPlainObjectType>::Flags} & 
      \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit}) );
00149   VERIFY( !(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<ConstPlainObjectType, Aligned>::Flags} & 
      \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit}) );
00150 \}
00151 
00152 \textcolor{keyword}{template}<\textcolor{keyword}{typename} B>
00153 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} call\_ref\_1(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<VectorXf>} a, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix}{B} &b) \{ VERIFY\_IS\_EQUAL(a,b); \}
00154 \textcolor{keyword}{template}<\textcolor{keyword}{typename} B>
00155 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} call\_ref\_2(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const VectorXf>}& a, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{B} &b) \{ VERIFY\_IS\_EQUAL(a,b); \}
00156 \textcolor{keyword}{template}<\textcolor{keyword}{typename} B>
00157 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} call\_ref\_3(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}<VectorXf,0,\hyperlink{class_eigen_1_1_inner_stride}{InnerStride<>} > a, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{B} &b) \{ VERIFY\_IS\_EQUAL(a,b); \}
00158 \textcolor{keyword}{template}<\textcolor{keyword}{typename} B>
00159 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} call\_ref\_4(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}<\textcolor{keyword}{const} VectorXf,0,\hyperlink{class_eigen_1_1_inner_stride}{InnerStride<>} >& a, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{B} &b) \{ VERIFY\_IS\_EQUAL(a,b); \}
00160 \textcolor{keyword}{template}<\textcolor{keyword}{typename} B>
00161 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} call\_ref\_5(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}<MatrixXf,0,\hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>} > a, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{B} &b) \{ VERIFY\_IS\_EQUAL(a,b); \}
00162 \textcolor{keyword}{template}<\textcolor{keyword}{typename} B>
00163 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} call\_ref\_6(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}<\textcolor{keyword}{const} MatrixXf,0,\hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>} >& a, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{B} &b) \{ VERIFY\_IS\_EQUAL(a,b); \}
00164 \textcolor{keyword}{template}<\textcolor{keyword}{typename} B>
00165 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} call\_ref\_7(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,Dynamic,3>} > a, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{B} &b) \{ VERIFY\_IS\_EQUAL(a,b); \}
00166 
00167 \textcolor{keywordtype}{void} call\_ref()
00168 \{
00169   VectorXcf ca  = VectorXcf::Random(10);
00170   VectorXf a    = VectorXf::Random(10);
00171   RowVectorXf b = RowVectorXf::Random(10);
00172   MatrixXf \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}    = MatrixXf::Random(10,10);
00173   RowVector3f c = RowVector3f::Random();
00174   \textcolor{keyword}{const} VectorXf& ac(a);
00175   \hyperlink{group___core___module_class_eigen_1_1_vector_block}{VectorBlock<VectorXf>} ab(a,0,3);
00176   \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_vector_block}{VectorBlock<VectorXf>} abc(a,0,3);
00177   
00178 
00179   VERIFY\_EVALUATION\_COUNT( call\_ref\_1(a,a), 0);
00180   VERIFY\_EVALUATION\_COUNT( call\_ref\_1(b,b.transpose()), 0);
00181 \textcolor{comment}{//   call\_ref\_1(ac,a<c);           // does not compile because ac is const}
00182   VERIFY\_EVALUATION\_COUNT( call\_ref\_1(ab,ab), 0);
00183   VERIFY\_EVALUATION\_COUNT( call\_ref\_1(a.head(4),a.head(4)), 0);
00184   VERIFY\_EVALUATION\_COUNT( call\_ref\_1(abc,abc), 0);
00185   VERIFY\_EVALUATION\_COUNT( call\_ref\_1(A.col(3),A.col(3)), 0);
00186 \textcolor{comment}{//   call\_ref\_1(A.row(3),A.row(3));    // does not compile because innerstride!=1}
00187   VERIFY\_EVALUATION\_COUNT( call\_ref\_3(A.row(3),A.row(3).transpose()), 0);
00188   VERIFY\_EVALUATION\_COUNT( call\_ref\_4(A.row(3),A.row(3).transpose()), 0);
00189 \textcolor{comment}{//   call\_ref\_1(a+a, a+a);          // does not compile for obvious reason}
00190 
00191   MatrixXf tmp = A*A.col(1);
00192   VERIFY\_EVALUATION\_COUNT( call\_ref\_2(A*A.col(1), tmp), 1);     \textcolor{comment}{// evaluated into a temp}
00193   VERIFY\_EVALUATION\_COUNT( call\_ref\_2(ac.head(5),ac.head(5)), 0);
00194   VERIFY\_EVALUATION\_COUNT( call\_ref\_2(ac,ac), 0);
00195   VERIFY\_EVALUATION\_COUNT( call\_ref\_2(a,a), 0);
00196   VERIFY\_EVALUATION\_COUNT( call\_ref\_2(ab,ab), 0);
00197   VERIFY\_EVALUATION\_COUNT( call\_ref\_2(a.head(4),a.head(4)), 0);
00198   tmp = a+a;
00199   VERIFY\_EVALUATION\_COUNT( call\_ref\_2(a+a,tmp), 1);            \textcolor{comment}{// evaluated into a temp}
00200   VERIFY\_EVALUATION\_COUNT( call\_ref\_2(ca.imag(),ca.imag()), 1);      \textcolor{comment}{// evaluated into a temp}
00201 
00202   VERIFY\_EVALUATION\_COUNT( call\_ref\_4(ac.head(5),ac.head(5)), 0);
00203   tmp = a+a;
00204   VERIFY\_EVALUATION\_COUNT( call\_ref\_4(a+a,tmp), 1);           \textcolor{comment}{// evaluated into a temp}
00205   VERIFY\_EVALUATION\_COUNT( call\_ref\_4(ca.imag(),ca.imag()), 0);
00206 
00207   VERIFY\_EVALUATION\_COUNT( call\_ref\_5(a,a), 0);
00208   VERIFY\_EVALUATION\_COUNT( call\_ref\_5(a.head(3),a.head(3)), 0);
00209   VERIFY\_EVALUATION\_COUNT( call\_ref\_5(A,A), 0);
00210 \textcolor{comment}{//   call\_ref\_5(A.transpose(),A.transpose());   // does not compile because storage order does not match}
00211   VERIFY\_EVALUATION\_COUNT( call\_ref\_5(A.block(1,1,2,2),A.block(1,1,2,2)), 0);
00212   VERIFY\_EVALUATION\_COUNT( call\_ref\_5(b,b), 0);             \textcolor{comment}{// storage order do not match, but this is a
       degenerate case that should work}
00213   VERIFY\_EVALUATION\_COUNT( call\_ref\_5(a.row(3),a.row(3)), 0);
00214 
00215   VERIFY\_EVALUATION\_COUNT( call\_ref\_6(a,a), 0);
00216   VERIFY\_EVALUATION\_COUNT( call\_ref\_6(a.head(3),a.head(3)), 0);
00217   VERIFY\_EVALUATION\_COUNT( call\_ref\_6(A.row(3),A.row(3)), 1);           \textcolor{comment}{// evaluated into a temp thouth it
       could be avoided by viewing it as a 1xn matrix}
00218   tmp = A+A;
00219   VERIFY\_EVALUATION\_COUNT( call\_ref\_6(A+A,tmp), 1);                \textcolor{comment}{// evaluated into a temp}
00220   VERIFY\_EVALUATION\_COUNT( call\_ref\_6(A,A), 0);
00221   VERIFY\_EVALUATION\_COUNT( call\_ref\_6(A.transpose(),A.transpose()), 1);      \textcolor{comment}{// evaluated into a temp
       because the storage orders do not match}
00222   VERIFY\_EVALUATION\_COUNT( call\_ref\_6(A.block(1,1,2,2),A.block(1,1,2,2)), 0);
00223   
00224   VERIFY\_EVALUATION\_COUNT( call\_ref\_7(c,c), 0);
00225 \}
00226 
00227 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,Dynamic,Dynamic,RowMajor>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{RowMatrixXd};
00228 \textcolor{keywordtype}{int} test\_ref\_overload\_fun1(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<MatrixXd>} )       \{ \textcolor{keywordflow}{return} 1; \}
00229 \textcolor{keywordtype}{int} test\_ref\_overload\_fun1(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<RowMatrixXd>} )    \{ \textcolor{keywordflow}{return} 2; \}
00230 \textcolor{keywordtype}{int} test\_ref\_overload\_fun1(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<MatrixXf>} )       \{ \textcolor{keywordflow}{return} 3; \}
00231 
00232 \textcolor{keywordtype}{int} test\_ref\_overload\_fun2(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const MatrixXd>} ) \{ \textcolor{keywordflow}{return} 4; \}
00233 \textcolor{keywordtype}{int} test\_ref\_overload\_fun2(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const MatrixXf>} ) \{ \textcolor{keywordflow}{return} 5; \}
00234 
00235 \textcolor{keywordtype}{void} test\_ref\_ambiguous(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const ArrayXd>} &A, 
      \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<ArrayXd>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{B})
00236 \{
00237   B = A;
00238   B = A - A;
00239 \}
00240 
00241 \textcolor{comment}{// See also bug 969}
00242 \textcolor{keywordtype}{void} test\_ref\_overloads()
00243 \{
00244   MatrixXd Ad, Bd;
00245   RowMatrixXd rAd, rBd;
00246   VERIFY( test\_ref\_overload\_fun1(Ad)==1 );
00247   VERIFY( test\_ref\_overload\_fun1(rAd)==2 );
00248   
00249   MatrixXf Af, Bf;
00250   VERIFY( test\_ref\_overload\_fun2(Ad)==4 );
00251   VERIFY( test\_ref\_overload\_fun2(Ad+Bd)==4 );
00252   VERIFY( test\_ref\_overload\_fun2(Af+Bf)==5 );
00253   
00254   ArrayXd A, \hyperlink{group___core___module_class_eigen_1_1_matrix}{B};
00255   test\_ref\_ambiguous(A, B);
00256 \}
00257 
00258 \textcolor{keywordtype}{void} test\_ref()
00259 \{
00260   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00261     CALL\_SUBTEST\_1( ref\_vector(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00262     CALL\_SUBTEST\_1( check\_const\_correctness(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00263     CALL\_SUBTEST\_2( ref\_vector(Vector4d()) );
00264     CALL\_SUBTEST\_2( check\_const\_correctness(Matrix4d()) );
00265     CALL\_SUBTEST\_3( ref\_vector(Vector4cf()) );
00266     CALL\_SUBTEST\_4( ref\_vector(VectorXcf(8)) );
00267     CALL\_SUBTEST\_5( ref\_vector(VectorXi(12)) );
00268     CALL\_SUBTEST\_5( check\_const\_correctness(VectorXi(12)) );
00269 
00270     CALL\_SUBTEST\_1( ref\_matrix(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00271     CALL\_SUBTEST\_2( ref\_matrix(Matrix4d()) );
00272     CALL\_SUBTEST\_1( ref\_matrix(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,3,5>}()) );
00273     CALL\_SUBTEST\_4( ref\_matrix(MatrixXcf(internal::random<int>(1,10),internal::random<int>(1,10))) );
00274     CALL\_SUBTEST\_4( ref\_matrix(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<std::complex<double>,10,15>()) );
00275     CALL\_SUBTEST\_5( ref\_matrix(MatrixXi(internal::random<int>(1,10),internal::random<int>(1,10))) );
00276     CALL\_SUBTEST\_6( call\_ref() );
00277   \}
00278   
00279   CALL\_SUBTEST\_7( test\_ref\_overloads() );
00280 \}
\end{DoxyCode}
