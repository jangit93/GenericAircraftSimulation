\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_more_vectorization_2_math_functions_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+More\+Vectorization/\+Math\+Functions.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_more_vectorization_2_math_functions_8h_source}\index{Math\+Functions.\+h@{Math\+Functions.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Rohit Garg <rpg.314@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_MOREVECTORIZATION\_MATHFUNCTIONS\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_MOREVECTORIZATION\_MATHFUNCTIONS\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00017 
00019 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> \textcolor{keyword}{inline} \textcolor{keyword}{static} Packet pasin(Packet a) \{ \textcolor{keywordflow}{return} std::asin(a); \}
00020 
00021 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE}
00022 
00023 \textcolor{keyword}{template}<> EIGEN\_DONT\_INLINE Packet4f pasin(Packet4f x)
00024 \{
00025   \_EIGEN\_DECLARE\_CONST\_Packet4f(half, 0.5);
00026   \_EIGEN\_DECLARE\_CONST\_Packet4f(minus\_half, -0.5);
00027   \_EIGEN\_DECLARE\_CONST\_Packet4f(3half, 1.5);
00028 
00029   \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(sign\_mask, 0x80000000);
00030 
00031   \_EIGEN\_DECLARE\_CONST\_Packet4f(pi, 3.141592654);
00032   \_EIGEN\_DECLARE\_CONST\_Packet4f(pi\_over\_2, 3.141592654*0.5);
00033 
00034   \_EIGEN\_DECLARE\_CONST\_Packet4f(asin1, 4.2163199048E-2);
00035   \_EIGEN\_DECLARE\_CONST\_Packet4f(asin2, 2.4181311049E-2);
00036   \_EIGEN\_DECLARE\_CONST\_Packet4f(asin3, 4.5470025998E-2);
00037   \_EIGEN\_DECLARE\_CONST\_Packet4f(asin4, 7.4953002686E-2);
00038   \_EIGEN\_DECLARE\_CONST\_Packet4f(asin5, 1.6666752422E-1);
00039 
00040   Packet4f a = pabs(x);\textcolor{comment}{//got the absolute value}
00041 
00042   Packet4f sign\_bit= \_mm\_and\_ps(x, p4f\_sign\_mask);\textcolor{comment}{//extracted the sign bit}
00043 
00044   Packet4f z1,z2;\textcolor{comment}{//will need them during computation    }
00045 
00046 
00047 \textcolor{comment}{//will compute the two branches for asin}
00048 \textcolor{comment}{//so first compare with half}
00049 
00050   Packet4f branch\_mask= \_mm\_cmpgt\_ps(a, p4f\_half);\textcolor{comment}{//this is to select which branch to take}
00051 \textcolor{comment}{//both will be taken, and finally results will be merged}
00052 \textcolor{comment}{//the branch for values >0.5}
00053 
00054     \{
00055 \textcolor{comment}{//the core series expansion }
00056     z1=pmadd(p4f\_minus\_half,a,p4f\_half);
00057     Packet4f x1=psqrt(z1);
00058     Packet4f s1=pmadd(p4f\_asin1, z1, p4f\_asin2);
00059     Packet4f s2=pmadd(s1, z1, p4f\_asin3);
00060     Packet4f s3=pmadd(s2,z1, p4f\_asin4);
00061     Packet4f s4=pmadd(s3,z1, p4f\_asin5);
00062     Packet4f temp=pmul(s4,z1);\textcolor{comment}{//not really a madd but a mul by z so that the next term can be a madd}
00063     z1=pmadd(temp,x1,x1);
00064     z1=padd(z1,z1);
00065     z1=psub(p4f\_pi\_over\_2,z1);
00066     \}
00067 
00068     \{
00069 \textcolor{comment}{//the core series expansion }
00070     Packet4f x2=a;
00071     z2=pmul(x2,x2);
00072     Packet4f s1=pmadd(p4f\_asin1, z2, p4f\_asin2);
00073     Packet4f s2=pmadd(s1, z2, p4f\_asin3);
00074     Packet4f s3=pmadd(s2,z2, p4f\_asin4);
00075     Packet4f s4=pmadd(s3,z2, p4f\_asin5);
00076     Packet4f temp=pmul(s4,z2);\textcolor{comment}{//not really a madd but a mul by z so that the next term can be a madd}
00077     z2=pmadd(temp,x2,x2);
00078     \}
00079 
00080 \textcolor{comment}{/* select the correct result from the two branch evaluations */}
00081   z1  = \_mm\_and\_ps(branch\_mask, z1);
00082   z2  = \_mm\_andnot\_ps(branch\_mask, z2);
00083   Packet4f z  = \_mm\_or\_ps(z1,z2);
00084 
00085 \textcolor{comment}{/* update the sign */}
00086   \textcolor{keywordflow}{return} \_mm\_xor\_ps(z, sign\_bit);
00087 \}
00088 
00089 \textcolor{preprocessor}{#endif // EIGEN\_VECTORIZE\_SSE}
00090 
00091 \} \textcolor{comment}{// end namespace internal}
00092 
00093 \} \textcolor{comment}{// end namespace Eigen}
00094 
00095 \textcolor{preprocessor}{#endif // EIGEN\_MOREVECTORIZATION\_MATHFUNCTIONS\_H}
\end{DoxyCode}
