\hypertarget{visual__studio_2zlib_2contrib_2puff_2pufftest_8c_source}{}\section{visual\+\_\+studio/zlib/contrib/puff/pufftest.c}
\label{visual__studio_2zlib_2contrib_2puff_2pufftest_8c_source}\index{pufftest.\+c@{pufftest.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * pufftest.c}
00003 \textcolor{comment}{ * Copyright (C) 2002-2013 Mark Adler}
00004 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in puff.h}
00005 \textcolor{comment}{ * version 2.3, 21 Jan 2013}
00006 \textcolor{comment}{ */}
00007 
00008 \textcolor{comment}{/* Example of how to use puff().}
00009 \textcolor{comment}{}
00010 \textcolor{comment}{   Usage: puff [-w] [-f] [-nnn] file}
00011 \textcolor{comment}{          ... | puff [-w] [-f] [-nnn]}
00012 \textcolor{comment}{}
00013 \textcolor{comment}{   where file is the input file with deflate data, nnn is the number of bytes}
00014 \textcolor{comment}{   of input to skip before inflating (e.g. to skip a zlib or gzip header), and}
00015 \textcolor{comment}{   -w is used to write the decompressed data to stdout.  -f is for coverage}
00016 \textcolor{comment}{   testing, and causes pufftest to fail with not enough output space (-f does}
00017 \textcolor{comment}{   a write like -w, so -w is not required). */}
00018 
00019 \textcolor{preprocessor}{#include <stdio.h>}
00020 \textcolor{preprocessor}{#include <stdlib.h>}
00021 \textcolor{preprocessor}{#include "puff.h"}
00022 
00023 \textcolor{preprocessor}{#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(\_\_CYGWIN\_\_)}
00024 \textcolor{preprocessor}{#  include <fcntl.h>}
00025 \textcolor{preprocessor}{#  include <io.h>}
00026 \textcolor{preprocessor}{#  define SET\_BINARY\_MODE(file) setmode(fileno(file), O\_BINARY)}
00027 \textcolor{preprocessor}{#else}
00028 \textcolor{preprocessor}{#  define SET\_BINARY\_MODE(file)}
00029 \textcolor{preprocessor}{#endif}
00030 
00031 \textcolor{preprocessor}{#define local static}
00032 
00033 \textcolor{comment}{/* Return size times approximately the cube root of 2, keeping the result as 1,}
00034 \textcolor{comment}{   3, or 5 times a power of 2 -- the result is always > size, until the result}
00035 \textcolor{comment}{   is the maximum value of an unsigned long, where it remains.  This is useful}
00036 \textcolor{comment}{   to keep reallocations less than ~33% over the actual data. */}
00037 local \textcolor{keywordtype}{size\_t} bythirds(\textcolor{keywordtype}{size\_t} size)
00038 \{
00039     \textcolor{keywordtype}{int} n;
00040     \textcolor{keywordtype}{size\_t} m;
00041 
00042     m = size;
00043     \textcolor{keywordflow}{for} (n = 0; m; n++)
00044         m >>= 1;
00045     \textcolor{keywordflow}{if} (n < 3)
00046         \textcolor{keywordflow}{return} size + 1;
00047     n -= 3;
00048     m = size >> n;
00049     m += m == 6 ? 2 : 1;
00050     m <<= n;
00051     \textcolor{keywordflow}{return} m > size ? m : (size\_t)(-1);
00052 \}
00053 
00054 \textcolor{comment}{/* Read the input file *name, or stdin if name is NULL, into allocated memory.}
00055 \textcolor{comment}{   Reallocate to larger buffers until the entire file is read in.  Return a}
00056 \textcolor{comment}{   pointer to the allocated data, or NULL if there was a memory allocation}
00057 \textcolor{comment}{   failure.  *len is the number of bytes of data read from the input file (even}
00058 \textcolor{comment}{   if load() returns NULL).  If the input file was empty or could not be opened}
00059 \textcolor{comment}{   or read, *len is zero. */}
00060 local \textcolor{keywordtype}{void} *load(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *name, \textcolor{keywordtype}{size\_t} *len)
00061 \{
00062     \textcolor{keywordtype}{size\_t} size;
00063     \textcolor{keywordtype}{void} *buf, *\hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap};
00064     FILE *in;
00065 
00066     *len = 0;
00067     buf = malloc(size = 4096);
00068     \textcolor{keywordflow}{if} (buf == NULL)
00069         \textcolor{keywordflow}{return} NULL;
00070     in = name == NULL ? stdin : fopen(name, \textcolor{stringliteral}{"rb"});
00071     \textcolor{keywordflow}{if} (in != NULL) \{
00072         \textcolor{keywordflow}{for} (;;) \{
00073             *len += fread((\textcolor{keywordtype}{char} *)buf + *len, 1, size - *len, in);
00074             \textcolor{keywordflow}{if} (*len < size) \textcolor{keywordflow}{break};
00075             size = bythirds(size);
00076             \textcolor{keywordflow}{if} (size == *len || (swap = realloc(buf, size)) == NULL) \{
00077                 free(buf);
00078                 buf = NULL;
00079                 \textcolor{keywordflow}{break};
00080             \}
00081             buf = \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap};
00082         \}
00083         fclose(in);
00084     \}
00085     \textcolor{keywordflow}{return} buf;
00086 \}
00087 
00088 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
00089 \{
00090     \textcolor{keywordtype}{int} ret, put = 0, fail = 0;
00091     \textcolor{keywordtype}{unsigned} skip = 0;
00092     \textcolor{keywordtype}{char} *arg, *name = NULL;
00093     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *source = NULL, *dest;
00094     \textcolor{keywordtype}{size\_t} len = 0;
00095     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} sourcelen, destlen;
00096 
00097     \textcolor{comment}{/* process arguments */}
00098     \textcolor{keywordflow}{while} (arg = *++argv, --argc)
00099         \textcolor{keywordflow}{if} (arg[0] == \textcolor{charliteral}{'-'}) \{
00100             \textcolor{keywordflow}{if} (arg[1] == \textcolor{charliteral}{'w'} && arg[2] == 0)
00101                 put = 1;
00102             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg[1] == \textcolor{charliteral}{'f'} && arg[2] == 0)
00103                 fail = 1, put = 1;
00104             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg[1] >= \textcolor{charliteral}{'0'} && arg[1] <= \textcolor{charliteral}{'9'})
00105                 skip = (unsigned)atoi(arg + 1);
00106             \textcolor{keywordflow}{else} \{
00107                 fprintf(stderr, \textcolor{stringliteral}{"invalid option %s\(\backslash\)n"}, arg);
00108                 \textcolor{keywordflow}{return} 3;
00109             \}
00110         \}
00111         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (name != NULL) \{
00112             fprintf(stderr, \textcolor{stringliteral}{"only one file name allowed\(\backslash\)n"});
00113             \textcolor{keywordflow}{return} 3;
00114         \}
00115         \textcolor{keywordflow}{else}
00116             name = arg;
00117     source = load(name, &len);
00118     \textcolor{keywordflow}{if} (source == NULL) \{
00119         fprintf(stderr, \textcolor{stringliteral}{"memory allocation failure\(\backslash\)n"});
00120         \textcolor{keywordflow}{return} 4;
00121     \}
00122     \textcolor{keywordflow}{if} (len == 0) \{
00123         fprintf(stderr, \textcolor{stringliteral}{"could not read %s, or it was empty\(\backslash\)n"},
00124                 name == NULL ? \textcolor{stringliteral}{"<stdin>"} : name);
00125         free(source);
00126         \textcolor{keywordflow}{return} 3;
00127     \}
00128     \textcolor{keywordflow}{if} (skip >= len) \{
00129         fprintf(stderr, \textcolor{stringliteral}{"skip request of %d leaves no input\(\backslash\)n"}, skip);
00130         free(source);
00131         \textcolor{keywordflow}{return} 3;
00132     \}
00133 
00134     \textcolor{comment}{/* test inflate data with offset skip */}
00135     len -= skip;
00136     sourcelen = (\textcolor{keywordtype}{unsigned} long)len;
00137     ret = puff(NIL, &destlen, source + skip, &sourcelen);
00138     \textcolor{keywordflow}{if} (ret)
00139         fprintf(stderr, \textcolor{stringliteral}{"puff() failed with return code %d\(\backslash\)n"}, ret);
00140     \textcolor{keywordflow}{else} \{
00141         fprintf(stderr, \textcolor{stringliteral}{"puff() succeeded uncompressing %lu bytes\(\backslash\)n"}, destlen);
00142         \textcolor{keywordflow}{if} (sourcelen < len) fprintf(stderr, \textcolor{stringliteral}{"%lu compressed bytes unused\(\backslash\)n"},
00143                                      len - sourcelen);
00144     \}
00145 
00146     \textcolor{comment}{/* if requested, inflate again and write decompressd data to stdout */}
00147     \textcolor{keywordflow}{if} (put && ret == 0) \{
00148         \textcolor{keywordflow}{if} (fail)
00149             destlen >>= 1;
00150         dest = malloc(destlen);
00151         \textcolor{keywordflow}{if} (dest == NULL) \{
00152             fprintf(stderr, \textcolor{stringliteral}{"memory allocation failure\(\backslash\)n"});
00153             free(source);
00154             \textcolor{keywordflow}{return} 4;
00155         \}
00156         puff(dest, &destlen, source + skip, &sourcelen);
00157         SET\_BINARY\_MODE(stdout);
00158         fwrite(dest, 1, destlen, stdout);
00159         free(dest);
00160     \}
00161 
00162     \textcolor{comment}{/* clean up */}
00163     free(source);
00164     \textcolor{keywordflow}{return} ret;
00165 \}
\end{DoxyCode}
