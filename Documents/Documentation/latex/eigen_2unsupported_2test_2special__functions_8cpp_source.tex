\hypertarget{eigen_2unsupported_2test_2special__functions_8cpp_source}{}\section{eigen/unsupported/test/special\+\_\+functions.cpp}
\label{eigen_2unsupported_2test_2special__functions_8cpp_source}\index{special\+\_\+functions.\+cpp@{special\+\_\+functions.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2016 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 \textcolor{preprocessor}{#include "../Eigen/SpecialFunctions"}
00012 
00013 \textcolor{keyword}{template}<\textcolor{keyword}{typename} X, \textcolor{keyword}{typename} Y>
00014 \textcolor{keywordtype}{void} verify\_component\_wise(\textcolor{keyword}{const} X& x, \textcolor{keyword}{const} Y& y)
00015 \{
00016   \textcolor{keywordflow}{for}(Index i=0; i<x.size(); ++i)
00017   \{
00018     \textcolor{keywordflow}{if}((numext::isfinite)(y(i)))
00019       VERIFY\_IS\_APPROX( x(i), y(i) );
00020     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((numext::isnan)(y(i)))
00021       VERIFY((numext::isnan)(x(i)));
00022     \textcolor{keywordflow}{else}
00023       VERIFY\_IS\_EQUAL( x(i), y(i) );
00024   \}
00025 \}
00026 
00027 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArrayType> \textcolor{keywordtype}{void} array\_special\_functions()
00028 \{
00029   \textcolor{keyword}{using} std::abs;
00030   \textcolor{keyword}{using} std::sqrt;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ArrayType::Scalar Scalar;
00032   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar;
00033 
00034   Scalar plusinf = std::numeric\_limits<Scalar>::infinity();
00035   Scalar nan = std::numeric\_limits<Scalar>::quiet\_NaN();
00036 
00037   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows = internal::random<Index>(1,30);
00038   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols = 1;
00039 
00040   \textcolor{comment}{// API}
00041   \{
00042     ArrayType m1 = ArrayType::Random(rows,cols);
00043 \textcolor{preprocessor}{#if EIGEN\_HAS\_C99\_MATH}
00044     VERIFY\_IS\_APPROX(m1.lgamma(), lgamma(m1));
00045     VERIFY\_IS\_APPROX(m1.digamma(), digamma(m1));
00046     VERIFY\_IS\_APPROX(m1.erf(), erf(m1));
00047     VERIFY\_IS\_APPROX(m1.erfc(), erfc(m1));
00048 \textcolor{preprocessor}{#endif  // EIGEN\_HAS\_C99\_MATH}
00049   \}
00050 
00051 
00052 \textcolor{preprocessor}{#if EIGEN\_HAS\_C99\_MATH}
00053   \textcolor{comment}{// check special functions (comparing against numpy implementation)}
00054   \textcolor{keywordflow}{if} (!NumTraits<Scalar>::IsComplex)
00055   \{
00056 
00057     \{
00058       ArrayType m1 = ArrayType::Random(rows,cols);
00059       ArrayType m2 = ArrayType::Random(rows,cols);
00060 
00061       \textcolor{comment}{// Test various propreties of igamma & igammac.  These are normalized}
00062       \textcolor{comment}{// gamma integrals where}
00063       \textcolor{comment}{//   igammac(a, x) = Gamma(a, x) / Gamma(a)}
00064       \textcolor{comment}{//   igamma(a, x) = gamma(a, x) / Gamma(a)}
00065       \textcolor{comment}{// where Gamma and gamma are considered the standard unnormalized}
00066       \textcolor{comment}{// upper and lower incomplete gamma functions, respectively.}
00067       ArrayType a = m1.abs() + 2;
00068       ArrayType x = m2.abs() + 2;
00069       ArrayType zero = ArrayType::Zero(rows, cols);
00070       ArrayType one = ArrayType::Constant(rows, cols, Scalar(1.0));
00071       ArrayType a\_m1 = a - one;
00072       ArrayType Gamma\_a\_x = \hyperlink{namespace_eigen_a1abaa2ff8c7b1871eaf026a47c6bbf3b}{Eigen::igammac}(a, x) * a.lgamma().exp();
00073       ArrayType Gamma\_a\_m1\_x = \hyperlink{namespace_eigen_a1abaa2ff8c7b1871eaf026a47c6bbf3b}{Eigen::igammac}(a\_m1, x) * a\_m1.lgamma().exp();
00074       ArrayType gamma\_a\_x = \hyperlink{namespace_eigen_af5aa651137636b1cdbd27de1cfe91148}{Eigen::igamma}(a, x) * a.lgamma().exp();
00075       ArrayType gamma\_a\_m1\_x = \hyperlink{namespace_eigen_af5aa651137636b1cdbd27de1cfe91148}{Eigen::igamma}(a\_m1, x) * a\_m1.lgamma().exp();
00076 
00077       \textcolor{comment}{// Gamma(a, 0) == Gamma(a)}
00078       VERIFY\_IS\_APPROX(\hyperlink{namespace_eigen_a1abaa2ff8c7b1871eaf026a47c6bbf3b}{Eigen::igammac}(a, zero), one);
00079 
00080       \textcolor{comment}{// Gamma(a, x) + gamma(a, x) == Gamma(a)}
00081       VERIFY\_IS\_APPROX(Gamma\_a\_x + gamma\_a\_x, a.lgamma().exp());
00082 
00083       \textcolor{comment}{// Gamma(a, x) == (a - 1) * Gamma(a-1, x) + x^(a-1) * exp(-x)}
00084       VERIFY\_IS\_APPROX(Gamma\_a\_x, (a - 1) * Gamma\_a\_m1\_x + x.pow(a-1) * (-x).exp());
00085 
00086       \textcolor{comment}{// gamma(a, x) == (a - 1) * gamma(a-1, x) - x^(a-1) * exp(-x)}
00087       VERIFY\_IS\_APPROX(gamma\_a\_x, (a - 1) * gamma\_a\_m1\_x - x.pow(a-1) * (-x).exp());
00088     \}
00089 
00090     \{
00091       \textcolor{comment}{// Check exact values of igamma and igammac against a third party calculation.}
00092       Scalar a\_s[] = \{Scalar(0), Scalar(1), Scalar(1.5), Scalar(4), Scalar(0.0001), Scalar(1000.5)\};
00093       Scalar x\_s[] = \{Scalar(0), Scalar(1), Scalar(1.5), Scalar(4), Scalar(0.0001), Scalar(1000.5)\};
00094 
00095       \textcolor{comment}{// location i*6+j corresponds to a\_s[i], x\_s[j].}
00096       Scalar igamma\_s[][6] = \{\{0.0, nan, nan, nan, nan, nan\},
00097                               \{0.0, 0.6321205588285578, 0.7768698398515702,
00098                               0.9816843611112658, 9.999500016666262e-05, 1.0\},
00099                               \{0.0, 0.4275932955291202, 0.608374823728911,
00100                               0.9539882943107686, 7.522076445089201e-07, 1.0\},
00101                               \{0.0, 0.01898815687615381, 0.06564245437845008,
00102                               0.5665298796332909, 4.166333347221828e-18, 1.0\},
00103                               \{0.0, 0.9999780593618628, 0.9999899967080838,
00104                               0.9999996219837988, 0.9991370418689945, 1.0\},
00105                               \{0.0, 0.0, 0.0, 0.0, 0.0, 0.5042041932513908\}\};
00106       Scalar igammac\_s[][6] = \{\{nan, nan, nan, nan, nan, nan\},
00107                               \{1.0, 0.36787944117144233, 0.22313016014842982,
00108                                 0.018315638888734182, 0.9999000049998333, 0.0\},
00109                               \{1.0, 0.5724067044708798, 0.3916251762710878,
00110                                 0.04601170568923136, 0.9999992477923555, 0.0\},
00111                               \{1.0, 0.9810118431238462, 0.9343575456215499,
00112                                 0.4334701203667089, 1.0, 0.0\},
00113                               \{1.0, 2.1940638138146658e-05, 1.0003291916285e-05,
00114                                 3.7801620118431334e-07, 0.0008629581310054535,
00115                                 0.0\},
00116                               \{1.0, 1.0, 1.0, 1.0, 1.0, 0.49579580674813944\}\};
00117       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 6; ++i) \{
00118         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 6; ++j) \{
00119           \textcolor{keywordflow}{if} ((std::isnan)(igamma\_s[i][j])) \{
00120             VERIFY((std::isnan)(numext::igamma(a\_s[i], x\_s[j])));
00121           \} \textcolor{keywordflow}{else} \{
00122             VERIFY\_IS\_APPROX(numext::igamma(a\_s[i], x\_s[j]), igamma\_s[i][j]);
00123           \}
00124 
00125           \textcolor{keywordflow}{if} ((std::isnan)(igammac\_s[i][j])) \{
00126             VERIFY((std::isnan)(numext::igammac(a\_s[i], x\_s[j])));
00127           \} \textcolor{keywordflow}{else} \{
00128             VERIFY\_IS\_APPROX(numext::igammac(a\_s[i], x\_s[j]), igammac\_s[i][j]);
00129           \}
00130         \}
00131       \}
00132     \}
00133   \}
00134 \textcolor{preprocessor}{#endif  // EIGEN\_HAS\_C99\_MATH}
00135 
00136   \textcolor{comment}{// Check the zeta function against scipy.special.zeta}
00137   \{
00138     ArrayType x(7), q(7), res(7), ref(7);
00139     x << 1.5,   4, 10.5, 10000.5,    3, 1,        0.9;
00140     q << 2,   1.5,    3,  1.0001, -2.5, 1.2345, 1.2345;
00141     ref << 1.61237534869, 0.234848505667, 1.03086757337e-5, 0.367879440865, 0.054102025820864097, plusinf, 
      nan;
00142     CALL\_SUBTEST( verify\_component\_wise(ref, ref); );
00143     CALL\_SUBTEST( res = x.zeta(q); verify\_component\_wise(res, ref); );
00144     CALL\_SUBTEST( res = zeta(x,q); verify\_component\_wise(res, ref); );
00145   \}
00146 
00147   \textcolor{comment}{// digamma}
00148   \{
00149     ArrayType x(7), res(7), ref(7);
00150     x << 1, 1.5, 4, -10.5, 10000.5, 0, -1;
00151     ref << -0.5772156649015329, 0.03648997397857645, 1.2561176684318, 2.398239129535781, 9.210340372392849,
       plusinf, plusinf;
00152     CALL\_SUBTEST( verify\_component\_wise(ref, ref); );
00153 
00154     CALL\_SUBTEST( res = x.digamma(); verify\_component\_wise(res, ref); );
00155     CALL\_SUBTEST( res = digamma(x);  verify\_component\_wise(res, ref); );
00156   \}
00157 
00158 
00159 \textcolor{preprocessor}{#if EIGEN\_HAS\_C99\_MATH}
00160   \{
00161     ArrayType n(11), x(11), res(11), ref(11);
00162     n << 1, 1,    1, 1.5,   17,   31,   28,    8, 42, 147, 170;
00163     x << 2, 3, 25.5, 1.5,  4.7, 11.8, 17.7, 30.2, 15.8, 54.1, 64;
00164     ref << 0.644934066848, 0.394934066848, 0.0399946696496, nan, 293.334565435, 0.445487887616, -2.47810300
      902e-07, -8.29668781082e-09, -0.434562276666, 0.567742190178, -0.0108615497927;
00165     CALL\_SUBTEST( verify\_component\_wise(ref, ref); );
00166 
00167     \textcolor{keywordflow}{if}(\textcolor{keyword}{sizeof}(RealScalar)>=8) \{  \textcolor{comment}{// double}
00168       \textcolor{comment}{// Reason for commented line: http://eigen.tuxfamily.org/bz/show\_bug.cgi?id=1232}
00169       \textcolor{comment}{//       CALL\_SUBTEST( res = x.polygamma(n); verify\_component\_wise(res, ref); );}
00170       CALL\_SUBTEST( res = \hyperlink{namespace_eigen_ae3b47a13a0699f5dbaa0623c11333dca}{polygamma}(n,x);  verify\_component\_wise(res, ref); );
00171     \}
00172     \textcolor{keywordflow}{else} \{
00173       \textcolor{comment}{//       CALL\_SUBTEST( res = x.polygamma(n); verify\_component\_wise(res.head(8), ref.head(8)); );}
00174       CALL\_SUBTEST( res = \hyperlink{namespace_eigen_ae3b47a13a0699f5dbaa0623c11333dca}{polygamma}(n,x); verify\_component\_wise(res.head(8), ref.head(8)); );
00175     \}
00176   \}
00177 \textcolor{preprocessor}{#endif}
00178 
00179 \textcolor{preprocessor}{#if EIGEN\_HAS\_C99\_MATH}
00180   \{
00181     \textcolor{comment}{// Inputs and ground truth generated with scipy via:}
00182     \textcolor{comment}{//   a = np.logspace(-3, 3, 5) - 1e-3}
00183     \textcolor{comment}{//   b = np.logspace(-3, 3, 5) - 1e-3}
00184     \textcolor{comment}{//   x = np.linspace(-0.1, 1.1, 5)}
00185     \textcolor{comment}{//   (full\_a, full\_b, full\_x) = np.vectorize(lambda a, b, x: (a, b, x))(*np.ix\_(a, b, x))}
00186     \textcolor{comment}{//   full\_a = full\_a.flatten().tolist()  # same for full\_b, full\_x}
00187     \textcolor{comment}{//   v = scipy.special.betainc(full\_a, full\_b, full\_x).flatten().tolist()}
00188     \textcolor{comment}{//}
00189     \textcolor{comment}{// Note in Eigen, we call betainc with arguments in the order (x, a, b).}
00190     ArrayType a(125);
00191     ArrayType b(125);
00192     ArrayType x(125);
00193     ArrayType v(125);
00194     ArrayType res(125);
00195 
00196     a << 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
00197         0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
00198         0.03062277660168379, 0.03062277660168379, 0.03062277660168379,
00199         0.03062277660168379, 0.03062277660168379, 0.03062277660168379,
00200         0.03062277660168379, 0.03062277660168379, 0.03062277660168379,
00201         0.03062277660168379, 0.03062277660168379, 0.03062277660168379,
00202         0.03062277660168379, 0.03062277660168379, 0.03062277660168379,
00203         0.03062277660168379, 0.03062277660168379, 0.03062277660168379,
00204         0.03062277660168379, 0.03062277660168379, 0.03062277660168379,
00205         0.03062277660168379, 0.03062277660168379, 0.03062277660168379,
00206         0.03062277660168379, 0.999, 0.999, 0.999, 0.999, 0.999, 0.999, 0.999,
00207         0.999, 0.999, 0.999, 0.999, 0.999, 0.999, 0.999, 0.999, 0.999, 0.999,
00208         0.999, 0.999, 0.999, 0.999, 0.999, 0.999, 0.999, 0.999,
00209         31.62177660168379, 31.62177660168379, 31.62177660168379,
00210         31.62177660168379, 31.62177660168379, 31.62177660168379,
00211         31.62177660168379, 31.62177660168379, 31.62177660168379,
00212         31.62177660168379, 31.62177660168379, 31.62177660168379,
00213         31.62177660168379, 31.62177660168379, 31.62177660168379,
00214         31.62177660168379, 31.62177660168379, 31.62177660168379,
00215         31.62177660168379, 31.62177660168379, 31.62177660168379,
00216         31.62177660168379, 31.62177660168379, 31.62177660168379,
00217         31.62177660168379, 999.999, 999.999, 999.999, 999.999, 999.999, 999.999,
00218         999.999, 999.999, 999.999, 999.999, 999.999, 999.999, 999.999, 999.999,
00219         999.999, 999.999, 999.999, 999.999, 999.999, 999.999, 999.999, 999.999,
00220         999.999, 999.999, 999.999;
00221 
00222     b << 0.0, 0.0, 0.0, 0.0, 0.0, 0.03062277660168379, 0.03062277660168379,
00223         0.03062277660168379, 0.03062277660168379, 0.03062277660168379, 0.999,
00224         0.999, 0.999, 0.999, 0.999, 31.62177660168379, 31.62177660168379,
00225         31.62177660168379, 31.62177660168379, 31.62177660168379, 999.999,
00226         999.999, 999.999, 999.999, 999.999, 0.0, 0.0, 0.0, 0.0, 0.0,
00227         0.03062277660168379, 0.03062277660168379, 0.03062277660168379,
00228         0.03062277660168379, 0.03062277660168379, 0.999, 0.999, 0.999, 0.999,
00229         0.999, 31.62177660168379, 31.62177660168379, 31.62177660168379,
00230         31.62177660168379, 31.62177660168379, 999.999, 999.999, 999.999,
00231         999.999, 999.999, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03062277660168379,
00232         0.03062277660168379, 0.03062277660168379, 0.03062277660168379,
00233         0.03062277660168379, 0.999, 0.999, 0.999, 0.999, 0.999,
00234         31.62177660168379, 31.62177660168379, 31.62177660168379,
00235         31.62177660168379, 31.62177660168379, 999.999, 999.999, 999.999,
00236         999.999, 999.999, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03062277660168379,
00237         0.03062277660168379, 0.03062277660168379, 0.03062277660168379,
00238         0.03062277660168379, 0.999, 0.999, 0.999, 0.999, 0.999,
00239         31.62177660168379, 31.62177660168379, 31.62177660168379,
00240         31.62177660168379, 31.62177660168379, 999.999, 999.999, 999.999,
00241         999.999, 999.999, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03062277660168379,
00242         0.03062277660168379, 0.03062277660168379, 0.03062277660168379,
00243         0.03062277660168379, 0.999, 0.999, 0.999, 0.999, 0.999,
00244         31.62177660168379, 31.62177660168379, 31.62177660168379,
00245         31.62177660168379, 31.62177660168379, 999.999, 999.999, 999.999,
00246         999.999, 999.999;
00247 
00248     x << -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5,
00249         0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2,
00250         0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1,
00251         0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1,
00252         -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8,
00253         1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5,
00254         0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2,
00255         0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1,
00256         0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5, 0.8, 1.1, -0.1, 0.2, 0.5,
00257         0.8, 1.1;
00258 
00259     v << nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan,
00260         nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan,
00261         nan, nan, nan, 0.47972119876364683, 0.5, 0.5202788012363533, nan, nan,
00262         0.9518683957740043, 0.9789663010413743, 0.9931729188073435, nan, nan,
00263         0.999995949033062, 0.9999999999993698, 0.9999999999999999, nan, nan,
00264         0.9999999999999999, 0.9999999999999999, 0.9999999999999999, nan, nan,
00265         nan, nan, nan, nan, nan, 0.006827081192655869, 0.0210336989586256,
00266         0.04813160422599567, nan, nan, 0.20014344256217678, 0.5000000000000001,
00267         0.7998565574378232, nan, nan, 0.9991401428435834, 0.999999999698403,
00268         0.9999999999999999, nan, nan, 0.9999999999999999, 0.9999999999999999,
00269         0.9999999999999999, nan, nan, nan, nan, nan, nan, nan,
00270         1.0646600232370887e-25, 6.301722877826246e-13, 4.050966937974938e-06,
00271         nan, nan, 7.864342668429763e-23, 3.015969667594166e-10,
00272         0.0008598571564165444, nan, nan, 6.031987710123844e-08,
00273         0.5000000000000007, 0.9999999396801229, nan, nan, 0.9999999999999999,
00274         0.9999999999999999, 0.9999999999999999, nan, nan, nan, nan, nan, nan,
00275         nan, 0.0, 7.029920380986636e-306, 2.2450728208591345e-101, nan, nan,
00276         0.0, 9.275871147869727e-302, 1.2232913026152827e-97, nan, nan, 0.0,
00277         3.0891393081932924e-252, 2.9303043666183996e-60, nan, nan,
00278         2.248913486879199e-196, 0.5000000000004947, 0.9999999999999999, nan;
00279 
00280     CALL\_SUBTEST(res = \hyperlink{namespace_eigen_a726eae91d4e91d8e25cbe55fffa6a92f}{betainc}(a, b, x);
00281                  verify\_component\_wise(res, v););
00282   \}
00283 
00284   \textcolor{comment}{// Test various properties of betainc}
00285   \{
00286     ArrayType m1 = ArrayType::Random(32);
00287     ArrayType m2 = ArrayType::Random(32);
00288     ArrayType m3 = ArrayType::Random(32);
00289     ArrayType one = ArrayType::Constant(32, Scalar(1.0));
00290     \textcolor{keyword}{const} Scalar eps = std::numeric\_limits<Scalar>::epsilon();
00291     ArrayType a = (m1 * 4.0).exp();
00292     ArrayType b = (m2 * 4.0).exp();
00293     ArrayType x = m3.abs();
00294 
00295     \textcolor{comment}{// betainc(a, 1, x) == x**a}
00296     CALL\_SUBTEST(
00297         ArrayType test = \hyperlink{namespace_eigen_a726eae91d4e91d8e25cbe55fffa6a92f}{betainc}(a, one, x);
00298         ArrayType expected = x.pow(a);
00299         verify\_component\_wise(test, expected););
00300 
00301     \textcolor{comment}{// betainc(1, b, x) == 1 - (1 - x)**b}
00302     CALL\_SUBTEST(
00303         ArrayType test = \hyperlink{namespace_eigen_a726eae91d4e91d8e25cbe55fffa6a92f}{betainc}(one, b, x);
00304         ArrayType expected = one - (one - x).\hyperlink{group___core___module_ab6dc101d82e8228a19a8840e3a29c1c9}{pow}(b);
00305         verify\_component\_wise(test, expected););
00306 
00307     \textcolor{comment}{// betainc(a, b, x) == 1 - betainc(b, a, 1-x)}
00308     CALL\_SUBTEST(
00309         ArrayType test = \hyperlink{namespace_eigen_a726eae91d4e91d8e25cbe55fffa6a92f}{betainc}(a, b, x) + \hyperlink{namespace_eigen_a726eae91d4e91d8e25cbe55fffa6a92f}{betainc}(b, a, one - x);
00310         ArrayType expected = one;
00311         verify\_component\_wise(test, expected););
00312 
00313     \textcolor{comment}{// betainc(a+1, b, x) = betainc(a, b, x) - x**a * (1 - x)**b / (a * beta(a, b))}
00314     CALL\_SUBTEST(
00315         ArrayType num = x.pow(a) * (one - x).\hyperlink{group___core___module_ab6dc101d82e8228a19a8840e3a29c1c9}{pow}(b);
00316         ArrayType denom = a * (a.lgamma() + b.lgamma() - (a + b).lgamma()).exp();
00317         \textcolor{comment}{// Add eps to rhs and lhs so that component-wise test doesn't result in}
00318         \textcolor{comment}{// nans when both outputs are zeros.}
00319         ArrayType expected = \hyperlink{namespace_eigen_a726eae91d4e91d8e25cbe55fffa6a92f}{betainc}(a, b, x) - num / denom + eps;
00320         ArrayType test = \hyperlink{namespace_eigen_a726eae91d4e91d8e25cbe55fffa6a92f}{betainc}(a + one, b, x) + eps;
00321         \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(Scalar) >= 8) \{ \textcolor{comment}{// double}
00322           verify\_component\_wise(test, expected);
00323         \} \textcolor{keywordflow}{else} \{
00324           \textcolor{comment}{// Reason for limited test: http://eigen.tuxfamily.org/bz/show\_bug.cgi?id=1232}
00325           verify\_component\_wise(test.head(8), expected.head(8));
00326         \});
00327 
00328     \textcolor{comment}{// betainc(a, b+1, x) = betainc(a, b, x) + x**a * (1 - x)**b / (b * beta(a, b))}
00329     CALL\_SUBTEST(
00330         \textcolor{comment}{// Add eps to rhs and lhs so that component-wise test doesn't result in}
00331         \textcolor{comment}{// nans when both outputs are zeros.}
00332         ArrayType num = x.pow(a) * (one - x).\hyperlink{group___core___module_ab6dc101d82e8228a19a8840e3a29c1c9}{pow}(b);
00333         ArrayType denom = b * (a.lgamma() + b.lgamma() - (a + b).lgamma()).exp();
00334         ArrayType expected = \hyperlink{namespace_eigen_a726eae91d4e91d8e25cbe55fffa6a92f}{betainc}(a, b, x) + num / denom + eps;
00335         ArrayType test = \hyperlink{namespace_eigen_a726eae91d4e91d8e25cbe55fffa6a92f}{betainc}(a, b + one, x) + eps;
00336         verify\_component\_wise(test, expected););
00337   \}
00338 \textcolor{preprocessor}{#endif}
00339 \}
00340 
00341 \textcolor{keywordtype}{void} test\_special\_functions()
00342 \{
00343   CALL\_SUBTEST\_1(array\_special\_functions<ArrayXf>());
00344   CALL\_SUBTEST\_2(array\_special\_functions<ArrayXd>());
00345 \}
\end{DoxyCode}
