\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_assign_evaluator_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/\+Assign\+Evaluator.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_assign_evaluator_8h_source}\index{Assign\+Evaluator.\+h@{Assign\+Evaluator.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2011 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2011-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{// Copyright (C) 2011-2012 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00007 \textcolor{comment}{//}
00008 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00009 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00010 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00011 
00012 \textcolor{preprocessor}{#ifndef EIGEN\_ASSIGN\_EVALUATOR\_H}
00013 \textcolor{preprocessor}{#define EIGEN\_ASSIGN\_EVALUATOR\_H}
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00016 
00017 \textcolor{comment}{// This implementation is based on Assign.h}
00018 
00019 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00020   
00021 \textcolor{comment}{/***************************************************************************}
00022 \textcolor{comment}{* Part 1 : the logic deciding a strategy for traversal and unrolling       *}
00023 \textcolor{comment}{***************************************************************************/}
00024 
00025 \textcolor{comment}{// copy\_using\_evaluator\_traits is based on assign\_traits}
00026 
00027 \textcolor{keyword}{template} <\textcolor{keyword}{typename} DstEvaluator, \textcolor{keyword}{typename} SrcEvaluator, \textcolor{keyword}{typename} AssignFunc>
00028 \textcolor{keyword}{struct }copy\_using\_evaluator\_traits
00029 \{
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstEvaluator::XprType Dst;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Dst::Scalar DstScalar;
00032   
00033   \textcolor{keyword}{enum} \{
00034     DstFlags = DstEvaluator::Flags,
00035     SrcFlags = SrcEvaluator::Flags
00036   \};
00037   
00038 \textcolor{keyword}{public}:
00039   \textcolor{keyword}{enum} \{
00040     DstAlignment = DstEvaluator::Alignment,
00041     SrcAlignment = SrcEvaluator::Alignment,
00042     DstHasDirectAccess = DstFlags & \hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit},
00043     JointAlignment = EIGEN\_PLAIN\_ENUM\_MIN(DstAlignment,SrcAlignment)
00044   \};
00045 
00046 \textcolor{keyword}{private}:
00047   \textcolor{keyword}{enum} \{
00048     InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)
00049               : int(DstFlags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} ? int(Dst::ColsAtCompileTime)
00050               : int(Dst::RowsAtCompileTime),
00051     InnerMaxSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)
00052               : int(DstFlags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} ? int(Dst::MaxColsAtCompileTime)
00053               : int(Dst::MaxRowsAtCompileTime),
00054     OuterStride = int(outer\_stride\_at\_compile\_time<Dst>::ret),
00055     MaxSizeAtCompileTime = Dst::SizeAtCompileTime
00056   \};
00057 
00058   \textcolor{comment}{// TODO distinguish between linear traversal and inner-traversals}
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} find\_best\_packet<DstScalar,Dst::SizeAtCompileTime>::type LinearPacketType;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} find\_best\_packet<DstScalar,InnerSize>::type InnerPacketType;
00061 
00062   \textcolor{keyword}{enum} \{
00063     LinearPacketSize = unpacket\_traits<LinearPacketType>::size,
00064     InnerPacketSize = unpacket\_traits<InnerPacketType>::size
00065   \};
00066 
00067 \textcolor{keyword}{public}:
00068   \textcolor{keyword}{enum} \{
00069     LinearRequiredAlignment = unpacket\_traits<LinearPacketType>::alignment,
00070     InnerRequiredAlignment = unpacket\_traits<InnerPacketType>::alignment
00071   \};
00072 
00073 \textcolor{keyword}{private}:
00074   \textcolor{keyword}{enum} \{
00075     DstIsRowMajor = DstFlags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit},
00076     SrcIsRowMajor = SrcFlags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit},
00077     StorageOrdersAgree = (int(DstIsRowMajor) == int(SrcIsRowMajor)),
00078     MightVectorize = \textcolor{keywordtype}{bool}(StorageOrdersAgree)
00079                   && (int(DstFlags) & int(SrcFlags) & ActualPacketAccessBit)
00080                   && \textcolor{keywordtype}{bool}(functor\_traits<AssignFunc>::PacketAccess),
00081     MayInnerVectorize  = MightVectorize
00082                        && int(InnerSize)!=\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} && int(InnerSize)%int(InnerPacketSize)==0
00083                        && int(OuterStride)!=\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} && int(OuterStride)%int(InnerPacketSize)==0
00084                        && (EIGEN\_UNALIGNED\_VECTORIZE  || int(JointAlignment)>=int(InnerRequiredAlignment)),
00085     MayLinearize = \textcolor{keywordtype}{bool}(StorageOrdersAgree) && (int(DstFlags) & int(SrcFlags) & 
      \hyperlink{group__flags_ga4b983a15d57cd55806df618ac544d09e}{LinearAccessBit}),
00086     MayLinearVectorize = \textcolor{keywordtype}{bool}(MightVectorize) && MayLinearize && DstHasDirectAccess
00087                        && (EIGEN\_UNALIGNED\_VECTORIZE || (int(DstAlignment)>=int(LinearRequiredAlignment)) 
      || MaxSizeAtCompileTime == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}),
00088       \textcolor{comment}{/* If the destination isn't aligned, we have to do runtime checks and we don't unroll,}
00089 \textcolor{comment}{         so it's only good for large enough sizes. */}
00090     MaySliceVectorize  = bool(MightVectorize) && bool(DstHasDirectAccess)
00091                        && (int(InnerMaxSize)==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} || int(InnerMaxSize)>=(
      EIGEN\_UNALIGNED\_VECTORIZE?InnerPacketSize:(3*InnerPacketSize)))
00092       \textcolor{comment}{/* slice vectorization can be slow, so we only want it if the slices are big, which is}
00093 \textcolor{comment}{         indicated by InnerMaxSize rather than InnerSize, think of the case of a dynamic block}
00094 \textcolor{comment}{         in a fixed-size matrix}
00095 \textcolor{comment}{         However, with EIGEN\_UNALIGNED\_VECTORIZE and unrolling, slice vectorization is still worth it */}
00096   \};
00097 
00098 \textcolor{keyword}{public}:
00099   \textcolor{keyword}{enum} \{
00100     Traversal = int(MayLinearVectorize) && (LinearPacketSize>InnerPacketSize) ? \textcolor{keywordtype}{int}(
      LinearVectorizedTraversal)
00101               : int(MayInnerVectorize)   ? int(InnerVectorizedTraversal)
00102               : int(MayLinearVectorize)  ? int(LinearVectorizedTraversal)
00103               : int(MaySliceVectorize)   ? int(SliceVectorizedTraversal)
00104               : int(MayLinearize)        ? int(LinearTraversal)
00105                                          : int(DefaultTraversal),
00106     Vectorized = int(Traversal) == InnerVectorizedTraversal
00107               || int(Traversal) == LinearVectorizedTraversal
00108               || int(Traversal) == SliceVectorizedTraversal
00109   \};
00110 
00111   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<int(Traversal)==LinearVectorizedTraversal, LinearPacketType,
       InnerPacketType>::type PacketType;
00112 
00113 \textcolor{keyword}{private}:
00114   \textcolor{keyword}{enum} \{
00115     ActualPacketSize    = int(Traversal)==LinearVectorizedTraversal ? LinearPacketSize
00116                         : Vectorized ? InnerPacketSize
00117                         : 1,
00118     UnrollingLimit      = EIGEN\_UNROLLING\_LIMIT * ActualPacketSize,
00119     MayUnrollCompletely = int(Dst::SizeAtCompileTime) != \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}
00120                        && int(Dst::SizeAtCompileTime) * (int(DstEvaluator::CoeffReadCost)+int(
      SrcEvaluator::CoeffReadCost)) <= \textcolor{keywordtype}{int}(UnrollingLimit),
00121     MayUnrollInner      = int(InnerSize) != \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}
00122                        && int(InnerSize) * (int(DstEvaluator::CoeffReadCost)+int(
      SrcEvaluator::CoeffReadCost)) <= \textcolor{keywordtype}{int}(UnrollingLimit)
00123   \};
00124 
00125 \textcolor{keyword}{public}:
00126   \textcolor{keyword}{enum} \{
00127     Unrolling = (int(Traversal) == int(InnerVectorizedTraversal) || int(Traversal) == int(DefaultTraversal)
      )
00128                 ? (
00129                     \textcolor{keywordtype}{int}(MayUnrollCompletely) ? int(CompleteUnrolling)
00130                   : int(MayUnrollInner)      ? int(InnerUnrolling)
00131                                              : int(NoUnrolling)
00132                   )
00133               : int(Traversal) == int(LinearVectorizedTraversal)
00134                 ? ( bool(MayUnrollCompletely) && ( EIGEN\_UNALIGNED\_VECTORIZE || (int(DstAlignment)>=int(
      LinearRequiredAlignment)))
00135                           ? int(CompleteUnrolling)
00136                           : int(NoUnrolling) )
00137               : int(Traversal) == int(LinearTraversal)
00138                 ? ( bool(MayUnrollCompletely) ? int(CompleteUnrolling) 
00139                                               : int(NoUnrolling) )
00140 #if EIGEN\_UNALIGNED\_VECTORIZE
00141               : int(Traversal) == int(SliceVectorizedTraversal)
00142                 ? ( bool(MayUnrollInner) ? int(InnerUnrolling)
00143                                          : int(NoUnrolling) )
00144 #endif
00145               : int(NoUnrolling)
00146   \};
00147 
00148 \textcolor{preprocessor}{#ifdef EIGEN\_DEBUG\_ASSIGN}
00149   \textcolor{keyword}{static} \textcolor{keywordtype}{void} debug()
00150   \{
00151     std::cerr << \textcolor{stringliteral}{"DstXpr: "} << \textcolor{keyword}{typeid}(\textcolor{keyword}{typename} DstEvaluator::XprType).name() << std::endl;
00152     std::cerr << \textcolor{stringliteral}{"SrcXpr: "} << \textcolor{keyword}{typeid}(\textcolor{keyword}{typename} SrcEvaluator::XprType).name() << std::endl;
00153     std::cerr.setf(std::ios::hex, std::ios::basefield);
00154     std::cerr << \textcolor{stringliteral}{"DstFlags"} << \textcolor{stringliteral}{" = "} << DstFlags << \textcolor{stringliteral}{" ("} << demangle\_flags(DstFlags) << \textcolor{stringliteral}{" )"} << std::endl;
00155     std::cerr << \textcolor{stringliteral}{"SrcFlags"} << \textcolor{stringliteral}{" = "} << SrcFlags << \textcolor{stringliteral}{" ("} << demangle\_flags(SrcFlags) << \textcolor{stringliteral}{" )"} << std::endl;
00156     std::cerr.unsetf(std::ios::hex);
00157     EIGEN\_DEBUG\_VAR(DstAlignment)
00158     EIGEN\_DEBUG\_VAR(SrcAlignment)
00159     EIGEN\_DEBUG\_VAR(LinearRequiredAlignment)
00160     EIGEN\_DEBUG\_VAR(InnerRequiredAlignment)
00161     EIGEN\_DEBUG\_VAR(JointAlignment)
00162     EIGEN\_DEBUG\_VAR(InnerSize)
00163     EIGEN\_DEBUG\_VAR(InnerMaxSize)
00164     EIGEN\_DEBUG\_VAR(LinearPacketSize)
00165     EIGEN\_DEBUG\_VAR(InnerPacketSize)
00166     EIGEN\_DEBUG\_VAR(ActualPacketSize)
00167     EIGEN\_DEBUG\_VAR(StorageOrdersAgree)
00168     EIGEN\_DEBUG\_VAR(MightVectorize)
00169     EIGEN\_DEBUG\_VAR(MayLinearize)
00170     EIGEN\_DEBUG\_VAR(MayInnerVectorize)
00171     EIGEN\_DEBUG\_VAR(MayLinearVectorize)
00172     EIGEN\_DEBUG\_VAR(MaySliceVectorize)
00173     std::cerr << \textcolor{stringliteral}{"Traversal"} << \textcolor{stringliteral}{" = "} << Traversal << \textcolor{stringliteral}{" ("} << demangle\_traversal(Traversal) << \textcolor{stringliteral}{")"} << 
      std::endl;
00174     EIGEN\_DEBUG\_VAR(SrcEvaluator::CoeffReadCost)
00175     EIGEN\_DEBUG\_VAR(UnrollingLimit)
00176     EIGEN\_DEBUG\_VAR(MayUnrollCompletely)
00177     EIGEN\_DEBUG\_VAR(MayUnrollInner)
00178     std::cerr << \textcolor{stringliteral}{"Unrolling"} << \textcolor{stringliteral}{" = "} << Unrolling << \textcolor{stringliteral}{" ("} << demangle\_unrolling(Unrolling) << \textcolor{stringliteral}{")"} << 
      std::endl;
00179     std::cerr << std::endl;
00180   \}
00181 \textcolor{preprocessor}{#endif}
00182 \};
00183 
00184 \textcolor{comment}{/***************************************************************************}
00185 \textcolor{comment}{* Part 2 : meta-unrollers}
00186 \textcolor{comment}{***************************************************************************/}
00187 
00188 \textcolor{comment}{/************************}
00189 \textcolor{comment}{*** Default traversal ***}
00190 \textcolor{comment}{************************/}
00191 
00192 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel, \textcolor{keywordtype}{int} Index, \textcolor{keywordtype}{int} Stop>
00193 \textcolor{keyword}{struct }copy\_using\_evaluator\_DefaultTraversal\_CompleteUnrolling
00194 \{
00195   \textcolor{comment}{// FIXME: this is not very clean, perhaps this information should be provided by the kernel?}
00196   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::DstEvaluatorType DstEvaluatorType;
00197   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstEvaluatorType::XprType DstXprType;
00198   
00199   \textcolor{keyword}{enum} \{
00200     outer = \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} / DstXprType::InnerSizeAtCompileTime,
00201     inner = \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} % DstXprType::InnerSizeAtCompileTime
00202   \};
00203 
00204   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00205   \{
00206     kernel.assignCoeffByOuterInner(outer, inner);
00207     copy\_using\_evaluator\_DefaultTraversal\_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
00208   \}
00209 \};
00210 
00211 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel, \textcolor{keywordtype}{int} Stop>
00212 \textcolor{keyword}{struct }copy\_using\_evaluator\_DefaultTraversal\_CompleteUnrolling<Kernel, Stop, Stop>
00213 \{
00214   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel&) \{ \}
00215 \};
00216 
00217 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel, \textcolor{keywordtype}{int} Index\_, \textcolor{keywordtype}{int} Stop>
00218 \textcolor{keyword}{struct }copy\_using\_evaluator\_DefaultTraversal\_InnerUnrolling
00219 \{
00220   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer)
00221   \{
00222     kernel.assignCoeffByOuterInner(outer, Index\_);
00223     copy\_using\_evaluator\_DefaultTraversal\_InnerUnrolling<Kernel, Index\_+1, Stop>::run(kernel, outer);
00224   \}
00225 \};
00226 
00227 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel, \textcolor{keywordtype}{int} Stop>
00228 \textcolor{keyword}{struct }copy\_using\_evaluator\_DefaultTraversal\_InnerUnrolling<Kernel, Stop, Stop>
00229 \{
00230   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel&, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}) \{ \}
00231 \};
00232 
00233 \textcolor{comment}{/***********************}
00234 \textcolor{comment}{*** Linear traversal ***}
00235 \textcolor{comment}{***********************/}
00236 
00237 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel, \textcolor{keywordtype}{int} Index, \textcolor{keywordtype}{int} Stop>
00238 \textcolor{keyword}{struct }copy\_using\_evaluator\_LinearTraversal\_CompleteUnrolling
00239 \{
00240   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel& kernel)
00241   \{
00242     kernel.assignCoeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index});
00243     copy\_using\_evaluator\_LinearTraversal\_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
00244   \}
00245 \};
00246 
00247 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel, \textcolor{keywordtype}{int} Stop>
00248 \textcolor{keyword}{struct }copy\_using\_evaluator\_LinearTraversal\_CompleteUnrolling<Kernel, Stop, Stop>
00249 \{
00250   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel&) \{ \}
00251 \};
00252 
00253 \textcolor{comment}{/**************************}
00254 \textcolor{comment}{*** Inner vectorization ***}
00255 \textcolor{comment}{**************************/}
00256 
00257 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel, \textcolor{keywordtype}{int} Index, \textcolor{keywordtype}{int} Stop>
00258 \textcolor{keyword}{struct }copy\_using\_evaluator\_innervec\_CompleteUnrolling
00259 \{
00260   \textcolor{comment}{// FIXME: this is not very clean, perhaps this information should be provided by the kernel?}
00261   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::DstEvaluatorType DstEvaluatorType;
00262   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstEvaluatorType::XprType DstXprType;
00263   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::PacketType PacketType;
00264   
00265   \textcolor{keyword}{enum} \{
00266     outer = \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} / DstXprType::InnerSizeAtCompileTime,
00267     inner = \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} % DstXprType::InnerSizeAtCompileTime,
00268     SrcAlignment = Kernel::AssignmentTraits::SrcAlignment,
00269     DstAlignment = Kernel::AssignmentTraits::DstAlignment
00270   \};
00271 
00272   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00273   \{
00274     kernel.template assignPacketByOuterInner<DstAlignment, SrcAlignment, PacketType>(outer, inner);
00275     \textcolor{keyword}{enum} \{ NextIndex = \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} + unpacket\_traits<PacketType>::size \};
00276     copy\_using\_evaluator\_innervec\_CompleteUnrolling<Kernel, NextIndex, Stop>::run(kernel);
00277   \}
00278 \};
00279 
00280 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel, \textcolor{keywordtype}{int} Stop>
00281 \textcolor{keyword}{struct }copy\_using\_evaluator\_innervec\_CompleteUnrolling<Kernel, Stop, Stop>
00282 \{
00283   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel&) \{ \}
00284 \};
00285 
00286 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel, \textcolor{keywordtype}{int} Index\_, \textcolor{keywordtype}{int} Stop, \textcolor{keywordtype}{int} SrcAlignment, \textcolor{keywordtype}{int} DstAlignment>
00287 \textcolor{keyword}{struct }copy\_using\_evaluator\_innervec\_InnerUnrolling
00288 \{
00289   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::PacketType PacketType;
00290   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer)
00291   \{
00292     kernel.template assignPacketByOuterInner<DstAlignment, SrcAlignment, PacketType>(outer, Index\_);
00293     \textcolor{keyword}{enum} \{ NextIndex = Index\_ + unpacket\_traits<PacketType>::size \};
00294     copy\_using\_evaluator\_innervec\_InnerUnrolling<Kernel, NextIndex, Stop, SrcAlignment, DstAlignment>::run(
      kernel, outer);
00295   \}
00296 \};
00297 
00298 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel, \textcolor{keywordtype}{int} Stop, \textcolor{keywordtype}{int} SrcAlignment, \textcolor{keywordtype}{int} DstAlignment>
00299 \textcolor{keyword}{struct }copy\_using\_evaluator\_innervec\_InnerUnrolling<Kernel, Stop, Stop, SrcAlignment, DstAlignment>
00300 \{
00301   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}) \{ \}
00302 \};
00303 
00304 \textcolor{comment}{/***************************************************************************}
00305 \textcolor{comment}{* Part 3 : implementation of all cases}
00306 \textcolor{comment}{***************************************************************************/}
00307 
00308 \textcolor{comment}{// dense\_assignment\_loop is based on assign\_impl}
00309 
00310 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel,
00311          \textcolor{keywordtype}{int} Traversal = Kernel::AssignmentTraits::Traversal,
00312          \textcolor{keywordtype}{int} Unrolling = Kernel::AssignmentTraits::Unrolling>
00313 \textcolor{keyword}{struct }dense\_assignment\_loop;
00314 
00315 \textcolor{comment}{/************************}
00316 \textcolor{comment}{*** Default traversal ***}
00317 \textcolor{comment}{************************/}
00318 
00319 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel>
00320 \textcolor{keyword}{struct }dense\_assignment\_loop<Kernel, DefaultTraversal, NoUnrolling>
00321 \{
00322   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} \textcolor{keywordtype}{void} EIGEN\_STRONG\_INLINE run(Kernel &kernel)
00323   \{
00324     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer = 0; outer < kernel.outerSize(); ++outer) \{
00325       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner = 0; inner < kernel.innerSize(); ++inner) \{
00326         kernel.assignCoeffByOuterInner(outer, inner);
00327       \}
00328     \}
00329   \}
00330 \};
00331 
00332 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel>
00333 \textcolor{keyword}{struct }dense\_assignment\_loop<Kernel, DefaultTraversal, CompleteUnrolling>
00334 \{
00335   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00336   \{
00337     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::DstEvaluatorType::XprType DstXprType;
00338     copy\_using\_evaluator\_DefaultTraversal\_CompleteUnrolling<Kernel, 0, DstXprType::SizeAtCompileTime>::run(
      kernel);
00339   \}
00340 \};
00341 
00342 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel>
00343 \textcolor{keyword}{struct }dense\_assignment\_loop<Kernel, DefaultTraversal, InnerUnrolling>
00344 \{
00345   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00346   \{
00347     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::DstEvaluatorType::XprType DstXprType;
00348 
00349     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerSize = kernel.outerSize();
00350     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer = 0; outer < outerSize; ++outer)
00351       copy\_using\_evaluator\_DefaultTraversal\_InnerUnrolling<Kernel, 0,
       DstXprType::InnerSizeAtCompileTime>::run(kernel, outer);
00352   \}
00353 \};
00354 
00355 \textcolor{comment}{/***************************}
00356 \textcolor{comment}{*** Linear vectorization ***}
00357 \textcolor{comment}{***************************/}
00358 
00359 
00360 \textcolor{comment}{// The goal of unaligned\_dense\_assignment\_loop is simply to factorize the handling}
00361 \textcolor{comment}{// of the non vectorizable beginning and ending parts}
00362 
00363 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IsAligned = false>
00364 \textcolor{keyword}{struct }unaligned\_dense\_assignment\_loop
00365 \{
00366   \textcolor{comment}{// if IsAligned = true, then do nothing}
00367   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Kernel>
00368   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel&, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}) \{\}
00369 \};
00370 
00371 \textcolor{keyword}{template} <>
00372 \textcolor{keyword}{struct }unaligned\_dense\_assignment\_loop<false>
00373 \{
00374   \textcolor{comment}{// MSVC must not inline this functions. If it does, it fails to optimize the}
00375   \textcolor{comment}{// packet access path.}
00376   \textcolor{comment}{// FIXME check which version exhibits this issue}
00377 \textcolor{preprocessor}{#if EIGEN\_COMP\_MSVC}
00378   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Kernel>
00379   \textcolor{keyword}{static} EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel,
00380                                     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} start,
00381                                     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} end)
00382 \textcolor{preprocessor}{#else}
00383   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Kernel>
00384   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel,
00385                                       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} start,
00386                                       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} end)
00387 \textcolor{preprocessor}{#endif}
00388   \{
00389     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index = start; index < end; ++index)
00390       kernel.assignCoeff(index);
00391   \}
00392 \};
00393 
00394 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel>
00395 \textcolor{keyword}{struct }dense\_assignment\_loop<Kernel, LinearVectorizedTraversal, NoUnrolling>
00396 \{
00397   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00398   \{
00399     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = kernel.size();
00400     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::Scalar Scalar;
00401     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::PacketType PacketType;
00402     \textcolor{keyword}{enum} \{
00403       requestedAlignment = Kernel::AssignmentTraits::LinearRequiredAlignment,
00404       packetSize = unpacket\_traits<PacketType>::size,
00405       dstIsAligned = int(Kernel::AssignmentTraits::DstAlignment)>=int(requestedAlignment),
00406       dstAlignment = packet\_traits<Scalar>::AlignedOnScalar ? int(requestedAlignment)
00407                                                             : int(Kernel::AssignmentTraits::DstAlignment),
00408       srcAlignment = Kernel::AssignmentTraits::JointAlignment
00409     \};
00410     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedStart = dstIsAligned ? 0 : internal::first\_aligned<requestedAlignment>(kernel.
      dstDataPtr(), size);
00411     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;
00412 
00413     unaligned\_dense\_assignment\_loop<dstIsAligned!=0>::run(kernel, 0, alignedStart);
00414 
00415     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index = alignedStart; index < alignedEnd; index += packetSize)
00416       kernel.template assignPacket<dstAlignment, srcAlignment, PacketType>(index);
00417 
00418     unaligned\_dense\_assignment\_loop<>::run(kernel, alignedEnd, size);
00419   \}
00420 \};
00421 
00422 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel>
00423 \textcolor{keyword}{struct }dense\_assignment\_loop<Kernel, LinearVectorizedTraversal, CompleteUnrolling>
00424 \{
00425   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00426   \{
00427     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::DstEvaluatorType::XprType DstXprType;
00428     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::PacketType PacketType;
00429     
00430     \textcolor{keyword}{enum} \{ size = DstXprType::SizeAtCompileTime,
00431            packetSize =unpacket\_traits<PacketType>::size,
00432            alignedSize = (size/packetSize)*packetSize \};
00433 
00434     copy\_using\_evaluator\_innervec\_CompleteUnrolling<Kernel, 0, alignedSize>::run(kernel);
00435     copy\_using\_evaluator\_DefaultTraversal\_CompleteUnrolling<Kernel, alignedSize, size>::run(kernel);
00436   \}
00437 \};
00438 
00439 \textcolor{comment}{/**************************}
00440 \textcolor{comment}{*** Inner vectorization ***}
00441 \textcolor{comment}{**************************/}
00442 
00443 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel>
00444 \textcolor{keyword}{struct }dense\_assignment\_loop<Kernel, InnerVectorizedTraversal, NoUnrolling>
00445 \{
00446   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::PacketType PacketType;
00447   \textcolor{keyword}{enum} \{
00448     SrcAlignment = Kernel::AssignmentTraits::SrcAlignment,
00449     DstAlignment = Kernel::AssignmentTraits::DstAlignment
00450   \};
00451   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00452   \{
00453     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} innerSize = kernel.innerSize();
00454     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerSize = kernel.outerSize();
00455     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} packetSize = unpacket\_traits<PacketType>::size;
00456     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer = 0; outer < outerSize; ++outer)
00457       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner = 0; inner < innerSize; inner+=packetSize)
00458         kernel.template assignPacketByOuterInner<DstAlignment, SrcAlignment, PacketType>(outer, inner);
00459   \}
00460 \};
00461 
00462 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel>
00463 \textcolor{keyword}{struct }dense\_assignment\_loop<Kernel, InnerVectorizedTraversal, CompleteUnrolling>
00464 \{
00465   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00466   \{
00467     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::DstEvaluatorType::XprType DstXprType;
00468     copy\_using\_evaluator\_innervec\_CompleteUnrolling<Kernel, 0, DstXprType::SizeAtCompileTime>::run(kernel);
00469   \}
00470 \};
00471 
00472 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel>
00473 \textcolor{keyword}{struct }dense\_assignment\_loop<Kernel, InnerVectorizedTraversal, InnerUnrolling>
00474 \{
00475   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00476   \{
00477     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::DstEvaluatorType::XprType DstXprType;
00478     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::AssignmentTraits Traits;
00479     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerSize = kernel.outerSize();
00480     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer = 0; outer < outerSize; ++outer)
00481       copy\_using\_evaluator\_innervec\_InnerUnrolling<Kernel, 0, DstXprType::InnerSizeAtCompileTime,
00482                                                    Traits::SrcAlignment, Traits::DstAlignment>::run(kernel,
       outer);
00483   \}
00484 \};
00485 
00486 \textcolor{comment}{/***********************}
00487 \textcolor{comment}{*** Linear traversal ***}
00488 \textcolor{comment}{***********************/}
00489 
00490 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel>
00491 \textcolor{keyword}{struct }dense\_assignment\_loop<Kernel, LinearTraversal, NoUnrolling>
00492 \{
00493   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00494   \{
00495     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = kernel.size();
00496     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < size; ++i)
00497       kernel.assignCoeff(i);
00498   \}
00499 \};
00500 
00501 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel>
00502 \textcolor{keyword}{struct }dense\_assignment\_loop<Kernel, LinearTraversal, CompleteUnrolling>
00503 \{
00504   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00505   \{
00506     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::DstEvaluatorType::XprType DstXprType;
00507     copy\_using\_evaluator\_LinearTraversal\_CompleteUnrolling<Kernel, 0, DstXprType::SizeAtCompileTime>::run(
      kernel);
00508   \}
00509 \};
00510 
00511 \textcolor{comment}{/**************************}
00512 \textcolor{comment}{*** Slice vectorization ***}
00513 \textcolor{comment}{***************************/}
00514 
00515 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel>
00516 \textcolor{keyword}{struct }dense\_assignment\_loop<Kernel, SliceVectorizedTraversal, NoUnrolling>
00517 \{
00518   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00519   \{
00520     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::Scalar Scalar;
00521     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::PacketType PacketType;
00522     \textcolor{keyword}{enum} \{
00523       packetSize = unpacket\_traits<PacketType>::size,
00524       requestedAlignment = int(Kernel::AssignmentTraits::InnerRequiredAlignment),
00525       alignable = packet\_traits<Scalar>::AlignedOnScalar || int(Kernel::AssignmentTraits::DstAlignment)>=\textcolor{keyword}{
      sizeof}(Scalar),
00526       dstIsAligned = \textcolor{keywordtype}{int}(Kernel::AssignmentTraits::DstAlignment)>=int(requestedAlignment),
00527       dstAlignment = alignable ? int(requestedAlignment)
00528                                : int(Kernel::AssignmentTraits::DstAlignment)
00529     \};
00530     \textcolor{keyword}{const} Scalar *dst\_ptr = kernel.dstDataPtr();
00531     \textcolor{keywordflow}{if}((!\textcolor{keywordtype}{bool}(dstIsAligned)) && (UIntPtr(dst\_ptr) % \textcolor{keyword}{sizeof}(Scalar))>0)
00532     \{
00533       \textcolor{comment}{// the pointer is not aligend-on scalar, so alignment is not possible}
00534       \textcolor{keywordflow}{return} dense\_assignment\_loop<Kernel,DefaultTraversal,NoUnrolling>::run(kernel);
00535     \}
00536     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} packetAlignedMask = packetSize - 1;
00537     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} innerSize = kernel.innerSize();
00538     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerSize = kernel.outerSize();
00539     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedStep = alignable ? (packetSize - kernel.outerStride() % packetSize) & 
      packetAlignedMask : 0;
00540     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedStart = ((!alignable) || \textcolor{keywordtype}{bool}(dstIsAligned)) ? 0 : 
      internal::first\_aligned<requestedAlignment>(dst\_ptr, innerSize);
00541 
00542     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer = 0; outer < outerSize; ++outer)
00543     \{
00544       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedEnd = alignedStart + ((innerSize-alignedStart) & ~packetAlignedMask);
00545       \textcolor{comment}{// do the non-vectorizable part of the assignment}
00546       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner = 0; inner<alignedStart ; ++inner)
00547         kernel.assignCoeffByOuterInner(outer, inner);
00548 
00549       \textcolor{comment}{// do the vectorizable part of the assignment}
00550       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner = alignedStart; inner<alignedEnd; inner+=packetSize)
00551         kernel.template assignPacketByOuterInner<dstAlignment, Unaligned, PacketType>(outer, inner);
00552 
00553       \textcolor{comment}{// do the non-vectorizable part of the assignment}
00554       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner = alignedEnd; inner<innerSize ; ++inner)
00555         kernel.assignCoeffByOuterInner(outer, inner);
00556 
00557       alignedStart = numext::mini((alignedStart+alignedStep)%packetSize, innerSize);
00558     \}
00559   \}
00560 \};
00561 
00562 \textcolor{preprocessor}{#if EIGEN\_UNALIGNED\_VECTORIZE}
00563 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Kernel>
00564 \textcolor{keyword}{struct }dense\_assignment\_loop<Kernel, SliceVectorizedTraversal, InnerUnrolling>
00565 \{
00566   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Kernel &kernel)
00567   \{
00568     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::DstEvaluatorType::XprType DstXprType;
00569     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Kernel::PacketType PacketType;
00570 
00571     \textcolor{keyword}{enum} \{ size = DstXprType::InnerSizeAtCompileTime,
00572            packetSize =unpacket\_traits<PacketType>::size,
00573            vectorizableSize = (size/packetSize)*packetSize \};
00574 
00575     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer = 0; outer < kernel.outerSize(); ++outer)
00576     \{
00577       copy\_using\_evaluator\_innervec\_InnerUnrolling<Kernel, 0, vectorizableSize, 0, 0>::run(kernel, outer);
00578       copy\_using\_evaluator\_DefaultTraversal\_InnerUnrolling<Kernel, vectorizableSize, size>::run(kernel, 
      outer);
00579     \}
00580   \}
00581 \};
00582 \textcolor{preprocessor}{#endif}
00583 
00584 
00585 \textcolor{comment}{/***************************************************************************}
00586 \textcolor{comment}{* Part 4 : Generic dense assignment kernel}
00587 \textcolor{comment}{***************************************************************************/}
00588 
00589 \textcolor{comment}{// This class generalize the assignment of a coefficient (or packet) from one dense evaluator}
00590 \textcolor{comment}{// to another dense writable evaluator.}
00591 \textcolor{comment}{// It is parametrized by the two evaluators, and the actual assignment functor.}
00592 \textcolor{comment}{// This abstraction level permits to keep the evaluation loops as simple and as generic as possible.}
00593 \textcolor{comment}{// One can customize the assignment using this generic dense\_assignment\_kernel with different}
00594 \textcolor{comment}{// functors, or by completely overloading it, by-passing a functor.}
00595 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstEvaluatorTypeT, \textcolor{keyword}{typename} SrcEvaluatorTypeT, \textcolor{keyword}{typename} Functor, \textcolor{keywordtype}{int} Version = Specialize
      d>
00596 \textcolor{keyword}{class }generic\_dense\_assignment\_kernel
00597 \{
00598 \textcolor{keyword}{protected}:
00599   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstEvaluatorTypeT::XprType DstXprType;
00600   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SrcEvaluatorTypeT::XprType SrcXprType;
00601 \textcolor{keyword}{public}:
00602   
00603   \textcolor{keyword}{typedef} DstEvaluatorTypeT DstEvaluatorType;
00604   \textcolor{keyword}{typedef} SrcEvaluatorTypeT SrcEvaluatorType;
00605   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstEvaluatorType::Scalar Scalar;
00606   \textcolor{keyword}{typedef} copy\_using\_evaluator\_traits<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor> AssignmentTraits;
00607   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} AssignmentTraits::PacketType PacketType;
00608   
00609   
00610   EIGEN\_DEVICE\_FUNC generic\_dense\_assignment\_kernel(DstEvaluatorType &dst, \textcolor{keyword}{const} SrcEvaluatorType &src, \textcolor{keyword}{
      const} \hyperlink{struct_functor}{Functor} &\hyperlink{structfunc}{func}, DstXprType& dstExpr)
00611     : m\_dst(dst), m\_src(src), m\_functor(func), m\_dstExpr(dstExpr)
00612   \{
00613 \textcolor{preprocessor}{    #ifdef EIGEN\_DEBUG\_ASSIGN}
00614     AssignmentTraits::debug();
00615 \textcolor{preprocessor}{    #endif}
00616   \}
00617   
00618   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size()\textcolor{keyword}{ const        }\{ \textcolor{keywordflow}{return} m\_dstExpr.size(); \}
00619   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} innerSize()\textcolor{keyword}{ const   }\{ \textcolor{keywordflow}{return} m\_dstExpr.innerSize(); \}
00620   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerSize()\textcolor{keyword}{ const   }\{ \textcolor{keywordflow}{return} m\_dstExpr.outerSize(); \}
00621   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const        }\{ \textcolor{keywordflow}{return} m\_dstExpr.rows(); \}
00622   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const        }\{ \textcolor{keywordflow}{return} m\_dstExpr.cols(); \}
00623   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dstExpr.outerStride(); \}
00624   
00625   EIGEN\_DEVICE\_FUNC DstEvaluatorType& dstEvaluator() \{ \textcolor{keywordflow}{return} m\_dst; \}
00626   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} SrcEvaluatorType& srcEvaluator()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_src; \}
00627   
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_assign_evaluator_8h_source_l00629}\hyperlink{class_eigen_1_1internal_1_1generic__dense__assignment__kernel_a7ca974cc4049f1ef3d6f2feac94ea35b}{00629}   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1internal_1_1generic__dense__assignment__kernel_a7ca974cc4049f1ef3d6f2feac94ea35b}{assignCoeff}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
00630   \{
00631     m\_functor.assignCoeff(m\_dst.coeffRef(row,col), m\_src.coeff(row,col));
00632   \}
00633   
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_assign_evaluator_8h_source_l00635}\hyperlink{class_eigen_1_1internal_1_1generic__dense__assignment__kernel_a9f36120222600d1d843b4253b08a383b}{00635}   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1internal_1_1generic__dense__assignment__kernel_a9f36120222600d1d843b4253b08a383b}{assignCoeff}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)
00636   \{
00637     m\_functor.assignCoeff(m\_dst.coeffRef(index), m\_src.coeff(index));
00638   \}
00639   
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_assign_evaluator_8h_source_l00641}\hyperlink{class_eigen_1_1internal_1_1generic__dense__assignment__kernel_aff1bc113e270d4f895ca90570536303b}{00641}   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1internal_1_1generic__dense__assignment__kernel_aff1bc113e270d4f895ca90570536303b}{assignCoeffByOuterInner}(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner)
00642   \{
00643     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row = rowIndexByOuterInner(outer, inner); 
00644     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col = colIndexByOuterInner(outer, inner); 
00645     assignCoeff(row, col);
00646   \}
00647   
00648   
00649   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode, \textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00650   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} assignPacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
00651   \{
00652     m\_functor.template assignPacket<StoreMode>(&m\_dst.coeffRef(row,col), m\_src.template 
      packet<LoadMode,PacketType>(row,col));
00653   \}
00654   
00655   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode, \textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00656   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} assignPacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)
00657   \{
00658     m\_functor.template assignPacket<StoreMode>(&m\_dst.coeffRef(index), m\_src.template 
      packet<LoadMode,PacketType>(index));
00659   \}
00660   
00661   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode, \textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00662   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} assignPacketByOuterInner(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner)
00663   \{
00664     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row = rowIndexByOuterInner(outer, inner); 
00665     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col = colIndexByOuterInner(outer, inner);
00666     assignPacket<StoreMode,LoadMode,PacketType>(row, col);
00667   \}
00668   
00669   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rowIndexByOuterInner(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner)
00670   \{
00671     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstEvaluatorType::ExpressionTraits Traits;
00672     \textcolor{keywordflow}{return} int(Traits::RowsAtCompileTime) == 1 ? 0
00673       : int(Traits::ColsAtCompileTime) == 1 ? inner
00674       : int(DstEvaluatorType::Flags)&RowMajorBit ? outer
00675       : inner;
00676   \}
00677 
00678   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} colIndexByOuterInner(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner)
00679   \{
00680     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstEvaluatorType::ExpressionTraits Traits;
00681     \textcolor{keywordflow}{return} int(Traits::ColsAtCompileTime) == 1 ? 0
00682       : int(Traits::RowsAtCompileTime) == 1 ? inner
00683       : int(DstEvaluatorType::Flags)&RowMajorBit ? inner
00684       : outer;
00685   \}
00686 
00687   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} Scalar* dstDataPtr()\textcolor{keyword}{ const}
00688 \textcolor{keyword}{  }\{
00689     \textcolor{keywordflow}{return} m\_dstExpr.data();
00690   \}
00691   
00692 \textcolor{keyword}{protected}:
00693   DstEvaluatorType& m\_dst;
00694   \textcolor{keyword}{const} SrcEvaluatorType& m\_src;
00695   \textcolor{keyword}{const} \hyperlink{struct_functor}{Functor} &m\_functor;
00696   \textcolor{comment}{// TODO find a way to avoid the needs of the original expression}
00697   DstXprType& m\_dstExpr;
00698 \};
00699 
00700 \textcolor{comment}{/***************************************************************************}
00701 \textcolor{comment}{* Part 5 : Entry point for dense rectangular assignment}
00702 \textcolor{comment}{***************************************************************************/}
00703 
00704 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType,\textcolor{keyword}{typename} SrcXprType, \textcolor{keyword}{typename} Functor>
00705 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00706 \textcolor{keywordtype}{void} resize\_if\_allowed(DstXprType &dst, \textcolor{keyword}{const} SrcXprType& src, \textcolor{keyword}{const} \hyperlink{struct_functor}{Functor} &\textcolor{comment}{/*func*/})
00707 \{
00708   EIGEN\_ONLY\_USED\_FOR\_DEBUG(dst);
00709   EIGEN\_ONLY\_USED\_FOR\_DEBUG(src);
00710   eigen\_assert(dst.rows() == src.rows() && dst.cols() == src.cols());
00711 \}
00712 
00713 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType,\textcolor{keyword}{typename} SrcXprType, \textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>
00714 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00715 \textcolor{keywordtype}{void} resize\_if\_allowed(DstXprType &dst, \textcolor{keyword}{const} SrcXprType& src, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<T1,T2>} &\textcolor{comment}{/*func*/})
00716 \{
00717   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstRows = src.rows();
00718   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstCols = src.cols();
00719   \textcolor{keywordflow}{if}(((dst.rows()!=dstRows) || (dst.cols()!=dstCols)))
00720     dst.resize(dstRows, dstCols);
00721   eigen\_assert(dst.rows() == dstRows && dst.cols() == dstCols);
00722 \}
00723 
00724 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType, \textcolor{keyword}{typename} Functor>
00725 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} call\_dense\_assignment\_loop(DstXprType& dst, \textcolor{keyword}{const} SrcXprType& 
      src, \textcolor{keyword}{const} \hyperlink{struct_functor}{Functor} &\hyperlink{structfunc}{func})
00726 \{
00727   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<DstXprType>} DstEvaluatorType;
00728   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<SrcXprType>} SrcEvaluatorType;
00729 
00730   SrcEvaluatorType srcEvaluator(src);
00731 
00732   \textcolor{comment}{// NOTE To properly handle A = (A*A.transpose())/s with A rectangular,}
00733   \textcolor{comment}{// we need to resize the destination after the source evaluator has been created.}
00734   resize\_if\_allowed(dst, src, func);
00735 
00736   DstEvaluatorType dstEvaluator(dst);
00737     
00738   \textcolor{keyword}{typedef} 
      \hyperlink{class_eigen_1_1internal_1_1generic__dense__assignment__kernel}{generic\_dense\_assignment\_kernel<DstEvaluatorType,SrcEvaluatorType,Functor>}
       Kernel;
00739   Kernel kernel(dstEvaluator, srcEvaluator, func, dst.const\_cast\_derived());
00740 
00741   \hyperlink{struct_eigen_1_1internal_1_1dense__assignment__loop}{dense\_assignment\_loop<Kernel>::run}(kernel);
00742 \}
00743 
00744 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType>
00745 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} call\_dense\_assignment\_loop(DstXprType& dst, \textcolor{keyword}{const} SrcXprType& 
      src)
00746 \{
00747   call\_dense\_assignment\_loop(dst, src, 
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<typename DstXprType::Scalar,typename SrcXprType::Scalar>}
      ());
00748 \}
00749 
00750 \textcolor{comment}{/***************************************************************************}
00751 \textcolor{comment}{* Part 6 : Generic assignment}
00752 \textcolor{comment}{***************************************************************************/}
00753 
00754 \textcolor{comment}{// Based on the respective shapes of the destination and source,}
00755 \textcolor{comment}{// the class AssignmentKind determine the kind of assignment mechanism.}
00756 \textcolor{comment}{// AssignmentKind must define a Kind typedef.}
00757 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstShape, \textcolor{keyword}{typename} SrcShape> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment_kind}{AssignmentKind};
00758 
00759 \textcolor{comment}{// Assignement kind defined in this file:}
00760 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_dense2_dense}{Dense2Dense} \{\};
00761 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_eigen_base2_eigen_base}{EigenBase2EigenBase} \{\};
00762 
00763 \textcolor{keyword}{template}<\textcolor{keyword}{typename},\textcolor{keyword}{typename}> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment_kind}{AssignmentKind} \{ \textcolor{keyword}{typedef} 
      \hyperlink{struct_eigen_1_1internal_1_1_eigen_base2_eigen_base}{EigenBase2EigenBase} Kind; \};
00764 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment_kind}{AssignmentKind}<DenseShape,DenseShape> \{ \textcolor{keyword}{typedef} 
      \hyperlink{struct_eigen_1_1internal_1_1_dense2_dense}{Dense2Dense} Kind; \};
00765     
00766 \textcolor{comment}{// This is the main assignment class}
00767 \textcolor{keyword}{template}< \textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType, \textcolor{keyword}{typename} \hyperlink{struct_functor}{Functor},
00768           \textcolor{keyword}{typename} Kind = \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1_assignment_kind}{AssignmentKind< typename evaluator\_traits<DstXprType>::Shape}
       , \textcolor{keyword}{typename} evaluator\_traits<SrcXprType>::Shape >::Kind,
00769           \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1_enable_if}{EnableIf} = \textcolor{keywordtype}{void}>
00770 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment}{Assignment};
00771 
00772 
00773 \textcolor{comment}{// The only purpose of this call\_assignment() function is to deal with noalias() / "assume-aliasing" and
       automatic transposition.}
00774 \textcolor{comment}{// Indeed, I (Gael) think that this concept of "assume-aliasing" was a mistake, and it makes thing quite
       complicated.}
00775 \textcolor{comment}{// So this intermediate function removes everything related to "assume-aliasing" such that Assignment}
00776 \textcolor{comment}{// does not has to bother about these annoying details.}
00777 
00778 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{typename} Src>
00779 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00780 \textcolor{keywordtype}{void} call\_assignment(Dst& dst, \textcolor{keyword}{const} Src& src)
00781 \{
00782   call\_assignment(dst, src, 
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<typename Dst::Scalar,typename Src::Scalar>}
      ());
00783 \}
00784 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{typename} Src>
00785 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00786 \textcolor{keywordtype}{void} call\_assignment(\textcolor{keyword}{const} Dst& dst, \textcolor{keyword}{const} Src& src)
00787 \{
00788   call\_assignment(dst, src, 
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<typename Dst::Scalar,typename Src::Scalar>}
      ());
00789 \}
00790                      
00791 \textcolor{comment}{// Deal with "assume-aliasing"}
00792 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{typename} Src, \textcolor{keyword}{typename} Func>
00793 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00794 \textcolor{keywordtype}{void} call\_assignment(Dst& dst, \textcolor{keyword}{const} Src& src, \textcolor{keyword}{const} Func& func, \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1enable__if}{enable\_if}< \hyperlink{struct_eigen_1_1internal_1_1evaluator__assume__aliasing}{evaluator\_assume\_aliasing<Src>::value}, \textcolor{keywordtype}{void}*>::
      type = 0)
00795 \{
00796   \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1plain__matrix__type}{plain\_matrix\_type<Src>::type} tmp(src);
00797   call\_assignment\_no\_alias(dst, tmp, func);
00798 \}
00799 
00800 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{typename} Src, \textcolor{keyword}{typename} Func>
00801 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00802 \textcolor{keywordtype}{void} call\_assignment(Dst& dst, \textcolor{keyword}{const} Src& src, \textcolor{keyword}{const} Func& func, \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1enable__if}{enable\_if}<!\hyperlink{struct_eigen_1_1internal_1_1evaluator__assume__aliasing}{evaluator\_assume\_aliasing<Src>::value}, \textcolor{keywordtype}{void}*>::
      type = 0)
00803 \{
00804   call\_assignment\_no\_alias(dst, src, func);
00805 \}
00806 
00807 \textcolor{comment}{// by-pass "assume-aliasing"}
00808 \textcolor{comment}{// When there is no aliasing, we require that 'dst' has been properly resized}
00809 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{class }StorageBase, \textcolor{keyword}{typename} Src, \textcolor{keyword}{typename} Func>
00810 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00811 \textcolor{keywordtype}{void} call\_assignment(\hyperlink{group___core___module_class_eigen_1_1_no_alias}{NoAlias<Dst,StorageBase>}& dst, \textcolor{keyword}{const} Src& src, \textcolor{keyword}{const} Func& 
      func)
00812 \{
00813   call\_assignment\_no\_alias(dst.expression(), src, func);
00814 \}
00815 
00816 
00817 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{typename} Src, \textcolor{keyword}{typename} Func>
00818 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00819 \textcolor{keywordtype}{void} call\_assignment\_no\_alias(Dst& dst, \textcolor{keyword}{const} Src& src, \textcolor{keyword}{const} Func& func)
00820 \{
00821   \textcolor{keyword}{enum} \{
00822     NeedToTranspose = (    (int(Dst::RowsAtCompileTime) == 1 && int(Src::ColsAtCompileTime) == 1)
00823                         || (\textcolor{keywordtype}{int}(Dst::ColsAtCompileTime) == 1 && int(Src::RowsAtCompileTime) == 1)
00824                       ) && int(Dst::SizeAtCompileTime) != 1
00825   \};
00826 
00827   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{internal::conditional<NeedToTranspose, Transpose<Dst>}
      , Dst>::type ActualDstTypeCleaned;
00828   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::conditional<NeedToTranspose, Transpose<Dst>, Dst&>::type ActualDstType;
00829   ActualDstType actualDst(dst);
00830   
00831   \textcolor{comment}{// TODO check whether this is the right place to perform these checks:}
00832   EIGEN\_STATIC\_ASSERT\_LVALUE(Dst)
00833   EIGEN\_STATIC\_ASSERT\_SAME\_MATRIX\_SIZE(ActualDstTypeCleaned,Src)
00834   EIGEN\_CHECK\_BINARY\_COMPATIBILIY(Func,\textcolor{keyword}{typename} ActualDstTypeCleaned::Scalar,\textcolor{keyword}{typename} Src::Scalar);
00835   
00836   \hyperlink{struct_eigen_1_1internal_1_1_assignment}{Assignment<ActualDstTypeCleaned,Src,Func>::run}(actualDst, 
      src, func);
00837 \}
00838 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{typename} Src>
00839 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00840 \textcolor{keywordtype}{void} call\_assignment\_no\_alias(Dst& dst, \textcolor{keyword}{const} Src& src)
00841 \{
00842   call\_assignment\_no\_alias(dst, src, 
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<typename Dst::Scalar,typename Src::Scalar>}
      ());
00843 \}
00844 
00845 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{typename} Src, \textcolor{keyword}{typename} Func>
00846 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00847 \textcolor{keywordtype}{void} call\_assignment\_no\_alias\_no\_transpose(Dst& dst, \textcolor{keyword}{const} Src& src, \textcolor{keyword}{const} Func& func)
00848 \{
00849   \textcolor{comment}{// TODO check whether this is the right place to perform these checks:}
00850   EIGEN\_STATIC\_ASSERT\_LVALUE(Dst)
00851   EIGEN\_STATIC\_ASSERT\_SAME\_MATRIX\_SIZE(Dst,Src)
00852   EIGEN\_CHECK\_BINARY\_COMPATIBILIY(Func,\textcolor{keyword}{typename} Dst::Scalar,\textcolor{keyword}{typename} Src::Scalar);
00853 
00854   \hyperlink{struct_eigen_1_1internal_1_1_assignment}{Assignment<Dst,Src,Func>::run}(dst, src, func);
00855 \}
00856 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{typename} Src>
00857 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00858 \textcolor{keywordtype}{void} call\_assignment\_no\_alias\_no\_transpose(Dst& dst, \textcolor{keyword}{const} Src& src)
00859 \{
00860   call\_assignment\_no\_alias\_no\_transpose(dst, src, 
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<typename Dst::Scalar,typename Src::Scalar>}
      ());
00861 \}
00862 
00863 \textcolor{comment}{// forward declaration}
00864 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{typename} Src> \textcolor{keywordtype}{void} check\_for\_aliasing(\textcolor{keyword}{const} Dst &dst, \textcolor{keyword}{const} Src &src);
00865 
00866 \textcolor{comment}{// Generic Dense to Dense assignment}
00867 \textcolor{comment}{// Note that the last template argument "Weak" is needed to make it possible to perform}
00868 \textcolor{comment}{// both partial specialization+SFINAE without ambiguous specialization}
00869 \textcolor{keyword}{template}< \textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType, \textcolor{keyword}{typename} Functor, \textcolor{keyword}{typename} Weak>
00870 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment}{Assignment}<DstXprType, SrcXprType, Functor, Dense2Dense, Weak>
00871 \{
00872   EIGEN\_DEVICE\_FUNC
00873   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} Functor &func)
00874   \{
00875 \textcolor{preprocessor}{#ifndef EIGEN\_NO\_DEBUG}
00876     internal::check\_for\_aliasing(dst, src);
00877 \textcolor{preprocessor}{#endif}
00878     
00879     call\_dense\_assignment\_loop(dst, src, func);
00880   \}
00881 \};
00882 
00883 \textcolor{comment}{// Generic assignment through evalTo.}
00884 \textcolor{comment}{// TODO: not sure we have to keep that one, but it helps porting current code to new evaluator mechanism.}
00885 \textcolor{comment}{// Note that the last template argument "Weak" is needed to make it possible to perform}
00886 \textcolor{comment}{// both partial specialization+SFINAE without ambiguous specialization}
00887 \textcolor{keyword}{template}< \textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType, \textcolor{keyword}{typename} Functor, \textcolor{keyword}{typename} Weak>
00888 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment}{Assignment}<DstXprType, SrcXprType, Functor, EigenBase2EigenBase, Weak>
00889 \{
00890   EIGEN\_DEVICE\_FUNC
00891   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<typename DstXprType::Scalar,typename SrcXprType::Scalar>}
       &\textcolor{comment}{/*func*/})
00892   \{
00893     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstRows = src.rows();
00894     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstCols = src.cols();
00895     \textcolor{keywordflow}{if}((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
00896       dst.resize(dstRows, dstCols);
00897 
00898     eigen\_assert(dst.rows() == src.rows() && dst.cols() == src.cols());
00899     src.evalTo(dst);
00900   \}
00901 
00902   \textcolor{comment}{// NOTE The following two functions are templated to avoid their instanciation if not needed}
00903   \textcolor{comment}{//      This is needed because some expressions supports evalTo only and/or have 'void' as scalar type.}
00904   \textcolor{keyword}{template}<\textcolor{keyword}{typename} SrcScalarType>
00905   EIGEN\_DEVICE\_FUNC
00906   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1add__assign__op}{internal::add\_assign\_op<typename DstXprType::Scalar,SrcScalarType>}
       &\textcolor{comment}{/*func*/})
00907   \{
00908     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstRows = src.rows();
00909     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstCols = src.cols();
00910     \textcolor{keywordflow}{if}((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
00911       dst.resize(dstRows, dstCols);
00912 
00913     eigen\_assert(dst.rows() == src.rows() && dst.cols() == src.cols());
00914     src.addTo(dst);
00915   \}
00916 
00917   \textcolor{keyword}{template}<\textcolor{keyword}{typename} SrcScalarType>
00918   EIGEN\_DEVICE\_FUNC
00919   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1sub__assign__op}{internal::sub\_assign\_op<typename DstXprType::Scalar,SrcScalarType>}
       &\textcolor{comment}{/*func*/})
00920   \{
00921     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstRows = src.rows();
00922     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstCols = src.cols();
00923     \textcolor{keywordflow}{if}((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
00924       dst.resize(dstRows, dstCols);
00925 
00926     eigen\_assert(dst.rows() == src.rows() && dst.cols() == src.cols());
00927     src.subTo(dst);
00928   \}
00929 \};
00930 
00931 \} \textcolor{comment}{// namespace internal}
00932 
00933 \} \textcolor{comment}{// end namespace Eigen}
00934 
00935 \textcolor{preprocessor}{#endif // EIGEN\_ASSIGN\_EVALUATOR\_H}
\end{DoxyCode}
