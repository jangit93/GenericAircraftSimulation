\hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source}{}\section{eigen/\+Eigen/src/\+Core/\+Redux.h}
\label{eigen_2_eigen_2src_2_core_2_redux_8h_source}\index{Redux.\+h@{Redux.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_REDUX\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_REDUX\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00017 
00018 \textcolor{comment}{// TODO}
00019 \textcolor{comment}{//  * implement other kind of vectorization}
00020 \textcolor{comment}{//  * factorize code}
00021 
00022 \textcolor{comment}{/***************************************************************************}
00023 \textcolor{comment}{* Part 1 : the logic deciding a strategy for vectorization and unrolling}
00024 \textcolor{comment}{***************************************************************************/}
00025 
00026 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00027}\hyperlink{struct_eigen_1_1internal_1_1redux__traits}{00027} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1redux__traits}{redux\_traits}
00028 \{
00029 \textcolor{keyword}{public}:
00030     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} find\_best\_packet<typename Derived::Scalar,Derived::SizeAtCompileTime>::type PacketType
      ;
00031   \textcolor{keyword}{enum} \{
00032     PacketSize = \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{unpacket\_traits<PacketType>::size},
00033     InnerMaxSize = int(Derived::IsRowMajor)
00034                  ? Derived::MaxColsAtCompileTime
00035                  : Derived::MaxRowsAtCompileTime
00036   \};
00037 
00038   \textcolor{keyword}{enum} \{
00039     MightVectorize = (int(Derived::Flags)&ActualPacketAccessBit)
00040                   && (\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits<Func>::PacketAccess}),
00041     MayLinearVectorize = bool(MightVectorize) && (int(Derived::Flags)&
      \hyperlink{group__flags_ga4b983a15d57cd55806df618ac544d09e}{LinearAccessBit}),
00042     MaySliceVectorize  = \textcolor{keywordtype}{bool}(MightVectorize) && int(InnerMaxSize)>=3*PacketSize
00043   \};
00044 
00045 \textcolor{keyword}{public}:
00046   \textcolor{keyword}{enum} \{
00047     Traversal = int(MayLinearVectorize) ? int(LinearVectorizedTraversal)
00048               : int(MaySliceVectorize)  ? int(SliceVectorizedTraversal)
00049                                         : int(DefaultTraversal)
00050   \};
00051 
00052 \textcolor{keyword}{public}:
00053   \textcolor{keyword}{enum} \{
00054     Cost = Derived::SizeAtCompileTime == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} ? \hyperlink{namespace_eigen_a3163430a1c13173faffde69016b48aaf}{HugeCost}
00055          : Derived::SizeAtCompileTime * Derived::CoeffReadCost + (Derived::SizeAtCompileTime-1) * 
      \hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits<Func>::Cost},
00056     UnrollingLimit = EIGEN\_UNROLLING\_LIMIT * (\textcolor{keywordtype}{int}(Traversal) == int(DefaultTraversal) ? 1 : int(PacketSize)
      )
00057   \};
00058 
00059 \textcolor{keyword}{public}:
00060   \textcolor{keyword}{enum} \{
00061     Unrolling = Cost <= UnrollingLimit ? CompleteUnrolling : NoUnrolling
00062   \};
00063   
00064 \textcolor{preprocessor}{#ifdef EIGEN\_DEBUG\_ASSIGN}
00065   \textcolor{keyword}{static} \textcolor{keywordtype}{void} debug()
00066   \{
00067     std::cerr << \textcolor{stringliteral}{"Xpr: "} << \textcolor{keyword}{typeid}(\textcolor{keyword}{typename} Derived::XprType).name() << std::endl;
00068     std::cerr.setf(std::ios::hex, std::ios::basefield);
00069     EIGEN\_DEBUG\_VAR(Derived::Flags)
00070     std::cerr.unsetf(std::ios::hex);
00071     EIGEN\_DEBUG\_VAR(InnerMaxSize)
00072     EIGEN\_DEBUG\_VAR(PacketSize)
00073     EIGEN\_DEBUG\_VAR(MightVectorize)
00074     EIGEN\_DEBUG\_VAR(MayLinearVectorize)
00075     EIGEN\_DEBUG\_VAR(MaySliceVectorize)
00076     EIGEN\_DEBUG\_VAR(Traversal)
00077     EIGEN\_DEBUG\_VAR(UnrollingLimit)
00078     EIGEN\_DEBUG\_VAR(Unrolling)
00079     std::cerr << std::endl;
00080   \}
00081 \textcolor{preprocessor}{#endif}
00082 \};
00083 
00084 \textcolor{comment}{/***************************************************************************}
00085 \textcolor{comment}{* Part 2 : unrollers}
00086 \textcolor{comment}{***************************************************************************/}
00087 
00088 \textcolor{comment}{/*** no vectorization ***/}
00089 
00090 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} Derived, \textcolor{keywordtype}{int} Start, \textcolor{keywordtype}{int} Length>
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00091}\hyperlink{struct_eigen_1_1internal_1_1redux__novec__unroller}{00091} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1redux__novec__unroller}{redux\_novec\_unroller}
00092 \{
00093   \textcolor{keyword}{enum} \{
00094     HalfLength = Length/2
00095   \};
00096 
00097   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00098 
00099   EIGEN\_DEVICE\_FUNC
00100   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(\textcolor{keyword}{const} Derived &mat, \textcolor{keyword}{const} Func& \hyperlink{structfunc}{func})
00101   \{
00102     \textcolor{keywordflow}{return} func(\hyperlink{struct_eigen_1_1internal_1_1redux__novec__unroller}{redux\_novec\_unroller<Func, Derived, Start, HalfLength>::run}
      (mat,func),
00103                 
      \hyperlink{struct_eigen_1_1internal_1_1redux__novec__unroller}{redux\_novec\_unroller<Func, Derived, Start+HalfLength, Length-HalfLength>::run}
      (mat,func));
00104   \}
00105 \};
00106 
00107 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} Derived, \textcolor{keywordtype}{int} Start>
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00108}\hyperlink{struct_eigen_1_1internal_1_1redux__novec__unroller_3_01_func_00_01_derived_00_01_start_00_011_01_4}{00108} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1redux__novec__unroller}{redux\_novec\_unroller}<Func, Derived, Start, 1>
00109 \{
00110   \textcolor{keyword}{enum} \{
00111     outer = Start / Derived::InnerSizeAtCompileTime,
00112     inner = Start % Derived::InnerSizeAtCompileTime
00113   \};
00114 
00115   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00116 
00117   EIGEN\_DEVICE\_FUNC
00118   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(\textcolor{keyword}{const} Derived &mat, \textcolor{keyword}{const} Func&)
00119   \{
00120     \textcolor{keywordflow}{return} mat.coeffByOuterInner(outer, inner);
00121   \}
00122 \};
00123 
00124 \textcolor{comment}{// This is actually dead code and will never be called. It is required}
00125 \textcolor{comment}{// to prevent false warnings regarding failed inlining though}
00126 \textcolor{comment}{// for 0 length run() will never be called at all.}
00127 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} Derived, \textcolor{keywordtype}{int} Start>
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00128}\hyperlink{struct_eigen_1_1internal_1_1redux__novec__unroller_3_01_func_00_01_derived_00_01_start_00_010_01_4}{00128} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1redux__novec__unroller}{redux\_novec\_unroller}<Func, Derived, Start, 0>
00129 \{
00130   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00131   EIGEN\_DEVICE\_FUNC 
00132   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(\textcolor{keyword}{const} Derived&, \textcolor{keyword}{const} Func&) \{ \textcolor{keywordflow}{return} Scalar(); \}
00133 \};
00134 
00135 \textcolor{comment}{/*** vectorization ***/}
00136 
00137 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} Derived, \textcolor{keywordtype}{int} Start, \textcolor{keywordtype}{int} Length>
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00138}\hyperlink{struct_eigen_1_1internal_1_1redux__vec__unroller}{00138} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1redux__vec__unroller}{redux\_vec\_unroller}
00139 \{
00140   \textcolor{keyword}{enum} \{
00141     PacketSize = \hyperlink{struct_eigen_1_1internal_1_1redux__traits}{redux\_traits<Func, Derived>::PacketSize},
00142     HalfLength = Length/2
00143   \};
00144 
00145   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00146   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} redux\_traits<Func, Derived>::PacketType PacketScalar;
00147 
00148   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE PacketScalar run(\textcolor{keyword}{const} Derived &mat, \textcolor{keyword}{const} Func& 
      \hyperlink{structfunc}{func})
00149   \{
00150     \textcolor{keywordflow}{return} func.packetOp(
00151             \hyperlink{struct_eigen_1_1internal_1_1redux__vec__unroller}{redux\_vec\_unroller<Func, Derived, Start, HalfLength>::run}
      (mat,func),
00152             
      \hyperlink{struct_eigen_1_1internal_1_1redux__vec__unroller}{redux\_vec\_unroller<Func, Derived, Start+HalfLength, Length-HalfLength>::run}
      (mat,func) );
00153   \}
00154 \};
00155 
00156 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} Derived, \textcolor{keywordtype}{int} Start>
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00157}\hyperlink{struct_eigen_1_1internal_1_1redux__vec__unroller_3_01_func_00_01_derived_00_01_start_00_011_01_4}{00157} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1redux__vec__unroller}{redux\_vec\_unroller}<Func, Derived, Start, 1>
00158 \{
00159   \textcolor{keyword}{enum} \{
00160     index = Start * \hyperlink{struct_eigen_1_1internal_1_1redux__traits}{redux\_traits<Func, Derived>::PacketSize},
00161     outer = index / int(Derived::InnerSizeAtCompileTime),
00162     inner = index % int(Derived::InnerSizeAtCompileTime),
00163     alignment = Derived::Alignment
00164   \};
00165 
00166   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00167   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} redux\_traits<Func, Derived>::PacketType PacketScalar;
00168 
00169   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE PacketScalar run(\textcolor{keyword}{const} Derived &mat, \textcolor{keyword}{const} Func&)
00170   \{
00171     \textcolor{keywordflow}{return} mat.template packetByOuterInner<alignment,PacketScalar>(outer, inner);
00172   \}
00173 \};
00174 
00175 \textcolor{comment}{/***************************************************************************}
00176 \textcolor{comment}{* Part 3 : implementation of all cases}
00177 \textcolor{comment}{***************************************************************************/}
00178 
00179 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} Derived,
00180          \textcolor{keywordtype}{int} Traversal = \hyperlink{struct_eigen_1_1internal_1_1redux__traits}{redux\_traits<Func, Derived>::Traversal},
00181          \textcolor{keywordtype}{int} Unrolling = \hyperlink{struct_eigen_1_1internal_1_1redux__traits}{redux\_traits<Func, Derived>::Unrolling}
00182 >
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00183}\hyperlink{struct_eigen_1_1internal_1_1redux__impl}{00183} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1redux__impl}{redux\_impl};
00184 
00185 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00186}\hyperlink{struct_eigen_1_1internal_1_1redux__impl_3_01_func_00_01_derived_00_01_default_traversal_00_01_no_unrolling_01_4}{00186} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1redux__impl}{redux\_impl}<Func, Derived, DefaultTraversal, NoUnrolling>
00187 \{
00188   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00189   EIGEN\_DEVICE\_FUNC
00190   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(\textcolor{keyword}{const} Derived &mat, \textcolor{keyword}{const} Func& \hyperlink{structfunc}{func})
00191   \{
00192     eigen\_assert(mat.rows()>0 && mat.cols()>0 && \textcolor{stringliteral}{"you are using an empty matrix"});
00193     Scalar res;
00194     res = mat.coeffByOuterInner(0, 0);
00195     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 1; i < mat.innerSize(); ++i)
00196       res = func(res, mat.coeffByOuterInner(0, i));
00197     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 1; i < mat.outerSize(); ++i)
00198       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < mat.innerSize(); ++j)
00199         res = func(res, mat.coeffByOuterInner(i, j));
00200     \textcolor{keywordflow}{return} res;
00201   \}
00202 \};
00203 
00204 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00205}\hyperlink{struct_eigen_1_1internal_1_1redux__impl_3_01_func_00_01_derived_00_01_default_traversal_00_01_complete_unrolling_01_4}{00205} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1redux__impl}{redux\_impl}<Func,Derived, DefaultTraversal, CompleteUnrolling>
00206   : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1internal_1_1redux__novec__unroller}{redux\_novec\_unroller}<Func,Derived, 0, Derived::SizeAtCompileTime>
00207 \{\};
00208 
00209 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00210}\hyperlink{struct_eigen_1_1internal_1_1redux__impl_3_01_func_00_01_derived_00_01_linear_vectorized_traversal_00_01_no_unrolling_01_4}{00210} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1redux__impl}{redux\_impl}<Func, Derived, LinearVectorizedTraversal, NoUnrolling>
00211 \{
00212   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00213   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} redux\_traits<Func, Derived>::PacketType PacketScalar;
00214 
00215   \textcolor{keyword}{static} Scalar run(\textcolor{keyword}{const} Derived &mat, \textcolor{keyword}{const} Func& \hyperlink{structfunc}{func})
00216   \{
00217     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = mat.size();
00218     
00219     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} packetSize = \hyperlink{struct_eigen_1_1internal_1_1redux__traits}{redux\_traits<Func, Derived>::PacketSize}
      ;
00220     \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetAlignment = \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{unpacket\_traits<PacketScalar>::alignment}
      ;
00221     \textcolor{keyword}{enum} \{
00222       alignment0 = (bool(Derived::Flags & \hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit}) && bool(
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<Scalar>::AlignedOnScalar})) ? \textcolor{keywordtype}{int}(packetAlignment) : int
      (\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}),
00223       alignment = EIGEN\_PLAIN\_ENUM\_MAX(alignment0, Derived::Alignment)
00224     \};
00225     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedStart = internal::first\_default\_aligned(mat.nestedExpression());
00226     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedSize2 = ((size-alignedStart)/(2*packetSize))*(2*packetSize);
00227     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedSize = ((size-alignedStart)/(packetSize))*(packetSize);
00228     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedEnd2 = alignedStart + alignedSize2;
00229     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedEnd  = alignedStart + alignedSize;
00230     Scalar res;
00231     \textcolor{keywordflow}{if}(alignedSize)
00232     \{
00233       PacketScalar packet\_res0 = mat.template packet<alignment,PacketScalar>(alignedStart);
00234       \textcolor{keywordflow}{if}(alignedSize>packetSize) \textcolor{comment}{// we have at least two packets to partly unroll the loop}
00235       \{
00236         PacketScalar packet\_res1 = mat.template packet<alignment,PacketScalar>(alignedStart+packetSize);
00237         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index = alignedStart + 2*packetSize; index < alignedEnd2; index += 2*packetSize)
00238         \{
00239           packet\_res0 = func.packetOp(packet\_res0, mat.template packet<alignment,PacketScalar>(index));
00240           packet\_res1 = func.packetOp(packet\_res1, mat.template packet<alignment,PacketScalar>(index+
      packetSize));
00241         \}
00242 
00243         packet\_res0 = func.packetOp(packet\_res0,packet\_res1);
00244         \textcolor{keywordflow}{if}(alignedEnd>alignedEnd2)
00245           packet\_res0 = func.packetOp(packet\_res0, mat.template packet<alignment,PacketScalar>(alignedEnd2)
      );
00246       \}
00247       res = func.predux(packet\_res0);
00248 
00249       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index = 0; index < alignedStart; ++index)
00250         res = func(res,mat.coeff(index));
00251 
00252       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index = alignedEnd; index < size; ++index)
00253         res = func(res,mat.coeff(index));
00254     \}
00255     \textcolor{keywordflow}{else} \textcolor{comment}{// too small to vectorize anything.}
00256          \textcolor{comment}{// since this is dynamic-size hence inefficient anyway for such small sizes, don't try to
       optimize.}
00257     \{
00258       res = mat.coeff(0);
00259       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index = 1; index < size; ++index)
00260         res = func(res,mat.coeff(index));
00261     \}
00262 
00263     \textcolor{keywordflow}{return} res;
00264   \}
00265 \};
00266 
00267 \textcolor{comment}{// NOTE: for SliceVectorizedTraversal we simply bypass unrolling}
00268 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} Derived, \textcolor{keywordtype}{int} Unrolling>
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00269}\hyperlink{struct_eigen_1_1internal_1_1redux__impl_3_01_func_00_01_derived_00_01_slice_vectorized_traversal_00_01_unrolling_01_4}{00269} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1redux__impl}{redux\_impl}<Func, Derived, SliceVectorizedTraversal, Unrolling>
00270 \{
00271   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00272   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} redux\_traits<Func, Derived>::PacketType PacketType;
00273 
00274   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} Scalar run(\textcolor{keyword}{const} Derived &mat, \textcolor{keyword}{const} Func& \hyperlink{structfunc}{func})
00275   \{
00276     eigen\_assert(mat.rows()>0 && mat.cols()>0 && \textcolor{stringliteral}{"you are using an empty matrix"});
00277     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} innerSize = mat.innerSize();
00278     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerSize = mat.outerSize();
00279     \textcolor{keyword}{enum} \{
00280       packetSize = \hyperlink{struct_eigen_1_1internal_1_1redux__traits}{redux\_traits<Func, Derived>::PacketSize}
00281     \};
00282     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} packetedInnerSize = ((innerSize)/packetSize)*packetSize;
00283     Scalar res;
00284     \textcolor{keywordflow}{if}(packetedInnerSize)
00285     \{
00286       PacketType packet\_res = mat.template packet<Unaligned,PacketType>(0,0);
00287       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<outerSize; ++j)
00288         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=(j==0?packetSize:0); i<packetedInnerSize; i+=\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(packetSize))
00289           packet\_res = func.packetOp(packet\_res, mat.template packetByOuterInner<Unaligned,PacketType>(j,i)
      );
00290 
00291       res = func.predux(packet\_res);
00292       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<outerSize; ++j)
00293         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=packetedInnerSize; i<innerSize; ++i)
00294           res = func(res, mat.coeffByOuterInner(j,i));
00295     \}
00296     \textcolor{keywordflow}{else} \textcolor{comment}{// too small to vectorize anything.}
00297          \textcolor{comment}{// since this is dynamic-size hence inefficient anyway for such small sizes, don't try to
       optimize.}
00298     \{
00299       res = \hyperlink{struct_eigen_1_1internal_1_1redux__impl}{redux\_impl<Func, Derived, DefaultTraversal, NoUnrolling>::run}
      (mat, func);
00300     \}
00301 
00302     \textcolor{keywordflow}{return} res;
00303   \}
00304 \};
00305 
00306 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00307}\hyperlink{struct_eigen_1_1internal_1_1redux__impl_3_01_func_00_01_derived_00_01_linear_vectorized_traversal_00_01_complete_unrolling_01_4}{00307} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1redux__impl}{redux\_impl}<Func, Derived, LinearVectorizedTraversal, CompleteUnrolling>
00308 \{
00309   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00310 
00311   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} redux\_traits<Func, Derived>::PacketType PacketScalar;
00312   \textcolor{keyword}{enum} \{
00313     PacketSize = \hyperlink{struct_eigen_1_1internal_1_1redux__traits}{redux\_traits<Func, Derived>::PacketSize},
00314     Size = Derived::SizeAtCompileTime,
00315     VectorizedSize = (Size / PacketSize) * PacketSize
00316   \};
00317   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(\textcolor{keyword}{const} Derived &mat, \textcolor{keyword}{const} Func& 
      \hyperlink{structfunc}{func})
00318   \{
00319     eigen\_assert(mat.rows()>0 && mat.cols()>0 && \textcolor{stringliteral}{"you are using an empty matrix"});
00320     \textcolor{keywordflow}{if} (VectorizedSize > 0) \{
00321       Scalar res = func.predux(
      \hyperlink{struct_eigen_1_1internal_1_1redux__vec__unroller}{redux\_vec\_unroller<Func, Derived, 0, Size / PacketSize>::run}
      (mat,func));
00322       \textcolor{keywordflow}{if} (VectorizedSize != Size)
00323         res = func(res,
      \hyperlink{struct_eigen_1_1internal_1_1redux__novec__unroller}{redux\_novec\_unroller<Func, Derived, VectorizedSize, Size-VectorizedSize>::run}
      (mat,func));
00324       \textcolor{keywordflow}{return} res;
00325     \}
00326     \textcolor{keywordflow}{else} \{
00327       \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1redux__novec__unroller}{redux\_novec\_unroller<Func, Derived, 0, Size>::run}
      (mat,func);
00328     \}
00329   \}
00330 \};
00331 
00332 \textcolor{comment}{// evaluator adaptor}
00333 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_XprType>
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00334}\hyperlink{class_eigen_1_1internal_1_1redux__evaluator}{00334} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1redux__evaluator}{redux\_evaluator}
00335 \{
00336 \textcolor{keyword}{public}:
00337   \textcolor{keyword}{typedef} \_XprType XprType;
00338   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1internal_1_1redux__evaluator}{redux\_evaluator}(\textcolor{keyword}{const} XprType &xpr) : m\_evaluator(xpr), m\_xpr(
      xpr) \{\}
00339   
00340   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00341   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00342   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::PacketScalar PacketScalar;
00343   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::PacketReturnType PacketReturnType;
00344   
00345   \textcolor{keyword}{enum} \{
00346     MaxRowsAtCompileTime = XprType::MaxRowsAtCompileTime,
00347     MaxColsAtCompileTime = XprType::MaxColsAtCompileTime,
00348     \textcolor{comment}{// TODO we should not remove DirectAccessBit and rather find an elegant way to query the alignment
       offset at runtime from the evaluator}
00349     Flags = \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<XprType>::Flags} & ~
      \hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit},
00350     IsRowMajor = XprType::IsRowMajor,
00351     SizeAtCompileTime = XprType::SizeAtCompileTime,
00352     InnerSizeAtCompileTime = XprType::InnerSizeAtCompileTime,
00353     CoeffReadCost = \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<XprType>::CoeffReadCost},
00354     Alignment = \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<XprType>::Alignment}
00355   \};
00356   
00357   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr.rows(); \}
00358   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr.cols(); \}
00359   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr.size(); \}
00360   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} innerSize()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr.innerSize(); \}
00361   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerSize()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr.outerSize(); \}
00362 
00363   EIGEN\_DEVICE\_FUNC
00364   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00365 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} m\_evaluator.coeff(row, col); \}
00366 
00367   EIGEN\_DEVICE\_FUNC
00368   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00369 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} m\_evaluator.coeff(index); \}
00370 
00371   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00372   \hyperlink{struct_eigen_1_1_packet_type}{PacketType} packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00373 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} m\_evaluator.template packet<LoadMode,PacketType>(row, col); \}
00374 
00375   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00376   \hyperlink{struct_eigen_1_1_packet_type}{PacketType} packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00377 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} m\_evaluator.template packet<LoadMode,PacketType>(index); \}
00378   
00379   EIGEN\_DEVICE\_FUNC
00380   CoeffReturnType coeffByOuterInner(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner)\textcolor{keyword}{ const}
00381 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} m\_evaluator.coeff(IsRowMajor ? outer : inner, IsRowMajor ? inner : outer); \}
00382   
00383   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00384   \hyperlink{struct_eigen_1_1_packet_type}{PacketType} packetByOuterInner(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner)\textcolor{keyword}{ const}
00385 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} m\_evaluator.template packet<LoadMode,PacketType>(IsRowMajor ? outer : inner, IsRowMajor ? inner 
      : outer); \}
00386   
00387   \textcolor{keyword}{const} XprType & nestedExpression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00388   
00389 \textcolor{keyword}{protected}:
00390   \hyperlink{struct_eigen_1_1internal_1_1evaluator}{internal::evaluator<XprType>} m\_evaluator;
00391   \textcolor{keyword}{const} XprType &m\_xpr;
00392 \};
00393 
00394 \} \textcolor{comment}{// end namespace internal}
00395 
00396 \textcolor{comment}{/***************************************************************************}
00397 \textcolor{comment}{* Part 4 : public API}
00398 \textcolor{comment}{***************************************************************************/}
00399 
00400 
00408 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00409 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func>
00410 \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Scalar}
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00411}\hyperlink{group___core___module_ad2ab5a8020dcd9d5986cb20d8a7ab213}{00411} \hyperlink{group___core___module_class_eigen_1_1_dense_base}{DenseBase<Derived>::redux}(\textcolor{keyword}{const} Func& \hyperlink{structfunc}{func})\textcolor{keyword}{ const}
00412 \textcolor{keyword}{}\{
00413   eigen\_assert(this->rows()>0 && this->cols()>0 && \textcolor{stringliteral}{"you are using an empty matrix"});
00414 
00415   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1redux__evaluator}{internal::redux\_evaluator<Derived>} ThisEvaluator;
00416   ThisEvaluator thisEval(derived());
00417   
00418   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1redux__impl}{internal::redux\_impl<Func, ThisEvaluator>::run}(
      thisEval, func);
00419 \}
00420 
00424 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00425 EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Scalar}
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00426}\hyperlink{group___core___module_a6634944be3d4fef551b57ffad30467f2}{00426} \hyperlink{group___core___module_a6634944be3d4fef551b57ffad30467f2}{DenseBase<Derived>::minCoeff}()\textcolor{keyword}{ const}
00427 \textcolor{keyword}{}\{
00428   \textcolor{keywordflow}{return} derived().redux(\hyperlink{struct_eigen_1_1internal_1_1scalar__min__op}{Eigen::internal::scalar\_min\_op<Scalar,Scalar>}
      ());
00429 \}
00430 
00434 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00435 EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Scalar}
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00436}\hyperlink{group___core___module_ac0d151ec47eb7a44a3a5ba1587ddbeb4}{00436} \hyperlink{group___core___module_ac0d151ec47eb7a44a3a5ba1587ddbeb4}{DenseBase<Derived>::maxCoeff}()\textcolor{keyword}{ const}
00437 \textcolor{keyword}{}\{
00438   \textcolor{keywordflow}{return} derived().redux(\hyperlink{struct_eigen_1_1internal_1_1scalar__max__op}{Eigen::internal::scalar\_max\_op<Scalar,Scalar>}
      ());
00439 \}
00440 
00447 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00448 EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Scalar}
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00449}\hyperlink{group___core___module_a4dee689c76ff86da9d8e49950604597b}{00449} \hyperlink{group___core___module_a4dee689c76ff86da9d8e49950604597b}{DenseBase<Derived>::sum}()\textcolor{keyword}{ const}
00450 \textcolor{keyword}{}\{
00451   \textcolor{keywordflow}{if}(SizeAtCompileTime==0 || (SizeAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} && size()==0))
00452     \textcolor{keywordflow}{return} \hyperlink{group___core___module_a5feed465b3a8e60c47e73ecce83e39a2}{Scalar}(0);
00453   \textcolor{keywordflow}{return} derived().redux(\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{Eigen::internal::scalar\_sum\_op<Scalar,Scalar>}
      ());
00454 \}
00455 
00460 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00461 EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Scalar}
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00462}\hyperlink{group___core___module_a89d85ac0cf349eb53481c148033459d7}{00462} \hyperlink{group___core___module_a89d85ac0cf349eb53481c148033459d7}{DenseBase<Derived>::mean}()\textcolor{keyword}{ const}
00463 \textcolor{keyword}{}\{
00464 \textcolor{preprocessor}{#ifdef \_\_INTEL\_COMPILER}
00465 \textcolor{preprocessor}{  #pragma warning push}
00466 \textcolor{preprocessor}{  #pragma warning ( disable : 2259 )}
00467 \textcolor{preprocessor}{#endif}
00468   \textcolor{keywordflow}{return} \hyperlink{group___core___module_a5feed465b3a8e60c47e73ecce83e39a2}{Scalar}(derived().redux(
      \hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{Eigen::internal::scalar\_sum\_op<Scalar,Scalar>}())) / 
      \hyperlink{group___core___module_a5feed465b3a8e60c47e73ecce83e39a2}{Scalar}(this->size());
00469 \textcolor{preprocessor}{#ifdef \_\_INTEL\_COMPILER}
00470 \textcolor{preprocessor}{  #pragma warning pop}
00471 \textcolor{preprocessor}{#endif}
00472 \}
00473 
00481 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00482 EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Scalar}
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00483}\hyperlink{group___core___module_a175ceb201923b4c6767770559e47e40e}{00483} \hyperlink{group___core___module_a175ceb201923b4c6767770559e47e40e}{DenseBase<Derived>::prod}()\textcolor{keyword}{ const}
00484 \textcolor{keyword}{}\{
00485   \textcolor{keywordflow}{if}(SizeAtCompileTime==0 || (SizeAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} && size()==0))
00486     \textcolor{keywordflow}{return} \hyperlink{group___core___module_a5feed465b3a8e60c47e73ecce83e39a2}{Scalar}(1);
00487   \textcolor{keywordflow}{return} derived().redux(\hyperlink{struct_eigen_1_1internal_1_1scalar__product__op}{Eigen::internal::scalar\_product\_op<Scalar>}
      ());
00488 \}
00489 
00496 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00497 EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Scalar}
\Hypertarget{eigen_2_eigen_2src_2_core_2_redux_8h_source_l00498}\hyperlink{group___core___module_a2cc7a95b161f3a660bdb8ff048b44161}{00498} \hyperlink{group___core___module_a2cc7a95b161f3a660bdb8ff048b44161}{MatrixBase<Derived>::trace}()\textcolor{keyword}{ const}
00499 \textcolor{keyword}{}\{
00500   \textcolor{keywordflow}{return} derived().diagonal().sum();
00501 \}
00502 
00503 \} \textcolor{comment}{// end namespace Eigen}
00504 
00505 \textcolor{preprocessor}{#endif // EIGEN\_REDUX\_H}
\end{DoxyCode}
