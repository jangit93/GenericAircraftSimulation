\hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source}{}\section{eigen/unsupported/\+Eigen/src/\+Special\+Functions/\+Special\+Functions\+Impl.h}
\label{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source}\index{Special\+Functions\+Impl.\+h@{Special\+Functions\+Impl.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Eugene Brevdo <ebrevdo@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SPECIAL\_FUNCTIONS\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SPECIAL\_FUNCTIONS\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00015 
00016 \textcolor{comment}{//  Parts of this code are based on the Cephes Math Library.}
00017 \textcolor{comment}{//}
00018 \textcolor{comment}{//  Cephes Math Library Release 2.8:  June, 2000}
00019 \textcolor{comment}{//  Copyright 1984, 1987, 1992, 2000 by Stephen L. Moshier}
00020 \textcolor{comment}{//}
00021 \textcolor{comment}{//  Permission has been kindly provided by the original author}
00022 \textcolor{comment}{//  to incorporate the Cephes software into the Eigen codebase:}
00023 \textcolor{comment}{//}
00024 \textcolor{comment}{//    From: Stephen Moshier}
00025 \textcolor{comment}{//    To: Eugene Brevdo}
00026 \textcolor{comment}{//    Subject: Re: Permission to wrap several cephes functions in Eigen}
00027 \textcolor{comment}{//}
00028 \textcolor{comment}{//    Hello Eugene,}
00029 \textcolor{comment}{//}
00030 \textcolor{comment}{//    Thank you for writing.}
00031 \textcolor{comment}{//}
00032 \textcolor{comment}{//    If your licensing is similar to BSD, the formal way that has been}
00033 \textcolor{comment}{//    handled is simply to add a statement to the effect that you are incorporating}
00034 \textcolor{comment}{//    the Cephes software by permission of the author.}
00035 \textcolor{comment}{//}
00036 \textcolor{comment}{//    Good luck with your project,}
00037 \textcolor{comment}{//    Steve}
00038 
00039 \textcolor{keyword}{namespace }cephes \{
00040 
00041 \textcolor{comment}{/* polevl (modified for Eigen)}
00042 \textcolor{comment}{ *}
00043 \textcolor{comment}{ *      Evaluate polynomial}
00044 \textcolor{comment}{ *}
00045 \textcolor{comment}{ *}
00046 \textcolor{comment}{ *}
00047 \textcolor{comment}{ * SYNOPSIS:}
00048 \textcolor{comment}{ *}
00049 \textcolor{comment}{ * int N;}
00050 \textcolor{comment}{ * Scalar x, y, coef[N+1];}
00051 \textcolor{comment}{ *}
00052 \textcolor{comment}{ * y = polevl<decltype(x), N>( x, coef);}
00053 \textcolor{comment}{ *}
00054 \textcolor{comment}{ *}
00055 \textcolor{comment}{ *}
00056 \textcolor{comment}{ * DESCRIPTION:}
00057 \textcolor{comment}{ *}
00058 \textcolor{comment}{ * Evaluates polynomial of degree N:}
00059 \textcolor{comment}{ *}
00060 \textcolor{comment}{ *                     2          N}
00061 \textcolor{comment}{ * y  =  C  + C x + C x  +...+ C x}
00062 \textcolor{comment}{ *        0    1     2          N}
00063 \textcolor{comment}{ *}
00064 \textcolor{comment}{ * Coefficients are stored in reverse order:}
00065 \textcolor{comment}{ *}
00066 \textcolor{comment}{ * coef[0] = C  , ..., coef[N] = C  .}
00067 \textcolor{comment}{ *            N                   0}
00068 \textcolor{comment}{ *}
00069 \textcolor{comment}{ *  The function p1evl() assumes that coef[N] = 1.0 and is}
00070 \textcolor{comment}{ * omitted from the array.  Its calling arguments are}
00071 \textcolor{comment}{ * otherwise the same as polevl().}
00072 \textcolor{comment}{ *}
00073 \textcolor{comment}{ *}
00074 \textcolor{comment}{ * The Eigen implementation is templatized.  For best speed, store}
00075 \textcolor{comment}{ * coef as a const array (constexpr), e.g.}
00076 \textcolor{comment}{ *}
00077 \textcolor{comment}{ * const double coef[] = \{1.0, 2.0, 3.0, ...\};}
00078 \textcolor{comment}{ *}
00079 \textcolor{comment}{ */}
00080 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} N>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00081}\hyperlink{struct_eigen_1_1internal_1_1cephes_1_1polevl}{00081} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1cephes_1_1polevl}{polevl} \{
00082   EIGEN\_DEVICE\_FUNC
00083   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(\textcolor{keyword}{const} Scalar x, \textcolor{keyword}{const} Scalar coef[]) \{
00084     EIGEN\_STATIC\_ASSERT((N > 0), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00085 
00086     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1cephes_1_1polevl}{polevl<Scalar, N - 1>::run}(x, coef) * x + coef[N];
00087   \}
00088 \};
00089 
00090 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00091}\hyperlink{struct_eigen_1_1internal_1_1cephes_1_1polevl_3_01_scalar_00_010_01_4}{00091} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1cephes_1_1polevl}{polevl}<Scalar, 0> \{
00092   EIGEN\_DEVICE\_FUNC
00093   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(\textcolor{keyword}{const} Scalar, \textcolor{keyword}{const} Scalar coef[]) \{
00094     \textcolor{keywordflow}{return} coef[0];
00095   \}
00096 \};
00097 
00098 \}  \textcolor{comment}{// end namespace cephes}
00099 
00100 \textcolor{comment}{/****************************************************************************}
00101 \textcolor{comment}{ * Implementation of lgamma, requires C++11/C99                             *}
00102 \textcolor{comment}{ ****************************************************************************/}
00103 
00104 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00105}\hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{00105} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl} \{
00106   EIGEN\_DEVICE\_FUNC
00107   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(\textcolor{keyword}{const} Scalar) \{
00108     EIGEN\_STATIC\_ASSERT((\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, Scalar>::value} 
      == \textcolor{keyword}{false}),
00109                         THIS\_TYPE\_IS\_NOT\_SUPPORTED);
00110     \textcolor{keywordflow}{return} Scalar(0);
00111   \}
00112 \};
00113 
00114 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00115}\hyperlink{struct_eigen_1_1internal_1_1lgamma__retval}{00115} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1lgamma__retval}{lgamma\_retval} \{
00116   \textcolor{keyword}{typedef} Scalar type;
00117 \};
00118 
00119 \textcolor{preprocessor}{#if EIGEN\_HAS\_C99\_MATH}
00120 \textcolor{keyword}{template} <>
00121 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl}<float> \{
00122   EIGEN\_DEVICE\_FUNC
00123   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} run(\textcolor{keywordtype}{float} x) \{
00124 \textcolor{preprocessor}{#if !defined(\_\_CUDA\_ARCH\_\_) && (defined(\_BSD\_SOURCE) || defined(\_SVID\_SOURCE)) && !defined(\_\_APPLE\_\_)}
00125     \textcolor{keywordtype}{int} signgam;
00126     return ::lgammaf\_r(x, &signgam);
00127 \textcolor{preprocessor}{#else}
00128     return ::lgammaf(x);
00129 \textcolor{preprocessor}{#endif}
00130   \}
00131 \};
00132 
00133 \textcolor{keyword}{template} <>
00134 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl}<double> \{
00135   EIGEN\_DEVICE\_FUNC
00136   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} run(\textcolor{keywordtype}{double} x) \{
00137 \textcolor{preprocessor}{#if !defined(\_\_CUDA\_ARCH\_\_) && (defined(\_BSD\_SOURCE) || defined(\_SVID\_SOURCE)) && !defined(\_\_APPLE\_\_)}
00138     \textcolor{keywordtype}{int} signgam;
00139     return ::lgamma\_r(x, &signgam);
00140 \textcolor{preprocessor}{#else}
00141     return ::lgamma(x);
00142 \textcolor{preprocessor}{#endif}
00143   \}
00144 \};
00145 \textcolor{preprocessor}{#endif}
00146 
00147 \textcolor{comment}{/****************************************************************************}
00148 \textcolor{comment}{ * Implementation of digamma (psi), based on Cephes                         *}
00149 \textcolor{comment}{ ****************************************************************************/}
00150 
00151 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00152}\hyperlink{struct_eigen_1_1internal_1_1digamma__retval}{00152} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1digamma__retval}{digamma\_retval} \{
00153   \textcolor{keyword}{typedef} Scalar type;
00154 \};
00155 
00156 \textcolor{comment}{/*}
00157 \textcolor{comment}{ *}
00158 \textcolor{comment}{ * Polynomial evaluation helper for the Psi (digamma) function.}
00159 \textcolor{comment}{ *}
00160 \textcolor{comment}{ * digamma\_impl\_maybe\_poly::run(s) evaluates the asymptotic Psi expansion for}
00161 \textcolor{comment}{ * input Scalar s, assuming s is above 10.0.}
00162 \textcolor{comment}{ *}
00163 \textcolor{comment}{ * If s is above a certain threshold for the given Scalar type, zero}
00164 \textcolor{comment}{ * is returned.  Otherwise the polynomial is evaluated with enough}
00165 \textcolor{comment}{ * coefficients for results matching Scalar machine precision.}
00166 \textcolor{comment}{ *}
00167 \textcolor{comment}{ *}
00168 \textcolor{comment}{ */}
00169 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00170}\hyperlink{struct_eigen_1_1internal_1_1digamma__impl__maybe__poly}{00170} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1digamma__impl__maybe__poly}{digamma\_impl\_maybe\_poly} \{
00171   EIGEN\_DEVICE\_FUNC
00172   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(\textcolor{keyword}{const} Scalar) \{
00173     EIGEN\_STATIC\_ASSERT((\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, Scalar>::value} 
      == \textcolor{keyword}{false}),
00174                         THIS\_TYPE\_IS\_NOT\_SUPPORTED);
00175     \textcolor{keywordflow}{return} Scalar(0);
00176   \}
00177 \};
00178 
00179 
00180 \textcolor{keyword}{template} <>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00181}\hyperlink{struct_eigen_1_1internal_1_1digamma__impl__maybe__poly_3_01float_01_4}{00181} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1digamma__impl__maybe__poly}{digamma\_impl\_maybe\_poly}<float> \{
00182   EIGEN\_DEVICE\_FUNC
00183   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} run(\textcolor{keyword}{const} \textcolor{keywordtype}{float} s) \{
00184     \textcolor{keyword}{const} \textcolor{keywordtype}{float} \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}[] = \{
00185       -4.16666666666666666667E-3f,
00186       3.96825396825396825397E-3f,
00187       -8.33333333333333333333E-3f,
00188       8.33333333333333333333E-2f
00189     \};
00190 
00191     \textcolor{keywordtype}{float} z;
00192     \textcolor{keywordflow}{if} (s < 1.0e8f) \{
00193       z = 1.0f / (s * s);
00194       \textcolor{keywordflow}{return} z * \hyperlink{struct_eigen_1_1internal_1_1cephes_1_1polevl}{cephes::polevl<float, 3>::run}(z, A);
00195     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} 0.0f;
00196   \}
00197 \};
00198 
00199 \textcolor{keyword}{template} <>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00200}\hyperlink{struct_eigen_1_1internal_1_1digamma__impl__maybe__poly_3_01double_01_4}{00200} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1digamma__impl__maybe__poly}{digamma\_impl\_maybe\_poly}<double> \{
00201   EIGEN\_DEVICE\_FUNC
00202   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} run(\textcolor{keyword}{const} \textcolor{keywordtype}{double} s) \{
00203     \textcolor{keyword}{const} \textcolor{keywordtype}{double} \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}[] = \{
00204       8.33333333333333333333E-2,
00205       -2.10927960927960927961E-2,
00206       7.57575757575757575758E-3,
00207       -4.16666666666666666667E-3,
00208       3.96825396825396825397E-3,
00209       -8.33333333333333333333E-3,
00210       8.33333333333333333333E-2
00211     \};
00212 
00213     \textcolor{keywordtype}{double} z;
00214     \textcolor{keywordflow}{if} (s < 1.0e17) \{
00215       z = 1.0 / (s * s);
00216       \textcolor{keywordflow}{return} z * \hyperlink{struct_eigen_1_1internal_1_1cephes_1_1polevl}{cephes::polevl<double, 6>::run}(z, A);
00217     \}
00218     \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} 0.0;
00219   \}
00220 \};
00221 
00222 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00223}\hyperlink{struct_eigen_1_1internal_1_1digamma__impl}{00223} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1digamma__impl}{digamma\_impl} \{
00224   EIGEN\_DEVICE\_FUNC
00225   \textcolor{keyword}{static} Scalar run(Scalar x) \{
00226     \textcolor{comment}{/*}
00227 \textcolor{comment}{     *}
00228 \textcolor{comment}{     *     Psi (digamma) function (modified for Eigen)}
00229 \textcolor{comment}{     *}
00230 \textcolor{comment}{     *}
00231 \textcolor{comment}{     * SYNOPSIS:}
00232 \textcolor{comment}{     *}
00233 \textcolor{comment}{     * double x, y, psi();}
00234 \textcolor{comment}{     *}
00235 \textcolor{comment}{     * y = psi( x );}
00236 \textcolor{comment}{     *}
00237 \textcolor{comment}{     *}
00238 \textcolor{comment}{     * DESCRIPTION:}
00239 \textcolor{comment}{     *}
00240 \textcolor{comment}{     *              d      -}
00241 \textcolor{comment}{     *   psi(x)  =  -- ln | (x)}
00242 \textcolor{comment}{     *              dx}
00243 \textcolor{comment}{     *}
00244 \textcolor{comment}{     * is the logarithmic derivative of the gamma function.}
00245 \textcolor{comment}{     * For integer x,}
00246 \textcolor{comment}{     *                   n-1}
00247 \textcolor{comment}{     *                    -}
00248 \textcolor{comment}{     * psi(n) = -EUL  +   >  1/k.}
00249 \textcolor{comment}{     *                    -}
00250 \textcolor{comment}{     *                   k=1}
00251 \textcolor{comment}{     *}
00252 \textcolor{comment}{     * If x is negative, it is transformed to a positive argument by the}
00253 \textcolor{comment}{     * reflection formula  psi(1-x) = psi(x) + pi cot(pi x).}
00254 \textcolor{comment}{     * For general positive x, the argument is made greater than 10}
00255 \textcolor{comment}{     * using the recurrence  psi(x+1) = psi(x) + 1/x.}
00256 \textcolor{comment}{     * Then the following asymptotic expansion is applied:}
00257 \textcolor{comment}{     *}
00258 \textcolor{comment}{     *                           inf.   B}
00259 \textcolor{comment}{     *                            -      2k}
00260 \textcolor{comment}{     * psi(x) = log(x) - 1/2x -   >   -------}
00261 \textcolor{comment}{     *                            -        2k}
00262 \textcolor{comment}{     *                           k=1   2k x}
00263 \textcolor{comment}{     *}
00264 \textcolor{comment}{     * where the B2k are Bernoulli numbers.}
00265 \textcolor{comment}{     *}
00266 \textcolor{comment}{     * ACCURACY (float):}
00267 \textcolor{comment}{     *    Relative error (except absolute when |psi| < 1):}
00268 \textcolor{comment}{     * arithmetic   domain     # trials      peak         rms}
00269 \textcolor{comment}{     *    IEEE      0,30        30000       1.3e-15     1.4e-16}
00270 \textcolor{comment}{     *    IEEE      -30,0       40000       1.5e-15     2.2e-16}
00271 \textcolor{comment}{     *}
00272 \textcolor{comment}{     * ACCURACY (double):}
00273 \textcolor{comment}{     *    Absolute error,  relative when |psi| > 1 :}
00274 \textcolor{comment}{     * arithmetic   domain     # trials      peak         rms}
00275 \textcolor{comment}{     *    IEEE      -33,0        30000      8.2e-7      1.2e-7}
00276 \textcolor{comment}{     *    IEEE      0,33        100000      7.3e-7      7.7e-8}
00277 \textcolor{comment}{     *}
00278 \textcolor{comment}{     * ERROR MESSAGES:}
00279 \textcolor{comment}{     *     message         condition      value returned}
00280 \textcolor{comment}{     * psi singularity    x integer <=0      INFINITY}
00281 \textcolor{comment}{     */}
00282 
00283     Scalar p, q, nz, s, w, y;
00284     \textcolor{keywordtype}{bool} negative = \textcolor{keyword}{false};
00285 
00286     \textcolor{keyword}{const} Scalar maxnum = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::infinity}();
00287     \textcolor{keyword}{const} Scalar m\_pi = Scalar(EIGEN\_PI);
00288 
00289     \textcolor{keyword}{const} Scalar zero = Scalar(0);
00290     \textcolor{keyword}{const} Scalar one = Scalar(1);
00291     \textcolor{keyword}{const} Scalar \hyperlink{struct_eigen_1_1half}{half} = Scalar(0.5);
00292     nz = zero;
00293 
00294     \textcolor{keywordflow}{if} (x <= zero) \{
00295       negative = \textcolor{keyword}{true};
00296       q = x;
00297       p = numext::floor(q);
00298       \textcolor{keywordflow}{if} (p == q) \{
00299         \textcolor{keywordflow}{return} maxnum;
00300       \}
00301       \textcolor{comment}{/* Remove the zeros of tan(m\_pi x)}
00302 \textcolor{comment}{       * by subtracting the nearest integer from x}
00303 \textcolor{comment}{       */}
00304       nz = q - p;
00305       \textcolor{keywordflow}{if} (nz != half) \{
00306         \textcolor{keywordflow}{if} (nz > half) \{
00307           p += one;
00308           nz = q - p;
00309         \}
00310         nz = m\_pi / numext::tan(m\_pi * nz);
00311       \}
00312       \textcolor{keywordflow}{else} \{
00313         nz = zero;
00314       \}
00315       x = one - x;
00316     \}
00317 
00318     \textcolor{comment}{/* use the recurrence psi(x+1) = psi(x) + 1/x. */}
00319     s = x;
00320     w = zero;
00321     \textcolor{keywordflow}{while} (s < Scalar(10)) \{
00322       w += one / s;
00323       s += one;
00324     \}
00325 
00326     y = \hyperlink{struct_eigen_1_1internal_1_1digamma__impl__maybe__poly}{digamma\_impl\_maybe\_poly<Scalar>::run}(s);
00327 
00328     y = numext::log(s) - (half / s) - y - w;
00329 
00330     \textcolor{keywordflow}{return} (negative) ? y - nz : y;
00331   \}
00332 \};
00333 
00334 \textcolor{comment}{/****************************************************************************}
00335 \textcolor{comment}{ * Implementation of erf, requires C++11/C99                                *}
00336 \textcolor{comment}{ ****************************************************************************/}
00337 
00338 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00339}\hyperlink{struct_eigen_1_1internal_1_1erf__impl}{00339} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1erf__impl}{erf\_impl} \{
00340   EIGEN\_DEVICE\_FUNC
00341   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(\textcolor{keyword}{const} Scalar) \{
00342     EIGEN\_STATIC\_ASSERT((\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, Scalar>::value} 
      == \textcolor{keyword}{false}),
00343                         THIS\_TYPE\_IS\_NOT\_SUPPORTED);
00344     \textcolor{keywordflow}{return} Scalar(0);
00345   \}
00346 \};
00347 
00348 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00349}\hyperlink{struct_eigen_1_1internal_1_1erf__retval}{00349} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1erf__retval}{erf\_retval} \{
00350   \textcolor{keyword}{typedef} Scalar type;
00351 \};
00352 
00353 \textcolor{preprocessor}{#if EIGEN\_HAS\_C99\_MATH}
00354 \textcolor{keyword}{template} <>
00355 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1erf__impl}{erf\_impl}<float> \{
00356   EIGEN\_DEVICE\_FUNC
00357   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} run(\textcolor{keywordtype}{float} x) \{ return ::erff(x); \}
00358 \};
00359 
00360 \textcolor{keyword}{template} <>
00361 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1erf__impl}{erf\_impl}<double> \{
00362   EIGEN\_DEVICE\_FUNC
00363   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} run(\textcolor{keywordtype}{double} x) \{ return ::erf(x); \}
00364 \};
00365 \textcolor{preprocessor}{#endif  // EIGEN\_HAS\_C99\_MATH}
00366 
00367 \textcolor{comment}{/***************************************************************************}
00368 \textcolor{comment}{* Implementation of erfc, requires C++11/C99                               *}
00369 \textcolor{comment}{****************************************************************************/}
00370 
00371 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00372}\hyperlink{struct_eigen_1_1internal_1_1erfc__impl}{00372} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1erfc__impl}{erfc\_impl} \{
00373   EIGEN\_DEVICE\_FUNC
00374   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(\textcolor{keyword}{const} Scalar) \{
00375     EIGEN\_STATIC\_ASSERT((\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, Scalar>::value} 
      == \textcolor{keyword}{false}),
00376                         THIS\_TYPE\_IS\_NOT\_SUPPORTED);
00377     \textcolor{keywordflow}{return} Scalar(0);
00378   \}
00379 \};
00380 
00381 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00382}\hyperlink{struct_eigen_1_1internal_1_1erfc__retval}{00382} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1erfc__retval}{erfc\_retval} \{
00383   \textcolor{keyword}{typedef} Scalar type;
00384 \};
00385 
00386 \textcolor{preprocessor}{#if EIGEN\_HAS\_C99\_MATH}
00387 \textcolor{keyword}{template} <>
00388 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1erfc__impl}{erfc\_impl}<float> \{
00389   EIGEN\_DEVICE\_FUNC
00390   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} run(\textcolor{keyword}{const} \textcolor{keywordtype}{float} x) \{ return ::erfcf(x); \}
00391 \};
00392 
00393 \textcolor{keyword}{template} <>
00394 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1erfc__impl}{erfc\_impl}<double> \{
00395   EIGEN\_DEVICE\_FUNC
00396   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} run(\textcolor{keyword}{const} \textcolor{keywordtype}{double} x) \{ return ::erfc(x); \}
00397 \};
00398 \textcolor{preprocessor}{#endif  // EIGEN\_HAS\_C99\_MATH}
00399 
00400 \textcolor{comment}{/**********************************************************************************************************
      ****}
00401 \textcolor{comment}{ * Implementation of igammac (complemented incomplete gamma integral), based on Cephes but requires C++11/
      C99 *}
00402 \textcolor{comment}{ **********************************************************************************************************
      ****/}
00403 
00404 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00405}\hyperlink{struct_eigen_1_1internal_1_1igammac__retval}{00405} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1igammac__retval}{igammac\_retval} \{
00406   \textcolor{keyword}{typedef} Scalar type;
00407 \};
00408 
00409 \textcolor{comment}{// NOTE: cephes\_helper is also used to implement zeta}
00410 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00411}\hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{00411} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper} \{
00412   EIGEN\_DEVICE\_FUNC
00413   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar machep() \{ assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"machep not supported for this type"}); \textcolor{keywordflow}{
      return} 0.0; \}
00414   EIGEN\_DEVICE\_FUNC
00415   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar big() \{ assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"big not supported for this type"}); \textcolor{keywordflow}{return} 0.0;
       \}
00416   EIGEN\_DEVICE\_FUNC
00417   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar biginv() \{ assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"biginv not supported for this type"}); \textcolor{keywordflow}{
      return} 0.0; \}
00418 \};
00419 
00420 \textcolor{keyword}{template} <>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00421}\hyperlink{struct_eigen_1_1internal_1_1cephes__helper_3_01float_01_4}{00421} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper}<float> \{
00422   EIGEN\_DEVICE\_FUNC
00423   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} machep() \{
00424     \textcolor{keywordflow}{return} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<float>::epsilon}() / 2;  \textcolor{comment}{// 1.0 - machep == 1.0}
00425   \}
00426   EIGEN\_DEVICE\_FUNC
00427   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} big() \{
00428     \textcolor{comment}{// use epsneg (1.0 - epsneg == 1.0)}
00429     \textcolor{keywordflow}{return} 1.0f / (\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<float>::epsilon}() / 2);
00430   \}
00431   EIGEN\_DEVICE\_FUNC
00432   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} biginv() \{
00433     \textcolor{comment}{// epsneg}
00434     \textcolor{keywordflow}{return} machep();
00435   \}
00436 \};
00437 
00438 \textcolor{keyword}{template} <>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00439}\hyperlink{struct_eigen_1_1internal_1_1cephes__helper_3_01double_01_4}{00439} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper}<double> \{
00440   EIGEN\_DEVICE\_FUNC
00441   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} machep() \{
00442     \textcolor{keywordflow}{return} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<double>::epsilon}() / 2;  \textcolor{comment}{// 1.0 - machep == 1.0}
00443   \}
00444   EIGEN\_DEVICE\_FUNC
00445   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} big() \{
00446     \textcolor{keywordflow}{return} 1.0 / \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<double>::epsilon}();
00447   \}
00448   EIGEN\_DEVICE\_FUNC
00449   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} biginv() \{
00450     \textcolor{comment}{// inverse of eps}
00451     \textcolor{keywordflow}{return} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<double>::epsilon}();
00452   \}
00453 \};
00454 
00455 \textcolor{preprocessor}{#if !EIGEN\_HAS\_C99\_MATH}
00456 
00457 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00458}\hyperlink{struct_eigen_1_1internal_1_1igammac__impl}{00458} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1igammac__impl}{igammac\_impl} \{
00459   EIGEN\_DEVICE\_FUNC
00460   \textcolor{keyword}{static} Scalar run(Scalar a, Scalar x) \{
00461     EIGEN\_STATIC\_ASSERT((\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, Scalar>::value} 
      == \textcolor{keyword}{false}),
00462                         THIS\_TYPE\_IS\_NOT\_SUPPORTED);
00463     \textcolor{keywordflow}{return} Scalar(0);
00464   \}
00465 \};
00466 
00467 \textcolor{preprocessor}{#else}
00468 
00469 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1igamma__impl}{igamma\_impl};  \textcolor{comment}{// predeclare igamma\_impl}
00470 
00471 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00472 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1igammac__impl}{igammac\_impl} \{
00473   EIGEN\_DEVICE\_FUNC
00474   \textcolor{keyword}{static} Scalar run(Scalar a, Scalar x) \{
00475     \textcolor{comment}{/*  igamc()}
00476 \textcolor{comment}{     *}
00477 \textcolor{comment}{     *  Incomplete gamma integral (modified for Eigen)}
00478 \textcolor{comment}{     *}
00479 \textcolor{comment}{     *}
00480 \textcolor{comment}{     *}
00481 \textcolor{comment}{     * SYNOPSIS:}
00482 \textcolor{comment}{     *}
00483 \textcolor{comment}{     * double a, x, y, igamc();}
00484 \textcolor{comment}{     *}
00485 \textcolor{comment}{     * y = igamc( a, x );}
00486 \textcolor{comment}{     *}
00487 \textcolor{comment}{     * DESCRIPTION:}
00488 \textcolor{comment}{     *}
00489 \textcolor{comment}{     * The function is defined by}
00490 \textcolor{comment}{     *}
00491 \textcolor{comment}{     *}
00492 \textcolor{comment}{     *  igamc(a,x)   =   1 - igam(a,x)}
00493 \textcolor{comment}{     *}
00494 \textcolor{comment}{     *                            inf.}
00495 \textcolor{comment}{     *                              -}
00496 \textcolor{comment}{     *                     1       | |  -t  a-1}
00497 \textcolor{comment}{     *               =   -----     |   e   t   dt.}
00498 \textcolor{comment}{     *                    -      | |}
00499 \textcolor{comment}{     *                   | (a)    -}
00500 \textcolor{comment}{     *                             x}
00501 \textcolor{comment}{     *}
00502 \textcolor{comment}{     *}
00503 \textcolor{comment}{     * In this implementation both arguments must be positive.}
00504 \textcolor{comment}{     * The integral is evaluated by either a power series or}
00505 \textcolor{comment}{     * continued fraction expansion, depending on the relative}
00506 \textcolor{comment}{     * values of a and x.}
00507 \textcolor{comment}{     *}
00508 \textcolor{comment}{     * ACCURACY (float):}
00509 \textcolor{comment}{     *}
00510 \textcolor{comment}{     *                      Relative error:}
00511 \textcolor{comment}{     * arithmetic   domain     # trials      peak         rms}
00512 \textcolor{comment}{     *    IEEE      0,30        30000       7.8e-6      5.9e-7}
00513 \textcolor{comment}{     *}
00514 \textcolor{comment}{     *}
00515 \textcolor{comment}{     * ACCURACY (double):}
00516 \textcolor{comment}{     *}
00517 \textcolor{comment}{     * Tested at random a, x.}
00518 \textcolor{comment}{     *                a         x                      Relative error:}
00519 \textcolor{comment}{     * arithmetic   domain   domain     # trials      peak         rms}
00520 \textcolor{comment}{     *    IEEE     0.5,100   0,100      200000       1.9e-14     1.7e-15}
00521 \textcolor{comment}{     *    IEEE     0.01,0.5  0,100      200000       1.4e-13     1.6e-15}
00522 \textcolor{comment}{     *}
00523 \textcolor{comment}{     */}
00524     \textcolor{comment}{/*}
00525 \textcolor{comment}{      Cephes Math Library Release 2.2: June, 1992}
00526 \textcolor{comment}{      Copyright 1985, 1987, 1992 by Stephen L. Moshier}
00527 \textcolor{comment}{      Direct inquiries to 30 Frost Street, Cambridge, MA 02140}
00528 \textcolor{comment}{    */}
00529     \textcolor{keyword}{const} Scalar zero = 0;
00530     \textcolor{keyword}{const} Scalar one = 1;
00531     \textcolor{keyword}{const} Scalar nan = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::quiet\_NaN}();
00532 
00533     \textcolor{keywordflow}{if} ((x < zero) || (a <= zero)) \{
00534       \textcolor{comment}{// domain error}
00535       \textcolor{keywordflow}{return} nan;
00536     \}
00537 
00538     \textcolor{keywordflow}{if} ((x < one) || (x < a)) \{
00539       \textcolor{comment}{/* The checks above ensure that we meet the preconditions for}
00540 \textcolor{comment}{       * igamma\_impl::Impl(), so call it, rather than igamma\_impl::Run().}
00541 \textcolor{comment}{       * Calling Run() would also work, but in that case the compiler may not be}
00542 \textcolor{comment}{       * able to prove that igammac\_impl::Run and igamma\_impl::Run are not}
00543 \textcolor{comment}{       * mutually recursive.  This leads to worse code, particularly on}
00544 \textcolor{comment}{       * platforms like nvptx, where recursion is allowed only begrudgingly.}
00545 \textcolor{comment}{       */}
00546       \textcolor{keywordflow}{return} (one - \hyperlink{struct_eigen_1_1internal_1_1igamma__impl}{igamma\_impl<Scalar>::Impl}(a, x));
00547     \}
00548 
00549     \textcolor{keywordflow}{return} Impl(a, x);
00550   \}
00551 
00552  \textcolor{keyword}{private}:
00553   \textcolor{comment}{/* igamma\_impl calls igammac\_impl::Impl. */}
00554   \textcolor{keyword}{friend} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1igamma__impl}{igamma\_impl}<Scalar>;
00555 
00556   \textcolor{comment}{/* Actually computes igamc(a, x).}
00557 \textcolor{comment}{   *}
00558 \textcolor{comment}{   * Preconditions:}
00559 \textcolor{comment}{   *   a > 0}
00560 \textcolor{comment}{   *   x >= 1}
00561 \textcolor{comment}{   *   x >= a}
00562 \textcolor{comment}{   */}
00563   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} Scalar Impl(Scalar a, Scalar x) \{
00564     \textcolor{keyword}{const} Scalar zero = 0;
00565     \textcolor{keyword}{const} Scalar one = 1;
00566     \textcolor{keyword}{const} Scalar two = 2;
00567     \textcolor{keyword}{const} Scalar machep = \hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper<Scalar>::machep}();
00568     \textcolor{keyword}{const} Scalar maxlog = numext::log(\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::highest}());
00569     \textcolor{keyword}{const} Scalar big = \hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper<Scalar>::big}();
00570     \textcolor{keyword}{const} Scalar biginv = \hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper<Scalar>::biginv}();
00571     \textcolor{keyword}{const} Scalar inf = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::infinity}();
00572 
00573     Scalar ans, ax, c, yc, r, t, y, z;
00574     Scalar pk, pkm1, pkm2, qk, qkm1, qkm2;
00575 
00576     \textcolor{keywordflow}{if} (x == inf) \textcolor{keywordflow}{return} zero;  \textcolor{comment}{// std::isinf crashes on CUDA}
00577 
00578     \textcolor{comment}{/* Compute  x**a * exp(-x) / gamma(a)  */}
00579     ax = a * numext::log(x) - x - \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<Scalar>::run}(a);
00580     \textcolor{keywordflow}{if} (ax < -maxlog) \{  \textcolor{comment}{// underflow}
00581       \textcolor{keywordflow}{return} zero;
00582     \}
00583     ax = numext::exp(ax);
00584 
00585     \textcolor{comment}{// continued fraction}
00586     y = one - a;
00587     z = x + y + one;
00588     c = zero;
00589     pkm2 = one;
00590     qkm2 = x;
00591     pkm1 = x + one;
00592     qkm1 = z * x;
00593     ans = pkm1 / qkm1;
00594 
00595     \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
00596       c += one;
00597       y += one;
00598       z += two;
00599       yc = y * c;
00600       pk = pkm1 * z - pkm2 * yc;
00601       qk = qkm1 * z - qkm2 * yc;
00602       \textcolor{keywordflow}{if} (qk != zero) \{
00603         r = pk / qk;
00604         t = numext::abs((ans - r) / r);
00605         ans = r;
00606       \} \textcolor{keywordflow}{else} \{
00607         t = one;
00608       \}
00609       pkm2 = pkm1;
00610       pkm1 = pk;
00611       qkm2 = qkm1;
00612       qkm1 = qk;
00613       \textcolor{keywordflow}{if} (numext::abs(pk) > big) \{
00614         pkm2 *= biginv;
00615         pkm1 *= biginv;
00616         qkm2 *= biginv;
00617         qkm1 *= biginv;
00618       \}
00619       \textcolor{keywordflow}{if} (t <= machep) \{
00620         \textcolor{keywordflow}{break};
00621       \}
00622     \}
00623 
00624     \textcolor{keywordflow}{return} (ans * ax);
00625   \}
00626 \};
00627 
00628 \textcolor{preprocessor}{#endif  // EIGEN\_HAS\_C99\_MATH}
00629 
00630 \textcolor{comment}{/************************************************************************************************}
00631 \textcolor{comment}{ * Implementation of igamma (incomplete gamma integral), based on Cephes but requires C++11/C99 *}
00632 \textcolor{comment}{ ************************************************************************************************/}
00633 
00634 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00635}\hyperlink{struct_eigen_1_1internal_1_1igamma__retval}{00635} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1igamma__retval}{igamma\_retval} \{
00636   \textcolor{keyword}{typedef} Scalar type;
00637 \};
00638 
00639 \textcolor{preprocessor}{#if !EIGEN\_HAS\_C99\_MATH}
00640 
00641 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00642}\hyperlink{struct_eigen_1_1internal_1_1igamma__impl}{00642} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1igamma__impl}{igamma\_impl} \{
00643   EIGEN\_DEVICE\_FUNC
00644   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(Scalar a, Scalar x) \{
00645     EIGEN\_STATIC\_ASSERT((\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, Scalar>::value} 
      == \textcolor{keyword}{false}),
00646                         THIS\_TYPE\_IS\_NOT\_SUPPORTED);
00647     \textcolor{keywordflow}{return} Scalar(0);
00648   \}
00649 \};
00650 
00651 \textcolor{preprocessor}{#else}
00652 
00653 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00654 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1igamma__impl}{igamma\_impl} \{
00655   EIGEN\_DEVICE\_FUNC
00656   \textcolor{keyword}{static} Scalar run(Scalar a, Scalar x) \{
00657     \textcolor{comment}{/*  igam()}
00658 \textcolor{comment}{     *  Incomplete gamma integral}
00659 \textcolor{comment}{     *}
00660 \textcolor{comment}{     *}
00661 \textcolor{comment}{     *}
00662 \textcolor{comment}{     * SYNOPSIS:}
00663 \textcolor{comment}{     *}
00664 \textcolor{comment}{     * double a, x, y, igam();}
00665 \textcolor{comment}{     *}
00666 \textcolor{comment}{     * y = igam( a, x );}
00667 \textcolor{comment}{     *}
00668 \textcolor{comment}{     * DESCRIPTION:}
00669 \textcolor{comment}{     *}
00670 \textcolor{comment}{     * The function is defined by}
00671 \textcolor{comment}{     *}
00672 \textcolor{comment}{     *                           x}
00673 \textcolor{comment}{     *                            -}
00674 \textcolor{comment}{     *                   1       | |  -t  a-1}
00675 \textcolor{comment}{     *  igam(a,x)  =   -----     |   e   t   dt.}
00676 \textcolor{comment}{     *                  -      | |}
00677 \textcolor{comment}{     *                 | (a)    -}
00678 \textcolor{comment}{     *                           0}
00679 \textcolor{comment}{     *}
00680 \textcolor{comment}{     *}
00681 \textcolor{comment}{     * In this implementation both arguments must be positive.}
00682 \textcolor{comment}{     * The integral is evaluated by either a power series or}
00683 \textcolor{comment}{     * continued fraction expansion, depending on the relative}
00684 \textcolor{comment}{     * values of a and x.}
00685 \textcolor{comment}{     *}
00686 \textcolor{comment}{     * ACCURACY (double):}
00687 \textcolor{comment}{     *}
00688 \textcolor{comment}{     *                      Relative error:}
00689 \textcolor{comment}{     * arithmetic   domain     # trials      peak         rms}
00690 \textcolor{comment}{     *    IEEE      0,30       200000       3.6e-14     2.9e-15}
00691 \textcolor{comment}{     *    IEEE      0,100      300000       9.9e-14     1.5e-14}
00692 \textcolor{comment}{     *}
00693 \textcolor{comment}{     *}
00694 \textcolor{comment}{     * ACCURACY (float):}
00695 \textcolor{comment}{     *}
00696 \textcolor{comment}{     *                      Relative error:}
00697 \textcolor{comment}{     * arithmetic   domain     # trials      peak         rms}
00698 \textcolor{comment}{     *    IEEE      0,30        20000       7.8e-6      5.9e-7}
00699 \textcolor{comment}{     *}
00700 \textcolor{comment}{     */}
00701     \textcolor{comment}{/*}
00702 \textcolor{comment}{      Cephes Math Library Release 2.2: June, 1992}
00703 \textcolor{comment}{      Copyright 1985, 1987, 1992 by Stephen L. Moshier}
00704 \textcolor{comment}{      Direct inquiries to 30 Frost Street, Cambridge, MA 02140}
00705 \textcolor{comment}{    */}
00706 
00707 
00708     \textcolor{comment}{/* left tail of incomplete gamma function:}
00709 \textcolor{comment}{     *}
00710 \textcolor{comment}{     *          inf.      k}
00711 \textcolor{comment}{     *   a  -x   -       x}
00712 \textcolor{comment}{     *  x  e     >   ----------}
00713 \textcolor{comment}{     *           -     -}
00714 \textcolor{comment}{     *          k=0   | (a+k+1)}
00715 \textcolor{comment}{     *}
00716 \textcolor{comment}{     */}
00717     \textcolor{keyword}{const} Scalar zero = 0;
00718     \textcolor{keyword}{const} Scalar one = 1;
00719     \textcolor{keyword}{const} Scalar nan = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::quiet\_NaN}();
00720 
00721     \textcolor{keywordflow}{if} (x == zero) \textcolor{keywordflow}{return} zero;
00722 
00723     \textcolor{keywordflow}{if} ((x < zero) || (a <= zero)) \{  \textcolor{comment}{// domain error}
00724       \textcolor{keywordflow}{return} nan;
00725     \}
00726 
00727     \textcolor{keywordflow}{if} ((x > one) && (x > a)) \{
00728       \textcolor{comment}{/* The checks above ensure that we meet the preconditions for}
00729 \textcolor{comment}{       * igammac\_impl::Impl(), so call it, rather than igammac\_impl::Run().}
00730 \textcolor{comment}{       * Calling Run() would also work, but in that case the compiler may not be}
00731 \textcolor{comment}{       * able to prove that igammac\_impl::Run and igamma\_impl::Run are not}
00732 \textcolor{comment}{       * mutually recursive.  This leads to worse code, particularly on}
00733 \textcolor{comment}{       * platforms like nvptx, where recursion is allowed only begrudgingly.}
00734 \textcolor{comment}{       */}
00735       \textcolor{keywordflow}{return} (one - \hyperlink{struct_eigen_1_1internal_1_1igammac__impl}{igammac\_impl<Scalar>::Impl}(a, x));
00736     \}
00737 
00738     \textcolor{keywordflow}{return} Impl(a, x);
00739   \}
00740 
00741  \textcolor{keyword}{private}:
00742   \textcolor{comment}{/* igammac\_impl calls igamma\_impl::Impl. */}
00743   \textcolor{keyword}{friend} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1igammac__impl}{igammac\_impl}<Scalar>;
00744 
00745   \textcolor{comment}{/* Actually computes igam(a, x).}
00746 \textcolor{comment}{   *}
00747 \textcolor{comment}{   * Preconditions:}
00748 \textcolor{comment}{   *   x > 0}
00749 \textcolor{comment}{   *   a > 0}
00750 \textcolor{comment}{   *   !(x > 1 && x > a)}
00751 \textcolor{comment}{   */}
00752   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} Scalar Impl(Scalar a, Scalar x) \{
00753     \textcolor{keyword}{const} Scalar zero = 0;
00754     \textcolor{keyword}{const} Scalar one = 1;
00755     \textcolor{keyword}{const} Scalar machep = \hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper<Scalar>::machep}();
00756     \textcolor{keyword}{const} Scalar maxlog = numext::log(\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::highest}());
00757 
00758     Scalar ans, ax, c, r;
00759 
00760     \textcolor{comment}{/* Compute  x**a * exp(-x) / gamma(a)  */}
00761     ax = a * numext::log(x) - x - \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<Scalar>::run}(a);
00762     \textcolor{keywordflow}{if} (ax < -maxlog) \{
00763       \textcolor{comment}{// underflow}
00764       \textcolor{keywordflow}{return} zero;
00765     \}
00766     ax = numext::exp(ax);
00767 
00768     \textcolor{comment}{/* power series */}
00769     r = a;
00770     c = one;
00771     ans = one;
00772 
00773     \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
00774       r += one;
00775       c *= x/r;
00776       ans += c;
00777       \textcolor{keywordflow}{if} (c/ans <= machep) \{
00778         \textcolor{keywordflow}{break};
00779       \}
00780     \}
00781 
00782     \textcolor{keywordflow}{return} (ans * ax / a);
00783   \}
00784 \};
00785 
00786 \textcolor{preprocessor}{#endif  // EIGEN\_HAS\_C99\_MATH}
00787 
00788 \textcolor{comment}{/*****************************************************************************}
00789 \textcolor{comment}{ * Implementation of Riemann zeta function of two arguments, based on Cephes *}
00790 \textcolor{comment}{ *****************************************************************************/}
00791 
00792 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00793}\hyperlink{struct_eigen_1_1internal_1_1zeta__retval}{00793} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1zeta__retval}{zeta\_retval} \{
00794     \textcolor{keyword}{typedef} Scalar type;
00795 \};
00796 
00797 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00798}\hyperlink{struct_eigen_1_1internal_1_1zeta__impl__series}{00798} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1zeta__impl__series}{zeta\_impl\_series} \{
00799   EIGEN\_DEVICE\_FUNC
00800   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(\textcolor{keyword}{const} Scalar) \{
00801     EIGEN\_STATIC\_ASSERT((\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, Scalar>::value} 
      == \textcolor{keyword}{false}),
00802                         THIS\_TYPE\_IS\_NOT\_SUPPORTED);
00803     \textcolor{keywordflow}{return} Scalar(0);
00804   \}
00805 \};
00806 
00807 \textcolor{keyword}{template} <>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00808}\hyperlink{struct_eigen_1_1internal_1_1zeta__impl__series_3_01float_01_4}{00808} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1zeta__impl__series}{zeta\_impl\_series}<float> \{
00809   EIGEN\_DEVICE\_FUNC
00810   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} run(\textcolor{keywordtype}{float}& a, \textcolor{keywordtype}{float}& b, \textcolor{keywordtype}{float}& s, \textcolor{keyword}{const} \textcolor{keywordtype}{float} x, \textcolor{keyword}{const} \textcolor{keywordtype}{float} machep) \{
00811     \textcolor{keywordtype}{int} i = 0;
00812     \textcolor{keywordflow}{while}(i < 9)
00813     \{
00814         i += 1;
00815         a += 1.0f;
00816         b = numext::pow( a, -x );
00817         s += b;
00818         \textcolor{keywordflow}{if}( numext::abs(b/s) < machep )
00819             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00820     \}
00821 
00822     \textcolor{comment}{//Return whether we are done}
00823     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00824   \}
00825 \};
00826 
00827 \textcolor{keyword}{template} <>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00828}\hyperlink{struct_eigen_1_1internal_1_1zeta__impl__series_3_01double_01_4}{00828} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1zeta__impl__series}{zeta\_impl\_series}<double> \{
00829   EIGEN\_DEVICE\_FUNC
00830   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} run(\textcolor{keywordtype}{double}& a, \textcolor{keywordtype}{double}& b, \textcolor{keywordtype}{double}& s, \textcolor{keyword}{const} \textcolor{keywordtype}{double} x, \textcolor{keyword}{const} \textcolor{keywordtype}{double} machep)
       \{
00831     \textcolor{keywordtype}{int} i = 0;
00832     \textcolor{keywordflow}{while}( (i < 9) || (a <= 9.0) )
00833     \{
00834         i += 1;
00835         a += 1.0;
00836         b = numext::pow( a, -x );
00837         s += b;
00838         \textcolor{keywordflow}{if}( numext::abs(b/s) < machep )
00839             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00840     \}
00841 
00842     \textcolor{comment}{//Return whether we are done}
00843     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00844   \}
00845 \};
00846 
00847 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00848}\hyperlink{struct_eigen_1_1internal_1_1zeta__impl}{00848} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1zeta__impl}{zeta\_impl} \{
00849     EIGEN\_DEVICE\_FUNC
00850     \textcolor{keyword}{static} Scalar run(Scalar x, Scalar q) \{
00851         \textcolor{comment}{/*                          zeta.c}
00852 \textcolor{comment}{         *}
00853 \textcolor{comment}{         *  Riemann zeta function of two arguments}
00854 \textcolor{comment}{         *}
00855 \textcolor{comment}{         *}
00856 \textcolor{comment}{         *}
00857 \textcolor{comment}{         * SYNOPSIS:}
00858 \textcolor{comment}{         *}
00859 \textcolor{comment}{         * double x, q, y, zeta();}
00860 \textcolor{comment}{         *}
00861 \textcolor{comment}{         * y = zeta( x, q );}
00862 \textcolor{comment}{         *}
00863 \textcolor{comment}{         *}
00864 \textcolor{comment}{         *}
00865 \textcolor{comment}{         * DESCRIPTION:}
00866 \textcolor{comment}{         *}
00867 \textcolor{comment}{         *}
00868 \textcolor{comment}{         *}
00869 \textcolor{comment}{         *                 inf.}
00870 \textcolor{comment}{         *                  -        -x}
00871 \textcolor{comment}{         *   zeta(x,q)  =   >   (k+q)}
00872 \textcolor{comment}{         *                  -}
00873 \textcolor{comment}{         *                 k=0}
00874 \textcolor{comment}{         *}
00875 \textcolor{comment}{         * where x > 1 and q is not a negative integer or zero.}
00876 \textcolor{comment}{         * The Euler-Maclaurin summation formula is used to obtain}
00877 \textcolor{comment}{         * the expansion}
00878 \textcolor{comment}{         *}
00879 \textcolor{comment}{         *                n}
00880 \textcolor{comment}{         *                -       -x}
00881 \textcolor{comment}{         * zeta(x,q)  =   >  (k+q)}
00882 \textcolor{comment}{         *                -}
00883 \textcolor{comment}{         *               k=1}
00884 \textcolor{comment}{         *}
00885 \textcolor{comment}{         *           1-x                 inf.  B   x(x+1)...(x+2j)}
00886 \textcolor{comment}{         *      (n+q)           1         -     2j}
00887 \textcolor{comment}{         *  +  ---------  -  -------  +   >    --------------------}
00888 \textcolor{comment}{         *        x-1              x      -                   x+2j+1}
00889 \textcolor{comment}{         *                   2(n+q)      j=1       (2j)! (n+q)}
00890 \textcolor{comment}{         *}
00891 \textcolor{comment}{         * where the B2j are Bernoulli numbers.  Note that (see zetac.c)}
00892 \textcolor{comment}{         * zeta(x,1) = zetac(x) + 1.}
00893 \textcolor{comment}{         *}
00894 \textcolor{comment}{         *}
00895 \textcolor{comment}{         *}
00896 \textcolor{comment}{         * ACCURACY:}
00897 \textcolor{comment}{         *}
00898 \textcolor{comment}{         * Relative error for single precision:}
00899 \textcolor{comment}{         * arithmetic   domain     # trials      peak         rms}
00900 \textcolor{comment}{         *    IEEE      0,25        10000       6.9e-7      1.0e-7}
00901 \textcolor{comment}{         *}
00902 \textcolor{comment}{         * Large arguments may produce underflow in powf(), in which}
00903 \textcolor{comment}{         * case the results are inaccurate.}
00904 \textcolor{comment}{         *}
00905 \textcolor{comment}{         * REFERENCE:}
00906 \textcolor{comment}{         *}
00907 \textcolor{comment}{         * Gradshteyn, I. S., and I. M. Ryzhik, Tables of Integrals,}
00908 \textcolor{comment}{         * Series, and Products, p. 1073; Academic Press, 1980.}
00909 \textcolor{comment}{         *}
00910 \textcolor{comment}{         */}
00911 
00912         \textcolor{keywordtype}{int} i;
00913         Scalar p, r, a, b, k, s, t, w;
00914 
00915         \textcolor{keyword}{const} Scalar \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}[] = \{
00916             Scalar(12.0),
00917             Scalar(-720.0),
00918             Scalar(30240.0),
00919             Scalar(-1209600.0),
00920             Scalar(47900160.0),
00921             Scalar(-1.8924375803183791606e9), \textcolor{comment}{/*1.307674368e12/691*/}
00922             Scalar(7.47242496e10),
00923             Scalar(-2.950130727918164224e12), \textcolor{comment}{/*1.067062284288e16/3617*/}
00924             Scalar(1.1646782814350067249e14), \textcolor{comment}{/*5.109094217170944e18/43867*/}
00925             Scalar(-4.5979787224074726105e15), \textcolor{comment}{/*8.028576626982912e20/174611*/}
00926             Scalar(1.8152105401943546773e17), \textcolor{comment}{/*1.5511210043330985984e23/854513*/}
00927             Scalar(-7.1661652561756670113e18) \textcolor{comment}{/*1.6938241367317436694528e27/236364091*/}
00928             \};
00929 
00930         \textcolor{keyword}{const} Scalar maxnum = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::infinity}();
00931         \textcolor{keyword}{const} Scalar zero = 0.0, \hyperlink{struct_eigen_1_1half}{half} = 0.5, one = 1.0;
00932         \textcolor{keyword}{const} Scalar machep = \hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper<Scalar>::machep}();
00933         \textcolor{keyword}{const} Scalar nan = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::quiet\_NaN}();
00934 
00935         \textcolor{keywordflow}{if}( x == one )
00936             \textcolor{keywordflow}{return} maxnum;
00937 
00938         \textcolor{keywordflow}{if}( x < one )
00939         \{
00940             \textcolor{keywordflow}{return} nan;
00941         \}
00942 
00943         \textcolor{keywordflow}{if}( q <= zero )
00944         \{
00945             \textcolor{keywordflow}{if}(q == numext::floor(q))
00946             \{
00947                 \textcolor{keywordflow}{return} maxnum;
00948             \}
00949             p = x;
00950             r = numext::floor(p);
00951             \textcolor{keywordflow}{if} (p != r)
00952                 \textcolor{keywordflow}{return} nan;
00953         \}
00954 
00955         \textcolor{comment}{/* Permit negative q but continue sum until n+q > +9 .}
00956 \textcolor{comment}{         * This case should be handled by a reflection formula.}
00957 \textcolor{comment}{         * If q<0 and x is an integer, there is a relation to}
00958 \textcolor{comment}{         * the polygamma function.}
00959 \textcolor{comment}{         */}
00960         s = numext::pow( q, -x );
00961         a = q;
00962         b = zero;
00963         \textcolor{comment}{// Run the summation in a helper function that is specific to the floating precision}
00964         \textcolor{keywordflow}{if} (\hyperlink{struct_eigen_1_1internal_1_1zeta__impl__series}{zeta\_impl\_series<Scalar>::run}(a, b, s, x, machep)) \{
00965             \textcolor{keywordflow}{return} s;
00966         \}
00967 
00968         w = a;
00969         s += b*w/(x-one);
00970         s -= \hyperlink{struct_eigen_1_1half}{half} * b;
00971         a = one;
00972         k = zero;
00973         \textcolor{keywordflow}{for}( i=0; i<12; i++ )
00974         \{
00975             a *= x + k;
00976             b /= w;
00977             t = a*b/A[i];
00978             s = s + t;
00979             t = numext::abs(t/s);
00980             \textcolor{keywordflow}{if}( t < machep ) \{
00981               \textcolor{keywordflow}{break};
00982             \}
00983             k += one;
00984             a *= x + k;
00985             b /= w;
00986             k += one;
00987         \}
00988         \textcolor{keywordflow}{return} s;
00989   \}
00990 \};
00991 
00992 \textcolor{comment}{/****************************************************************************}
00993 \textcolor{comment}{ * Implementation of polygamma function, requires C++11/C99                 *}
00994 \textcolor{comment}{ ****************************************************************************/}
00995 
00996 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l00997}\hyperlink{struct_eigen_1_1internal_1_1polygamma__retval}{00997} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1polygamma__retval}{polygamma\_retval} \{
00998     \textcolor{keyword}{typedef} Scalar type;
00999 \};
01000 
01001 \textcolor{preprocessor}{#if !EIGEN\_HAS\_C99\_MATH}
01002 
01003 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l01004}\hyperlink{struct_eigen_1_1internal_1_1polygamma__impl}{01004} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1polygamma__impl}{polygamma\_impl} \{
01005     EIGEN\_DEVICE\_FUNC
01006     \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(Scalar n, Scalar x) \{
01007         EIGEN\_STATIC\_ASSERT((\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, Scalar>::value}
       == \textcolor{keyword}{false}),
01008                             THIS\_TYPE\_IS\_NOT\_SUPPORTED);
01009         \textcolor{keywordflow}{return} Scalar(0);
01010     \}
01011 \};
01012 
01013 \textcolor{preprocessor}{#else}
01014 
01015 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01016 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1polygamma__impl}{polygamma\_impl} \{
01017     EIGEN\_DEVICE\_FUNC
01018     \textcolor{keyword}{static} Scalar run(Scalar n, Scalar x) \{
01019         Scalar zero = 0.0, one = 1.0;
01020         Scalar nplus = n + one;
01021         \textcolor{keyword}{const} Scalar nan = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::quiet\_NaN}();
01022 
01023         \textcolor{comment}{// Check that n is an integer}
01024         \textcolor{keywordflow}{if} (numext::floor(n) != n) \{
01025             \textcolor{keywordflow}{return} nan;
01026         \}
01027         \textcolor{comment}{// Just return the digamma function for n = 1}
01028         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n == zero) \{
01029             \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1digamma__impl}{digamma\_impl<Scalar>::run}(x);
01030         \}
01031         \textcolor{comment}{// Use the same implementation as scipy}
01032         \textcolor{keywordflow}{else} \{
01033             Scalar factorial = numext::exp(\hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<Scalar>::run}(nplus));
01034             \textcolor{keywordflow}{return} numext::pow(-one, nplus) * factorial * \hyperlink{struct_eigen_1_1internal_1_1zeta__impl}{zeta\_impl<Scalar>::run}(
      nplus, x);
01035         \}
01036   \}
01037 \};
01038 
01039 \textcolor{preprocessor}{#endif  // EIGEN\_HAS\_C99\_MATH}
01040 
01041 \textcolor{comment}{/************************************************************************************************}
01042 \textcolor{comment}{ * Implementation of betainc (incomplete beta integral), based on Cephes but requires C++11/C99 *}
01043 \textcolor{comment}{ ************************************************************************************************/}
01044 
01045 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l01046}\hyperlink{struct_eigen_1_1internal_1_1betainc__retval}{01046} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1betainc__retval}{betainc\_retval} \{
01047   \textcolor{keyword}{typedef} Scalar type;
01048 \};
01049 
01050 \textcolor{preprocessor}{#if !EIGEN\_HAS\_C99\_MATH}
01051 
01052 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_special_functions_2_special_functions_impl_8h_source_l01053}\hyperlink{struct_eigen_1_1internal_1_1betainc__impl}{01053} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1betainc__impl}{betainc\_impl} \{
01054   EIGEN\_DEVICE\_FUNC
01055   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(Scalar a, Scalar b, Scalar x) \{
01056     EIGEN\_STATIC\_ASSERT((\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, Scalar>::value} 
      == \textcolor{keyword}{false}),
01057                         THIS\_TYPE\_IS\_NOT\_SUPPORTED);
01058     \textcolor{keywordflow}{return} Scalar(0);
01059   \}
01060 \};
01061 
01062 \textcolor{preprocessor}{#else}
01063 
01064 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01065 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1betainc__impl}{betainc\_impl} \{
01066   EIGEN\_DEVICE\_FUNC
01067   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(Scalar, Scalar, Scalar) \{
01068     \textcolor{comment}{/*  betaincf.c}
01069 \textcolor{comment}{     *}
01070 \textcolor{comment}{     *  Incomplete beta integral}
01071 \textcolor{comment}{     *}
01072 \textcolor{comment}{     *}
01073 \textcolor{comment}{     * SYNOPSIS:}
01074 \textcolor{comment}{     *}
01075 \textcolor{comment}{     * float a, b, x, y, betaincf();}
01076 \textcolor{comment}{     *}
01077 \textcolor{comment}{     * y = betaincf( a, b, x );}
01078 \textcolor{comment}{     *}
01079 \textcolor{comment}{     *}
01080 \textcolor{comment}{     * DESCRIPTION:}
01081 \textcolor{comment}{     *}
01082 \textcolor{comment}{     * Returns incomplete beta integral of the arguments, evaluated}
01083 \textcolor{comment}{     * from zero to x.  The function is defined as}
01084 \textcolor{comment}{     *}
01085 \textcolor{comment}{     *                  x}
01086 \textcolor{comment}{     *     -            -}
01087 \textcolor{comment}{     *    | (a+b)      | |  a-1     b-1}
01088 \textcolor{comment}{     *  -----------    |   t   (1-t)   dt.}
01089 \textcolor{comment}{     *   -     -     | |}
01090 \textcolor{comment}{     *  | (a) | (b)   -}
01091 \textcolor{comment}{     *                 0}
01092 \textcolor{comment}{     *}
01093 \textcolor{comment}{     * The domain of definition is 0 <= x <= 1.  In this}
01094 \textcolor{comment}{     * implementation a and b are restricted to positive values.}
01095 \textcolor{comment}{     * The integral from x to 1 may be obtained by the symmetry}
01096 \textcolor{comment}{     * relation}
01097 \textcolor{comment}{     *}
01098 \textcolor{comment}{     *    1 - betainc( a, b, x )  =  betainc( b, a, 1-x ).}
01099 \textcolor{comment}{     *}
01100 \textcolor{comment}{     * The integral is evaluated by a continued fraction expansion.}
01101 \textcolor{comment}{     * If a < 1, the function calls itself recursively after a}
01102 \textcolor{comment}{     * transformation to increase a to a+1.}
01103 \textcolor{comment}{     *}
01104 \textcolor{comment}{     * ACCURACY (float):}
01105 \textcolor{comment}{     *}
01106 \textcolor{comment}{     * Tested at random points (a,b,x) with a and b in the indicated}
01107 \textcolor{comment}{     * interval and x between 0 and 1.}
01108 \textcolor{comment}{     *}
01109 \textcolor{comment}{     * arithmetic   domain     # trials      peak         rms}
01110 \textcolor{comment}{     * Relative error:}
01111 \textcolor{comment}{     *    IEEE       0,30       10000       3.7e-5      5.1e-6}
01112 \textcolor{comment}{     *    IEEE       0,100      10000       1.7e-4      2.5e-5}
01113 \textcolor{comment}{     * The useful domain for relative error is limited by underflow}
01114 \textcolor{comment}{     * of the single precision exponential function.}
01115 \textcolor{comment}{     * Absolute error:}
01116 \textcolor{comment}{     *    IEEE       0,30      100000       2.2e-5      9.6e-7}
01117 \textcolor{comment}{     *    IEEE       0,100      10000       6.5e-5      3.7e-6}
01118 \textcolor{comment}{     *}
01119 \textcolor{comment}{     * Larger errors may occur for extreme ratios of a and b.}
01120 \textcolor{comment}{     *}
01121 \textcolor{comment}{     * ACCURACY (double):}
01122 \textcolor{comment}{     * arithmetic   domain     # trials      peak         rms}
01123 \textcolor{comment}{     *    IEEE      0,5         10000       6.9e-15     4.5e-16}
01124 \textcolor{comment}{     *    IEEE      0,85       250000       2.2e-13     1.7e-14}
01125 \textcolor{comment}{     *    IEEE      0,1000      30000       5.3e-12     6.3e-13}
01126 \textcolor{comment}{     *    IEEE      0,10000    250000       9.3e-11     7.1e-12}
01127 \textcolor{comment}{     *    IEEE      0,100000    10000       8.7e-10     4.8e-11}
01128 \textcolor{comment}{     * Outputs smaller than the IEEE gradual underflow threshold}
01129 \textcolor{comment}{     * were excluded from these statistics.}
01130 \textcolor{comment}{     *}
01131 \textcolor{comment}{     * ERROR MESSAGES:}
01132 \textcolor{comment}{     *   message         condition      value returned}
01133 \textcolor{comment}{     * incbet domain      x<0, x>1          nan}
01134 \textcolor{comment}{     * incbet underflow                     nan}
01135 \textcolor{comment}{     */}
01136 
01137     EIGEN\_STATIC\_ASSERT((\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, Scalar>::value} 
      == \textcolor{keyword}{false}),
01138                         THIS\_TYPE\_IS\_NOT\_SUPPORTED);
01139     \textcolor{keywordflow}{return} Scalar(0);
01140   \}
01141 \};
01142 
01143 \textcolor{comment}{/* Continued fraction expansion #1 for incomplete beta integral (small\_branch = True)}
01144 \textcolor{comment}{ * Continued fraction expansion #2 for incomplete beta integral (small\_branch = False)}
01145 \textcolor{comment}{ */}
01146 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01147 \textcolor{keyword}{struct }incbeta\_cfe \{
01148   EIGEN\_DEVICE\_FUNC
01149   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Scalar run(Scalar a, Scalar b, Scalar x, \textcolor{keywordtype}{bool} small\_branch) \{
01150     EIGEN\_STATIC\_ASSERT((\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, float>::value} ||
01151                          \hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, double>::value}),
01152                         THIS\_TYPE\_IS\_NOT\_SUPPORTED);
01153     \textcolor{keyword}{const} Scalar big = \hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper<Scalar>::big}();
01154     \textcolor{keyword}{const} Scalar machep = \hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper<Scalar>::machep}();
01155     \textcolor{keyword}{const} Scalar biginv = \hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper<Scalar>::biginv}();
01156 
01157     \textcolor{keyword}{const} Scalar zero = 0;
01158     \textcolor{keyword}{const} Scalar one = 1;
01159     \textcolor{keyword}{const} Scalar two = 2;
01160 
01161     Scalar xk, pk, pkm1, pkm2, qk, qkm1, qkm2;
01162     Scalar k1, k2, k3, k4, k5, k6, k7, k8, k26update;
01163     Scalar ans;
01164     \textcolor{keywordtype}{int} n;
01165 
01166     \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_iters = (\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, float>::value}) 
      ? 100 : 300;
01167     \textcolor{keyword}{const} Scalar thresh =
01168         (\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, float>::value}) ? machep : Scalar(
      3) * machep;
01169     Scalar r = (\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, float>::value}) ? zero : 
      one;
01170 
01171     \textcolor{keywordflow}{if} (small\_branch) \{
01172       k1 = a;
01173       k2 = a + b;
01174       k3 = a;
01175       k4 = a + one;
01176       k5 = one;
01177       k6 = b - one;
01178       k7 = k4;
01179       k8 = a + two;
01180       k26update = one;
01181     \} \textcolor{keywordflow}{else} \{
01182       k1 = a;
01183       k2 = b - one;
01184       k3 = a;
01185       k4 = a + one;
01186       k5 = one;
01187       k6 = a + b;
01188       k7 = a + one;
01189       k8 = a + two;
01190       k26update = -one;
01191       x = x / (one - x);
01192     \}
01193 
01194     pkm2 = zero;
01195     qkm2 = one;
01196     pkm1 = one;
01197     qkm1 = one;
01198     ans = one;
01199     n = 0;
01200 
01201     \textcolor{keywordflow}{do} \{
01202       xk = -(x * k1 * k2) / (k3 * k4);
01203       pk = pkm1 + pkm2 * xk;
01204       qk = qkm1 + qkm2 * xk;
01205       pkm2 = pkm1;
01206       pkm1 = pk;
01207       qkm2 = qkm1;
01208       qkm1 = qk;
01209 
01210       xk = (x * k5 * k6) / (k7 * k8);
01211       pk = pkm1 + pkm2 * xk;
01212       qk = qkm1 + qkm2 * xk;
01213       pkm2 = pkm1;
01214       pkm1 = pk;
01215       qkm2 = qkm1;
01216       qkm1 = qk;
01217 
01218       \textcolor{keywordflow}{if} (qk != zero) \{
01219         r = pk / qk;
01220         \textcolor{keywordflow}{if} (numext::abs(ans - r) < numext::abs(r) * thresh) \{
01221           \textcolor{keywordflow}{return} r;
01222         \}
01223         ans = r;
01224       \}
01225 
01226       k1 += one;
01227       k2 += k26update;
01228       k3 += two;
01229       k4 += two;
01230       k5 += one;
01231       k6 -= k26update;
01232       k7 += two;
01233       k8 += two;
01234 
01235       \textcolor{keywordflow}{if} ((numext::abs(qk) + numext::abs(pk)) > big) \{
01236         pkm2 *= biginv;
01237         pkm1 *= biginv;
01238         qkm2 *= biginv;
01239         qkm1 *= biginv;
01240       \}
01241       \textcolor{keywordflow}{if} ((numext::abs(qk) < biginv) || (numext::abs(pk) < biginv)) \{
01242         pkm2 *= big;
01243         pkm1 *= big;
01244         qkm2 *= big;
01245         qkm1 *= big;
01246       \}
01247     \} \textcolor{keywordflow}{while} (++n < num\_iters);
01248 
01249     \textcolor{keywordflow}{return} ans;
01250   \}
01251 \};
01252 
01253 \textcolor{comment}{/* Helper functions depending on the Scalar type */}
01254 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01255 \textcolor{keyword}{struct }betainc\_helper \{\};
01256 
01257 \textcolor{keyword}{template} <>
01258 \textcolor{keyword}{struct }betainc\_helper<float> \{
01259   \textcolor{comment}{/* Core implementation, assumes a large (> 1.0) */}
01260   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} incbsa(\textcolor{keywordtype}{float} aa, \textcolor{keywordtype}{float} bb,
01261                                                             \textcolor{keywordtype}{float} xx) \{
01262     \textcolor{keywordtype}{float} ans, a, b, t, x, onemx;
01263     \textcolor{keywordtype}{bool} reversed\_a\_b = \textcolor{keyword}{false};
01264 
01265     onemx = 1.0f - xx;
01266 
01267     \textcolor{comment}{/* see if x is greater than the mean */}
01268     \textcolor{keywordflow}{if} (xx > (aa / (aa + bb))) \{
01269       reversed\_a\_b = \textcolor{keyword}{true};
01270       a = bb;
01271       b = aa;
01272       t = xx;
01273       x = onemx;
01274     \} \textcolor{keywordflow}{else} \{
01275       a = aa;
01276       b = bb;
01277       t = onemx;
01278       x = xx;
01279     \}
01280 
01281     \textcolor{comment}{/* Choose expansion for optimal convergence */}
01282     \textcolor{keywordflow}{if} (b > 10.0f) \{
01283       \textcolor{keywordflow}{if} (numext::abs(b * x / a) < 0.3f) \{
01284         t = betainc\_helper<float>::incbps(a, b, x);
01285         \textcolor{keywordflow}{if} (reversed\_a\_b) t = 1.0f - t;
01286         \textcolor{keywordflow}{return} t;
01287       \}
01288     \}
01289 
01290     ans = x * (a + b - 2.0f) / (a - 1.0f);
01291     \textcolor{keywordflow}{if} (ans < 1.0f) \{
01292       ans = incbeta\_cfe<float>::run(a, b, x, \textcolor{keyword}{true} \textcolor{comment}{/* small\_branch */});
01293       t = b * numext::log(t);
01294     \} \textcolor{keywordflow}{else} \{
01295       ans = incbeta\_cfe<float>::run(a, b, x, \textcolor{keyword}{false} \textcolor{comment}{/* small\_branch */});
01296       t = (b - 1.0f) * numext::log(t);
01297     \}
01298 
01299     t += a * numext::log(x) + \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<float>::run}(a + b) -
01300          \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<float>::run}(a) - 
      \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<float>::run}(b);
01301     t += numext::log(ans / a);
01302     t = numext::exp(t);
01303 
01304     \textcolor{keywordflow}{if} (reversed\_a\_b) t = 1.0f - t;
01305     \textcolor{keywordflow}{return} t;
01306   \}
01307 
01308   EIGEN\_DEVICE\_FUNC
01309   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} incbps(\textcolor{keywordtype}{float} a, \textcolor{keywordtype}{float} b, \textcolor{keywordtype}{float} x) \{
01310     \textcolor{keywordtype}{float} t, u, y, s;
01311     \textcolor{keyword}{const} \textcolor{keywordtype}{float} machep = \hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper<float>::machep}();
01312 
01313     y = a * numext::log(x) + (b - 1.0f) * numext::log1p(-x) - numext::log(a);
01314     y -= \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<float>::run}(a) + 
      \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<float>::run}(b);
01315     y += \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<float>::run}(a + b);
01316 
01317     t = x / (1.0f - x);
01318     s = 0.0f;
01319     u = 1.0f;
01320     \textcolor{keywordflow}{do} \{
01321       b -= 1.0f;
01322       \textcolor{keywordflow}{if} (b == 0.0f) \{
01323         \textcolor{keywordflow}{break};
01324       \}
01325       a += 1.0f;
01326       u *= t * b / a;
01327       s += u;
01328     \} \textcolor{keywordflow}{while} (numext::abs(u) > machep);
01329 
01330     \textcolor{keywordflow}{return} numext::exp(y) * (1.0f + s);
01331   \}
01332 \};
01333 
01334 \textcolor{keyword}{template} <>
01335 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1betainc__impl}{betainc\_impl}<float> \{
01336   EIGEN\_DEVICE\_FUNC
01337   \textcolor{keyword}{static} \textcolor{keywordtype}{float} run(\textcolor{keywordtype}{float} a, \textcolor{keywordtype}{float} b, \textcolor{keywordtype}{float} x) \{
01338     \textcolor{keyword}{const} \textcolor{keywordtype}{float} nan = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<float>::quiet\_NaN}();
01339     \textcolor{keywordtype}{float} ans, t;
01340 
01341     \textcolor{keywordflow}{if} (a <= 0.0f) \textcolor{keywordflow}{return} nan;
01342     \textcolor{keywordflow}{if} (b <= 0.0f) \textcolor{keywordflow}{return} nan;
01343     \textcolor{keywordflow}{if} ((x <= 0.0f) || (x >= 1.0f)) \{
01344       \textcolor{keywordflow}{if} (x == 0.0f) \textcolor{keywordflow}{return} 0.0f;
01345       \textcolor{keywordflow}{if} (x == 1.0f) \textcolor{keywordflow}{return} 1.0f;
01346       \textcolor{comment}{// mtherr("betaincf", DOMAIN);}
01347       \textcolor{keywordflow}{return} nan;
01348     \}
01349 
01350     \textcolor{comment}{/* transformation for small aa */}
01351     \textcolor{keywordflow}{if} (a <= 1.0f) \{
01352       ans = betainc\_helper<float>::incbsa(a + 1.0f, b, x);
01353       t = a * numext::log(x) + b * numext::log1p(-x) +
01354           \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<float>::run}(a + b) - 
      \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<float>::run}(a + 1.0f) -
01355           \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<float>::run}(b);
01356       \textcolor{keywordflow}{return} (ans + numext::exp(t));
01357     \} \textcolor{keywordflow}{else} \{
01358       \textcolor{keywordflow}{return} betainc\_helper<float>::incbsa(a, b, x);
01359     \}
01360   \}
01361 \};
01362 
01363 \textcolor{keyword}{template} <>
01364 \textcolor{keyword}{struct }betainc\_helper<double> \{
01365   EIGEN\_DEVICE\_FUNC
01366   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} incbps(\textcolor{keywordtype}{double} a, \textcolor{keywordtype}{double} b, \textcolor{keywordtype}{double} x) \{
01367     \textcolor{keyword}{const} \textcolor{keywordtype}{double} machep = \hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper<double>::machep}();
01368 
01369     \textcolor{keywordtype}{double} s, t, u, v, n, t1, z, ai;
01370 
01371     ai = 1.0 / a;
01372     u = (1.0 - b) * x;
01373     v = u / (a + 1.0);
01374     t1 = v;
01375     t = u;
01376     n = 2.0;
01377     s = 0.0;
01378     z = machep * ai;
01379     \textcolor{keywordflow}{while} (numext::abs(v) > z) \{
01380       u = (n - b) * x / n;
01381       t *= u;
01382       v = t / (a + n);
01383       s += v;
01384       n += 1.0;
01385     \}
01386     s += t1;
01387     s += ai;
01388 
01389     u = a * numext::log(x);
01390     \textcolor{comment}{// TODO: gamma() is not directly implemented in Eigen.}
01391     \textcolor{comment}{/*}
01392 \textcolor{comment}{    if ((a + b) < maxgam && numext::abs(u) < maxlog) \{}
01393 \textcolor{comment}{      t = gamma(a + b) / (gamma(a) * gamma(b));}
01394 \textcolor{comment}{      s = s * t * pow(x, a);}
01395 \textcolor{comment}{    \} else \{}
01396 \textcolor{comment}{    */}
01397     t = \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<double>::run}(a + b) - 
      \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<double>::run}(a) -
01398         \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<double>::run}(b) + u + numext::log(s);
01399     \textcolor{keywordflow}{return} s = numext::exp(t);
01400   \}
01401 \};
01402 
01403 \textcolor{keyword}{template} <>
01404 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1betainc__impl}{betainc\_impl}<double> \{
01405   EIGEN\_DEVICE\_FUNC
01406   \textcolor{keyword}{static} \textcolor{keywordtype}{double} run(\textcolor{keywordtype}{double} aa, \textcolor{keywordtype}{double} bb, \textcolor{keywordtype}{double} xx) \{
01407     \textcolor{keyword}{const} \textcolor{keywordtype}{double} nan = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<double>::quiet\_NaN}();
01408     \textcolor{keyword}{const} \textcolor{keywordtype}{double} machep = \hyperlink{struct_eigen_1_1internal_1_1cephes__helper}{cephes\_helper<double>::machep}();
01409     \textcolor{comment}{// const double maxgam = 171.624376956302725;}
01410 
01411     \textcolor{keywordtype}{double} a, b, t, x, xc, w, y;
01412     \textcolor{keywordtype}{bool} reversed\_a\_b = \textcolor{keyword}{false};
01413 
01414     \textcolor{keywordflow}{if} (aa <= 0.0 || bb <= 0.0) \{
01415       \textcolor{keywordflow}{return} nan;  \textcolor{comment}{// goto domerr;}
01416     \}
01417 
01418     \textcolor{keywordflow}{if} ((xx <= 0.0) || (xx >= 1.0)) \{
01419       \textcolor{keywordflow}{if} (xx == 0.0) \textcolor{keywordflow}{return} (0.0);
01420       \textcolor{keywordflow}{if} (xx == 1.0) \textcolor{keywordflow}{return} (1.0);
01421       \textcolor{comment}{// mtherr("incbet", DOMAIN);}
01422       \textcolor{keywordflow}{return} nan;
01423     \}
01424 
01425     \textcolor{keywordflow}{if} ((bb * xx) <= 1.0 && xx <= 0.95) \{
01426       \textcolor{keywordflow}{return} betainc\_helper<double>::incbps(aa, bb, xx);
01427     \}
01428 
01429     w = 1.0 - xx;
01430 
01431     \textcolor{comment}{/* Reverse a and b if x is greater than the mean. */}
01432     \textcolor{keywordflow}{if} (xx > (aa / (aa + bb))) \{
01433       reversed\_a\_b = \textcolor{keyword}{true};
01434       a = bb;
01435       b = aa;
01436       xc = xx;
01437       x = w;
01438     \} \textcolor{keywordflow}{else} \{
01439       a = aa;
01440       b = bb;
01441       xc = w;
01442       x = xx;
01443     \}
01444 
01445     \textcolor{keywordflow}{if} (reversed\_a\_b && (b * x) <= 1.0 && x <= 0.95) \{
01446       t = betainc\_helper<double>::incbps(a, b, x);
01447       \textcolor{keywordflow}{if} (t <= machep) \{
01448         t = 1.0 - machep;
01449       \} \textcolor{keywordflow}{else} \{
01450         t = 1.0 - t;
01451       \}
01452       \textcolor{keywordflow}{return} t;
01453     \}
01454 
01455     \textcolor{comment}{/* Choose expansion for better convergence. */}
01456     y = x * (a + b - 2.0) - (a - 1.0);
01457     \textcolor{keywordflow}{if} (y < 0.0) \{
01458       w = incbeta\_cfe<double>::run(a, b, x, \textcolor{keyword}{true} \textcolor{comment}{/* small\_branch */});
01459     \} \textcolor{keywordflow}{else} \{
01460       w = incbeta\_cfe<double>::run(a, b, x, \textcolor{keyword}{false} \textcolor{comment}{/* small\_branch */}) / xc;
01461     \}
01462 
01463     \textcolor{comment}{/* Multiply w by the factor}
01464 \textcolor{comment}{         a      b   \_             \_     \_}
01465 \textcolor{comment}{        x  (1-x)   | (a+b) / ( a | (a) | (b) ) .   */}
01466 
01467     y = a * numext::log(x);
01468     t = b * numext::log(xc);
01469     \textcolor{comment}{// TODO: gamma is not directly implemented in Eigen.}
01470     \textcolor{comment}{/*}
01471 \textcolor{comment}{    if ((a + b) < maxgam && numext::abs(y) < maxlog && numext::abs(t) < maxlog)}
01472 \textcolor{comment}{    \{}
01473 \textcolor{comment}{      t = pow(xc, b);}
01474 \textcolor{comment}{      t *= pow(x, a);}
01475 \textcolor{comment}{      t /= a;}
01476 \textcolor{comment}{      t *= w;}
01477 \textcolor{comment}{      t *= gamma(a + b) / (gamma(a) * gamma(b));}
01478 \textcolor{comment}{    \} else \{}
01479 \textcolor{comment}{    */}
01480     \textcolor{comment}{/* Resort to logarithms.  */}
01481     y += t + \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<double>::run}(a + b) - 
      \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<double>::run}(a) -
01482          \hyperlink{struct_eigen_1_1internal_1_1lgamma__impl}{lgamma\_impl<double>::run}(b);
01483     y += numext::log(w / a);
01484     t = numext::exp(y);
01485 
01486     \textcolor{comment}{/* \} */}
01487     \textcolor{comment}{// done:}
01488 
01489     \textcolor{keywordflow}{if} (reversed\_a\_b) \{
01490       \textcolor{keywordflow}{if} (t <= machep) \{
01491         t = 1.0 - machep;
01492       \} \textcolor{keywordflow}{else} \{
01493         t = 1.0 - t;
01494       \}
01495     \}
01496     \textcolor{keywordflow}{return} t;
01497   \}
01498 \};
01499 
01500 \textcolor{preprocessor}{#endif  // EIGEN\_HAS\_C99\_MATH}
01501 
01502 \}  \textcolor{comment}{// end namespace internal}
01503 
01504 \textcolor{keyword}{namespace }numext \{
01505 
01506 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01507 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} EIGEN\_MATHFUNC\_RETVAL(lgamma, Scalar)
01508     lgamma(\textcolor{keyword}{const} Scalar& x) \{
01509   \textcolor{keywordflow}{return} EIGEN\_MATHFUNC\_IMPL(lgamma, Scalar)::run(x);
01510 \}
01511 
01512 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01513 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} EIGEN\_MATHFUNC\_RETVAL(digamma, Scalar)
01514     digamma(\textcolor{keyword}{const} Scalar& x) \{
01515   \textcolor{keywordflow}{return} EIGEN\_MATHFUNC\_IMPL(digamma, Scalar)::run(x);
01516 \}
01517 
01518 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01519 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} EIGEN\_MATHFUNC\_RETVAL(\hyperlink{namespace_eigen_af9555e27540da78d2c4bdd17d3b750b1}{zeta}, Scalar)
01520 \hyperlink{namespace_eigen_af9555e27540da78d2c4bdd17d3b750b1}{zeta}(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& q) \{
01521     \textcolor{keywordflow}{return} EIGEN\_MATHFUNC\_IMPL(\hyperlink{namespace_eigen_af9555e27540da78d2c4bdd17d3b750b1}{zeta}, Scalar)::run(x, q);
01522 \}
01523 
01524 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01525 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} EIGEN\_MATHFUNC\_RETVAL(\hyperlink{namespace_eigen_ae3b47a13a0699f5dbaa0623c11333dca}{polygamma}, Scalar)
01526 \hyperlink{namespace_eigen_ae3b47a13a0699f5dbaa0623c11333dca}{polygamma}(\textcolor{keyword}{const} Scalar& n, \textcolor{keyword}{const} Scalar& x) \{
01527     \textcolor{keywordflow}{return} EIGEN\_MATHFUNC\_IMPL(\hyperlink{namespace_eigen_ae3b47a13a0699f5dbaa0623c11333dca}{polygamma}, Scalar)::run(n, x);
01528 \}
01529 
01530 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01531 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} EIGEN\_MATHFUNC\_RETVAL(erf, Scalar)
01532     erf(\textcolor{keyword}{const} Scalar& x) \{
01533   \textcolor{keywordflow}{return} EIGEN\_MATHFUNC\_IMPL(erf, Scalar)::run(x);
01534 \}
01535 
01536 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01537 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} EIGEN\_MATHFUNC\_RETVAL(erfc, Scalar)
01538     erfc(\textcolor{keyword}{const} Scalar& x) \{
01539   \textcolor{keywordflow}{return} EIGEN\_MATHFUNC\_IMPL(erfc, Scalar)::run(x);
01540 \}
01541 
01542 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01543 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} EIGEN\_MATHFUNC\_RETVAL(\hyperlink{namespace_eigen_af5aa651137636b1cdbd27de1cfe91148}{igamma}, Scalar)
01544     \hyperlink{namespace_eigen_af5aa651137636b1cdbd27de1cfe91148}{igamma}(\textcolor{keyword}{const} Scalar& a, \textcolor{keyword}{const} Scalar& x) \{
01545   \textcolor{keywordflow}{return} EIGEN\_MATHFUNC\_IMPL(\hyperlink{namespace_eigen_af5aa651137636b1cdbd27de1cfe91148}{igamma}, Scalar)::run(a, x);
01546 \}
01547 
01548 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01549 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} EIGEN\_MATHFUNC\_RETVAL(\hyperlink{namespace_eigen_a1abaa2ff8c7b1871eaf026a47c6bbf3b}{igammac}, Scalar)
01550     \hyperlink{namespace_eigen_a1abaa2ff8c7b1871eaf026a47c6bbf3b}{igammac}(\textcolor{keyword}{const} Scalar& a, \textcolor{keyword}{const} Scalar& x) \{
01551   \textcolor{keywordflow}{return} EIGEN\_MATHFUNC\_IMPL(\hyperlink{namespace_eigen_a1abaa2ff8c7b1871eaf026a47c6bbf3b}{igammac}, Scalar)::run(a, x);
01552 \}
01553 
01554 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
01555 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} EIGEN\_MATHFUNC\_RETVAL(\hyperlink{namespace_eigen_a726eae91d4e91d8e25cbe55fffa6a92f}{betainc}, Scalar)
01556     \hyperlink{namespace_eigen_a726eae91d4e91d8e25cbe55fffa6a92f}{betainc}(\textcolor{keyword}{const} Scalar& a, \textcolor{keyword}{const} Scalar& b, \textcolor{keyword}{const} Scalar& x) \{
01557   \textcolor{keywordflow}{return} EIGEN\_MATHFUNC\_IMPL(\hyperlink{namespace_eigen_a726eae91d4e91d8e25cbe55fffa6a92f}{betainc}, Scalar)::run(a, b, x);
01558 \}
01559 
01560 \}  \textcolor{comment}{// end namespace numext}
01561 
01562 
01563 \}  \textcolor{comment}{// end namespace Eigen}
01564 
01565 \textcolor{preprocessor}{#endif  // EIGEN\_SPECIAL\_FUNCTIONS\_H}
\end{DoxyCode}
