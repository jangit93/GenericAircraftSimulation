\hypertarget{eigen_2_eigen_2src_2_core_2_solver_base_8h_source}{}\section{eigen/\+Eigen/src/\+Core/\+Solver\+Base.h}
\label{eigen_2_eigen_2src_2_core_2_solver_base_8h_source}\index{Solver\+Base.\+h@{Solver\+Base.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SOLVERBASE\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SOLVERBASE\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 
00018 
00019 \} \textcolor{comment}{// end namespace internal}
00020 
00040 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_solver_base_8h_source_l00041}\hyperlink{class_eigen_1_1_solver_base}{00041} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_solver_base}{SolverBase} : \textcolor{keyword}{public} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase}<Derived>
00042 \{
00043   \textcolor{keyword}{public}:
00044 
00045     \textcolor{keyword}{typedef} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<Derived>} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{Base};
00046     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Scalar} Scalar;
00047     \textcolor{keyword}{typedef} Scalar CoeffReturnType;
00048 
00049     \textcolor{keyword}{enum} \{
00050       RowsAtCompileTime = \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::RowsAtCompileTime}
      ,
00051       ColsAtCompileTime = \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::ColsAtCompileTime}
      ,
00052       SizeAtCompileTime = (
      \hyperlink{struct_eigen_1_1internal_1_1size__at__compile__time}{internal::size\_at\_compile\_time<internal::traits<Derived>::RowsAtCompileTime}
      ,
00053                                                           
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::ColsAtCompileTime}>::ret),
00054       MaxRowsAtCompileTime = \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::MaxRowsAtCompileTime}
      ,
00055       MaxColsAtCompileTime = \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::MaxColsAtCompileTime}
      ,
00056       MaxSizeAtCompileTime = (\hyperlink{struct_eigen_1_1internal_1_1size__at__compile__time}{internal::size\_at\_compile\_time}<
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::MaxRowsAtCompileTime},
00057                                                              
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::MaxColsAtCompileTime}>::ret),
00058       IsVectorAtCompileTime = \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::MaxRowsAtCompileTime}
       == 1
00059                            || \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::MaxColsAtCompileTime}
       == 1
00060     \};
00061 
\Hypertarget{eigen_2_eigen_2src_2_core_2_solver_base_8h_source_l00063}\hyperlink{class_eigen_1_1_solver_base_a4d5e5baddfba3790ab1a5f247dcc4dc1}{00063}     \hyperlink{class_eigen_1_1_solver_base_a4d5e5baddfba3790ab1a5f247dcc4dc1}{SolverBase}()
00064     \{\}
00065 
00066     ~\hyperlink{class_eigen_1_1_solver_base}{SolverBase}()
00067     \{\}
00068 
00069     \textcolor{keyword}{using} Base::derived;
00070 
00073     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs>
00074     \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_solve}{Solve<Derived, Rhs>}
\Hypertarget{eigen_2_eigen_2src_2_core_2_solver_base_8h_source_l00075}\hyperlink{class_eigen_1_1_solver_base_a7fd647d110487799205df6f99547879d}{00075}     \hyperlink{class_eigen_1_1_solver_base_a7fd647d110487799205df6f99547879d}{solve}(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>}& b)\textcolor{keyword}{ const}
00076 \textcolor{keyword}{    }\{
00077       eigen\_assert(derived().rows()==b.rows() && \textcolor{stringliteral}{"solve(): invalid number of rows of the right hand side
       matrix b"});
00078       \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_solve}{Solve<Derived, Rhs>}(derived(), b.derived());
00079     \}
00080 
00082     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1add__const}{internal::add\_const<Transpose<const Derived>}
       >::type \hyperlink{group___core___module_class_eigen_1_1_transpose}{ConstTransposeReturnType};
\Hypertarget{eigen_2_eigen_2src_2_core_2_solver_base_8h_source_l00090}\hyperlink{class_eigen_1_1_solver_base_a732e75b5132bb4db3775916927b0e86c}{00090}     \textcolor{keyword}{inline} ConstTransposeReturnType \hyperlink{class_eigen_1_1_solver_base_a732e75b5132bb4db3775916927b0e86c}{transpose}()\textcolor{keyword}{ const}
00091 \textcolor{keyword}{    }\{
00092       \textcolor{keywordflow}{return} ConstTransposeReturnType(derived());
00093     \}
00094 
00096     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{internal::conditional<NumTraits<Scalar>::IsComplex}
      ,
00097                         \hyperlink{group___core___module_class_eigen_1_1_cwise_unary_op}{CwiseUnaryOp<internal::scalar\_conjugate\_op<Scalar>}
      , ConstTransposeReturnType>,
00098                         ConstTransposeReturnType
00099                      >::type \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{AdjointReturnType};
\Hypertarget{eigen_2_eigen_2src_2_core_2_solver_base_8h_source_l00109}\hyperlink{class_eigen_1_1_solver_base_a05a3686a89888681c8e0c2bcab6d1ce5}{00109}     \textcolor{keyword}{inline} AdjointReturnType \hyperlink{class_eigen_1_1_solver_base_a05a3686a89888681c8e0c2bcab6d1ce5}{adjoint}()\textcolor{keyword}{ const}
00110 \textcolor{keyword}{    }\{
00111       \textcolor{keywordflow}{return} AdjointReturnType(derived().transpose());
00112     \}
00113 
00114   \textcolor{keyword}{protected}:
00115 \};
00116 
00117 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00118 
00119 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_solver_base_8h_source_l00120}\hyperlink{struct_eigen_1_1internal_1_1generic__xpr__base_3_01_derived_00_01_matrix_xpr_00_01_solver_storage_01_4}{00120} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1generic__xpr__base}{generic\_xpr\_base}<Derived, \hyperlink{struct_eigen_1_1_matrix_xpr}{MatrixXpr}, 
      \hyperlink{struct_eigen_1_1_solver_storage}{SolverStorage}>
00121 \{
00122   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_solver_base}{SolverBase<Derived>} \hyperlink{class_eigen_1_1_solver_base}{type};
00123 
00124 \};
00125 
00126 \} \textcolor{comment}{// end namespace internal}
00127 
00128 \} \textcolor{comment}{// end namespace Eigen}
00129 
00130 \textcolor{preprocessor}{#endif // EIGEN\_SOLVERBASE\_H}
\end{DoxyCode}
