\hypertarget{matio_2visual__studio_2test_2eigen_2test_2stdvector__overload_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/stdvector\+\_\+overload.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2stdvector__overload_8cpp_source}\index{stdvector\+\_\+overload.\+cpp@{stdvector\+\_\+overload.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2010 Hauke Heibel <hauke.heibel@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#include "main.h"}
00012 
00013 \textcolor{preprocessor}{#include <Eigen/StdVector>}
00014 \textcolor{preprocessor}{#include <Eigen/Geometry>}
00015 
00016 EIGEN\_DEFINE\_STL\_VECTOR\_SPECIALIZATION(Vector4f)
00017 
00018 EIGEN\_DEFINE\_STL\_VECTOR\_SPECIALIZATION(Matrix2f)
00019 EIGEN\_DEFINE\_STL\_VECTOR\_SPECIALIZATION(Matrix4f)
00020 EIGEN\_DEFINE\_STL\_VECTOR\_SPECIALIZATION(Matrix4d)
00021 
00022 EIGEN\_DEFINE\_STL\_VECTOR\_SPECIALIZATION(\hyperlink{group___geometry___module_class_eigen_1_1_transform}{Affine3f})
00023 EIGEN\_DEFINE\_STL\_VECTOR\_SPECIALIZATION(\hyperlink{group___geometry___module_class_eigen_1_1_transform}{Affine3d})
00024 
00025 EIGEN\_DEFINE\_STL\_VECTOR\_SPECIALIZATION(\hyperlink{group___geometry___module_class_eigen_1_1_quaternion}{Quaternionf})
00026 EIGEN\_DEFINE\_STL\_VECTOR\_SPECIALIZATION(\hyperlink{group___geometry___module_class_eigen_1_1_quaternion}{Quaterniond})
00027 
00028 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00029 \textcolor{keywordtype}{void} check\_stdvector\_matrix(\textcolor{keyword}{const} MatrixType& m)
00030 \{
00031   \textcolor{keyword}{typename} MatrixType::Index rows = m.rows();
00032   \textcolor{keyword}{typename} MatrixType::Index cols = m.cols();
00033   MatrixType x = MatrixType::Random(rows,cols), y = MatrixType::Random(rows,cols);
00034   std::vector<MatrixType> v(10, MatrixType(rows,cols)), w(20, y);
00035   v[5] = x;
00036   w[6] = v[5];
00037   VERIFY\_IS\_APPROX(w[6], v[5]);
00038   v = w;
00039   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00040   \{
00041     VERIFY\_IS\_APPROX(w[i], v[i]);
00042   \}
00043 
00044   v.resize(21);
00045   v[20] = x;
00046   VERIFY\_IS\_APPROX(v[20], x);
00047   v.resize(22,y);
00048   VERIFY\_IS\_APPROX(v[21], y);
00049   v.push\_back(x);
00050   VERIFY\_IS\_APPROX(v[22], x);
00051   VERIFY((internal::UIntPtr)&(v[22]) == (internal::UIntPtr)&(v[21]) + \textcolor{keyword}{sizeof}(MatrixType));
00052 
00053   \textcolor{comment}{// do a lot of push\_back such that the vector gets internally resized}
00054   \textcolor{comment}{// (with memory reallocation)}
00055   MatrixType* ref = &w[0];
00056   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<30 || ((ref==&w[0]) && i<300); ++i)
00057     v.push\_back(w[i%w.size()]);
00058   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=23; i<v.size(); ++i)
00059   \{
00060     VERIFY(v[i]==w[(i-23)%w.size()]);
00061   \}
00062 \}
00063 
00064 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TransformType>
00065 \textcolor{keywordtype}{void} check\_stdvector\_transform(\textcolor{keyword}{const} TransformType&)
00066 \{
00067   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} TransformType::MatrixType MatrixType;
00068   TransformType x(MatrixType::Random()), y(MatrixType::Random());
00069   std::vector<TransformType> v(10), w(20, y);
00070   v[5] = x;
00071   w[6] = v[5];
00072   VERIFY\_IS\_APPROX(w[6], v[5]);
00073   v = w;
00074   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00075   \{
00076     VERIFY\_IS\_APPROX(w[i], v[i]);
00077   \}
00078 
00079   v.resize(21);
00080   v[20] = x;
00081   VERIFY\_IS\_APPROX(v[20], x);
00082   v.resize(22,y);
00083   VERIFY\_IS\_APPROX(v[21], y);
00084   v.push\_back(x);
00085   VERIFY\_IS\_APPROX(v[22], x);
00086   VERIFY((internal::UIntPtr)&(v[22]) == (internal::UIntPtr)&(v[21]) + \textcolor{keyword}{sizeof}(TransformType));
00087 
00088   \textcolor{comment}{// do a lot of push\_back such that the vector gets internally resized}
00089   \textcolor{comment}{// (with memory reallocation)}
00090   TransformType* ref = &w[0];
00091   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<30 || ((ref==&w[0]) && i<300); ++i)
00092     v.push\_back(w[i%w.size()]);
00093   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=23; i<v.size(); ++i)
00094   \{
00095     VERIFY(v[i].matrix()==w[(i-23)%w.size()].matrix());
00096   \}
00097 \}
00098 
00099 \textcolor{keyword}{template}<\textcolor{keyword}{typename} QuaternionType>
00100 \textcolor{keywordtype}{void} check\_stdvector\_quaternion(\textcolor{keyword}{const} QuaternionType&)
00101 \{
00102   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} QuaternionType::Coefficients Coefficients;
00103   QuaternionType x(Coefficients::Random()), y(Coefficients::Random());
00104   std::vector<QuaternionType> v(10), w(20, y);
00105   v[5] = x;
00106   w[6] = v[5];
00107   VERIFY\_IS\_APPROX(w[6], v[5]);
00108   v = w;
00109   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00110   \{
00111     VERIFY\_IS\_APPROX(w[i], v[i]);
00112   \}
00113 
00114   v.resize(21);
00115   v[20] = x;
00116   VERIFY\_IS\_APPROX(v[20], x);
00117   v.resize(22,y);
00118   VERIFY\_IS\_APPROX(v[21], y);
00119   v.push\_back(x);
00120   VERIFY\_IS\_APPROX(v[22], x);
00121   VERIFY((internal::UIntPtr)&(v[22]) == (internal::UIntPtr)&(v[21]) + \textcolor{keyword}{sizeof}(QuaternionType));
00122 
00123   \textcolor{comment}{// do a lot of push\_back such that the vector gets internally resized}
00124   \textcolor{comment}{// (with memory reallocation)}
00125   QuaternionType* ref = &w[0];
00126   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<30 || ((ref==&w[0]) && i<300); ++i)
00127     v.push\_back(w[i%w.size()]);
00128   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=23; i<v.size(); ++i)
00129   \{
00130     VERIFY(v[i].coeffs()==w[(i-23)%w.size()].coeffs());
00131   \}
00132 \}
00133 
00134 \textcolor{keywordtype}{void} test\_stdvector\_overload()
00135 \{
00136   \textcolor{comment}{// some non vectorizable fixed sizes}
00137   CALL\_SUBTEST\_1(check\_stdvector\_matrix(Vector2f()));
00138   CALL\_SUBTEST\_1(check\_stdvector\_matrix(Matrix3f()));
00139   CALL\_SUBTEST\_2(check\_stdvector\_matrix(Matrix3d()));
00140 
00141   \textcolor{comment}{// some vectorizable fixed sizes}
00142   CALL\_SUBTEST\_1(check\_stdvector\_matrix(Matrix2f()));
00143   CALL\_SUBTEST\_1(check\_stdvector\_matrix(Vector4f()));
00144   CALL\_SUBTEST\_1(check\_stdvector\_matrix(Matrix4f()));
00145   CALL\_SUBTEST\_2(check\_stdvector\_matrix(Matrix4d()));
00146 
00147   \textcolor{comment}{// some dynamic sizes}
00148   CALL\_SUBTEST\_3(check\_stdvector\_matrix(MatrixXd(1,1)));
00149   CALL\_SUBTEST\_3(check\_stdvector\_matrix(VectorXd(20)));
00150   CALL\_SUBTEST\_3(check\_stdvector\_matrix(RowVectorXf(20)));
00151   CALL\_SUBTEST\_3(check\_stdvector\_matrix(MatrixXcf(10,10)));
00152 
00153   \textcolor{comment}{// some Transform}
00154   CALL\_SUBTEST\_4(check\_stdvector\_transform(\hyperlink{group___geometry___module_ga2c1ea05a21899654ee3a2e3f91fa30e0}{Affine2f}())); \textcolor{comment}{// does not need the specialization
       (2+1)^2 = 9}
00155   CALL\_SUBTEST\_4(check\_stdvector\_transform(\hyperlink{group___geometry___module_ga17e901de8ff882aea7845c5457db6a4f}{Affine3f}()));
00156   CALL\_SUBTEST\_4(check\_stdvector\_transform(\hyperlink{group___geometry___module_gaaffa69d3143826efeb84e5d6c56a4c78}{Affine3d}()));
00157 
00158   \textcolor{comment}{// some Quaternion}
00159   CALL\_SUBTEST\_5(check\_stdvector\_quaternion(\hyperlink{group___geometry___module_ga785b13a5a87f9bf55d4eba51ead2dcf0}{Quaternionf}()));
00160   CALL\_SUBTEST\_5(check\_stdvector\_quaternion(\hyperlink{group___geometry___module_ga6e77eb8b6aae0e04be2db88107dbc642}{Quaterniond}()));
00161 \}
\end{DoxyCode}
