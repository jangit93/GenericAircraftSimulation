\hypertarget{eigen_2_eigen_2src_2_core_2_stable_norm_8h_source}{}\section{eigen/\+Eigen/src/\+Core/\+Stable\+Norm.h}
\label{eigen_2_eigen_2src_2_core_2_stable_norm_8h_source}\index{Stable\+Norm.\+h@{Stable\+Norm.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_STABLENORM\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_STABLENORM\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType, \textcolor{keyword}{typename} Scalar>
00018 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} stable\_norm\_kernel(\textcolor{keyword}{const} ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)
00019 \{
00020   Scalar maxCoeff = bl.cwiseAbs().maxCoeff();
00021   
00022   \textcolor{keywordflow}{if}(maxCoeff>scale)
00023   \{
00024     ssq = ssq * numext::abs2(scale/maxCoeff);
00025     Scalar tmp = Scalar(1)/maxCoeff;
00026     \textcolor{keywordflow}{if}(tmp > NumTraits<Scalar>::highest())
00027     \{
00028       invScale = NumTraits<Scalar>::highest();
00029       scale = Scalar(1)/invScale;
00030     \}
00031     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(maxCoeff>NumTraits<Scalar>::highest()) \textcolor{comment}{// we got a INF}
00032     \{
00033       invScale = Scalar(1);
00034       scale = maxCoeff;
00035     \}
00036     \textcolor{keywordflow}{else}
00037     \{
00038       scale = maxCoeff;
00039       invScale = tmp;
00040     \}
00041   \}
00042   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(maxCoeff!=maxCoeff) \textcolor{comment}{// we got a NaN}
00043   \{
00044     scale = maxCoeff;
00045   \}
00046   
00047   \textcolor{comment}{// TODO if the maxCoeff is much much smaller than the current scale,}
00048   \textcolor{comment}{// then we can neglect this sub vector}
00049   \textcolor{keywordflow}{if}(scale>Scalar(0)) \textcolor{comment}{// if scale==0, then bl is 0 }
00050     ssq += (bl*invScale).squaredNorm();
00051 \}
00052 
00053 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00054 \textcolor{keyword}{inline} \textcolor{keyword}{typename} NumTraits<typename traits<Derived>::Scalar>::Real
00055 blueNorm\_impl(\textcolor{keyword}{const} EigenBase<Derived>& \_vec)
00056 \{
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::RealScalar RealScalar;  
00058   \textcolor{keyword}{using} std::pow;
00059   \textcolor{keyword}{using} std::sqrt;
00060   \textcolor{keyword}{using} std::abs;
00061   \textcolor{keyword}{const} Derived& vec(\_vec.derived());
00062   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} initialized = \textcolor{keyword}{false};
00063   \textcolor{keyword}{static} RealScalar b1, b2, s1m, s2m, rbig, relerr;
00064   \textcolor{keywordflow}{if}(!initialized)
00065   \{
00066     \textcolor{keywordtype}{int} ibeta, it, iemin, iemax, iexp;
00067     RealScalar eps;
00068     \textcolor{comment}{// This program calculates the machine-dependent constants}
00069     \textcolor{comment}{// bl, b2, slm, s2m, relerr overfl}
00070     \textcolor{comment}{// from the "basic" machine-dependent numbers}
00071     \textcolor{comment}{// nbig, ibeta, it, iemin, iemax, rbig.}
00072     \textcolor{comment}{// The following define the basic machine-dependent constants.}
00073     \textcolor{comment}{// For portability, the PORT subprograms "ilmaeh" and "rlmach"}
00074     \textcolor{comment}{// are used. For any specific computer, each of the assignment}
00075     \textcolor{comment}{// statements can be replaced}
00076     ibeta = std::numeric\_limits<RealScalar>::radix;                 \textcolor{comment}{// base for floating-point numbers}
00077     it    = std::numeric\_limits<RealScalar>::digits;                \textcolor{comment}{// number of base-beta digits in
       mantissa}
00078     iemin = std::numeric\_limits<RealScalar>::min\_exponent;          \textcolor{comment}{// minimum exponent}
00079     iemax = std::numeric\_limits<RealScalar>::max\_exponent;          \textcolor{comment}{// maximum exponent}
00080     rbig  = (std::numeric\_limits<RealScalar>::max)();               \textcolor{comment}{// largest floating-point number}
00081 
00082     iexp  = -((1-iemin)/2);
00083     b1    = RealScalar(pow(RealScalar(ibeta),RealScalar(iexp)));    \textcolor{comment}{// lower boundary of midrange}
00084     iexp  = (iemax + 1 - it)/2;
00085     b2    = RealScalar(pow(RealScalar(ibeta),RealScalar(iexp)));    \textcolor{comment}{// upper boundary of midrange}
00086 
00087     iexp  = (2-iemin)/2;
00088     s1m   = RealScalar(pow(RealScalar(ibeta),RealScalar(iexp)));    \textcolor{comment}{// scaling factor for lower range}
00089     iexp  = - ((iemax+it)/2);
00090     s2m   = RealScalar(pow(RealScalar(ibeta),RealScalar(iexp)));    \textcolor{comment}{// scaling factor for upper range}
00091 
00092     eps     = RealScalar(pow(\textcolor{keywordtype}{double}(ibeta), 1-it));
00093     relerr  = sqrt(eps);                                            \textcolor{comment}{// tolerance for neglecting asml}
00094     initialized = \textcolor{keyword}{true};
00095   \}
00096   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = vec.size();
00097   RealScalar ab2 = b2 / RealScalar(n);
00098   RealScalar asml = RealScalar(0);
00099   RealScalar amed = RealScalar(0);
00100   RealScalar abig = RealScalar(0);
00101   \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} Derived::InnerIterator it(vec, 0); it; ++it)
00102   \{
00103     RealScalar ax = abs(it.value());
00104     \textcolor{keywordflow}{if}(ax > ab2)     abig += numext::abs2(ax*s2m);
00105     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(ax < b1) asml += numext::abs2(ax*s1m);
00106     \textcolor{keywordflow}{else}             amed += numext::abs2(ax);
00107   \}
00108   \textcolor{keywordflow}{if}(amed!=amed)
00109     \textcolor{keywordflow}{return} amed;  \textcolor{comment}{// we got a NaN}
00110   \textcolor{keywordflow}{if}(abig > RealScalar(0))
00111   \{
00112     abig = sqrt(abig);
00113     \textcolor{keywordflow}{if}(abig > rbig) \textcolor{comment}{// overflow, or *this contains INF values}
00114       \textcolor{keywordflow}{return} abig;  \textcolor{comment}{// return INF}
00115     \textcolor{keywordflow}{if}(amed > RealScalar(0))
00116     \{
00117       abig = abig/s2m;
00118       amed = sqrt(amed);
00119     \}
00120     \textcolor{keywordflow}{else}
00121       \textcolor{keywordflow}{return} abig/s2m;
00122   \}
00123   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(asml > RealScalar(0))
00124   \{
00125     \textcolor{keywordflow}{if} (amed > RealScalar(0))
00126     \{
00127       abig = sqrt(amed);
00128       amed = sqrt(asml) / s1m;
00129     \}
00130     \textcolor{keywordflow}{else}
00131       \textcolor{keywordflow}{return} sqrt(asml)/s1m;
00132   \}
00133   \textcolor{keywordflow}{else}
00134     \textcolor{keywordflow}{return} sqrt(amed);
00135   asml = numext::mini(abig, amed);
00136   abig = numext::maxi(abig, amed);
00137   \textcolor{keywordflow}{if}(asml <= abig*relerr)
00138     \textcolor{keywordflow}{return} abig;
00139   \textcolor{keywordflow}{else}
00140     \textcolor{keywordflow}{return} abig * sqrt(RealScalar(1) + numext::abs2(asml/abig));
00141 \}
00142 
00143 \} \textcolor{comment}{// end namespace internal}
00144 
00155 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00156 \textcolor{keyword}{inline} \textcolor{keyword}{typename} NumTraits<typename internal::traits<Derived>::Scalar>::Real
\Hypertarget{eigen_2_eigen_2src_2_core_2_stable_norm_8h_source_l00157}\hyperlink{group___core___module_ab84d3e64f855813b1eea4202c0697dc1}{00157} \hyperlink{group___core___module_ab84d3e64f855813b1eea4202c0697dc1}{MatrixBase<Derived>::stableNorm}()\textcolor{keyword}{ const}
00158 \textcolor{keyword}{}\{
00159   \textcolor{keyword}{using} std::sqrt;
00160   \textcolor{keyword}{using} std::abs;
00161   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockSize = 4096;
00162   RealScalar scale(0);
00163   RealScalar invScale(1);
00164   RealScalar ssq(0); \textcolor{comment}{// sum of square}
00165   
00166   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<Derived,2>::type} DerivedCopy
      ;
00167   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<DerivedCopy>::type} 
      DerivedCopyClean;
00168   DerivedCopy copy(derived());
00169   
00170   \textcolor{keyword}{enum} \{
00171     CanAlign = (   (int(DerivedCopyClean::Flags)&\hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit})
00172                 || (\textcolor{keywordtype}{int}(\hyperlink{struct_eigen_1_1internal_1_1evaluator}{internal::evaluator<DerivedCopyClean>::Alignment}
      )>0) \textcolor{comment}{// FIXME Alignment)>0 might not be enough}
00173                ) && (blockSize*\textcolor{keyword}{sizeof}(\hyperlink{group___core___module_a5feed465b3a8e60c47e73ecce83e39a2}{Scalar})*2<EIGEN\_STACK\_ALLOCATION\_LIMIT)
00174                  && (EIGEN\_MAX\_STATIC\_ALIGN\_BYTES>0) \textcolor{comment}{// if we cannot allocate on the stack, then let's not
       bother about this optimization}
00175   \};
00176   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1conditional}{internal::conditional<CanAlign, Ref<const Matrix<Scalar,Dynamic,1,0,blockSize,1>}
      , \hyperlink{struct_eigen_1_1internal_1_1evaluator}{internal::evaluator<DerivedCopyClean>::Alignment}>,
00177                                                    \textcolor{keyword}{typename} DerivedCopyClean::ConstSegmentReturnType>::type
       SegmentWrapper;
00178   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = size();
00179   
00180   \textcolor{keywordflow}{if}(n==1)
00181     \textcolor{keywordflow}{return} abs(this->coeff(0));
00182   
00183   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} bi = internal::first\_default\_aligned(copy);
00184   \textcolor{keywordflow}{if} (bi>0)
00185     internal::stable\_norm\_kernel(copy.head(bi), ssq, scale, invScale);
00186   \textcolor{keywordflow}{for} (; bi<n; bi+=blockSize)
00187     internal::stable\_norm\_kernel(SegmentWrapper(copy.segment(bi,numext::mini(blockSize, n - bi))), ssq, 
      scale, invScale);
00188   \textcolor{keywordflow}{return} scale * sqrt(ssq);
00189 \}
00190 
00200 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00201 \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename internal::traits<Derived>::Scalar}
      >::Real
\Hypertarget{eigen_2_eigen_2src_2_core_2_stable_norm_8h_source_l00202}\hyperlink{group___core___module_a3f3faa00163c16824ff03e58a210c74c}{00202} \hyperlink{group___core___module_a3f3faa00163c16824ff03e58a210c74c}{MatrixBase<Derived>::blueNorm}()\textcolor{keyword}{ const}
00203 \textcolor{keyword}{}\{
00204   \textcolor{keywordflow}{return} internal::blueNorm\_impl(*\textcolor{keyword}{this});
00205 \}
00206 
00212 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00213 \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename internal::traits<Derived>::Scalar}
      >::Real
\Hypertarget{eigen_2_eigen_2src_2_core_2_stable_norm_8h_source_l00214}\hyperlink{group___core___module_a32222d3b6677e6cdf0b801463f329b72}{00214} \hyperlink{group___core___module_a32222d3b6677e6cdf0b801463f329b72}{MatrixBase<Derived>::hypotNorm}()\textcolor{keyword}{ const}
00215 \textcolor{keyword}{}\{
00216   \textcolor{keywordflow}{return} this->cwiseAbs().redux(\hyperlink{struct_eigen_1_1internal_1_1scalar__hypot__op}{internal::scalar\_hypot\_op<RealScalar>}(
      ));
00217 \}
00218 
00219 \} \textcolor{comment}{// end namespace Eigen}
00220 
00221 \textcolor{preprocessor}{#endif // EIGEN\_STABLENORM\_H}
\end{DoxyCode}
