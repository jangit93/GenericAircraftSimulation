\hypertarget{eigen_2bench_2btl_2libs_2_b_l_a_s_2blas__interface__impl_8hh_source}{}\section{eigen/bench/btl/libs/\+B\+L\+A\+S/blas\+\_\+interface\+\_\+impl.hh}
\label{eigen_2bench_2btl_2libs_2_b_l_a_s_2blas__interface__impl_8hh_source}\index{blas\+\_\+interface\+\_\+impl.\+hh@{blas\+\_\+interface\+\_\+impl.\+hh}}

\begin{DoxyCode}
00001 
00002 \textcolor{preprocessor}{#define BLAS\_FUNC(NAME) CAT(CAT(SCALAR\_PREFIX,NAME),\_)}
00003 
\Hypertarget{eigen_2bench_2btl_2libs_2_b_l_a_s_2blas__interface__impl_8hh_source_l00004}\hyperlink{classblas__interface_3_01_s_c_a_l_a_r_01_4}{00004} \textcolor{keyword}{template}<> \textcolor{keyword}{class }\hyperlink{classblas__interface}{blas\_interface}<SCALAR> : \textcolor{keyword}{public} \hyperlink{classc__interface__base}{c\_interface\_base}<SCALAR>
00005 \{
00006 
00007 public :
00008   
00009   \textcolor{keyword}{static} SCALAR fone;
00010   \textcolor{keyword}{static} SCALAR fzero;
00011 
00012   \textcolor{keyword}{static} \textcolor{keyword}{inline} std::string name()
00013   \{
00014     \textcolor{keywordflow}{return} MAKE\_STRING(CBLASNAME);
00015   \}
00016 
00017   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} matrix\_vector\_product(gene\_matrix & \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, gene\_vector & \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, gene\_vector & X, \textcolor{keywordtype}{int} N)\{
00018     BLAS\_FUNC(gemv)(&notrans,&N,&N,&fone,A,&N,B,&intone,&fzero,X,&intone);
00019   \}
00020 
00021   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} symv(gene\_matrix & A, gene\_vector & B, gene\_vector & X, \textcolor{keywordtype}{int} N)\{
00022     BLAS\_FUNC(symv)(&lower, &N,&fone,A,&N,B,&intone,&fzero,X,&intone);
00023   \}
00024 
00025   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} syr2(gene\_matrix & A, gene\_vector & B, gene\_vector & X, \textcolor{keywordtype}{int} N)\{
00026     BLAS\_FUNC(syr2)(&lower,&N,&fone,B,&intone,X,&intone,A,&N);
00027   \}
00028 
00029   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} ger(gene\_matrix & A, gene\_vector & X, gene\_vector & Y, \textcolor{keywordtype}{int} N)\{
00030     BLAS\_FUNC(ger)(&N,&N,&fone,X,&intone,Y,&intone,A,&N);
00031   \}
00032 
00033   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} rot(gene\_vector & A,  gene\_vector & B, SCALAR c, SCALAR s, \textcolor{keywordtype}{int} N)\{
00034     BLAS\_FUNC(rot)(&N,A,&intone,B,&intone,&c,&s);
00035   \}
00036 
00037   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} atv\_product(gene\_matrix & A, gene\_vector & B, gene\_vector & X, \textcolor{keywordtype}{int} N)\{
00038     BLAS\_FUNC(gemv)(&trans,&N,&N,&fone,A,&N,B,&intone,&fzero,X,&intone);
00039   \}
00040 
00041   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} matrix\_matrix\_product(gene\_matrix & A, gene\_matrix & B, gene\_matrix & X, \textcolor{keywordtype}{int} N)\{
00042     BLAS\_FUNC(gemm)(&notrans,&notrans,&N,&N,&N,&fone,A,&N,B,&N,&fzero,X,&N);
00043   \}
00044 
00045   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} transposed\_matrix\_matrix\_product(gene\_matrix & A, gene\_matrix & B, gene\_matrix & X, \textcolor{keywordtype}{
      int} N)\{
00046     BLAS\_FUNC(gemm)(&notrans,&notrans,&N,&N,&N,&fone,A,&N,B,&N,&fzero,X,&N);
00047   \}
00048 
00049 \textcolor{comment}{//   static inline void ata\_product(gene\_matrix & A, gene\_matrix & X, int N)\{}
00050 \textcolor{comment}{//     ssyrk\_(&lower,&trans,&N,&N,&fone,A,&N,&fzero,X,&N);}
00051 \textcolor{comment}{//   \}}
00052 
00053   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} aat\_product(gene\_matrix & A, gene\_matrix & X, \textcolor{keywordtype}{int} N)\{
00054     BLAS\_FUNC(syrk)(&lower,&notrans,&N,&N,&fone,A,&N,&fzero,X,&N);
00055   \}
00056 
00057   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} axpy(SCALAR coef, \textcolor{keyword}{const} gene\_vector & X, gene\_vector & Y, \textcolor{keywordtype}{int} N)\{
00058     BLAS\_FUNC(axpy)(&N,&coef,X,&intone,Y,&intone);
00059   \}
00060 
00061   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} axpby(SCALAR a, \textcolor{keyword}{const} gene\_vector & X, SCALAR b, gene\_vector & Y, \textcolor{keywordtype}{int} N)\{
00062     BLAS\_FUNC(scal)(&N,&b,Y,&intone);
00063     BLAS\_FUNC(axpy)(&N,&a,X,&intone,Y,&intone);
00064   \}
00065 
00066   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} cholesky(\textcolor{keyword}{const} gene\_matrix & X, gene\_matrix & \hyperlink{group___core___module}{C}, \textcolor{keywordtype}{int} N)\{
00067     \textcolor{keywordtype}{int} N2 = N*N;
00068     BLAS\_FUNC(copy)(&N2, X, &intone, C, &intone);
00069     \textcolor{keywordtype}{char} uplo = \textcolor{charliteral}{'L'};
00070     \textcolor{keywordtype}{int} info = 0;
00071     BLAS\_FUNC(potrf)(&uplo, &N, C, &N, &info);
00072     \textcolor{keywordflow}{if}(info!=0) std::cerr << \textcolor{stringliteral}{"potrf\_ error "} << info << \textcolor{stringliteral}{"\(\backslash\)n"};
00073   \}
00074 
00075   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} partial\_lu\_decomp(\textcolor{keyword}{const} gene\_matrix & X, gene\_matrix & C, \textcolor{keywordtype}{int} N)\{
00076     \textcolor{keywordtype}{int} N2 = N*N;
00077     BLAS\_FUNC(copy)(&N2, X, &intone, C, &intone);
00078     \textcolor{keywordtype}{int} info = 0;
00079     \textcolor{keywordtype}{int} * ipiv = (\textcolor{keywordtype}{int}*)alloca(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})*N);
00080     BLAS\_FUNC(getrf)(&N, &N, C, &N, ipiv, &info);
00081     \textcolor{keywordflow}{if}(info!=0) std::cerr << \textcolor{stringliteral}{"getrf\_ error "} << info << \textcolor{stringliteral}{"\(\backslash\)n"};
00082   \}
00083   
00084   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} trisolve\_lower(\textcolor{keyword}{const} gene\_matrix & L, \textcolor{keyword}{const} gene\_vector& B, gene\_vector & X, \textcolor{keywordtype}{int} N)\{
00085     BLAS\_FUNC(copy)(&N, B, &intone, X, &intone);
00086     BLAS\_FUNC(trsv)(&lower, &notrans, &nonunit, &N, L, &N, X, &intone);
00087   \}
00088 
00089   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} trisolve\_lower\_matrix(\textcolor{keyword}{const} gene\_matrix & L, \textcolor{keyword}{const} gene\_matrix& B, gene\_matrix & X, \textcolor{keywordtype}{
      int} N)\{
00090     BLAS\_FUNC(copy)(&N, B, &intone, X, &intone);
00091     BLAS\_FUNC(trsm)(&right, &lower, &notrans, &nonunit, &N, &N, &fone, L, &N, X, &N);
00092   \}
00093 
00094   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} trmm(gene\_matrix & A, gene\_matrix & B, gene\_matrix & \textcolor{comment}{/*X*/}, \textcolor{keywordtype}{int} N)\{
00095     BLAS\_FUNC(trmm)(&left, &lower, &notrans,&nonunit, &N,&N,&fone,A,&N,B,&N);
00096   \}
00097 
00098 \textcolor{preprocessor}{  #ifdef HAS\_LAPACK}
00099 
00100   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} lu\_decomp(\textcolor{keyword}{const} gene\_matrix & X, gene\_matrix & C, \textcolor{keywordtype}{int} N)\{
00101     \textcolor{keywordtype}{int} N2 = N*N;
00102     BLAS\_FUNC(copy)(&N2, X, &intone, C, &intone);
00103     \textcolor{keywordtype}{int} info = 0;
00104     \textcolor{keywordtype}{int} * ipiv = (\textcolor{keywordtype}{int}*)alloca(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})*N);
00105     \textcolor{keywordtype}{int} * jpiv = (\textcolor{keywordtype}{int}*)alloca(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})*N);
00106     BLAS\_FUNC(getc2)(&N, C, &N, ipiv, jpiv, &info);
00107   \}
00108 
00109 
00110 
00111   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} hessenberg(\textcolor{keyword}{const} gene\_matrix & X, gene\_matrix & C, \textcolor{keywordtype}{int} N)\{
00112     \{
00113       \textcolor{keywordtype}{int} N2 = N*N;
00114       \textcolor{keywordtype}{int} inc = 1;
00115       BLAS\_FUNC(copy)(&N2, X, &inc, C, &inc);
00116     \}
00117     \textcolor{keywordtype}{int} info = 0;
00118     \textcolor{keywordtype}{int} ilo = 1;
00119     \textcolor{keywordtype}{int} ihi = N;
00120     \textcolor{keywordtype}{int} bsize = 64;
00121     \textcolor{keywordtype}{int} worksize = N*bsize;
00122     SCALAR* d = \textcolor{keyword}{new} SCALAR[N+worksize];
00123     BLAS\_FUNC(gehrd)(&N, &ilo, &ihi, C, &N, d, d+N, &worksize, &info);
00124     \textcolor{keyword}{delete}[] d;
00125   \}
00126 
00127   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} tridiagonalization(\textcolor{keyword}{const} gene\_matrix & X, gene\_matrix & C, \textcolor{keywordtype}{int} N)\{
00128     \{
00129       \textcolor{keywordtype}{int} N2 = N*N;
00130       \textcolor{keywordtype}{int} inc = 1;
00131       BLAS\_FUNC(copy)(&N2, X, &inc, C, &inc);
00132     \}
00133     \textcolor{keywordtype}{char} uplo = \textcolor{charliteral}{'U'};
00134     \textcolor{keywordtype}{int} info = 0;
00135     \textcolor{keywordtype}{int} bsize = 64;
00136     \textcolor{keywordtype}{int} worksize = N*bsize;
00137     SCALAR* d = \textcolor{keyword}{new} SCALAR[3*N+worksize];
00138     BLAS\_FUNC(sytrd)(&uplo, &N, C, &N, d, d+N, d+2*N, d+3*N, &worksize, &info);
00139     \textcolor{keyword}{delete}[] d;
00140   \}
00141   
00142 \textcolor{preprocessor}{  #endif // HAS\_LAPACK}
00143 
00144 \};
00145 
00146 SCALAR \hyperlink{classblas__interface}{blas\_interface<SCALAR>::fone} = SCALAR(1);
00147 SCALAR \hyperlink{classblas__interface}{blas\_interface<SCALAR>::fzero} = SCALAR(0);
\end{DoxyCode}
