\hypertarget{eigen_2test_2permutationmatrices_8cpp_source}{}\section{eigen/test/permutationmatrices.cpp}
\label{eigen_2test_2permutationmatrices_8cpp_source}\index{permutationmatrices.\+cpp@{permutationmatrices.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#define TEST\_ENABLE\_TEMPORARY\_TRACKING}
00011   
00012 \textcolor{preprocessor}{#include "main.h"}
00013 
00014 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00015 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} permutationmatrices(\textcolor{keyword}{const} MatrixType& m)
00016 \{
00017   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00018   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00019   \textcolor{keyword}{enum} \{ Rows = MatrixType::RowsAtCompileTime, Cols = MatrixType::ColsAtCompileTime,
00020          Options = MatrixType::Options \};
00021   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_permutation_matrix}{PermutationMatrix<Rows>} LeftPermutationType;
00022   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<int, Rows, 1>} LeftPermutationVectorType;
00023   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<LeftPermutationType>} MapLeftPerm;
00024   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_permutation_matrix}{PermutationMatrix<Cols>} RightPermutationType;
00025   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<int, Cols, 1>} RightPermutationVectorType;
00026   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<RightPermutationType>} MapRightPerm;
00027 
00028   Index rows = m.rows();
00029   Index cols = m.cols();
00030 
00031   MatrixType m\_original = MatrixType::Random(rows,cols);
00032   LeftPermutationVectorType lv;
00033   randomPermutationVector(lv, rows);
00034   LeftPermutationType lp(lv);
00035   RightPermutationVectorType rv;
00036   randomPermutationVector(rv, cols);
00037   RightPermutationType rp(rv);
00038   MatrixType m\_permuted = MatrixType::Random(rows,cols);
00039   
00040   VERIFY\_EVALUATION\_COUNT(m\_permuted = lp * m\_original * rp, 1); \textcolor{comment}{// 1 temp for sub expression "lp *
       m\_original"}
00041 
00042   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<rows; i++)
00043     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<cols; j++)
00044         VERIFY\_IS\_APPROX(m\_permuted(lv(i),j), m\_original(i,rv(j)));
00045 
00046   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Rows,Rows>} lm(lp);
00047   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Cols,Cols>} rm(rp);
00048 
00049   VERIFY\_IS\_APPROX(m\_permuted, lm*m\_original*rm);
00050   
00051   m\_permuted = m\_original;
00052   VERIFY\_EVALUATION\_COUNT(m\_permuted = lp * m\_permuted * rp, 1);
00053   VERIFY\_IS\_APPROX(m\_permuted, lm*m\_original*rm);
00054   
00055   VERIFY\_IS\_APPROX(lp.inverse()*m\_permuted*rp.inverse(), m\_original);
00056   VERIFY\_IS\_APPROX(lv.asPermutation().inverse()*m\_permuted*rv.asPermutation().inverse(), m\_original);
00057   VERIFY\_IS\_APPROX(MapLeftPerm(lv.data(),lv.size()).inverse()*m\_permuted*MapRightPerm(rv.data(),rv.size()).
      inverse(), m\_original);
00058   
00059   VERIFY((lp*lp.inverse()).toDenseMatrix().isIdentity());
00060   VERIFY((lv.asPermutation()*lv.asPermutation().inverse()).toDenseMatrix().isIdentity());
00061   VERIFY((MapLeftPerm(lv.data(),lv.size())*MapLeftPerm(lv.data(),lv.size()).inverse()).toDenseMatrix().
      isIdentity());
00062 
00063   LeftPermutationVectorType lv2;
00064   randomPermutationVector(lv2, rows);
00065   LeftPermutationType lp2(lv2);
00066   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Rows,Rows>} lm2(lp2);
00067   VERIFY\_IS\_APPROX((lp*lp2).toDenseMatrix().\textcolor{keyword}{template} cast<Scalar>(), lm*lm2);
00068   VERIFY\_IS\_APPROX((lv.asPermutation()*lv2.asPermutation()).toDenseMatrix().template cast<Scalar>(), lm*lm2
      );
00069   VERIFY\_IS\_APPROX((MapLeftPerm(lv.data(),lv.size())*MapLeftPerm(lv2.data(),lv2.size())).toDenseMatrix().
      template cast<Scalar>(), lm*lm2);
00070 
00071   LeftPermutationType identityp;
00072   identityp.setIdentity(rows);
00073   VERIFY\_IS\_APPROX(m\_original, identityp*m\_original);
00074   
00075   \textcolor{comment}{// check inplace permutations}
00076   m\_permuted = m\_original;
00077   VERIFY\_EVALUATION\_COUNT(m\_permuted.noalias()= lp.inverse() * m\_permuted, 1); \textcolor{comment}{// 1 temp to allocate the
       mask}
00078   VERIFY\_IS\_APPROX(m\_permuted, lp.inverse()*m\_original);
00079   
00080   m\_permuted = m\_original;
00081   VERIFY\_EVALUATION\_COUNT(m\_permuted.noalias() = m\_permuted * rp.inverse(), 1); \textcolor{comment}{// 1 temp to allocate the
       mask}
00082   VERIFY\_IS\_APPROX(m\_permuted, m\_original*rp.inverse());
00083   
00084   m\_permuted = m\_original;
00085   VERIFY\_EVALUATION\_COUNT(m\_permuted.noalias() = lp * m\_permuted, 1); \textcolor{comment}{// 1 temp to allocate the mask}
00086   VERIFY\_IS\_APPROX(m\_permuted, lp*m\_original);
00087   
00088   m\_permuted = m\_original;
00089   VERIFY\_EVALUATION\_COUNT(m\_permuted.noalias() = m\_permuted * rp, 1); \textcolor{comment}{// 1 temp to allocate the mask}
00090   VERIFY\_IS\_APPROX(m\_permuted, m\_original*rp);
00091 
00092   \textcolor{keywordflow}{if}(rows>1 && cols>1)
00093   \{
00094     lp2 = lp;
00095     Index i = internal::random<Index>(0, rows-1);
00096     Index j;
00097     \textcolor{keywordflow}{do} j = internal::random<Index>(0, rows-1); \textcolor{keywordflow}{while}(j==i);
00098     lp2.applyTranspositionOnTheLeft(i, j);
00099     lm = lp;
00100     lm.row(i).swap(lm.row(j));
00101     VERIFY\_IS\_APPROX(lm, lp2.toDenseMatrix().template cast<Scalar>());
00102 
00103     RightPermutationType rp2 = rp;
00104     i = internal::random<Index>(0, cols-1);
00105     \textcolor{keywordflow}{do} j = internal::random<Index>(0, cols-1); \textcolor{keywordflow}{while}(j==i);
00106     rp2.applyTranspositionOnTheRight(i, j);
00107     rm = rp;
00108     rm.col(i).swap(rm.col(j));
00109     VERIFY\_IS\_APPROX(rm, rp2.toDenseMatrix().template cast<Scalar>());
00110   \}
00111 
00112   \{
00113     \textcolor{comment}{// simple compilation check}
00114     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Cols, Cols>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{A} = rp;
00115     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Cols, Cols>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{B} = rp.transpose();
00116     VERIFY\_IS\_APPROX(A, B.transpose());
00117   \}
00118 \}
00119 
00120 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00121 \textcolor{keywordtype}{void} bug890()
00122 \{
00123   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<T, Dynamic, Dynamic>} MatrixType;
00124   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<T, Dynamic, 1>} \hyperlink{struct_vector_type}{VectorType};
00125   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_stride}{Stride<Dynamic,Dynamic>} S;
00126   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<MatrixType, Aligned, S>} \hyperlink{group___core___module_class_eigen_1_1_map}{MapType};
00127   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_permutation_matrix}{PermutationMatrix<Dynamic>} Perm;
00128   
00129   VectorType v1(2), v2(2), op(4), rhs(2);
00130   v1 << 666,667;
00131   op << 1,0,0,1;
00132   rhs << 42,42;
00133   
00134   Perm P(2);
00135   P.indices() << 1, 0;
00136 
00137   MapType(v1.data(),2,1,S(1,1)) = P * MapType(rhs.data(),2,1,S(1,1));
00138   VERIFY\_IS\_APPROX(v1, (P * rhs).eval());
00139   
00140   MapType(v1.data(),2,1,S(1,1)) = P.\hyperlink{group___geometry___module_a20ca137b84f18b9c41a0fef9c222e0da}{inverse}() * MapType(rhs.data(),2,1,S(1,1));
00141   VERIFY\_IS\_APPROX(v1, (P.\hyperlink{group___geometry___module_a20ca137b84f18b9c41a0fef9c222e0da}{inverse}() * rhs).eval());
00142 \}
00143 
00144 \textcolor{keywordtype}{void} test\_permutationmatrices()
00145 \{
00146   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00147     CALL\_SUBTEST\_1( permutationmatrices(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00148     CALL\_SUBTEST\_2( permutationmatrices(Matrix3f()) );
00149     CALL\_SUBTEST\_3( permutationmatrices(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,3,3,RowMajor>}()) );
00150     CALL\_SUBTEST\_4( permutationmatrices(Matrix4d()) );
00151     CALL\_SUBTEST\_5( permutationmatrices(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,40,60>}()) );
00152     CALL\_SUBTEST\_6( permutationmatrices(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,Dynamic,Dynamic,RowMajor>}
      (20, 30)) );
00153     CALL\_SUBTEST\_7( permutationmatrices(MatrixXcf(15, 10)) );
00154   \}
00155   CALL\_SUBTEST\_5( bug890<double>() );
00156 \}
\end{DoxyCode}
