\hypertarget{matio_2visual__studio_2test_2eigen_2test_2product__selfadjoint_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/product\+\_\+selfadjoint.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2product__selfadjoint_8cpp_source}\index{product\+\_\+selfadjoint.\+cpp@{product\+\_\+selfadjoint.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} product\_selfadjoint(\textcolor{keyword}{const} MatrixType& m)
00013 \{
00014   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00015   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00016   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, 1>} 
      \hyperlink{struct_vector_type}{VectorType};
00017   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, 1, MatrixType::RowsAtCompileTime>} 
      RowVectorType;
00018 
00019   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, Dynamic, RowMajor>}
       RhsMatrixType;
00020 
00021   Index rows = m.rows();
00022   Index cols = m.cols();
00023 
00024   MatrixType m1 = MatrixType::Random(rows, cols),
00025              m2 = MatrixType::Random(rows, cols),
00026              m3;
00027   VectorType v1 = VectorType::Random(rows),
00028              v2 = VectorType::Random(rows),
00029              v3(rows);
00030   RowVectorType r1 = RowVectorType::Random(rows),
00031                 r2 = RowVectorType::Random(rows);
00032   RhsMatrixType m4 = RhsMatrixType::Random(rows,10);
00033 
00034   Scalar s1 = internal::random<Scalar>(),
00035          s2 = internal::random<Scalar>(),
00036          s3 = internal::random<Scalar>();
00037 
00038   m1 = (m1.adjoint() + m1).eval();
00039 
00040   \textcolor{comment}{// rank2 update}
00041   m2 = m1.template triangularView<Lower>();
00042   m2.template selfadjointView<Lower>().rankUpdate(v1,v2);
00043   VERIFY\_IS\_APPROX(m2, (m1 + v1 * v2.adjoint()+ v2 * v1.adjoint()).\textcolor{keyword}{template} triangularView<Lower>().
      toDenseMatrix());
00044 
00045   m2 = m1.template triangularView<Upper>();
00046   m2.template selfadjointView<Upper>().rankUpdate(-v1,s2*v2,s3);
00047   VERIFY\_IS\_APPROX(m2, (m1 + (s3*(-v1)*(s2*v2).adjoint()+numext::conj(s3)*(s2*v2)*(-v1).adjoint())).\textcolor{keyword}{
      template} triangularView<Upper>().toDenseMatrix());
00048 
00049   m2 = m1.template triangularView<Upper>();
00050   m2.template selfadjointView<Upper>().rankUpdate(-s2*r1.adjoint(),r2.adjoint()*s3,s1);
00051   VERIFY\_IS\_APPROX(m2, (m1 + s1*(-s2*r1.adjoint())*(r2.adjoint()*s3).adjoint() + numext::conj(s1)*(r2.
      adjoint()*s3) * (-s2*r1.adjoint()).adjoint()).\textcolor{keyword}{template} triangularView<Upper>().toDenseMatrix());
00052 
00053   \textcolor{keywordflow}{if} (rows>1)
00054   \{
00055     m2 = m1.template triangularView<Lower>();
00056     m2.block(1,1,rows-1,cols-1).template selfadjointView<Lower>().rankUpdate(v1.tail(rows-1),v2.head(cols-1
      ));
00057     m3 = m1;
00058     m3.block(1,1,rows-1,cols-1) += v1.tail(rows-1) * v2.head(cols-1).adjoint()+ v2.head(cols-1) * v1.tail(
      rows-1).adjoint();
00059     VERIFY\_IS\_APPROX(m2, m3.template triangularView<Lower>().toDenseMatrix());
00060   \}
00061 \}
00062 
00063 \textcolor{keywordtype}{void} test\_product\_selfadjoint()
00064 \{
00065   \textcolor{keywordtype}{int} s = 0;
00066   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat ; i++) \{
00067     CALL\_SUBTEST\_1( product\_selfadjoint(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00068     CALL\_SUBTEST\_2( product\_selfadjoint(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 2, 2>}()) );
00069     CALL\_SUBTEST\_3( product\_selfadjoint(Matrix3d()) );
00070     
00071     s = internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2);
00072     CALL\_SUBTEST\_4( product\_selfadjoint(MatrixXcf(s, s)) );
00073     TEST\_SET\_BUT\_UNUSED\_VARIABLE(s)
00074     
00075     s = internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2);
00076     CALL\_SUBTEST\_5( product\_selfadjoint(MatrixXcd(s,s)) );
00077     TEST\_SET\_BUT\_UNUSED\_VARIABLE(s)
00078     
00079     s = internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE);
00080     CALL\_SUBTEST\_6( product\_selfadjoint(MatrixXd(s,s)) );
00081     TEST\_SET\_BUT\_UNUSED\_VARIABLE(s)
00082     
00083     s = internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE);
00084     CALL\_SUBTEST\_7( product\_selfadjoint(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,Dynamic,Dynamic,RowMajor>}
      (s,s)) );
00085     TEST\_SET\_BUT\_UNUSED\_VARIABLE(s)
00086   \}
00087 \}
\end{DoxyCode}
