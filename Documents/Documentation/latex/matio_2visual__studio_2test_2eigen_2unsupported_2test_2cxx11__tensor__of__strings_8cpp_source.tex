\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2test_2cxx11__tensor__of__strings_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/test/cxx11\+\_\+tensor\+\_\+of\+\_\+strings.cpp}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2test_2cxx11__tensor__of__strings_8cpp_source}\index{cxx11\+\_\+tensor\+\_\+of\+\_\+strings.\+cpp@{cxx11\+\_\+tensor\+\_\+of\+\_\+strings.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{preprocessor}{#include <Eigen/CXX11/Tensor>}
00013 
00014 \textcolor{keyword}{using} \hyperlink{class_eigen_1_1_tensor}{Eigen::Tensor};
00015 \textcolor{keyword}{using} \hyperlink{class_eigen_1_1_tensor_map}{Eigen::TensorMap};
00016 
00017 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_assign()
00018 \{
00019   std::string data1[6];
00020   \hyperlink{class_eigen_1_1_tensor_map}{TensorMap<Tensor<std::string, 2>}> mat1(data1, 2, 3);
00021   std::string data2[6];
00022   \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_map}{TensorMap<Tensor<const std::string, 2>}> mat2(data2, 2, 3);
00023 
00024   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 6; ++i) \{
00025     std::ostringstream s1;
00026     s1 << \textcolor{stringliteral}{"abc"} << i*3;
00027     data1[i] = s1.str();
00028     std::ostringstream s2;
00029     s2 << \textcolor{stringliteral}{"def"} << i*5;
00030     data2[i] = s2.str();
00031   \}
00032 
00033   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} rslt1;
00034   rslt1 = mat1;
00035   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} rslt2;
00036   rslt2 = mat2;
00037 
00038   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} rslt3 = mat1;
00039   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} rslt4 = mat2;
00040 
00041   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} rslt5(mat1);
00042   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} rslt6(mat2);
00043 
00044   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 2; ++i) \{
00045     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 3; ++j) \{
00046       VERIFY\_IS\_EQUAL(rslt1(i,j), data1[i+2*j]);
00047       VERIFY\_IS\_EQUAL(rslt2(i,j), data2[i+2*j]);
00048       VERIFY\_IS\_EQUAL(rslt3(i,j), data1[i+2*j]);
00049       VERIFY\_IS\_EQUAL(rslt4(i,j), data2[i+2*j]);
00050       VERIFY\_IS\_EQUAL(rslt5(i,j), data1[i+2*j]);
00051       VERIFY\_IS\_EQUAL(rslt6(i,j), data2[i+2*j]);
00052     \}
00053   \}
00054 \}
00055 
00056 
00057 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_concat()
00058 \{
00059   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} t1(2, 3);
00060   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} t2(2, 3);
00061 
00062   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 2; ++i) \{
00063     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 3; ++j) \{
00064       std::ostringstream s1;
00065       s1 << \textcolor{stringliteral}{"abc"} << i + j*2;
00066       t1(i, j) = s1.str();
00067       std::ostringstream s2;
00068       s2 << \textcolor{stringliteral}{"def"} << i*5 + j*32;
00069       t2(i, j) = s2.str();
00070     \}
00071   \}
00072 
00073   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} result = t1.concatenate(t2, 1);
00074   VERIFY\_IS\_EQUAL(result.dimension(0), 2);
00075   VERIFY\_IS\_EQUAL(result.dimension(1), 6);
00076 
00077   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 2; ++i) \{
00078     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 3; ++j) \{
00079       VERIFY\_IS\_EQUAL(result(i, j),   t1(i, j));
00080       VERIFY\_IS\_EQUAL(result(i, j+3), t2(i, j));
00081     \}
00082   \}
00083 \}
00084 
00085 
00086 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_slices()
00087 \{
00088   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} data(2, 6);
00089   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 2; ++i) \{
00090     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 3; ++j) \{
00091       std::ostringstream s1;
00092       s1 << \textcolor{stringliteral}{"abc"} << i + j*2;
00093       data(i, j) = s1.str();
00094     \}
00095   \}
00096 
00097   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_d_sizes}{Eigen::DSizes<ptrdiff\_t, 2>} half\_size(2, 3);
00098   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_d_sizes}{Eigen::DSizes<ptrdiff\_t, 2>} first\_half(0, 0);
00099   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_d_sizes}{Eigen::DSizes<ptrdiff\_t, 2>} second\_half(0, 3);
00100 
00101   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} t1 = data.slice(first\_half, half\_size);
00102   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} t2 = data.slice(second\_half, half\_size);
00103 
00104   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 2; ++i) \{
00105     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 3; ++j) \{
00106       VERIFY\_IS\_EQUAL(data(i, j),   t1(i, j));
00107       VERIFY\_IS\_EQUAL(data(i, j+3), t2(i, j));
00108     \}
00109   \}
00110 \}
00111 
00112 
00113 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_additions()
00114 \{
00115   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 1>} data1(3);
00116   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 1>} data2(3);
00117   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; ++i) \{
00118     data1(i) = \textcolor{stringliteral}{"abc"};
00119     std::ostringstream s1;
00120     s1 << i;
00121     data2(i) = s1.str();
00122   \}
00123 
00124   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 1>} sum = data1 + data2;
00125   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; ++i) \{
00126     std::ostringstream concat;
00127     concat << \textcolor{stringliteral}{"abc"} << i;
00128     std::string expected = concat.str();
00129     VERIFY\_IS\_EQUAL(sum(i), expected);
00130   \}
00131 \}
00132 
00133 
00134 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_initialization()
00135 \{
00136   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::string, 2>} a(2, 3);
00137   a.setConstant(std::string(\textcolor{stringliteral}{"foo"}));
00138   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 2*3; ++i) \{
00139     VERIFY\_IS\_EQUAL(a(i), std::string(\textcolor{stringliteral}{"foo"}));
00140   \}
00141 \}
00142 
00143 
00144 \textcolor{keywordtype}{void} test\_cxx11\_tensor\_of\_strings()
00145 \{
00146   \textcolor{comment}{// Beware: none of this is likely to ever work on a GPU.}
00147   CALL\_SUBTEST(test\_assign());
00148   CALL\_SUBTEST(test\_concat());
00149   CALL\_SUBTEST(test\_slices());
00150   CALL\_SUBTEST(test\_additions());
00151   CALL\_SUBTEST(test\_initialization());
00152 \}
\end{DoxyCode}
