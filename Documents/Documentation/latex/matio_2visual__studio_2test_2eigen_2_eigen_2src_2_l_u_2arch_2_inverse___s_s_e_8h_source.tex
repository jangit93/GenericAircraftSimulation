\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_l_u_2arch_2_inverse___s_s_e_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+L\+U/arch/\+Inverse\+\_\+\+S\+SE.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_l_u_2arch_2_inverse___s_s_e_8h_source}\index{Inverse\+\_\+\+S\+S\+E.\+h@{Inverse\+\_\+\+S\+S\+E.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2001 Intel Corporation}
00005 \textcolor{comment}{// Copyright (C) 2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{// Copyright (C) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>}
00007 \textcolor{comment}{//}
00008 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00009 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00010 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00011 
00012 \textcolor{comment}{// The SSE code for the 4x4 float and double matrix inverse in this file}
00013 \textcolor{comment}{// comes from the following Intel's library:}
00014 \textcolor{comment}{//
       http://software.intel.com/en-us/articles/optimized-matrix-library-for-use-with-the-intel-pentiumr-4-processors-sse2-instructions/}
00015 \textcolor{comment}{//}
00016 \textcolor{comment}{// Here is the respective copyright and license statement:}
00017 \textcolor{comment}{//}
00018 \textcolor{comment}{//   Copyright (c) 2001 Intel Corporation.}
00019 \textcolor{comment}{//}
00020 \textcolor{comment}{// Permition is granted to use, copy, distribute and prepare derivative works}
00021 \textcolor{comment}{// of this library for any purpose and without fee, provided, that the above}
00022 \textcolor{comment}{// copyright notice and this statement appear in all copies.}
00023 \textcolor{comment}{// Intel makes no representations about the suitability of this software for}
00024 \textcolor{comment}{// any purpose, and specifically disclaims all warranties.}
00025 \textcolor{comment}{// See LEGAL.TXT for all the legal information.}
00026 
00027 \textcolor{preprocessor}{#ifndef EIGEN\_INVERSE\_SSE\_H}
00028 \textcolor{preprocessor}{#define EIGEN\_INVERSE\_SSE\_H}
00029 
00030 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00031 
00032 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00033 
00034 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ResultType>
00035 \textcolor{keyword}{struct }compute\_inverse\_size4<Architecture::SSE, float, MatrixType, ResultType>
00036 \{
00037   \textcolor{keyword}{enum} \{
00038     MatrixAlignment     = traits<MatrixType>::Alignment,
00039     ResultAlignment     = traits<ResultType>::Alignment,
00040     StorageOrdersMatch  = (MatrixType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) == (ResultType::Flags&
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})
00041   \};
00042   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<(MatrixType::Flags&LinearAccessBit),MatrixType const &,typename
       MatrixType::PlainObject>::type ActualMatrixType;
00043   
00044   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} MatrixType& mat, ResultType& result)
00045   \{
00046     ActualMatrixType matrix(mat);
00047     EIGEN\_ALIGN16 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_Sign\_PNNP[4] = \{ 0x00000000, 0x80000000, 0x80000000, 0x00000000 \};
00048 
00049     \textcolor{comment}{// Load the full matrix into registers}
00050     \_\_m128 \_L1 = matrix.template packet<MatrixAlignment>( 0);
00051     \_\_m128 \_L2 = matrix.template packet<MatrixAlignment>( 4);
00052     \_\_m128 \_L3 = matrix.template packet<MatrixAlignment>( 8);
00053     \_\_m128 \_L4 = matrix.template packet<MatrixAlignment>(12);
00054 
00055     \textcolor{comment}{// The inverse is calculated using "Divide and Conquer" technique. The}
00056     \textcolor{comment}{// original matrix is divide into four 2x2 sub-matrices. Since each}
00057     \textcolor{comment}{// register holds four matrix element, the smaller matrices are}
00058     \textcolor{comment}{// represented as a registers. Hence we get a better locality of the}
00059     \textcolor{comment}{// calculations.}
00060 
00061     \_\_m128 A, B, C, D; \textcolor{comment}{// the four sub-matrices}
00062     \textcolor{keywordflow}{if}(!StorageOrdersMatch)
00063     \{
00064       A = \_mm\_unpacklo\_ps(\_L1, \_L2);
00065       B = \_mm\_unpacklo\_ps(\_L3, \_L4);
00066       C = \_mm\_unpackhi\_ps(\_L1, \_L2);
00067       D = \_mm\_unpackhi\_ps(\_L3, \_L4);
00068     \}
00069     \textcolor{keywordflow}{else}
00070     \{
00071       A = \_mm\_movelh\_ps(\_L1, \_L2);
00072       B = \_mm\_movehl\_ps(\_L2, \_L1);
00073       C = \_mm\_movelh\_ps(\_L3, \_L4);
00074       D = \_mm\_movehl\_ps(\_L4, \_L3);
00075     \}
00076 
00077     \_\_m128 iA, iB, iC, iD,                 \textcolor{comment}{// partial inverse of the sub-matrices}
00078             DC, AB;
00079     \_\_m128 dA, dB, dC, dD;                 \textcolor{comment}{// determinant of the sub-matrices}
00080     \_\_m128 det, d, d1, d2;
00081     \_\_m128 rd;                             \textcolor{comment}{// reciprocal of the determinant}
00082 
00083     \textcolor{comment}{//  AB = A# * B}
00084     AB = \_mm\_mul\_ps(\_mm\_shuffle\_ps(A,A,0x0F), B);
00085     AB = \_mm\_sub\_ps(AB,\_mm\_mul\_ps(\_mm\_shuffle\_ps(A,A,0xA5), \_mm\_shuffle\_ps(B,B,0x4E)));
00086     \textcolor{comment}{//  DC = D# * C}
00087     DC = \_mm\_mul\_ps(\_mm\_shuffle\_ps(D,D,0x0F), C);
00088     DC = \_mm\_sub\_ps(DC,\_mm\_mul\_ps(\_mm\_shuffle\_ps(D,D,0xA5), \_mm\_shuffle\_ps(C,C,0x4E)));
00089 
00090     \textcolor{comment}{//  dA = |A|}
00091     dA = \_mm\_mul\_ps(\_mm\_shuffle\_ps(A, A, 0x5F),A);
00092     dA = \_mm\_sub\_ss(dA, \_mm\_movehl\_ps(dA,dA));
00093     \textcolor{comment}{//  dB = |B|}
00094     dB = \_mm\_mul\_ps(\_mm\_shuffle\_ps(B, B, 0x5F),B);
00095     dB = \_mm\_sub\_ss(dB, \_mm\_movehl\_ps(dB,dB));
00096 
00097     \textcolor{comment}{//  dC = |C|}
00098     dC = \_mm\_mul\_ps(\_mm\_shuffle\_ps(C, C, 0x5F),C);
00099     dC = \_mm\_sub\_ss(dC, \_mm\_movehl\_ps(dC,dC));
00100     \textcolor{comment}{//  dD = |D|}
00101     dD = \_mm\_mul\_ps(\_mm\_shuffle\_ps(D, D, 0x5F),D);
00102     dD = \_mm\_sub\_ss(dD, \_mm\_movehl\_ps(dD,dD));
00103 
00104     \textcolor{comment}{//  d = trace(AB*DC) = trace(A#*B*D#*C)}
00105     d = \_mm\_mul\_ps(\_mm\_shuffle\_ps(DC,DC,0xD8),AB);
00106 
00107     \textcolor{comment}{//  iD = C*A#*B}
00108     iD = \_mm\_mul\_ps(\_mm\_shuffle\_ps(C,C,0xA0), \_mm\_movelh\_ps(AB,AB));
00109     iD = \_mm\_add\_ps(iD,\_mm\_mul\_ps(\_mm\_shuffle\_ps(C,C,0xF5), \_mm\_movehl\_ps(AB,AB)));
00110     \textcolor{comment}{//  iA = B*D#*C}
00111     iA = \_mm\_mul\_ps(\_mm\_shuffle\_ps(B,B,0xA0), \_mm\_movelh\_ps(DC,DC));
00112     iA = \_mm\_add\_ps(iA,\_mm\_mul\_ps(\_mm\_shuffle\_ps(B,B,0xF5), \_mm\_movehl\_ps(DC,DC)));
00113 
00114     \textcolor{comment}{//  d = trace(AB*DC) = trace(A#*B*D#*C) [continue]}
00115     d  = \_mm\_add\_ps(d, \_mm\_movehl\_ps(d, d));
00116     d  = \_mm\_add\_ss(d, \_mm\_shuffle\_ps(d, d, 1));
00117     d1 = \_mm\_mul\_ss(dA,dD);
00118     d2 = \_mm\_mul\_ss(dB,dC);
00119 
00120     \textcolor{comment}{//  iD = D*|A| - C*A#*B}
00121     iD = \_mm\_sub\_ps(\_mm\_mul\_ps(D,\_mm\_shuffle\_ps(dA,dA,0)), iD);
00122 
00123     \textcolor{comment}{//  iA = A*|D| - B*D#*C;}
00124     iA = \_mm\_sub\_ps(\_mm\_mul\_ps(A,\_mm\_shuffle\_ps(dD,dD,0)), iA);
00125 
00126     \textcolor{comment}{//  det = |A|*|D| + |B|*|C| - trace(A#*B*D#*C)}
00127     det = \_mm\_sub\_ss(\_mm\_add\_ss(d1,d2),d);
00128     rd  = \_mm\_div\_ss(\_mm\_set\_ss(1.0f), det);
00129 
00130 \textcolor{comment}{//     #ifdef ZERO\_SINGULAR}
00131 \textcolor{comment}{//         rd = \_mm\_and\_ps(\_mm\_cmpneq\_ss(det,\_mm\_setzero\_ps()), rd);}
00132 \textcolor{comment}{//     #endif}
00133 
00134     \textcolor{comment}{//  iB = D * (A#B)# = D*B#*A}
00135     iB = \_mm\_mul\_ps(D, \_mm\_shuffle\_ps(AB,AB,0x33));
00136     iB = \_mm\_sub\_ps(iB, \_mm\_mul\_ps(\_mm\_shuffle\_ps(D,D,0xB1), \_mm\_shuffle\_ps(AB,AB,0x66)));
00137     \textcolor{comment}{//  iC = A * (D#C)# = A*C#*D}
00138     iC = \_mm\_mul\_ps(A, \_mm\_shuffle\_ps(DC,DC,0x33));
00139     iC = \_mm\_sub\_ps(iC, \_mm\_mul\_ps(\_mm\_shuffle\_ps(A,A,0xB1), \_mm\_shuffle\_ps(DC,DC,0x66)));
00140 
00141     rd = \_mm\_shuffle\_ps(rd,rd,0);
00142     rd = \_mm\_xor\_ps(rd, \_mm\_load\_ps((\textcolor{keywordtype}{float}*)\_Sign\_PNNP));
00143 
00144     \textcolor{comment}{//  iB = C*|B| - D*B#*A}
00145     iB = \_mm\_sub\_ps(\_mm\_mul\_ps(C,\_mm\_shuffle\_ps(dB,dB,0)), iB);
00146 
00147     \textcolor{comment}{//  iC = B*|C| - A*C#*D;}
00148     iC = \_mm\_sub\_ps(\_mm\_mul\_ps(B,\_mm\_shuffle\_ps(dC,dC,0)), iC);
00149 
00150     \textcolor{comment}{//  iX = iX / det}
00151     iA = \_mm\_mul\_ps(rd,iA);
00152     iB = \_mm\_mul\_ps(rd,iB);
00153     iC = \_mm\_mul\_ps(rd,iC);
00154     iD = \_mm\_mul\_ps(rd,iD);
00155 
00156     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} res\_stride = result.outerStride();
00157     \textcolor{keywordtype}{float}* res = result.data();
00158     pstoret<float, Packet4f, ResultAlignment>(res+0,            \_mm\_shuffle\_ps(iA,iB,0x77));
00159     pstoret<float, Packet4f, ResultAlignment>(res+res\_stride,   \_mm\_shuffle\_ps(iA,iB,0x22));
00160     pstoret<float, Packet4f, ResultAlignment>(res+2*res\_stride, \_mm\_shuffle\_ps(iC,iD,0x77));
00161     pstoret<float, Packet4f, ResultAlignment>(res+3*res\_stride, \_mm\_shuffle\_ps(iC,iD,0x22));
00162   \}
00163 
00164 \};
00165 
00166 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ResultType>
00167 \textcolor{keyword}{struct }compute\_inverse\_size4<Architecture::SSE, double, MatrixType, ResultType>
00168 \{
00169   \textcolor{keyword}{enum} \{
00170     MatrixAlignment     = traits<MatrixType>::Alignment,
00171     ResultAlignment     = traits<ResultType>::Alignment,
00172     StorageOrdersMatch  = (MatrixType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) == (ResultType::Flags&
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})
00173   \};
00174   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<(MatrixType::Flags&LinearAccessBit),MatrixType const &,typename
       MatrixType::PlainObject>::type ActualMatrixType;
00175   
00176   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} MatrixType& mat, ResultType& result)
00177   \{
00178     ActualMatrixType matrix(mat);
00179     \textcolor{keyword}{const} \_\_m128d \_Sign\_NP = \_mm\_castsi128\_pd(\_mm\_set\_epi32(0x0,0x0,0x80000000,0x0));
00180     \textcolor{keyword}{const} \_\_m128d \_Sign\_PN = \_mm\_castsi128\_pd(\_mm\_set\_epi32(0x80000000,0x0,0x0,0x0));
00181 
00182     \textcolor{comment}{// The inverse is calculated using "Divide and Conquer" technique. The}
00183     \textcolor{comment}{// original matrix is divide into four 2x2 sub-matrices. Since each}
00184     \textcolor{comment}{// register of the matrix holds two elements, the smaller matrices are}
00185     \textcolor{comment}{// consisted of two registers. Hence we get a better locality of the}
00186     \textcolor{comment}{// calculations.}
00187 
00188     \textcolor{comment}{// the four sub-matrices}
00189     \_\_m128d A1, A2, B1, B2, C1, C2, D1, D2;
00190     
00191     \textcolor{keywordflow}{if}(StorageOrdersMatch)
00192     \{
00193       A1 = matrix.template packet<MatrixAlignment>( 0); B1 = matrix.template packet<MatrixAlignment>( 2);
00194       A2 = matrix.template packet<MatrixAlignment>( 4); B2 = matrix.template packet<MatrixAlignment>( 6);
00195       C1 = matrix.template packet<MatrixAlignment>( 8); D1 = matrix.template packet<MatrixAlignment>(10);
00196       C2 = matrix.template packet<MatrixAlignment>(12); D2 = matrix.template packet<MatrixAlignment>(14);
00197     \}
00198     \textcolor{keywordflow}{else}
00199     \{
00200       \_\_m128d tmp;
00201       A1 = matrix.template packet<MatrixAlignment>( 0); C1 = matrix.template packet<MatrixAlignment>( 2);
00202       A2 = matrix.template packet<MatrixAlignment>( 4); C2 = matrix.template packet<MatrixAlignment>( 6);
00203       tmp = A1;
00204       A1 = \_mm\_unpacklo\_pd(A1,A2);
00205       A2 = \_mm\_unpackhi\_pd(tmp,A2);
00206       tmp = C1;
00207       C1 = \_mm\_unpacklo\_pd(C1,C2);
00208       C2 = \_mm\_unpackhi\_pd(tmp,C2);
00209       
00210       B1 = matrix.template packet<MatrixAlignment>( 8); D1 = matrix.template packet<MatrixAlignment>(10);
00211       B2 = matrix.template packet<MatrixAlignment>(12); D2 = matrix.template packet<MatrixAlignment>(14);
00212       tmp = B1;
00213       B1 = \_mm\_unpacklo\_pd(B1,B2);
00214       B2 = \_mm\_unpackhi\_pd(tmp,B2);
00215       tmp = D1;
00216       D1 = \_mm\_unpacklo\_pd(D1,D2);
00217       D2 = \_mm\_unpackhi\_pd(tmp,D2);
00218     \}
00219     
00220     \_\_m128d iA1, iA2, iB1, iB2, iC1, iC2, iD1, iD2,     \textcolor{comment}{// partial invese of the sub-matrices}
00221             DC1, DC2, AB1, AB2;
00222     \_\_m128d dA, dB, dC, dD;     \textcolor{comment}{// determinant of the sub-matrices}
00223     \_\_m128d det, d1, d2, rd;
00224 
00225     \textcolor{comment}{//  dA = |A|}
00226     dA = \_mm\_shuffle\_pd(A2, A2, 1);
00227     dA = \_mm\_mul\_pd(A1, dA);
00228     dA = \_mm\_sub\_sd(dA, \_mm\_shuffle\_pd(dA,dA,3));
00229     \textcolor{comment}{//  dB = |B|}
00230     dB = \_mm\_shuffle\_pd(B2, B2, 1);
00231     dB = \_mm\_mul\_pd(B1, dB);
00232     dB = \_mm\_sub\_sd(dB, \_mm\_shuffle\_pd(dB,dB,3));
00233 
00234     \textcolor{comment}{//  AB = A# * B}
00235     AB1 = \_mm\_mul\_pd(B1, \_mm\_shuffle\_pd(A2,A2,3));
00236     AB2 = \_mm\_mul\_pd(B2, \_mm\_shuffle\_pd(A1,A1,0));
00237     AB1 = \_mm\_sub\_pd(AB1, \_mm\_mul\_pd(B2, \_mm\_shuffle\_pd(A1,A1,3)));
00238     AB2 = \_mm\_sub\_pd(AB2, \_mm\_mul\_pd(B1, \_mm\_shuffle\_pd(A2,A2,0)));
00239 
00240     \textcolor{comment}{//  dC = |C|}
00241     dC = \_mm\_shuffle\_pd(C2, C2, 1);
00242     dC = \_mm\_mul\_pd(C1, dC);
00243     dC = \_mm\_sub\_sd(dC, \_mm\_shuffle\_pd(dC,dC,3));
00244     \textcolor{comment}{//  dD = |D|}
00245     dD = \_mm\_shuffle\_pd(D2, D2, 1);
00246     dD = \_mm\_mul\_pd(D1, dD);
00247     dD = \_mm\_sub\_sd(dD, \_mm\_shuffle\_pd(dD,dD,3));
00248 
00249     \textcolor{comment}{//  DC = D# * C}
00250     DC1 = \_mm\_mul\_pd(C1, \_mm\_shuffle\_pd(D2,D2,3));
00251     DC2 = \_mm\_mul\_pd(C2, \_mm\_shuffle\_pd(D1,D1,0));
00252     DC1 = \_mm\_sub\_pd(DC1, \_mm\_mul\_pd(C2, \_mm\_shuffle\_pd(D1,D1,3)));
00253     DC2 = \_mm\_sub\_pd(DC2, \_mm\_mul\_pd(C1, \_mm\_shuffle\_pd(D2,D2,0)));
00254 
00255     \textcolor{comment}{//  rd = trace(AB*DC) = trace(A#*B*D#*C)}
00256     d1 = \_mm\_mul\_pd(AB1, \_mm\_shuffle\_pd(DC1, DC2, 0));
00257     d2 = \_mm\_mul\_pd(AB2, \_mm\_shuffle\_pd(DC1, DC2, 3));
00258     rd = \_mm\_add\_pd(d1, d2);
00259     rd = \_mm\_add\_sd(rd, \_mm\_shuffle\_pd(rd, rd,3));
00260 
00261     \textcolor{comment}{//  iD = C*A#*B}
00262     iD1 = \_mm\_mul\_pd(AB1, \_mm\_shuffle\_pd(C1,C1,0));
00263     iD2 = \_mm\_mul\_pd(AB1, \_mm\_shuffle\_pd(C2,C2,0));
00264     iD1 = \_mm\_add\_pd(iD1, \_mm\_mul\_pd(AB2, \_mm\_shuffle\_pd(C1,C1,3)));
00265     iD2 = \_mm\_add\_pd(iD2, \_mm\_mul\_pd(AB2, \_mm\_shuffle\_pd(C2,C2,3)));
00266 
00267     \textcolor{comment}{//  iA = B*D#*C}
00268     iA1 = \_mm\_mul\_pd(DC1, \_mm\_shuffle\_pd(B1,B1,0));
00269     iA2 = \_mm\_mul\_pd(DC1, \_mm\_shuffle\_pd(B2,B2,0));
00270     iA1 = \_mm\_add\_pd(iA1, \_mm\_mul\_pd(DC2, \_mm\_shuffle\_pd(B1,B1,3)));
00271     iA2 = \_mm\_add\_pd(iA2, \_mm\_mul\_pd(DC2, \_mm\_shuffle\_pd(B2,B2,3)));
00272 
00273     \textcolor{comment}{//  iD = D*|A| - C*A#*B}
00274     dA = \_mm\_shuffle\_pd(dA,dA,0);
00275     iD1 = \_mm\_sub\_pd(\_mm\_mul\_pd(D1, dA), iD1);
00276     iD2 = \_mm\_sub\_pd(\_mm\_mul\_pd(D2, dA), iD2);
00277 
00278     \textcolor{comment}{//  iA = A*|D| - B*D#*C;}
00279     dD = \_mm\_shuffle\_pd(dD,dD,0);
00280     iA1 = \_mm\_sub\_pd(\_mm\_mul\_pd(A1, dD), iA1);
00281     iA2 = \_mm\_sub\_pd(\_mm\_mul\_pd(A2, dD), iA2);
00282 
00283     d1 = \_mm\_mul\_sd(dA, dD);
00284     d2 = \_mm\_mul\_sd(dB, dC);
00285 
00286     \textcolor{comment}{//  iB = D * (A#B)# = D*B#*A}
00287     iB1 = \_mm\_mul\_pd(D1, \_mm\_shuffle\_pd(AB2,AB1,1));
00288     iB2 = \_mm\_mul\_pd(D2, \_mm\_shuffle\_pd(AB2,AB1,1));
00289     iB1 = \_mm\_sub\_pd(iB1, \_mm\_mul\_pd(\_mm\_shuffle\_pd(D1,D1,1), \_mm\_shuffle\_pd(AB2,AB1,2)));
00290     iB2 = \_mm\_sub\_pd(iB2, \_mm\_mul\_pd(\_mm\_shuffle\_pd(D2,D2,1), \_mm\_shuffle\_pd(AB2,AB1,2)));
00291 
00292     \textcolor{comment}{//  det = |A|*|D| + |B|*|C| - trace(A#*B*D#*C)}
00293     det = \_mm\_add\_sd(d1, d2);
00294     det = \_mm\_sub\_sd(det, rd);
00295 
00296     \textcolor{comment}{//  iC = A * (D#C)# = A*C#*D}
00297     iC1 = \_mm\_mul\_pd(A1, \_mm\_shuffle\_pd(DC2,DC1,1));
00298     iC2 = \_mm\_mul\_pd(A2, \_mm\_shuffle\_pd(DC2,DC1,1));
00299     iC1 = \_mm\_sub\_pd(iC1, \_mm\_mul\_pd(\_mm\_shuffle\_pd(A1,A1,1), \_mm\_shuffle\_pd(DC2,DC1,2)));
00300     iC2 = \_mm\_sub\_pd(iC2, \_mm\_mul\_pd(\_mm\_shuffle\_pd(A2,A2,1), \_mm\_shuffle\_pd(DC2,DC1,2)));
00301 
00302     rd = \_mm\_div\_sd(\_mm\_set\_sd(1.0), det);
00303 \textcolor{comment}{//     #ifdef ZERO\_SINGULAR}
00304 \textcolor{comment}{//         rd = \_mm\_and\_pd(\_mm\_cmpneq\_sd(det,\_mm\_setzero\_pd()), rd);}
00305 \textcolor{comment}{//     #endif}
00306     rd = \_mm\_shuffle\_pd(rd,rd,0);
00307 
00308     \textcolor{comment}{//  iB = C*|B| - D*B#*A}
00309     dB = \_mm\_shuffle\_pd(dB,dB,0);
00310     iB1 = \_mm\_sub\_pd(\_mm\_mul\_pd(C1, dB), iB1);
00311     iB2 = \_mm\_sub\_pd(\_mm\_mul\_pd(C2, dB), iB2);
00312 
00313     d1 = \_mm\_xor\_pd(rd, \_Sign\_PN);
00314     d2 = \_mm\_xor\_pd(rd, \_Sign\_NP);
00315 
00316     \textcolor{comment}{//  iC = B*|C| - A*C#*D;}
00317     dC = \_mm\_shuffle\_pd(dC,dC,0);
00318     iC1 = \_mm\_sub\_pd(\_mm\_mul\_pd(B1, dC), iC1);
00319     iC2 = \_mm\_sub\_pd(\_mm\_mul\_pd(B2, dC), iC2);
00320 
00321     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} res\_stride = result.outerStride();
00322     \textcolor{keywordtype}{double}* res = result.data();
00323     pstoret<double, Packet2d, ResultAlignment>(res+0,             \_mm\_mul\_pd(\_mm\_shuffle\_pd(iA2, iA1, 3), 
      d1));
00324     pstoret<double, Packet2d, ResultAlignment>(res+res\_stride,    \_mm\_mul\_pd(\_mm\_shuffle\_pd(iA2, iA1, 0), 
      d2));
00325     pstoret<double, Packet2d, ResultAlignment>(res+2,             \_mm\_mul\_pd(\_mm\_shuffle\_pd(iB2, iB1, 3), 
      d1));
00326     pstoret<double, Packet2d, ResultAlignment>(res+res\_stride+2,  \_mm\_mul\_pd(\_mm\_shuffle\_pd(iB2, iB1, 0), 
      d2));
00327     pstoret<double, Packet2d, ResultAlignment>(res+2*res\_stride,  \_mm\_mul\_pd(\_mm\_shuffle\_pd(iC2, iC1, 3), 
      d1));
00328     pstoret<double, Packet2d, ResultAlignment>(res+3*res\_stride,  \_mm\_mul\_pd(\_mm\_shuffle\_pd(iC2, iC1, 0), 
      d2));
00329     pstoret<double, Packet2d, ResultAlignment>(res+2*res\_stride+2,\_mm\_mul\_pd(\_mm\_shuffle\_pd(iD2, iD1, 3), 
      d1));
00330     pstoret<double, Packet2d, ResultAlignment>(res+3*res\_stride+2,\_mm\_mul\_pd(\_mm\_shuffle\_pd(iD2, iD1, 0), 
      d2));
00331   \}
00332 \};
00333 
00334 \} \textcolor{comment}{// end namespace internal}
00335 
00336 \} \textcolor{comment}{// end namespace Eigen}
00337 
00338 \textcolor{preprocessor}{#endif // EIGEN\_INVERSE\_SSE\_H}
\end{DoxyCode}
