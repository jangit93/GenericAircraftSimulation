\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Eigenvalues/\+Self\+Adjoint\+Eigen\+Solver.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source}\index{Self\+Adjoint\+Eigen\+Solver.\+h@{Self\+Adjoint\+Eigen\+Solver.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2010 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_SELFADJOINTEIGENSOLVER\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_SELFADJOINTEIGENSOLVER\_H}
00013 
00014 \textcolor{preprocessor}{#include "./Tridiagonalization.h"}
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00017 
00018 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
00019 \textcolor{keyword}{class }GeneralizedSelfAdjointEigenSolver;
00020 
00021 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SolverType,\textcolor{keywordtype}{int} Size,\textcolor{keywordtype}{bool} IsComplex> \textcolor{keyword}{struct }direct\_selfadjoint\_eigenvalues;
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} DiagType, \textcolor{keyword}{typename} SubDiagType>
00024 \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} computeFromTridiagonal\_impl(DiagType& diag, SubDiagType& subdiag, \textcolor{keyword}{const} 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} maxIterations, \textcolor{keywordtype}{bool} computeEigenvectors, MatrixType& eivec);
00025 \}
00026 
00070 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType> \textcolor{keyword}{class }SelfAdjointEigenSolver
00071 \{
00072   \textcolor{keyword}{public}:
00073 
00074     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00075     \textcolor{keyword}{enum} \{
00076       Size = MatrixType::RowsAtCompileTime,
00077       ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00078       Options = MatrixType::Options,
00079       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
00080     \};
00081     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source_l00083}\hyperlink{group___eigenvalues___module_a0bfcedf4245b6846007ca4f01e4feb1f}{00083}     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar \hyperlink{group___eigenvalues___module_a0bfcedf4245b6846007ca4f01e4feb1f}{Scalar};
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source_l00084}\hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{00084}     \textcolor{keyword}{typedef} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Eigen::Index} \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index}; 
00085     
00086     \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module}{Matrix<Scalar,Size,Size,ColMajor,MaxColsAtCompileTime,MaxColsAtCompileTime>}
       \hyperlink{group___core___module}{EigenvectorsType};
00087 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source_l00094}\hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{00094}     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar};
00095     
00096     \textcolor{keyword}{friend} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1direct__selfadjoint__eigenvalues}{internal::direct\_selfadjoint\_eigenvalues}<
      \hyperlink{group___eigenvalues___module_class_eigen_1_1_self_adjoint_eigen_solver}{SelfAdjointEigenSolver},Size,\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits}<Scalar>::IsComplex>;
00097 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source_l00103}\hyperlink{group___eigenvalues___module_acd090d5fdfc3cc017a13b6d8daa92287}{00103}     typedef typename \hyperlink{struct_eigen_1_1internal_1_1plain__col__type}{internal::plain\_col\_type}<MatrixType, RealScalar>::type 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{RealVectorType};
00104     typedef \hyperlink{group___eigenvalues___module_class_eigen_1_1_tridiagonalization}{Tridiagonalization}<MatrixType> 
      \hyperlink{group___eigenvalues___module_class_eigen_1_1_tridiagonalization}{TridiagonalizationType};
00105     typedef typename \hyperlink{group___core___module_class_eigen_1_1_matrix}{TridiagonalizationType::SubDiagonalType} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{SubDiagonalType};
00106 
00117     EIGEN\_DEVICE\_FUNC
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source_l00118}\hyperlink{group___eigenvalues___module_af3466b3809be4a7738d84493d80d4737}{00118}     \hyperlink{group___eigenvalues___module_class_eigen_1_1_self_adjoint_eigen_solver}{SelfAdjointEigenSolver}()
00119         : m\_eivec(),
00120           m\_eivalues(),
00121           m\_subdiag(),
00122           m\_isInitialized(false)
00123     \{ \}
00124 
00137     EIGEN\_DEVICE\_FUNC
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source_l00138}\hyperlink{group___eigenvalues___module_af20f466a4c29477271e91841e3382b27}{00138}     \textcolor{keyword}{explicit} \hyperlink{group___eigenvalues___module_af20f466a4c29477271e91841e3382b27}{SelfAdjointEigenSolver}(Index size)
00139         : m\_eivec(size, size),
00140           m\_eivalues(size),
00141           m\_subdiag(size > 1 ? size - 1 : 1),
00142           m\_isInitialized(false)
00143     \{\}
00144 
00160     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>
00161     EIGEN\_DEVICE\_FUNC
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source_l00162}\hyperlink{group___eigenvalues___module_ade694ed7b0a4d9da9480cedc849be76f}{00162}     \textcolor{keyword}{explicit} \hyperlink{group___eigenvalues___module_ade694ed7b0a4d9da9480cedc849be76f}{SelfAdjointEigenSolver}(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<InputType>}& matrix, \textcolor{keywordtype}{int} options = 
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors})
00163       : m\_eivec(matrix.rows(), matrix.cols()),
00164         m\_eivalues(matrix.cols()),
00165         m\_subdiag(matrix.rows() > 1 ? matrix.rows() - 1 : 1),
00166         m\_isInitialized(false)
00167     \{
00168       compute(matrix.\hyperlink{group___core___module_a324b16961a11d2ecfd2d1b7dd7946545}{derived}(), options);
00169     \}
00170 
00201     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>
00202     EIGEN\_DEVICE\_FUNC
00203     \hyperlink{group___eigenvalues___module_class_eigen_1_1_self_adjoint_eigen_solver}{SelfAdjointEigenSolver}& compute(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<InputType>}& matrix, \textcolor{keywordtype}{int} options = 
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors});
00204     
00223     EIGEN\_DEVICE\_FUNC
00224     \hyperlink{group___eigenvalues___module_class_eigen_1_1_self_adjoint_eigen_solver}{SelfAdjointEigenSolver}& computeDirect(\textcolor{keyword}{const} MatrixType& matrix, \textcolor{keywordtype}{int} options = 
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors});
00225 
00238     \hyperlink{group___eigenvalues___module_class_eigen_1_1_self_adjoint_eigen_solver}{SelfAdjointEigenSolver}& computeFromTridiagonal(\textcolor{keyword}{const} 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{RealVectorType}& diag, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix}{SubDiagonalType}& subdiag , \textcolor{keywordtype}{int} options=
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors});
00239 
00258     EIGEN\_DEVICE\_FUNC
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source_l00259}\hyperlink{group___eigenvalues___module_a7b9f7e641fa46ac4c5f2371405c69b2b}{00259}     \textcolor{keyword}{const} EigenvectorsType& \hyperlink{group___eigenvalues___module_a7b9f7e641fa46ac4c5f2371405c69b2b}{eigenvectors}()\textcolor{keyword}{ const}
00260 \textcolor{keyword}{    }\{
00261       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"SelfAdjointEigenSolver is not initialized."});
00262       eigen\_assert(m\_eigenvectorsOk && \textcolor{stringliteral}{"The eigenvectors have not been computed together with the
       eigenvalues."});
00263       \textcolor{keywordflow}{return} m\_eivec;
00264     \}
00265 
00281     EIGEN\_DEVICE\_FUNC
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source_l00282}\hyperlink{group___eigenvalues___module_a8efab27e82aa6aa0ae0c64739238c2e0}{00282}     \textcolor{keyword}{const} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{RealVectorType}& \hyperlink{group___eigenvalues___module_a8efab27e82aa6aa0ae0c64739238c2e0}{eigenvalues}()\textcolor{keyword}{ const}
00283 \textcolor{keyword}{    }\{
00284       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"SelfAdjointEigenSolver is not initialized."});
00285       \textcolor{keywordflow}{return} m\_eivalues;
00286     \}
00287 
00305     EIGEN\_DEVICE\_FUNC
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source_l00306}\hyperlink{group___eigenvalues___module_a5c5158fd86366081bdabec38112c2c8a}{00306}     MatrixType \hyperlink{group___eigenvalues___module_a5c5158fd86366081bdabec38112c2c8a}{operatorSqrt}()\textcolor{keyword}{ const}
00307 \textcolor{keyword}{    }\{
00308       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"SelfAdjointEigenSolver is not initialized."});
00309       eigen\_assert(m\_eigenvectorsOk && \textcolor{stringliteral}{"The eigenvectors have not been computed together with the
       eigenvalues."});
00310       \textcolor{keywordflow}{return} m\_eivec * m\_eivalues.cwiseSqrt().asDiagonal() * m\_eivec.adjoint();
00311     \}
00312 
00330     EIGEN\_DEVICE\_FUNC
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source_l00331}\hyperlink{group___eigenvalues___module_a71fe0aea0b22d176efcea556c5c160f5}{00331}     MatrixType \hyperlink{group___eigenvalues___module_a71fe0aea0b22d176efcea556c5c160f5}{operatorInverseSqrt}()\textcolor{keyword}{ const}
00332 \textcolor{keyword}{    }\{
00333       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"SelfAdjointEigenSolver is not initialized."});
00334       eigen\_assert(m\_eigenvectorsOk && \textcolor{stringliteral}{"The eigenvectors have not been computed together with the
       eigenvalues."});
00335       \textcolor{keywordflow}{return} m\_eivec * m\_eivalues.cwiseInverse().cwiseSqrt().asDiagonal() * m\_eivec.adjoint();
00336     \}
00337 
00342     EIGEN\_DEVICE\_FUNC
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_self_adjoint_eigen_solver_8h_source_l00343}\hyperlink{group___eigenvalues___module_a56bd59b85a6f6f00ff7bff307ad0e015}{00343}     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} \hyperlink{group___eigenvalues___module_a56bd59b85a6f6f00ff7bff307ad0e015}{info}()\textcolor{keyword}{ const}
00344 \textcolor{keyword}{    }\{
00345       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"SelfAdjointEigenSolver is not initialized."});
00346       \textcolor{keywordflow}{return} m\_info;
00347     \}
00348 
00354     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} m\_maxIterations = 30;
00355 
00356   \textcolor{keyword}{protected}:
00357     \textcolor{keyword}{static} \textcolor{keywordtype}{void} check\_template\_parameters()
00358     \{
00359       EIGEN\_STATIC\_ASSERT\_NON\_INTEGER(Scalar);
00360     \}
00361     
00362     EigenvectorsType m\_eivec;
00363     \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{RealVectorType} m\_eivalues;
00364     \textcolor{keyword}{typename} \hyperlink{group___core___module_class_eigen_1_1_matrix}{TridiagonalizationType::SubDiagonalType} m\_subdiag;
00365     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} m\_info;
00366     \textcolor{keywordtype}{bool} m\_isInitialized;
00367     \textcolor{keywordtype}{bool} m\_eigenvectorsOk;
00368 \};
00369 
00370 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00391 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StorageOrder,\textcolor{keyword}{typename} RealScalar, \textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index>
00392 EIGEN\_DEVICE\_FUNC
00393 \textcolor{keyword}{static} \textcolor{keywordtype}{void} tridiagonal\_qr\_step(\hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar}* diag, \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar}* subdiag, 
      \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} start, \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} end, \hyperlink{group___eigenvalues___module_a0bfcedf4245b6846007ca4f01e4feb1f}{Scalar}* matrixQ, \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} n);
00394 \}
00395 
00396 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00397 \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>
00398 EIGEN\_DEVICE\_FUNC
00399 \hyperlink{group___eigenvalues___module_class_eigen_1_1_self_adjoint_eigen_solver}{SelfAdjointEigenSolver<MatrixType>}& 
      \hyperlink{group___eigenvalues___module_a88bcdc24112efa7c4d2ebb3476efcbe9}{SelfAdjointEigenSolver<MatrixType>}
00400 \hyperlink{group___eigenvalues___module_a88bcdc24112efa7c4d2ebb3476efcbe9}{::compute}(\textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<InputType>}& a\_matrix, \textcolor{keywordtype}{int} options)
00401 \{
00402   check\_template\_parameters();
00403   
00404   \textcolor{keyword}{const} InputType &matrix(a\_matrix.\hyperlink{group___core___module_a324b16961a11d2ecfd2d1b7dd7946545}{derived}());
00405   
00406   \textcolor{keyword}{using} std::abs;
00407   eigen\_assert(matrix.cols() == matrix.rows());
00408   eigen\_assert((options&~(EigVecMask|GenEigMask))==0
00409           && (options&EigVecMask)!=EigVecMask
00410           && \textcolor{stringliteral}{"invalid option parameter"});
00411   \textcolor{keywordtype}{bool} computeEigenvectors = (options&\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors})==
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors};
00412   \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} n = matrix.cols();
00413   m\_eivalues.resize(n,1);
00414 
00415   \textcolor{keywordflow}{if}(n==1)
00416   \{
00417     m\_eivec = matrix;
00418     m\_eivalues.coeffRef(0,0) = numext::real(m\_eivec.coeff(0,0));
00419     \textcolor{keywordflow}{if}(computeEigenvectors)
00420       m\_eivec.setOnes(n,n);
00421     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00422     m\_isInitialized = \textcolor{keyword}{true};
00423     m\_eigenvectorsOk = computeEigenvectors;
00424     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00425   \}
00426 
00427   \textcolor{comment}{// declare some aliases}
00428   \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{RealVectorType}& diag = m\_eivalues;
00429   \hyperlink{group___core___module}{EigenvectorsType}& mat = m\_eivec;
00430 
00431   \textcolor{comment}{// map the matrix coefficients to [-1:1] to avoid over- and underflow.}
00432   mat = matrix.template triangularView<Lower>();
00433   \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar} scale = mat.cwiseAbs().maxCoeff();
00434   \textcolor{keywordflow}{if}(scale==\hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar}(0)) scale = \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar}(1);
00435   mat.template triangularView<Lower>() /= scale;
00436   m\_subdiag.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(n-1);
00437   internal::tridiagonalization\_inplace(mat, diag, m\_subdiag, computeEigenvectors);
00438 
00439   m\_info = internal::computeFromTridiagonal\_impl(diag, m\_subdiag, m\_maxIterations, computeEigenvectors, 
      m\_eivec);
00440   
00441   \textcolor{comment}{// scale back the eigen values}
00442   m\_eivalues *= scale;
00443 
00444   m\_isInitialized = \textcolor{keyword}{true};
00445   m\_eigenvectorsOk = computeEigenvectors;
00446   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00447 \}
00448 
00449 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00450 \hyperlink{group___eigenvalues___module_class_eigen_1_1_self_adjoint_eigen_solver}{SelfAdjointEigenSolver<MatrixType>}& 
      \hyperlink{group___eigenvalues___module_a297893df7098c43278d385e4d4e23fe4}{SelfAdjointEigenSolver<MatrixType>}
00451 \hyperlink{group___eigenvalues___module_a297893df7098c43278d385e4d4e23fe4}{::computeFromTridiagonal}(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{RealVectorType}& diag, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{SubDiagonalType}& subdiag , \textcolor{keywordtype}{int} options)
00452 \{
00453   \textcolor{comment}{//TODO : Add an option to scale the values beforehand}
00454   \textcolor{keywordtype}{bool} computeEigenvectors = (options&\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors})==
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors};
00455 
00456   m\_eivalues = diag;
00457   m\_subdiag = subdiag;
00458   \textcolor{keywordflow}{if} (computeEigenvectors)
00459   \{
00460     m\_eivec.setIdentity(diag.size(), diag.size());
00461   \}
00462   m\_info = internal::computeFromTridiagonal\_impl(m\_eivalues, m\_subdiag, m\_maxIterations, 
      computeEigenvectors, m\_eivec);
00463 
00464   m\_isInitialized = \textcolor{keyword}{true};
00465   m\_eigenvectorsOk = computeEigenvectors;
00466   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00467 \}
00468 
00469 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00481 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} DiagType, \textcolor{keyword}{typename} SubDiagType>
00482 \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} computeFromTridiagonal\_impl(DiagType& diag, SubDiagType& subdiag, \textcolor{keyword}{const} 
      \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} maxIterations, \textcolor{keywordtype}{bool} computeEigenvectors, MatrixType& eivec)
00483 \{
00484   \textcolor{keyword}{using} std::abs;
00485 
00486   \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} info;
00487   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar \hyperlink{group___eigenvalues___module_a0bfcedf4245b6846007ca4f01e4feb1f}{Scalar};
00488 
00489   \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} n = diag.size();
00490   \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} end = n-1;
00491   \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} start = 0;
00492   \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} iter = 0; \textcolor{comment}{// total number of iterations}
00493   
00494   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DiagType::RealScalar \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar};
00495   \textcolor{keyword}{const} RealScalar considerAsZero = (std::numeric\_limits<RealScalar>::min)();
00496   \textcolor{keyword}{const} RealScalar precision = RealScalar(2)*\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::epsilon}()
      ;
00497   
00498   \textcolor{keywordflow}{while} (end>0)
00499   \{
00500     \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} i = start; i<end; ++i)
00501       \textcolor{keywordflow}{if} (internal::isMuchSmallerThan(abs(subdiag[i]),(abs(diag[i])+abs(diag[i+1])),precision) || abs(
      subdiag[i]) <= considerAsZero)
00502         subdiag[i] = 0;
00503 
00504     \textcolor{comment}{// find the largest unreduced block}
00505     \textcolor{keywordflow}{while} (end>0 && subdiag[end-1]==RealScalar(0))
00506     \{
00507       end--;
00508     \}
00509     \textcolor{keywordflow}{if} (end<=0)
00510       \textcolor{keywordflow}{break};
00511 
00512     \textcolor{comment}{// if we spent too many iterations, we give up}
00513     iter++;
00514     \textcolor{keywordflow}{if}(iter > maxIterations * n) \textcolor{keywordflow}{break};
00515 
00516     start = end - 1;
00517     \textcolor{keywordflow}{while} (start>0 && subdiag[start-1]!=0)
00518       start--;
00519 
00520     internal::tridiagonal\_qr\_step<MatrixType::Flags&RowMajorBit ? RowMajor : ColMajor>(diag.data(), subdiag
      .data(), start, end, computeEigenvectors ? eivec.data() : (Scalar*)0, n);
00521   \}
00522   \textcolor{keywordflow}{if} (iter <= maxIterations * n)
00523     info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00524   \textcolor{keywordflow}{else}
00525     info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence};
00526 
00527   \textcolor{comment}{// Sort eigenvalues and corresponding vectors.}
00528   \textcolor{comment}{// TODO make the sort optional ?}
00529   \textcolor{comment}{// TODO use a better sort algorithm !!}
00530   \textcolor{keywordflow}{if} (info == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success})
00531   \{
00532     \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} i = 0; i < n-1; ++i)
00533     \{
00534       \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} k;
00535       diag.segment(i,n-i).minCoeff(&k);
00536       \textcolor{keywordflow}{if} (k > 0)
00537       \{
00538         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(diag[i], diag[k+i]);
00539         \textcolor{keywordflow}{if}(computeEigenvectors)
00540           eivec.col(i).swap(eivec.col(k+i));
00541       \}
00542     \}
00543   \}
00544   \textcolor{keywordflow}{return} info;
00545 \}
00546   
00547 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SolverType,\textcolor{keywordtype}{int} Size,\textcolor{keywordtype}{bool} IsComplex> \textcolor{keyword}{struct }direct\_selfadjoint\_eigenvalues
00548 \{
00549   EIGEN\_DEVICE\_FUNC
00550   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(SolverType& eig, \textcolor{keyword}{const} \textcolor{keyword}{typename} SolverType::MatrixType& 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, \textcolor{keywordtype}{int} options)
00551   \{ eig.compute(A,options); \}
00552 \};
00553 
00554 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SolverType> \textcolor{keyword}{struct }direct\_selfadjoint\_eigenvalues<SolverType,3,false>
00555 \{
00556   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SolverType::MatrixType MatrixType;
00557   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SolverType::RealVectorType \hyperlink{struct_vector_type}{VectorType};
00558   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SolverType::Scalar \hyperlink{group___eigenvalues___module_a0bfcedf4245b6846007ca4f01e4feb1f}{Scalar};
00559   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SolverType::EigenvectorsType \hyperlink{group___core___module}{EigenvectorsType};
00560   
00561 
00566   EIGEN\_DEVICE\_FUNC
00567   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} computeRoots(\textcolor{keyword}{const} MatrixType& m, VectorType& roots)
00568   \{
00569     EIGEN\_USING\_STD\_MATH(sqrt)
00570     EIGEN\_USING\_STD\_MATH(atan2)
00571     EIGEN\_USING\_STD\_MATH(cos)
00572     EIGEN\_USING\_STD\_MATH(sin)
00573     \textcolor{keyword}{const} Scalar s\_inv3 = Scalar(1)/Scalar(3);
00574     \textcolor{keyword}{const} Scalar s\_sqrt3 = sqrt(Scalar(3));
00575 
00576     \textcolor{comment}{// The characteristic equation is x^3 - c2*x^2 + c1*x - c0 = 0.  The}
00577     \textcolor{comment}{// eigenvalues are the roots to this equation, all guaranteed to be}
00578     \textcolor{comment}{// real-valued, because the matrix is symmetric.}
00579     Scalar c0 = m(0,0)*m(1,1)*m(2,2) + Scalar(2)*m(1,0)*m(2,0)*m(2,1) - m(0,0)*m(2,1)*m(2,1) - m(1,1)*m(2,0
      )*m(2,0) - m(2,2)*m(1,0)*m(1,0);
00580     Scalar c1 = m(0,0)*m(1,1) - m(1,0)*m(1,0) + m(0,0)*m(2,2) - m(2,0)*m(2,0) + m(1,1)*m(2,2) - m(2,1)*m(2,
      1);
00581     Scalar c2 = m(0,0) + m(1,1) + m(2,2);
00582 
00583     \textcolor{comment}{// Construct the parameters used in classifying the roots of the equation}
00584     \textcolor{comment}{// and in solving the equation for the roots in closed form.}
00585     Scalar c2\_over\_3 = c2*s\_inv3;
00586     Scalar a\_over\_3 = (c2*c2\_over\_3 - c1)*s\_inv3;
00587     a\_over\_3 = numext::maxi(a\_over\_3, Scalar(0));
00588 
00589     Scalar half\_b = Scalar(0.5)*(c0 + c2\_over\_3*(Scalar(2)*c2\_over\_3*c2\_over\_3 - c1));
00590 
00591     Scalar q = a\_over\_3*a\_over\_3*a\_over\_3 - half\_b*half\_b;
00592     q = numext::maxi(q, Scalar(0));
00593 
00594     \textcolor{comment}{// Compute the eigenvalues by solving for the roots of the polynomial.}
00595     Scalar rho = sqrt(a\_over\_3);
00596     Scalar theta = atan2(sqrt(q),half\_b)*s\_inv3;  \textcolor{comment}{// since sqrt(q) > 0, atan2 is in [0, pi] and theta is in
       [0, pi/3]}
00597     Scalar cos\_theta = cos(theta);
00598     Scalar sin\_theta = sin(theta);
00599     \textcolor{comment}{// roots are already sorted, since cos is monotonically decreasing on [0, pi]}
00600     roots(0) = c2\_over\_3 - rho*(cos\_theta + s\_sqrt3*sin\_theta); \textcolor{comment}{// == 2*rho*cos(theta+2pi/3)}
00601     roots(1) = c2\_over\_3 - rho*(cos\_theta - s\_sqrt3*sin\_theta); \textcolor{comment}{// == 2*rho*cos(theta+ pi/3)}
00602     roots(2) = c2\_over\_3 + Scalar(2)*rho*cos\_theta;
00603   \}
00604 
00605   EIGEN\_DEVICE\_FUNC
00606   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} extract\_kernel(MatrixType& mat, \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<VectorType>} res, 
      \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<VectorType>} representative)
00607   \{
00608     \textcolor{keyword}{using} std::abs;
00609     \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} i0;
00610     \textcolor{comment}{// Find non-zero column i0 (by construction, there must exist a non zero coefficient on the diagonal):}
00611     mat.diagonal().cwiseAbs().maxCoeff(&i0);
00612     \textcolor{comment}{// mat.col(i0) is a good candidate for an orthogonal vector to the current eigenvector,}
00613     \textcolor{comment}{// so let's save it:}
00614     representative = mat.col(i0);
00615     Scalar n0, n1;
00616     VectorType c0, c1;
00617     n0 = (c0 = representative.cross(mat.col((i0+1)%3))).squaredNorm();
00618     n1 = (c1 = representative.cross(mat.col((i0+2)%3))).squaredNorm();
00619     \textcolor{keywordflow}{if}(n0>n1) res = c0/std::sqrt(n0);
00620     \textcolor{keywordflow}{else}      res = c1/std::sqrt(n1);
00621 
00622     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00623   \}
00624 
00625   EIGEN\_DEVICE\_FUNC
00626   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(SolverType& solver, \textcolor{keyword}{const} MatrixType& mat, \textcolor{keywordtype}{int} options)
00627   \{
00628     eigen\_assert(mat.cols() == 3 && mat.cols() == mat.rows());
00629     eigen\_assert((options&~(EigVecMask|GenEigMask))==0
00630             && (options&EigVecMask)!=EigVecMask
00631             && \textcolor{stringliteral}{"invalid option parameter"});
00632     \textcolor{keywordtype}{bool} computeEigenvectors = (options&\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors})==
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors};
00633     
00634     EigenvectorsType& eivecs = solver.m\_eivec;
00635     VectorType& eivals = solver.m\_eivalues;
00636   
00637     \textcolor{comment}{// Shift the matrix to the mean eigenvalue and map the matrix coefficients to [-1:1] to avoid over- and
       underflow.}
00638     Scalar shift = mat.trace() / Scalar(3);
00639     \textcolor{comment}{// TODO Avoid this copy. Currently it is necessary to suppress bogus values when determining maxCoeff
       and for computing the eigenvectors later}
00640     MatrixType scaledMat = mat.template selfadjointView<Lower>();
00641     scaledMat.diagonal().array() -= shift;
00642     Scalar scale = scaledMat.cwiseAbs().maxCoeff();
00643     \textcolor{keywordflow}{if}(scale > 0) scaledMat /= scale;   \textcolor{comment}{// TODO for scale==0 we could save the remaining operations}
00644 
00645     \textcolor{comment}{// compute the eigenvalues}
00646     computeRoots(scaledMat,eivals);
00647 
00648     \textcolor{comment}{// compute the eigenvectors}
00649     \textcolor{keywordflow}{if}(computeEigenvectors)
00650     \{
00651       \textcolor{keywordflow}{if}((eivals(2)-eivals(0))<=\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{Eigen::NumTraits<Scalar>::epsilon}())
00652       \{
00653         \textcolor{comment}{// All three eigenvalues are numerically the same}
00654         eivecs.setIdentity();
00655       \}
00656       \textcolor{keywordflow}{else}
00657       \{
00658         MatrixType tmp;
00659         tmp = scaledMat;
00660 
00661         \textcolor{comment}{// Compute the eigenvector of the most distinct eigenvalue}
00662         Scalar d0 = eivals(2) - eivals(1);
00663         Scalar d1 = eivals(1) - eivals(0);
00664         \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} k(0), l(2);
00665         \textcolor{keywordflow}{if}(d0 > d1)
00666         \{
00667           \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{numext::swap}(k,l);
00668           d0 = d1;
00669         \}
00670 
00671         \textcolor{comment}{// Compute the eigenvector of index k}
00672         \{
00673           tmp.diagonal().array () -= eivals(k);
00674           \textcolor{comment}{// By construction, 'tmp' is of rank 2, and its kernel corresponds to the respective eigenvector.}
00675           extract\_kernel(tmp, eivecs.col(k), eivecs.col(l));
00676         \}
00677 
00678         \textcolor{comment}{// Compute eigenvector of index l}
00679         \textcolor{keywordflow}{if}(d0<=2*\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{Eigen::NumTraits<Scalar>::epsilon}()*d1)
00680         \{
00681           \textcolor{comment}{// If d0 is too small, then the two other eigenvalues are numerically the same,}
00682           \textcolor{comment}{// and thus we only have to ortho-normalize the near orthogonal vector we saved above.}
00683           eivecs.col(l) -= eivecs.col(k).dot(eivecs.col(l))*eivecs.col(l);
00684           eivecs.col(l).normalize();
00685         \}
00686         \textcolor{keywordflow}{else}
00687         \{
00688           tmp = scaledMat;
00689           tmp.diagonal().array () -= eivals(l);
00690 
00691           VectorType dummy;
00692           extract\_kernel(tmp, eivecs.col(l), dummy);
00693         \}
00694 
00695         \textcolor{comment}{// Compute last eigenvector from the other two}
00696         eivecs.col(1) = eivecs.col(2).cross(eivecs.col(0)).normalized();
00697       \}
00698     \}
00699 
00700     \textcolor{comment}{// Rescale back to the original size.}
00701     eivals *= scale;
00702     eivals.array() += shift;
00703     
00704     solver.m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00705     solver.m\_isInitialized = \textcolor{keyword}{true};
00706     solver.m\_eigenvectorsOk = computeEigenvectors;
00707   \}
00708 \};
00709 
00710 \textcolor{comment}{// 2x2 direct eigenvalues decomposition, code from Hauke Heibel}
00711 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SolverType> 
00712 \textcolor{keyword}{struct }direct\_selfadjoint\_eigenvalues<SolverType,2,false>
00713 \{
00714   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SolverType::MatrixType MatrixType;
00715   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SolverType::RealVectorType \hyperlink{struct_vector_type}{VectorType};
00716   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SolverType::Scalar \hyperlink{group___eigenvalues___module_a0bfcedf4245b6846007ca4f01e4feb1f}{Scalar};
00717   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SolverType::EigenvectorsType \hyperlink{group___core___module}{EigenvectorsType};
00718   
00719   EIGEN\_DEVICE\_FUNC
00720   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} computeRoots(\textcolor{keyword}{const} MatrixType& m, VectorType& roots)
00721   \{
00722     \textcolor{keyword}{using} std::sqrt;
00723     \textcolor{keyword}{const} Scalar t0 = Scalar(0.5) * sqrt( numext::abs2(m(0,0)-m(1,1)) + Scalar(4)*numext::abs2(m(1,0)));
00724     \textcolor{keyword}{const} Scalar t1 = Scalar(0.5) * (m(0,0) + m(1,1));
00725     roots(0) = t1 - t0;
00726     roots(1) = t1 + t0;
00727   \}
00728   
00729   EIGEN\_DEVICE\_FUNC
00730   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(SolverType& solver, \textcolor{keyword}{const} MatrixType& mat, \textcolor{keywordtype}{int} options)
00731   \{
00732     EIGEN\_USING\_STD\_MATH(sqrt);
00733     EIGEN\_USING\_STD\_MATH(abs);
00734     
00735     eigen\_assert(mat.cols() == 2 && mat.cols() == mat.rows());
00736     eigen\_assert((options&~(EigVecMask|GenEigMask))==0
00737             && (options&EigVecMask)!=EigVecMask
00738             && \textcolor{stringliteral}{"invalid option parameter"});
00739     \textcolor{keywordtype}{bool} computeEigenvectors = (options&\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors})==
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors};
00740     
00741     EigenvectorsType& eivecs = solver.m\_eivec;
00742     VectorType& eivals = solver.m\_eivalues;
00743   
00744     \textcolor{comment}{// Shift the matrix to the mean eigenvalue and map the matrix coefficients to [-1:1] to avoid over- and
       underflow.}
00745     Scalar shift = mat.trace() / Scalar(2);
00746     MatrixType scaledMat = mat;
00747     scaledMat.coeffRef(0,1) = mat.coeff(1,0);
00748     scaledMat.diagonal().array() -= shift;
00749     Scalar scale = scaledMat.cwiseAbs().maxCoeff();
00750     \textcolor{keywordflow}{if}(scale > Scalar(0))
00751       scaledMat /= scale;
00752 
00753     \textcolor{comment}{// Compute the eigenvalues}
00754     computeRoots(scaledMat,eivals);
00755 
00756     \textcolor{comment}{// compute the eigen vectors}
00757     \textcolor{keywordflow}{if}(computeEigenvectors)
00758     \{
00759       \textcolor{keywordflow}{if}((eivals(1)-eivals(0))<=abs(eivals(1))*\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{Eigen::NumTraits<Scalar>::epsilon}
      ())
00760       \{
00761         eivecs.setIdentity();
00762       \}
00763       \textcolor{keywordflow}{else}
00764       \{
00765         scaledMat.diagonal().array () -= eivals(1);
00766         Scalar a2 = numext::abs2(scaledMat(0,0));
00767         Scalar c2 = numext::abs2(scaledMat(1,1));
00768         Scalar b2 = numext::abs2(scaledMat(1,0));
00769         \textcolor{keywordflow}{if}(a2>c2)
00770         \{
00771           eivecs.col(1) << -scaledMat(1,0), scaledMat(0,0);
00772           eivecs.col(1) /= sqrt(a2+b2);
00773         \}
00774         \textcolor{keywordflow}{else}
00775         \{
00776           eivecs.col(1) << -scaledMat(1,1), scaledMat(1,0);
00777           eivecs.col(1) /= sqrt(c2+b2);
00778         \}
00779 
00780         eivecs.col(0) << eivecs.col(1).unitOrthogonal();
00781       \}
00782     \}
00783 
00784     \textcolor{comment}{// Rescale back to the original size.}
00785     eivals *= scale;
00786     eivals.array() += shift;
00787 
00788     solver.m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00789     solver.m\_isInitialized = \textcolor{keyword}{true};
00790     solver.m\_eigenvectorsOk = computeEigenvectors;
00791   \}
00792 \};
00793 
00794 \}
00795 
00796 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00797 EIGEN\_DEVICE\_FUNC
00798 \hyperlink{group___eigenvalues___module_class_eigen_1_1_self_adjoint_eigen_solver}{SelfAdjointEigenSolver<MatrixType>}& 
      \hyperlink{group___eigenvalues___module_a40b0a68841d6176b1ab98743cc82bef4}{SelfAdjointEigenSolver<MatrixType>}
00799 \hyperlink{group___eigenvalues___module_a40b0a68841d6176b1ab98743cc82bef4}{::computeDirect}(\textcolor{keyword}{const} MatrixType& matrix, \textcolor{keywordtype}{int} options)
00800 \{
00801   
      \hyperlink{struct_eigen_1_1internal_1_1direct__selfadjoint__eigenvalues}{internal::direct\_selfadjoint\_eigenvalues<SelfAdjointEigenSolver,Size,NumTraits<Scalar>::IsComplex}
      >::run(*\textcolor{keyword}{this},matrix,options);
00802   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00803 \}
00804 
00805 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00806 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StorageOrder,\textcolor{keyword}{typename} RealScalar, \textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index>
00807 EIGEN\_DEVICE\_FUNC
00808 \textcolor{keyword}{static} \textcolor{keywordtype}{void} tridiagonal\_qr\_step(\hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar}* diag, \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar}* subdiag, 
      \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} start, \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} end, \hyperlink{group___eigenvalues___module_a0bfcedf4245b6846007ca4f01e4feb1f}{Scalar}* matrixQ, \hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} n)
00809 \{
00810   \textcolor{keyword}{using} std::abs;
00811   \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar} td = (diag[end-1] - diag[end])*\hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar}(0.5);
00812   \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar} e = subdiag[end-1];
00813   \textcolor{comment}{// Note that thanks to scaling, e^2 or td^2 cannot overflow, however they can still}
00814   \textcolor{comment}{// underflow thus leading to inf/NaN values when using the following commented code:}
00815 \textcolor{comment}{//   RealScalar e2 = numext::abs2(subdiag[end-1]);}
00816 \textcolor{comment}{//   RealScalar mu = diag[end] - e2 / (td + (td>0 ? 1 : -1) * sqrt(td*td + e2));}
00817   \textcolor{comment}{// This explain the following, somewhat more complicated, version:}
00818   \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar} mu = diag[end];
00819   \textcolor{keywordflow}{if}(td==\hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar}(0))
00820     mu -= abs(e);
00821   \textcolor{keywordflow}{else}
00822   \{
00823     \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar} e2 = numext::abs2(subdiag[end-1]);
00824     \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar} h = numext::hypot(td,e);
00825     \textcolor{keywordflow}{if}(e2==\hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar}(0)) mu -= (e / (td + (td>\hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar}(0) ? 
      \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar}(1) : RealScalar(-1)))) * (e / h);
00826     \textcolor{keywordflow}{else}                  mu -= e2 / (td + (td>RealScalar(0) ? h : -h));
00827   \}
00828   
00829   \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar} x = diag[start] - mu;
00830   \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar} z = subdiag[start];
00831   \textcolor{keywordflow}{for} (\hyperlink{group___eigenvalues___module_a8a59ab7734b6eae2754fd78bc7c3a360}{Index} k = start; k < end; ++k)
00832   \{
00833     \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<RealScalar>} rot;
00834     rot.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(x, z);
00835 
00836     \textcolor{comment}{// do T = G' T G}
00837     \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar} sdk = rot.s() * diag[k] + rot.c() * subdiag[k];
00838     \hyperlink{group___eigenvalues___module_a5dae5f422a3c71060e6bd31332bf64fd}{RealScalar} dkp1 = rot.s() * subdiag[k] + rot.c() * diag[k+1];
00839 
00840     diag[k] = rot.c() * (rot.c() * diag[k] - rot.s() * subdiag[k]) - rot.s() * (rot.c() * subdiag[k] - rot.
      s() * diag[k+1]);
00841     diag[k+1] = rot.s() * sdk + rot.c() * dkp1;
00842     subdiag[k] = rot.c() * sdk - rot.s() * dkp1;
00843     
00844 
00845     \textcolor{keywordflow}{if} (k > start)
00846       subdiag[k - 1] = rot.c() * subdiag[k-1] - rot.s() * z;
00847 
00848     x = subdiag[k];
00849 
00850     \textcolor{keywordflow}{if} (k < end - 1)
00851     \{
00852       z = -rot.s() * subdiag[k+1];
00853       subdiag[k + 1] = rot.c() * subdiag[k+1];
00854     \}
00855     
00856     \textcolor{comment}{// apply the givens rotation to the unit matrix Q = Q * G}
00857     \textcolor{keywordflow}{if} (matrixQ)
00858     \{
00859       \textcolor{comment}{// FIXME if StorageOrder == RowMajor this operation is not very efficient}
00860       \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<Scalar,Dynamic,Dynamic,StorageOrder>} > q(
      matrixQ,n,n);
00861       q.applyOnTheRight(k,k+1,rot);
00862     \}
00863   \}
00864 \}
00865 
00866 \} \textcolor{comment}{// end namespace internal}
00867 
00868 \} \textcolor{comment}{// end namespace Eigen}
00869 
00870 \textcolor{preprocessor}{#endif // EIGEN\_SELFADJOINTEIGENSOLVER\_H}
\end{DoxyCode}
