\hypertarget{eigen_2test_2first__aligned_8cpp_source}{}\section{eigen/test/first\+\_\+aligned.cpp}
\label{eigen_2test_2first__aligned_8cpp_source}\index{first\+\_\+aligned.\+cpp@{first\+\_\+aligned.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00013 \textcolor{keywordtype}{void} test\_first\_aligned\_helper(Scalar *\hyperlink{class_eigen_1_1array}{array}, \textcolor{keywordtype}{int} size)
00014 \{
00015   \textcolor{keyword}{const} \textcolor{keywordtype}{int} packet\_size = \textcolor{keyword}{sizeof}(Scalar) * internal::packet\_traits<Scalar>::size;
00016   VERIFY(((\textcolor{keywordtype}{size\_t}(array) + \textcolor{keyword}{sizeof}(Scalar) * internal::first\_default\_aligned(array, size)) % packet\_size) ==
       0);
00017 \}
00018 
00019 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00020 \textcolor{keywordtype}{void} test\_none\_aligned\_helper(Scalar *array, \textcolor{keywordtype}{int} size)
00021 \{
00022   EIGEN\_UNUSED\_VARIABLE(array);
00023   EIGEN\_UNUSED\_VARIABLE(size);
00024   VERIFY(internal::packet\_traits<Scalar>::size == 1 || internal::first\_default\_aligned(array, size) == size
      );
00025 \}
00026 
\Hypertarget{eigen_2test_2first__aligned_8cpp_source_l00027}\hyperlink{structsome__non__vectorizable__type}{00027} \textcolor{keyword}{struct }\hyperlink{structsome__non__vectorizable__type}{some\_non\_vectorizable\_type} \{ \textcolor{keywordtype}{float} x; \};
00028 
00029 \textcolor{keywordtype}{void} test\_first\_aligned()
00030 \{
00031   EIGEN\_ALIGN16 \textcolor{keywordtype}{float} array\_float[100];
00032   test\_first\_aligned\_helper(array\_float, 50);
00033   test\_first\_aligned\_helper(array\_float+1, 50);
00034   test\_first\_aligned\_helper(array\_float+2, 50);
00035   test\_first\_aligned\_helper(array\_float+3, 50);
00036   test\_first\_aligned\_helper(array\_float+4, 50);
00037   test\_first\_aligned\_helper(array\_float+5, 50);
00038   
00039   EIGEN\_ALIGN16 \textcolor{keywordtype}{double} array\_double[100];
00040   test\_first\_aligned\_helper(array\_double, 50);
00041   test\_first\_aligned\_helper(array\_double+1, 50);
00042   test\_first\_aligned\_helper(array\_double+2, 50);
00043   
00044   \textcolor{keywordtype}{double} *array\_double\_plus\_4\_bytes = (\textcolor{keywordtype}{double}*)(internal::UIntPtr(array\_double)+4);
00045   test\_none\_aligned\_helper(array\_double\_plus\_4\_bytes, 50);
00046   test\_none\_aligned\_helper(array\_double\_plus\_4\_bytes+1, 50);
00047   
00048   \hyperlink{structsome__non__vectorizable__type}{some\_non\_vectorizable\_type} array\_nonvec[100];
00049   test\_first\_aligned\_helper(array\_nonvec, 100);
00050   test\_none\_aligned\_helper(array\_nonvec, 100);
00051 \}
\end{DoxyCode}
