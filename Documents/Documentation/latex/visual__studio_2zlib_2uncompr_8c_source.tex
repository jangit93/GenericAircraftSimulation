\hypertarget{visual__studio_2zlib_2uncompr_8c_source}{}\section{visual\+\_\+studio/zlib/uncompr.c}
\label{visual__studio_2zlib_2uncompr_8c_source}\index{uncompr.\+c@{uncompr.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* uncompr.c -- decompress a memory buffer}
00002 \textcolor{comment}{ * Copyright (C) 1995-2003, 2010, 2014, 2016 Jean-loup Gailly, Mark Adler}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ */}
00005 
00006 \textcolor{comment}{/* @(#) $Id$ */}
00007 
00008 \textcolor{preprocessor}{#define ZLIB\_INTERNAL}
00009 \textcolor{preprocessor}{#include "zlib.h"}
00010 
00011 \textcolor{comment}{/* ===========================================================================}
00012 \textcolor{comment}{     Decompresses the source buffer into the destination buffer.  *sourceLen is}
00013 \textcolor{comment}{   the byte length of the source buffer. Upon entry, *destLen is the total size}
00014 \textcolor{comment}{   of the destination buffer, which must be large enough to hold the entire}
00015 \textcolor{comment}{   uncompressed data. (The size of the uncompressed data must have been saved}
00016 \textcolor{comment}{   previously by the compressor and transmitted to the decompressor by some}
00017 \textcolor{comment}{   mechanism outside the scope of this compression library.) Upon exit,}
00018 \textcolor{comment}{   *destLen is the size of the decompressed data and *sourceLen is the number}
00019 \textcolor{comment}{   of source bytes consumed. Upon return, source + *sourceLen points to the}
00020 \textcolor{comment}{   first unused input byte.}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{     uncompress returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough}
00023 \textcolor{comment}{   memory, Z\_BUF\_ERROR if there was not enough room in the output buffer, or}
00024 \textcolor{comment}{   Z\_DATA\_ERROR if the input data was corrupted, including if the input data is}
00025 \textcolor{comment}{   an incomplete zlib stream.}
00026 \textcolor{comment}{*/}
00027 \textcolor{keywordtype}{int} ZEXPORT uncompress2 (dest, destLen, source, sourceLen)
00028     Bytef *dest;
00029     uLongf *destLen;
00030     \textcolor{keyword}{const} Bytef *source;
00031     uLong *sourceLen;
00032 \{
00033     \hyperlink{structz__stream__s}{z\_stream} stream;
00034     \textcolor{keywordtype}{int} err;
00035     \textcolor{keyword}{const} uInt max = (uInt)-1;
00036     uLong len, left;
00037     Byte buf[1];    \textcolor{comment}{/* for detection of incomplete stream when *destLen == 0 */}
00038 
00039     len = *sourceLen;
00040     \textcolor{keywordflow}{if} (*destLen) \{
00041         left = *destLen;
00042         *destLen = 0;
00043     \}
00044     \textcolor{keywordflow}{else} \{
00045         left = 1;
00046         dest = buf;
00047     \}
00048 
00049     stream.next\_in = (z\_const Bytef *)source;
00050     stream.avail\_in = 0;
00051     stream.zalloc = (alloc\_func)0;
00052     stream.zfree = (free\_func)0;
00053     stream.opaque = (voidpf)0;
00054 
00055     err = inflateInit(&stream);
00056     \textcolor{keywordflow}{if} (err != Z\_OK) \textcolor{keywordflow}{return} err;
00057 
00058     stream.next\_out = dest;
00059     stream.avail\_out = 0;
00060 
00061     \textcolor{keywordflow}{do} \{
00062         \textcolor{keywordflow}{if} (stream.avail\_out == 0) \{
00063             stream.avail\_out = left > (uLong)max ? max : (uInt)left;
00064             left -= stream.avail\_out;
00065         \}
00066         \textcolor{keywordflow}{if} (stream.avail\_in == 0) \{
00067             stream.avail\_in = len > (uLong)max ? max : (uInt)len;
00068             len -= stream.avail\_in;
00069         \}
00070         err = inflate(&stream, Z\_NO\_FLUSH);
00071     \} \textcolor{keywordflow}{while} (err == Z\_OK);
00072 
00073     *sourceLen -= len + stream.avail\_in;
00074     \textcolor{keywordflow}{if} (dest != buf)
00075         *destLen = stream.total\_out;
00076     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (stream.total\_out && err == Z\_BUF\_ERROR)
00077         left = 1;
00078 
00079     inflateEnd(&stream);
00080     \textcolor{keywordflow}{return} err == Z\_STREAM\_END ? Z\_OK :
00081            err == Z\_NEED\_DICT ? Z\_DATA\_ERROR  :
00082            err == Z\_BUF\_ERROR && left + stream.avail\_out ? Z\_DATA\_ERROR :
00083            err;
00084 \}
00085 
00086 \textcolor{keywordtype}{int} ZEXPORT uncompress (dest, destLen, source, sourceLen)
00087     Bytef *dest;
00088     uLongf *destLen;
00089     \textcolor{keyword}{const} Bytef *source;
00090     uLong sourceLen;
00091 \{
00092     \textcolor{keywordflow}{return} uncompress2(dest, destLen, source, &sourceLen);
00093 \}
\end{DoxyCode}
