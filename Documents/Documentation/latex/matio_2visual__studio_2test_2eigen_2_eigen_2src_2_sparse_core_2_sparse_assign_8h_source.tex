\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_assign_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+Core/\+Sparse\+Assign.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_assign_8h_source}\index{Sparse\+Assign.\+h@{Sparse\+Assign.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSEASSIGN\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SPARSEASSIGN\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>    
00016 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00017 Derived& SparseMatrixBase<Derived>::operator=(\textcolor{keyword}{const} EigenBase<OtherDerived> &other)
00018 \{
00019   internal::call\_assignment\_no\_alias(derived(), other.derived());
00020   \textcolor{keywordflow}{return} derived();
00021 \}
00022 
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00024 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00025 Derived& SparseMatrixBase<Derived>::operator=(\textcolor{keyword}{const} ReturnByValue<OtherDerived>& other)
00026 \{
00027   \textcolor{comment}{// TODO use the evaluator mechanism}
00028   other.evalTo(derived());
00029   \textcolor{keywordflow}{return} derived();
00030 \}
00031 
00032 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00033 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00034 \textcolor{keyword}{inline} Derived& SparseMatrixBase<Derived>::operator=(\textcolor{keyword}{const} SparseMatrixBase<OtherDerived>& other)
00035 \{
00036   \textcolor{comment}{// by default sparse evaluation do not alias, so we can safely bypass the generic call\_assignment routine}
00037   internal::Assignment<Derived,OtherDerived,internal::assign\_op<Scalar,typename OtherDerived::Scalar> >
00038           ::run(derived(), other.derived(), internal::assign\_op<Scalar,typename OtherDerived::Scalar>());
00039   \textcolor{keywordflow}{return} derived();
00040 \}
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00043 \textcolor{keyword}{inline} Derived& SparseMatrixBase<Derived>::operator=(\textcolor{keyword}{const} Derived& other)
00044 \{
00045   internal::call\_assignment\_no\_alias(derived(), other.derived());
00046   \textcolor{keywordflow}{return} derived();
00047 \}
00048 
00049 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00050 
00051 \textcolor{keyword}{template}<>
00052 \textcolor{keyword}{struct }storage\_kind\_to\_evaluator\_kind<Sparse> \{
00053   \textcolor{keyword}{typedef} IteratorBased Kind;
00054 \};
00055 
00056 \textcolor{keyword}{template}<>
00057 \textcolor{keyword}{struct }storage\_kind\_to\_shape<Sparse> \{
00058   \textcolor{keyword}{typedef} SparseShape Shape;
00059 \};
00060 
00061 \textcolor{keyword}{struct }Sparse2Sparse \{\};
00062 \textcolor{keyword}{struct }Sparse2Dense  \{\};
00063 
00064 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }AssignmentKind<SparseShape, SparseShape>           \{ \textcolor{keyword}{typedef} Sparse2Sparse Kind; \};
00065 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }AssignmentKind<SparseShape, SparseTriangularShape> \{ \textcolor{keyword}{typedef} Sparse2Sparse Kind; \};
00066 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }AssignmentKind<DenseShape,  SparseShape>           \{ \textcolor{keyword}{typedef} Sparse2Dense  Kind; \};
00067 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }AssignmentKind<DenseShape,  SparseTriangularShape> \{ \textcolor{keyword}{typedef} Sparse2Dense  Kind; \};
00068 
00069 
00070 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType>
00071 \textcolor{keywordtype}{void} assign\_sparse\_to\_sparse(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src)
00072 \{
00073   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::Scalar Scalar;
00074   \textcolor{keyword}{typedef} internal::evaluator<DstXprType> DstEvaluatorType;
00075   \textcolor{keyword}{typedef} internal::evaluator<SrcXprType> SrcEvaluatorType;
00076 
00077   SrcEvaluatorType srcEvaluator(src);
00078 
00079   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} transpose = (DstEvaluatorType::Flags & \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) != (SrcEvaluatorType::Flags & 
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit});
00080   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerEvaluationSize = (SrcEvaluatorType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? src.rows() : 
      src.cols();
00081   \textcolor{keywordflow}{if} ((!transpose) && src.isRValue())
00082   \{
00083     \textcolor{comment}{// eval without temporary}
00084     dst.resize(src.rows(), src.cols());
00085     dst.setZero();
00086     dst.reserve((std::max)(src.rows(),src.cols())*2);
00087     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<outerEvaluationSize; ++j)
00088     \{
00089       dst.startVec(j);
00090       \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} SrcEvaluatorType::InnerIterator it(srcEvaluator, j); it; ++it)
00091       \{
00092         Scalar v = it.value();
00093         dst.insertBackByOuterInner(j,it.index()) = v;
00094       \}
00095     \}
00096     dst.finalize();
00097   \}
00098   \textcolor{keywordflow}{else}
00099   \{
00100     \textcolor{comment}{// eval through a temporary}
00101     eigen\_assert(( ((internal::traits<DstXprType>::SupportedAccessPatterns & OuterRandomAccessPattern)==
      OuterRandomAccessPattern) ||
00102               (!((DstEvaluatorType::Flags & RowMajorBit) != (SrcEvaluatorType::Flags & RowMajorBit)))) &&
00103               \textcolor{stringliteral}{"the transpose operation is supposed to be handled in SparseMatrix::operator="});
00104 
00105     \textcolor{keyword}{enum} \{ Flip = (DstEvaluatorType::Flags & \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) != (SrcEvaluatorType::Flags & 
      RowMajorBit) \};
00106 
00107     
00108     DstXprType temp(src.rows(), src.cols());
00109 
00110     temp.reserve((std::max)(src.rows(),src.cols())*2);
00111     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<outerEvaluationSize; ++j)
00112     \{
00113       temp.startVec(j);
00114       \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} SrcEvaluatorType::InnerIterator it(srcEvaluator, j); it; ++it)
00115       \{
00116         Scalar v = it.value();
00117         temp.insertBackByOuterInner(Flip?it.index():j,Flip?j:it.index()) = v;
00118       \}
00119     \}
00120     temp.finalize();
00121 
00122     dst = temp.markAsRValue();
00123   \}
00124 \}
00125 
00126 \textcolor{comment}{// Generic Sparse to Sparse assignment}
00127 \textcolor{keyword}{template}< \textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType, \textcolor{keyword}{typename} Functor>
00128 \textcolor{keyword}{struct }Assignment<DstXprType, SrcXprType, \hyperlink{struct_functor}{Functor}, Sparse2Sparse>
00129 \{
00130   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} internal::assign\_op<typename
       DstXprType::Scalar,typename SrcXprType::Scalar> &\textcolor{comment}{/*func*/})
00131   \{
00132     assign\_sparse\_to\_sparse(dst.derived(), src.derived());
00133   \}
00134 \};
00135 
00136 \textcolor{comment}{// Generic Sparse to Dense assignment}
00137 \textcolor{keyword}{template}< \textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType, \textcolor{keyword}{typename} Functor>
00138 \textcolor{keyword}{struct }Assignment<DstXprType, SrcXprType, \hyperlink{struct_functor}{Functor}, Sparse2Dense>
00139 \{
00140   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} \hyperlink{struct_functor}{Functor} &
      \hyperlink{structfunc}{func})
00141   \{
00142     \textcolor{keywordflow}{if}(internal::is\_same<\hyperlink{struct_functor}{Functor},internal::assign\_op<typename DstXprType::Scalar,typename
       SrcXprType::Scalar> >::value)
00143       dst.setZero();
00144     
00145     internal::evaluator<SrcXprType> srcEval(src);
00146     resize\_if\_allowed(dst, src, func);
00147     internal::evaluator<DstXprType> dstEval(dst);
00148     
00149     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerEvaluationSize = (internal::evaluator<SrcXprType>::Flags&
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? src.rows() : src.cols();
00150     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<outerEvaluationSize; ++j)
00151       \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} internal::evaluator<SrcXprType>::InnerIterator i(srcEval,j); i; ++i)
00152         func.assignCoeff(dstEval.coeffRef(i.row(),i.col()), i.value());
00153   \}
00154 \};
00155 
00156 \textcolor{comment}{// Specialization for "dst = dec.solve(rhs)"}
00157 \textcolor{comment}{// NOTE we need to specialize it for Sparse2Sparse to avoid ambiguous specialization error}
00158 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} DecType, \textcolor{keyword}{typename} RhsType, \textcolor{keyword}{typename} Scalar>
00159 \textcolor{keyword}{struct }Assignment<DstXprType, Solve<DecType,RhsType>, \hyperlink{namespaceinternal}{internal}::assign\_op<Scalar,Scalar>, 
      Sparse2Sparse>
00160 \{
00161   \textcolor{keyword}{typedef} Solve<DecType,RhsType> SrcXprType;
00162   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} internal::assign\_op<Scalar,Scalar> &)
00163   \{
00164     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstRows = src.rows();
00165     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstCols = src.cols();
00166     \textcolor{keywordflow}{if}((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
00167       dst.resize(dstRows, dstCols);
00168 
00169     src.dec().\_solve\_impl(src.rhs(), dst);
00170   \}
00171 \};
00172 
00173 \textcolor{keyword}{struct }Diagonal2Sparse \{\};
00174 
00175 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }AssignmentKind<SparseShape,DiagonalShape> \{ \textcolor{keyword}{typedef} Diagonal2Sparse Kind; \};
00176 
00177 \textcolor{keyword}{template}< \textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType, \textcolor{keyword}{typename} Functor>
00178 \textcolor{keyword}{struct }Assignment<DstXprType, SrcXprType, \hyperlink{struct_functor}{Functor}, Diagonal2Sparse>
00179 \{
00180   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::StorageIndex StorageIndex;
00181   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::Scalar Scalar;
00182   \textcolor{keyword}{typedef} Array<StorageIndex,Dynamic,1> ArrayXI;
00183   \textcolor{keyword}{typedef} Array<Scalar,Dynamic,1> ArrayXS;
00184   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Options>
00185   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(SparseMatrix<Scalar,Options,StorageIndex> &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} 
      internal::assign\_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\textcolor{comment}{/*func*/})
00186   \{
00187     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstRows = src.rows();
00188     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstCols = src.cols();
00189     \textcolor{keywordflow}{if}((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
00190       dst.resize(dstRows, dstCols);
00191 
00192     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = src.diagonal().size();
00193     dst.makeCompressed();
00194     dst.resizeNonZeros(size);
00195     Map<ArrayXI>(dst.innerIndexPtr(), size).setLinSpaced(0,StorageIndex(size)-1);
00196     Map<ArrayXI>(dst.outerIndexPtr(), size+1).setLinSpaced(0,StorageIndex(size));
00197     Map<ArrayXS>(dst.valuePtr(), size) = src.diagonal();
00198   \}
00199   
00200   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstDerived>
00201   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(SparseMatrixBase<DstDerived> &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} 
      internal::assign\_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\textcolor{comment}{/*func*/})
00202   \{
00203     dst.diagonal() = src.diagonal();
00204   \}
00205   
00206   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} internal::add\_assign\_op<typename
       DstXprType::Scalar,typename SrcXprType::Scalar> &\textcolor{comment}{/*func*/})
00207   \{ dst.diagonal() += src.diagonal(); \}
00208   
00209   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} internal::sub\_assign\_op<typename
       DstXprType::Scalar,typename SrcXprType::Scalar> &\textcolor{comment}{/*func*/})
00210   \{ dst.diagonal() -= src.diagonal(); \}
00211 \};
00212 \} \textcolor{comment}{// end namespace internal}
00213 
00214 \} \textcolor{comment}{// end namespace Eigen}
00215 
00216 \textcolor{preprocessor}{#endif // EIGEN\_SPARSEASSIGN\_H}
\end{DoxyCode}
