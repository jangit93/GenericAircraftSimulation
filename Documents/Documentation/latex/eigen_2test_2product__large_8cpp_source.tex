\hypertarget{eigen_2test_2product__large_8cpp_source}{}\section{eigen/test/product\+\_\+large.cpp}
\label{eigen_2test_2product__large_8cpp_source}\index{product\+\_\+large.\+cpp@{product\+\_\+large.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "product.h"}
00011 
00012 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00013 \textcolor{keywordtype}{void} test\_aliasing()
00014 \{
00015   \textcolor{keywordtype}{int} rows = internal::random<int>(1,12);
00016   \textcolor{keywordtype}{int} cols = internal::random<int>(1,12);
00017   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<T,Dynamic,Dynamic>} MatrixType;
00018   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<T,Dynamic,1>} \hyperlink{struct_vector_type}{VectorType};
00019   VectorType x(cols); x.setRandom();
00020   VectorType z(x);
00021   VectorType y(rows); y.setZero();
00022   MatrixType \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}(rows,cols); \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00023   \textcolor{comment}{// CwiseBinaryOp}
00024   VERIFY\_IS\_APPROX(x = y + \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}*x, \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}*z);     \textcolor{comment}{// OK because "y + A*x" is marked as "assume-aliasing"}
00025   x = z;
00026   \textcolor{comment}{// CwiseUnaryOp}
00027   VERIFY\_IS\_APPROX(x = \hyperlink{group___sparse_core___module}{T}(1.)*(\hyperlink{group___core___module_class_eigen_1_1_matrix}{A}*x), \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}*z); \textcolor{comment}{// OK because 1*(A*x) is replaced by (1*A*x) which is a
       Product<> expression}
00028   x = z;
00029   \textcolor{comment}{// VERIFY\_IS\_APPROX(x = y-A*x, -A*z);   // Not OK in 3.3 because x is resized before A*x gets evaluated}
00030   x = z;
00031 \}
00032 
00033 \textcolor{keywordtype}{void} test\_product\_large()
00034 \{
00035   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00036     CALL\_SUBTEST\_1( product(MatrixXf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), internal::random<int>(1,
      EIGEN\_TEST\_MAX\_SIZE))) );
00037     CALL\_SUBTEST\_2( product(MatrixXd(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), internal::random<int>(1,
      EIGEN\_TEST\_MAX\_SIZE))) );
00038     CALL\_SUBTEST\_3( product(MatrixXi(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), internal::random<int>(1,
      EIGEN\_TEST\_MAX\_SIZE))) );
00039     CALL\_SUBTEST\_4( product(MatrixXcf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2), internal::random<int>
      (1,EIGEN\_TEST\_MAX\_SIZE/2))) );
00040     CALL\_SUBTEST\_5( product(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,Dynamic,Dynamic,RowMajor>}(
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00041 
00042     CALL\_SUBTEST\_1( test\_aliasing<float>() );
00043   \}
00044 
00045 \textcolor{preprocessor}{#if defined EIGEN\_TEST\_PART\_6}
00046   \{
00047     \textcolor{comment}{// test a specific issue in DiagonalProduct}
00048     \textcolor{keywordtype}{int} N = 1000000;
00049     VectorXf v = VectorXf::Ones(N);
00050     MatrixXf m = MatrixXf::Ones(N,3);
00051     m = (v+v).asDiagonal() * m;
00052     VERIFY\_IS\_APPROX(m, MatrixXf::Constant(N,3,2));
00053   \}
00054 
00055   \{
00056     \textcolor{comment}{// test deferred resizing in Matrix::operator=}
00057     MatrixXf a = MatrixXf::Random(10,4), b = MatrixXf::Random(4,10), c = a;
00058     VERIFY\_IS\_APPROX((a = a * b), (c * b).eval());
00059   \}
00060 
00061   \{
00062     \textcolor{comment}{// check the functions to setup blocking sizes compile and do not segfault}
00063     \textcolor{comment}{// FIXME check they do what they are supposed to do !!}
00064     std::ptrdiff\_t l1 = internal::random<int>(10000,20000);
00065     std::ptrdiff\_t l2 = internal::random<int>(100000,200000);
00066     std::ptrdiff\_t l3 = internal::random<int>(1000000,2000000);
00067     \hyperlink{namespace_eigen_ae64421554aa0a4bf9258bafe3170102b}{setCpuCacheSizes}(l1,l2,l3);
00068     VERIFY(l1==\hyperlink{namespace_eigen_a2669f89ff38296a38e6d973552eb4e33}{l1CacheSize}());
00069     VERIFY(l2==\hyperlink{namespace_eigen_a2cfc0330ba567d63a496be1cac8427ae}{l2CacheSize}());
00070     std::ptrdiff\_t k1 = internal::random<int>(10,100)*16;
00071     std::ptrdiff\_t m1 = internal::random<int>(10,100)*16;
00072     std::ptrdiff\_t n1 = internal::random<int>(10,100)*16;
00073     \textcolor{comment}{// only makes sure it compiles fine}
00074     internal::computeProductBlockingSizes<float,float,std::ptrdiff\_t>(k1,m1,n1,1);
00075   \}
00076 
00077   \{
00078     \textcolor{comment}{// test regression in row-vector by matrix (bad Map type)}
00079     MatrixXf mat1(10,32); mat1.setRandom();
00080     MatrixXf mat2(32,32); mat2.setRandom();
00081     MatrixXf r1 = mat1.row(2)*mat2.transpose();
00082     VERIFY\_IS\_APPROX(r1, (mat1.row(2)*mat2.transpose()).eval());
00083 
00084     MatrixXf r2 = mat1.row(2)*mat2;
00085     VERIFY\_IS\_APPROX(r2, (mat1.row(2)*mat2).eval());
00086   \}
00087 
00088   \{
00089     Eigen::MatrixXd \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}(10,10), \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, \hyperlink{group___core___module}{C};
00090     \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00091     C = \hyperlink{group___core___module_class_eigen_1_1_matrix}{A};
00092     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<79; ++k)
00093       C = C * \hyperlink{group___core___module_class_eigen_1_1_matrix}{A};
00094     B.noalias() = (((\hyperlink{group___core___module_class_eigen_1_1_matrix}{A}*\hyperlink{group___core___module_class_eigen_1_1_matrix}{A})*(\hyperlink{group___core___module_class_eigen_1_1_matrix}{A}*\hyperlink{group___core___module_class_eigen_1_1_matrix}{A}))*((A*A)*(A*A))*((A*A)*(A*A))*((A*A)*(A*A))*((A*A)*(A*A)) * ((A*A)*(A*A)
      )*((A*A)*(A*A))*((A*A)*(A*A))*((A*A)*(A*A))*((A*A)*(A*A)))
00095                 * (((A*A)*(A*A))*((A*A)*(A*A))*((A*A)*(A*A))*((A*A)*(A*A))*((A*A)*(A*A)) * ((A*A)*(A*A))*((
      A*A)*(A*A))*((A*A)*(A*A))*((A*A)*(A*A))*((A*A)*(A*A)));
00096     VERIFY\_IS\_APPROX(B,C);
00097   \}
00098 \textcolor{preprocessor}{#endif}
00099 
00100   \textcolor{comment}{// Regression test for bug 714:}
00101 \textcolor{preprocessor}{#if defined EIGEN\_HAS\_OPENMP}
00102   omp\_set\_dynamic(1);
00103   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00104     CALL\_SUBTEST\_6( product(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,Dynamic,Dynamic>}(
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00105   \}
00106 \textcolor{preprocessor}{#endif}
00107 \}
\end{DoxyCode}
