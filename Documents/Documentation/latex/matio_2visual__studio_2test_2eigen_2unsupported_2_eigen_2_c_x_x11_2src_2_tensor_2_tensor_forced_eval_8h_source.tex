\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_forced_eval_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Forced\+Eval.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_forced_eval_8h_source}\index{Tensor\+Forced\+Eval.\+h@{Tensor\+Forced\+Eval.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_FORCED\_EVAL\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_FORCED\_EVAL\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00029 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
00030 \textcolor{keyword}{struct }traits<TensorForcedEvalOp<XprType, MakePointer\_> >
00031 \{
00032   \textcolor{comment}{// Type promotion to handle the case where the types of the lhs and the rhs are different.}
00033   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00034   \textcolor{keyword}{typedef} traits<XprType> XprTraits;
00035   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<XprType>::StorageKind StorageKind;
00036   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<XprType>::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00037   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00038   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<Nested>::type \_Nested;
00039   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions;
00040   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00041 
00042   \textcolor{keyword}{enum} \{
00043     Flags = 0
00044   \};
00045   \textcolor{keyword}{template} <\textcolor{keyword}{class} T> \textcolor{keyword}{struct }MakePointer \{
00046     \textcolor{comment}{// Intermediate typedef to workaround MSVC issue.}
00047     \textcolor{keyword}{typedef} MakePointer\_<T> MakePointerT;
00048     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MakePointerT::Type Type;
00049   \};
00050 \};
00051 
00052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
00053 \textcolor{keyword}{struct }eval<TensorForcedEvalOp<XprType, MakePointer\_>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00054 \{
00055   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorForcedEvalOp<XprType, MakePointer\_>& type;
00056 \};
00057 
00058 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
00059 \textcolor{keyword}{struct }nested<TensorForcedEvalOp<XprType, MakePointer\_>, 1, typename eval<TensorForcedEvalOp<XprType, 
      MakePointer\_> >::type>
00060 \{
00061   \textcolor{keyword}{typedef} TensorForcedEvalOp<XprType, MakePointer\_> type;
00062 \};
00063 
00064 \}  \textcolor{comment}{// end namespace internal}
00065 
00066 
00067 
00068 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
00069 \textcolor{keyword}{class }TensorForcedEvalOp : \textcolor{keyword}{public} TensorBase<TensorForcedEvalOp<XprType, MakePointer\_>, ReadOnlyAccessors>
00070 \{
00071   \textcolor{keyword}{public}:
00072   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorForcedEvalOp>::Scalar}
       Scalar;
00073   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00074   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<typename XprType::CoeffReturnType>::type CoeffReturnType;
00075   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorForcedEvalOp>::type}
       Nested;
00076   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorForcedEvalOp>::StorageKind}
       StorageKind;
00077   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorForcedEvalOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00078 
00079   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorForcedEvalOp(\textcolor{keyword}{const} XprType& expr)
00080       : m\_xpr(expr) \{\}
00081 
00082     EIGEN\_DEVICE\_FUNC
00083     \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type&
00084     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00085 
00086   \textcolor{keyword}{protected}:
00087     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00088 \};
00089 
00090 
00091 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
00092 \textcolor{keyword}{struct }TensorEvaluator<const TensorForcedEvalOp<ArgType, MakePointer\_>, Device>
00093 \{
00094   \textcolor{keyword}{typedef} TensorForcedEvalOp<ArgType, MakePointer\_> XprType;
00095   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ArgType::Scalar Scalar;
00096   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} TensorEvaluator<ArgType, Device>::Dimensions Dimensions;
00097   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00098   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00099   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00100   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = internal::unpacket\_traits<PacketReturnType>::size;
00101 
00102   \textcolor{keyword}{enum} \{
00103     IsAligned = \textcolor{keyword}{true},
00104     PacketAccess = (PacketSize > 1),
00105     Layout = TensorEvaluator<ArgType, Device>::Layout,
00106     RawAccess = \textcolor{keyword}{true}
00107   \};
00108 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_forced_eval_8h_source_l00109}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_forced_eval_op_3_01_arg_type_00_01_make_pointer___01_4_00_01_device_01_4_aad4c3dfe2a278cd7c75fa1848153d53e}{00109}   EIGEN\_DEVICE\_FUNC \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_forced_eval_op_3_01_arg_type_00_01_make_pointer___01_4_00_01_device_01_4_aad4c3dfe2a278cd7c75fa1848153d53e}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00111       : m\_impl(op.expression(), device), m\_op(op.expression()), m\_device(device), m\_buffer(NULL)
00112   \{ \}
00113 
00114   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_impl.dimensions(); \}
00115 
00116   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(CoeffReturnType*) \{
00117     \textcolor{keyword}{const} Index numValues =  internal::array\_prod(m\_impl.dimensions());
00118     m\_buffer = (CoeffReturnType*)m\_device.allocate(numValues * \textcolor{keyword}{sizeof}(CoeffReturnType));
00119     \textcolor{comment}{// Should initialize the memory in case we're dealing with non POD types.}
00120     \textcolor{keywordflow}{if} (\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<CoeffReturnType>::RequireInitialization})
       \{
00121       \textcolor{keywordflow}{for} (Index i = 0; i < numValues; ++i) \{
00122         \textcolor{keyword}{new}(m\_buffer+i) CoeffReturnType();
00123       \}
00124     \}
00125     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_eval_to_op}{TensorEvalToOp< const typename internal::remove\_const<ArgType>::type}
       > EvalTo;
00126     EvalTo evalToTmp(m\_buffer, m\_op);
00127     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} PacketAccess = 
      \hyperlink{struct_eigen_1_1internal_1_1_is_vectorizable}{internal::IsVectorizable<Device, const ArgType>::value}
      ;
00128     
      \hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{internal::TensorExecutor<const EvalTo, typename internal::remove\_const<Device>::type}
      , PacketAccess>::run(evalToTmp, m\_device);
00129     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00130   \}
00131   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00132     m\_device.deallocate(m\_buffer);
00133     m\_buffer = NULL;
00134   \}
00135 
00136   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00137 \textcolor{keyword}{  }\{
00138     \textcolor{keywordflow}{return} m\_buffer[index];
00139   \}
00140 
00141   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00142   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00143 \textcolor{keyword}{  }\{
00144     \textcolor{keywordflow}{return} internal::ploadt<PacketReturnType, LoadMode>(m\_buffer + index);
00145   \}
00146 
00147   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost} costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00148     \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(\textcolor{keyword}{sizeof}(CoeffReturnType), 0, 0, vectorized, PacketSize);
00149   \}
00150 
00151   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{typename} MakePointer<Scalar>::Type data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_buffer; \}
00152 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_forced_eval_8h_source_l00154}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_forced_eval_op_3_01_arg_type_00_01_make_pointer___01_4_00_01_device_01_4_ab3202fdd99e83bf2bd678ef11d37341e}{00154}   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>}& \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_forced_eval_op_3_01_arg_type_00_01_make_pointer___01_4_00_01_device_01_4_ab3202fdd99e83bf2bd678ef11d37341e}{impl}() \{ \textcolor{keywordflow}{return} m\_impl; \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_forced_eval_8h_source_l00156}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_forced_eval_op_3_01_arg_type_00_01_make_pointer___01_4_00_01_device_01_4_a8cfc74b439783ec96b54f9a34a101b5f}{00156}   \textcolor{keyword}{const} Device& \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_forced_eval_op_3_01_arg_type_00_01_make_pointer___01_4_00_01_device_01_4_a8cfc74b439783ec96b54f9a34a101b5f}{device}()\textcolor{keyword}{ const}\{\textcolor{keywordflow}{return} m\_device;\}
00157  \textcolor{keyword}{private}:
00158   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} m\_impl;
00159   \textcolor{keyword}{const} ArgType m\_op;
00160   \textcolor{keyword}{const} Device& m\_device;
00161   \textcolor{keyword}{typename} MakePointer<CoeffReturnType>::Type m\_buffer;
00162 \};
00163 
00164 
00165 \} \textcolor{comment}{// end namespace Eigen}
00166 
00167 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_FORCED\_EVAL\_H}
\end{DoxyCode}
