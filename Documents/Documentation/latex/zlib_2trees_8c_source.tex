\hypertarget{zlib_2trees_8c_source}{}\section{zlib/trees.c}
\label{zlib_2trees_8c_source}\index{trees.\+c@{trees.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* trees.c -- output deflated data using Huffman coding}
00002 \textcolor{comment}{ * Copyright (C) 1995-2017 Jean-loup Gailly}
00003 \textcolor{comment}{ * detect\_data\_type() function provided freely by Cosmin Truta, 2006}
00004 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00005 \textcolor{comment}{ */}
00006 
00007 \textcolor{comment}{/*}
00008 \textcolor{comment}{ *  ALGORITHM}
00009 \textcolor{comment}{ *}
00010 \textcolor{comment}{ *      The "deflation" process uses several Huffman trees. The more}
00011 \textcolor{comment}{ *      common source values are represented by shorter bit sequences.}
00012 \textcolor{comment}{ *}
00013 \textcolor{comment}{ *      Each code tree is stored in a compressed form which is itself}
00014 \textcolor{comment}{ * a Huffman encoding of the lengths of all the code strings (in}
00015 \textcolor{comment}{ * ascending order by source values).  The actual code strings are}
00016 \textcolor{comment}{ * reconstructed from the lengths in the inflate process, as described}
00017 \textcolor{comment}{ * in the deflate specification.}
00018 \textcolor{comment}{ *}
00019 \textcolor{comment}{ *  REFERENCES}
00020 \textcolor{comment}{ *}
00021 \textcolor{comment}{ *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".}
00022 \textcolor{comment}{ *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc}
00023 \textcolor{comment}{ *}
00024 \textcolor{comment}{ *      Storer, James A.}
00025 \textcolor{comment}{ *          Data Compression:  Methods and Theory, pp. 49-50.}
00026 \textcolor{comment}{ *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.}
00027 \textcolor{comment}{ *}
00028 \textcolor{comment}{ *      Sedgewick, R.}
00029 \textcolor{comment}{ *          Algorithms, p290.}
00030 \textcolor{comment}{ *          Addison-Wesley, 1983. ISBN 0-201-06672-6.}
00031 \textcolor{comment}{ */}
00032 
00033 \textcolor{comment}{/* @(#) $Id$ */}
00034 
00035 \textcolor{comment}{/* #define GEN\_TREES\_H */}
00036 
00037 \textcolor{preprocessor}{#include "deflate.h"}
00038 
00039 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
00040 \textcolor{preprocessor}{#  include <ctype.h>}
00041 \textcolor{preprocessor}{#endif}
00042 
00043 \textcolor{comment}{/* ===========================================================================}
00044 \textcolor{comment}{ * Constants}
00045 \textcolor{comment}{ */}
00046 
00047 \textcolor{preprocessor}{#define MAX\_BL\_BITS 7}
00048 \textcolor{comment}{/* Bit length codes must not exceed MAX\_BL\_BITS bits */}
00049 
00050 \textcolor{preprocessor}{#define END\_BLOCK 256}
00051 \textcolor{comment}{/* end of block literal code */}
00052 
00053 \textcolor{preprocessor}{#define REP\_3\_6      16}
00054 \textcolor{comment}{/* repeat previous bit length 3-6 times (2 bits of repeat count) */}
00055 
00056 \textcolor{preprocessor}{#define REPZ\_3\_10    17}
00057 \textcolor{comment}{/* repeat a zero length 3-10 times  (3 bits of repeat count) */}
00058 
00059 \textcolor{preprocessor}{#define REPZ\_11\_138  18}
00060 \textcolor{comment}{/* repeat a zero length 11-138 times  (7 bits of repeat count) */}
00061 
00062 local \textcolor{keyword}{const} \textcolor{keywordtype}{int} extra\_lbits[LENGTH\_CODES] \textcolor{comment}{/* extra bits for each length code */}
00063    = \{0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0\};
00064 
00065 local \textcolor{keyword}{const} \textcolor{keywordtype}{int} extra\_dbits[D\_CODES] \textcolor{comment}{/* extra bits for each distance code */}
00066    = \{0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13\};
00067 
00068 local \textcolor{keyword}{const} \textcolor{keywordtype}{int} extra\_blbits[BL\_CODES]\textcolor{comment}{/* extra bits for each bit length code */}
00069    = \{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7\};
00070 
00071 local \textcolor{keyword}{const} uch bl\_order[BL\_CODES]
00072    = \{16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15\};
00073 \textcolor{comment}{/* The lengths of the bit length codes are sent in order of decreasing}
00074 \textcolor{comment}{ * probability, to avoid transmitting the lengths for unused bit length codes.}
00075 \textcolor{comment}{ */}
00076 
00077 \textcolor{comment}{/* ===========================================================================}
00078 \textcolor{comment}{ * Local data. These are initialized only once.}
00079 \textcolor{comment}{ */}
00080 
00081 \textcolor{preprocessor}{#define DIST\_CODE\_LEN  512 }\textcolor{comment}{/* see definition of array dist\_code below */}\textcolor{preprocessor}{}
00082 
00083 \textcolor{preprocessor}{#if defined(GEN\_TREES\_H) || !defined(STDC)}
00084 \textcolor{comment}{/* non ANSI compilers may not accept trees.h */}
00085 
00086 local \hyperlink{structct__data__s}{ct\_data} static\_ltree[L\_CODES+2];
00087 \textcolor{comment}{/* The static literal tree. Since the bit lengths are imposed, there is no}
00088 \textcolor{comment}{ * need for the L\_CODES extra codes used during heap construction. However}
00089 \textcolor{comment}{ * The codes 286 and 287 are needed to build a canonical tree (see \_tr\_init}
00090 \textcolor{comment}{ * below).}
00091 \textcolor{comment}{ */}
00092 
00093 local \hyperlink{structct__data__s}{ct\_data} static\_dtree[D\_CODES];
00094 \textcolor{comment}{/* The static distance tree. (Actually a trivial tree since all codes use}
00095 \textcolor{comment}{ * 5 bits.)}
00096 \textcolor{comment}{ */}
00097 
00098 uch \_dist\_code[DIST\_CODE\_LEN];
00099 \textcolor{comment}{/* Distance codes. The first 256 values correspond to the distances}
00100 \textcolor{comment}{ * 3 .. 258, the last 256 values correspond to the top 8 bits of}
00101 \textcolor{comment}{ * the 15 bit distances.}
00102 \textcolor{comment}{ */}
00103 
00104 uch \_length\_code[MAX\_MATCH-MIN\_MATCH+1];
00105 \textcolor{comment}{/* length code for each normalized match length (0 == MIN\_MATCH) */}
00106 
00107 local \textcolor{keywordtype}{int} base\_length[LENGTH\_CODES];
00108 \textcolor{comment}{/* First normalized length for each code (0 = MIN\_MATCH) */}
00109 
00110 local \textcolor{keywordtype}{int} base\_dist[D\_CODES];
00111 \textcolor{comment}{/* First normalized distance for each code (0 = distance of 1) */}
00112 
00113 \textcolor{preprocessor}{#else}
00114 \textcolor{preprocessor}{#  include "trees.h"}
00115 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* GEN\_TREES\_H */}\textcolor{preprocessor}{}
00116 
00117 \textcolor{keyword}{struct }\hyperlink{structstatic__tree__desc__s}{static\_tree\_desc\_s} \{
00118     \textcolor{keyword}{const} \hyperlink{structct__data__s}{ct\_data} *static\_tree;  \textcolor{comment}{/* static tree or NULL */}
00119     \textcolor{keyword}{const} intf *extra\_bits;      \textcolor{comment}{/* extra bits for each code or NULL */}
00120     \textcolor{keywordtype}{int}     extra\_base;          \textcolor{comment}{/* base index for extra\_bits */}
00121     \textcolor{keywordtype}{int}     elems;               \textcolor{comment}{/* max number of elements in the tree */}
00122     \textcolor{keywordtype}{int}     max\_length;          \textcolor{comment}{/* max bit length for the codes */}
00123 \};
00124 
00125 local \textcolor{keyword}{const} \hyperlink{structstatic__tree__desc__s}{static\_tree\_desc}  static\_l\_desc =
00126 \{static\_ltree, extra\_lbits, LITERALS+1, L\_CODES, MAX\_BITS\};
00127 
00128 local \textcolor{keyword}{const} \hyperlink{structstatic__tree__desc__s}{static\_tree\_desc}  static\_d\_desc =
00129 \{static\_dtree, extra\_dbits, 0,          D\_CODES, MAX\_BITS\};
00130 
00131 local \textcolor{keyword}{const} \hyperlink{structstatic__tree__desc__s}{static\_tree\_desc}  static\_bl\_desc =
00132 \{(\textcolor{keyword}{const} \hyperlink{structct__data__s}{ct\_data} *)0, extra\_blbits, 0,   BL\_CODES, MAX\_BL\_BITS\};
00133 
00134 \textcolor{comment}{/* ===========================================================================}
00135 \textcolor{comment}{ * Local (static) routines in this file.}
00136 \textcolor{comment}{ */}
00137 
00138 local \textcolor{keywordtype}{void} tr\_static\_init OF((\textcolor{keywordtype}{void}));
00139 local \textcolor{keywordtype}{void} init\_block     OF((\hyperlink{structinternal__state}{deflate\_state} *s));
00140 local \textcolor{keywordtype}{void} pqdownheap     OF((\hyperlink{structinternal__state}{deflate\_state} *s, \hyperlink{structct__data__s}{ct\_data} *tree, \textcolor{keywordtype}{int} k));
00141 local \textcolor{keywordtype}{void} gen\_bitlen     OF((\hyperlink{structinternal__state}{deflate\_state} *s, \hyperlink{structtree__desc__s}{tree\_desc} *desc));
00142 local \textcolor{keywordtype}{void} gen\_codes      OF((\hyperlink{structct__data__s}{ct\_data} *tree, \textcolor{keywordtype}{int} max\_code, ushf *bl\_count));
00143 local \textcolor{keywordtype}{void} build\_tree     OF((\hyperlink{structinternal__state}{deflate\_state} *s, \hyperlink{structtree__desc__s}{tree\_desc} *desc));
00144 local \textcolor{keywordtype}{void} scan\_tree      OF((\hyperlink{structinternal__state}{deflate\_state} *s, \hyperlink{structct__data__s}{ct\_data} *tree, \textcolor{keywordtype}{int} max\_code));
00145 local \textcolor{keywordtype}{void} send\_tree      OF((\hyperlink{structinternal__state}{deflate\_state} *s, \hyperlink{structct__data__s}{ct\_data} *tree, \textcolor{keywordtype}{int} max\_code));
00146 local \textcolor{keywordtype}{int}  build\_bl\_tree  OF((\hyperlink{structinternal__state}{deflate\_state} *s));
00147 local \textcolor{keywordtype}{void} send\_all\_trees OF((\hyperlink{structinternal__state}{deflate\_state} *s, \textcolor{keywordtype}{int} lcodes, \textcolor{keywordtype}{int} dcodes,
00148                               \textcolor{keywordtype}{int} blcodes));
00149 local \textcolor{keywordtype}{void} compress\_block OF((\hyperlink{structinternal__state}{deflate\_state} *s, \textcolor{keyword}{const} \hyperlink{structct__data__s}{ct\_data} *ltree,
00150                               \textcolor{keyword}{const} \hyperlink{structct__data__s}{ct\_data} *dtree));
00151 local \textcolor{keywordtype}{int}  detect\_data\_type OF((\hyperlink{structinternal__state}{deflate\_state} *s));
00152 local \textcolor{keywordtype}{unsigned} bi\_reverse OF((\textcolor{keywordtype}{unsigned} value, \textcolor{keywordtype}{int} length));
00153 local \textcolor{keywordtype}{void} bi\_windup      OF((\hyperlink{structinternal__state}{deflate\_state} *s));
00154 local \textcolor{keywordtype}{void} bi\_flush       OF((\hyperlink{structinternal__state}{deflate\_state} *s));
00155 
00156 \textcolor{preprocessor}{#ifdef GEN\_TREES\_H}
00157 local \textcolor{keywordtype}{void} gen\_trees\_header OF((\textcolor{keywordtype}{void}));
00158 \textcolor{preprocessor}{#endif}
00159 
00160 \textcolor{preprocessor}{#ifndef ZLIB\_DEBUG}
00161 \textcolor{preprocessor}{#  define send\_code(s, c, tree) send\_bits(s, tree[c].Code, tree[c].Len)}
00162    \textcolor{comment}{/* Send a code of the given tree. c and tree must not have side effects */}
00163 
00164 \textcolor{preprocessor}{#else }\textcolor{comment}{/* !ZLIB\_DEBUG */}\textcolor{preprocessor}{}
00165 \textcolor{preprocessor}{#  define send\_code(s, c, tree) \(\backslash\)}
00166 \textcolor{preprocessor}{     \{ if (z\_verbose>2) fprintf(stderr,"\(\backslash\)ncd %3d ",(c)); \(\backslash\)}
00167 \textcolor{preprocessor}{       send\_bits(s, tree[c].Code, tree[c].Len); \}}
00168 \textcolor{preprocessor}{#endif}
00169 
00170 \textcolor{comment}{/* ===========================================================================}
00171 \textcolor{comment}{ * Output a short LSB first on the stream.}
00172 \textcolor{comment}{ * IN assertion: there is enough room in pendingBuf.}
00173 \textcolor{comment}{ */}
00174 \textcolor{preprocessor}{#define put\_short(s, w) \{ \(\backslash\)}
00175 \textcolor{preprocessor}{    put\_byte(s, (uch)((w) & 0xff)); \(\backslash\)}
00176 \textcolor{preprocessor}{    put\_byte(s, (uch)((ush)(w) >> 8)); \(\backslash\)}
00177 \textcolor{preprocessor}{\}}
00178 
00179 \textcolor{comment}{/* ===========================================================================}
00180 \textcolor{comment}{ * Send a value on a given number of bits.}
00181 \textcolor{comment}{ * IN assertion: length <= 16 and value fits in length bits.}
00182 \textcolor{comment}{ */}
00183 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
00184 local \textcolor{keywordtype}{void} send\_bits      OF((\hyperlink{structinternal__state}{deflate\_state} *s, \textcolor{keywordtype}{int} value, \textcolor{keywordtype}{int} length));
00185 
00186 local \textcolor{keywordtype}{void} send\_bits(s, value, length)
00187     \hyperlink{structinternal__state}{deflate\_state} *s;
00188     \textcolor{keywordtype}{int} value;  \textcolor{comment}{/* value to send */}
00189     \textcolor{keywordtype}{int} length; \textcolor{comment}{/* number of bits */}
00190 \{
00191     Tracevv((stderr,\textcolor{stringliteral}{" l %2d v %4x "}, length, value));
00192     Assert(length > 0 && length <= 15, \textcolor{stringliteral}{"invalid length"});
00193     s->bits\_sent += (ulg)length;
00194 
00195     \textcolor{comment}{/* If not enough room in bi\_buf, use (valid) bits from bi\_buf and}
00196 \textcolor{comment}{     * (16 - bi\_valid) bits from value, leaving (width - (16-bi\_valid))}
00197 \textcolor{comment}{     * unused bits in value.}
00198 \textcolor{comment}{     */}
00199     \textcolor{keywordflow}{if} (s->bi\_valid > (\textcolor{keywordtype}{int})Buf\_size - length) \{
00200         s->bi\_buf |= (ush)value << s->bi\_valid;
00201         put\_short(s, s->bi\_buf);
00202         s->bi\_buf = (ush)value >> (Buf\_size - s->bi\_valid);
00203         s->bi\_valid += length - Buf\_size;
00204     \} \textcolor{keywordflow}{else} \{
00205         s->bi\_buf |= (ush)value << s->bi\_valid;
00206         s->bi\_valid += length;
00207     \}
00208 \}
00209 \textcolor{preprocessor}{#else }\textcolor{comment}{/* !ZLIB\_DEBUG */}\textcolor{preprocessor}{}
00210 
00211 \textcolor{preprocessor}{#define send\_bits(s, value, length) \(\backslash\)}
00212 \textcolor{preprocessor}{\{ int len = length;\(\backslash\)}
00213 \textcolor{preprocessor}{  if (s->bi\_valid > (int)Buf\_size - len) \{\(\backslash\)}
00214 \textcolor{preprocessor}{    int val = (int)value;\(\backslash\)}
00215 \textcolor{preprocessor}{    s->bi\_buf |= (ush)val << s->bi\_valid;\(\backslash\)}
00216 \textcolor{preprocessor}{    put\_short(s, s->bi\_buf);\(\backslash\)}
00217 \textcolor{preprocessor}{    s->bi\_buf = (ush)val >> (Buf\_size - s->bi\_valid);\(\backslash\)}
00218 \textcolor{preprocessor}{    s->bi\_valid += len - Buf\_size;\(\backslash\)}
00219 \textcolor{preprocessor}{  \} else \{\(\backslash\)}
00220 \textcolor{preprocessor}{    s->bi\_buf |= (ush)(value) << s->bi\_valid;\(\backslash\)}
00221 \textcolor{preprocessor}{    s->bi\_valid += len;\(\backslash\)}
00222 \textcolor{preprocessor}{  \}\(\backslash\)}
00223 \textcolor{preprocessor}{\}}
00224 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* ZLIB\_DEBUG */}\textcolor{preprocessor}{}
00225 
00226 
00227 \textcolor{comment}{/* the arguments must not have side effects */}
00228 
00229 \textcolor{comment}{/* ===========================================================================}
00230 \textcolor{comment}{ * Initialize the various 'constant' tables.}
00231 \textcolor{comment}{ */}
00232 local \textcolor{keywordtype}{void} tr\_static\_init()
00233 \{
00234 \textcolor{preprocessor}{#if defined(GEN\_TREES\_H) || !defined(STDC)}
00235     \textcolor{keyword}{static} \textcolor{keywordtype}{int} static\_init\_done = 0;
00236     \textcolor{keywordtype}{int} n;        \textcolor{comment}{/* iterates over tree elements */}
00237     \textcolor{keywordtype}{int} bits;     \textcolor{comment}{/* bit counter */}
00238     \textcolor{keywordtype}{int} length;   \textcolor{comment}{/* length value */}
00239     \textcolor{keywordtype}{int} \hyperlink{structcode}{code};     \textcolor{comment}{/* code value */}
00240     \textcolor{keywordtype}{int} dist;     \textcolor{comment}{/* distance index */}
00241     ush bl\_count[MAX\_BITS+1];
00242     \textcolor{comment}{/* number of codes at each bit length for an optimal tree */}
00243 
00244     \textcolor{keywordflow}{if} (static\_init\_done) \textcolor{keywordflow}{return};
00245 
00246     \textcolor{comment}{/* For some embedded targets, global variables are not initialized: */}
00247 \textcolor{preprocessor}{#ifdef NO\_INIT\_GLOBAL\_POINTERS}
00248     static\_l\_desc.static\_tree = static\_ltree;
00249     static\_l\_desc.extra\_bits = extra\_lbits;
00250     static\_d\_desc.static\_tree = static\_dtree;
00251     static\_d\_desc.extra\_bits = extra\_dbits;
00252     static\_bl\_desc.extra\_bits = extra\_blbits;
00253 \textcolor{preprocessor}{#endif}
00254 
00255     \textcolor{comment}{/* Initialize the mapping length (0..255) -> length code (0..28) */}
00256     length = 0;
00257     \textcolor{keywordflow}{for} (code = 0; code < LENGTH\_CODES-1; code++) \{
00258         base\_length[code] = length;
00259         \textcolor{keywordflow}{for} (n = 0; n < (1<<extra\_lbits[code]); n++) \{
00260             \_length\_code[length++] = (uch)code;
00261         \}
00262     \}
00263     Assert (length == 256, \textcolor{stringliteral}{"tr\_static\_init: length != 256"});
00264     \textcolor{comment}{/* Note that the length 255 (match length 258) can be represented}
00265 \textcolor{comment}{     * in two different ways: code 284 + 5 bits or code 285, so we}
00266 \textcolor{comment}{     * overwrite length\_code[255] to use the best encoding:}
00267 \textcolor{comment}{     */}
00268     \_length\_code[length-1] = (uch)code;
00269 
00270     \textcolor{comment}{/* Initialize the mapping dist (0..32K) -> dist code (0..29) */}
00271     dist = 0;
00272     \textcolor{keywordflow}{for} (code = 0 ; code < 16; code++) \{
00273         base\_dist[code] = dist;
00274         \textcolor{keywordflow}{for} (n = 0; n < (1<<extra\_dbits[code]); n++) \{
00275             \_dist\_code[dist++] = (uch)code;
00276         \}
00277     \}
00278     Assert (dist == 256, \textcolor{stringliteral}{"tr\_static\_init: dist != 256"});
00279     dist >>= 7; \textcolor{comment}{/* from now on, all distances are divided by 128 */}
00280     \textcolor{keywordflow}{for} ( ; code < D\_CODES; code++) \{
00281         base\_dist[code] = dist << 7;
00282         \textcolor{keywordflow}{for} (n = 0; n < (1<<(extra\_dbits[code]-7)); n++) \{
00283             \_dist\_code[256 + dist++] = (uch)code;
00284         \}
00285     \}
00286     Assert (dist == 256, \textcolor{stringliteral}{"tr\_static\_init: 256+dist != 512"});
00287 
00288     \textcolor{comment}{/* Construct the codes of the static literal tree */}
00289     \textcolor{keywordflow}{for} (bits = 0; bits <= MAX\_BITS; bits++) bl\_count[bits] = 0;
00290     n = 0;
00291     \textcolor{keywordflow}{while} (n <= 143) static\_ltree[n++].Len = 8, bl\_count[8]++;
00292     \textcolor{keywordflow}{while} (n <= 255) static\_ltree[n++].Len = 9, bl\_count[9]++;
00293     \textcolor{keywordflow}{while} (n <= 279) static\_ltree[n++].Len = 7, bl\_count[7]++;
00294     \textcolor{keywordflow}{while} (n <= 287) static\_ltree[n++].Len = 8, bl\_count[8]++;
00295     \textcolor{comment}{/* Codes 286 and 287 do not exist, but we must include them in the}
00296 \textcolor{comment}{     * tree construction to get a canonical Huffman tree (longest code}
00297 \textcolor{comment}{     * all ones)}
00298 \textcolor{comment}{     */}
00299     gen\_codes((\hyperlink{structct__data__s}{ct\_data} *)static\_ltree, L\_CODES+1, bl\_count);
00300 
00301     \textcolor{comment}{/* The static distance tree is trivial: */}
00302     \textcolor{keywordflow}{for} (n = 0; n < D\_CODES; n++) \{
00303         static\_dtree[n].Len = 5;
00304         static\_dtree[n].Code = bi\_reverse((\textcolor{keywordtype}{unsigned})n, 5);
00305     \}
00306     static\_init\_done = 1;
00307 
00308 \textcolor{preprocessor}{#  ifdef GEN\_TREES\_H}
00309     gen\_trees\_header();
00310 \textcolor{preprocessor}{#  endif}
00311 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* defined(GEN\_TREES\_H) || !defined(STDC) */}\textcolor{preprocessor}{}
00312 \}
00313 
00314 \textcolor{comment}{/* ===========================================================================}
00315 \textcolor{comment}{ * Genererate the file trees.h describing the static trees.}
00316 \textcolor{comment}{ */}
00317 \textcolor{preprocessor}{#ifdef GEN\_TREES\_H}
00318 \textcolor{preprocessor}{#  ifndef ZLIB\_DEBUG}
00319 \textcolor{preprocessor}{#    include <stdio.h>}
00320 \textcolor{preprocessor}{#  endif}
00321 
00322 \textcolor{preprocessor}{#  define SEPARATOR(i, last, width) \(\backslash\)}
00323 \textcolor{preprocessor}{      ((i) == (last)? "\(\backslash\)n\};\(\backslash\)n\(\backslash\)n" :    \(\backslash\)}
00324 \textcolor{preprocessor}{       ((i) % (width) == (width)-1 ? ",\(\backslash\)n" : ", "))}
00325 
00326 \textcolor{keywordtype}{void} gen\_trees\_header()
00327 \{
00328     FILE *header = fopen(\textcolor{stringliteral}{"trees.h"}, \textcolor{stringliteral}{"w"});
00329     \textcolor{keywordtype}{int} i;
00330 
00331     Assert (header != NULL, \textcolor{stringliteral}{"Can't open trees.h"});
00332     fprintf(header,
00333             \textcolor{stringliteral}{"/* header created automatically with -DGEN\_TREES\_H */\(\backslash\)n\(\backslash\)n"});
00334 
00335     fprintf(header, \textcolor{stringliteral}{"local const ct\_data static\_ltree[L\_CODES+2] = \{\(\backslash\)n"});
00336     \textcolor{keywordflow}{for} (i = 0; i < L\_CODES+2; i++) \{
00337         fprintf(header, \textcolor{stringliteral}{"\{\{%3u\},\{%3u\}\}%s"}, static\_ltree[i].Code,
00338                 static\_ltree[i].Len, SEPARATOR(i, L\_CODES+1, 5));
00339     \}
00340 
00341     fprintf(header, \textcolor{stringliteral}{"local const ct\_data static\_dtree[D\_CODES] = \{\(\backslash\)n"});
00342     \textcolor{keywordflow}{for} (i = 0; i < D\_CODES; i++) \{
00343         fprintf(header, \textcolor{stringliteral}{"\{\{%2u\},\{%2u\}\}%s"}, static\_dtree[i].Code,
00344                 static\_dtree[i].Len, SEPARATOR(i, D\_CODES-1, 5));
00345     \}
00346 
00347     fprintf(header, \textcolor{stringliteral}{"const uch ZLIB\_INTERNAL \_dist\_code[DIST\_CODE\_LEN] = \{\(\backslash\)n"});
00348     \textcolor{keywordflow}{for} (i = 0; i < DIST\_CODE\_LEN; i++) \{
00349         fprintf(header, \textcolor{stringliteral}{"%2u%s"}, \_dist\_code[i],
00350                 SEPARATOR(i, DIST\_CODE\_LEN-1, 20));
00351     \}
00352 
00353     fprintf(header,
00354         \textcolor{stringliteral}{"const uch ZLIB\_INTERNAL \_length\_code[MAX\_MATCH-MIN\_MATCH+1]= \{\(\backslash\)n"});
00355     \textcolor{keywordflow}{for} (i = 0; i < MAX\_MATCH-MIN\_MATCH+1; i++) \{
00356         fprintf(header, \textcolor{stringliteral}{"%2u%s"}, \_length\_code[i],
00357                 SEPARATOR(i, MAX\_MATCH-MIN\_MATCH, 20));
00358     \}
00359 
00360     fprintf(header, \textcolor{stringliteral}{"local const int base\_length[LENGTH\_CODES] = \{\(\backslash\)n"});
00361     \textcolor{keywordflow}{for} (i = 0; i < LENGTH\_CODES; i++) \{
00362         fprintf(header, \textcolor{stringliteral}{"%1u%s"}, base\_length[i],
00363                 SEPARATOR(i, LENGTH\_CODES-1, 20));
00364     \}
00365 
00366     fprintf(header, \textcolor{stringliteral}{"local const int base\_dist[D\_CODES] = \{\(\backslash\)n"});
00367     \textcolor{keywordflow}{for} (i = 0; i < D\_CODES; i++) \{
00368         fprintf(header, \textcolor{stringliteral}{"%5u%s"}, base\_dist[i],
00369                 SEPARATOR(i, D\_CODES-1, 10));
00370     \}
00371 
00372     fclose(header);
00373 \}
00374 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* GEN\_TREES\_H */}\textcolor{preprocessor}{}
00375 
00376 \textcolor{comment}{/* ===========================================================================}
00377 \textcolor{comment}{ * Initialize the tree data structures for a new zlib stream.}
00378 \textcolor{comment}{ */}
00379 \textcolor{keywordtype}{void} ZLIB\_INTERNAL \_tr\_init(s)
00380     \hyperlink{structinternal__state}{deflate\_state} *s;
00381 \{
00382     tr\_static\_init();
00383 
00384     s->l\_desc.dyn\_tree = s->dyn\_ltree;
00385     s->l\_desc.stat\_desc = &static\_l\_desc;
00386 
00387     s->d\_desc.dyn\_tree = s->dyn\_dtree;
00388     s->d\_desc.stat\_desc = &static\_d\_desc;
00389 
00390     s->bl\_desc.dyn\_tree = s->bl\_tree;
00391     s->bl\_desc.stat\_desc = &static\_bl\_desc;
00392 
00393     s->bi\_buf = 0;
00394     s->bi\_valid = 0;
00395 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
00396     s->compressed\_len = 0L;
00397     s->bits\_sent = 0L;
00398 \textcolor{preprocessor}{#endif}
00399 
00400     \textcolor{comment}{/* Initialize the first block of the first file: */}
00401     init\_block(s);
00402 \}
00403 
00404 \textcolor{comment}{/* ===========================================================================}
00405 \textcolor{comment}{ * Initialize a new block.}
00406 \textcolor{comment}{ */}
00407 local \textcolor{keywordtype}{void} init\_block(s)
00408     \hyperlink{structinternal__state}{deflate\_state} *s;
00409 \{
00410     \textcolor{keywordtype}{int} n; \textcolor{comment}{/* iterates over tree elements */}
00411 
00412     \textcolor{comment}{/* Initialize the trees. */}
00413     \textcolor{keywordflow}{for} (n = 0; n < L\_CODES;  n++) s->dyn\_ltree[n].Freq = 0;
00414     for (n = 0; n < D\_CODES;  n++) s->dyn\_dtree[n].Freq = 0;
00415     for (n = 0; n < BL\_CODES; n++) s->bl\_tree[n].Freq = 0;
00416 
00417     s->dyn\_ltree[END\_BLOCK].Freq = 1;
00418     s->opt\_len = s->static\_len = 0L;
00419     s->last\_lit = s->matches = 0;
00420 \}
00421 
00422 \textcolor{preprocessor}{#define SMALLEST 1}
00423 \textcolor{comment}{/* Index within the heap array of least frequent node in the Huffman tree */}
00424 
00425 
00426 \textcolor{comment}{/* ===========================================================================}
00427 \textcolor{comment}{ * Remove the smallest element from the heap and recreate the heap with}
00428 \textcolor{comment}{ * one less element. Updates heap and heap\_len.}
00429 \textcolor{comment}{ */}
00430 \textcolor{preprocessor}{#define pqremove(s, tree, top) \(\backslash\)}
00431 \textcolor{preprocessor}{\{\(\backslash\)}
00432 \textcolor{preprocessor}{    top = s->heap[SMALLEST]; \(\backslash\)}
00433 \textcolor{preprocessor}{    s->heap[SMALLEST] = s->heap[s->heap\_len--]; \(\backslash\)}
00434 \textcolor{preprocessor}{    pqdownheap(s, tree, SMALLEST); \(\backslash\)}
00435 \textcolor{preprocessor}{\}}
00436 
00437 \textcolor{comment}{/* ===========================================================================}
00438 \textcolor{comment}{ * Compares to subtrees, using the tree depth as tie breaker when}
00439 \textcolor{comment}{ * the subtrees have equal frequency. This minimizes the worst case length.}
00440 \textcolor{comment}{ */}
00441 \textcolor{preprocessor}{#define smaller(tree, n, m, depth) \(\backslash\)}
00442 \textcolor{preprocessor}{   (tree[n].Freq < tree[m].Freq || \(\backslash\)}
00443 \textcolor{preprocessor}{   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))}
00444 
00445 \textcolor{comment}{/* ===========================================================================}
00446 \textcolor{comment}{ * Restore the heap property by moving down the tree starting at node k,}
00447 \textcolor{comment}{ * exchanging a node with the smallest of its two sons if necessary, stopping}
00448 \textcolor{comment}{ * when the heap property is re-established (each father smaller than its}
00449 \textcolor{comment}{ * two sons).}
00450 \textcolor{comment}{ */}
00451 local \textcolor{keywordtype}{void} pqdownheap(s, tree, k)
00452     \hyperlink{structinternal__state}{deflate\_state} *s;
00453     \hyperlink{structct__data__s}{ct\_data} *tree;  \textcolor{comment}{/* the tree to restore */}
00454     \textcolor{keywordtype}{int} k;               \textcolor{comment}{/* node to move down */}
00455 \{
00456     \textcolor{keywordtype}{int} v = s->heap[k];
00457     \textcolor{keywordtype}{int} j = k << 1;  \textcolor{comment}{/* left son of k */}
00458     \textcolor{keywordflow}{while} (j <= s->heap\_len) \{
00459         \textcolor{comment}{/* Set j to the smallest of the two sons: */}
00460         \textcolor{keywordflow}{if} (j < s->heap\_len &&
00461             smaller(tree, s->heap[j+1], s->heap[j], s->depth)) \{
00462             j++;
00463         \}
00464         \textcolor{comment}{/* Exit if v is smaller than both sons */}
00465         \textcolor{keywordflow}{if} (smaller(tree, v, s->heap[j], s->depth)) \textcolor{keywordflow}{break};
00466 
00467         \textcolor{comment}{/* Exchange v with the smallest son */}
00468         s->heap[k] = s->heap[j];  k = j;
00469 
00470         \textcolor{comment}{/* And continue down the tree, setting j to the left son of k */}
00471         j <<= 1;
00472     \}
00473     s->heap[k] = v;
00474 \}
00475 
00476 \textcolor{comment}{/* ===========================================================================}
00477 \textcolor{comment}{ * Compute the optimal bit lengths for a tree and update the total bit length}
00478 \textcolor{comment}{ * for the current block.}
00479 \textcolor{comment}{ * IN assertion: the fields freq and dad are set, heap[heap\_max] and}
00480 \textcolor{comment}{ *    above are the tree nodes sorted by increasing frequency.}
00481 \textcolor{comment}{ * OUT assertions: the field len is set to the optimal bit length, the}
00482 \textcolor{comment}{ *     array bl\_count contains the frequencies for each bit length.}
00483 \textcolor{comment}{ *     The length opt\_len is updated; static\_len is also updated if stree is}
00484 \textcolor{comment}{ *     not null.}
00485 \textcolor{comment}{ */}
00486 local \textcolor{keywordtype}{void} gen\_bitlen(s, desc)
00487     \hyperlink{structinternal__state}{deflate\_state} *s;
00488     \hyperlink{structtree__desc__s}{tree\_desc} *desc;    \textcolor{comment}{/* the tree descriptor */}
00489 \{
00490     \hyperlink{structct__data__s}{ct\_data} *tree        = desc->dyn\_tree;
00491     \textcolor{keywordtype}{int} max\_code         = desc->max\_code;
00492     \textcolor{keyword}{const} \hyperlink{structct__data__s}{ct\_data} *stree = desc->stat\_desc->static\_tree;
00493     \textcolor{keyword}{const} intf *extra    = desc->stat\_desc->extra\_bits;
00494     \textcolor{keywordtype}{int} base             = desc->stat\_desc->extra\_base;
00495     \textcolor{keywordtype}{int} max\_length       = desc->stat\_desc->max\_length;
00496     \textcolor{keywordtype}{int} h;              \textcolor{comment}{/* heap index */}
00497     \textcolor{keywordtype}{int} n, m;           \textcolor{comment}{/* iterate over the tree elements */}
00498     \textcolor{keywordtype}{int} bits;           \textcolor{comment}{/* bit length */}
00499     \textcolor{keywordtype}{int} xbits;          \textcolor{comment}{/* extra bits */}
00500     ush f;              \textcolor{comment}{/* frequency */}
00501     \textcolor{keywordtype}{int} overflow = 0;   \textcolor{comment}{/* number of elements with bit length too large */}
00502 
00503     \textcolor{keywordflow}{for} (bits = 0; bits <= MAX\_BITS; bits++) s->bl\_count[bits] = 0;
00504 
00505     \textcolor{comment}{/* In a first pass, compute the optimal bit lengths (which may}
00506 \textcolor{comment}{     * overflow in the case of the bit length tree).}
00507 \textcolor{comment}{     */}
00508     tree[s->heap[s->heap\_max]].Len = 0; \textcolor{comment}{/* root of the heap */}
00509 
00510     for (h = s->heap\_max+1; h < HEAP\_SIZE; h++) \{
00511         n = s->heap[h];
00512         bits = tree[tree[n].Dad].Len + 1;
00513         \textcolor{keywordflow}{if} (bits > max\_length) bits = max\_length, overflow++;
00514         tree[n].Len = (ush)bits;
00515         \textcolor{comment}{/* We overwrite tree[n].Dad which is no longer needed */}
00516 
00517         \textcolor{keywordflow}{if} (n > max\_code) \textcolor{keywordflow}{continue}; \textcolor{comment}{/* not a leaf node */}
00518 
00519         s->bl\_count[bits]++;
00520         xbits = 0;
00521         \textcolor{keywordflow}{if} (n >= base) xbits = extra[n-base];
00522         f = tree[n].Freq;
00523         s->opt\_len += (ulg)f * (\textcolor{keywordtype}{unsigned})(bits + xbits);
00524         \textcolor{keywordflow}{if} (stree) s->static\_len += (ulg)f * (\textcolor{keywordtype}{unsigned})(stree[n].Len + xbits);
00525     \}
00526     \textcolor{keywordflow}{if} (overflow == 0) \textcolor{keywordflow}{return};
00527 
00528     Tracev((stderr,\textcolor{stringliteral}{"\(\backslash\)nbit length overflow\(\backslash\)n"}));
00529     \textcolor{comment}{/* This happens for example on obj2 and pic of the Calgary corpus */}
00530 
00531     \textcolor{comment}{/* Find the first bit length which could increase: */}
00532     \textcolor{keywordflow}{do} \{
00533         bits = max\_length-1;
00534         \textcolor{keywordflow}{while} (s->bl\_count[bits] == 0) bits--;
00535         s->bl\_count[bits]--;      \textcolor{comment}{/* move one leaf down the tree */}
00536         s->bl\_count[bits+1] += 2; \textcolor{comment}{/* move one overflow item as its brother */}
00537         s->bl\_count[max\_length]--;
00538         \textcolor{comment}{/* The brother of the overflow item also moves one step up,}
00539 \textcolor{comment}{         * but this does not affect bl\_count[max\_length]}
00540 \textcolor{comment}{         */}
00541         overflow -= 2;
00542     \} \textcolor{keywordflow}{while} (overflow > 0);
00543 
00544     \textcolor{comment}{/* Now recompute all bit lengths, scanning in increasing frequency.}
00545 \textcolor{comment}{     * h is still equal to HEAP\_SIZE. (It is simpler to reconstruct all}
00546 \textcolor{comment}{     * lengths instead of fixing only the wrong ones. This idea is taken}
00547 \textcolor{comment}{     * from 'ar' written by Haruhiko Okumura.)}
00548 \textcolor{comment}{     */}
00549     \textcolor{keywordflow}{for} (bits = max\_length; bits != 0; bits--) \{
00550         n = s->bl\_count[bits];
00551         \textcolor{keywordflow}{while} (n != 0) \{
00552             m = s->heap[--h];
00553             \textcolor{keywordflow}{if} (m > max\_code) \textcolor{keywordflow}{continue};
00554             \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned}) tree[m].Len != (\textcolor{keywordtype}{unsigned}) bits) \{
00555                 Tracev((stderr,\textcolor{stringliteral}{"code %d bits %d->%d\(\backslash\)n"}, m, tree[m].Len, bits));
00556                 s->opt\_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;
00557                 tree[m].Len = (ush)bits;
00558             \}
00559             n--;
00560         \}
00561     \}
00562 \}
00563 
00564 \textcolor{comment}{/* ===========================================================================}
00565 \textcolor{comment}{ * Generate the codes for a given tree and bit counts (which need not be}
00566 \textcolor{comment}{ * optimal).}
00567 \textcolor{comment}{ * IN assertion: the array bl\_count contains the bit length statistics for}
00568 \textcolor{comment}{ * the given tree and the field len is set for all tree elements.}
00569 \textcolor{comment}{ * OUT assertion: the field code is set for all tree elements of non}
00570 \textcolor{comment}{ *     zero code length.}
00571 \textcolor{comment}{ */}
00572 local \textcolor{keywordtype}{void} gen\_codes (tree, max\_code, bl\_count)
00573     \hyperlink{structct__data__s}{ct\_data} *tree;             \textcolor{comment}{/* the tree to decorate */}
00574     \textcolor{keywordtype}{int} max\_code;              \textcolor{comment}{/* largest code with non zero frequency */}
00575     ushf *bl\_count;            \textcolor{comment}{/* number of codes at each bit length */}
00576 \{
00577     ush next\_code[MAX\_BITS+1]; \textcolor{comment}{/* next code value for each bit length */}
00578     \textcolor{keywordtype}{unsigned} code = 0;         \textcolor{comment}{/* running code value */}
00579     \textcolor{keywordtype}{int} bits;                  \textcolor{comment}{/* bit index */}
00580     \textcolor{keywordtype}{int} n;                     \textcolor{comment}{/* code index */}
00581 
00582     \textcolor{comment}{/* The distribution counts are first used to generate the code values}
00583 \textcolor{comment}{     * without bit reversal.}
00584 \textcolor{comment}{     */}
00585     \textcolor{keywordflow}{for} (bits = 1; bits <= MAX\_BITS; bits++) \{
00586         code = (code + bl\_count[bits-1]) << 1;
00587         next\_code[bits] = (ush)code;
00588     \}
00589     \textcolor{comment}{/* Check that the bit counts in bl\_count are consistent. The last code}
00590 \textcolor{comment}{     * must be all ones.}
00591 \textcolor{comment}{     */}
00592     Assert (code + bl\_count[MAX\_BITS]-1 == (1<<MAX\_BITS)-1,
00593             \textcolor{stringliteral}{"inconsistent bit counts"});
00594     Tracev((stderr,\textcolor{stringliteral}{"\(\backslash\)ngen\_codes: max\_code %d "}, max\_code));
00595 
00596     \textcolor{keywordflow}{for} (n = 0;  n <= max\_code; n++) \{
00597         \textcolor{keywordtype}{int} len = tree[n].Len;
00598         \textcolor{keywordflow}{if} (len == 0) \textcolor{keywordflow}{continue};
00599         \textcolor{comment}{/* Now reverse the bits */}
00600         tree[n].Code = (ush)bi\_reverse(next\_code[len]++, len);
00601 
00602         Tracecv(tree != static\_ltree, (stderr,\textcolor{stringliteral}{"\(\backslash\)nn %3d %c l %2d c %4x (%x) "},
00603              n, (isgraph(n) ? n : \textcolor{charliteral}{' '}), len, tree[n].Code, next\_code[len]-1));
00604     \}
00605 \}
00606 
00607 \textcolor{comment}{/* ===========================================================================}
00608 \textcolor{comment}{ * Construct one Huffman tree and assigns the code bit strings and lengths.}
00609 \textcolor{comment}{ * Update the total bit length for the current block.}
00610 \textcolor{comment}{ * IN assertion: the field freq is set for all tree elements.}
00611 \textcolor{comment}{ * OUT assertions: the fields len and code are set to the optimal bit length}
00612 \textcolor{comment}{ *     and corresponding code. The length opt\_len is updated; static\_len is}
00613 \textcolor{comment}{ *     also updated if stree is not null. The field max\_code is set.}
00614 \textcolor{comment}{ */}
00615 local \textcolor{keywordtype}{void} build\_tree(s, desc)
00616     \hyperlink{structinternal__state}{deflate\_state} *s;
00617     \hyperlink{structtree__desc__s}{tree\_desc} *desc; \textcolor{comment}{/* the tree descriptor */}
00618 \{
00619     \hyperlink{structct__data__s}{ct\_data} *tree         = desc->dyn\_tree;
00620     \textcolor{keyword}{const} \hyperlink{structct__data__s}{ct\_data} *stree  = desc->stat\_desc->static\_tree;
00621     \textcolor{keywordtype}{int} elems             = desc->stat\_desc->elems;
00622     \textcolor{keywordtype}{int} n, m;          \textcolor{comment}{/* iterate over heap elements */}
00623     \textcolor{keywordtype}{int} max\_code = -1; \textcolor{comment}{/* largest code with non zero frequency */}
00624     \textcolor{keywordtype}{int} node;          \textcolor{comment}{/* new node being created */}
00625 
00626     \textcolor{comment}{/* Construct the initial heap, with least frequent element in}
00627 \textcolor{comment}{     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].}
00628 \textcolor{comment}{     * heap[0] is not used.}
00629 \textcolor{comment}{     */}
00630     s->heap\_len = 0, s->heap\_max = HEAP\_SIZE;
00631 
00632     \textcolor{keywordflow}{for} (n = 0; n < elems; n++) \{
00633         \textcolor{keywordflow}{if} (tree[n].Freq != 0) \{
00634             s->heap[++(s->heap\_len)] = max\_code = n;
00635             s->depth[n] = 0;
00636         \} \textcolor{keywordflow}{else} \{
00637             tree[n].Len = 0;
00638         \}
00639     \}
00640 
00641     \textcolor{comment}{/* The pkzip format requires that at least one distance code exists,}
00642 \textcolor{comment}{     * and that at least one bit should be sent even if there is only one}
00643 \textcolor{comment}{     * possible code. So to avoid special checks later on we force at least}
00644 \textcolor{comment}{     * two codes of non zero frequency.}
00645 \textcolor{comment}{     */}
00646     \textcolor{keywordflow}{while} (s->heap\_len < 2) \{
00647         node = s->heap[++(s->heap\_len)] = (max\_code < 2 ? ++max\_code : 0);
00648         tree[node].Freq = 1;
00649         s->depth[node] = 0;
00650         s->opt\_len--; \textcolor{keywordflow}{if} (stree) s->static\_len -= stree[node].Len;
00651         \textcolor{comment}{/* node is 0 or 1 so it does not have extra bits */}
00652     \}
00653     desc->max\_code = max\_code;
00654 
00655     \textcolor{comment}{/* The elements heap[heap\_len/2+1 .. heap\_len] are leaves of the tree,}
00656 \textcolor{comment}{     * establish sub-heaps of increasing lengths:}
00657 \textcolor{comment}{     */}
00658     \textcolor{keywordflow}{for} (n = s->heap\_len/2; n >= 1; n--) pqdownheap(s, tree, n);
00659 
00660     \textcolor{comment}{/* Construct the Huffman tree by repeatedly combining the least two}
00661 \textcolor{comment}{     * frequent nodes.}
00662 \textcolor{comment}{     */}
00663     node = elems;              \textcolor{comment}{/* next internal node of the tree */}
00664     \textcolor{keywordflow}{do} \{
00665         pqremove(s, tree, n);  \textcolor{comment}{/* n = node of least frequency */}
00666         m = s->heap[SMALLEST]; \textcolor{comment}{/* m = node of next least frequency */}
00667 
00668         s->heap[--(s->heap\_max)] = n; \textcolor{comment}{/* keep the nodes sorted by frequency */}
00669         s->heap[--(s->heap\_max)] = m;
00670 
00671         \textcolor{comment}{/* Create a new node father of n and m */}
00672         tree[node].Freq = tree[n].Freq + tree[m].Freq;
00673         s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
00674                                 s->depth[n] : s->depth[m]) + 1);
00675         tree[n].Dad = tree[m].Dad = (ush)node;
00676 \textcolor{preprocessor}{#ifdef DUMP\_BL\_TREE}
00677         \textcolor{keywordflow}{if} (tree == s->bl\_tree) \{
00678             fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)nnode %d(%d), sons %d(%d) %d(%d)"},
00679                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
00680         \}
00681 \textcolor{preprocessor}{#endif}
00682         \textcolor{comment}{/* and insert the new node in the heap */}
00683         s->heap[SMALLEST] = node++;
00684         pqdownheap(s, tree, SMALLEST);
00685 
00686     \} \textcolor{keywordflow}{while} (s->heap\_len >= 2);
00687 
00688     s->heap[--(s->heap\_max)] = s->heap[SMALLEST];
00689 
00690     \textcolor{comment}{/* At this point, the fields freq and dad are set. We can now}
00691 \textcolor{comment}{     * generate the bit lengths.}
00692 \textcolor{comment}{     */}
00693     gen\_bitlen(s, (\hyperlink{structtree__desc__s}{tree\_desc} *)desc);
00694 
00695     \textcolor{comment}{/* The field len is now set, we can generate the bit codes */}
00696     gen\_codes ((\hyperlink{structct__data__s}{ct\_data} *)tree, max\_code, s->bl\_count);
00697 \}
00698 
00699 \textcolor{comment}{/* ===========================================================================}
00700 \textcolor{comment}{ * Scan a literal or distance tree to determine the frequencies of the codes}
00701 \textcolor{comment}{ * in the bit length tree.}
00702 \textcolor{comment}{ */}
00703 local \textcolor{keywordtype}{void} scan\_tree (s, tree, max\_code)
00704     \hyperlink{structinternal__state}{deflate\_state} *s;
00705     \hyperlink{structct__data__s}{ct\_data} *tree;   \textcolor{comment}{/* the tree to be scanned */}
00706     \textcolor{keywordtype}{int} max\_code;    \textcolor{comment}{/* and its largest code of non zero frequency */}
00707 \{
00708     \textcolor{keywordtype}{int} n;                     \textcolor{comment}{/* iterates over all tree elements */}
00709     \textcolor{keywordtype}{int} prevlen = -1;          \textcolor{comment}{/* last emitted length */}
00710     \textcolor{keywordtype}{int} curlen;                \textcolor{comment}{/* length of current code */}
00711     \textcolor{keywordtype}{int} nextlen = tree[0].Len; \textcolor{comment}{/* length of next code */}
00712     \textcolor{keywordtype}{int} count = 0;             \textcolor{comment}{/* repeat count of the current code */}
00713     \textcolor{keywordtype}{int} max\_count = 7;         \textcolor{comment}{/* max repeat count */}
00714     \textcolor{keywordtype}{int} min\_count = 4;         \textcolor{comment}{/* min repeat count */}
00715 
00716     \textcolor{keywordflow}{if} (nextlen == 0) max\_count = 138, min\_count = 3;
00717     tree[max\_code+1].Len = (ush)0xffff; \textcolor{comment}{/* guard */}
00718 
00719     \textcolor{keywordflow}{for} (n = 0; n <= max\_code; n++) \{
00720         curlen = nextlen; nextlen = tree[n+1].Len;
00721         \textcolor{keywordflow}{if} (++count < max\_count && curlen == nextlen) \{
00722             \textcolor{keywordflow}{continue};
00723         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (count < min\_count) \{
00724             s->bl\_tree[curlen].Freq += count;
00725         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (curlen != 0) \{
00726             \textcolor{keywordflow}{if} (curlen != prevlen) s->bl\_tree[curlen].Freq++;
00727             s->bl\_tree[REP\_3\_6].Freq++;
00728         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (count <= 10) \{
00729             s->bl\_tree[REPZ\_3\_10].Freq++;
00730         \} \textcolor{keywordflow}{else} \{
00731             s->bl\_tree[REPZ\_11\_138].Freq++;
00732         \}
00733         count = 0; prevlen = curlen;
00734         \textcolor{keywordflow}{if} (nextlen == 0) \{
00735             max\_count = 138, min\_count = 3;
00736         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (curlen == nextlen) \{
00737             max\_count = 6, min\_count = 3;
00738         \} \textcolor{keywordflow}{else} \{
00739             max\_count = 7, min\_count = 4;
00740         \}
00741     \}
00742 \}
00743 
00744 \textcolor{comment}{/* ===========================================================================}
00745 \textcolor{comment}{ * Send a literal or distance tree in compressed form, using the codes in}
00746 \textcolor{comment}{ * bl\_tree.}
00747 \textcolor{comment}{ */}
00748 local \textcolor{keywordtype}{void} send\_tree (s, tree, max\_code)
00749     \hyperlink{structinternal__state}{deflate\_state} *s;
00750     \hyperlink{structct__data__s}{ct\_data} *tree; \textcolor{comment}{/* the tree to be scanned */}
00751     \textcolor{keywordtype}{int} max\_code;       \textcolor{comment}{/* and its largest code of non zero frequency */}
00752 \{
00753     \textcolor{keywordtype}{int} n;                     \textcolor{comment}{/* iterates over all tree elements */}
00754     \textcolor{keywordtype}{int} prevlen = -1;          \textcolor{comment}{/* last emitted length */}
00755     \textcolor{keywordtype}{int} curlen;                \textcolor{comment}{/* length of current code */}
00756     \textcolor{keywordtype}{int} nextlen = tree[0].Len; \textcolor{comment}{/* length of next code */}
00757     \textcolor{keywordtype}{int} count = 0;             \textcolor{comment}{/* repeat count of the current code */}
00758     \textcolor{keywordtype}{int} max\_count = 7;         \textcolor{comment}{/* max repeat count */}
00759     \textcolor{keywordtype}{int} min\_count = 4;         \textcolor{comment}{/* min repeat count */}
00760 
00761     \textcolor{comment}{/* tree[max\_code+1].Len = -1; */}  \textcolor{comment}{/* guard already set */}
00762     \textcolor{keywordflow}{if} (nextlen == 0) max\_count = 138, min\_count = 3;
00763 
00764     \textcolor{keywordflow}{for} (n = 0; n <= max\_code; n++) \{
00765         curlen = nextlen; nextlen = tree[n+1].Len;
00766         \textcolor{keywordflow}{if} (++count < max\_count && curlen == nextlen) \{
00767             \textcolor{keywordflow}{continue};
00768         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (count < min\_count) \{
00769             \textcolor{keywordflow}{do} \{ send\_code(s, curlen, s->bl\_tree); \} \textcolor{keywordflow}{while} (--count != 0);
00770 
00771         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (curlen != 0) \{
00772             \textcolor{keywordflow}{if} (curlen != prevlen) \{
00773                 send\_code(s, curlen, s->bl\_tree); count--;
00774             \}
00775             Assert(count >= 3 && count <= 6, \textcolor{stringliteral}{" 3\_6?"});
00776             send\_code(s, REP\_3\_6, s->bl\_tree); send\_bits(s, count-3, 2);
00777 
00778         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (count <= 10) \{
00779             send\_code(s, REPZ\_3\_10, s->bl\_tree); send\_bits(s, count-3, 3);
00780 
00781         \} \textcolor{keywordflow}{else} \{
00782             send\_code(s, REPZ\_11\_138, s->bl\_tree); send\_bits(s, count-11, 7);
00783         \}
00784         count = 0; prevlen = curlen;
00785         \textcolor{keywordflow}{if} (nextlen == 0) \{
00786             max\_count = 138, min\_count = 3;
00787         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (curlen == nextlen) \{
00788             max\_count = 6, min\_count = 3;
00789         \} \textcolor{keywordflow}{else} \{
00790             max\_count = 7, min\_count = 4;
00791         \}
00792     \}
00793 \}
00794 
00795 \textcolor{comment}{/* ===========================================================================}
00796 \textcolor{comment}{ * Construct the Huffman tree for the bit lengths and return the index in}
00797 \textcolor{comment}{ * bl\_order of the last bit length code to send.}
00798 \textcolor{comment}{ */}
00799 local \textcolor{keywordtype}{int} build\_bl\_tree(s)
00800     \hyperlink{structinternal__state}{deflate\_state} *s;
00801 \{
00802     \textcolor{keywordtype}{int} max\_blindex;  \textcolor{comment}{/* index of last bit length code of non zero freq */}
00803 
00804     \textcolor{comment}{/* Determine the bit length frequencies for literal and distance trees */}
00805     scan\_tree(s, (\hyperlink{structct__data__s}{ct\_data} *)s->dyn\_ltree, s->l\_desc.max\_code);
00806     scan\_tree(s, (\hyperlink{structct__data__s}{ct\_data} *)s->dyn\_dtree, s->d\_desc.max\_code);
00807 
00808     \textcolor{comment}{/* Build the bit length tree: */}
00809     build\_tree(s, (\hyperlink{structtree__desc__s}{tree\_desc} *)(&(s->bl\_desc)));
00810     \textcolor{comment}{/* opt\_len now includes the length of the tree representations, except}
00811 \textcolor{comment}{     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.}
00812 \textcolor{comment}{     */}
00813 
00814     \textcolor{comment}{/* Determine the number of bit length codes to send. The pkzip format}
00815 \textcolor{comment}{     * requires that at least 4 bit length codes be sent. (appnote.txt says}
00816 \textcolor{comment}{     * 3 but the actual value used is 4.)}
00817 \textcolor{comment}{     */}
00818     \textcolor{keywordflow}{for} (max\_blindex = BL\_CODES-1; max\_blindex >= 3; max\_blindex--) \{
00819         \textcolor{keywordflow}{if} (s->bl\_tree[bl\_order[max\_blindex]].Len != 0) \textcolor{keywordflow}{break};
00820     \}
00821     \textcolor{comment}{/* Update opt\_len to include the bit length tree and counts */}
00822     s->opt\_len += 3*((ulg)max\_blindex+1) + 5+5+4;
00823     Tracev((stderr, \textcolor{stringliteral}{"\(\backslash\)ndyn trees: dyn %ld, stat %ld"},
00824             s->opt\_len, s->static\_len));
00825 
00826     \textcolor{keywordflow}{return} max\_blindex;
00827 \}
00828 
00829 \textcolor{comment}{/* ===========================================================================}
00830 \textcolor{comment}{ * Send the header for a block using dynamic Huffman trees: the counts, the}
00831 \textcolor{comment}{ * lengths of the bit length codes, the literal tree and the distance tree.}
00832 \textcolor{comment}{ * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.}
00833 \textcolor{comment}{ */}
00834 local \textcolor{keywordtype}{void} send\_all\_trees(s, lcodes, dcodes, blcodes)
00835     \hyperlink{structinternal__state}{deflate\_state} *s;
00836     \textcolor{keywordtype}{int} lcodes, dcodes, blcodes; \textcolor{comment}{/* number of codes for each tree */}
00837 \{
00838     \textcolor{keywordtype}{int} rank;                    \textcolor{comment}{/* index in bl\_order */}
00839 
00840     Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \textcolor{stringliteral}{"not enough codes"});
00841     Assert (lcodes <= L\_CODES && dcodes <= D\_CODES && blcodes <= BL\_CODES,
00842             \textcolor{stringliteral}{"too many codes"});
00843     Tracev((stderr, \textcolor{stringliteral}{"\(\backslash\)nbl counts: "}));
00844     send\_bits(s, lcodes-257, 5); \textcolor{comment}{/* not +255 as stated in appnote.txt */}
00845     send\_bits(s, dcodes-1,   5);
00846     send\_bits(s, blcodes-4,  4); \textcolor{comment}{/* not -3 as stated in appnote.txt */}
00847     \textcolor{keywordflow}{for} (rank = 0; rank < blcodes; rank++) \{
00848         Tracev((stderr, \textcolor{stringliteral}{"\(\backslash\)nbl code %2d "}, bl\_order[rank]));
00849         send\_bits(s, s->bl\_tree[bl\_order[rank]].Len, 3);
00850     \}
00851     Tracev((stderr, \textcolor{stringliteral}{"\(\backslash\)nbl tree: sent %ld"}, s->bits\_sent));
00852 
00853     send\_tree(s, (\hyperlink{structct__data__s}{ct\_data} *)s->dyn\_ltree, lcodes-1); \textcolor{comment}{/* literal tree */}
00854     Tracev((stderr, \textcolor{stringliteral}{"\(\backslash\)nlit tree: sent %ld"}, s->bits\_sent));
00855 
00856     send\_tree(s, (\hyperlink{structct__data__s}{ct\_data} *)s->dyn\_dtree, dcodes-1); \textcolor{comment}{/* distance tree */}
00857     Tracev((stderr, \textcolor{stringliteral}{"\(\backslash\)ndist tree: sent %ld"}, s->bits\_sent));
00858 \}
00859 
00860 \textcolor{comment}{/* ===========================================================================}
00861 \textcolor{comment}{ * Send a stored block}
00862 \textcolor{comment}{ */}
00863 \textcolor{keywordtype}{void} ZLIB\_INTERNAL \_tr\_stored\_block(s, buf, stored\_len, last)
00864     \hyperlink{structinternal__state}{deflate\_state} *s;
00865     charf *buf;       \textcolor{comment}{/* input block */}
00866     ulg stored\_len;   \textcolor{comment}{/* length of input block */}
00867     \textcolor{keywordtype}{int} last;         \textcolor{comment}{/* one if this is the last block for a file */}
00868 \{
00869     send\_bits(s, (STORED\_BLOCK<<1)+last, 3);    \textcolor{comment}{/* send block type */}
00870     bi\_windup(s);        \textcolor{comment}{/* align on byte boundary */}
00871     put\_short(s, (ush)stored\_len);
00872     put\_short(s, (ush)~stored\_len);
00873     zmemcpy(s->pending\_buf + s->pending, (Bytef *)buf, stored\_len);
00874     s->pending += stored\_len;
00875 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
00876     s->compressed\_len = (s->compressed\_len + 3 + 7) & (ulg)~7L;
00877     s->compressed\_len += (stored\_len + 4) << 3;
00878     s->bits\_sent += 2*16;
00879     s->bits\_sent += stored\_len<<3;
00880 \textcolor{preprocessor}{#endif}
00881 \}
00882 
00883 \textcolor{comment}{/* ===========================================================================}
00884 \textcolor{comment}{ * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)}
00885 \textcolor{comment}{ */}
00886 \textcolor{keywordtype}{void} ZLIB\_INTERNAL \_tr\_flush\_bits(s)
00887     \hyperlink{structinternal__state}{deflate\_state} *s;
00888 \{
00889     bi\_flush(s);
00890 \}
00891 
00892 \textcolor{comment}{/* ===========================================================================}
00893 \textcolor{comment}{ * Send one empty static block to give enough lookahead for inflate.}
00894 \textcolor{comment}{ * This takes 10 bits, of which 7 may remain in the bit buffer.}
00895 \textcolor{comment}{ */}
00896 \textcolor{keywordtype}{void} ZLIB\_INTERNAL \_tr\_align(s)
00897     \hyperlink{structinternal__state}{deflate\_state} *s;
00898 \{
00899     send\_bits(s, STATIC\_TREES<<1, 3);
00900     send\_code(s, END\_BLOCK, static\_ltree);
00901 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
00902     s->compressed\_len += 10L; \textcolor{comment}{/* 3 for block type, 7 for EOB */}
00903 \textcolor{preprocessor}{#endif}
00904     bi\_flush(s);
00905 \}
00906 
00907 \textcolor{comment}{/* ===========================================================================}
00908 \textcolor{comment}{ * Determine the best encoding for the current block: dynamic trees, static}
00909 \textcolor{comment}{ * trees or store, and write out the encoded block.}
00910 \textcolor{comment}{ */}
00911 \textcolor{keywordtype}{void} ZLIB\_INTERNAL \_tr\_flush\_block(s, buf, stored\_len, last)
00912     \hyperlink{structinternal__state}{deflate\_state} *s;
00913     charf *buf;       \textcolor{comment}{/* input block, or NULL if too old */}
00914     ulg stored\_len;   \textcolor{comment}{/* length of input block */}
00915     \textcolor{keywordtype}{int} last;         \textcolor{comment}{/* one if this is the last block for a file */}
00916 \{
00917     ulg opt\_lenb, static\_lenb; \textcolor{comment}{/* opt\_len and static\_len in bytes */}
00918     \textcolor{keywordtype}{int} max\_blindex = 0;  \textcolor{comment}{/* index of last bit length code of non zero freq */}
00919 
00920     \textcolor{comment}{/* Build the Huffman trees unless a stored block is forced */}
00921     \textcolor{keywordflow}{if} (s->level > 0) \{
00922 
00923         \textcolor{comment}{/* Check if the file is binary or text */}
00924         \textcolor{keywordflow}{if} (s->strm->data\_type == Z\_UNKNOWN)
00925             s->strm->data\_type = detect\_data\_type(s);
00926 
00927         \textcolor{comment}{/* Construct the literal and distance trees */}
00928         build\_tree(s, (\hyperlink{structtree__desc__s}{tree\_desc} *)(&(s->l\_desc)));
00929         Tracev((stderr, \textcolor{stringliteral}{"\(\backslash\)nlit data: dyn %ld, stat %ld"}, s->opt\_len,
00930                 s->static\_len));
00931 
00932         build\_tree(s, (\hyperlink{structtree__desc__s}{tree\_desc} *)(&(s->d\_desc)));
00933         Tracev((stderr, \textcolor{stringliteral}{"\(\backslash\)ndist data: dyn %ld, stat %ld"}, s->opt\_len,
00934                 s->static\_len));
00935         \textcolor{comment}{/* At this point, opt\_len and static\_len are the total bit lengths of}
00936 \textcolor{comment}{         * the compressed block data, excluding the tree representations.}
00937 \textcolor{comment}{         */}
00938 
00939         \textcolor{comment}{/* Build the bit length tree for the above two trees, and get the index}
00940 \textcolor{comment}{         * in bl\_order of the last bit length code to send.}
00941 \textcolor{comment}{         */}
00942         max\_blindex = build\_bl\_tree(s);
00943 
00944         \textcolor{comment}{/* Determine the best encoding. Compute the block lengths in bytes. */}
00945         opt\_lenb = (s->opt\_len+3+7)>>3;
00946         static\_lenb = (s->static\_len+3+7)>>3;
00947 
00948         Tracev((stderr, \textcolor{stringliteral}{"\(\backslash\)nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u "},
00949                 opt\_lenb, s->opt\_len, static\_lenb, s->static\_len, stored\_len,
00950                 s->last\_lit));
00951 
00952         \textcolor{keywordflow}{if} (static\_lenb <= opt\_lenb) opt\_lenb = static\_lenb;
00953 
00954     \} \textcolor{keywordflow}{else} \{
00955         Assert(buf != (\textcolor{keywordtype}{char}*)0, \textcolor{stringliteral}{"lost buf"});
00956         opt\_lenb = static\_lenb = stored\_len + 5; \textcolor{comment}{/* force a stored block */}
00957     \}
00958 
00959 \textcolor{preprocessor}{#ifdef FORCE\_STORED}
00960     \textcolor{keywordflow}{if} (buf != (\textcolor{keywordtype}{char}*)0) \{ \textcolor{comment}{/* force stored block */}
00961 \textcolor{preprocessor}{#else}
00962     \textcolor{keywordflow}{if} (stored\_len+4 <= opt\_lenb && buf != (\textcolor{keywordtype}{char}*)0) \{
00963                        \textcolor{comment}{/* 4: two words for the lengths */}
00964 \textcolor{preprocessor}{#endif}
00965         \textcolor{comment}{/* The test buf != NULL is only necessary if LIT\_BUFSIZE > WSIZE.}
00966 \textcolor{comment}{         * Otherwise we can't have processed more than WSIZE input bytes since}
00967 \textcolor{comment}{         * the last block flush, because compression would have been}
00968 \textcolor{comment}{         * successful. If LIT\_BUFSIZE <= WSIZE, it is never too late to}
00969 \textcolor{comment}{         * transform a block into a stored block.}
00970 \textcolor{comment}{         */}
00971         \_tr\_stored\_block(s, buf, stored\_len, last);
00972 
00973 \textcolor{preprocessor}{#ifdef FORCE\_STATIC}
00974     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (static\_lenb >= 0) \{ \textcolor{comment}{/* force static trees */}
00975 \textcolor{preprocessor}{#else}
00976     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (s->strategy == Z\_FIXED || static\_lenb == opt\_lenb) \{
00977 \textcolor{preprocessor}{#endif}
00978         send\_bits(s, (STATIC\_TREES<<1)+last, 3);
00979         compress\_block(s, (\textcolor{keyword}{const} \hyperlink{structct__data__s}{ct\_data} *)static\_ltree,
00980                        (\textcolor{keyword}{const} \hyperlink{structct__data__s}{ct\_data} *)static\_dtree);
00981 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
00982         s->compressed\_len += 3 + s->static\_len;
00983 \textcolor{preprocessor}{#endif}
00984     \} \textcolor{keywordflow}{else} \{
00985         send\_bits(s, (DYN\_TREES<<1)+last, 3);
00986         send\_all\_trees(s, s->l\_desc.max\_code+1, s->d\_desc.max\_code+1,
00987                        max\_blindex+1);
00988         compress\_block(s, (\textcolor{keyword}{const} \hyperlink{structct__data__s}{ct\_data} *)s->dyn\_ltree,
00989                        (\textcolor{keyword}{const} \hyperlink{structct__data__s}{ct\_data} *)s->dyn\_dtree);
00990 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
00991         s->compressed\_len += 3 + s->opt\_len;
00992 \textcolor{preprocessor}{#endif}
00993     \}
00994     Assert (s->compressed\_len == s->bits\_sent, \textcolor{stringliteral}{"bad compressed size"});
00995     \textcolor{comment}{/* The above check is made mod 2^32, for files larger than 512 MB}
00996 \textcolor{comment}{     * and uLong implemented on 32 bits.}
00997 \textcolor{comment}{     */}
00998     init\_block(s);
00999 
01000     \textcolor{keywordflow}{if} (last) \{
01001         bi\_windup(s);
01002 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
01003         s->compressed\_len += 7;  \textcolor{comment}{/* align on byte boundary */}
01004 \textcolor{preprocessor}{#endif}
01005     \}
01006     Tracev((stderr,\textcolor{stringliteral}{"\(\backslash\)ncomprlen %lu(%lu) "}, s->compressed\_len>>3,
01007            s->compressed\_len-7*last));
01008 \}
01009 
01010 \textcolor{comment}{/* ===========================================================================}
01011 \textcolor{comment}{ * Save the match info and tally the frequency counts. Return true if}
01012 \textcolor{comment}{ * the current block must be flushed.}
01013 \textcolor{comment}{ */}
01014 \textcolor{keywordtype}{int} ZLIB\_INTERNAL \_tr\_tally (s, dist, lc)
01015     \hyperlink{structinternal__state}{deflate\_state} *s;
01016     \textcolor{keywordtype}{unsigned} dist;  \textcolor{comment}{/* distance of matched string */}
01017     \textcolor{keywordtype}{unsigned} lc;    \textcolor{comment}{/* match length-MIN\_MATCH or unmatched char (if dist==0) */}
01018 \{
01019     s->d\_buf[s->last\_lit] = (ush)dist;
01020     s->l\_buf[s->last\_lit++] = (uch)lc;
01021     \textcolor{keywordflow}{if} (dist == 0) \{
01022         \textcolor{comment}{/* lc is the unmatched char */}
01023         s->dyn\_ltree[lc].Freq++;
01024     \} \textcolor{keywordflow}{else} \{
01025         s->matches++;
01026         \textcolor{comment}{/* Here, lc is the match length - MIN\_MATCH */}
01027         dist--;             \textcolor{comment}{/* dist = match distance - 1 */}
01028         Assert((ush)dist < (ush)MAX\_DIST(s) &&
01029                (ush)lc <= (ush)(MAX\_MATCH-MIN\_MATCH) &&
01030                (ush)d\_code(dist) < (ush)D\_CODES,  \textcolor{stringliteral}{"\_tr\_tally: bad match"});
01031 
01032         s->dyn\_ltree[\_length\_code[lc]+LITERALS+1].Freq++;
01033         s->dyn\_dtree[d\_code(dist)].Freq++;
01034     \}
01035 
01036 \textcolor{preprocessor}{#ifdef TRUNCATE\_BLOCK}
01037     \textcolor{comment}{/* Try to guess if it is profitable to stop the current block here */}
01038     \textcolor{keywordflow}{if} ((s->last\_lit & 0x1fff) == 0 && s->level > 2) \{
01039         \textcolor{comment}{/* Compute an upper bound for the compressed length */}
01040         ulg out\_length = (ulg)s->last\_lit*8L;
01041         ulg in\_length = (ulg)((long)s->strstart - s->block\_start);
01042         \textcolor{keywordtype}{int} dcode;
01043         \textcolor{keywordflow}{for} (dcode = 0; dcode < D\_CODES; dcode++) \{
01044             out\_length += (ulg)s->dyn\_dtree[dcode].Freq *
01045                 (5L+extra\_dbits[dcode]);
01046         \}
01047         out\_length >>= 3;
01048         Tracev((stderr,\textcolor{stringliteral}{"\(\backslash\)nlast\_lit %u, in %ld, out ~%ld(%ld%%) "},
01049                s->last\_lit, in\_length, out\_length,
01050                100L - out\_length*100L/in\_length));
01051         \textcolor{keywordflow}{if} (s->matches < s->last\_lit/2 && out\_length < in\_length/2) \textcolor{keywordflow}{return} 1;
01052     \}
01053 \textcolor{preprocessor}{#endif}
01054     \textcolor{keywordflow}{return} (s->last\_lit == s->lit\_bufsize-1);
01055     \textcolor{comment}{/* We avoid equality with lit\_bufsize because of wraparound at 64K}
01056 \textcolor{comment}{     * on 16 bit machines and because stored blocks are restricted to}
01057 \textcolor{comment}{     * 64K-1 bytes.}
01058 \textcolor{comment}{     */}
01059 \}
01060 
01061 \textcolor{comment}{/* ===========================================================================}
01062 \textcolor{comment}{ * Send the block data compressed using the given Huffman trees}
01063 \textcolor{comment}{ */}
01064 local \textcolor{keywordtype}{void} compress\_block(s, ltree, dtree)
01065     \hyperlink{structinternal__state}{deflate\_state} *s;
01066     \textcolor{keyword}{const} \hyperlink{structct__data__s}{ct\_data} *ltree; \textcolor{comment}{/* literal tree */}
01067     \textcolor{keyword}{const} \hyperlink{structct__data__s}{ct\_data} *dtree; \textcolor{comment}{/* distance tree */}
01068 \{
01069     \textcolor{keywordtype}{unsigned} dist;      \textcolor{comment}{/* distance of matched string */}
01070     \textcolor{keywordtype}{int} lc;             \textcolor{comment}{/* match length or unmatched char (if dist == 0) */}
01071     \textcolor{keywordtype}{unsigned} lx = 0;    \textcolor{comment}{/* running index in l\_buf */}
01072     \textcolor{keywordtype}{unsigned} code;      \textcolor{comment}{/* the code to send */}
01073     \textcolor{keywordtype}{int} extra;          \textcolor{comment}{/* number of extra bits to send */}
01074 
01075     \textcolor{keywordflow}{if} (s->last\_lit != 0) \textcolor{keywordflow}{do} \{
01076         dist = s->d\_buf[lx];
01077         lc = s->l\_buf[lx++];
01078         \textcolor{keywordflow}{if} (dist == 0) \{
01079             send\_code(s, lc, ltree); \textcolor{comment}{/* send a literal byte */}
01080             Tracecv(isgraph(lc), (stderr,\textcolor{stringliteral}{" '%c' "}, lc));
01081         \} \textcolor{keywordflow}{else} \{
01082             \textcolor{comment}{/* Here, lc is the match length - MIN\_MATCH */}
01083             code = \_length\_code[lc];
01084             send\_code(s, code+LITERALS+1, ltree); \textcolor{comment}{/* send the length code */}
01085             extra = extra\_lbits[code];
01086             \textcolor{keywordflow}{if} (extra != 0) \{
01087                 lc -= base\_length[code];
01088                 send\_bits(s, lc, extra);       \textcolor{comment}{/* send the extra length bits */}
01089             \}
01090             dist--; \textcolor{comment}{/* dist is now the match distance - 1 */}
01091             code = d\_code(dist);
01092             Assert (code < D\_CODES, \textcolor{stringliteral}{"bad d\_code"});
01093 
01094             send\_code(s, code, dtree);       \textcolor{comment}{/* send the distance code */}
01095             extra = extra\_dbits[code];
01096             \textcolor{keywordflow}{if} (extra != 0) \{
01097                 dist -= (unsigned)base\_dist[code];
01098                 send\_bits(s, dist, extra);   \textcolor{comment}{/* send the extra distance bits */}
01099             \}
01100         \} \textcolor{comment}{/* literal or match pair ? */}
01101 
01102         \textcolor{comment}{/* Check that the overlay between pending\_buf and d\_buf+l\_buf is ok: */}
01103         Assert((uInt)(s->pending) < s->lit\_bufsize + 2*lx,
01104                \textcolor{stringliteral}{"pendingBuf overflow"});
01105 
01106     \} \textcolor{keywordflow}{while} (lx < s->last\_lit);
01107 
01108     send\_code(s, END\_BLOCK, ltree);
01109 \}
01110 
01111 \textcolor{comment}{/* ===========================================================================}
01112 \textcolor{comment}{ * Check if the data type is TEXT or BINARY, using the following algorithm:}
01113 \textcolor{comment}{ * - TEXT if the two conditions below are satisfied:}
01114 \textcolor{comment}{ *    a) There are no non-portable control characters belonging to the}
01115 \textcolor{comment}{ *       "black list" (0..6, 14..25, 28..31).}
01116 \textcolor{comment}{ *    b) There is at least one printable character belonging to the}
01117 \textcolor{comment}{ *       "white list" (9 \{TAB\}, 10 \{LF\}, 13 \{CR\}, 32..255).}
01118 \textcolor{comment}{ * - BINARY otherwise.}
01119 \textcolor{comment}{ * - The following partially-portable control characters form a}
01120 \textcolor{comment}{ *   "gray list" that is ignored in this detection algorithm:}
01121 \textcolor{comment}{ *   (7 \{BEL\}, 8 \{BS\}, 11 \{VT\}, 12 \{FF\}, 26 \{SUB\}, 27 \{ESC\}).}
01122 \textcolor{comment}{ * IN assertion: the fields Freq of dyn\_ltree are set.}
01123 \textcolor{comment}{ */}
01124 local \textcolor{keywordtype}{int} detect\_data\_type(s)
01125     \hyperlink{structinternal__state}{deflate\_state} *s;
01126 \{
01127     \textcolor{comment}{/* black\_mask is the bit mask of black-listed bytes}
01128 \textcolor{comment}{     * set bits 0..6, 14..25, and 28..31}
01129 \textcolor{comment}{     * 0xf3ffc07f = binary 11110011111111111100000001111111}
01130 \textcolor{comment}{     */}
01131     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} black\_mask = 0xf3ffc07fUL;
01132     \textcolor{keywordtype}{int} n;
01133 
01134     \textcolor{comment}{/* Check for non-textual ("black-listed") bytes. */}
01135     \textcolor{keywordflow}{for} (n = 0; n <= 31; n++, black\_mask >>= 1)
01136         \textcolor{keywordflow}{if} ((black\_mask & 1) && (s->dyn\_ltree[n].Freq != 0))
01137             \textcolor{keywordflow}{return} Z\_BINARY;
01138 
01139     \textcolor{comment}{/* Check for textual ("white-listed") bytes. */}
01140     \textcolor{keywordflow}{if} (s->dyn\_ltree[9].Freq != 0 || s->dyn\_ltree[10].Freq != 0
01141             || s->dyn\_ltree[13].Freq != 0)
01142         \textcolor{keywordflow}{return} Z\_TEXT;
01143     \textcolor{keywordflow}{for} (n = 32; n < LITERALS; n++)
01144         \textcolor{keywordflow}{if} (s->dyn\_ltree[n].Freq != 0)
01145             \textcolor{keywordflow}{return} Z\_TEXT;
01146 
01147     \textcolor{comment}{/* There are no "black-listed" or "white-listed" bytes:}
01148 \textcolor{comment}{     * this stream either is empty or has tolerated ("gray-listed") bytes only.}
01149 \textcolor{comment}{     */}
01150     \textcolor{keywordflow}{return} Z\_BINARY;
01151 \}
01152 
01153 \textcolor{comment}{/* ===========================================================================}
01154 \textcolor{comment}{ * Reverse the first len bits of a code, using straightforward code (a faster}
01155 \textcolor{comment}{ * method would use a table)}
01156 \textcolor{comment}{ * IN assertion: 1 <= len <= 15}
01157 \textcolor{comment}{ */}
01158 local \textcolor{keywordtype}{unsigned} bi\_reverse(code, len)
01159     \textcolor{keywordtype}{unsigned} code; \textcolor{comment}{/* the value to invert */}
01160     \textcolor{keywordtype}{int} len;       \textcolor{comment}{/* its bit length */}
01161 \{
01162     \textcolor{keyword}{register} \textcolor{keywordtype}{unsigned} res = 0;
01163     \textcolor{keywordflow}{do} \{
01164         res |= code & 1;
01165         code >>= 1, res <<= 1;
01166     \} \textcolor{keywordflow}{while} (--len > 0);
01167     \textcolor{keywordflow}{return} res >> 1;
01168 \}
01169 
01170 \textcolor{comment}{/* ===========================================================================}
01171 \textcolor{comment}{ * Flush the bit buffer, keeping at most 7 bits in it.}
01172 \textcolor{comment}{ */}
01173 local \textcolor{keywordtype}{void} bi\_flush(s)
01174     \hyperlink{structinternal__state}{deflate\_state} *s;
01175 \{
01176     \textcolor{keywordflow}{if} (s->bi\_valid == 16) \{
01177         put\_short(s, s->bi\_buf);
01178         s->bi\_buf = 0;
01179         s->bi\_valid = 0;
01180     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (s->bi\_valid >= 8) \{
01181         put\_byte(s, (Byte)s->bi\_buf);
01182         s->bi\_buf >>= 8;
01183         s->bi\_valid -= 8;
01184     \}
01185 \}
01186 
01187 \textcolor{comment}{/* ===========================================================================}
01188 \textcolor{comment}{ * Flush the bit buffer and align the output on a byte boundary}
01189 \textcolor{comment}{ */}
01190 local \textcolor{keywordtype}{void} bi\_windup(s)
01191     \hyperlink{structinternal__state}{deflate\_state} *s;
01192 \{
01193     \textcolor{keywordflow}{if} (s->bi\_valid > 8) \{
01194         put\_short(s, s->bi\_buf);
01195     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (s->bi\_valid > 0) \{
01196         put\_byte(s, (Byte)s->bi\_buf);
01197     \}
01198     s->bi\_buf = 0;
01199     s->bi\_valid = 0;
01200 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
01201     s->bits\_sent = (s->bits\_sent+7) & ~7;
01202 \textcolor{preprocessor}{#endif}
01203 \}
\end{DoxyCode}
