\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u__kernel__bmod_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+L\+U/\+Sparse\+L\+U\+\_\+kernel\+\_\+bmod.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u__kernel__bmod_8h_source}\index{Sparse\+L\+U\+\_\+kernel\+\_\+bmod.\+h@{Sparse\+L\+U\+\_\+kernel\+\_\+bmod.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2012 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef SPARSELU\_KERNEL\_BMOD\_H}
00012 \textcolor{preprocessor}{#define SPARSELU\_KERNEL\_BMOD\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016   
00017 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} SegSizeAtCompileTime> \textcolor{keyword}{struct }LU\_kernel\_bmod
00018 \{
00032   \textcolor{keyword}{template} <\textcolor{keyword}{typename} BlockScalarVector, \textcolor{keyword}{typename} ScalarVector, \textcolor{keyword}{typename} IndexVector>
00033   \textcolor{keyword}{static} EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} segsize, BlockScalarVector& dense, ScalarVector& tempv
      , ScalarVector& lusup, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& luptr, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lda,
00034                                     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nrow, IndexVector& lsub, \textcolor{keyword}{const} 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lptr, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} no\_zeros);
00035 \};
00036 
00037 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} SegSizeAtCompileTime>
00038 \textcolor{keyword}{template} <\textcolor{keyword}{typename} BlockScalarVector, \textcolor{keyword}{typename} ScalarVector, \textcolor{keyword}{typename} IndexVector>
00039 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} LU\_kernel\_bmod<SegSizeAtCompileTime>::run(\textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} segsize, 
      BlockScalarVector& dense, ScalarVector& tempv, ScalarVector& lusup, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& luptr, \textcolor{keyword}{const} 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lda,
00040                                                                   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nrow, IndexVector& lsub,
       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lptr, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} no\_zeros)
00041 \{
00042   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarVector::Scalar Scalar;
00043   \textcolor{comment}{// First, copy U[*,j] segment from dense(*) to tempv(*)}
00044   \textcolor{comment}{// The result of triangular solve is in tempv[*]; }
00045     \textcolor{comment}{// The result of matric-vector update is in dense[*]}
00046   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} isub = lptr + no\_zeros; 
00047   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i;
00048   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} irow;
00049   \textcolor{keywordflow}{for} (i = 0; i < ((SegSizeAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic})?segsize:SegSizeAtCompileTime); i++)
00050   \{
00051     irow = lsub(isub); 
00052     tempv(i) = dense(irow); 
00053     ++isub; 
00054   \}
00055   \textcolor{comment}{// Dense triangular solve -- start effective triangle}
00056   luptr += lda * no\_zeros + no\_zeros; 
00057   \textcolor{comment}{// Form Eigen matrix and vector }
00058   Map<Matrix<Scalar,SegSizeAtCompileTime,SegSizeAtCompileTime, ColMajor>, 0, OuterStride<> > A( &(lusup.
      data()[luptr]), segsize, segsize, OuterStride<>(lda) );
00059   Map<Matrix<Scalar,SegSizeAtCompileTime,1> > u(tempv.data(), segsize);
00060   
00061   u = A.template triangularView<UnitLower>().solve(u); 
00062   
00063   \textcolor{comment}{// Dense matrix-vector product y <-- B*x }
00064   luptr += segsize;
00065   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} PacketSize = internal::packet\_traits<Scalar>::size;
00066   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} ldl = internal::first\_multiple(nrow, PacketSize);
00067   Map<Matrix<Scalar,Dynamic,SegSizeAtCompileTime, ColMajor>, 0, OuterStride<> > B( &(lusup.data()[luptr]), 
      nrow, segsize, OuterStride<>(lda) );
00068   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} aligned\_offset = internal::first\_default\_aligned(tempv.data()+segsize, PacketSize);
00069   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} aligned\_with\_B\_offset = (PacketSize-internal::first\_default\_aligned(B.data(), PacketSize))%
      PacketSize;
00070   Map<Matrix<Scalar,Dynamic,1>, 0, OuterStride<> > l(tempv.data()+segsize+aligned\_offset+
      aligned\_with\_B\_offset, nrow, OuterStride<>(ldl) );
00071   
00072   l.setZero();
00073   internal::sparselu\_gemm<Scalar>(l.rows(), l.cols(), B.cols(), B.data(), B.outerStride(), u.data(), u.
      outerStride(), l.data(), l.outerStride());
00074   
00075   \textcolor{comment}{// Scatter tempv[] into SPA dense[] as a temporary storage }
00076   isub = lptr + no\_zeros;
00077   \textcolor{keywordflow}{for} (i = 0; i < ((SegSizeAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic})?segsize:SegSizeAtCompileTime); i++)
00078   \{
00079     irow = lsub(isub++); 
00080     dense(irow) = tempv(i);
00081   \}
00082   
00083   \textcolor{comment}{// Scatter l into SPA dense[]}
00084   \textcolor{keywordflow}{for} (i = 0; i < nrow; i++)
00085   \{
00086     irow = lsub(isub++); 
00087     dense(irow) -= l(i);
00088   \} 
00089 \}
00090 
00091 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }LU\_kernel\_bmod<1>
00092 \{
00093   \textcolor{keyword}{template} <\textcolor{keyword}{typename} BlockScalarVector, \textcolor{keyword}{typename} ScalarVector, \textcolor{keyword}{typename} IndexVector>
00094   \textcolor{keyword}{static} EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \textcolor{comment}{/*segsize*/}, BlockScalarVector& dense, ScalarVector& \textcolor{comment}{
      /*tempv*/}, ScalarVector& lusup, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& luptr,
00095                                     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lda, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nrow, IndexVector& lsub, \textcolor{keyword}{const} 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lptr, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} no\_zeros);
00096 \};
00097 
00098 
00099 \textcolor{keyword}{template} <\textcolor{keyword}{typename} BlockScalarVector, \textcolor{keyword}{typename} ScalarVector, \textcolor{keyword}{typename} IndexVector>
00100 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} LU\_kernel\_bmod<1>::run(\textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \textcolor{comment}{/*segsize*/}, BlockScalarVector& dense, 
      ScalarVector& \textcolor{comment}{/*tempv*/}, ScalarVector& lusup, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& luptr,
00101                                               \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lda, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nrow, IndexVector& 
      lsub, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lptr, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} no\_zeros)
00102 \{
00103   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarVector::Scalar Scalar;
00104   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} IndexVector::Scalar StorageIndex;
00105   Scalar f = dense(lsub(lptr + no\_zeros));
00106   luptr += lda * no\_zeros + no\_zeros + 1;
00107   \textcolor{keyword}{const} Scalar* a(lusup.data() + luptr);
00108   \textcolor{keyword}{const} StorageIndex*  irow(lsub.data()+lptr + no\_zeros + 1);
00109   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0;
00110   \textcolor{keywordflow}{for} (; i+1 < nrow; i+=2)
00111   \{
00112     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i0 = *(irow++);
00113     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i1 = *(irow++);
00114     Scalar a0 = *(a++);
00115     Scalar a1 = *(a++);
00116     Scalar d0 = dense.coeff(i0);
00117     Scalar d1 = dense.coeff(i1);
00118     d0 -= f*a0;
00119     d1 -= f*a1;
00120     dense.coeffRef(i0) = d0;
00121     dense.coeffRef(i1) = d1;
00122   \}
00123   \textcolor{keywordflow}{if}(i<nrow)
00124     dense.coeffRef(*(irow++)) -= f * *(a++);
00125 \}
00126 
00127 \} \textcolor{comment}{// end namespace internal}
00128 
00129 \} \textcolor{comment}{// end namespace Eigen}
00130 \textcolor{preprocessor}{#endif // SPARSELU\_KERNEL\_BMOD\_H}
\end{DoxyCode}
