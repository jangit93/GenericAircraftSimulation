\hypertarget{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4}{}\section{Eigen\+:\+:internal\+:\+:Full\+Reducer$<$ Self, Op, const Eigen\+:\+:Sycl\+Device, Vectorizable $>$ Struct Template Reference}
\label{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4}\index{Eigen\+::internal\+::\+Full\+Reducer$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$@{Eigen\+::internal\+::\+Full\+Reducer$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$}}


{\ttfamily \#include $<$Tensor\+Reduction\+Sycl.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_aa02e68b933cb294854a8dd61a3952962}\label{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_aa02e68b933cb294854a8dd61a3952962}} 
typedef Self\+::\+Coeff\+Return\+Type {\bfseries Coeff\+Return\+Type}
\item 
\mbox{\Hypertarget{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_aa02e68b933cb294854a8dd61a3952962}\label{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_aa02e68b933cb294854a8dd61a3952962}} 
typedef Self\+::\+Coeff\+Return\+Type {\bfseries Coeff\+Return\+Type}
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_aee608a1f9a8dca2b99477c2738357c05}{run} (const Self \&self, Op \&reducer, const Eigen\+::\+Sycl\+Device \&dev, Coeff\+Return\+Type $\ast$output)
\item 
static void \hyperlink{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_aee608a1f9a8dca2b99477c2738357c05}{run} (const Self \&self, Op \&reducer, const Eigen\+::\+Sycl\+Device \&dev, Coeff\+Return\+Type $\ast$output)
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_ad34ed0cca9c578fc6611f1197a6d76bf}\label{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_ad34ed0cca9c578fc6611f1197a6d76bf}} 
static const bool {\bfseries Has\+Optimized\+Implementation} = false
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Self, typename Op, bool Vectorizable$>$\newline
struct Eigen\+::internal\+::\+Full\+Reducer$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$}

For now let\textquotesingle{}s start with a full reducer Self is useless here because in expression construction we are going to treat reduction as a leafnode. we want to take reduction child and then build a construction and apply the full reducer function on it. Fullreducre applies the reduction operation on the child of the reduction. once it is done the reduction is an empty shell and can be thrown away and treated as 

Definition at line \hyperlink{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source_l00103}{103} of file \hyperlink{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source}{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Reduction\+Sycl.\+h}.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_aee608a1f9a8dca2b99477c2738357c05}\label{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_aee608a1f9a8dca2b99477c2738357c05}} 
\index{Eigen\+::internal\+::\+Full\+Reducer$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$@{Eigen\+::internal\+::\+Full\+Reducer$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$}!run@{run}}
\index{run@{run}!Eigen\+::internal\+::\+Full\+Reducer$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$@{Eigen\+::internal\+::\+Full\+Reducer$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$}}
\subsubsection{\texorpdfstring{run()}{run()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Self , typename Op , bool Vectorizable$>$ \\
static void \hyperlink{struct_eigen_1_1internal_1_1_full_reducer}{Eigen\+::internal\+::\+Full\+Reducer}$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$\+::run (\begin{DoxyParamCaption}\item[{const Self \&}]{self,  }\item[{Op \&}]{reducer,  }\item[{const Eigen\+::\+Sycl\+Device \&}]{dev,  }\item[{Coeff\+Return\+Type $\ast$}]{output }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

this is the child of reduction

initial reduction. If the size is less than red\+\_\+factor we only creates one thread.

if the shared memory is less than the G\+Range, we set shared\+\_\+mem size to the Total\+Size and in this case one kernel would be created for recursion to reduce all to one.

creating the shared memory for calculating reduction. This one is used to collect all the reduced value of shared memory as we dont have global barrier on G\+PU. Once it is saved we can recursively apply reduction on it in order to reduce the whole.

reduction cannot be captured automatically through our device conversion recursion. The reason is that reduction has two behaviour the first behaviour is when it is used as a root to lauch the sub-\/kernel. The second one is when it is treated as a leafnode to pass the calculated result to its parent kernel. While the latter is automatically detected through our device expression generator. The former is created here.

This is the evaluator for device\+\_\+self\+\_\+expr. This is exactly similar to the self which has been passed to run function. The difference is the device\+\_\+evaluator is detectable and recognisable on the device.

const cast added as a naive solution to solve the qualifier drop error

This is used to recursively reduce the tmp value to an element of 1; 

Definition at line \hyperlink{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source_l00108}{108} of file \hyperlink{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source}{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Reduction\+Sycl.\+h}.

\mbox{\Hypertarget{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_aee608a1f9a8dca2b99477c2738357c05}\label{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_aee608a1f9a8dca2b99477c2738357c05}} 
\index{Eigen\+::internal\+::\+Full\+Reducer$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$@{Eigen\+::internal\+::\+Full\+Reducer$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$}!run@{run}}
\index{run@{run}!Eigen\+::internal\+::\+Full\+Reducer$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$@{Eigen\+::internal\+::\+Full\+Reducer$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$}}
\subsubsection{\texorpdfstring{run()}{run()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Self , typename Op , bool Vectorizable$>$ \\
static void \hyperlink{struct_eigen_1_1internal_1_1_full_reducer}{Eigen\+::internal\+::\+Full\+Reducer}$<$ Self, Op, const Eigen\+::\+Sycl\+Device, Vectorizable $>$\+::run (\begin{DoxyParamCaption}\item[{const Self \&}]{self,  }\item[{Op \&}]{reducer,  }\item[{const Eigen\+::\+Sycl\+Device \&}]{dev,  }\item[{Coeff\+Return\+Type $\ast$}]{output }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

this is the child of reduction

initial reduction. If the size is less than red\+\_\+factor we only creates one thread.

if the shared memory is less than the G\+Range, we set shared\+\_\+mem size to the Total\+Size and in this case one kernel would be created for recursion to reduce all to one.

creating the shared memory for calculating reduction. This one is used to collect all the reduced value of shared memory as we dont have global barrier on G\+PU. Once it is saved we can recursively apply reduction on it in order to reduce the whole.

reduction cannot be captured automatically through our device conversion recursion. The reason is that reduction has two behaviour the first behaviour is when it is used as a root to lauch the sub-\/kernel. The second one is when it is treated as a leafnode to pass the calculated result to its parent kernel. While the latter is automatically detected through our device expression generator. The former is created here.

This is the evaluator for device\+\_\+self\+\_\+expr. This is exactly similar to the self which has been passed to run function. The difference is the device\+\_\+evaluator is detectable and recognisable on the device.

const cast added as a naive solution to solve the qualifier drop error

This is used to recursively reduce the tmp value to an element of 1; 

Definition at line \hyperlink{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source_l00108}{108} of file \hyperlink{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source}{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Reduction\+Sycl.\+h}.



The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Reduction\+Sycl.\+h\end{DoxyCompactItemize}
