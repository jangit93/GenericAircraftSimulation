\hypertarget{eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_inplace_l_u_8h_source}{}\section{eigen/unsupported/\+Eigen/src/\+Skyline/\+Skyline\+Inplace\+LU.h}
\label{eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_inplace_l_u_8h_source}\index{Skyline\+Inplace\+L\+U.\+h@{Skyline\+Inplace\+L\+U.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Guillaume Saupin <guillaume.saupin@cea.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SKYLINEINPLACELU\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SKYLINEINPLACELU\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00024 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_inplace_l_u_8h_source_l00025}\hyperlink{class_eigen_1_1_skyline_inplace_l_u}{00025} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_skyline_inplace_l_u}{SkylineInplaceLU} \{
00026 \textcolor{keyword}{protected}:
00027     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00028     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index Index;
00029     
00030     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename MatrixType::Scalar>::Real}
       RealScalar;
00031 
00032 \textcolor{keyword}{public}:
00033 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_inplace_l_u_8h_source_l00036}\hyperlink{class_eigen_1_1_skyline_inplace_l_u_ac76b9384281e73b86b80f770015cf436}{00036}     \hyperlink{class_eigen_1_1_skyline_inplace_l_u_ac76b9384281e73b86b80f770015cf436}{SkylineInplaceLU}(MatrixType& matrix, \textcolor{keywordtype}{int} \hyperlink{class_eigen_1_1_skyline_inplace_l_u_a5e491f7643c548ac81d3f4a7e432be19}{flags} = 0)
00037     : \textcolor{comment}{/*m\_matrix(matrix.rows(), matrix.cols()),*/} m\_flags(\hyperlink{class_eigen_1_1_skyline_inplace_l_u_a5e491f7643c548ac81d3f4a7e432be19}{flags}), m\_status(0), m\_lu(matrix) \{
00038         m\_precision = RealScalar(0.1) * Eigen::dummy\_precision<RealScalar > ();
00039         m\_lu.IsRowMajor ? computeRowMajor() : \hyperlink{class_eigen_1_1_skyline_inplace_l_u_a590e9a988b2843712a29a541787e6c38}{compute}();
00040     \}
00041 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_inplace_l_u_8h_source_l00052}\hyperlink{class_eigen_1_1_skyline_inplace_l_u_a1c057a7dec39b8b196d49d7d411ea999}{00052}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_skyline_inplace_l_u_a1c057a7dec39b8b196d49d7d411ea999}{setPrecision}(RealScalar v) \{
00053         m\_precision = v;
00054     \}
00055 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_inplace_l_u_8h_source_l00059}\hyperlink{class_eigen_1_1_skyline_inplace_l_u_a050bcbe008f2ddeea4f6d5872e0daca5}{00059}     RealScalar \hyperlink{class_eigen_1_1_skyline_inplace_l_u_a050bcbe008f2ddeea4f6d5872e0daca5}{precision}()\textcolor{keyword}{ const }\{
00060         \textcolor{keywordflow}{return} m\_precision;
00061     \}
00062 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_inplace_l_u_8h_source_l00071}\hyperlink{class_eigen_1_1_skyline_inplace_l_u_afd8013d183aaca495dfd10d819e61aaf}{00071}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_skyline_inplace_l_u_afd8013d183aaca495dfd10d819e61aaf}{setFlags}(\textcolor{keywordtype}{int} f) \{
00072         m\_flags = f;
00073     \}
00074 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_inplace_l_u_8h_source_l00076}\hyperlink{class_eigen_1_1_skyline_inplace_l_u_a5e491f7643c548ac81d3f4a7e432be19}{00076}     \textcolor{keywordtype}{int} \hyperlink{class_eigen_1_1_skyline_inplace_l_u_a5e491f7643c548ac81d3f4a7e432be19}{flags}()\textcolor{keyword}{ const }\{
00077         \textcolor{keywordflow}{return} m\_flags;
00078     \}
00079 
00080     \textcolor{keywordtype}{void} setOrderingMethod(\textcolor{keywordtype}{int} m) \{
00081         m\_flags = m;
00082     \}
00083 
00084     \textcolor{keywordtype}{int} orderingMethod()\textcolor{keyword}{ const }\{
00085         \textcolor{keywordflow}{return} m\_flags;
00086     \}
00087 
00089     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_skyline_inplace_l_u_a590e9a988b2843712a29a541787e6c38}{compute}();
00090     \textcolor{keywordtype}{void} computeRowMajor();
00091 
00093     \textcolor{comment}{//inline const MatrixType& matrixL() const \{ return m\_matrixL; \}}
00094 
00096     \textcolor{comment}{//inline const MatrixType& matrixU() const \{ return m\_matrixU; \}}
00097 
00098     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BDerived, \textcolor{keyword}{typename} XDerived>
00099     \textcolor{keywordtype}{bool} \hyperlink{class_eigen_1_1_skyline_inplace_l_u_a53c846d76559221d2bcf336a2da4d68f}{solve}(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<BDerived>} &b, 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<XDerived>}* x,
00100             \textcolor{keyword}{const} \textcolor{keywordtype}{int} transposed = 0) \textcolor{keyword}{const};
00101 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_inplace_l_u_8h_source_l00103}\hyperlink{class_eigen_1_1_skyline_inplace_l_u_abd633c27a0a342fb392b6af3ceb800ba}{00103}     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \hyperlink{class_eigen_1_1_skyline_inplace_l_u_abd633c27a0a342fb392b6af3ceb800ba}{succeeded}(\textcolor{keywordtype}{void})\textcolor{keyword}{ const }\{
00104         \textcolor{keywordflow}{return} m\_succeeded;
00105     \}
00106 
00107 \textcolor{keyword}{protected}:
00108     RealScalar m\_precision;
00109     \textcolor{keywordtype}{int} m\_flags;
00110     \textcolor{keyword}{mutable} \textcolor{keywordtype}{int} m\_status;
00111     \textcolor{keywordtype}{bool} m\_succeeded;
00112     MatrixType& m\_lu;
00113 \};
00114 
00118 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00119 \textcolor{comment}{//template<typename \_Scalar>}
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_inplace_l_u_8h_source_l00120}\hyperlink{class_eigen_1_1_skyline_inplace_l_u_a590e9a988b2843712a29a541787e6c38}{00120} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_skyline_inplace_l_u_a590e9a988b2843712a29a541787e6c38}{SkylineInplaceLU<MatrixType>::compute}() \{
00121     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} rows = m\_lu.rows();
00122     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} cols = m\_lu.cols();
00123 
00124     eigen\_assert(rows == cols && \textcolor{stringliteral}{"We do not (yet) support rectangular LU."});
00125     eigen\_assert(!m\_lu.IsRowMajor && \textcolor{stringliteral}{"LU decomposition does not work with rowMajor Storage"});
00126 
00127     \textcolor{keywordflow}{for} (Index row = 0; row < rows; row++) \{
00128         \textcolor{keyword}{const} \textcolor{keywordtype}{double} pivot = m\_lu.coeffDiag(row);
00129 
00130         \textcolor{comment}{//Lower matrix Columns update}
00131         \textcolor{keyword}{const} Index& col = row;
00132         \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} MatrixType::InnerLowerIterator lIt(m\_lu, col); lIt; ++lIt) \{
00133             lIt.valueRef() /= pivot;
00134         \}
00135 
00136         \textcolor{comment}{//Upper matrix update -> contiguous memory access}
00137         \textcolor{keyword}{typename} MatrixType::InnerLowerIterator lIt(m\_lu, col);
00138         \textcolor{keywordflow}{for} (Index rrow = row + 1; rrow < m\_lu.rows(); rrow++) \{
00139             \textcolor{keyword}{typename} MatrixType::InnerUpperIterator uItPivot(m\_lu, row);
00140             \textcolor{keyword}{typename} MatrixType::InnerUpperIterator uIt(m\_lu, rrow);
00141             \textcolor{keyword}{const} \textcolor{keywordtype}{double} coef = lIt.value();
00142 
00143             uItPivot += (rrow - row - 1);
00144 
00145             \textcolor{comment}{//update upper part  -> contiguous memory access}
00146             \textcolor{keywordflow}{for} (++uItPivot; uIt && uItPivot;) \{
00147                 uIt.valueRef() -= uItPivot.value() * coef;
00148 
00149                 ++uIt;
00150                 ++uItPivot;
00151             \}
00152             ++lIt;
00153         \}
00154 
00155         \textcolor{comment}{//Upper matrix update -> non contiguous memory access}
00156         \textcolor{keyword}{typename} MatrixType::InnerLowerIterator lIt3(m\_lu, col);
00157         \textcolor{keywordflow}{for} (Index rrow = row + 1; rrow < m\_lu.rows(); rrow++) \{
00158             \textcolor{keyword}{typename} MatrixType::InnerUpperIterator uItPivot(m\_lu, row);
00159             \textcolor{keyword}{const} \textcolor{keywordtype}{double} coef = lIt3.value();
00160 
00161             \textcolor{comment}{//update lower part ->  non contiguous memory access}
00162             \textcolor{keywordflow}{for} (Index i = 0; i < rrow - row - 1; i++) \{
00163                 m\_lu.coeffRefLower(rrow, row + i + 1) -= uItPivot.value() * coef;
00164                 ++uItPivot;
00165             \}
00166             ++lIt3;
00167         \}
00168         \textcolor{comment}{//update diag -> contiguous}
00169         \textcolor{keyword}{typename} MatrixType::InnerLowerIterator lIt2(m\_lu, col);
00170         \textcolor{keywordflow}{for} (Index rrow = row + 1; rrow < m\_lu.rows(); rrow++) \{
00171 
00172             \textcolor{keyword}{typename} MatrixType::InnerUpperIterator uItPivot(m\_lu, row);
00173             \textcolor{keyword}{typename} MatrixType::InnerUpperIterator uIt(m\_lu, rrow);
00174             \textcolor{keyword}{const} \textcolor{keywordtype}{double} coef = lIt2.value();
00175 
00176             uItPivot += (rrow - row - 1);
00177             m\_lu.coeffRefDiag(rrow) -= uItPivot.value() * coef;
00178             ++lIt2;
00179         \}
00180     \}
00181 \}
00182 
00183 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00184 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_skyline_inplace_l_u}{SkylineInplaceLU<MatrixType>::computeRowMajor}() \{
00185     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} rows = m\_lu.rows();
00186     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} cols = m\_lu.cols();
00187 
00188     eigen\_assert(rows == cols && \textcolor{stringliteral}{"We do not (yet) support rectangular LU."});
00189     eigen\_assert(m\_lu.IsRowMajor && \textcolor{stringliteral}{"You're trying to apply rowMajor decomposition on a ColMajor matrix !"})
      ;
00190 
00191     \textcolor{keywordflow}{for} (Index row = 0; row < rows; row++) \{
00192         \textcolor{keyword}{typename} MatrixType::InnerLowerIterator llIt(m\_lu, row);
00193 
00194 
00195         \textcolor{keywordflow}{for} (Index col = llIt.col(); col < row; col++) \{
00196             \textcolor{keywordflow}{if} (m\_lu.coeffExistLower(row, col)) \{
00197                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} diag = m\_lu.coeffDiag(col);
00198 
00199                 \textcolor{keyword}{typename} MatrixType::InnerLowerIterator lIt(m\_lu, row);
00200                 \textcolor{keyword}{typename} MatrixType::InnerUpperIterator uIt(m\_lu, col);
00201 
00202 
00203                 \textcolor{keyword}{const} Index offset = lIt.col() - uIt.row();
00204 
00205 
00206                 Index stop = offset > 0 ? col - lIt.col() : col - uIt.row();
00207 
00208                 \textcolor{comment}{//#define VECTORIZE}
00209 \textcolor{preprocessor}{#ifdef VECTORIZE}
00210                 \hyperlink{group___core___module_class_eigen_1_1_map}{Map<VectorXd >} rowVal(lIt.valuePtr() + (offset > 0 ? 0 : -offset), stop);
00211                 \hyperlink{group___core___module_class_eigen_1_1_map}{Map<VectorXd >} colVal(uIt.valuePtr() + (offset > 0 ? offset : 0), stop);
00212 
00213 
00214                 Scalar newCoeff = m\_lu.coeffLower(row, col) - rowVal.dot(colVal);
00215 \textcolor{preprocessor}{#else}
00216                 \textcolor{keywordflow}{if} (offset > 0) \textcolor{comment}{//Skip zero value of lIt}
00217                     uIt += offset;
00218                 \textcolor{keywordflow}{else} \textcolor{comment}{//Skip zero values of uIt}
00219                     lIt += -offset;
00220                 Scalar newCoeff = m\_lu.coeffLower(row, col);
00221 
00222                 \textcolor{keywordflow}{for} (Index k = 0; k < stop; ++k) \{
00223                     \textcolor{keyword}{const} Scalar tmp = newCoeff;
00224                     newCoeff = tmp - lIt.value() * uIt.value();
00225                     ++lIt;
00226                     ++uIt;
00227                 \}
00228 \textcolor{preprocessor}{#endif}
00229 
00230                 m\_lu.coeffRefLower(row, col) = newCoeff / diag;
00231             \}
00232         \}
00233 
00234         \textcolor{comment}{//Upper matrix update}
00235         \textcolor{keyword}{const} Index col = row;
00236         \textcolor{keyword}{typename} MatrixType::InnerUpperIterator uuIt(m\_lu, col);
00237         \textcolor{keywordflow}{for} (Index rrow = uuIt.row(); rrow < col; rrow++) \{
00238 
00239             \textcolor{keyword}{typename} MatrixType::InnerLowerIterator lIt(m\_lu, rrow);
00240             \textcolor{keyword}{typename} MatrixType::InnerUpperIterator uIt(m\_lu, col);
00241             \textcolor{keyword}{const} Index offset = lIt.col() - uIt.row();
00242 
00243             Index stop = offset > 0 ? rrow - lIt.col() : rrow - uIt.row();
00244 
00245 \textcolor{preprocessor}{#ifdef VECTORIZE}
00246             \hyperlink{group___core___module_class_eigen_1_1_map}{Map<VectorXd >} rowVal(lIt.valuePtr() + (offset > 0 ? 0 : -offset), stop);
00247             \hyperlink{group___core___module_class_eigen_1_1_map}{Map<VectorXd >} colVal(uIt.valuePtr() + (offset > 0 ? offset : 0), stop);
00248 
00249             Scalar newCoeff = m\_lu.coeffUpper(rrow, col) - rowVal.dot(colVal);
00250 \textcolor{preprocessor}{#else}
00251             \textcolor{keywordflow}{if} (offset > 0) \textcolor{comment}{//Skip zero value of lIt}
00252                 uIt += offset;
00253             \textcolor{keywordflow}{else} \textcolor{comment}{//Skip zero values of uIt}
00254                 lIt += -offset;
00255             Scalar newCoeff = m\_lu.coeffUpper(rrow, col);
00256             \textcolor{keywordflow}{for} (Index k = 0; k < stop; ++k) \{
00257                 \textcolor{keyword}{const} Scalar tmp = newCoeff;
00258                 newCoeff = tmp - lIt.value() * uIt.value();
00259 
00260                 ++lIt;
00261                 ++uIt;
00262             \}
00263 \textcolor{preprocessor}{#endif}
00264             m\_lu.coeffRefUpper(rrow, col) = newCoeff;
00265         \}
00266 
00267 
00268         \textcolor{comment}{//Diag matrix update}
00269         \textcolor{keyword}{typename} MatrixType::InnerLowerIterator lIt(m\_lu, row);
00270         \textcolor{keyword}{typename} MatrixType::InnerUpperIterator uIt(m\_lu, row);
00271 
00272         \textcolor{keyword}{const} Index offset = lIt.col() - uIt.row();
00273 
00274 
00275         Index stop = offset > 0 ? lIt.size() : uIt.size();
00276 \textcolor{preprocessor}{#ifdef VECTORIZE}
00277         \hyperlink{group___core___module_class_eigen_1_1_map}{Map<VectorXd >} rowVal(lIt.valuePtr() + (offset > 0 ? 0 : -offset), stop);
00278         \hyperlink{group___core___module_class_eigen_1_1_map}{Map<VectorXd >} colVal(uIt.valuePtr() + (offset > 0 ? offset : 0), stop);
00279         Scalar newCoeff = m\_lu.coeffDiag(row) - rowVal.dot(colVal);
00280 \textcolor{preprocessor}{#else}
00281         \textcolor{keywordflow}{if} (offset > 0) \textcolor{comment}{//Skip zero value of lIt}
00282             uIt += offset;
00283         \textcolor{keywordflow}{else} \textcolor{comment}{//Skip zero values of uIt}
00284             lIt += -offset;
00285         Scalar newCoeff = m\_lu.coeffDiag(row);
00286         \textcolor{keywordflow}{for} (Index k = 0; k < stop; ++k) \{
00287             \textcolor{keyword}{const} Scalar tmp = newCoeff;
00288             newCoeff = tmp - lIt.value() * uIt.value();
00289             ++lIt;
00290             ++uIt;
00291         \}
00292 \textcolor{preprocessor}{#endif}
00293         m\_lu.coeffRefDiag(row) = newCoeff;
00294     \}
00295 \}
00296 
00305 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00306 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BDerived, \textcolor{keyword}{typename} XDerived>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_inplace_l_u_8h_source_l00307}\hyperlink{class_eigen_1_1_skyline_inplace_l_u_a53c846d76559221d2bcf336a2da4d68f}{00307} \textcolor{keywordtype}{bool} \hyperlink{class_eigen_1_1_skyline_inplace_l_u_a53c846d76559221d2bcf336a2da4d68f}{SkylineInplaceLU<MatrixType>::solve}(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<BDerived>} &b, \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<XDerived>}* x, \textcolor{keyword}{const} \textcolor{keywordtype}{int} 
      transposed)\textcolor{keyword}{ const }\{
00308     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} rows = m\_lu.rows();
00309     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} cols = m\_lu.cols();
00310 
00311 
00312     \textcolor{keywordflow}{for} (Index row = 0; row < rows; row++) \{
00313         x->coeffRef(row) = b.coeff(row);
00314         Scalar newVal = x->coeff(row);
00315         \textcolor{keyword}{typename} MatrixType::InnerLowerIterator lIt(m\_lu, row);
00316 
00317         Index col = lIt.col();
00318         \textcolor{keywordflow}{while} (lIt.col() < row) \{
00319 
00320             newVal -= x->coeff(col++) * lIt.\hyperlink{group___core___module_a8da735a6bfc7012606acf787156d10a0}{value}();
00321             ++lIt;
00322         \}
00323 
00324         x->coeffRef(row) = newVal;
00325     \}
00326 
00327 
00328     \textcolor{keywordflow}{for} (Index col = rows - 1; col > 0; col--) \{
00329         x->coeffRef(col) = x->coeff(col) / m\_lu.coeffDiag(col);
00330 
00331         \textcolor{keyword}{const} Scalar x\_col = x->coeff(col);
00332 
00333         \textcolor{keyword}{typename} MatrixType::InnerUpperIterator uIt(m\_lu, col);
00334         uIt += uIt.size()-1;
00335 
00336 
00337         \textcolor{keywordflow}{while} (uIt) \{
00338             x->coeffRef(uIt.row()) -= x\_col * uIt.\hyperlink{group___core___module_a8da735a6bfc7012606acf787156d10a0}{value}();
00339             \textcolor{comment}{//TODO : introduce --operator}
00340             uIt += -1;
00341         \}
00342 
00343 
00344     \}
00345     x->coeffRef(0) = x->coeff(0) / m\_lu.coeffDiag(0);
00346 
00347     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00348 \}
00349 
00350 \} \textcolor{comment}{// end namespace Eigen}
00351 
00352 \textcolor{preprocessor}{#endif // EIGEN\_SKYLINELU\_H}
\end{DoxyCode}
