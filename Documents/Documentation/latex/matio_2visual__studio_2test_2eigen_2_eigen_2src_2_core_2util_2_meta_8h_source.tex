\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2util_2_meta_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/util/\+Meta.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2util_2_meta_8h_source}\index{Meta.\+h@{Meta.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_META\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_META\_H}
00013 
00014 \textcolor{preprocessor}{#if defined(\_\_CUDA\_ARCH\_\_)}
00015 \textcolor{preprocessor}{#include <cfloat>}
00016 \textcolor{preprocessor}{#include <math\_constants.h>}
00017 \textcolor{preprocessor}{#endif}
00018 
00019 \textcolor{preprocessor}{#if EIGEN\_COMP\_ICC>=1600 &&  \_\_cplusplus >= 201103L}
00020 \textcolor{preprocessor}{#include <cstdint>}
00021 \textcolor{preprocessor}{#endif}
00022 
00023 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00024 
00025 \textcolor{keyword}{typedef} EIGEN\_DEFAULT\_DENSE\_INDEX\_TYPE DenseIndex;
00026 
00033 \textcolor{keyword}{typedef} EIGEN\_DEFAULT\_DENSE\_INDEX\_TYPE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00034 
00035 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00036 
00044 \textcolor{comment}{// Only recent versions of ICC complain about using ptrdiff\_t to hold pointers,}
00045 \textcolor{comment}{// and older versions do not provide *intptr\_t types.}
00046 \textcolor{preprocessor}{#if EIGEN\_COMP\_ICC>=1600 &&  \_\_cplusplus >= 201103L}
00047 \textcolor{keyword}{typedef} std::intptr\_t  IntPtr;
00048 \textcolor{keyword}{typedef} std::uintptr\_t UIntPtr;
00049 \textcolor{preprocessor}{#else}
00050 \textcolor{keyword}{typedef} std::ptrdiff\_t IntPtr;
00051 \textcolor{keyword}{typedef} std::size\_t UIntPtr;
00052 \textcolor{preprocessor}{#endif}
00053 
00054 \textcolor{keyword}{struct }true\_type \{  \textcolor{keyword}{enum} \{ value = 1 \}; \};
00055 \textcolor{keyword}{struct }false\_type \{ \textcolor{keyword}{enum} \{ value = 0 \}; \};
00056 
00057 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Condition, \textcolor{keyword}{typename} Then, \textcolor{keyword}{typename} Else>
00058 \textcolor{keyword}{struct }conditional \{ \textcolor{keyword}{typedef} Then type; \};
00059 
00060 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Then, \textcolor{keyword}{typename} Else>
00061 \textcolor{keyword}{struct }conditional <false, Then, Else> \{ \textcolor{keyword}{typedef} Else type; \};
00062 
00063 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U> \textcolor{keyword}{struct }is\_same \{ \textcolor{keyword}{enum} \{ value = 0 \}; \};
00064 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }is\_same<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T},\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}> \{ \textcolor{keyword}{enum} \{ value = 1 \}; \};
00065 
00066 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }remove\_reference \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type; \};
00067 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }remove\_reference<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&> \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type; \};
00068 
00069 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }remove\_pointer \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type; \};
00070 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }remove\_pointer<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*> \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type; \};
00071 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }remove\_pointer<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*\textcolor{keyword}{const}> \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type; \};
00072 
00073 \textcolor{keyword}{template} <\textcolor{keyword}{class} T> \textcolor{keyword}{struct }remove\_const \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type; \};
00074 \textcolor{keyword}{template} <\textcolor{keyword}{class} T> \textcolor{keyword}{struct }remove\_const<const \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}> \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type; \};
00075 \textcolor{keyword}{template} <\textcolor{keyword}{class} T> \textcolor{keyword}{struct }remove\_const<const \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}[]> \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type[]; \};
00076 \textcolor{keyword}{template} <\textcolor{keyword}{class} T, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Size> \textcolor{keyword}{struct }remove\_const<const \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}[Size]> \{ \textcolor{keyword}{typedef} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type[Size]; \};
00077 
00078 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }remove\_all \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type; \};
00079 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }remove\_all<const \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}>   \{ \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<T>::type type; \};
00080 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }remove\_all<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} const&>  \{ \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<T>::type type; \};
00081 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }remove\_all<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&>        \{ \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<T>::type type; \};
00082 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }remove\_all<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} const*>  \{ \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<T>::type type; \};
00083 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }remove\_all<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*>        \{ \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<T>::type type; \};
00084 
00085 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }is\_arithmetic      \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{false} \}; \};
00086 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<float>         \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00087 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<double>        \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00088 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<long double>   \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00089 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<bool>          \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00090 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<char>          \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00091 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<signed char>   \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00092 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<unsigned char> \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00093 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<signed short>  \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00094 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<unsigned short>\{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00095 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<signed int>    \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00096 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<unsigned int>  \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00097 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<signed long>   \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00098 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<unsigned long> \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00099 
00100 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }is\_integral        \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{false} \}; \};
00101 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_integral<bool>            \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00102 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_integral<char>            \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00103 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_integral<signed char>     \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00104 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_integral<unsigned char>   \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00105 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_integral<signed short>    \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00106 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_integral<unsigned short>  \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00107 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_integral<signed int>      \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00108 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_integral<unsigned int>    \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00109 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_integral<signed long>     \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00110 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_integral<unsigned long>   \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00111 
00112 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }add\_const \{ \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type; \};
00113 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }add\_const<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&> \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& type; \};
00114 
00115 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }is\_const \{ \textcolor{keyword}{enum} \{ value = 0 \}; \};
00116 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }is\_const<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} const> \{ \textcolor{keyword}{enum} \{ value = 1 \}; \};
00117 
00118 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }add\_const\_on\_value\_type            \{ \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type;  \};
00119 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }add\_const\_on\_value\_type<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&>        \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} \textcolor{keyword}{const}& type; \};
00120 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }add\_const\_on\_value\_type<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*>        \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} \textcolor{keyword}{const}* type; \};
00121 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }add\_const\_on\_value\_type<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* \textcolor{keyword}{const}>  \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} \textcolor{keyword}{const}* \textcolor{keyword}{const} type; \};
00122 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }add\_const\_on\_value\_type<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} const* \textcolor{keyword}{const}>  \{ \textcolor{keyword}{typedef} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} \textcolor{keyword}{const}* \textcolor{keyword}{const} type; \};
00123 
00124 
00125 \textcolor{keyword}{template}<\textcolor{keyword}{typename} From, \textcolor{keyword}{typename} To>
00126 \textcolor{keyword}{struct }is\_convertible\_impl
00127 \{
00128 \textcolor{keyword}{private}:
00129   \textcolor{keyword}{struct }any\_conversion
00130   \{
00131     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> any\_conversion(\textcolor{keyword}{const} \textcolor{keyword}{volatile} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&);
00132     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> any\_conversion(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&);
00133   \};
00134   \textcolor{keyword}{struct }yes \{\textcolor{keywordtype}{int} a[1];\};
00135   \textcolor{keyword}{struct }no  \{\textcolor{keywordtype}{int} a[2];\};
00136 
00137   \textcolor{keyword}{static} yes test(\textcolor{keyword}{const} To&, \textcolor{keywordtype}{int});
00138   \textcolor{keyword}{static} no  test(any\_conversion, ...);
00139 
00140 \textcolor{keyword}{public}:
00141   \textcolor{keyword}{static} From ms\_from;
00142 \textcolor{preprocessor}{#ifdef \_\_INTEL\_COMPILER}
00143 \textcolor{preprocessor}{  #pragma warning push}
00144 \textcolor{preprocessor}{  #pragma warning ( disable : 2259 )}
00145 \textcolor{preprocessor}{#endif}
00146   \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{sizeof}(test(ms\_from, 0))==\textcolor{keyword}{sizeof}(yes) \};
00147 \textcolor{preprocessor}{#ifdef \_\_INTEL\_COMPILER}
00148 \textcolor{preprocessor}{  #pragma warning pop}
00149 \textcolor{preprocessor}{#endif}
00150 \};
00151 
00152 \textcolor{keyword}{template}<\textcolor{keyword}{typename} From, \textcolor{keyword}{typename} To>
00153 \textcolor{keyword}{struct }is\_convertible
00154 \{
00155   \textcolor{keyword}{enum} \{ value = is\_convertible\_impl<typename remove\_all<From>::type,
00156                                      \textcolor{keyword}{typename} remove\_all<To  >::type>::value \};
00157 \};
00158 
00162 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Condition, \textcolor{keyword}{typename} T=\textcolor{keywordtype}{void}> \textcolor{keyword}{struct }enable\_if;
00163 
00164 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }enable\_if<true,\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}>
00165 \{ \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type; \};
00166 
00167 \textcolor{preprocessor}{#if defined(\_\_CUDA\_ARCH\_\_)}
00168 \textcolor{preprocessor}{#if !defined(\_\_FLT\_EPSILON\_\_)}
00169 \textcolor{preprocessor}{#define \_\_FLT\_EPSILON\_\_ FLT\_EPSILON}
00170 \textcolor{preprocessor}{#define \_\_DBL\_EPSILON\_\_ DBL\_EPSILON}
00171 \textcolor{preprocessor}{#endif}
00172 
00173 \textcolor{keyword}{namespace }device \{
00174 
00175 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }numeric\_limits
00176 \{
00177   EIGEN\_DEVICE\_FUNC
00178   \textcolor{keyword}{static} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} epsilon() \{ \textcolor{keywordflow}{return} 0; \}
00179   \textcolor{keyword}{static} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} (max)() \{ assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Highest not supported for this type"}); \}
00180   \textcolor{keyword}{static} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} (min)() \{ assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Lowest not supported for this type"}); \}
00181   \textcolor{keyword}{static} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} infinity() \{ assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Infinity not supported for this type"}); \}
00182   \textcolor{keyword}{static} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} quiet\_NaN() \{ assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"quiet\_NaN not supported for this type"}); \}
00183 \};
00184 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }numeric\_limits<float>
00185 \{
00186   EIGEN\_DEVICE\_FUNC
00187   \textcolor{keyword}{static} \textcolor{keywordtype}{float} epsilon() \{ \textcolor{keywordflow}{return} \_\_FLT\_EPSILON\_\_; \}
00188   EIGEN\_DEVICE\_FUNC
00189   \textcolor{keyword}{static} float (max)() \{ \textcolor{keywordflow}{return} CUDART\_MAX\_NORMAL\_F; \}
00190   EIGEN\_DEVICE\_FUNC
00191   \textcolor{keyword}{static} float (min)() \{ \textcolor{keywordflow}{return} FLT\_MIN; \}
00192   EIGEN\_DEVICE\_FUNC
00193   \textcolor{keyword}{static} \textcolor{keywordtype}{float} infinity() \{ \textcolor{keywordflow}{return} CUDART\_INF\_F; \}
00194   EIGEN\_DEVICE\_FUNC
00195   \textcolor{keyword}{static} \textcolor{keywordtype}{float} quiet\_NaN() \{ \textcolor{keywordflow}{return} CUDART\_NAN\_F; \}
00196 \};
00197 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }numeric\_limits<double>
00198 \{
00199   EIGEN\_DEVICE\_FUNC
00200   \textcolor{keyword}{static} \textcolor{keywordtype}{double} epsilon() \{ \textcolor{keywordflow}{return} \_\_DBL\_EPSILON\_\_; \}
00201   EIGEN\_DEVICE\_FUNC
00202   \textcolor{keyword}{static} double (max)() \{ \textcolor{keywordflow}{return} DBL\_MAX; \}
00203   EIGEN\_DEVICE\_FUNC
00204   \textcolor{keyword}{static} double (min)() \{ \textcolor{keywordflow}{return} DBL\_MIN; \}
00205   EIGEN\_DEVICE\_FUNC
00206   \textcolor{keyword}{static} \textcolor{keywordtype}{double} infinity() \{ \textcolor{keywordflow}{return} CUDART\_INF; \}
00207   EIGEN\_DEVICE\_FUNC
00208   \textcolor{keyword}{static} \textcolor{keywordtype}{double} quiet\_NaN() \{ \textcolor{keywordflow}{return} CUDART\_NAN; \}
00209 \};
00210 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }numeric\_limits<int>
00211 \{
00212   EIGEN\_DEVICE\_FUNC
00213   \textcolor{keyword}{static} \textcolor{keywordtype}{int} epsilon() \{ \textcolor{keywordflow}{return} 0; \}
00214   EIGEN\_DEVICE\_FUNC
00215   \textcolor{keyword}{static} int (max)() \{ \textcolor{keywordflow}{return} INT\_MAX; \}
00216   EIGEN\_DEVICE\_FUNC
00217   \textcolor{keyword}{static} int (min)() \{ \textcolor{keywordflow}{return} INT\_MIN; \}
00218 \};
00219 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }numeric\_limits<unsigned int>
00220 \{
00221   EIGEN\_DEVICE\_FUNC
00222   \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} epsilon() \{ \textcolor{keywordflow}{return} 0; \}
00223   EIGEN\_DEVICE\_FUNC
00224   \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} int (max)() \{ \textcolor{keywordflow}{return} UINT\_MAX; \}
00225   EIGEN\_DEVICE\_FUNC
00226   \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} int (min)() \{ \textcolor{keywordflow}{return} 0; \}
00227 \};
00228 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }numeric\_limits<long>
00229 \{
00230   EIGEN\_DEVICE\_FUNC
00231   \textcolor{keyword}{static} \textcolor{keywordtype}{long} epsilon() \{ \textcolor{keywordflow}{return} 0; \}
00232   EIGEN\_DEVICE\_FUNC
00233   \textcolor{keyword}{static} long (max)() \{ \textcolor{keywordflow}{return} LONG\_MAX; \}
00234   EIGEN\_DEVICE\_FUNC
00235   \textcolor{keyword}{static} long (min)() \{ \textcolor{keywordflow}{return} LONG\_MIN; \}
00236 \};
00237 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }numeric\_limits<unsigned long>
00238 \{
00239   EIGEN\_DEVICE\_FUNC
00240   \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} epsilon() \{ \textcolor{keywordflow}{return} 0; \}
00241   EIGEN\_DEVICE\_FUNC
00242   \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} long (max)() \{ \textcolor{keywordflow}{return} ULONG\_MAX; \}
00243   EIGEN\_DEVICE\_FUNC
00244   \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} long (min)() \{ \textcolor{keywordflow}{return} 0; \}
00245 \};
00246 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }numeric\_limits<long long>
00247 \{
00248   EIGEN\_DEVICE\_FUNC
00249   \textcolor{keyword}{static} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} epsilon() \{ \textcolor{keywordflow}{return} 0; \}
00250   EIGEN\_DEVICE\_FUNC
00251   \textcolor{keyword}{static} \textcolor{keywordtype}{long} long (max)() \{ \textcolor{keywordflow}{return} LLONG\_MAX; \}
00252   EIGEN\_DEVICE\_FUNC
00253   \textcolor{keyword}{static} \textcolor{keywordtype}{long} long (min)() \{ \textcolor{keywordflow}{return} LLONG\_MIN; \}
00254 \};
00255 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }numeric\_limits<unsigned long long>
00256 \{
00257   EIGEN\_DEVICE\_FUNC
00258   \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} epsilon() \{ \textcolor{keywordflow}{return} 0; \}
00259   EIGEN\_DEVICE\_FUNC
00260   \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} long (max)() \{ \textcolor{keywordflow}{return} ULLONG\_MAX; \}
00261   EIGEN\_DEVICE\_FUNC
00262   \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} long (min)() \{ \textcolor{keywordflow}{return} 0; \}
00263 \};
00264 
00265 \}
00266 
00267 \textcolor{preprocessor}{#endif}
00268 
00272 \textcolor{keyword}{class }noncopyable
00273 \{
00274   EIGEN\_DEVICE\_FUNC noncopyable(\textcolor{keyword}{const} noncopyable&);
00275   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} noncopyable& operator=(\textcolor{keyword}{const} noncopyable&);
00276 \textcolor{keyword}{protected}:
00277   EIGEN\_DEVICE\_FUNC noncopyable() \{\}
00278   EIGEN\_DEVICE\_FUNC ~noncopyable() \{\}
00279 \};
00280 
00288 \textcolor{preprocessor}{#if EIGEN\_HAS\_STD\_RESULT\_OF}
00289 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }result\_of \{
00290   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::result\_of<T>::type type1;
00291   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<type1>::type type;
00292 \};
00293 \textcolor{preprocessor}{#else}
00294 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }result\_of \{ \};
00295 
00296 \textcolor{keyword}{struct }has\_none \{\textcolor{keywordtype}{int} a[1];\};
00297 \textcolor{keyword}{struct }has\_std\_result\_type \{\textcolor{keywordtype}{int} a[2];\};
00298 \textcolor{keyword}{struct }has\_tr1\_result \{\textcolor{keywordtype}{int} a[3];\};
00299 
00300 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} ArgType, \textcolor{keywordtype}{int} SizeOf=sizeof(has\_none)>
00301 \textcolor{keyword}{struct }unary\_result\_of\_select \{\textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ArgType>::type type;\};
00302 
00303 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} ArgType>
00304 \textcolor{keyword}{struct }unary\_result\_of\_select<Func, ArgType, sizeof(has\_std\_result\_type)> \{\textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      Func::result\_type type;\};
00305 
00306 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} ArgType>
00307 \textcolor{keyword}{struct }unary\_result\_of\_select<Func, ArgType, sizeof(has\_tr1\_result)> \{\textcolor{keyword}{typedef} \textcolor{keyword}{typename} Func::template 
      result<Func(ArgType)>::type type;\};
00308 
00309 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} ArgType>
00310 \textcolor{keyword}{struct }result\_of<Func(ArgType)> \{
00311     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00312     \textcolor{keyword}{static} has\_std\_result\_type    testFunctor(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} \textcolor{keyword}{const} *, \textcolor{keyword}{typename} T::result\_type \textcolor{keyword}{const} * = 0);
00313     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00314     \textcolor{keyword}{static} has\_tr1\_result         testFunctor(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} \textcolor{keyword}{const} *, \textcolor{keyword}{typename} T::template result<
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}(ArgType)>::type \textcolor{keyword}{const} * = 0);
00315     \textcolor{keyword}{static} has\_none               testFunctor(...);
00316 
00317     \textcolor{comment}{// note that the following indirection is needed for gcc-3.3}
00318     \textcolor{keyword}{enum} \{FunctorType = \textcolor{keyword}{sizeof}(testFunctor(static\_cast<Func*>(0)))\};
00319     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} unary\_result\_of\_select<Func, ArgType, FunctorType>::type type;
00320 \};
00321 
00322 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} ArgType0, \textcolor{keyword}{typename} ArgType1, \textcolor{keywordtype}{int} SizeOf=sizeof(has\_none)>
00323 \textcolor{keyword}{struct }binary\_result\_of\_select \{\textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ArgType0>::type type;\};
00324 
00325 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} ArgType0, \textcolor{keyword}{typename} ArgType1>
00326 \textcolor{keyword}{struct }binary\_result\_of\_select<Func, ArgType0, ArgType1, sizeof(has\_std\_result\_type)>
00327 \{\textcolor{keyword}{typedef} \textcolor{keyword}{typename} Func::result\_type type;\};
00328 
00329 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} ArgType0, \textcolor{keyword}{typename} ArgType1>
00330 \textcolor{keyword}{struct }binary\_result\_of\_select<Func, ArgType0, ArgType1, sizeof(has\_tr1\_result)>
00331 \{\textcolor{keyword}{typedef} \textcolor{keyword}{typename} Func::template result<Func(ArgType0,ArgType1)>::type type;\};
00332 
00333 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} ArgType0, \textcolor{keyword}{typename} ArgType1>
00334 \textcolor{keyword}{struct }result\_of<Func(ArgType0,ArgType1)> \{
00335     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00336     \textcolor{keyword}{static} has\_std\_result\_type    testFunctor(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} \textcolor{keyword}{const} *, \textcolor{keyword}{typename} T::result\_type \textcolor{keyword}{const} * = 0);
00337     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00338     \textcolor{keyword}{static} has\_tr1\_result         testFunctor(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} \textcolor{keyword}{const} *, \textcolor{keyword}{typename} T::template result<
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}(ArgType0,ArgType1)>::type \textcolor{keyword}{const} * = 0);
00339     \textcolor{keyword}{static} has\_none               testFunctor(...);
00340 
00341     \textcolor{comment}{// note that the following indirection is needed for gcc-3.3}
00342     \textcolor{keyword}{enum} \{FunctorType = \textcolor{keyword}{sizeof}(testFunctor(static\_cast<Func*>(0)))\};
00343     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} binary\_result\_of\_select<Func, ArgType0, ArgType1, FunctorType>::type type;
00344 \};
00345 
00346 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} ArgType0, \textcolor{keyword}{typename} ArgType1, \textcolor{keyword}{typename} ArgType2, \textcolor{keywordtype}{int} SizeOf=sizeof(has\_none
      )>
00347 \textcolor{keyword}{struct }ternary\_result\_of\_select \{\textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ArgType0>::type type;\};
00348 
00349 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} ArgType0, \textcolor{keyword}{typename} ArgType1, \textcolor{keyword}{typename} ArgType2>
00350 \textcolor{keyword}{struct }ternary\_result\_of\_select<Func, ArgType0, ArgType1, ArgType2, sizeof(has\_std\_result\_type)>
00351 \{\textcolor{keyword}{typedef} \textcolor{keyword}{typename} Func::result\_type type;\};
00352 
00353 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} ArgType0, \textcolor{keyword}{typename} ArgType1, \textcolor{keyword}{typename} ArgType2>
00354 \textcolor{keyword}{struct }ternary\_result\_of\_select<Func, ArgType0, ArgType1, ArgType2, sizeof(has\_tr1\_result)>
00355 \{\textcolor{keyword}{typedef} \textcolor{keyword}{typename} Func::template result<Func(ArgType0,ArgType1,ArgType2)>::type type;\};
00356 
00357 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} ArgType0, \textcolor{keyword}{typename} ArgType1, \textcolor{keyword}{typename} ArgType2>
00358 \textcolor{keyword}{struct }result\_of<Func(ArgType0,ArgType1,ArgType2)> \{
00359     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00360     \textcolor{keyword}{static} has\_std\_result\_type    testFunctor(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} \textcolor{keyword}{const} *, \textcolor{keyword}{typename} T::result\_type \textcolor{keyword}{const} * = 0);
00361     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00362     \textcolor{keyword}{static} has\_tr1\_result         testFunctor(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} \textcolor{keyword}{const} *, \textcolor{keyword}{typename} T::template result<
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}(ArgType0,ArgType1,ArgType2)>::type \textcolor{keyword}{const} * = 0);
00363     \textcolor{keyword}{static} has\_none               testFunctor(...);
00364 
00365     \textcolor{comment}{// note that the following indirection is needed for gcc-3.3}
00366     \textcolor{keyword}{enum} \{FunctorType = \textcolor{keyword}{sizeof}(testFunctor(static\_cast<Func*>(0)))\};
00367     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ternary\_result\_of\_select<Func, ArgType0, ArgType1, ArgType2, FunctorType>::type type;
00368 \};
00369 \textcolor{preprocessor}{#endif}
00370 
00371 \textcolor{keyword}{struct }meta\_yes \{ \textcolor{keywordtype}{char} a[1]; \};
00372 \textcolor{keyword}{struct }meta\_no  \{ \textcolor{keywordtype}{char} a[2]; \};
00373 
00374 \textcolor{comment}{// Check whether T::ReturnType does exist}
00375 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00376 \textcolor{keyword}{struct }has\_ReturnType
00377 \{
00378   \textcolor{keyword}{template} <\textcolor{keyword}{typename} C> \textcolor{keyword}{static} meta\_yes testFunctor(\textcolor{keyword}{typename} C::ReturnType \textcolor{keyword}{const} *);
00379   \textcolor{keyword}{template} <\textcolor{keyword}{typename} C> \textcolor{keyword}{static} meta\_no testFunctor(...);
00380 
00381   \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{sizeof}(testFunctor<T>(0)) == \textcolor{keyword}{sizeof}(meta\_yes) \};
00382 \};
00383 
00384 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* return\_ptr();
00385 
00386 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} IndexType=Index>
00387 \textcolor{keyword}{struct }has\_nullary\_operator
00388 \{
00389   \textcolor{keyword}{template} <\textcolor{keyword}{typename} C> \textcolor{keyword}{static} meta\_yes testFunctor(C \textcolor{keyword}{const} *,\textcolor{keyword}{typename} enable\_if<(\textcolor{keyword}{sizeof}(return\_ptr<C>()->\textcolor{keyword}{
      operator}()())>0)>::type * = 0);
00390   \textcolor{keyword}{static} meta\_no testFunctor(...);
00391 
00392   \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{sizeof}(testFunctor(static\_cast<T*>(0))) == \textcolor{keyword}{sizeof}(meta\_yes) \};
00393 \};
00394 
00395 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} IndexType=Index>
00396 \textcolor{keyword}{struct }has\_unary\_operator
00397 \{
00398   \textcolor{keyword}{template} <\textcolor{keyword}{typename} C> \textcolor{keyword}{static} meta\_yes testFunctor(C \textcolor{keyword}{const} *,\textcolor{keyword}{typename} enable\_if<(\textcolor{keyword}{sizeof}(return\_ptr<C>()->\textcolor{keyword}{
      operator}()(IndexType(0)))>0)>::type * = 0);
00399   \textcolor{keyword}{static} meta\_no testFunctor(...);
00400 
00401   \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{sizeof}(testFunctor(static\_cast<T*>(0))) == \textcolor{keyword}{sizeof}(meta\_yes) \};
00402 \};
00403 
00404 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} IndexType=Index>
00405 \textcolor{keyword}{struct }has\_binary\_operator
00406 \{
00407   \textcolor{keyword}{template} <\textcolor{keyword}{typename} C> \textcolor{keyword}{static} meta\_yes testFunctor(C \textcolor{keyword}{const} *,\textcolor{keyword}{typename} enable\_if<(\textcolor{keyword}{sizeof}(return\_ptr<C>()->\textcolor{keyword}{
      operator}()(IndexType(0),IndexType(0)))>0)>::type * = 0);
00408   \textcolor{keyword}{static} meta\_no testFunctor(...);
00409 
00410   \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{sizeof}(testFunctor(static\_cast<T*>(0))) == \textcolor{keyword}{sizeof}(meta\_yes) \};
00411 \};
00412 
00416 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Y,
00417          \textcolor{keywordtype}{int} InfX = 0,
00418          \textcolor{keywordtype}{int} SupX = ((Y==1) ? 1 : Y/2),
00419          \textcolor{keywordtype}{bool} Done = ((SupX-InfX)<=1 ? \textcolor{keyword}{true} : ((SupX*SupX <= Y) && ((SupX+1)*(SupX+1) > Y))) >
00420                                 \textcolor{comment}{// use ?: instead of || just to shut up a stupid gcc 4.3 warning}
00421 \textcolor{keyword}{class} meta\_sqrt
00422 \{
00423     \textcolor{keyword}{enum} \{
00424       MidX = (InfX+SupX)/2,
00425       TakeInf = MidX*MidX > Y ? 1 : 0,
00426       NewInf = \textcolor{keywordtype}{int}(TakeInf) ? InfX : int(MidX),
00427       NewSup = int(TakeInf) ? int(MidX) : SupX
00428     \};
00429   \textcolor{keyword}{public}:
00430     \textcolor{keyword}{enum} \{ ret = meta\_sqrt<Y,NewInf,NewSup>::ret \};
00431 \};
00432 
00433 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Y, \textcolor{keywordtype}{int} InfX, \textcolor{keywordtype}{int} SupX>
00434 \textcolor{keyword}{class }meta\_sqrt<Y, InfX, SupX, true> \{ \textcolor{keyword}{public}:  \textcolor{keyword}{enum} \{ ret = (SupX*SupX <= Y) ? SupX : InfX \}; \};
00435 
00436 
00441 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} A, \textcolor{keywordtype}{int} B, \textcolor{keywordtype}{int} K=1, \textcolor{keywordtype}{bool} Done = ((A*K)%B)==0>
00442 \textcolor{keyword}{struct }meta\_least\_common\_multiple
00443 \{
00444   \textcolor{keyword}{enum} \{ ret = meta\_least\_common\_multiple<A,B,K+1>::ret \};
00445 \};
00446 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} A, \textcolor{keywordtype}{int} B, \textcolor{keywordtype}{int} K>
00447 \textcolor{keyword}{struct }meta\_least\_common\_multiple<A,B,K,true>
00448 \{
00449   \textcolor{keyword}{enum} \{ ret = A*K \};
00450 \};
00451 
00453 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U> \textcolor{keyword}{struct }scalar\_product\_traits
00454 \{
00455   \textcolor{keyword}{enum} \{ Defined = 0 \};
00456 \};
00457 
00458 \textcolor{comment}{// FIXME quick workaround around current limitation of result\_of}
00459 \textcolor{comment}{// template<typename Scalar, typename ArgType0, typename ArgType1>}
00460 \textcolor{comment}{// struct result\_of<scalar\_product\_op<Scalar>(ArgType0,ArgType1)> \{}
00461 \textcolor{comment}{// typedef typename scalar\_product\_traits<typename remove\_all<ArgType0>::type, typename
       remove\_all<ArgType1>::type>::ReturnType type;}
00462 \textcolor{comment}{// \};}
00463 
00464 \} \textcolor{comment}{// end namespace internal}
00465 
00466 \textcolor{keyword}{namespace }numext \{
00467   
00468 \textcolor{preprocessor}{#if defined(\_\_CUDA\_ARCH\_\_)}
00469 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> EIGEN\_DEVICE\_FUNC   \textcolor{keywordtype}{void} \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} &a, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} &b) \{ \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} tmp = b; b = a; a = tmp; \}
00470 \textcolor{preprocessor}{#else}
00471 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} &a, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} &b) \{ \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(a,b); \}
00472 \textcolor{preprocessor}{#endif}
00473 
00474 \textcolor{preprocessor}{#if defined(\_\_CUDA\_ARCH\_\_)}
00475 \textcolor{keyword}{using} internal::device::numeric\_limits;
00476 \textcolor{preprocessor}{#else}
00477 \textcolor{keyword}{using} std::numeric\_limits;
00478 \textcolor{preprocessor}{#endif}
00479 
00480 \textcolor{comment}{// Integer division with rounding up.}
00481 \textcolor{comment}{// T is assumed to be an integer type with a>=0, and b>0}
00482 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00483 \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} div\_ceil(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} &a, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} &b)
00484 \{
00485   \textcolor{keywordflow}{return} (a+b-1) / b;
00486 \}
00487 
00488 \} \textcolor{comment}{// end namespace numext}
00489 
00490 \} \textcolor{comment}{// end namespace Eigen}
00491 
00492 \textcolor{preprocessor}{#endif // EIGEN\_META\_H}
\end{DoxyCode}
