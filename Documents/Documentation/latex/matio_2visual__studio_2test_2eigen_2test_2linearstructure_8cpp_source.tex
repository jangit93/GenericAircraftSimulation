\hypertarget{matio_2visual__studio_2test_2eigen_2test_2linearstructure_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/linearstructure.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2linearstructure_8cpp_source}\index{linearstructure.\+cpp@{linearstructure.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{keyword}{static} \textcolor{keywordtype}{bool} g\_called;
00012 \textcolor{preprocessor}{#define EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN \{ g\_called |= (!internal::is\_same<LhsScalar,RhsScalar>::value); \}}
00013 
00014 \textcolor{preprocessor}{#include "main.h"}
00015 
00016 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} linearStructure(\textcolor{keyword}{const} MatrixType& m)
00017 \{
00018   \textcolor{keyword}{using} std::abs;
00019   \textcolor{comment}{/* this test covers the following files:}
00020 \textcolor{comment}{     CwiseUnaryOp.h, CwiseBinaryOp.h, SelfCwiseBinaryOp.h }
00021 \textcolor{comment}{  */}
00022   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00023   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00024   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00025 
00026   Index rows = m.rows();
00027   Index cols = m.cols();
00028 
00029   \textcolor{comment}{// this test relies a lot on Random.h, and there's not much more that we can do}
00030   \textcolor{comment}{// to test it, hence I consider that we will have tested Random.h}
00031   MatrixType m1 = MatrixType::Random(rows, cols),
00032              m2 = MatrixType::Random(rows, cols),
00033              m3(rows, cols);
00034 
00035   Scalar s1 = internal::random<Scalar>();
00036   \textcolor{keywordflow}{while} (abs(s1)<RealScalar(1e-3)) s1 = internal::random<Scalar>();
00037 
00038   Index r = internal::random<Index>(0, rows-1),
00039         c = internal::random<Index>(0, cols-1);
00040 
00041   VERIFY\_IS\_APPROX(-(-m1),                  m1);
00042   VERIFY\_IS\_APPROX(m1+m1,                   2*m1);
00043   VERIFY\_IS\_APPROX(m1+m2-m1,                m2);
00044   VERIFY\_IS\_APPROX(-m2+m1+m2,               m1);
00045   VERIFY\_IS\_APPROX(m1*s1,                   s1*m1);
00046   VERIFY\_IS\_APPROX((m1+m2)*s1,              s1*m1+s1*m2);
00047   VERIFY\_IS\_APPROX((-m1+m2)*s1,             -s1*m1+s1*m2);
00048   m3 = m2; m3 += m1;
00049   VERIFY\_IS\_APPROX(m3,                      m1+m2);
00050   m3 = m2; m3 -= m1;
00051   VERIFY\_IS\_APPROX(m3,                      m2-m1);
00052   m3 = m2; m3 *= s1;
00053   VERIFY\_IS\_APPROX(m3,                      s1*m2);
00054   \textcolor{keywordflow}{if}(!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsInteger})
00055   \{
00056     m3 = m2; m3 /= s1;
00057     VERIFY\_IS\_APPROX(m3,                    m2/s1);
00058   \}
00059 
00060   \textcolor{comment}{// again, test operator() to check const-qualification}
00061   VERIFY\_IS\_APPROX((-m1)(r,c), -(m1(r,c)));
00062   VERIFY\_IS\_APPROX((m1-m2)(r,c), (m1(r,c))-(m2(r,c)));
00063   VERIFY\_IS\_APPROX((m1+m2)(r,c), (m1(r,c))+(m2(r,c)));
00064   VERIFY\_IS\_APPROX((s1*m1)(r,c), s1*(m1(r,c)));
00065   VERIFY\_IS\_APPROX((m1*s1)(r,c), (m1(r,c))*s1);
00066   \textcolor{keywordflow}{if}(!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsInteger})
00067     VERIFY\_IS\_APPROX((m1/s1)(r,c), (m1(r,c))/s1);
00068 
00069   \textcolor{comment}{// use .block to disable vectorization and compare to the vectorized version}
00070   VERIFY\_IS\_APPROX(m1+m1.block(0,0,rows,cols), m1+m1);
00071   VERIFY\_IS\_APPROX(m1.cwiseProduct(m1.block(0,0,rows,cols)), m1.cwiseProduct(m1));
00072   VERIFY\_IS\_APPROX(m1 - m1.block(0,0,rows,cols), m1 - m1);
00073   VERIFY\_IS\_APPROX(m1.block(0,0,rows,cols) * s1, m1 * s1);
00074 \}
00075 
00076 \textcolor{comment}{// Make sure that complex * real and real * complex are properly optimized}
00077 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} real\_complex(DenseIndex rows = MatrixType::RowsAtCompileTime, DenseIndex
       cols = MatrixType::ColsAtCompileTime)
00078 \{
00079   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00080   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00081   
00082   RealScalar s = internal::random<RealScalar>();
00083   MatrixType m1 = MatrixType::Random(rows, cols);
00084   
00085   g\_called = \textcolor{keyword}{false};
00086   VERIFY\_IS\_APPROX(s*m1, Scalar(s)*m1);
00087   VERIFY(g\_called && \textcolor{stringliteral}{"real * matrix<complex> not properly optimized"});
00088   
00089   g\_called = \textcolor{keyword}{false};
00090   VERIFY\_IS\_APPROX(m1*s, m1*Scalar(s));
00091   VERIFY(g\_called && \textcolor{stringliteral}{"matrix<complex> * real not properly optimized"});
00092   
00093   g\_called = \textcolor{keyword}{false};
00094   VERIFY\_IS\_APPROX(m1/s, m1/Scalar(s));
00095   VERIFY(g\_called && \textcolor{stringliteral}{"matrix<complex> / real not properly optimized"});
00096 
00097   g\_called = \textcolor{keyword}{false};
00098   VERIFY\_IS\_APPROX(s+m1.array(), Scalar(s)+m1.array());
00099   VERIFY(g\_called && \textcolor{stringliteral}{"real + matrix<complex> not properly optimized"});
00100 
00101   g\_called = \textcolor{keyword}{false};
00102   VERIFY\_IS\_APPROX(m1.array()+s, m1.array()+Scalar(s));
00103   VERIFY(g\_called && \textcolor{stringliteral}{"matrix<complex> + real not properly optimized"});
00104 
00105   g\_called = \textcolor{keyword}{false};
00106   VERIFY\_IS\_APPROX(s-m1.array(), Scalar(s)-m1.array());
00107   VERIFY(g\_called && \textcolor{stringliteral}{"real - matrix<complex> not properly optimized"});
00108 
00109   g\_called = \textcolor{keyword}{false};
00110   VERIFY\_IS\_APPROX(m1.array()-s, m1.array()-Scalar(s));
00111   VERIFY(g\_called && \textcolor{stringliteral}{"matrix<complex> - real not properly optimized"});
00112 \}
00113 
00114 \textcolor{keywordtype}{void} test\_linearstructure()
00115 \{
00116   g\_called = \textcolor{keyword}{true};
00117   VERIFY(g\_called); \textcolor{comment}{// avoid `unneeded-internal-declaration` warning.}
00118   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00119     CALL\_SUBTEST\_1( linearStructure(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00120     CALL\_SUBTEST\_2( linearStructure(Matrix2f()) );
00121     CALL\_SUBTEST\_3( linearStructure(Vector3d()) );
00122     CALL\_SUBTEST\_4( linearStructure(Matrix4d()) );
00123     CALL\_SUBTEST\_5( linearStructure(MatrixXcf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2))) );
00124     CALL\_SUBTEST\_6( linearStructure(MatrixXf (internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00125     CALL\_SUBTEST\_7( linearStructure(MatrixXi (internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00126     CALL\_SUBTEST\_8( linearStructure(MatrixXcd(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2))) );
00127     CALL\_SUBTEST\_9( linearStructure(ArrayXXf (internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00128     CALL\_SUBTEST\_10( linearStructure(ArrayXXcf (internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00129     
00130     CALL\_SUBTEST\_11( real\_complex<Matrix4cd>() );
00131     CALL\_SUBTEST\_11( real\_complex<MatrixXcf>(10,10) );
00132     CALL\_SUBTEST\_11( real\_complex<ArrayXXcf>(10,10) );
00133   \}
00134   
00135 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_4}
00136   \{
00137     \textcolor{comment}{// make sure that /=scalar and /scalar do not overflow}
00138     \textcolor{comment}{// rational: 1.0/4.94e-320 overflow, but m/4.94e-320 should not}
00139     Matrix4d m2, m3;
00140     m3 = m2 =  Matrix4d::Random()*1e-20;
00141     m2 = m2 / 4.9e-320;
00142     VERIFY\_IS\_APPROX(m2.cwiseQuotient(m2), Matrix4d::Ones());
00143     m3 /= 4.9e-320;
00144     VERIFY\_IS\_APPROX(m3.cwiseQuotient(m3), Matrix4d::Ones());
00145     
00146     
00147   \}
00148 \textcolor{preprocessor}{#endif}
00149 \}
\end{DoxyCode}
