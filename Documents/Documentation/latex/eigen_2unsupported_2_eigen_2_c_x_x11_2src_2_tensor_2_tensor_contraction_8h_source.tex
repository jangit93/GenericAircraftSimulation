\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_contraction_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Contraction.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_contraction_8h_source}\index{Tensor\+Contraction.\+h@{Tensor\+Contraction.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_CONTRACTION\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_CONTRACTION\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 
00024 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dimensions, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_contraction_8h_source_l00025}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_contraction_op_3_01_dimensions_00_01_lhs_xpr_type_00_01_rhs_xpr_type_01_4_01_4}{00025} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_contraction_op}{TensorContractionOp}<Dimensions, LhsXprType, RhsXprType> >
00026 \{
00027   \textcolor{comment}{// Type promotion to handle the case where the types of the lhs and the rhs are different.}
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{class_eigen_1_1internal_1_1gebp__traits}{gebp\_traits<typename remove\_const<typename LhsXprType::Scalar>::type}
      ,
00029                                \textcolor{keyword}{typename} 
      \hyperlink{group___sparse_core___module}{remove\_const<typename RhsXprType::Scalar>::type}>::ResScalar 
      Scalar;
00030 
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1promote__storage__type}{promote\_storage\_type<typename traits<LhsXprType>::StorageKind}
      ,
00032                                         \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<RhsXprType>::StorageKind}
      >::ret StorageKind;
00033   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1promote__index__type}{promote\_index\_type<typename traits<LhsXprType>::Index}
      ,
00034                                       \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<RhsXprType>::Index}>::type 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00035   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsXprType::Nested LhsNested;
00036   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsXprType::Nested RhsNested;
00037   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<LhsNested>::type} 
      \hyperlink{group___sparse_core___module}{\_LhsNested};
00038   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<RhsNested>::type} 
      \hyperlink{group___sparse_core___module}{\_RhsNested};
00039 
00040   \textcolor{comment}{// From NumDims below.}
00041   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<RhsXprType>::NumDimensions} + 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<RhsXprType>::NumDimensions} - 2 * 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size<Dimensions>::value};
00042   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<LhsXprType>::Layout};
00043 
00044   \textcolor{keyword}{enum} \{
00045     Flags = 0
00046   \};
00047 \};
00048 
00049 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dimensions, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_contraction_8h_source_l00050}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_contraction_op_3_01_dimensions_00_01_lhs_xpr_type_0ae5a9acfb75ebc4b7f37699317bff474}{00050} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_contraction_op}{TensorContractionOp}<Dimensions, LhsXprType, RhsXprType>, 
      \hyperlink{namespace_eigen}{Eigen}::\hyperlink{struct_eigen_1_1_dense}{Dense}>
00051 \{
00052   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_contraction_op}{TensorContractionOp<Dimensions, LhsXprType, RhsXprType>}
      & \hyperlink{class_eigen_1_1_tensor_contraction_op}{type};
00053 \};
00054 
00055 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dimensions, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_contraction_8h_source_l00056}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_contraction_op_3_01_dimensions_00_01_lhs_xpr_type916b0c22d0dc73d7838ae3849789214b}{00056} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_contraction_op}{TensorContractionOp}<Dimensions, LhsXprType, RhsXprType>, 1, typename
       \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_contraction_op}{TensorContractionOp}<Dimensions, LhsXprType, RhsXprType> >::
      \hyperlink{class_eigen_1_1_tensor_contraction_op}{type}>
00057 \{
00058   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_contraction_op}{TensorContractionOp<Dimensions, LhsXprType, RhsXprType>}
       \hyperlink{class_eigen_1_1_tensor_contraction_op}{type};
00059 \};
00060 
00061 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Indices\_, \textcolor{keyword}{typename} LeftArgType\_, \textcolor{keyword}{typename} RightArgType\_, \textcolor{keyword}{typename} Device\_>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_contraction_8h_source_l00062}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_evaluator_3_01const_01_tensor_contraction_op_3_01d675ebf024b6201c69018a9924deb8c5}{00062} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_contraction_op}{TensorContractionOp}<Indices\_, 
      LeftArgType\_, RightArgType\_>, Device\_> > \{
00063   \textcolor{keyword}{typedef} Indices\_ Indices;
00064   \textcolor{keyword}{typedef} LeftArgType\_ LeftArgType;
00065   \textcolor{keyword}{typedef} RightArgType\_ RightArgType;
00066   \textcolor{keyword}{typedef} Device\_ Device;
00067 
00068   \textcolor{comment}{// From NumDims below.}
00069   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<LeftArgType\_>::NumDimensions} +
       \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<RightArgType\_>::NumDimensions} - 2 * 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size<Indices\_>::value};
00070 \};
00071 
00072 \}  \textcolor{comment}{// end namespace internal}
00073 
00074 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Indices, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_contraction_8h_source_l00075}\hyperlink{class_eigen_1_1_tensor_contraction_op}{00075} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_contraction_op}{TensorContractionOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorContractionOp<Indices, Lhs
      XprType, RhsXprType>, ReadOnlyAccessors>
00076 \{
00077   \textcolor{keyword}{public}:
00078   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorContractionOp>::Scalar}
       Scalar;
00079   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1gebp__traits}{internal::gebp\_traits}<\textcolor{keyword}{typename} LhsXprType::CoeffReturnType,
00080                                                    \textcolor{keyword}{typename} RhsXprType::CoeffReturnType>::ResScalar 
      CoeffReturnType;
00081   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorContractionOp>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Nested};
00082   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorContractionOp>::StorageKind}
       StorageKind;
00083   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorContractionOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00084 
00085   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_contraction_op}{TensorContractionOp}(
00086       \textcolor{keyword}{const} LhsXprType& lhs, \textcolor{keyword}{const} RhsXprType& rhs, \textcolor{keyword}{const} Indices& dims)
00087       : m\_lhs\_xpr(lhs), m\_rhs\_xpr(rhs), m\_indices(dims) \{\}
00088 
00089   EIGEN\_DEVICE\_FUNC
00090   \textcolor{keyword}{const} Indices& indices()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_indices; \}
00091 
00093   EIGEN\_DEVICE\_FUNC
00094   \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename LhsXprType::Nested>::type}
      &
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_contraction_8h_source_l00095}\hyperlink{class_eigen_1_1_tensor_contraction_op_a1e3bb92babac5554f7164b12e9654daa}{00095}   \hyperlink{class_eigen_1_1_tensor_contraction_op_a1e3bb92babac5554f7164b12e9654daa}{lhsExpression}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhs\_xpr; \}
00096 
00097   EIGEN\_DEVICE\_FUNC
00098   \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename RhsXprType::Nested>::type}
      &
00099   rhsExpression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rhs\_xpr; \}
00100 
00101   \textcolor{keyword}{protected}:
00102     \textcolor{keyword}{typename} LhsXprType::Nested m\_lhs\_xpr;
00103     \textcolor{keyword}{typename} RhsXprType::Nested m\_rhs\_xpr;
00104     \textcolor{keyword}{const} Indices m\_indices;
00105 \};
00106 
00107 
00108 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_contraction_8h_source_l00109}\hyperlink{struct_eigen_1_1_tensor_contraction_evaluator_base}{00109} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_contraction_evaluator_base}{TensorContractionEvaluatorBase}
00110 \{
00111   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Indices} Indices;
00112   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::LeftArgType} LeftArgType
      ;
00113   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::RightArgType} 
      RightArgType;
00114   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Device} Device;
00115 
00116   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_contraction_op}{TensorContractionOp<Indices, LeftArgType, RightArgType>}
       \hyperlink{class_eigen_1_1_tensor_contraction_op}{XprType};
00117   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<typename XprType::Scalar>::type}
       \hyperlink{group___sparse_core___module}{Scalar};
00118   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00119   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00120   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00121 
00122   \textcolor{keyword}{enum} \{
00123     IsAligned = \textcolor{keyword}{true},
00124     PacketAccess = (\hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size}
       > 1),
00125     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::Layout},
00126     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00127     RawAccess = \textcolor{keyword}{true}
00128   \};
00129 
00130   \textcolor{comment}{// Most of the code is assuming that both input tensors are ColMajor. If the}
00131   \textcolor{comment}{// inputs are RowMajor, we will "cheat" by swapping the LHS and RHS:}
00132   \textcolor{comment}{// If we want to compute A * B = C, where A is LHS and B is RHS, the code}
00133   \textcolor{comment}{// will pretend B is LHS and A is RHS.}
00134   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{internal::conditional}<
00135     \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}), LeftArgType, RightArgType>::type 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{EvalLeftArgType};
00136   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{internal::conditional}<
00137     \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}), RightArgType, LeftArgType>::type 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{EvalRightArgType};
00138 
00139   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} LDims =
00140       
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<EvalLeftArgType, Device>::Dimensions}
      >::value;
00141   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} RDims =
00142       
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<EvalRightArgType, Device>::Dimensions}
      >::value;
00143   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} ContractDims = \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<Indices>::value};
00144   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = LDims + RDims - 2 * ContractDims;
00145 
00146   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1array}{array<Index, ContractDims>} \hyperlink{class_eigen_1_1array}{contract\_t};
00147   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1array}{array}<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, LDims - ContractDims> \hyperlink{class_eigen_1_1array}{left\_nocontract\_t};
00148   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1array}{array}<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, RDims - ContractDims> \hyperlink{class_eigen_1_1array}{right\_nocontract\_t};
00149 
00150   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumDims>} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00151 
00152   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00153   \hyperlink{struct_eigen_1_1_tensor_contraction_evaluator_base}{TensorContractionEvaluatorBase}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00154     : m\_leftImpl(choose(\hyperlink{struct_eigen_1_1_cond}{Cond}<static\_cast<int>(Layout) == static\_cast<int>(
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})>(),
00155                           op.\hyperlink{class_eigen_1_1_tensor_contraction_op_a1e3bb92babac5554f7164b12e9654daa}{lhsExpression}(), op.rhsExpression()), device),
00156     m\_rightImpl(choose(\hyperlink{struct_eigen_1_1_cond}{Cond}<static\_cast<int>(Layout) == static\_cast<int>(
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})>(),
00157                           op.rhsExpression(), op.\hyperlink{class_eigen_1_1_tensor_contraction_op_a1e3bb92babac5554f7164b12e9654daa}{lhsExpression}()), device),
00158         m\_device(device),
00159         m\_result(NULL) \{
00160     EIGEN\_STATIC\_ASSERT((static\_cast<int>(
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::Layout}) ==
00161                static\_cast<int>(\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<RightArgType, Device>::Layout}
      )),
00162                         YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00163 
00164 
00165     \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, LDims>} eval\_left\_dims;
00166     \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, RDims>} eval\_right\_dims;
00167     \hyperlink{class_eigen_1_1array}{array<IndexPair<Index>}, ContractDims> eval\_op\_indices;
00168     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00169       \textcolor{comment}{// For ColMajor, we keep using the existing dimensions}
00170       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < LDims; i++) \{
00171         eval\_left\_dims[i] = m\_leftImpl.dimensions()[i];
00172       \}
00173       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < RDims; i++) \{
00174         eval\_right\_dims[i] = m\_rightImpl.dimensions()[i];
00175       \}
00176       \textcolor{comment}{// We keep the pairs of contracting indices.}
00177       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < ContractDims; i++) \{
00178         eval\_op\_indices[i].first = op.indices()[i].first;
00179         eval\_op\_indices[i].second = op.indices()[i].second;
00180       \}
00181     \} \textcolor{keywordflow}{else} \{
00182       \textcolor{comment}{// For RowMajor, we need to reverse the existing dimensions}
00183       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < LDims; i++) \{
00184         eval\_left\_dims[i] = m\_leftImpl.dimensions()[LDims - i - 1];
00185       \}
00186       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < RDims; i++) \{
00187         eval\_right\_dims[i] = m\_rightImpl.dimensions()[RDims - i - 1];
00188       \}
00189       \textcolor{comment}{// We need to flip all the pairs of contracting indices as well as}
00190       \textcolor{comment}{// reversing the dimensions.}
00191       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < ContractDims; i++) \{
00192         eval\_op\_indices[i].first = LDims - 1 - op.indices()[ContractDims - 1 - i].second;
00193         eval\_op\_indices[i].second = RDims - 1 - op.indices()[ContractDims - 1 - i].first;
00194       \}
00195     \}
00196 
00197     \textcolor{comment}{// Check for duplicate axes and make sure the first index in eval\_op\_indices}
00198     \textcolor{comment}{// is increasing. Using O(n^2) sorting is OK since ContractDims is small}
00199     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < ContractDims; i++) \{
00200       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = i + 1; j < ContractDims; j++) \{
00201         eigen\_assert(eval\_op\_indices[j].first != eval\_op\_indices[i].first &&
00202                      eval\_op\_indices[j].second != eval\_op\_indices[i].second &&
00203                      \textcolor{stringliteral}{"contraction axes should be unique"});
00204         \textcolor{keywordflow}{if} (eval\_op\_indices[j].first < eval\_op\_indices[i].first) \{
00205           \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{numext::swap}(eval\_op\_indices[j], eval\_op\_indices[i]);
00206         \}
00207       \}
00208     \}
00209 
00210     \hyperlink{class_eigen_1_1array}{array<Index, LDims>} lhs\_strides;
00211     lhs\_strides[0] = 1;
00212     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < LDims-1; ++i) \{
00213       lhs\_strides[i+1] = lhs\_strides[i] * eval\_left\_dims[i];
00214     \}
00215 
00216     \hyperlink{class_eigen_1_1array}{array<Index, RDims>} rhs\_strides;
00217     rhs\_strides[0] = 1;
00218     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < RDims-1; ++i) \{
00219       rhs\_strides[i+1] = rhs\_strides[i] * eval\_right\_dims[i];
00220     \}
00221 
00222     \textcolor{keywordflow}{if} (m\_i\_strides.size() > 0) m\_i\_strides[0] = 1;
00223     \textcolor{keywordflow}{if} (m\_j\_strides.size() > 0) m\_j\_strides[0] = 1;
00224     \textcolor{keywordflow}{if} (m\_k\_strides.size() > 0) m\_k\_strides[0] = 1;
00225 
00226     m\_i\_size = 1;
00227     m\_j\_size = 1;
00228     m\_k\_size = 1;
00229 
00230     \textcolor{comment}{// To compute the dimension, we simply concatenate the non-contracting}
00231     \textcolor{comment}{// dimensions of the left and then the right tensor. Additionally, we also}
00232     \textcolor{comment}{// compute the strides corresponding to the left non-contracting}
00233     \textcolor{comment}{// dimensions and right non-contracting dimensions.}
00234     m\_lhs\_inner\_dim\_contiguous = \textcolor{keyword}{true};
00235     \textcolor{keywordtype}{int} dim\_idx = 0;
00236     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nocontract\_idx = 0;
00237 
00238     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < LDims; i++) \{
00239       \textcolor{comment}{// find if we are contracting on index i of left tensor}
00240       \textcolor{keywordtype}{bool} contracting = \textcolor{keyword}{false};
00241       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < ContractDims; j++) \{
00242         \textcolor{keywordflow}{if} (eval\_op\_indices[j].first == i) \{
00243           contracting = \textcolor{keyword}{true};
00244           \textcolor{keywordflow}{break};
00245         \}
00246       \}
00247       \textcolor{keywordflow}{if} (!contracting) \{
00248         \textcolor{comment}{// add dimension size to output dimensions}
00249         m\_dimensions[dim\_idx] = eval\_left\_dims[i];
00250         m\_left\_nocontract\_strides[nocontract\_idx] = lhs\_strides[i];
00251         \textcolor{keywordflow}{if} (dim\_idx != i) \{
00252           m\_lhs\_inner\_dim\_contiguous = \textcolor{keyword}{false};
00253         \}
00254         \textcolor{keywordflow}{if} (nocontract\_idx+1 < \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<left\_nocontract\_t>::value}
      ) \{
00255           m\_i\_strides[nocontract\_idx+1] =
00256               m\_i\_strides[nocontract\_idx] * eval\_left\_dims[i];
00257         \} \textcolor{keywordflow}{else} \{
00258           m\_i\_size = m\_i\_strides[nocontract\_idx] * eval\_left\_dims[i];
00259         \}
00260         dim\_idx++;
00261         nocontract\_idx++;
00262       \}
00263     \}
00264 
00265     nocontract\_idx = 0;
00266     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < RDims; i++) \{
00267       \textcolor{keywordtype}{bool} contracting = \textcolor{keyword}{false};
00268       \textcolor{comment}{// find if we are contracting on index i of right tensor}
00269       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < ContractDims; j++) \{
00270         \textcolor{keywordflow}{if} (eval\_op\_indices[j].second == i) \{
00271           contracting = \textcolor{keyword}{true};
00272           \textcolor{keywordflow}{break};
00273         \}
00274       \}
00275       \textcolor{keywordflow}{if} (!contracting) \{
00276         m\_dimensions[dim\_idx] = eval\_right\_dims[i];
00277         \textcolor{keywordflow}{if} (nocontract\_idx+1 < \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<right\_nocontract\_t>::value}
      ) \{
00278           m\_j\_strides[nocontract\_idx+1] =
00279               m\_j\_strides[nocontract\_idx] * eval\_right\_dims[i];
00280         \} \textcolor{keywordflow}{else} \{
00281           m\_j\_size = m\_j\_strides[nocontract\_idx] * eval\_right\_dims[i];
00282         \}
00283         m\_right\_nocontract\_strides[nocontract\_idx] = rhs\_strides[i];
00284         dim\_idx++;
00285         nocontract\_idx++;
00286       \}
00287     \}
00288 
00289     \textcolor{comment}{// Now compute the strides corresponding to the contracting dimensions. We}
00290     \textcolor{comment}{// assumed above that non-contracting axes are represented in the same order}
00291     \textcolor{comment}{// in the matrix as they are in the tensor. This is not the case for}
00292     \textcolor{comment}{// contracting axes. As the contracting axes must be of the same size in}
00293     \textcolor{comment}{// each tensor, we'll only look at the first tensor here.}
00294     m\_rhs\_inner\_dim\_contiguous = \textcolor{keyword}{true};
00295     m\_rhs\_inner\_dim\_reordered = \textcolor{keyword}{false};
00296     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < ContractDims; i++) \{
00297       Index left = eval\_op\_indices[i].first;
00298       Index right = eval\_op\_indices[i].second;
00299 
00300       Index size = eval\_left\_dims[left];
00301       eigen\_assert(size == eval\_right\_dims[right] &&
00302                    \textcolor{stringliteral}{"Contraction axes must be same size"});
00303 
00304       \textcolor{keywordflow}{if} (i+1 < static\_cast<int>(\hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<contract\_t>::value}
      )) \{
00305         m\_k\_strides[i+1] = m\_k\_strides[i] * size;
00306       \} \textcolor{keywordflow}{else} \{
00307         m\_k\_size = m\_k\_strides[i] * size;
00308       \}
00309       m\_left\_contracting\_strides[i] = lhs\_strides[left];
00310       m\_right\_contracting\_strides[i] = rhs\_strides[right];
00311 
00312       \textcolor{keywordflow}{if} (i > 0 && right < eval\_op\_indices[i-1].second) \{
00313         m\_rhs\_inner\_dim\_reordered = \textcolor{keyword}{true};
00314       \}
00315       \textcolor{keywordflow}{if} (right != i) \{
00316         m\_rhs\_inner\_dim\_contiguous = \textcolor{keyword}{false};
00317       \}
00318     \}
00319 
00320     \textcolor{comment}{// If the layout is RowMajor, we need to reverse the m\_dimensions}
00321     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor})) \{
00322       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0, j = NumDims - 1; i < j; i++, j--) \{
00323         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{numext::swap}(m\_dimensions[i], m\_dimensions[j]);
00324       \}
00325     \}
00326   \}
00327 
00328   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00329 
00330   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* data) \{
00331     m\_leftImpl.evalSubExprsIfNeeded(NULL);
00332     m\_rightImpl.evalSubExprsIfNeeded(NULL);
00333     \textcolor{keywordflow}{if} (data) \{
00334       evalTo(data);
00335       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00336     \} \textcolor{keywordflow}{else} \{
00337       m\_result = \textcolor{keyword}{static\_cast<}Scalar *\textcolor{keyword}{>}(m\_device.allocate(dimensions().TotalSize() * \textcolor{keyword}{sizeof}(Scalar)));
00338       evalTo(m\_result);
00339       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00340     \}
00341   \}
00342 
00343   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} evalTo(Scalar* buffer)\textcolor{keyword}{ const }\{
00344     \textcolor{keywordflow}{if} (this->m\_lhs\_inner\_dim\_contiguous) \{
00345       \textcolor{keywordflow}{if} (this->m\_rhs\_inner\_dim\_contiguous) \{
00346         \textcolor{keywordflow}{if} (this->m\_rhs\_inner\_dim\_reordered) \{
00347           \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Derived*\textcolor{keyword}{>}(\textcolor{keyword}{this})->\textcolor{keyword}{template} evalProduct<true, true, true, Unaligned>(buffer);
00348         \}
00349         \textcolor{keywordflow}{else} \{
00350           \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Derived*\textcolor{keyword}{>}(\textcolor{keyword}{this})->\textcolor{keyword}{template} evalProduct<true, true, false, Unaligned>(buffer);
00351         \}
00352       \}
00353       \textcolor{keywordflow}{else} \{
00354        \textcolor{keywordflow}{if} (this->m\_rhs\_inner\_dim\_reordered) \{
00355           \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Derived*\textcolor{keyword}{>}(\textcolor{keyword}{this})->\textcolor{keyword}{template} evalProduct<true, false, true, Unaligned>(buffer);
00356         \}
00357         \textcolor{keywordflow}{else} \{
00358           \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Derived*\textcolor{keyword}{>}(\textcolor{keyword}{this})->\textcolor{keyword}{template} evalProduct<true, false, false, Unaligned>(buffer);
00359         \}
00360       \}
00361     \}
00362     \textcolor{keywordflow}{else} \{
00363       \textcolor{keywordflow}{if} (this->m\_rhs\_inner\_dim\_contiguous) \{
00364         \textcolor{keywordflow}{if} (this->m\_rhs\_inner\_dim\_reordered) \{
00365           \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Derived*\textcolor{keyword}{>}(\textcolor{keyword}{this})->\textcolor{keyword}{template} evalProduct<false, true, true, Unaligned>(buffer);
00366         \}
00367         \textcolor{keywordflow}{else} \{
00368           \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Derived*\textcolor{keyword}{>}(\textcolor{keyword}{this})->\textcolor{keyword}{template} evalProduct<false, true, false, Unaligned>(buffer);
00369         \}
00370       \}
00371       \textcolor{keywordflow}{else} \{
00372        \textcolor{keywordflow}{if} (this->m\_rhs\_inner\_dim\_reordered) \{
00373           \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Derived*\textcolor{keyword}{>}(\textcolor{keyword}{this})->\textcolor{keyword}{template} evalProduct<false, false, true, Unaligned>(buffer);
00374         \}
00375         \textcolor{keywordflow}{else} \{
00376           \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Derived*\textcolor{keyword}{>}(\textcolor{keyword}{this})->\textcolor{keyword}{template} evalProduct<false, false, false, Unaligned>(buffer);
00377         \}
00378       \}
00379     \}
00380   \}
00381 
00382   \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} lhs\_inner\_dim\_contiguous, \textcolor{keywordtype}{bool} rhs\_inner\_dim\_contiguous, \textcolor{keywordtype}{bool} rhs\_inner\_dim\_reordered, \textcolor{keywordtype}{int}
       Alignment>
00383   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} evalGemv(Scalar* buffer)\textcolor{keyword}{ const }\{
00384     \textcolor{keyword}{const} Index rows = m\_i\_size;
00385     \textcolor{keyword}{const} Index cols = m\_k\_size;
00386 
00387     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___sparse_core___module}{internal::remove\_const<typename EvalLeftArgType::Scalar>::type}
       LhsScalar;
00388     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___sparse_core___module}{internal::remove\_const<typename EvalRightArgType::Scalar>::type}
       RhsScalar;
00389     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<EvalLeftArgType, Device>} LeftEvaluator;
00390     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<EvalRightArgType, Device>} 
      RightEvaluator;
00391     \textcolor{keyword}{const} Index lhs\_packet\_size = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<typename LeftEvaluator::PacketReturnType>::size}
      ;
00392     \textcolor{keyword}{const} Index rhs\_packet\_size = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<typename RightEvaluator::PacketReturnType>::size}
      ;
00393     \textcolor{keyword}{const} \textcolor{keywordtype}{int} lhs\_alignment = LeftEvaluator::IsAligned ? \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned} : 
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned};
00394     \textcolor{keyword}{const} \textcolor{keywordtype}{int} rhs\_alignment = RightEvaluator::IsAligned ? \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned} : 
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned};
00395     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1_tensor_contraction_input_mapper}{internal::TensorContractionInputMapper}<LhsScalar, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, internal::Lhs,
00396                                                    LeftEvaluator, left\_nocontract\_t,
00397                                                    contract\_t, lhs\_packet\_size,
00398                                                    lhs\_inner\_dim\_contiguous,
00399                                                    \textcolor{keyword}{false}, lhs\_alignment> LhsMapper;
00400 
00401     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1_tensor_contraction_input_mapper}{internal::TensorContractionInputMapper}<RhsScalar, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, internal::Rhs,
00402                                                    RightEvaluator, right\_nocontract\_t,
00403                                                    contract\_t, rhs\_packet\_size,
00404                                                    rhs\_inner\_dim\_contiguous,
00405                                                    rhs\_inner\_dim\_reordered, rhs\_alignment> RhsMapper;
00406 
00407     LhsMapper lhs(m\_leftImpl, m\_left\_nocontract\_strides, m\_i\_strides,
00408                   m\_left\_contracting\_strides, m\_k\_strides);
00409     RhsMapper rhs(m\_rightImpl, m\_right\_nocontract\_strides, m\_j\_strides,
00410                   m\_right\_contracting\_strides, m\_k\_strides);
00411 
00412     \textcolor{keyword}{const} Scalar alpha(1);
00413     \textcolor{keyword}{const} Index resIncr(1);
00414 
00415     \textcolor{comment}{// zero out the result buffer (which must be of size at least rows * sizeof(Scalar)}
00416     m\_device.memset(buffer, 0, rows * \textcolor{keyword}{sizeof}(Scalar));
00417 
00418     
      \hyperlink{struct_eigen_1_1internal_1_1general__matrix__vector__product}{
      internal::general\_matrix\_vector\_product<Index,LhsScalar,LhsMapper,ColMajor,false,RhsScalar,RhsMapper,false>::run}
      (
00419         rows, cols, lhs, rhs,
00420         buffer, resIncr, alpha);
00421   \}
00422 
00423   \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} lhs\_inner\_dim\_contiguous, \textcolor{keywordtype}{bool} rhs\_inner\_dim\_contiguous, \textcolor{keywordtype}{bool} rhs\_inner\_dim\_reordered, \textcolor{keywordtype}{int}
       Alignment>
00424   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} evalGemm(Scalar* buffer)\textcolor{keyword}{ const }\{
00425     \textcolor{comment}{// columns in left side, rows in right side}
00426     \textcolor{keyword}{const} Index k = this->m\_k\_size;
00427 
00428     \textcolor{comment}{// rows in left side}
00429     \textcolor{keyword}{const} Index m = this->m\_i\_size;
00430 
00431     \textcolor{comment}{// columns in right side}
00432     \textcolor{keyword}{const} Index n = this->m\_j\_size;
00433 
00434     \textcolor{comment}{// zero out the result buffer (which must be of size at least m * n * sizeof(Scalar)}
00435     this->m\_device.memset(buffer, 0, m * n * \textcolor{keyword}{sizeof}(Scalar));
00436 
00437     \textcolor{comment}{// define mr, nr, and all of my data mapper types}
00438     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___sparse_core___module}{internal::remove\_const<typename EvalLeftArgType::Scalar>::type}
       LhsScalar;
00439     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___sparse_core___module}{internal::remove\_const<typename EvalRightArgType::Scalar>::type}
       RhsScalar;
00440     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1gebp__traits}{internal::gebp\_traits<LhsScalar, RhsScalar>}
       Traits;
00441 
00442     \textcolor{keyword}{const} Index nr = Traits::nr;
00443     \textcolor{keyword}{const} Index mr = Traits::mr;
00444 
00445     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<EvalLeftArgType, Device>} LeftEvaluator;
00446     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<EvalRightArgType, Device>} 
      RightEvaluator;
00447 
00448     \textcolor{keyword}{const} Index lhs\_packet\_size = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<typename LeftEvaluator::PacketReturnType>::size}
      ;
00449     \textcolor{keyword}{const} Index rhs\_packet\_size = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<typename RightEvaluator::PacketReturnType>::size}
      ;
00450 
00451     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1_tensor_contraction_input_mapper}{internal::TensorContractionInputMapper}<LhsScalar, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, internal::Lhs,
00452                                                    LeftEvaluator, left\_nocontract\_t,
00453                                                    contract\_t, lhs\_packet\_size,
00454                                                    lhs\_inner\_dim\_contiguous,
00455                                                    \textcolor{keyword}{false}, \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}> LhsMapper;
00456 
00457     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1_tensor_contraction_input_mapper}{internal::TensorContractionInputMapper}<RhsScalar, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, internal::Rhs,
00458                                                    RightEvaluator, right\_nocontract\_t,
00459                                                    contract\_t, rhs\_packet\_size,
00460                                                    rhs\_inner\_dim\_contiguous,
00461                                                    rhs\_inner\_dim\_reordered, 
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}> RhsMapper;
00462 
00463     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1blas__data__mapper}{internal::blas\_data\_mapper<Scalar, Index, ColMajor>}
       OutputMapper;
00464 
00465     \textcolor{comment}{// Declare GEBP packing and kernel structs}
00466     
      \hyperlink{struct_eigen_1_1internal_1_1gemm__pack__lhs}{internal::gemm\_pack\_lhs<LhsScalar, Index, typename LhsMapper::SubMapper, mr, Traits::LhsProgress, ColMajor>}
       pack\_lhs;
00467     
      \hyperlink{struct_eigen_1_1internal_1_1gemm__pack__rhs}{internal::gemm\_pack\_rhs<RhsScalar, Index, typename RhsMapper::SubMapper, nr, ColMajor>}
       pack\_rhs;
00468 
00469     
      \hyperlink{struct_eigen_1_1internal_1_1gebp__kernel}{internal::gebp\_kernel<LhsScalar, RhsScalar, Index, OutputMapper, mr, nr, false, false>}
       gebp;
00470 
00471     \textcolor{comment}{// initialize data mappers}
00472     LhsMapper lhs(this->m\_leftImpl, this->m\_left\_nocontract\_strides, this->m\_i\_strides,
00473                   this->m\_left\_contracting\_strides, this->m\_k\_strides);
00474 
00475     RhsMapper rhs(this->m\_rightImpl, this->m\_right\_nocontract\_strides, this->m\_j\_strides,
00476                   this->m\_right\_contracting\_strides, this->m\_k\_strides);
00477 
00478     OutputMapper output(buffer, m);
00479 
00480     \textcolor{comment}{// Sizes of the blocks to load in cache. See the Goto paper for details.}
00481     
      \hyperlink{class_eigen_1_1internal_1_1_tensor_contraction_blocking}{internal::TensorContractionBlocking<LhsMapper, RhsMapper, Index, internal::ShardByCol>}
       blocking(k, m, n, 1);
00482     \textcolor{keyword}{const} Index kc = blocking.kc();
00483     \textcolor{keyword}{const} Index mc = numext::mini(m, blocking.mc());
00484     \textcolor{keyword}{const} Index nc = numext::mini(n, blocking.nc());
00485     \textcolor{keyword}{const} Index sizeA = mc * kc;
00486     \textcolor{keyword}{const} Index sizeB = kc * nc;
00487 
00488     LhsScalar* blockA = \textcolor{keyword}{static\_cast<}LhsScalar *\textcolor{keyword}{>}(this->m\_device.allocate(sizeA * \textcolor{keyword}{sizeof}(LhsScalar)));
00489     RhsScalar* blockB = \textcolor{keyword}{static\_cast<}RhsScalar *\textcolor{keyword}{>}(this->m\_device.allocate(sizeB * \textcolor{keyword}{sizeof}(RhsScalar)));
00490 
00491     \textcolor{keywordflow}{for}(Index i2=0; i2<m; i2+=mc)
00492     \{
00493       \textcolor{keyword}{const} Index actual\_mc = numext::mini(i2+mc,m)-i2;
00494       \textcolor{keywordflow}{for} (Index k2 = 0; k2 < k; k2 += kc) \{
00495         \textcolor{comment}{// make sure we don't overshoot right edge of left matrix, then pack vertical panel}
00496         \textcolor{keyword}{const} Index actual\_kc = numext::mini(k2 + kc, k) - k2;
00497         pack\_lhs(blockA, lhs.getSubMapper(i2, k2), actual\_kc, actual\_mc, 0, 0);
00498 
00499         \textcolor{comment}{// series of horizontal blocks}
00500         \textcolor{keywordflow}{for} (Index j2 = 0; j2 < n; j2 += nc) \{
00501           \textcolor{comment}{// make sure we don't overshoot right edge of right matrix, then pack block}
00502           \textcolor{keyword}{const} Index actual\_nc = numext::mini(j2 + nc, n) - j2;
00503           pack\_rhs(blockB, rhs.getSubMapper(k2, j2), actual\_kc, actual\_nc, 0, 0);
00504 
00505           \textcolor{comment}{// call gebp (matrix kernel)}
00506           \textcolor{comment}{// The parameters here are copied from Eigen's GEMM implementation}
00507           gebp(output.getSubMapper(i2, j2), blockA, blockB, actual\_mc, actual\_kc, actual\_nc, Scalar(1), -1,
       -1, 0, 0);
00508         \}
00509       \}
00510     \}
00511 
00512     this->m\_device.deallocate(blockA);
00513     this->m\_device.deallocate(blockB);
00514   \}
00515 
00516   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00517     m\_leftImpl.cleanup();
00518     m\_rightImpl.cleanup();
00519 
00520     \textcolor{keywordflow}{if} (m\_result != NULL) \{
00521       m\_device.deallocate(m\_result);
00522       m\_result = NULL;
00523     \}
00524   \}
00525 
00526   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const }\{
00527     \textcolor{keywordflow}{return} m\_result[index];
00528   \}
00529 
00530   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost} costPerCoeff(\textcolor{keywordtype}{bool})\textcolor{keyword}{ const }\{
00531     \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(\textcolor{keyword}{sizeof}(CoeffReturnType), 0, 0);
00532   \}
00533 
00534   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00535   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const }\{
00536     \textcolor{keywordflow}{return} internal::ploadt<PacketReturnType, LoadMode>(m\_result + index);
00537   \}
00538 
00539   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_result; \}
00540 
00541   \textcolor{keyword}{protected}:
00542   \textcolor{comment}{// Prevent assignment}
00543   TensorContractionEvaluatorBase& operator = (\textcolor{keyword}{const} TensorContractionEvaluatorBase&);
00544   Dimensions m\_dimensions;
00545 
00546   contract\_t m\_k\_strides;
00547   contract\_t m\_left\_contracting\_strides;
00548   contract\_t m\_right\_contracting\_strides;
00549 
00550   \textcolor{keywordtype}{bool} m\_lhs\_inner\_dim\_contiguous;
00551   \textcolor{keywordtype}{bool} m\_rhs\_inner\_dim\_contiguous;
00552   \textcolor{keywordtype}{bool} m\_rhs\_inner\_dim\_reordered;
00553 
00554   left\_nocontract\_t m\_i\_strides;
00555   right\_nocontract\_t m\_j\_strides;
00556   left\_nocontract\_t m\_left\_nocontract\_strides;
00557   right\_nocontract\_t m\_right\_nocontract\_strides;
00558 
00559   Index m\_i\_size;
00560   Index m\_j\_size;
00561   Index m\_k\_size;
00562 
00563   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<EvalLeftArgType, Device>} m\_leftImpl;
00564   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<EvalRightArgType, Device>} m\_rightImpl;
00565   \textcolor{keyword}{const} Device& m\_device;
00566   Scalar* m\_result;
00567 \};
00568 
00569 
00570 \textcolor{comment}{// evaluator for default device}
00571 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Indices, \textcolor{keyword}{typename} LeftArgType, \textcolor{keyword}{typename} RightArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_contraction_8h_source_l00572}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_contraction_op_3_01_indices_00_01_left_arg1f297d3eabde0efec8e4d9b1aa9abe5a}{00572} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_contraction_op}{TensorContractionOp}<Indices, LeftArgType, 
      RightArgType>, Device> :
00573     \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1_tensor_contraction_evaluator_base}{TensorContractionEvaluatorBase}<
00574       TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, Device> > \{
00575   \textcolor{keyword}{typedef} 
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>}
      , Device> \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_contraction_op_3_01_indices_00_01_left_arg1f297d3eabde0efec8e4d9b1aa9abe5a}{Self};
00576   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_tensor_contraction_evaluator_base}{TensorContractionEvaluatorBase<Self>} 
      \hyperlink{struct_eigen_1_1_tensor_contraction_evaluator_base}{Base};
00577 
00578   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_contraction_op}{TensorContractionOp<Indices, LeftArgType, RightArgType>}
       \hyperlink{class_eigen_1_1_tensor_contraction_op}{XprType};
00579   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<typename XprType::Scalar>::type}
       \hyperlink{group___sparse_core___module}{Scalar};
00580   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00581   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00582   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00583 
00584   \textcolor{keyword}{enum} \{
00585     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::Layout}
00586   \};
00587 
00588   \textcolor{comment}{// Most of the code is assuming that both input tensors are ColMajor. If the}
00589   \textcolor{comment}{// inputs are RowMajor, we will "cheat" by swapping the LHS and RHS:}
00590   \textcolor{comment}{// If we want to compute A * B = C, where A is LHS and B is RHS, the code}
00591   \textcolor{comment}{// will pretend B is LHS and A is RHS.}
00592   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{internal::conditional}<
00593     \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}), LeftArgType, RightArgType>::type 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{EvalLeftArgType};
00594   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{internal::conditional}<
00595     \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}), RightArgType, LeftArgType>::type 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{EvalRightArgType};
00596 
00597   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} LDims =
00598       
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<EvalLeftArgType, Device>::Dimensions}
      >::value;
00599   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} RDims =
00600       
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<EvalRightArgType, Device>::Dimensions}
      >::value;
00601   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} ContractDims = \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<Indices>::value};
00602 
00603   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1array}{array<Index, ContractDims>} \hyperlink{class_eigen_1_1array}{contract\_t};
00604   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1array}{array}<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, LDims - ContractDims> \hyperlink{class_eigen_1_1array}{left\_nocontract\_t};
00605   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1array}{array}<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, RDims - ContractDims> \hyperlink{class_eigen_1_1array}{right\_nocontract\_t};
00606 
00607   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = LDims + RDims - 2 * ContractDims;
00608 
00609   \textcolor{comment}{// Could we use NumDimensions here?}
00610   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumDims>} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00611 
00612   EIGEN\_DEVICE\_FUNC \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device) :
00613       Base(op, device) \{ \}
00614 
00615   \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} lhs\_inner\_dim\_contiguous, \textcolor{keywordtype}{bool} rhs\_inner\_dim\_contiguous, \textcolor{keywordtype}{bool} rhs\_inner\_dim\_reordered, \textcolor{keywordtype}{int}
       Alignment>
00616   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} evalProduct(Scalar* buffer)\textcolor{keyword}{ const }\{
00617     \textcolor{keywordflow}{if} (this->m\_j\_size == 1) \{
00618       this->\textcolor{keyword}{template} evalGemv<lhs\_inner\_dim\_contiguous, rhs\_inner\_dim\_contiguous, rhs\_inner\_dim\_reordered,
       Alignment>(buffer);
00619       \textcolor{keywordflow}{return};
00620     \}
00621 
00622     this->\textcolor{keyword}{template} evalGemm<lhs\_inner\_dim\_contiguous, rhs\_inner\_dim\_contiguous, rhs\_inner\_dim\_reordered,
       Alignment>(buffer);
00623   \}
00624 \};
00625 
00626 \} \textcolor{comment}{// end namespace Eigen}
00627 
00628 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_CONTRACTION\_H}
\end{DoxyCode}
