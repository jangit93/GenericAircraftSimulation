\hypertarget{matio_2visual__studio_2test_2eigen_2test_2evaluators_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/evaluators.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2evaluators_8cpp_source}\index{evaluators.\+cpp@{evaluators.\+cpp}}

\begin{DoxyCode}
00001 
00002 \textcolor{preprocessor}{#include "main.h"}
00003 
00004 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00005 
00006   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs,\textcolor{keyword}{typename} Rhs>
00007   \textcolor{keyword}{const} \hyperlink{group___core___module}{Product<Lhs,Rhs>}
00008   prod(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs)
00009   \{
00010     \textcolor{keywordflow}{return} \hyperlink{group___core___module}{Product<Lhs,Rhs>}(lhs,rhs);
00011   \}
00012 
00013   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs,\textcolor{keyword}{typename} Rhs>
00014   \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_product}{Product<Lhs,Rhs,LazyProduct>}
00015   lazyprod(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs)
00016   \{
00017     \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_product}{Product<Lhs,Rhs,LazyProduct>}(lhs,rhs);
00018   \}
00019   
00020   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType>
00021   EIGEN\_STRONG\_INLINE
00022   DstXprType& copy\_using\_evaluator(\textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<DstXprType>} &dst, \textcolor{keyword}{const} SrcXprType 
      &src)
00023   \{
00024     call\_assignment(dst.const\_cast\_derived(), src.derived(), internal::assign\_op<typename
       DstXprType::Scalar,typename SrcXprType::Scalar>());
00025     \textcolor{keywordflow}{return} dst.const\_cast\_derived();
00026   \}
00027   
00028   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{class }StorageBase, \textcolor{keyword}{typename} SrcXprType>
00029   EIGEN\_STRONG\_INLINE
00030   \textcolor{keyword}{const} DstXprType& copy\_using\_evaluator(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_no_alias}{NoAlias<DstXprType, StorageBase>}
      & dst, \textcolor{keyword}{const} SrcXprType &src)
00031   \{
00032     call\_assignment(dst, src.derived(), internal::assign\_op<typename DstXprType::Scalar,typename
       SrcXprType::Scalar>());
00033     \textcolor{keywordflow}{return} dst.expression();
00034   \}
00035   
00036   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType>
00037   EIGEN\_STRONG\_INLINE
00038   DstXprType& copy\_using\_evaluator(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase<DstXprType>} &dst, \textcolor{keyword}{const}
       SrcXprType &src)
00039   \{
00040 \textcolor{preprocessor}{    #ifdef EIGEN\_NO\_AUTOMATIC\_RESIZING}
00041     eigen\_assert((dst.size()==0 || (IsVectorAtCompileTime ? (dst.size() == src.size())
00042                                                           : (dst.rows() == src.rows() && dst.cols() == src.
      cols())))
00043                 && \textcolor{stringliteral}{"Size mismatch. Automatic resizing is disabled because EIGEN\_NO\_AUTOMATIC\_RESIZING is
       defined"});
00044 \textcolor{preprocessor}{  #else}
00045     dst.const\_cast\_derived().\hyperlink{class_eigen_1_1_plain_object_base_acc7200947e6399bee847ff37c8270fc8}{resizeLike}(src.derived());
00046 \textcolor{preprocessor}{  #endif}
00047     
00048     call\_assignment(dst.const\_cast\_derived(), src.derived(), internal::assign\_op<typename
       DstXprType::Scalar,typename SrcXprType::Scalar>());
00049     \textcolor{keywordflow}{return} dst.const\_cast\_derived();
00050   \}
00051 
00052   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType>
00053   \textcolor{keywordtype}{void} add\_assign\_using\_evaluator(\textcolor{keyword}{const} DstXprType& dst, \textcolor{keyword}{const} SrcXprType& src)
00054   \{
00055     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::Scalar Scalar;
00056     call\_assignment(const\_cast<DstXprType&>(dst), src.derived(), internal::add\_assign\_op<Scalar,typename
       SrcXprType::Scalar>());
00057   \}
00058 
00059   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType>
00060   \textcolor{keywordtype}{void} subtract\_assign\_using\_evaluator(\textcolor{keyword}{const} DstXprType& dst, \textcolor{keyword}{const} SrcXprType& src)
00061   \{
00062     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::Scalar Scalar;
00063     call\_assignment(const\_cast<DstXprType&>(dst), src.derived(), internal::sub\_assign\_op<Scalar,typename
       SrcXprType::Scalar>());
00064   \}
00065 
00066   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType>
00067   \textcolor{keywordtype}{void} multiply\_assign\_using\_evaluator(\textcolor{keyword}{const} DstXprType& dst, \textcolor{keyword}{const} SrcXprType& src)
00068   \{
00069     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::Scalar Scalar;
00070     call\_assignment(dst.const\_cast\_derived(), src.derived(), internal::mul\_assign\_op<Scalar,typename
       SrcXprType::Scalar>());
00071   \}
00072 
00073   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType>
00074   \textcolor{keywordtype}{void} divide\_assign\_using\_evaluator(\textcolor{keyword}{const} DstXprType& dst, \textcolor{keyword}{const} SrcXprType& src)
00075   \{
00076     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::Scalar Scalar;
00077     call\_assignment(dst.const\_cast\_derived(), src.derived(), internal::div\_assign\_op<Scalar,typename
       SrcXprType::Scalar>());
00078   \}
00079   
00080   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType>
00081   \textcolor{keywordtype}{void} swap\_using\_evaluator(\textcolor{keyword}{const} DstXprType& dst, \textcolor{keyword}{const} SrcXprType& src)
00082   \{
00083     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::Scalar Scalar;
00084     call\_assignment(dst.const\_cast\_derived(), src.const\_cast\_derived(), internal::swap\_assign\_op<Scalar>())
      ;
00085   \}
00086 
00087   \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00088     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{class }StorageBase, \textcolor{keyword}{typename} Src, \textcolor{keyword}{typename} Func>
00089     EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} call\_assignment(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_no_alias}{NoAlias<Dst,StorageBase>}& dst, \textcolor{keyword}{
      const} Src& src, \textcolor{keyword}{const} Func& \hyperlink{structfunc}{func})
00090     \{
00091       call\_assignment\_no\_alias(dst.expression(), src, func);
00092     \}
00093   \}
00094   
00095 \}
00096 
00097 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType> \textcolor{keywordtype}{long} get\_cost(\textcolor{keyword}{const} XprType& ) \{ \textcolor{keywordflow}{return} 
      \hyperlink{struct_eigen_1_1internal_1_1evaluator}{Eigen::internal::evaluator<XprType>::CoeffReadCost}; \}
00098 
00099 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00100 
00101 \textcolor{preprocessor}{#define VERIFY\_IS\_APPROX\_EVALUATOR(DEST,EXPR) VERIFY\_IS\_APPROX(copy\_using\_evaluator(DEST,(EXPR)),
       (EXPR).eval());}
00102 \textcolor{preprocessor}{#define VERIFY\_IS\_APPROX\_EVALUATOR2(DEST,EXPR,REF) VERIFY\_IS\_APPROX(copy\_using\_evaluator(DEST,(EXPR)),
       (REF).eval());}
00103 
00104 \textcolor{keywordtype}{void} test\_evaluators()
00105 \{
00106   \textcolor{comment}{// Testing Matrix evaluator and Transpose}
00107   Vector2d v = Vector2d::Random();
00108   \textcolor{keyword}{const} Vector2d v\_const(v);
00109   Vector2d v2;
00110   RowVector2d w;
00111 
00112   VERIFY\_IS\_APPROX\_EVALUATOR(v2, v);
00113   VERIFY\_IS\_APPROX\_EVALUATOR(v2, v\_const);
00114 
00115   \textcolor{comment}{// Testing Transpose}
00116   VERIFY\_IS\_APPROX\_EVALUATOR(w, v.transpose()); \textcolor{comment}{// Transpose as rvalue}
00117   VERIFY\_IS\_APPROX\_EVALUATOR(w, v\_const.transpose());
00118 
00119   copy\_using\_evaluator(w.transpose(), v); \textcolor{comment}{// Transpose as lvalue}
00120   VERIFY\_IS\_APPROX(w,v.transpose().eval());
00121 
00122   copy\_using\_evaluator(w.transpose(), v\_const);
00123   VERIFY\_IS\_APPROX(w,v\_const.transpose().eval());
00124 
00125   \textcolor{comment}{// Testing Array evaluator}
00126   \{
00127     ArrayXXf a(2,3);
00128     ArrayXXf b(3,2);
00129     a << 1,2,3, 4,5,6;
00130     \textcolor{keyword}{const} ArrayXXf a\_const(a);
00131 
00132     VERIFY\_IS\_APPROX\_EVALUATOR(b, a.transpose());
00133 
00134     VERIFY\_IS\_APPROX\_EVALUATOR(b, a\_const.transpose());
00135 
00136     \textcolor{comment}{// Testing CwiseNullaryOp evaluator}
00137     copy\_using\_evaluator(w, RowVector2d::Random());
00138     VERIFY((w.array() >= -1).all() && (w.array() <= 1).all()); \textcolor{comment}{// not easy to test ...}
00139 
00140     VERIFY\_IS\_APPROX\_EVALUATOR(w, RowVector2d::Zero());
00141 
00142     VERIFY\_IS\_APPROX\_EVALUATOR(w, RowVector2d::Constant(3));
00143     
00144     \textcolor{comment}{// mix CwiseNullaryOp and transpose}
00145     VERIFY\_IS\_APPROX\_EVALUATOR(w, Vector2d::Zero().transpose());
00146   \}
00147 
00148   \{
00149     \textcolor{comment}{// test product expressions}
00150     \textcolor{keywordtype}{int} s = internal::random<int>(1,100);
00151     MatrixXf a(s,s), b(s,s), c(s,s), d(s,s);
00152     a.setRandom();
00153     b.setRandom();
00154     c.setRandom();
00155     d.setRandom();
00156     VERIFY\_IS\_APPROX\_EVALUATOR(d, (a + b));
00157     VERIFY\_IS\_APPROX\_EVALUATOR(d, (a + b).transpose());
00158     VERIFY\_IS\_APPROX\_EVALUATOR2(d, prod(a,b), a*b);
00159     VERIFY\_IS\_APPROX\_EVALUATOR2(d.noalias(), prod(a,b), a*b);
00160     VERIFY\_IS\_APPROX\_EVALUATOR2(d, prod(a,b) + c, a*b + c);
00161     VERIFY\_IS\_APPROX\_EVALUATOR2(d, s * prod(a,b), s * a*b);
00162     VERIFY\_IS\_APPROX\_EVALUATOR2(d, prod(a,b).transpose(), (a*b).transpose());
00163     VERIFY\_IS\_APPROX\_EVALUATOR2(d, prod(a,b) + prod(b,c), a*b + b*c);
00164 
00165     \textcolor{comment}{// check that prod works even with aliasing present}
00166     c = a*a;
00167     copy\_using\_evaluator(a, prod(a,a));
00168     VERIFY\_IS\_APPROX(a,c);
00169 
00170     \textcolor{comment}{// check compound assignment of products}
00171     d = c;
00172     add\_assign\_using\_evaluator(c.noalias(), prod(a,b));
00173     d.noalias() += a*b;
00174     VERIFY\_IS\_APPROX(c, d);
00175 
00176     d = c;
00177     subtract\_assign\_using\_evaluator(c.noalias(), prod(a,b));
00178     d.noalias() -= a*b;
00179     VERIFY\_IS\_APPROX(c, d);
00180   \}
00181 
00182   \{
00183     \textcolor{comment}{// test product with all possible sizes}
00184     \textcolor{keywordtype}{int} s = internal::random<int>(1,100);
00185     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,      1,      1>} m11, res11;  m11.
      \hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(1,1);
00186     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,      1,      4>} m14, res14;  m14.
      \hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(1,4);
00187     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,      1,Dynamic>} m1X, res1X;  m1X.
      \hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(1,s);
00188     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,      4,      1>} m41, res41;  m41.
      \hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(4,1);
00189     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,      4,      4>} m44, res44;  m44.
      \hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(4,4);
00190     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,      4,Dynamic>} m4X, res4X;  m4X.
      \hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(4,s);
00191     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,Dynamic,      1>} mX1, resX1;  mX1.
      \hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(s,1);
00192     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,Dynamic,      4>} mX4, resX4;  mX4.
      \hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(s,4);
00193     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,Dynamic,Dynamic>} mXX, resXX;  mXX.
      \hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(s,s);
00194 
00195     VERIFY\_IS\_APPROX\_EVALUATOR2(res11, prod(m11,m11), m11*m11);
00196     VERIFY\_IS\_APPROX\_EVALUATOR2(res11, prod(m14,m41), m14*m41);
00197     VERIFY\_IS\_APPROX\_EVALUATOR2(res11, prod(m1X,mX1), m1X*mX1);
00198     VERIFY\_IS\_APPROX\_EVALUATOR2(res14, prod(m11,m14), m11*m14);
00199     VERIFY\_IS\_APPROX\_EVALUATOR2(res14, prod(m14,m44), m14*m44);
00200     VERIFY\_IS\_APPROX\_EVALUATOR2(res14, prod(m1X,mX4), m1X*mX4);
00201     VERIFY\_IS\_APPROX\_EVALUATOR2(res1X, prod(m11,m1X), m11*m1X);
00202     VERIFY\_IS\_APPROX\_EVALUATOR2(res1X, prod(m14,m4X), m14*m4X);
00203     VERIFY\_IS\_APPROX\_EVALUATOR2(res1X, prod(m1X,mXX), m1X*mXX);
00204     VERIFY\_IS\_APPROX\_EVALUATOR2(res41, prod(m41,m11), m41*m11);
00205     VERIFY\_IS\_APPROX\_EVALUATOR2(res41, prod(m44,m41), m44*m41);
00206     VERIFY\_IS\_APPROX\_EVALUATOR2(res41, prod(m4X,mX1), m4X*mX1);
00207     VERIFY\_IS\_APPROX\_EVALUATOR2(res44, prod(m41,m14), m41*m14);
00208     VERIFY\_IS\_APPROX\_EVALUATOR2(res44, prod(m44,m44), m44*m44);
00209     VERIFY\_IS\_APPROX\_EVALUATOR2(res44, prod(m4X,mX4), m4X*mX4);
00210     VERIFY\_IS\_APPROX\_EVALUATOR2(res4X, prod(m41,m1X), m41*m1X);
00211     VERIFY\_IS\_APPROX\_EVALUATOR2(res4X, prod(m44,m4X), m44*m4X);
00212     VERIFY\_IS\_APPROX\_EVALUATOR2(res4X, prod(m4X,mXX), m4X*mXX);
00213     VERIFY\_IS\_APPROX\_EVALUATOR2(resX1, prod(mX1,m11), mX1*m11);
00214     VERIFY\_IS\_APPROX\_EVALUATOR2(resX1, prod(mX4,m41), mX4*m41);
00215     VERIFY\_IS\_APPROX\_EVALUATOR2(resX1, prod(mXX,mX1), mXX*mX1);
00216     VERIFY\_IS\_APPROX\_EVALUATOR2(resX4, prod(mX1,m14), mX1*m14);
00217     VERIFY\_IS\_APPROX\_EVALUATOR2(resX4, prod(mX4,m44), mX4*m44);
00218     VERIFY\_IS\_APPROX\_EVALUATOR2(resX4, prod(mXX,mX4), mXX*mX4);
00219     VERIFY\_IS\_APPROX\_EVALUATOR2(resXX, prod(mX1,m1X), mX1*m1X);
00220     VERIFY\_IS\_APPROX\_EVALUATOR2(resXX, prod(mX4,m4X), mX4*m4X);
00221     VERIFY\_IS\_APPROX\_EVALUATOR2(resXX, prod(mXX,mXX), mXX*mXX);
00222   \}
00223 
00224   \{
00225     ArrayXXf a(2,3);
00226     ArrayXXf b(3,2);
00227     a << 1,2,3, 4,5,6;
00228     \textcolor{keyword}{const} ArrayXXf a\_const(a);
00229     
00230     \textcolor{comment}{// this does not work because Random is eval-before-nested: }
00231     \textcolor{comment}{// copy\_using\_evaluator(w, Vector2d::Random().transpose());}
00232 
00233     \textcolor{comment}{// test CwiseUnaryOp}
00234     VERIFY\_IS\_APPROX\_EVALUATOR(v2, 3 * v);
00235     VERIFY\_IS\_APPROX\_EVALUATOR(w, (3 * v).transpose());
00236     VERIFY\_IS\_APPROX\_EVALUATOR(b, (a + 3).transpose());
00237     VERIFY\_IS\_APPROX\_EVALUATOR(b, (2 * a\_const + 3).transpose());
00238 
00239     \textcolor{comment}{// test CwiseBinaryOp}
00240     VERIFY\_IS\_APPROX\_EVALUATOR(v2, v + Vector2d::Ones());
00241     VERIFY\_IS\_APPROX\_EVALUATOR(w, (v + Vector2d::Ones()).transpose().cwiseProduct(RowVector2d::Constant(3))
      );
00242 
00243     \textcolor{comment}{// dynamic matrices and arrays}
00244     MatrixXd mat1(6,6), mat2(6,6);
00245     VERIFY\_IS\_APPROX\_EVALUATOR(mat1, MatrixXd::Identity(6,6));
00246     VERIFY\_IS\_APPROX\_EVALUATOR(mat2, mat1);
00247     copy\_using\_evaluator(mat2.transpose(), mat1);
00248     VERIFY\_IS\_APPROX(mat2.transpose(), mat1);
00249 
00250     ArrayXXd arr1(6,6), arr2(6,6);
00251     VERIFY\_IS\_APPROX\_EVALUATOR(arr1, ArrayXXd::Constant(6,6, 3.0));
00252     VERIFY\_IS\_APPROX\_EVALUATOR(arr2, arr1);
00253     
00254     \textcolor{comment}{// test automatic resizing}
00255     mat2.resize(3,3);
00256     VERIFY\_IS\_APPROX\_EVALUATOR(mat2, mat1);
00257     arr2.resize(9,9);
00258     VERIFY\_IS\_APPROX\_EVALUATOR(arr2, arr1);
00259 
00260     \textcolor{comment}{// test direct traversal}
00261     Matrix3f m3;
00262     Array33f a3;
00263     VERIFY\_IS\_APPROX\_EVALUATOR(m3, Matrix3f::Identity());  \textcolor{comment}{// matrix, nullary}
00264     \textcolor{comment}{// TODO: find a way to test direct traversal with array}
00265     VERIFY\_IS\_APPROX\_EVALUATOR(m3.transpose(), Matrix3f::Identity().transpose());  \textcolor{comment}{// transpose}
00266     VERIFY\_IS\_APPROX\_EVALUATOR(m3, 2 * Matrix3f::Identity());  \textcolor{comment}{// unary}
00267     VERIFY\_IS\_APPROX\_EVALUATOR(m3, Matrix3f::Identity() + Matrix3f::Zero());  \textcolor{comment}{// binary}
00268     VERIFY\_IS\_APPROX\_EVALUATOR(m3.block(0,0,2,2), Matrix3f::Identity().block(1,1,2,2));  \textcolor{comment}{// block}
00269 
00270     \textcolor{comment}{// test linear traversal}
00271     VERIFY\_IS\_APPROX\_EVALUATOR(m3, Matrix3f::Zero());  \textcolor{comment}{// matrix, nullary}
00272     VERIFY\_IS\_APPROX\_EVALUATOR(a3, Array33f::Zero());  \textcolor{comment}{// array}
00273     VERIFY\_IS\_APPROX\_EVALUATOR(m3.transpose(), Matrix3f::Zero().transpose());  \textcolor{comment}{// transpose}
00274     VERIFY\_IS\_APPROX\_EVALUATOR(m3, 2 * Matrix3f::Zero());  \textcolor{comment}{// unary}
00275     VERIFY\_IS\_APPROX\_EVALUATOR(m3, Matrix3f::Zero() + m3);  \textcolor{comment}{// binary  }
00276 
00277     \textcolor{comment}{// test inner vectorization}
00278     Matrix4f m4, m4src = Matrix4f::Random();
00279     Array44f a4, a4src = Matrix4f::Random();
00280     VERIFY\_IS\_APPROX\_EVALUATOR(m4, m4src);  \textcolor{comment}{// matrix}
00281     VERIFY\_IS\_APPROX\_EVALUATOR(a4, a4src);  \textcolor{comment}{// array}
00282     VERIFY\_IS\_APPROX\_EVALUATOR(m4.transpose(), m4src.transpose());  \textcolor{comment}{// transpose}
00283     \textcolor{comment}{// TODO: find out why Matrix4f::Zero() does not allow inner vectorization}
00284     VERIFY\_IS\_APPROX\_EVALUATOR(m4, 2 * m4src);  \textcolor{comment}{// unary}
00285     VERIFY\_IS\_APPROX\_EVALUATOR(m4, m4src + m4src);  \textcolor{comment}{// binary}
00286 
00287     \textcolor{comment}{// test linear vectorization}
00288     MatrixXf mX(6,6), mXsrc = MatrixXf::Random(6,6);
00289     ArrayXXf aX(6,6), aXsrc = ArrayXXf::Random(6,6);
00290     VERIFY\_IS\_APPROX\_EVALUATOR(mX, mXsrc);  \textcolor{comment}{// matrix}
00291     VERIFY\_IS\_APPROX\_EVALUATOR(aX, aXsrc);  \textcolor{comment}{// array}
00292     VERIFY\_IS\_APPROX\_EVALUATOR(mX.transpose(), mXsrc.transpose());  \textcolor{comment}{// transpose}
00293     VERIFY\_IS\_APPROX\_EVALUATOR(mX, MatrixXf::Zero(6,6));  \textcolor{comment}{// nullary}
00294     VERIFY\_IS\_APPROX\_EVALUATOR(mX, 2 * mXsrc);  \textcolor{comment}{// unary}
00295     VERIFY\_IS\_APPROX\_EVALUATOR(mX, mXsrc + mXsrc);  \textcolor{comment}{// binary}
00296 
00297     \textcolor{comment}{// test blocks and slice vectorization}
00298     VERIFY\_IS\_APPROX\_EVALUATOR(m4, (mXsrc.block<4,4>(1,0)));
00299     VERIFY\_IS\_APPROX\_EVALUATOR(aX, ArrayXXf::Constant(10, 10, 3.0).block(2, 3, 6, 6));
00300 
00301     Matrix4f m4ref = m4;
00302     copy\_using\_evaluator(m4.block(1, 1, 2, 3), m3.bottomRows(2));
00303     m4ref.block(1, 1, 2, 3) = m3.bottomRows(2);
00304     VERIFY\_IS\_APPROX(m4, m4ref);
00305 
00306     mX.setIdentity(20,20);
00307     MatrixXf mXref = MatrixXf::Identity(20,20);
00308     mXsrc = MatrixXf::Random(9,12);
00309     copy\_using\_evaluator(mX.block(4, 4, 9, 12), mXsrc);
00310     mXref.block(4, 4, 9, 12) = mXsrc;
00311     VERIFY\_IS\_APPROX(mX, mXref);
00312 
00313     \textcolor{comment}{// test Map}
00314     \textcolor{keyword}{const} \textcolor{keywordtype}{float} raw[3] = \{1,2,3\};
00315     \textcolor{keywordtype}{float} buffer[3] = \{0,0,0\};
00316     Vector3f v3;
00317     Array3f a3f;
00318     VERIFY\_IS\_APPROX\_EVALUATOR(v3, \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Vector3f>}(raw));
00319     VERIFY\_IS\_APPROX\_EVALUATOR(a3f, \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Array3f>}(raw));
00320     Vector3f::Map(buffer) = 2*v3;
00321     VERIFY(buffer[0] == 2);
00322     VERIFY(buffer[1] == 4);
00323     VERIFY(buffer[2] == 6);
00324 
00325     \textcolor{comment}{// test CwiseUnaryView}
00326     mat1.setRandom();
00327     mat2.setIdentity();
00328     MatrixXcd matXcd(6,6), matXcd\_ref(6,6);
00329     copy\_using\_evaluator(matXcd.real(), mat1);
00330     copy\_using\_evaluator(matXcd.imag(), mat2);
00331     matXcd\_ref.real() = mat1;
00332     matXcd\_ref.imag() = mat2;
00333     VERIFY\_IS\_APPROX(matXcd, matXcd\_ref);
00334 
00335     \textcolor{comment}{// test Select}
00336     VERIFY\_IS\_APPROX\_EVALUATOR(aX, (aXsrc > 0).select(aXsrc, -aXsrc));
00337 
00338     \textcolor{comment}{// test Replicate}
00339     mXsrc = MatrixXf::Random(6, 6);
00340     VectorXf vX = VectorXf::Random(6);
00341     mX.resize(6, 6);
00342     VERIFY\_IS\_APPROX\_EVALUATOR(mX, mXsrc.colwise() + vX);
00343     matXcd.resize(12, 12);
00344     VERIFY\_IS\_APPROX\_EVALUATOR(matXcd, matXcd\_ref.replicate(2,2));
00345     VERIFY\_IS\_APPROX\_EVALUATOR(matXcd, (matXcd\_ref.replicate<2,2>()));
00346 
00347     \textcolor{comment}{// test partial reductions}
00348     VectorXd vec1(6);
00349     VERIFY\_IS\_APPROX\_EVALUATOR(vec1, mat1.rowwise().sum());
00350     VERIFY\_IS\_APPROX\_EVALUATOR(vec1, mat1.colwise().sum().transpose());
00351 
00352     \textcolor{comment}{// test MatrixWrapper and ArrayWrapper}
00353     mat1.setRandom(6,6);
00354     arr1.setRandom(6,6);
00355     VERIFY\_IS\_APPROX\_EVALUATOR(mat2, arr1.matrix());
00356     VERIFY\_IS\_APPROX\_EVALUATOR(arr2, mat1.array());
00357     VERIFY\_IS\_APPROX\_EVALUATOR(mat2, (arr1 + 2).matrix());
00358     VERIFY\_IS\_APPROX\_EVALUATOR(arr2, mat1.array() + 2);
00359     mat2.array() = arr1 * arr1;
00360     VERIFY\_IS\_APPROX(mat2, (arr1 * arr1).matrix());
00361     arr2.matrix() = MatrixXd::Identity(6,6);
00362     VERIFY\_IS\_APPROX(arr2, MatrixXd::Identity(6,6).\hyperlink{class_eigen_1_1array}{array}());
00363 
00364     \textcolor{comment}{// test Reverse}
00365     VERIFY\_IS\_APPROX\_EVALUATOR(arr2, arr1.reverse());
00366     VERIFY\_IS\_APPROX\_EVALUATOR(arr2, arr1.colwise().reverse());
00367     VERIFY\_IS\_APPROX\_EVALUATOR(arr2, arr1.rowwise().reverse());
00368     arr2.reverse() = arr1;
00369     VERIFY\_IS\_APPROX(arr2, arr1.reverse());
00370     mat2.array() = mat1.array().reverse();
00371     VERIFY\_IS\_APPROX(mat2.array(), mat1.array().reverse());
00372 
00373     \textcolor{comment}{// test Diagonal}
00374     VERIFY\_IS\_APPROX\_EVALUATOR(vec1, mat1.diagonal());
00375     vec1.resize(5);
00376     VERIFY\_IS\_APPROX\_EVALUATOR(vec1, mat1.diagonal(1));
00377     VERIFY\_IS\_APPROX\_EVALUATOR(vec1, mat1.diagonal<-1>());
00378     vec1.setRandom();
00379 
00380     mat2 = mat1;
00381     copy\_using\_evaluator(mat1.diagonal(1), vec1);
00382     mat2.diagonal(1) = vec1;
00383     VERIFY\_IS\_APPROX(mat1, mat2);
00384 
00385     copy\_using\_evaluator(mat1.diagonal<-1>(), mat1.diagonal(1));
00386     mat2.diagonal<-1>() = mat2.diagonal(1);
00387     VERIFY\_IS\_APPROX(mat1, mat2);
00388   \}
00389   
00390   \{
00391     \textcolor{comment}{// test swapping}
00392     MatrixXd mat1, mat2, mat1ref, mat2ref;
00393     mat1ref = mat1 = MatrixXd::Random(6, 6);
00394     mat2ref = mat2 = 2 * mat1 + MatrixXd::Identity(6, 6);
00395     swap\_using\_evaluator(mat1, mat2);
00396     mat1ref.swap(mat2ref);
00397     VERIFY\_IS\_APPROX(mat1, mat1ref);
00398     VERIFY\_IS\_APPROX(mat2, mat2ref);
00399 
00400     swap\_using\_evaluator(mat1.block(0, 0, 3, 3), mat2.block(3, 3, 3, 3));
00401     mat1ref.block(0, 0, 3, 3).swap(mat2ref.block(3, 3, 3, 3));
00402     VERIFY\_IS\_APPROX(mat1, mat1ref);
00403     VERIFY\_IS\_APPROX(mat2, mat2ref);
00404 
00405     swap\_using\_evaluator(mat1.row(2), mat2.col(3).transpose());
00406     mat1.row(2).swap(mat2.col(3).transpose());
00407     VERIFY\_IS\_APPROX(mat1, mat1ref);
00408     VERIFY\_IS\_APPROX(mat2, mat2ref);
00409   \}
00410 
00411   \{
00412     \textcolor{comment}{// test compound assignment}
00413     \textcolor{keyword}{const} Matrix4d mat\_const = Matrix4d::Random(); 
00414     Matrix4d mat, mat\_ref;
00415     mat = mat\_ref = Matrix4d::Identity();
00416     add\_assign\_using\_evaluator(mat, mat\_const);
00417     mat\_ref += mat\_const;
00418     VERIFY\_IS\_APPROX(mat, mat\_ref);
00419 
00420     subtract\_assign\_using\_evaluator(mat.row(1), 2*mat.row(2));
00421     mat\_ref.row(1) -= 2*mat\_ref.row(2);
00422     VERIFY\_IS\_APPROX(mat, mat\_ref);
00423 
00424     \textcolor{keyword}{const} ArrayXXf arr\_const = ArrayXXf::Random(5,3); 
00425     ArrayXXf arr, arr\_ref;
00426     arr = arr\_ref = ArrayXXf::Constant(5, 3, 0.5);
00427     multiply\_assign\_using\_evaluator(arr, arr\_const);
00428     arr\_ref *= arr\_const;
00429     VERIFY\_IS\_APPROX(arr, arr\_ref);
00430 
00431     divide\_assign\_using\_evaluator(arr.row(1), arr.row(2) + 1);
00432     arr\_ref.row(1) /= (arr\_ref.row(2) + 1);
00433     VERIFY\_IS\_APPROX(arr, arr\_ref);
00434   \}
00435   
00436   \{
00437     \textcolor{comment}{// test triangular shapes}
00438     MatrixXd \hyperlink{group___core___module_class_eigen_1_1_matrix}{A} = MatrixXd::Random(6,6), \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}(6,6), \hyperlink{group___core___module}{C}(6,6), D(6,6);
00439     A.setRandom();\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00440     VERIFY\_IS\_APPROX\_EVALUATOR2(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, A.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>(), MatrixXd(A.triangularView<
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>()));
00441     
00442     A.setRandom();\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00443     VERIFY\_IS\_APPROX\_EVALUATOR2(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, A.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda8155cfdfde9e75e7144dff0393d17181}{UnitLower}>(), MatrixXd(A.triangularView<
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda8155cfdfde9e75e7144dff0393d17181}{UnitLower}>()));
00444     
00445     A.setRandom();\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00446     VERIFY\_IS\_APPROX\_EVALUATOR2(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, A.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda8b0b63ff46dcd7377b59df14e0562fc1}{UnitUpper}>(), MatrixXd(A.triangularView<
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda8b0b63ff46dcd7377b59df14e0562fc1}{UnitUpper}>()));
00447     
00448     A.setRandom();\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00449     \hyperlink{group___core___module}{C} = \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}; \hyperlink{group___core___module}{C}.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>() = A;
00450     copy\_using\_evaluator(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>(), A);
00451     VERIFY(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.isApprox(\hyperlink{group___core___module}{C}) && \textcolor{stringliteral}{"copy\_using\_evaluator(B.triangularView<Upper>(), A)"});
00452     
00453     A.setRandom();\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00454     \hyperlink{group___core___module}{C} = \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}; \hyperlink{group___core___module}{C}.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}>() = A.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}>();
00455     copy\_using\_evaluator(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}>(), A.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}>());
00456     VERIFY(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.isApprox(\hyperlink{group___core___module}{C}) && \textcolor{stringliteral}{"copy\_using\_evaluator(B.triangularView<Lower>(), A.triangularView<Lower>())"})
      ;
00457     
00458     
00459     A.setRandom();\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00460     \hyperlink{group___core___module}{C} = \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}; \hyperlink{group___core___module}{C}.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}>() = A.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>().transpose();
00461     copy\_using\_evaluator(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}>(), A.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>().transpose());
00462     VERIFY(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.isApprox(\hyperlink{group___core___module}{C}) && \textcolor{stringliteral}{"copy\_using\_evaluator(B.triangularView<Lower>(),
       A.triangularView<Lower>().transpose())"});
00463     
00464     
00465     A.setRandom();\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(); \hyperlink{group___core___module}{C} = \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}; D = A;
00466     \hyperlink{group___core___module}{C}.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>().\hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(D.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>());
00467     swap\_using\_evaluator(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>(), A.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>());
00468     VERIFY(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.isApprox(\hyperlink{group___core___module}{C}) && \textcolor{stringliteral}{"swap\_using\_evaluator(B.triangularView<Upper>(), A.triangularView<Upper>())"})
      ;
00469     
00470     
00471     VERIFY\_IS\_APPROX\_EVALUATOR2(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, prod(A.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>(),A), MatrixXd(A.triangularView<
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>()*A));
00472     
00473     VERIFY\_IS\_APPROX\_EVALUATOR2(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, prod(A.selfadjointView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>(),A), MatrixXd(A.selfadjointView<
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>()*A));
00474   \}
00475 
00476   \{
00477     \textcolor{comment}{// test diagonal shapes}
00478     VectorXd d = VectorXd::Random(6);
00479     MatrixXd A = MatrixXd::Random(6,6), \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}(6,6);
00480     A.setRandom();\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00481     
00482     VERIFY\_IS\_APPROX\_EVALUATOR2(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, lazyprod(d.asDiagonal(),A), MatrixXd(d.asDiagonal()*A));
00483     VERIFY\_IS\_APPROX\_EVALUATOR2(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, lazyprod(A,d.asDiagonal()), MatrixXd(A*d.asDiagonal()));
00484   \}
00485 
00486   \{
00487     \textcolor{comment}{// test CoeffReadCost}
00488     Matrix4d a, b;
00489     VERIFY\_IS\_EQUAL( get\_cost(a), 1 );
00490     VERIFY\_IS\_EQUAL( get\_cost(a+b), 3);
00491     VERIFY\_IS\_EQUAL( get\_cost(2*a+b), 4);
00492     VERIFY\_IS\_EQUAL( get\_cost(a*b), 1);
00493     VERIFY\_IS\_EQUAL( get\_cost(a.lazyProduct(b)), 15);
00494     VERIFY\_IS\_EQUAL( get\_cost(a*(a*b)), 1);
00495     VERIFY\_IS\_EQUAL( get\_cost(a.lazyProduct(a*b)), 15);
00496     VERIFY\_IS\_EQUAL( get\_cost(a*(a+b)), 1);
00497     VERIFY\_IS\_EQUAL( get\_cost(a.lazyProduct(a+b)), 15);
00498   \}
00499 \}
\end{DoxyCode}
