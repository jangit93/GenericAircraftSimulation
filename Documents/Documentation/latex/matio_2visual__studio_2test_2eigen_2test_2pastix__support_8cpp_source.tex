\hypertarget{matio_2visual__studio_2test_2eigen_2test_2pastix__support_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/pastix\+\_\+support.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2pastix__support_8cpp_source}\index{pastix\+\_\+support.\+cpp@{pastix\+\_\+support.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2012 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#define EIGEN\_NO\_DEBUG\_SMALL\_PRODUCT\_BLOCKS}
00012 \textcolor{preprocessor}{#include "sparse\_solver.h"}
00013 \textcolor{preprocessor}{#include <Eigen/PaStiXSupport>}
00014 \textcolor{preprocessor}{#include <unsupported/Eigen/SparseExtra>}
00015 
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keywordtype}{void} test\_pastix\_T()
00018 \{
00019   \hyperlink{class_eigen_1_1_pastix_l_l_t}{PastixLLT< SparseMatrix<T, ColMajor>}, 
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Eigen::Lower} > pastix\_llt\_lower;
00020   \hyperlink{class_eigen_1_1_pastix_l_d_l_t}{PastixLDLT< SparseMatrix<T, ColMajor>}, 
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Eigen::Lower} > pastix\_ldlt\_lower;
00021   \hyperlink{class_eigen_1_1_pastix_l_l_t}{PastixLLT< SparseMatrix<T, ColMajor>}, 
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Eigen::Upper} > pastix\_llt\_upper;
00022   \hyperlink{class_eigen_1_1_pastix_l_d_l_t}{PastixLDLT< SparseMatrix<T, ColMajor>}, 
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Eigen::Upper} > pastix\_ldlt\_upper;
00023   \hyperlink{class_eigen_1_1_pastix_l_u}{PastixLU< SparseMatrix<T, ColMajor>} > pastix\_lu;
00024 
00025   check\_sparse\_spd\_solving(pastix\_llt\_lower);
00026   check\_sparse\_spd\_solving(pastix\_ldlt\_lower);
00027   check\_sparse\_spd\_solving(pastix\_llt\_upper);
00028   check\_sparse\_spd\_solving(pastix\_ldlt\_upper);
00029   check\_sparse\_square\_solving(pastix\_lu);
00030 
00031   \textcolor{comment}{// Some compilation check:}
00032   pastix\_llt\_lower.\hyperlink{class_eigen_1_1_pastix_base_a38378e7b2b5c750a8a23e2c21a69146c}{iparm}();
00033   pastix\_llt\_lower.\hyperlink{class_eigen_1_1_pastix_base_af4a29373aa3e6a980738efde33f92a76}{dparm}();
00034   pastix\_ldlt\_lower.\hyperlink{class_eigen_1_1_pastix_base_a38378e7b2b5c750a8a23e2c21a69146c}{iparm}();
00035   pastix\_ldlt\_lower.\hyperlink{class_eigen_1_1_pastix_base_af4a29373aa3e6a980738efde33f92a76}{dparm}();
00036   pastix\_lu.\hyperlink{class_eigen_1_1_pastix_base_a38378e7b2b5c750a8a23e2c21a69146c}{iparm}();
00037   pastix\_lu.\hyperlink{class_eigen_1_1_pastix_base_af4a29373aa3e6a980738efde33f92a76}{dparm}();
00038 \}
00039 
00040 \textcolor{comment}{// There is no support for selfadjoint matrices with PaStiX. }
00041 \textcolor{comment}{// Complex symmetric matrices should pass though}
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keywordtype}{void} test\_pastix\_T\_LU()
00043 \{
00044   \hyperlink{class_eigen_1_1_pastix_l_u}{PastixLU< SparseMatrix<T, ColMajor>} > pastix\_lu;
00045   check\_sparse\_square\_solving(pastix\_lu);
00046 \}
00047 
00048 \textcolor{keywordtype}{void} test\_pastix\_support()
00049 \{
00050   CALL\_SUBTEST\_1(test\_pastix\_T<float>());
00051   CALL\_SUBTEST\_2(test\_pastix\_T<double>());
00052   CALL\_SUBTEST\_3( (test\_pastix\_T\_LU<std::complex<float> >()) );
00053   CALL\_SUBTEST\_4(test\_pastix\_T\_LU<std::complex<double> >());
00054 \} 
\end{DoxyCode}
