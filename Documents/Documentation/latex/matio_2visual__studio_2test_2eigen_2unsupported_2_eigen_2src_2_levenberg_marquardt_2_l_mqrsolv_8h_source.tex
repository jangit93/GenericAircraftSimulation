\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_levenberg_marquardt_2_l_mqrsolv_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+Levenberg\+Marquardt/\+L\+Mqrsolv.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_levenberg_marquardt_2_l_mqrsolv_8h_source}\index{L\+Mqrsolv.\+h@{L\+Mqrsolv.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Thomas Capricelli <orzel@freehackers.org>}
00005 \textcolor{comment}{// Copyright (C) 2012 Desire Nuentsa <desire.nuentsa\_wakam@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This code initially comes from MINPACK whose original authors are:}
00008 \textcolor{comment}{// Copyright Jorge More - Argonne National Laboratory}
00009 \textcolor{comment}{// Copyright Burt Garbow - Argonne National Laboratory}
00010 \textcolor{comment}{// Copyright Ken Hillstrom - Argonne National Laboratory}
00011 \textcolor{comment}{//}
00012 \textcolor{comment}{// This Source Code Form is subject to the terms of the Minpack license}
00013 \textcolor{comment}{// (a BSD-like license) described in the campaigned CopyrightMINPACK.txt file.}
00014 
00015 \textcolor{preprocessor}{#ifndef EIGEN\_LMQRSOLV\_H}
00016 \textcolor{preprocessor}{#define EIGEN\_LMQRSOLV\_H}
00017 
00018 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00019 
00020 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00021 
00022 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar,\textcolor{keywordtype}{int} Rows, \textcolor{keywordtype}{int} Cols, \textcolor{keyword}{typename} PermIndex>
00023 \textcolor{keywordtype}{void} lmqrsolv(
00024   Matrix<Scalar,Rows,Cols> &s,
00025   \textcolor{keyword}{const} PermutationMatrix<Dynamic,Dynamic,PermIndex> &iPerm,
00026   \textcolor{keyword}{const} Matrix<Scalar,Dynamic,1> &diag,
00027   \textcolor{keyword}{const} Matrix<Scalar,Dynamic,1> &qtb,
00028   Matrix<Scalar,Dynamic,1> &x,
00029   Matrix<Scalar,Dynamic,1> &sdiag)
00030 \{
00031     \textcolor{comment}{/* Local variables */}
00032     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, j, k;
00033     Scalar temp;
00034     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = s.cols();
00035     Matrix<Scalar,Dynamic,1>  wa(n);
00036     JacobiRotation<Scalar> givens;
00037 
00038     \textcolor{comment}{/* Function Body */}
00039     \textcolor{comment}{// the following will only change the lower triangular part of s, including}
00040     \textcolor{comment}{// the diagonal, though the diagonal is restored afterward}
00041 
00042     \textcolor{comment}{/*     copy r and (q transpose)*b to preserve input and initialize s. */}
00043     \textcolor{comment}{/*     in particular, save the diagonal elements of r in x. */}
00044     x = s.diagonal();
00045     wa = qtb;
00046     
00047    
00048     s.topLeftCorner(n,n).template triangularView<StrictlyLower>() = s.topLeftCorner(n,n).transpose();
00049     \textcolor{comment}{/*     eliminate the diagonal matrix d using a givens rotation. */}
00050     \textcolor{keywordflow}{for} (j = 0; j < n; ++j) \{
00051 
00052         \textcolor{comment}{/*        prepare the row of d to be eliminated, locating the */}
00053         \textcolor{comment}{/*        diagonal element using p from the qr factorization. */}
00054         \textcolor{keyword}{const} PermIndex l = iPerm.indices()(j);
00055         \textcolor{keywordflow}{if} (diag[l] == 0.)
00056             \textcolor{keywordflow}{break};
00057         sdiag.tail(n-j).setZero();
00058         sdiag[j] = diag[l];
00059 
00060         \textcolor{comment}{/*        the transformations to eliminate the row of d */}
00061         \textcolor{comment}{/*        modify only a single element of (q transpose)*b */}
00062         \textcolor{comment}{/*        beyond the first n, which is initially zero. */}
00063         Scalar qtbpj = 0.;
00064         \textcolor{keywordflow}{for} (k = j; k < n; ++k) \{
00065             \textcolor{comment}{/*           determine a givens rotation which eliminates the */}
00066             \textcolor{comment}{/*           appropriate element in the current row of d. */}
00067             givens.makeGivens(-s(k,k), sdiag[k]);
00068 
00069             \textcolor{comment}{/*           compute the modified diagonal element of r and */}
00070             \textcolor{comment}{/*           the modified element of ((q transpose)*b,0). */}
00071             s(k,k) = givens.c() * s(k,k) + givens.s() * sdiag[k];
00072             temp = givens.c() * wa[k] + givens.s() * qtbpj;
00073             qtbpj = -givens.s() * wa[k] + givens.c() * qtbpj;
00074             wa[k] = temp;
00075 
00076             \textcolor{comment}{/*           accumulate the tranformation in the row of s. */}
00077             \textcolor{keywordflow}{for} (i = k+1; i<n; ++i) \{
00078                 temp = givens.c() * s(i,k) + givens.s() * sdiag[i];
00079                 sdiag[i] = -givens.s() * s(i,k) + givens.c() * sdiag[i];
00080                 s(i,k) = temp;
00081             \}
00082         \}
00083     \}
00084   
00085     \textcolor{comment}{/*     solve the triangular system for z. if the system is */}
00086     \textcolor{comment}{/*     singular, then obtain a least squares solution. */}
00087     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nsing;
00088     \textcolor{keywordflow}{for}(nsing=0; nsing<n && sdiag[nsing]!=0; nsing++) \{\}
00089 
00090     wa.tail(n-nsing).setZero();
00091     s.topLeftCorner(nsing, nsing).transpose().template triangularView<Upper>().solveInPlace(wa.head(nsing))
      ;
00092   
00093     \textcolor{comment}{// restore}
00094     sdiag = s.diagonal();
00095     s.diagonal() = x;
00096 
00097     \textcolor{comment}{/* permute the components of z back to components of x. */}
00098     x = iPerm * wa; 
00099 \}
00100 
00101 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} Index>
00102 \textcolor{keywordtype}{void} lmqrsolv(
00103   SparseMatrix<Scalar,\_Options,Index> &s,
00104   \textcolor{keyword}{const} PermutationMatrix<Dynamic,Dynamic> &iPerm,
00105   \textcolor{keyword}{const} Matrix<Scalar,Dynamic,1> &diag,
00106   \textcolor{keyword}{const} Matrix<Scalar,Dynamic,1> &qtb,
00107   Matrix<Scalar,Dynamic,1> &x,
00108   Matrix<Scalar,Dynamic,1> &sdiag)
00109 \{
00110   \textcolor{comment}{/* Local variables */}
00111   \textcolor{keyword}{typedef} SparseMatrix<Scalar,RowMajor,Index> FactorType;
00112     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, j, k, l;
00113     Scalar temp;
00114     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = s.cols();
00115     Matrix<Scalar,Dynamic,1>  wa(n);
00116     JacobiRotation<Scalar> givens;
00117 
00118     \textcolor{comment}{/* Function Body */}
00119     \textcolor{comment}{// the following will only change the lower triangular part of s, including}
00120     \textcolor{comment}{// the diagonal, though the diagonal is restored afterward}
00121 
00122     \textcolor{comment}{/*     copy r and (q transpose)*b to preserve input and initialize R. */}
00123     wa = qtb;
00124     FactorType R(s);
00125     \textcolor{comment}{// Eliminate the diagonal matrix d using a givens rotation}
00126     \textcolor{keywordflow}{for} (j = 0; j < n; ++j)
00127     \{
00128       \textcolor{comment}{// Prepare the row of d to be eliminated, locating the }
00129       \textcolor{comment}{// diagonal element using p from the qr factorization}
00130       l = iPerm.indices()(j);
00131       \textcolor{keywordflow}{if} (diag(l) == Scalar(0)) 
00132         \textcolor{keywordflow}{break}; 
00133       sdiag.tail(n-j).setZero();
00134       sdiag[j] = diag[l];
00135       \textcolor{comment}{// the transformations to eliminate the row of d}
00136       \textcolor{comment}{// modify only a single element of (q transpose)*b}
00137       \textcolor{comment}{// beyond the first n, which is initially zero. }
00138       
00139       Scalar qtbpj = 0; 
00140       \textcolor{comment}{// Browse the nonzero elements of row j of the upper triangular s}
00141       \textcolor{keywordflow}{for} (k = j; k < n; ++k)
00142       \{
00143         \textcolor{keyword}{typename} FactorType::InnerIterator itk(R,k);
00144         \textcolor{keywordflow}{for} (; itk; ++itk)\{
00145           \textcolor{keywordflow}{if} (itk.index() < k) \textcolor{keywordflow}{continue};
00146           \textcolor{keywordflow}{else} \textcolor{keywordflow}{break};
00147         \}
00148         \textcolor{comment}{//At this point, we have the diagonal element R(k,k)}
00149         \textcolor{comment}{// Determine a givens rotation which eliminates }
00150         \textcolor{comment}{// the appropriate element in the current row of d}
00151         givens.makeGivens(-itk.value(), sdiag(k));
00152         
00153         \textcolor{comment}{// Compute the modified diagonal element of r and }
00154         \textcolor{comment}{// the modified element of ((q transpose)*b,0).}
00155         itk.valueRef() = givens.c() * itk.value() + givens.s() * sdiag(k);
00156         temp = givens.c() * wa(k) + givens.s() * qtbpj; 
00157         qtbpj = -givens.s() * wa(k) + givens.c() * qtbpj;
00158         wa(k) = temp;
00159         
00160         \textcolor{comment}{// Accumulate the transformation in the remaining k row/column of R}
00161         \textcolor{keywordflow}{for} (++itk; itk; ++itk)
00162         \{
00163           i = itk.index();
00164           temp = givens.c() *  itk.value() + givens.s() * sdiag(i);
00165           sdiag(i) = -givens.s() * itk.value() + givens.c() * sdiag(i);
00166           itk.valueRef() = temp;
00167         \}
00168       \}
00169     \}
00170     
00171     \textcolor{comment}{// Solve the triangular system for z. If the system is }
00172     \textcolor{comment}{// singular, then obtain a least squares solution}
00173     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nsing;
00174     \textcolor{keywordflow}{for}(nsing = 0; nsing<n && sdiag(nsing) !=0; nsing++) \{\}
00175     
00176     wa.tail(n-nsing).setZero();
00177 \textcolor{comment}{//     x = wa; }
00178     wa.head(nsing) = R.topLeftCorner(nsing,nsing).template triangularView<Upper>().solve\textcolor{comment}{/*InPlace*/}(wa.head
      (nsing));
00179     
00180     sdiag = R.diagonal();
00181     \textcolor{comment}{// Permute the components of z back to components of x}
00182     x = iPerm * wa; 
00183 \}
00184 \} \textcolor{comment}{// end namespace internal}
00185 
00186 \} \textcolor{comment}{// end namespace Eigen}
00187 
00188 \textcolor{preprocessor}{#endif // EIGEN\_LMQRSOLV\_H}
\end{DoxyCode}
