\hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source}{}\section{eigen/\+Eigen/src/\+Core/functors/\+Binary\+Functors.h}
\label{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source}\index{Binary\+Functors.\+h@{Binary\+Functors.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_BINARY\_FUNCTORS\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_BINARY\_FUNCTORS\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{comment}{//---------- associative binary functors ----------}
00018 
00019 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Arg1, \textcolor{keyword}{typename} Arg2>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00020}\hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{00020} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}
00021 \{
00022   \textcolor{keyword}{typedef} Arg1 first\_argument\_type;
00023   \textcolor{keyword}{typedef} Arg2 second\_argument\_type;
00024 \};
00025 
00031 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00032}\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{00032} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{scalar\_sum\_op} : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,RhsScalar>
00033 \{
00034   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_sum\_op>::ReturnType}
       result\_type;
00035 \textcolor{preprocessor}{#ifndef EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN}
00036   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{scalar\_sum\_op})
00037 \textcolor{preprocessor}{#else}
00038   \hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{scalar\_sum\_op}() \{
00039     EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN
00040   \}
00041 \textcolor{preprocessor}{#endif}
00042   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a + b; \}
00043   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00044   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} packetOp(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& a, \textcolor{keyword}{const} 
      \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& b)\textcolor{keyword}{ const}
00045 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::padd(a,b); \}
00046   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00047   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type predux(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& a)\textcolor{keyword}{ const}
00048 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::predux(a); \}
00049 \};
00050 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00051}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__sum__op_3_01_lhs_scalar_00_01_rhs_scalar_01_4_01_4}{00051} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{scalar\_sum\_op}<LhsScalar,RhsScalar> > \{
00052   \textcolor{keyword}{enum} \{
00053     Cost = (\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<LhsScalar>::AddCost}+
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RhsScalar>::AddCost})/2, \textcolor{comment}{// rough estimate!}
00054     PacketAccess = \hyperlink{struct_eigen_1_1internal_1_1is__same}{is\_same<LhsScalar,RhsScalar>::value} && 
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::HasAdd} && 
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<RhsScalar>::HasAdd}
00055     \textcolor{comment}{// TODO vectorize mixed sum}
00056   \};
00057 \};
00058 
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00064}\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op_3_01bool_00_01bool_01_4}{00064} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{scalar\_sum\_op}<bool,bool> : \hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{scalar\_sum\_op}<int,int> \{
00065   EIGEN\_DEPRECATED
00066   \hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{scalar\_sum\_op}() \{\}
00067 \};
00068 
00069 
00075 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00076}\hyperlink{struct_eigen_1_1internal_1_1scalar__product__op}{00076} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__product__op}{scalar\_product\_op}  : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,RhsScalar>
00077 \{
00078   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_product\_op>::ReturnType}
       result\_type;
00079 \textcolor{preprocessor}{#ifndef EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN}
00080   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__product__op}{scalar\_product\_op})
00081 \textcolor{preprocessor}{#else}
00082   \hyperlink{struct_eigen_1_1internal_1_1scalar__product__op}{scalar\_product\_op}() \{
00083     EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN
00084   \}
00085 \textcolor{preprocessor}{#endif}
00086   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a * b; \}
00087   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00088   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} packetOp(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& a, \textcolor{keyword}{const} 
      \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& b)\textcolor{keyword}{ const}
00089 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pmul(a,b); \}
00090   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00091   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type predux(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& a)\textcolor{keyword}{ const}
00092 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::predux\_mul(a); \}
00093 \};
00094 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00095}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__product__op_3_01_lhs_scalar_00_01_rhs_scalar_01_4_01_4}{00095} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__product__op}{scalar\_product\_op}<LhsScalar,RhsScalar> > \{
00096   \textcolor{keyword}{enum} \{
00097     Cost = (\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<LhsScalar>::MulCost} + 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RhsScalar>::MulCost})/2, \textcolor{comment}{// rough estimate!}
00098     PacketAccess = \hyperlink{struct_eigen_1_1internal_1_1is__same}{is\_same<LhsScalar,RhsScalar>::value} && 
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::HasMul} && 
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<RhsScalar>::HasMul}
00099     \textcolor{comment}{// TODO vectorize mixed product}
00100   \};
00101 \};
00102 
00108 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00109}\hyperlink{struct_eigen_1_1internal_1_1scalar__conj__product__op}{00109} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__conj__product__op}{scalar\_conj\_product\_op}  : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,RhsScalar>
00110 \{
00111 
00112   \textcolor{keyword}{enum} \{
00113     Conj = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<LhsScalar>::IsComplex}
00114   \};
00115   
00116   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_conj\_product\_op>::ReturnType}
       result\_type;
00117   
00118   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__conj__product__op}{scalar\_conj\_product\_op})
00119   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const}
00120 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper<LhsScalar,RhsScalar,Conj,false>}().pmul(a,
      b); \}
00121   
00122   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00123   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} packetOp(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& a, \textcolor{keyword}{const} 
      \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& b)\textcolor{keyword}{ const}
00124 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper<Packet,Packet,Conj,false>}().pmul(a,b); \}
00125 \};
00126 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00127}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__conj__product__op_3_01_lhs_scalar_00_01_rhs_scalar_01_4_01_4}{00127} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__conj__product__op}{scalar\_conj\_product\_op}<LhsScalar,RhsScalar> > \{
00128   \textcolor{keyword}{enum} \{
00129     Cost = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<LhsScalar>::MulCost},
00130     PacketAccess = \hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<LhsScalar, RhsScalar>::value}
       && \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::HasMul}
00131   \};
00132 \};
00133 
00139 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00140}\hyperlink{struct_eigen_1_1internal_1_1scalar__min__op}{00140} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__min__op}{scalar\_min\_op} : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,RhsScalar>
00141 \{
00142   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_min\_op>::ReturnType}
       result\_type;
00143   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__min__op}{scalar\_min\_op})
00144   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::mini(a, b); \}
00145   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00146   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} packetOp(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& a, \textcolor{keyword}{const} 
      \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& b)\textcolor{keyword}{ const}
00147 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pmin(a,b); \}
00148   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00149   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type predux(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& a)\textcolor{keyword}{ const}
00150 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::predux\_min(a); \}
00151 \};
00152 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00153}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__min__op_3_01_lhs_scalar_00_01_rhs_scalar_01_4_01_4}{00153} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__min__op}{scalar\_min\_op}<LhsScalar,RhsScalar> > \{
00154   \textcolor{keyword}{enum} \{
00155     Cost = (\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<LhsScalar>::AddCost}+
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RhsScalar>::AddCost})/2,
00156     PacketAccess = \hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<LhsScalar, RhsScalar>::value}
       && \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::HasMin}
00157   \};
00158 \};
00159 
00165 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00166}\hyperlink{struct_eigen_1_1internal_1_1scalar__max__op}{00166} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__max__op}{scalar\_max\_op}  : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,RhsScalar>
00167 \{
00168   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_max\_op>::ReturnType}
       result\_type;
00169   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__max__op}{scalar\_max\_op})
00170   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::maxi(a, b); \}
00171   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00172   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} packetOp(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& a, \textcolor{keyword}{const} 
      \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& b)\textcolor{keyword}{ const}
00173 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pmax(a,b); \}
00174   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00175   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type predux(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& a)\textcolor{keyword}{ const}
00176 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::predux\_max(a); \}
00177 \};
00178 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00179}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__max__op_3_01_lhs_scalar_00_01_rhs_scalar_01_4_01_4}{00179} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__max__op}{scalar\_max\_op}<LhsScalar,RhsScalar> > \{
00180   \textcolor{keyword}{enum} \{
00181     Cost = (\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<LhsScalar>::AddCost}+
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RhsScalar>::AddCost})/2,
00182     PacketAccess = \hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<LhsScalar, RhsScalar>::value}
       && \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::HasMax}
00183   \};
00184 \};
00185 
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00190}\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{00190} \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, ComparisonName cmp> \textcolor{keyword}{struct }
      \hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op};
00191 
00192 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, ComparisonName cmp>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00193}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__cmp__op_3_01_lhs_scalar_00_01_rhs_scalar_00_01cmp_01_4_01_4}{00193} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op}<LhsScalar,RhsScalar, cmp> > \{
00194   \textcolor{keyword}{enum} \{
00195     Cost = (\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<LhsScalar>::AddCost}+
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RhsScalar>::AddCost})/2,
00196     PacketAccess = \textcolor{keyword}{false}
00197   \};
00198 \};
00199 
00200 \textcolor{keyword}{template}<ComparisonName Cmp, \textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00201}\hyperlink{struct_eigen_1_1internal_1_1result__of_3_01scalar__cmp__op_3_01_lhs_scalar_00_01_rhs_scalar_00_09c9877449c1099527f34eb0a0f299607}{00201} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1result__of}{result\_of}<\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op}<LhsScalar, RhsScalar, Cmp>(LhsScalar,RhsScalar)> \{
00202   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} type;
00203 \};
00204 
00205 
00206 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00207}\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op_3_01_lhs_scalar_00_01_rhs_scalar_00_01cmp___e_q_01_4}{00207} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op}<LhsScalar,RhsScalar, cmp\_EQ> : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,Rhs
      Scalar>
00208 \{
00209   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00210   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op})
00211   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} a==b;\}
00212 \};
00213 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00214}\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op_3_01_lhs_scalar_00_01_rhs_scalar_00_01cmp___l_t_01_4}{00214} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op}<LhsScalar,RhsScalar, cmp\_LT> : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,Rhs
      Scalar>
00215 \{
00216   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00217   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op})
00218   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} a<b;\}
00219 \};
00220 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00221}\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op_3_01_lhs_scalar_00_01_rhs_scalar_00_01cmp___l_e_01_4}{00221} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op}<LhsScalar,RhsScalar, cmp\_LE> : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,Rhs
      Scalar>
00222 \{
00223   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00224   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op})
00225   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} a<=b;\}
00226 \};
00227 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00228}\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op_3_01_lhs_scalar_00_01_rhs_scalar_00_01cmp___g_t_01_4}{00228} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op}<LhsScalar,RhsScalar, cmp\_GT> : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,Rhs
      Scalar>
00229 \{
00230   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00231   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op})
00232   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} a>b;\}
00233 \};
00234 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00235}\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op_3_01_lhs_scalar_00_01_rhs_scalar_00_01cmp___g_e_01_4}{00235} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op}<LhsScalar,RhsScalar, cmp\_GE> : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,Rhs
      Scalar>
00236 \{
00237   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00238   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op})
00239   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} a>=b;\}
00240 \};
00241 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00242}\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op_3_01_lhs_scalar_00_01_rhs_scalar_00_01cmp___u_n_o_r_d_01_4}{00242} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op}<LhsScalar,RhsScalar, cmp\_UNORD> : 
      \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,RhsScalar>
00243 \{
00244   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00245   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op})
00246   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} !(a<=b || b<=a);\}
00247 \};
00248 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00249}\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op_3_01_lhs_scalar_00_01_rhs_scalar_00_01cmp___n_e_q_01_4}{00249} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op}<LhsScalar,RhsScalar, cmp\_NEQ> : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,Rh
      sScalar>
00250 \{
00251   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00252   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__cmp__op}{scalar\_cmp\_op})
00253   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{
      return} a!=b;\}
00254 \};
00255 
00256 
00262 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00263}\hyperlink{struct_eigen_1_1internal_1_1scalar__hypot__op_3_01_scalar_00_01_scalar_01_4}{00263} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__hypot__op}{scalar\_hypot\_op}<Scalar,Scalar> : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<Scalar,Scalar>
00264 \{
00265   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__hypot__op}{scalar\_hypot\_op})
00266 \textcolor{comment}{//   typedef typename NumTraits<Scalar>::Real result\_type;}
00267   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& \_x, \textcolor{keyword}{const} Scalar& \_y)\textcolor{keyword}{ const}
00268 \textcolor{keyword}{  }\{
00269     EIGEN\_USING\_STD\_MATH(sqrt)
00270     Scalar p, qp;
00271     \textcolor{keywordflow}{if}(\_x>\_y)
00272     \{
00273       p = \_x;
00274       qp = \_y / p;
00275     \}
00276     \textcolor{keywordflow}{else}
00277     \{
00278       p = \_y;
00279       qp = \_x / p;
00280     \}
00281     \textcolor{keywordflow}{return} p * sqrt(Scalar(1) + qp*qp);
00282   \}
00283 \};
00284 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00285}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__hypot__op_3_01_scalar_00_01_scalar_01_4_01_4}{00285} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__hypot__op}{scalar\_hypot\_op}<Scalar,Scalar> > \{
00286   \textcolor{keyword}{enum}
00287   \{
00288     Cost = 3 * \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::AddCost} +
00289            2 * \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::MulCost} +
00290            2 * \hyperlink{struct_eigen_1_1internal_1_1scalar__div__cost}{scalar\_div\_cost<Scalar,false>::value},
00291     PacketAccess = \textcolor{keyword}{false}
00292   \};
00293 \};
00294 
00298 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Exponent>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00299}\hyperlink{struct_eigen_1_1internal_1_1scalar__pow__op}{00299} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__pow__op}{scalar\_pow\_op}  : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<Scalar,Exponent>
00300 \{
00301   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<Scalar,Exponent,scalar\_pow\_op>::ReturnType}
       result\_type;
00302 \textcolor{preprocessor}{#ifndef EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN}
00303   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__pow__op}{scalar\_pow\_op})
00304 \textcolor{preprocessor}{#else}
00305   \hyperlink{struct_eigen_1_1internal_1_1scalar__pow__op}{scalar\_pow\_op}() \{
00306     \textcolor{keyword}{typedef} Scalar LhsScalar;
00307     \textcolor{keyword}{typedef} Exponent RhsScalar;
00308     EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN
00309   \}
00310 \textcolor{preprocessor}{#endif}
00311   EIGEN\_DEVICE\_FUNC
00312   \textcolor{keyword}{inline} result\_type operator() (\textcolor{keyword}{const} Scalar& a, \textcolor{keyword}{const} Exponent& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::pow(a, b); \}
00313 \};
00314 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Exponent>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00315}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__pow__op_3_01_scalar_00_01_exponent_01_4_01_4}{00315} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__pow__op}{scalar\_pow\_op}<Scalar,Exponent> > \{
00316   \textcolor{keyword}{enum} \{ Cost = 5 * \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::MulCost}, PacketAccess = \textcolor{keyword}{false} \};
00317 \};
00318 
00319 
00320 
00321 \textcolor{comment}{//---------- non associative binary functors ----------}
00322 
00328 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00329}\hyperlink{struct_eigen_1_1internal_1_1scalar__difference__op}{00329} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__difference__op}{scalar\_difference\_op} : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,RhsScalar>
00330 \{
00331   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_difference\_op>::ReturnType}
       result\_type;
00332 \textcolor{preprocessor}{#ifndef EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN}
00333   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__difference__op}{scalar\_difference\_op})
00334 \textcolor{preprocessor}{#else}
00335   \hyperlink{struct_eigen_1_1internal_1_1scalar__difference__op}{scalar\_difference\_op}() \{
00336     EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN
00337   \}
00338 \textcolor{preprocessor}{#endif}
00339   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a - b; \}
00340   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00341   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} packetOp(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& a, \textcolor{keyword}{const} 
      \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& b)\textcolor{keyword}{ const}
00342 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::psub(a,b); \}
00343 \};
00344 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00345}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__difference__op_3_01_lhs_scalar_00_01_rhs_scalar_01_4_01_4}{00345} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__difference__op}{scalar\_difference\_op}<LhsScalar,RhsScalar> > \{
00346   \textcolor{keyword}{enum} \{
00347     Cost = (\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<LhsScalar>::AddCost}+
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RhsScalar>::AddCost})/2,
00348     PacketAccess = \hyperlink{struct_eigen_1_1internal_1_1is__same}{is\_same<LhsScalar,RhsScalar>::value} && 
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::HasSub} && 
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<RhsScalar>::HasSub}
00349   \};
00350 \};
00351 
00357 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00358}\hyperlink{struct_eigen_1_1internal_1_1scalar__quotient__op}{00358} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__quotient__op}{scalar\_quotient\_op}  : \hyperlink{struct_eigen_1_1internal_1_1binary__op__base}{binary\_op\_base}<LhsScalar,RhsScalar>
00359 \{
00360   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar\_quotient\_op>::ReturnType}
       result\_type;
00361 \textcolor{preprocessor}{#ifndef EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN}
00362   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__quotient__op}{scalar\_quotient\_op})
00363 \textcolor{preprocessor}{#else}
00364   \hyperlink{struct_eigen_1_1internal_1_1scalar__quotient__op}{scalar\_quotient\_op}() \{
00365     EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN
00366   \}
00367 \textcolor{preprocessor}{#endif}
00368   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& 
      b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a / b; \}
00369   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00370   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} packetOp(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& a, \textcolor{keyword}{const} 
      \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& b)\textcolor{keyword}{ const}
00371 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pdiv(a,b); \}
00372 \};
00373 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00374}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__quotient__op_3_01_lhs_scalar_00_01_rhs_scalar_01_4_01_4}{00374} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__quotient__op}{scalar\_quotient\_op}<LhsScalar,RhsScalar> > \{
00375   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} scalar\_quotient\_op<LhsScalar,RhsScalar>::result\_type result\_type;
00376   \textcolor{keyword}{enum} \{
00377     PacketAccess = \hyperlink{struct_eigen_1_1internal_1_1is__same}{is\_same<LhsScalar,RhsScalar>::value} && 
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::HasDiv} && 
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<RhsScalar>::HasDiv},
00378     Cost = \hyperlink{struct_eigen_1_1internal_1_1scalar__div__cost}{scalar\_div\_cost<result\_type,PacketAccess>::value}
00379   \};
00380 \};
00381 
00382 
00383 
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00389}\hyperlink{struct_eigen_1_1internal_1_1scalar__boolean__and__op}{00389} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__boolean__and__op}{scalar\_boolean\_and\_op} \{
00390   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__boolean__and__op}{scalar\_boolean\_and\_op})
00391   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator() (\textcolor{keyword}{const} \textcolor{keywordtype}{bool}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a && 
      b; \}
00392 \};
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00393}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__boolean__and__op_01_4}{00393} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__boolean__and__op}{scalar\_boolean\_and\_op}> \{
00394   \textcolor{keyword}{enum} \{
00395     Cost = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<bool>::AddCost},
00396     PacketAccess = \textcolor{keyword}{false}
00397   \};
00398 \};
00399 
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00405}\hyperlink{struct_eigen_1_1internal_1_1scalar__boolean__or__op}{00405} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__boolean__or__op}{scalar\_boolean\_or\_op} \{
00406   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__boolean__or__op}{scalar\_boolean\_or\_op})
00407   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator() (\textcolor{keyword}{const} \textcolor{keywordtype}{bool}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a || 
      b; \}
00408 \};
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00409}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__boolean__or__op_01_4}{00409} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__boolean__or__op}{scalar\_boolean\_or\_op}> \{
00410   \textcolor{keyword}{enum} \{
00411     Cost = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<bool>::AddCost},
00412     PacketAccess = \textcolor{keyword}{false}
00413   \};
00414 \};
00415 
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00421}\hyperlink{struct_eigen_1_1internal_1_1scalar__boolean__xor__op}{00421} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__boolean__xor__op}{scalar\_boolean\_xor\_op} \{
00422   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__boolean__xor__op}{scalar\_boolean\_xor\_op})
00423   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator() (\textcolor{keyword}{const} \textcolor{keywordtype}{bool}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a ^ b
      ; \}
00424 \};
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00425}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__boolean__xor__op_01_4}{00425} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__boolean__xor__op}{scalar\_boolean\_xor\_op}> \{
00426   \textcolor{keyword}{enum} \{
00427     Cost = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<bool>::AddCost},
00428     PacketAccess = \textcolor{keyword}{false}
00429   \};
00430 \};
00431 
00432 
00433 
00434 \textcolor{comment}{//---------- binary functors bound to a constant, thus appearing as a unary functor ----------}
00435 
00436 \textcolor{comment}{// The following two classes permits to turn any binary functor into a unary one with one argument bound to
       a constant value.}
00437 \textcolor{comment}{// They are analogues to std::binder1st/binder2nd but with the following differences:}
00438 \textcolor{comment}{//  - they are compatible with packetOp}
00439 \textcolor{comment}{//  - they are portable across C++ versions (the std::binder* are deprecated in C++11)}
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00440}\hyperlink{struct_eigen_1_1internal_1_1bind1st__op}{00440} \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1bind1st__op}{bind1st\_op} : BinaryOp \{
00441 
00442   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BinaryOp::first\_argument\_type  first\_argument\_type;
00443   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BinaryOp::second\_argument\_type second\_argument\_type;
00444   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BinaryOp::result\_type          result\_type;
00445 
00446   \hyperlink{struct_eigen_1_1internal_1_1bind1st__op}{bind1st\_op}(\textcolor{keyword}{const} first\_argument\_type &val) : m\_value(val) \{\}
00447 
00448   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} second\_argument\_type& b)\textcolor{keyword}{ const }
      \{ \textcolor{keywordflow}{return} BinaryOp::operator()(m\_value,b); \}
00449 
00450   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00451   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} packetOp(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& b)\textcolor{keyword}{ const}
00452 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} BinaryOp::packetOp(internal::pset1<Packet>(m\_value), b); \}
00453 
00454   first\_argument\_type m\_value;
00455 \};
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00456}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01bind1st__op_3_01_binary_op_01_4_01_4}{00456} \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1bind1st__op}{bind1st\_op}<BinaryOp> > : 
      \hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<BinaryOp> \{\};
00457 
00458 
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00459}\hyperlink{struct_eigen_1_1internal_1_1bind2nd__op}{00459} \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1bind2nd__op}{bind2nd\_op} : BinaryOp \{
00460 
00461   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BinaryOp::first\_argument\_type  first\_argument\_type;
00462   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BinaryOp::second\_argument\_type second\_argument\_type;
00463   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BinaryOp::result\_type          result\_type;
00464 
00465   \hyperlink{struct_eigen_1_1internal_1_1bind2nd__op}{bind2nd\_op}(\textcolor{keyword}{const} second\_argument\_type &val) : m\_value(val) \{\}
00466 
00467   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} first\_argument\_type& a)\textcolor{keyword}{ const }\{
       \textcolor{keywordflow}{return} BinaryOp::operator()(a,m\_value); \}
00468 
00469   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00470   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} packetOp(\textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}& a)\textcolor{keyword}{ const}
00471 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} BinaryOp::packetOp(a,internal::pset1<Packet>(m\_value)); \}
00472 
00473   second\_argument\_type m\_value;
00474 \};
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_binary_functors_8h_source_l00475}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01bind2nd__op_3_01_binary_op_01_4_01_4}{00475} \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1bind2nd__op}{bind2nd\_op}<BinaryOp> > : 
      \hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<BinaryOp> \{\};
00476 
00477 
00478 \} \textcolor{comment}{// end namespace internal}
00479 
00480 \} \textcolor{comment}{// end namespace Eigen}
00481 
00482 \textcolor{preprocessor}{#endif // EIGEN\_BINARY\_FUNCTORS\_H}
\end{DoxyCode}
