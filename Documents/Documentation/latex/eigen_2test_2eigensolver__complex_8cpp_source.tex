\hypertarget{eigen_2test_2eigensolver__complex_8cpp_source}{}\section{eigen/test/eigensolver\+\_\+complex.cpp}
\label{eigen_2test_2eigensolver__complex_8cpp_source}\index{eigensolver\+\_\+complex.\+cpp@{eigensolver\+\_\+complex.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2010 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#include "main.h"}
00012 \textcolor{preprocessor}{#include <limits>}
00013 \textcolor{preprocessor}{#include <Eigen/Eigenvalues>}
00014 \textcolor{preprocessor}{#include <Eigen/LU>}
00015 
00016 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{bool} find\_pivot(\textcolor{keyword}{typename} MatrixType::Scalar tol, MatrixType &diffs, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col=0)
00017 \{
00018   \textcolor{keywordtype}{bool} match = diffs.diagonal().sum() <= tol;
00019   \textcolor{keywordflow}{if}(match || col==diffs.cols())
00020   \{
00021     \textcolor{keywordflow}{return} match;
00022   \}
00023   \textcolor{keywordflow}{else}
00024   \{
00025     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = diffs.cols();
00026     std::vector<std::pair<Index,Index> > transpositions;
00027     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=col; i<n; ++i)
00028     \{
00029       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} best\_index(0);
00030       \textcolor{keywordflow}{if}(diffs.col(col).segment(col,n-i).minCoeff(&best\_index) > tol)
00031         \textcolor{keywordflow}{break};
00032       
00033       best\_index += col;
00034       
00035       diffs.row(col).swap(diffs.row(best\_index));
00036       \textcolor{keywordflow}{if}(find\_pivot(tol,diffs,col+1)) \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00037       diffs.row(col).swap(diffs.row(best\_index));
00038       
00039       \textcolor{comment}{// move current pivot to the end}
00040       diffs.row(n-(i-col)-1).swap(diffs.row(best\_index));
00041       transpositions.push\_back(std::pair<Index,Index>(n-(i-col)-1,best\_index));
00042     \}
00043     \textcolor{comment}{// restore}
00044     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=transpositions.size()-1; k>=0; --k)
00045       diffs.row(transpositions[k].first).swap(diffs.row(transpositions[k].second));
00046   \}
00047   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00048 \}
00049 
00050 \textcolor{comment}{/* Check that two column vectors are approximately equal upto permutations.}
00051 \textcolor{comment}{ * Initially, this method checked that the k-th power sums are equal for all k = 1, ..., vec1.rows(),}
00052 \textcolor{comment}{ * however this strategy is numerically inacurate because of numerical cancellation issues.}
00053 \textcolor{comment}{ */}
00054 \textcolor{keyword}{template}<\textcolor{keyword}{typename} VectorType>
00055 \textcolor{keywordtype}{void} verify\_is\_approx\_upto\_permutation(\textcolor{keyword}{const} \hyperlink{struct_vector_type}{VectorType}& vec1, \textcolor{keyword}{const} 
      \hyperlink{struct_vector_type}{VectorType}& vec2)
00056 \{
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::Scalar Scalar;
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00059 
00060   VERIFY(vec1.cols() == 1);
00061   VERIFY(vec2.cols() == 1);
00062   VERIFY(vec1.rows() == vec2.rows());
00063   
00064   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = vec1.rows();
00065   RealScalar tol = test\_precision<RealScalar>()*test\_precision<RealScalar>()*numext::maxi(vec1.squaredNorm(
      ),vec2.squaredNorm());
00066   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<RealScalar,Dynamic,Dynamic>} diffs = (vec1.rowwise().replicate(n)
       - vec2.rowwise().replicate(n).transpose()).cwiseAbs2();
00067   
00068   VERIFY( find\_pivot(tol, diffs) );
00069 \}
00070 
00071 
00072 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} eigensolver(\textcolor{keyword}{const} MatrixType& m)
00073 \{
00074   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00075   \textcolor{comment}{/* this test covers the following files:}
00076 \textcolor{comment}{     ComplexEigenSolver.h, and indirectly ComplexSchur.h}
00077 \textcolor{comment}{  */}
00078   Index rows = m.rows();
00079   Index cols = m.cols();
00080 
00081   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00082   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00083 
00084   MatrixType a = MatrixType::Random(rows,cols);
00085   MatrixType symmA =  a.adjoint() * a;
00086 
00087   \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_eigen_solver}{ComplexEigenSolver<MatrixType>} ei0(symmA);
00088   VERIFY\_IS\_EQUAL(ei0.info(), \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success});
00089   VERIFY\_IS\_APPROX(symmA * ei0.eigenvectors(), ei0.eigenvectors() * ei0.eigenvalues().asDiagonal());
00090 
00091   \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_eigen_solver}{ComplexEigenSolver<MatrixType>} ei1(a);
00092   VERIFY\_IS\_EQUAL(ei1.info(), \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success});
00093   VERIFY\_IS\_APPROX(a * ei1.eigenvectors(), ei1.eigenvectors() * ei1.eigenvalues().asDiagonal());
00094   \textcolor{comment}{// Note: If MatrixType is real then a.eigenvalues() uses EigenSolver and thus}
00095   \textcolor{comment}{// another algorithm so results may differ slightly}
00096   verify\_is\_approx\_upto\_permutation(a.eigenvalues(), ei1.eigenvalues());
00097 
00098   \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_eigen_solver}{ComplexEigenSolver<MatrixType>} ei2;
00099   ei2.\hyperlink{group___eigenvalues___module_a0c5a974da17774d75be41e351e6bda62}{setMaxIterations}(
      \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_schur}{ComplexSchur<MatrixType>::m\_maxIterationsPerRow} * rows).
      \hyperlink{group___eigenvalues___module_aeb7e38c6db5369f5c974f3786e94c1f0}{compute}(a);
00100   VERIFY\_IS\_EQUAL(ei2.info(), \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success});
00101   VERIFY\_IS\_EQUAL(ei2.eigenvectors(), ei1.eigenvectors());
00102   VERIFY\_IS\_EQUAL(ei2.eigenvalues(), ei1.eigenvalues());
00103   \textcolor{keywordflow}{if} (rows > 2) \{
00104     ei2.setMaxIterations(1).compute(a);
00105     VERIFY\_IS\_EQUAL(ei2.info(), \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence});
00106     VERIFY\_IS\_EQUAL(ei2.getMaxIterations(), 1);
00107   \}
00108 
00109   \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_eigen_solver}{ComplexEigenSolver<MatrixType>} eiNoEivecs(a, \textcolor{keyword}{false});
00110   VERIFY\_IS\_EQUAL(eiNoEivecs.info(), \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success});
00111   VERIFY\_IS\_APPROX(ei1.eigenvalues(), eiNoEivecs.eigenvalues());
00112 
00113   \textcolor{comment}{// Regression test for issue #66}
00114   MatrixType z = MatrixType::Zero(rows,cols);
00115   \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_eigen_solver}{ComplexEigenSolver<MatrixType>} eiz(z);
00116   VERIFY((eiz.eigenvalues().cwiseEqual(0)).all());
00117 
00118   MatrixType \textcolor{keywordtype}{id} = MatrixType::Identity(rows, cols);
00119   VERIFY\_IS\_APPROX(\textcolor{keywordtype}{id}.operatorNorm(), RealScalar(1));
00120 
00121   \textcolor{keywordflow}{if} (rows > 1 && rows < 20)
00122   \{
00123     \textcolor{comment}{// Test matrix with NaN}
00124     a(0,0) = std::numeric\_limits<typename MatrixType::RealScalar>::quiet\_NaN();
00125     \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_eigen_solver}{ComplexEigenSolver<MatrixType>} eiNaN(a);
00126     VERIFY\_IS\_EQUAL(eiNaN.info(), \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence});
00127   \}
00128 
00129   \textcolor{comment}{// regression test for bug 1098}
00130   \{
00131     \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_eigen_solver}{ComplexEigenSolver<MatrixType>} eig(a.adjoint() * a);
00132     eig.compute(a.adjoint() * a);
00133   \}
00134 
00135   \textcolor{comment}{// regression test for bug 478}
00136   \{
00137     a.setZero();
00138     \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_eigen_solver}{ComplexEigenSolver<MatrixType>} ei3(a);
00139     VERIFY\_IS\_EQUAL(ei3.info(), \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success});
00140     VERIFY\_IS\_MUCH\_SMALLER\_THAN(ei3.eigenvalues().norm(),RealScalar(1));
00141     VERIFY((ei3.eigenvectors().transpose()*ei3.eigenvectors().transpose()).eval().isIdentity());
00142   \}
00143 \}
00144 
00145 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} eigensolver\_verify\_assert(\textcolor{keyword}{const} MatrixType& m)
00146 \{
00147   \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_eigen_solver}{ComplexEigenSolver<MatrixType>} eig;
00148   VERIFY\_RAISES\_ASSERT(eig.\hyperlink{group___eigenvalues___module_a3aa5e27800349990778da8fa532c1270}{eigenvectors}());
00149   VERIFY\_RAISES\_ASSERT(eig.\hyperlink{group___eigenvalues___module_a10c25c7620e7faedcd39991cce3a757b}{eigenvalues}());
00150 
00151   MatrixType a = MatrixType::Random(m.rows(),m.cols());
00152   eig.\hyperlink{group___eigenvalues___module_aeb7e38c6db5369f5c974f3786e94c1f0}{compute}(a, \textcolor{keyword}{false});
00153   VERIFY\_RAISES\_ASSERT(eig.\hyperlink{group___eigenvalues___module_a3aa5e27800349990778da8fa532c1270}{eigenvectors}());
00154 \}
00155 
00156 \textcolor{keywordtype}{void} test\_eigensolver\_complex()
00157 \{
00158   \textcolor{keywordtype}{int} s = 0;
00159   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00160     CALL\_SUBTEST\_1( eigensolver(Matrix4cf()) );
00161     s = internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/4);
00162     CALL\_SUBTEST\_2( eigensolver(MatrixXcd(s,s)) );
00163     CALL\_SUBTEST\_3( eigensolver(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<std::complex<float>, 1, 1>()) );
00164     CALL\_SUBTEST\_4( eigensolver(Matrix3f()) );
00165     TEST\_SET\_BUT\_UNUSED\_VARIABLE(s)
00166   \}
00167   CALL\_SUBTEST\_1( eigensolver\_verify\_assert(Matrix4cf()) );
00168   s = internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/4);
00169   CALL\_SUBTEST\_2( eigensolver\_verify\_assert(MatrixXcd(s,s)) );
00170   CALL\_SUBTEST\_3( eigensolver\_verify\_assert(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<std::complex<float>, 1, 1>()) );
00171   CALL\_SUBTEST\_4( eigensolver\_verify\_assert(Matrix3f()) );
00172 
00173   \textcolor{comment}{// Test problem size constructors}
00174   CALL\_SUBTEST\_5(\hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_eigen_solver}{ComplexEigenSolver<MatrixXf>} tmp(s));
00175   
00176   TEST\_SET\_BUT\_UNUSED\_VARIABLE(s)
00177 \}
\end{DoxyCode}
