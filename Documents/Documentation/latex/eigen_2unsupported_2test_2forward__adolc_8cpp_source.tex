\hypertarget{eigen_2unsupported_2test_2forward__adolc_8cpp_source}{}\section{eigen/unsupported/test/forward\+\_\+adolc.cpp}
\label{eigen_2unsupported_2test_2forward__adolc_8cpp_source}\index{forward\+\_\+adolc.\+cpp@{forward\+\_\+adolc.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <g.gael@free.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 \textcolor{preprocessor}{#include <Eigen/Dense>}
00012 
00013 \textcolor{preprocessor}{#define NUMBER\_DIRECTIONS 16}
00014 \textcolor{preprocessor}{#include <unsupported/Eigen/AdolcForward>}
00015 
00016 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Vector>
00017 EIGEN\_DONT\_INLINE \textcolor{keyword}{typename} Vector::Scalar foo(\textcolor{keyword}{const} Vector& p)
00018 \{
00019   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Vector::Scalar Scalar;
00020   \textcolor{keywordflow}{return} (p-Vector(Scalar(-1),Scalar(1.))).norm() + (p.array().sqrt().abs() * p.array().sin()).sum() + p.
      dot(p);
00021 \}
00022 
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} NX=Dynamic, \textcolor{keywordtype}{int} NY=Dynamic>
00024 \textcolor{keyword}{struct }\hyperlink{struct_test_func1}{TestFunc1}
00025 \{
00026   \textcolor{keyword}{typedef} \_Scalar Scalar;
00027   \textcolor{keyword}{enum} \{
00028     InputsAtCompileTime = NX,
00029     ValuesAtCompileTime = NY
00030   \};
00031   \textcolor{keyword}{typedef} Matrix<Scalar,InputsAtCompileTime,1> InputType;
00032   \textcolor{keyword}{typedef} Matrix<Scalar,ValuesAtCompileTime,1> ValueType;
00033   \textcolor{keyword}{typedef} Matrix<Scalar,ValuesAtCompileTime,InputsAtCompileTime> JacobianType;
00034 
00035   \textcolor{keywordtype}{int} m\_inputs, m\_values;
00036 
00037   \hyperlink{struct_test_func1}{TestFunc1}() : m\_inputs(InputsAtCompileTime), m\_values(ValuesAtCompileTime) \{\}
00038   \hyperlink{struct_test_func1}{TestFunc1}(\textcolor{keywordtype}{int} inputs, \textcolor{keywordtype}{int} values) : m\_inputs(inputs), m\_values(values) \{\}
00039 
00040   \textcolor{keywordtype}{int} inputs()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_inputs; \}
00041   \textcolor{keywordtype}{int} values()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_values; \}
00042 
00043   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00044   \textcolor{keywordtype}{void} operator() (\textcolor{keyword}{const} Matrix<T,InputsAtCompileTime,1>& x, Matrix<T,ValuesAtCompileTime,1>* \_v)\textcolor{keyword}{ const}
00045 \textcolor{keyword}{  }\{
00046     Matrix<T,ValuesAtCompileTime,1>& v = *\_v;
00047 
00048     v[0] = 2 * x[0] * x[0] + x[0] * x[1];
00049     v[1] = 3 * x[1] * x[0] + 0.5 * x[1] * x[1];
00050     \textcolor{keywordflow}{if}(inputs()>2)
00051     \{
00052       v[0] += 0.5 * x[2];
00053       v[1] += x[2];
00054     \}
00055     \textcolor{keywordflow}{if}(values()>2)
00056     \{
00057       v[2] = 3 * x[1] * x[0] * x[0];
00058     \}
00059     \textcolor{keywordflow}{if} (inputs()>2 && values()>2)
00060       v[2] *= x[2];
00061   \}
00062 
00063   \textcolor{keywordtype}{void} operator() (\textcolor{keyword}{const} InputType& x, ValueType* v, JacobianType* \_j)\textcolor{keyword}{ const}
00064 \textcolor{keyword}{  }\{
00065     (*this)(x, v);
00066 
00067     \textcolor{keywordflow}{if}(\_j)
00068     \{
00069       JacobianType& j = *\_j;
00070 
00071       j(0,0) = 4 * x[0] + x[1];
00072       j(1,0) = 3 * x[1];
00073 
00074       j(0,1) = x[0];
00075       j(1,1) = 3 * x[0] + 2 * 0.5 * x[1];
00076 
00077       \textcolor{keywordflow}{if} (inputs()>2)
00078       \{
00079         j(0,2) = 0.5;
00080         j(1,2) = 1;
00081       \}
00082       \textcolor{keywordflow}{if}(values()>2)
00083       \{
00084         j(2,0) = 3 * x[1] * 2 * x[0];
00085         j(2,1) = 3 * x[0] * x[0];
00086       \}
00087       \textcolor{keywordflow}{if} (inputs()>2 && values()>2)
00088       \{
00089         j(2,0) *= x[2];
00090         j(2,1) *= x[2];
00091 
00092         j(2,2) = 3 * x[1] * x[0] * x[0];
00093         j(2,2) = 3 * x[1] * x[0] * x[0];
00094       \}
00095     \}
00096   \}
00097 \};
00098 
00099 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Func> \textcolor{keywordtype}{void} adolc\_forward\_jacobian(\textcolor{keyword}{const} Func& f)
00100 \{
00101     \textcolor{keyword}{typename} Func::InputType x = Func::InputType::Random(f.inputs());
00102     \textcolor{keyword}{typename} Func::ValueType y(f.values()), yref(f.values());
00103     \textcolor{keyword}{typename} Func::JacobianType j(f.values(),f.inputs()), jref(f.values(),f.inputs());
00104 
00105     jref.setZero();
00106     yref.setZero();
00107     f(x,&yref,&jref);
00108 \textcolor{comment}{//     std::cerr << y.transpose() << "\(\backslash\)n\(\backslash\)n";;}
00109 \textcolor{comment}{//     std::cerr << j << "\(\backslash\)n\(\backslash\)n";;}
00110 
00111     j.setZero();
00112     y.setZero();
00113     AdolcForwardJacobian<Func> autoj(f);
00114     autoj(x, &y, &j);
00115 \textcolor{comment}{//     std::cerr << y.transpose() << "\(\backslash\)n\(\backslash\)n";;}
00116 \textcolor{comment}{//     std::cerr << j << "\(\backslash\)n\(\backslash\)n";;}
00117 
00118     VERIFY\_IS\_APPROX(y, yref);
00119     VERIFY\_IS\_APPROX(j, jref);
00120 \}
00121 
00122 \textcolor{keywordtype}{void} test\_forward\_adolc()
00123 \{
00124   adtl::setNumDir(NUMBER\_DIRECTIONS);
00125 
00126   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00127     CALL\_SUBTEST(( adolc\_forward\_jacobian(\hyperlink{struct_test_func1}{TestFunc1<double,2,2>}()) ));
00128     CALL\_SUBTEST(( adolc\_forward\_jacobian(\hyperlink{struct_test_func1}{TestFunc1<double,2,3>}()) ));
00129     CALL\_SUBTEST(( adolc\_forward\_jacobian(\hyperlink{struct_test_func1}{TestFunc1<double,3,2>}()) ));
00130     CALL\_SUBTEST(( adolc\_forward\_jacobian(\hyperlink{struct_test_func1}{TestFunc1<double,3,3>}()) ));
00131     CALL\_SUBTEST(( adolc\_forward\_jacobian(\hyperlink{struct_test_func1}{TestFunc1<double>}(3,3)) ));
00132   \}
00133 
00134   \{
00135     \textcolor{comment}{// simple instanciation tests}
00136     Matrix<adtl::adouble,2,1> x;
00137     foo(x);
00138     Matrix<adtl::adouble,Dynamic,Dynamic> A(4,4);;
00139     A.selfadjointView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}>().eigenvalues();
00140   \}
00141 \}
\end{DoxyCode}
