\hypertarget{eigen_2bench_2spbench_2sp__solver_8cpp_source}{}\section{eigen/bench/spbench/sp\+\_\+solver.cpp}
\label{eigen_2bench_2spbench_2sp__solver_8cpp_source}\index{sp\+\_\+solver.\+cpp@{sp\+\_\+solver.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// Small bench routine for Eigen available in Eigen}
00002 \textcolor{comment}{// (C) Desire NUENTSA WAKAM, INRIA}
00003 
00004 \textcolor{preprocessor}{#include <iostream>}
00005 \textcolor{preprocessor}{#include <fstream>}
00006 \textcolor{preprocessor}{#include <iomanip>}
00007 \textcolor{preprocessor}{#include <Eigen/Jacobi>}
00008 \textcolor{preprocessor}{#include <Eigen/Householder>}
00009 \textcolor{preprocessor}{#include <Eigen/IterativeLinearSolvers>}
00010 \textcolor{preprocessor}{#include <Eigen/LU>}
00011 \textcolor{preprocessor}{#include <unsupported/Eigen/SparseExtra>}
00012 \textcolor{comment}{//#include <Eigen/SparseLU>}
00013 \textcolor{preprocessor}{#include <Eigen/SuperLUSupport>}
00014 \textcolor{comment}{// #include <unsupported/Eigen/src/IterativeSolvers/Scaling.h>}
00015 \textcolor{preprocessor}{#include <bench/BenchTimer.h>}
00016 \textcolor{preprocessor}{#include <unsupported/Eigen/IterativeSolvers>}
00017 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00018 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00019 
00020 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **args)
00021 \{
00022   \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double, ColMajor>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}; 
00023   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double, ColMajor>::Index} 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00024   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double, Dynamic, Dynamic>} 
      \hyperlink{group___core___module}{DenseMatrix};
00025   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double, Dynamic, 1>} DenseRhs;
00026   VectorXd b, x, tmp;
00027   \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} timer,totaltime; 
00028   \textcolor{comment}{//SparseLU<SparseMatrix<double, ColMajor> >   solver;}
00029 \textcolor{comment}{//   SuperLU<SparseMatrix<double, ColMajor> >   solver;}
00030   \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_conjugate_gradient}{ConjugateGradient<SparseMatrix<double, ColMajor>}, 
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower},\hyperlink{class_eigen_1_1_incomplete_cholesky}{IncompleteCholesky<double,Lower>} > solver; 
00031   ifstream matrix\_file; 
00032   \textcolor{keywordtype}{string} line;
00033   \textcolor{keywordtype}{int}  n;
00034   \textcolor{comment}{// Set parameters}
00035 \textcolor{comment}{//   solver.iparm(IPARM\_THREAD\_NBR) = 4;}
00036   \textcolor{comment}{/* Fill the matrix with sparse matrix stored in Matrix-Market coordinate column-oriented format */}
00037   \textcolor{keywordflow}{if} (argc < 2) assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"please, give the matrix market file "});
00038   
00039   timer.start();
00040   totaltime.start();
00041   loadMarket(A, args[1]);
00042   cout << \textcolor{stringliteral}{"End charging matrix "} << endl;
00043   \textcolor{keywordtype}{bool} iscomplex=\textcolor{keyword}{false}, isvector=\textcolor{keyword}{false};
00044   \textcolor{keywordtype}{int} sym;
00045   getMarketHeader(args[1], sym, iscomplex, isvector);
00046   \textcolor{keywordflow}{if} (iscomplex) \{ cout<< \textcolor{stringliteral}{" Not for complex matrices \(\backslash\)n"}; \textcolor{keywordflow}{return} -1; \}
00047   \textcolor{keywordflow}{if} (isvector) \{ cout << \textcolor{stringliteral}{"The provided file is not a matrix file\(\backslash\)n"}; \textcolor{keywordflow}{return} -1;\}
00048   \textcolor{keywordflow}{if} (sym != 0) \{ \textcolor{comment}{// symmetric matrices, only the lower part is stored}
00049     \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double, ColMajor>} temp; 
00050     temp = A;
00051     A = temp.selfadjointView<Lower>();
00052   \}
00053   timer.stop();
00054   
00055   n = A.\hyperlink{group___sparse_core___module_aa391750e3c530227e4a5c3c52e959975}{cols}();
00056   \textcolor{comment}{// ====== TESTS FOR SPARSE TUTORIAL ======}
00057 \textcolor{comment}{//   cout<< "OuterSize " << A.outerSize() << " inner " << A.innerSize() << endl; }
00058 \textcolor{comment}{//   SparseMatrix<double, RowMajor> mat1(A); }
00059 \textcolor{comment}{//   SparseMatrix<double, RowMajor> mat2;}
00060 \textcolor{comment}{//   cout << " norm of A " << mat1.norm() << endl; ;}
00061 \textcolor{comment}{//   PermutationMatrix<Dynamic, Dynamic, int> perm(n);}
00062 \textcolor{comment}{//   perm.resize(n,1);}
00063 \textcolor{comment}{//   perm.indices().setLinSpaced(n, 0, n-1);}
00064 \textcolor{comment}{//   mat2 = perm * mat1;}
00065 \textcolor{comment}{//   mat.subrows();}
00066 \textcolor{comment}{//   mat2.resize(n,n); }
00067 \textcolor{comment}{//   mat2.reserve(10);}
00068 \textcolor{comment}{//   mat2.setConstant();}
00069 \textcolor{comment}{//   std::cout<< "NORM " << mat1.squaredNorm()<< endl;  }
00070 
00071   cout<< \textcolor{stringliteral}{"Time to load the matrix "} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() <<endl;
00072   \textcolor{comment}{/* Fill the right hand side */}
00073 
00074 \textcolor{comment}{//   solver.set\_restart(374);}
00075   \textcolor{keywordflow}{if} (argc > 2)
00076     loadMarketVector(b, args[2]);
00077   \textcolor{keywordflow}{else} 
00078   \{
00079     b.resize(n);
00080     tmp.resize(n);
00081 \textcolor{comment}{//       tmp.setRandom();}
00082     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < n; i++) tmp(i) = i; 
00083     b = A * tmp ;
00084   \}
00085 \textcolor{comment}{//   Scaling<SparseMatrix<double> > scal; }
00086 \textcolor{comment}{//   scal.computeRef(A);}
00087 \textcolor{comment}{//   b = scal.LeftScaling().cwiseProduct(b);}
00088 
00089   \textcolor{comment}{/* Compute the factorization */}
00090   cout<< \textcolor{stringliteral}{"Starting the factorization "}<< endl; 
00091   timer.reset();
00092   timer.start(); 
00093   cout<< \textcolor{stringliteral}{"Size of Input Matrix "}<< b.size()<<\textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
00094   cout<< \textcolor{stringliteral}{"Rows and columns "}<< A.\hyperlink{group___sparse_core___module_a62e61bb861eee306d5b069ce652b5aa5}{rows}() <<\textcolor{stringliteral}{" "} <<A.\hyperlink{group___sparse_core___module_aa391750e3c530227e4a5c3c52e959975}{cols}() <<\textcolor{stringliteral}{"\(\backslash\)n"};
00095   solver.\hyperlink{group___iterative_linear_solvers___module_a7dfa55c55e82d697bde227696a630914}{compute}(A);
00096 \textcolor{comment}{//   solver.analyzePattern(A);}
00097 \textcolor{comment}{//   solver.factorize(A);}
00098   \textcolor{keywordflow}{if} (solver.\hyperlink{group___iterative_linear_solvers___module_a0d6b459433a316b4f12d48e5c80d61fe}{info}() != \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success}) \{
00099     std::cout<< \textcolor{stringliteral}{"The solver failed \(\backslash\)n"};
00100     \textcolor{keywordflow}{return} -1; 
00101   \}
00102   timer.stop(); 
00103   \textcolor{keywordtype}{float} time\_comp = timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}(); 
00104   cout <<\textcolor{stringliteral}{" Compute Time "} << time\_comp<< endl; 
00105   
00106   timer.reset();
00107   timer.start();
00108   x = solver.\hyperlink{group___sparse_core___module_a4a66e9498b06e3ec4ec36f06b26d4e8f}{solve}(b);
00109 \textcolor{comment}{//   x = scal.RightScaling().cwiseProduct(x);}
00110   timer.stop();
00111   \textcolor{keywordtype}{float} time\_solve = timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}(); 
00112   cout<< \textcolor{stringliteral}{" Time to solve "} << time\_solve << endl; 
00113  
00114   \textcolor{comment}{/* Check the accuracy */}
00115   VectorXd tmp2 = b - A*x;
00116   \textcolor{keywordtype}{double} tempNorm = tmp2.norm()/b.norm();
00117   cout << \textcolor{stringliteral}{"Relative norm of the computed solution : "} << tempNorm <<\textcolor{stringliteral}{"\(\backslash\)n"};
00118 \textcolor{comment}{//   cout << "Iterations : " << solver.iterations() << "\(\backslash\)n"; }
00119   
00120   totaltime.stop();
00121   cout << \textcolor{stringliteral}{"Total time "} << totaltime.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << \textcolor{stringliteral}{"\(\backslash\)n"};
00122 \textcolor{comment}{//  std::cout<<x.transpose()<<"\(\backslash\)n";}
00123   
00124   \textcolor{keywordflow}{return} 0;
00125 \}
\end{DoxyCode}
