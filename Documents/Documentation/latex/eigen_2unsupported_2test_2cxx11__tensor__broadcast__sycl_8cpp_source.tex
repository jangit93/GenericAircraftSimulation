\hypertarget{eigen_2unsupported_2test_2cxx11__tensor__broadcast__sycl_8cpp_source}{}\section{eigen/unsupported/test/cxx11\+\_\+tensor\+\_\+broadcast\+\_\+sycl.cpp}
\label{eigen_2unsupported_2test_2cxx11__tensor__broadcast__sycl_8cpp_source}\index{cxx11\+\_\+tensor\+\_\+broadcast\+\_\+sycl.\+cpp@{cxx11\+\_\+tensor\+\_\+broadcast\+\_\+sycl.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2016}
00005 \textcolor{comment}{// Mehdi Goli    Codeplay Software Ltd.}
00006 \textcolor{comment}{// Ralph Potter  Codeplay Software Ltd.}
00007 \textcolor{comment}{// Luke Iwanski  Codeplay Software Ltd.}
00008 \textcolor{comment}{// Contact: <eigen@codeplay.com>}
00009 \textcolor{comment}{//}
00010 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00011 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00012 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00013 
00014 \textcolor{preprocessor}{#define EIGEN\_TEST\_NO\_LONGDOUBLE}
00015 \textcolor{preprocessor}{#define EIGEN\_TEST\_NO\_COMPLEX}
00016 \textcolor{preprocessor}{#define EIGEN\_TEST\_FUNC cxx11\_tensor\_broadcast\_sycl}
00017 \textcolor{preprocessor}{#define EIGEN\_DEFAULT\_DENSE\_INDEX\_TYPE int}
00018 \textcolor{preprocessor}{#define EIGEN\_USE\_SYCL}
00019 
00020 \textcolor{preprocessor}{#include "main.h"}
00021 \textcolor{preprocessor}{#include <unsupported/Eigen/CXX11/Tensor>}
00022 
00023 \textcolor{keyword}{using} \hyperlink{class_eigen_1_1array}{Eigen::array};
00024 \textcolor{keyword}{using} Eigen::SyclDevice;
00025 \textcolor{keyword}{using} \hyperlink{class_eigen_1_1_tensor}{Eigen::Tensor};
00026 \textcolor{keyword}{using} \hyperlink{class_eigen_1_1_tensor_map}{Eigen::TensorMap};
00027 
00028 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_broadcast\_sycl(\textcolor{keyword}{const} Eigen::SyclDevice &sycl\_device)\{
00029 
00030   \textcolor{comment}{// BROADCAST test:}
00031   \hyperlink{class_eigen_1_1array}{array<int, 4>} in\_range   = \{\{2, 3, 5, 7\}\};
00032   \hyperlink{class_eigen_1_1array}{array<int, 4>} broadcasts = \{\{2, 3, 1, 4\}\};
00033   \hyperlink{class_eigen_1_1array}{array<int, 4>} out\_range;  \textcolor{comment}{// = in\_range * broadcasts}
00034   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < out\_range.size(); ++i)
00035     out\_range[i] = in\_range[i] * broadcasts[i];
00036 
00037   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 4>}  input(in\_range);
00038   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 4>} out(out\_range);
00039 
00040   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < in\_range.size(); ++i)
00041     VERIFY\_IS\_EQUAL(out.dimension(i), out\_range[i]);
00042 
00043 
00044   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < input.size(); ++i)
00045     input(i) = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(i);
00046 
00047   \textcolor{keywordtype}{float} * gpu\_in\_data  = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(sycl\_device.allocate(input.dimensions().TotalSize()*\textcolor{keyword}{sizeof}(
      float)));
00048   \textcolor{keywordtype}{float} * gpu\_out\_data  = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(sycl\_device.allocate(out.dimensions().TotalSize()*\textcolor{keyword}{sizeof}(
      float)));
00049 
00050   \hyperlink{class_eigen_1_1_tensor_map}{TensorMap<Tensor<float, 4>}>  gpu\_in(gpu\_in\_data, in\_range);
00051   \hyperlink{class_eigen_1_1_tensor_map}{TensorMap<Tensor<float, 4>}> gpu\_out(gpu\_out\_data, out\_range);
00052   sycl\_device.memcpyHostToDevice(gpu\_in\_data, input.data(),(input.dimensions().TotalSize())*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}));
00053   gpu\_out.device(sycl\_device) = gpu\_in.broadcast(broadcasts);
00054   sycl\_device.memcpyDeviceToHost(out.data(), gpu\_out\_data,(out.dimensions().TotalSize())*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}));
00055 
00056   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; ++i) \{
00057     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 9; ++j) \{
00058       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 0; k < 5; ++k) \{
00059         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} l = 0; l < 28; ++l) \{
00060           VERIFY\_IS\_APPROX(input(i%2,j%3,k%5,l%7), out(i,j,k,l));
00061         \}
00062       \}
00063     \}
00064   \}
00065   printf(\textcolor{stringliteral}{"Broadcast Test Passed\(\backslash\)n"});
00066   sycl\_device.deallocate(gpu\_in\_data);
00067   sycl\_device.deallocate(gpu\_out\_data);
00068 \}
00069 
00070 \textcolor{keywordtype}{void} test\_cxx11\_tensor\_broadcast\_sycl() \{
00071   cl::sycl::gpu\_selector s;
00072   Eigen::SyclDevice sycl\_device(s);
00073   CALL\_SUBTEST(test\_broadcast\_sycl(sycl\_device));
00074 \}
\end{DoxyCode}
