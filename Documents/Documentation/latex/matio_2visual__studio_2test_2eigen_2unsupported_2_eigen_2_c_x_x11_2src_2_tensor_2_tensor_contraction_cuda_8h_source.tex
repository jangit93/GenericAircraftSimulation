\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_contraction_cuda_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Contraction\+Cuda.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_contraction_cuda_8h_source}\index{Tensor\+Contraction\+Cuda.\+h@{Tensor\+Contraction\+Cuda.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014-2015 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2015 Navdeep Jaitly <ndjaitly@google.com>}
00006 \textcolor{comment}{// Copyright (C) 2014 Eric Martin <eric@ericmart.in>}
00007 \textcolor{comment}{//}
00008 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00009 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00010 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00011 
00012 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_CONTRACTION\_CUDA\_H}
00013 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_CONTRACTION\_CUDA\_H}
00014 
00015 \textcolor{preprocessor}{#if defined(EIGEN\_USE\_GPU) && defined(\_\_CUDACC\_\_)}
00016 
00017 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00018 
00019 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keyword}{typename} LhsMapper,
00020          \textcolor{keyword}{typename} RhsMapper, \textcolor{keyword}{typename} OutputMapper, \textcolor{keywordtype}{bool} needs\_edge\_check>
00021 \_\_device\_\_ EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00022 EigenContractionKernelInternal(\textcolor{keyword}{const} LhsMapper lhs, \textcolor{keyword}{const} RhsMapper rhs,
00023                                \textcolor{keyword}{const} OutputMapper output, Scalar* lhs\_shmem, Scalar* rhs\_shmem,
00024                        \textcolor{keyword}{const} Index m\_size, \textcolor{keyword}{const} Index n\_size, \textcolor{keyword}{const} Index k\_size) \{
00025 
00026   \textcolor{keyword}{const} Index m\_block\_idx = blockIdx.x;
00027   \textcolor{keyword}{const} Index n\_block\_idx = blockIdx.y;
00028 
00029   \textcolor{keyword}{const} Index base\_m = 64 * m\_block\_idx;
00030   \textcolor{keyword}{const} Index base\_n = 64 * n\_block\_idx;
00031 
00032   \textcolor{comment}{// declare and initialize 64 registers for output 8x8 block}
00033 
00034   \textcolor{comment}{// prefetch registers}
00035   Scalar lhs\_pf0;
00036   Scalar lhs\_pf1;
00037   Scalar lhs\_pf2;
00038   Scalar lhs\_pf3;
00039   Scalar lhs\_pf4;
00040   Scalar lhs\_pf5;
00041   Scalar lhs\_pf6;
00042   Scalar lhs\_pf7;
00043 
00044   Scalar rhs\_pf0;
00045   Scalar rhs\_pf1;
00046   Scalar rhs\_pf2;
00047   Scalar rhs\_pf3;
00048   Scalar rhs\_pf4;
00049   Scalar rhs\_pf5;
00050   Scalar rhs\_pf6;
00051   Scalar rhs\_pf7;
00052 
00053   \textcolor{comment}{// shared memory is formatted}
00054   \textcolor{comment}{// (contract idx in block, nocontract idx in block, block idx)}
00055   \textcolor{comment}{// where block idx is column major. This transposition limits the number of}
00056   \textcolor{comment}{// bank conflicts when reading the LHS. The core idea is that since the contracting}
00057   \textcolor{comment}{// index is shared by both sides, then the contracting index should be in threadIdx.x.}
00058 
00059   \textcolor{comment}{// On the LHS, we pad each row inside of each block with an extra element. This makes}
00060   \textcolor{comment}{// each block 8 rows of 9 elements, which is 72 elements. This gives no bank conflicts}
00061   \textcolor{comment}{// on writes and very few 2-way conflicts on reads. There is an 8x8 grid of these blocks.}
00062 
00063   \textcolor{comment}{// On the RHS we just add 8 padding elements to the end of each block. This gives no bank}
00064   \textcolor{comment}{// conflicts on writes and also none on reads.}
00065 
00066   \textcolor{comment}{// storage indices}
00067   \textcolor{keyword}{const} Index lhs\_store\_idx\_base = threadIdx.y * 72 + threadIdx.x * 9 + threadIdx.z;
00068   \textcolor{keyword}{const} Index rhs\_store\_idx\_base = threadIdx.y * 72 + threadIdx.z * 8 + threadIdx.x;
00069 
00070   \textcolor{keyword}{const} Index lhs\_store\_idx\_0 = lhs\_store\_idx\_base + 576 * 0;
00071   \textcolor{keyword}{const} Index lhs\_store\_idx\_1 = lhs\_store\_idx\_base + 576 * 1;
00072   \textcolor{keyword}{const} Index lhs\_store\_idx\_2 = lhs\_store\_idx\_base + 576 * 2;
00073   \textcolor{keyword}{const} Index lhs\_store\_idx\_3 = lhs\_store\_idx\_base + 576 * 3;
00074   \textcolor{keyword}{const} Index lhs\_store\_idx\_4 = lhs\_store\_idx\_base + 576 * 4;
00075   \textcolor{keyword}{const} Index lhs\_store\_idx\_5 = lhs\_store\_idx\_base + 576 * 5;
00076   \textcolor{keyword}{const} Index lhs\_store\_idx\_6 = lhs\_store\_idx\_base + 576 * 6;
00077   \textcolor{keyword}{const} Index lhs\_store\_idx\_7 = lhs\_store\_idx\_base + 576 * 7;
00078 
00079   \textcolor{keyword}{const} Index rhs\_store\_idx\_0 = rhs\_store\_idx\_base + 576 * 0;
00080   \textcolor{keyword}{const} Index rhs\_store\_idx\_1 = rhs\_store\_idx\_base + 576 * 1;
00081   \textcolor{keyword}{const} Index rhs\_store\_idx\_2 = rhs\_store\_idx\_base + 576 * 2;
00082   \textcolor{keyword}{const} Index rhs\_store\_idx\_3 = rhs\_store\_idx\_base + 576 * 3;
00083   \textcolor{keyword}{const} Index rhs\_store\_idx\_4 = rhs\_store\_idx\_base + 576 * 4;
00084   \textcolor{keyword}{const} Index rhs\_store\_idx\_5 = rhs\_store\_idx\_base + 576 * 5;
00085   \textcolor{keyword}{const} Index rhs\_store\_idx\_6 = rhs\_store\_idx\_base + 576 * 6;
00086   \textcolor{keyword}{const} Index rhs\_store\_idx\_7 = rhs\_store\_idx\_base + 576 * 7;
00087 
00088   \textcolor{comment}{// in the loading code, the following variables are important:}
00089   \textcolor{comment}{// threadIdx.x: the vertical position in an 8x8 block}
00090   \textcolor{comment}{// threadIdx.y: the vertical index of the 8x8 block in the grid}
00091   \textcolor{comment}{// threadIdx.z: the horizontal position in an 8x8 block}
00092   \textcolor{comment}{// k: the horizontal index of the 8x8 block in the grid}
00093   \textcolor{comment}{//}
00094   \textcolor{comment}{// The k parameter is implicit (it was the loop counter for a loop that went}
00095   \textcolor{comment}{// from 0 to <8, but now that loop is unrolled in the below code.}
00096 
00097   \textcolor{keyword}{const} Index load\_idx\_vert = threadIdx.x + 8 * threadIdx.y;
00098   \textcolor{keyword}{const} Index lhs\_vert = base\_m + load\_idx\_vert;
00099 
00100 \textcolor{preprocessor}{#define prefetchIntoRegisters(base\_k)                           \(\backslash\)}
00101 \textcolor{preprocessor}{  \{                                                             \(\backslash\)}
00102 \textcolor{preprocessor}{    lhs\_pf0 = conv(0);                                          \(\backslash\)}
00103 \textcolor{preprocessor}{    lhs\_pf1 = conv(0);                                          \(\backslash\)}
00104 \textcolor{preprocessor}{    lhs\_pf2 = conv(0);                                          \(\backslash\)}
00105 \textcolor{preprocessor}{    lhs\_pf3 = conv(0);                                          \(\backslash\)}
00106 \textcolor{preprocessor}{    lhs\_pf4 = conv(0);                                          \(\backslash\)}
00107 \textcolor{preprocessor}{    lhs\_pf5 = conv(0);                                          \(\backslash\)}
00108 \textcolor{preprocessor}{    lhs\_pf6 = conv(0);                                          \(\backslash\)}
00109 \textcolor{preprocessor}{    lhs\_pf7 = conv(0);                                          \(\backslash\)}
00110 \textcolor{preprocessor}{                                                                \(\backslash\)}
00111 \textcolor{preprocessor}{    rhs\_pf0 = conv(0);                                          \(\backslash\)}
00112 \textcolor{preprocessor}{    rhs\_pf1 = conv(0);                                          \(\backslash\)}
00113 \textcolor{preprocessor}{    rhs\_pf2 = conv(0);                                          \(\backslash\)}
00114 \textcolor{preprocessor}{    rhs\_pf3 = conv(0);                                          \(\backslash\)}
00115 \textcolor{preprocessor}{    rhs\_pf4 = conv(0);                                          \(\backslash\)}
00116 \textcolor{preprocessor}{    rhs\_pf5 = conv(0);                                          \(\backslash\)}
00117 \textcolor{preprocessor}{    rhs\_pf6 = conv(0);                                          \(\backslash\)}
00118 \textcolor{preprocessor}{    rhs\_pf7 = conv(0);                                          \(\backslash\)}
00119 \textcolor{preprocessor}{                                                                \(\backslash\)}
00120 \textcolor{preprocessor}{    if (!needs\_edge\_check || lhs\_vert < m\_size) \{               \(\backslash\)}
00121 \textcolor{preprocessor}{      const Index lhs\_horiz\_0 = base\_k + threadIdx.z + 0 * 8;   \(\backslash\)}
00122 \textcolor{preprocessor}{      const Index lhs\_horiz\_1 = base\_k + threadIdx.z + 1 * 8;   \(\backslash\)}
00123 \textcolor{preprocessor}{      const Index lhs\_horiz\_2 = base\_k + threadIdx.z + 2 * 8;   \(\backslash\)}
00124 \textcolor{preprocessor}{      const Index lhs\_horiz\_3 = base\_k + threadIdx.z + 3 * 8;   \(\backslash\)}
00125 \textcolor{preprocessor}{      const Index lhs\_horiz\_4 = base\_k + threadIdx.z + 4 * 8;   \(\backslash\)}
00126 \textcolor{preprocessor}{      const Index lhs\_horiz\_5 = base\_k + threadIdx.z + 5 * 8;   \(\backslash\)}
00127 \textcolor{preprocessor}{      const Index lhs\_horiz\_6 = base\_k + threadIdx.z + 6 * 8;   \(\backslash\)}
00128 \textcolor{preprocessor}{      const Index lhs\_horiz\_7 = base\_k + threadIdx.z + 7 * 8;   \(\backslash\)}
00129 \textcolor{preprocessor}{                                                                \(\backslash\)}
00130 \textcolor{preprocessor}{      if (!needs\_edge\_check || lhs\_horiz\_7 < k\_size) \{          \(\backslash\)}
00131 \textcolor{preprocessor}{        lhs\_pf0 = lhs(lhs\_vert, lhs\_horiz\_0);                   \(\backslash\)}
00132 \textcolor{preprocessor}{        lhs\_pf1 = lhs(lhs\_vert, lhs\_horiz\_1);                   \(\backslash\)}
00133 \textcolor{preprocessor}{        lhs\_pf2 = lhs(lhs\_vert, lhs\_horiz\_2);                   \(\backslash\)}
00134 \textcolor{preprocessor}{        lhs\_pf3 = lhs(lhs\_vert, lhs\_horiz\_3);                   \(\backslash\)}
00135 \textcolor{preprocessor}{        lhs\_pf4 = lhs(lhs\_vert, lhs\_horiz\_4);                   \(\backslash\)}
00136 \textcolor{preprocessor}{        lhs\_pf5 = lhs(lhs\_vert, lhs\_horiz\_5);                   \(\backslash\)}
00137 \textcolor{preprocessor}{        lhs\_pf6 = lhs(lhs\_vert, lhs\_horiz\_6);                   \(\backslash\)}
00138 \textcolor{preprocessor}{        lhs\_pf7 = lhs(lhs\_vert, lhs\_horiz\_7);                   \(\backslash\)}
00139 \textcolor{preprocessor}{      \} else if (lhs\_horiz\_6 < k\_size) \{                        \(\backslash\)}
00140 \textcolor{preprocessor}{        lhs\_pf0 = lhs(lhs\_vert, lhs\_horiz\_0);                   \(\backslash\)}
00141 \textcolor{preprocessor}{        lhs\_pf1 = lhs(lhs\_vert, lhs\_horiz\_1);                   \(\backslash\)}
00142 \textcolor{preprocessor}{        lhs\_pf2 = lhs(lhs\_vert, lhs\_horiz\_2);                   \(\backslash\)}
00143 \textcolor{preprocessor}{        lhs\_pf3 = lhs(lhs\_vert, lhs\_horiz\_3);                   \(\backslash\)}
00144 \textcolor{preprocessor}{        lhs\_pf4 = lhs(lhs\_vert, lhs\_horiz\_4);                   \(\backslash\)}
00145 \textcolor{preprocessor}{        lhs\_pf5 = lhs(lhs\_vert, lhs\_horiz\_5);                   \(\backslash\)}
00146 \textcolor{preprocessor}{        lhs\_pf6 = lhs(lhs\_vert, lhs\_horiz\_6);                   \(\backslash\)}
00147 \textcolor{preprocessor}{      \} else if (lhs\_horiz\_5 < k\_size) \{                        \(\backslash\)}
00148 \textcolor{preprocessor}{        lhs\_pf0 = lhs(lhs\_vert, lhs\_horiz\_0);                   \(\backslash\)}
00149 \textcolor{preprocessor}{        lhs\_pf1 = lhs(lhs\_vert, lhs\_horiz\_1);                   \(\backslash\)}
00150 \textcolor{preprocessor}{        lhs\_pf2 = lhs(lhs\_vert, lhs\_horiz\_2);                   \(\backslash\)}
00151 \textcolor{preprocessor}{        lhs\_pf3 = lhs(lhs\_vert, lhs\_horiz\_3);                   \(\backslash\)}
00152 \textcolor{preprocessor}{        lhs\_pf4 = lhs(lhs\_vert, lhs\_horiz\_4);                   \(\backslash\)}
00153 \textcolor{preprocessor}{        lhs\_pf5 = lhs(lhs\_vert, lhs\_horiz\_5);                   \(\backslash\)}
00154 \textcolor{preprocessor}{      \} else if (lhs\_horiz\_4 < k\_size) \{                        \(\backslash\)}
00155 \textcolor{preprocessor}{        lhs\_pf0 = lhs(lhs\_vert, lhs\_horiz\_0);                   \(\backslash\)}
00156 \textcolor{preprocessor}{        lhs\_pf1 = lhs(lhs\_vert, lhs\_horiz\_1);                   \(\backslash\)}
00157 \textcolor{preprocessor}{        lhs\_pf2 = lhs(lhs\_vert, lhs\_horiz\_2);                   \(\backslash\)}
00158 \textcolor{preprocessor}{        lhs\_pf3 = lhs(lhs\_vert, lhs\_horiz\_3);                   \(\backslash\)}
00159 \textcolor{preprocessor}{        lhs\_pf4 = lhs(lhs\_vert, lhs\_horiz\_4);                   \(\backslash\)}
00160 \textcolor{preprocessor}{      \} else if (lhs\_horiz\_3 < k\_size) \{                        \(\backslash\)}
00161 \textcolor{preprocessor}{        lhs\_pf0 = lhs(lhs\_vert, lhs\_horiz\_0);                   \(\backslash\)}
00162 \textcolor{preprocessor}{        lhs\_pf1 = lhs(lhs\_vert, lhs\_horiz\_1);                   \(\backslash\)}
00163 \textcolor{preprocessor}{        lhs\_pf2 = lhs(lhs\_vert, lhs\_horiz\_2);                   \(\backslash\)}
00164 \textcolor{preprocessor}{        lhs\_pf3 = lhs(lhs\_vert, lhs\_horiz\_3);                   \(\backslash\)}
00165 \textcolor{preprocessor}{      \} else if (lhs\_horiz\_2 < k\_size) \{                        \(\backslash\)}
00166 \textcolor{preprocessor}{        lhs\_pf0 = lhs(lhs\_vert, lhs\_horiz\_0);                   \(\backslash\)}
00167 \textcolor{preprocessor}{        lhs\_pf1 = lhs(lhs\_vert, lhs\_horiz\_1);                   \(\backslash\)}
00168 \textcolor{preprocessor}{        lhs\_pf2 = lhs(lhs\_vert, lhs\_horiz\_2);                   \(\backslash\)}
00169 \textcolor{preprocessor}{      \} else if (lhs\_horiz\_1 < k\_size) \{                        \(\backslash\)}
00170 \textcolor{preprocessor}{        lhs\_pf0 = lhs(lhs\_vert, lhs\_horiz\_0);                   \(\backslash\)}
00171 \textcolor{preprocessor}{        lhs\_pf1 = lhs(lhs\_vert, lhs\_horiz\_1);                   \(\backslash\)}
00172 \textcolor{preprocessor}{      \} else if (lhs\_horiz\_0 < k\_size) \{                        \(\backslash\)}
00173 \textcolor{preprocessor}{        lhs\_pf0 = lhs(lhs\_vert, lhs\_horiz\_0);                   \(\backslash\)}
00174 \textcolor{preprocessor}{      \}                                                         \(\backslash\)}
00175 \textcolor{preprocessor}{    \}                                                           \(\backslash\)}
00176 \textcolor{preprocessor}{                                                                \(\backslash\)}
00177 \textcolor{preprocessor}{    const Index rhs\_vert = base\_k + load\_idx\_vert;              \(\backslash\)}
00178 \textcolor{preprocessor}{    if (!needs\_edge\_check || rhs\_vert < k\_size) \{               \(\backslash\)}
00179 \textcolor{preprocessor}{      const Index rhs\_horiz\_0 = base\_n + threadIdx.z + 0 * 8;   \(\backslash\)}
00180 \textcolor{preprocessor}{      const Index rhs\_horiz\_1 = base\_n + threadIdx.z + 1 * 8;   \(\backslash\)}
00181 \textcolor{preprocessor}{      const Index rhs\_horiz\_2 = base\_n + threadIdx.z + 2 * 8;   \(\backslash\)}
00182 \textcolor{preprocessor}{      const Index rhs\_horiz\_3 = base\_n + threadIdx.z + 3 * 8;   \(\backslash\)}
00183 \textcolor{preprocessor}{      const Index rhs\_horiz\_4 = base\_n + threadIdx.z + 4 * 8;   \(\backslash\)}
00184 \textcolor{preprocessor}{      const Index rhs\_horiz\_5 = base\_n + threadIdx.z + 5 * 8;   \(\backslash\)}
00185 \textcolor{preprocessor}{      const Index rhs\_horiz\_6 = base\_n + threadIdx.z + 6 * 8;   \(\backslash\)}
00186 \textcolor{preprocessor}{      const Index rhs\_horiz\_7 = base\_n + threadIdx.z + 7 * 8;   \(\backslash\)}
00187 \textcolor{preprocessor}{                                                                \(\backslash\)}
00188 \textcolor{preprocessor}{      if (rhs\_horiz\_7 < n\_size) \{                               \(\backslash\)}
00189 \textcolor{preprocessor}{        rhs\_pf0 = rhs(rhs\_vert, rhs\_horiz\_0);                   \(\backslash\)}
00190 \textcolor{preprocessor}{        rhs\_pf1 = rhs(rhs\_vert, rhs\_horiz\_1);                   \(\backslash\)}
00191 \textcolor{preprocessor}{        rhs\_pf2 = rhs(rhs\_vert, rhs\_horiz\_2);                   \(\backslash\)}
00192 \textcolor{preprocessor}{        rhs\_pf3 = rhs(rhs\_vert, rhs\_horiz\_3);                   \(\backslash\)}
00193 \textcolor{preprocessor}{        rhs\_pf4 = rhs(rhs\_vert, rhs\_horiz\_4);                   \(\backslash\)}
00194 \textcolor{preprocessor}{        rhs\_pf5 = rhs(rhs\_vert, rhs\_horiz\_5);                   \(\backslash\)}
00195 \textcolor{preprocessor}{        rhs\_pf6 = rhs(rhs\_vert, rhs\_horiz\_6);                   \(\backslash\)}
00196 \textcolor{preprocessor}{        rhs\_pf7 = rhs(rhs\_vert, rhs\_horiz\_7);                   \(\backslash\)}
00197 \textcolor{preprocessor}{      \} else if (rhs\_horiz\_6 < n\_size) \{                        \(\backslash\)}
00198 \textcolor{preprocessor}{        rhs\_pf0 = rhs(rhs\_vert, rhs\_horiz\_0);                   \(\backslash\)}
00199 \textcolor{preprocessor}{        rhs\_pf1 = rhs(rhs\_vert, rhs\_horiz\_1);                   \(\backslash\)}
00200 \textcolor{preprocessor}{        rhs\_pf2 = rhs(rhs\_vert, rhs\_horiz\_2);                   \(\backslash\)}
00201 \textcolor{preprocessor}{        rhs\_pf3 = rhs(rhs\_vert, rhs\_horiz\_3);                   \(\backslash\)}
00202 \textcolor{preprocessor}{        rhs\_pf4 = rhs(rhs\_vert, rhs\_horiz\_4);                   \(\backslash\)}
00203 \textcolor{preprocessor}{        rhs\_pf5 = rhs(rhs\_vert, rhs\_horiz\_5);                   \(\backslash\)}
00204 \textcolor{preprocessor}{        rhs\_pf6 = rhs(rhs\_vert, rhs\_horiz\_6);                   \(\backslash\)}
00205 \textcolor{preprocessor}{      \} else if (rhs\_horiz\_5 < n\_size) \{                        \(\backslash\)}
00206 \textcolor{preprocessor}{        rhs\_pf0 = rhs(rhs\_vert, rhs\_horiz\_0);                   \(\backslash\)}
00207 \textcolor{preprocessor}{        rhs\_pf1 = rhs(rhs\_vert, rhs\_horiz\_1);                   \(\backslash\)}
00208 \textcolor{preprocessor}{        rhs\_pf2 = rhs(rhs\_vert, rhs\_horiz\_2);                   \(\backslash\)}
00209 \textcolor{preprocessor}{        rhs\_pf3 = rhs(rhs\_vert, rhs\_horiz\_3);                   \(\backslash\)}
00210 \textcolor{preprocessor}{        rhs\_pf4 = rhs(rhs\_vert, rhs\_horiz\_4);                   \(\backslash\)}
00211 \textcolor{preprocessor}{        rhs\_pf5 = rhs(rhs\_vert, rhs\_horiz\_5);                   \(\backslash\)}
00212 \textcolor{preprocessor}{      \} else if (rhs\_horiz\_4 < n\_size) \{                        \(\backslash\)}
00213 \textcolor{preprocessor}{        rhs\_pf0 = rhs(rhs\_vert, rhs\_horiz\_0);                   \(\backslash\)}
00214 \textcolor{preprocessor}{        rhs\_pf1 = rhs(rhs\_vert, rhs\_horiz\_1);                   \(\backslash\)}
00215 \textcolor{preprocessor}{        rhs\_pf2 = rhs(rhs\_vert, rhs\_horiz\_2);                   \(\backslash\)}
00216 \textcolor{preprocessor}{        rhs\_pf3 = rhs(rhs\_vert, rhs\_horiz\_3);                   \(\backslash\)}
00217 \textcolor{preprocessor}{        rhs\_pf4 = rhs(rhs\_vert, rhs\_horiz\_4);                   \(\backslash\)}
00218 \textcolor{preprocessor}{      \} else if (rhs\_horiz\_3 < n\_size) \{                        \(\backslash\)}
00219 \textcolor{preprocessor}{        rhs\_pf0 = rhs(rhs\_vert, rhs\_horiz\_0);                   \(\backslash\)}
00220 \textcolor{preprocessor}{        rhs\_pf1 = rhs(rhs\_vert, rhs\_horiz\_1);                   \(\backslash\)}
00221 \textcolor{preprocessor}{        rhs\_pf2 = rhs(rhs\_vert, rhs\_horiz\_2);                   \(\backslash\)}
00222 \textcolor{preprocessor}{        rhs\_pf3 = rhs(rhs\_vert, rhs\_horiz\_3);                   \(\backslash\)}
00223 \textcolor{preprocessor}{      \} else if (rhs\_horiz\_2 < n\_size) \{                        \(\backslash\)}
00224 \textcolor{preprocessor}{        rhs\_pf0 = rhs(rhs\_vert, rhs\_horiz\_0);                   \(\backslash\)}
00225 \textcolor{preprocessor}{        rhs\_pf1 = rhs(rhs\_vert, rhs\_horiz\_1);                   \(\backslash\)}
00226 \textcolor{preprocessor}{        rhs\_pf2 = rhs(rhs\_vert, rhs\_horiz\_2);                   \(\backslash\)}
00227 \textcolor{preprocessor}{      \} else if (rhs\_horiz\_1 < n\_size) \{                        \(\backslash\)}
00228 \textcolor{preprocessor}{        rhs\_pf0 = rhs(rhs\_vert, rhs\_horiz\_0);                   \(\backslash\)}
00229 \textcolor{preprocessor}{        rhs\_pf1 = rhs(rhs\_vert, rhs\_horiz\_1);                   \(\backslash\)}
00230 \textcolor{preprocessor}{      \} else if (rhs\_horiz\_0 < n\_size) \{                        \(\backslash\)}
00231 \textcolor{preprocessor}{        rhs\_pf0 = rhs(rhs\_vert, rhs\_horiz\_0);                   \(\backslash\)}
00232 \textcolor{preprocessor}{      \}                                                         \(\backslash\)}
00233 \textcolor{preprocessor}{    \}                                                           \(\backslash\)}
00234 \textcolor{preprocessor}{  \}                                                             \(\backslash\)}
00235 \textcolor{preprocessor}{}
00236 \textcolor{preprocessor}{#define writeRegToShmem(\_)                      \(\backslash\)}
00237 \textcolor{preprocessor}{  lhs\_shmem[lhs\_store\_idx\_0] = lhs\_pf0;         \(\backslash\)}
00238 \textcolor{preprocessor}{  rhs\_shmem[rhs\_store\_idx\_0] = rhs\_pf0;         \(\backslash\)}
00239 \textcolor{preprocessor}{                                                \(\backslash\)}
00240 \textcolor{preprocessor}{  lhs\_shmem[lhs\_store\_idx\_1] = lhs\_pf1;         \(\backslash\)}
00241 \textcolor{preprocessor}{  rhs\_shmem[rhs\_store\_idx\_1] = rhs\_pf1;         \(\backslash\)}
00242 \textcolor{preprocessor}{                                                \(\backslash\)}
00243 \textcolor{preprocessor}{  lhs\_shmem[lhs\_store\_idx\_2] = lhs\_pf2;         \(\backslash\)}
00244 \textcolor{preprocessor}{  rhs\_shmem[rhs\_store\_idx\_2] = rhs\_pf2;         \(\backslash\)}
00245 \textcolor{preprocessor}{                                                \(\backslash\)}
00246 \textcolor{preprocessor}{  lhs\_shmem[lhs\_store\_idx\_3] = lhs\_pf3;         \(\backslash\)}
00247 \textcolor{preprocessor}{  rhs\_shmem[rhs\_store\_idx\_3] = rhs\_pf3;         \(\backslash\)}
00248 \textcolor{preprocessor}{                                                \(\backslash\)}
00249 \textcolor{preprocessor}{  lhs\_shmem[lhs\_store\_idx\_4] = lhs\_pf4;         \(\backslash\)}
00250 \textcolor{preprocessor}{  rhs\_shmem[rhs\_store\_idx\_4] = rhs\_pf4;         \(\backslash\)}
00251 \textcolor{preprocessor}{                                                \(\backslash\)}
00252 \textcolor{preprocessor}{  lhs\_shmem[lhs\_store\_idx\_5] = lhs\_pf5;         \(\backslash\)}
00253 \textcolor{preprocessor}{  rhs\_shmem[rhs\_store\_idx\_5] = rhs\_pf5;         \(\backslash\)}
00254 \textcolor{preprocessor}{                                                \(\backslash\)}
00255 \textcolor{preprocessor}{  lhs\_shmem[lhs\_store\_idx\_6] = lhs\_pf6;         \(\backslash\)}
00256 \textcolor{preprocessor}{  rhs\_shmem[rhs\_store\_idx\_6] = rhs\_pf6;         \(\backslash\)}
00257 \textcolor{preprocessor}{                                                \(\backslash\)}
00258 \textcolor{preprocessor}{  lhs\_shmem[lhs\_store\_idx\_7] = lhs\_pf7;         \(\backslash\)}
00259 \textcolor{preprocessor}{  rhs\_shmem[rhs\_store\_idx\_7] = rhs\_pf7;         \(\backslash\)}
00260 \textcolor{preprocessor}{}
00261   \textcolor{comment}{// declare and initialize result array}
00262 \textcolor{preprocessor}{#define res(i, j) \_res\_##i##j}
00263 \textcolor{preprocessor}{#define initResultRow(i)                        \(\backslash\)}
00264 \textcolor{preprocessor}{  Scalar res(i, 0) = conv(0);                   \(\backslash\)}
00265 \textcolor{preprocessor}{  Scalar res(i, 1) = conv(0);                   \(\backslash\)}
00266 \textcolor{preprocessor}{  Scalar res(i, 2) = conv(0);                   \(\backslash\)}
00267 \textcolor{preprocessor}{  Scalar res(i, 3) = conv(0);                   \(\backslash\)}
00268 \textcolor{preprocessor}{  Scalar res(i, 4) = conv(0);                   \(\backslash\)}
00269 \textcolor{preprocessor}{  Scalar res(i, 5) = conv(0);                   \(\backslash\)}
00270 \textcolor{preprocessor}{  Scalar res(i, 6) = conv(0);                   \(\backslash\)}
00271 \textcolor{preprocessor}{  Scalar res(i, 7) = conv(0);                   \(\backslash\)}
00272 \textcolor{preprocessor}{}
00273   internal::scalar\_cast\_op<int, Scalar> conv;
00274   initResultRow(0);
00275   initResultRow(1);
00276   initResultRow(2);
00277   initResultRow(3);
00278   initResultRow(4);
00279   initResultRow(5);
00280   initResultRow(6);
00281   initResultRow(7);
00282 \textcolor{preprocessor}{#undef initResultRow}
00283 
00284   \textcolor{keywordflow}{for} (Index base\_k = 0; base\_k < k\_size; base\_k += 64) \{
00285     \textcolor{comment}{// wait for previous iteration to finish with shmem. Despite common sense,}
00286     \textcolor{comment}{// the code is a bit faster with this here then at bottom of loop}
00287     \_\_syncthreads();
00288 
00289     prefetchIntoRegisters(base\_k);
00290     writeRegToShmem();
00291 
00292 \textcolor{preprocessor}{    #undef prefetchIntoRegisters}
00293 \textcolor{preprocessor}{    #undef writeRegToShmem}
00294 
00295     \textcolor{comment}{// wait for shared mem packing to be done before starting computation}
00296     \_\_syncthreads();
00297 
00298     \textcolor{comment}{// compute 8x8 matrix product by outer product. This involves packing one column}
00299     \textcolor{comment}{// of LHS and one row of RHS into registers (takes 16 registers).}
00300 
00301 \textcolor{preprocessor}{#define lcol(i) \_lcol##i}
00302     Scalar lcol(0);
00303     Scalar lcol(1);
00304     Scalar lcol(2);
00305     Scalar lcol(3);
00306     Scalar lcol(4);
00307     Scalar lcol(5);
00308     Scalar lcol(6);
00309     Scalar lcol(7);
00310 
00311 \textcolor{preprocessor}{#define rrow(j) \_rrow##j}
00312     Scalar rrow(0);
00313     Scalar rrow(1);
00314     Scalar rrow(2);
00315     Scalar rrow(3);
00316     Scalar rrow(4);
00317     Scalar rrow(5);
00318     Scalar rrow(6);
00319     Scalar rrow(7);
00320 
00321     \textcolor{comment}{// Now x corresponds to k, y to m, and z to n}
00322     \textcolor{keyword}{const} Scalar* lhs\_block = &lhs\_shmem[threadIdx.x + 9 * threadIdx.y];
00323     \textcolor{keyword}{const} Scalar* rhs\_block = &rhs\_shmem[threadIdx.x + 8 * threadIdx.z];
00324 
00325 \textcolor{preprocessor}{#define lhs\_element(i, j) lhs\_block[72 * ((i) + 8 * (j))]}
00326 \textcolor{preprocessor}{#define rhs\_element(i, j) rhs\_block[72 * ((i) + 8 * (j))]}
00327 
00328 \textcolor{preprocessor}{#define loadData(i, j)                          \(\backslash\)}
00329 \textcolor{preprocessor}{    lcol(0) = lhs\_element(0, j);               \(\backslash\)}
00330 \textcolor{preprocessor}{    rrow(0) = rhs\_element(i, 0);               \(\backslash\)}
00331 \textcolor{preprocessor}{    lcol(1) = lhs\_element(1, j);               \(\backslash\)}
00332 \textcolor{preprocessor}{    rrow(1) = rhs\_element(i, 1);               \(\backslash\)}
00333 \textcolor{preprocessor}{    lcol(2) = lhs\_element(2, j);               \(\backslash\)}
00334 \textcolor{preprocessor}{    rrow(2) = rhs\_element(i, 2);               \(\backslash\)}
00335 \textcolor{preprocessor}{    lcol(3) = lhs\_element(3, j);               \(\backslash\)}
00336 \textcolor{preprocessor}{    rrow(3) = rhs\_element(i, 3);               \(\backslash\)}
00337 \textcolor{preprocessor}{    lcol(4) = lhs\_element(4, j);               \(\backslash\)}
00338 \textcolor{preprocessor}{    rrow(4) = rhs\_element(i, 4);               \(\backslash\)}
00339 \textcolor{preprocessor}{    lcol(5) = lhs\_element(5, j);               \(\backslash\)}
00340 \textcolor{preprocessor}{    rrow(5) = rhs\_element(i, 5);               \(\backslash\)}
00341 \textcolor{preprocessor}{    lcol(6) = lhs\_element(6, j);               \(\backslash\)}
00342 \textcolor{preprocessor}{    rrow(6) = rhs\_element(i, 6);               \(\backslash\)}
00343 \textcolor{preprocessor}{    lcol(7) = lhs\_element(7, j);               \(\backslash\)}
00344 \textcolor{preprocessor}{    rrow(7) = rhs\_element(i, 7);               \(\backslash\)}
00345 \textcolor{preprocessor}{}
00346 \textcolor{preprocessor}{#define computeCol(j)                           \(\backslash\)}
00347 \textcolor{preprocessor}{    res(0, j) += lcol(0) * rrow(j);             \(\backslash\)}
00348 \textcolor{preprocessor}{    res(1, j) += lcol(1) * rrow(j);             \(\backslash\)}
00349 \textcolor{preprocessor}{    res(2, j) += lcol(2) * rrow(j);             \(\backslash\)}
00350 \textcolor{preprocessor}{    res(3, j) += lcol(3) * rrow(j);             \(\backslash\)}
00351 \textcolor{preprocessor}{    res(4, j) += lcol(4) * rrow(j);             \(\backslash\)}
00352 \textcolor{preprocessor}{    res(5, j) += lcol(5) * rrow(j);             \(\backslash\)}
00353 \textcolor{preprocessor}{    res(6, j) += lcol(6) * rrow(j);             \(\backslash\)}
00354 \textcolor{preprocessor}{    res(7, j) += lcol(7) * rrow(j);             \(\backslash\)}
00355 \textcolor{preprocessor}{}
00356 \textcolor{preprocessor}{#define computePass(i)                          \(\backslash\)}
00357 \textcolor{preprocessor}{    loadData(i, i);                             \(\backslash\)}
00358 \textcolor{preprocessor}{                                                \(\backslash\)}
00359 \textcolor{preprocessor}{    computeCol(0);                              \(\backslash\)}
00360 \textcolor{preprocessor}{    computeCol(1);                              \(\backslash\)}
00361 \textcolor{preprocessor}{    computeCol(2);                              \(\backslash\)}
00362 \textcolor{preprocessor}{    computeCol(3);                              \(\backslash\)}
00363 \textcolor{preprocessor}{    computeCol(4);                              \(\backslash\)}
00364 \textcolor{preprocessor}{    computeCol(5);                              \(\backslash\)}
00365 \textcolor{preprocessor}{    computeCol(6);                              \(\backslash\)}
00366 \textcolor{preprocessor}{    computeCol(7);                              \(\backslash\)}
00367 \textcolor{preprocessor}{}
00368     computePass(0);
00369     computePass(1);
00370     computePass(2);
00371     computePass(3);
00372     computePass(4);
00373     computePass(5);
00374     computePass(6);
00375     computePass(7);
00376 
00377 \textcolor{preprocessor}{#undef lcol}
00378 \textcolor{preprocessor}{#undef rrow}
00379 \textcolor{preprocessor}{#undef lhs\_element}
00380 \textcolor{preprocessor}{#undef rhs\_element}
00381 \textcolor{preprocessor}{#undef loadData}
00382 \textcolor{preprocessor}{#undef computeCol}
00383 \textcolor{preprocessor}{#undef computePass}
00384   \} \textcolor{comment}{// end loop over k}
00385 
00386   \textcolor{comment}{// we've now iterated over all of the large (ie width 64) k blocks and}
00387   \textcolor{comment}{// accumulated results in registers. At this point thread (x, y, z) contains}
00388   \textcolor{comment}{// the sum across all big k blocks of the product of little k block of index (x, y)}
00389   \textcolor{comment}{// with block of index (y, z). To compute the final output, we need to reduce}
00390   \textcolor{comment}{// the 8 threads over y by summation.}
00391 \textcolor{preprocessor}{#define shuffleInc(i, j, mask) res(i, j) += \_\_shfl\_xor(res(i, j), mask)}
00392 
00393 \textcolor{preprocessor}{#define reduceRow(i, mask)                      \(\backslash\)}
00394 \textcolor{preprocessor}{  shuffleInc(i, 0, mask);                       \(\backslash\)}
00395 \textcolor{preprocessor}{  shuffleInc(i, 1, mask);                       \(\backslash\)}
00396 \textcolor{preprocessor}{  shuffleInc(i, 2, mask);                       \(\backslash\)}
00397 \textcolor{preprocessor}{  shuffleInc(i, 3, mask);                       \(\backslash\)}
00398 \textcolor{preprocessor}{  shuffleInc(i, 4, mask);                       \(\backslash\)}
00399 \textcolor{preprocessor}{  shuffleInc(i, 5, mask);                       \(\backslash\)}
00400 \textcolor{preprocessor}{  shuffleInc(i, 6, mask);                       \(\backslash\)}
00401 \textcolor{preprocessor}{  shuffleInc(i, 7, mask);                       \(\backslash\)}
00402 \textcolor{preprocessor}{}
00403 \textcolor{preprocessor}{#define reduceMatrix(mask)                      \(\backslash\)}
00404 \textcolor{preprocessor}{  reduceRow(0, mask);                           \(\backslash\)}
00405 \textcolor{preprocessor}{  reduceRow(1, mask);                           \(\backslash\)}
00406 \textcolor{preprocessor}{  reduceRow(2, mask);                           \(\backslash\)}
00407 \textcolor{preprocessor}{  reduceRow(3, mask);                           \(\backslash\)}
00408 \textcolor{preprocessor}{  reduceRow(4, mask);                           \(\backslash\)}
00409 \textcolor{preprocessor}{  reduceRow(5, mask);                           \(\backslash\)}
00410 \textcolor{preprocessor}{  reduceRow(6, mask);                           \(\backslash\)}
00411 \textcolor{preprocessor}{  reduceRow(7, mask);                           \(\backslash\)}
00412 \textcolor{preprocessor}{}
00413   \textcolor{comment}{// actually perform the reduction, now each thread of index (\_, y, z)}
00414   \textcolor{comment}{// contains the correct values in its registers that belong in the output}
00415   \textcolor{comment}{// block}
00416   reduceMatrix(1);
00417   reduceMatrix(2);
00418   reduceMatrix(4);
00419 
00420 \textcolor{preprocessor}{#undef shuffleInc}
00421 \textcolor{preprocessor}{#undef reduceRow}
00422 \textcolor{preprocessor}{#undef reduceMatrix}
00423 
00424   \textcolor{comment}{// now we need to copy the 64 values into main memory. We can't split work}
00425   \textcolor{comment}{// among threads because all variables are in registers. There's 2 ways}
00426   \textcolor{comment}{// to do this:}
00427   \textcolor{comment}{// (1) have 1 thread do 64 writes from registers into global memory}
00428   \textcolor{comment}{// (2) have 1 thread do 64 writes into shared memory, and then 8 threads}
00429   \textcolor{comment}{//     each do 8 writes into global memory. We can just overwrite the shared}
00430   \textcolor{comment}{//     memory from the problem we just solved.}
00431   \textcolor{comment}{// (2) is slightly faster than (1) due to less branching and more ILP}
00432 
00433   \textcolor{comment}{// TODO: won't yield much gain, but could just use currently unused shared mem}
00434   \textcolor{comment}{//       and then we won't have to sync}
00435   \textcolor{comment}{// wait for shared mem to be out of use}
00436   \_\_syncthreads();
00437 
00438 \textcolor{preprocessor}{#define writeResultShmem(i, j)                                          \(\backslash\)}
00439 \textcolor{preprocessor}{  lhs\_shmem[i + 8 * threadIdx.y + 64 * threadIdx.z + 512 * j] = res(i, j); \(\backslash\)}
00440 \textcolor{preprocessor}{}
00441 \textcolor{preprocessor}{#define writeRow(i)                             \(\backslash\)}
00442 \textcolor{preprocessor}{  writeResultShmem(i, 0);                       \(\backslash\)}
00443 \textcolor{preprocessor}{  writeResultShmem(i, 1);                       \(\backslash\)}
00444 \textcolor{preprocessor}{  writeResultShmem(i, 2);                       \(\backslash\)}
00445 \textcolor{preprocessor}{  writeResultShmem(i, 3);                       \(\backslash\)}
00446 \textcolor{preprocessor}{  writeResultShmem(i, 4);                       \(\backslash\)}
00447 \textcolor{preprocessor}{  writeResultShmem(i, 5);                       \(\backslash\)}
00448 \textcolor{preprocessor}{  writeResultShmem(i, 6);                       \(\backslash\)}
00449 \textcolor{preprocessor}{  writeResultShmem(i, 7);                       \(\backslash\)}
00450 \textcolor{preprocessor}{}
00451   \textcolor{keywordflow}{if} (threadIdx.x == 0) \{
00452     writeRow(0);
00453     writeRow(1);
00454     writeRow(2);
00455     writeRow(3);
00456     writeRow(4);
00457     writeRow(5);
00458     writeRow(6);
00459     writeRow(7);
00460   \}
00461 \textcolor{preprocessor}{#undef writeResultShmem}
00462 \textcolor{preprocessor}{#undef writeRow}
00463 
00464   \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_i\_write = numext::mini((\textcolor{keywordtype}{int})((m\_size - base\_m - threadIdx.y + 7) / 8), 8);
00465   \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_j\_write = numext::mini((\textcolor{keywordtype}{int})((n\_size - base\_n - threadIdx.z + 7) / 8), 8);
00466 
00467   \textcolor{keywordflow}{if} (threadIdx.x < max\_i\_write) \{
00468     \textcolor{keywordflow}{if} (max\_j\_write == 8) \{
00469       \textcolor{comment}{// TODO: can i trade bank conflicts for coalesced writes?}
00470       Scalar val0 = lhs\_shmem[threadIdx.x + 8 * threadIdx.y + 64 * threadIdx.z + 512 * 0];
00471       Scalar val1 = lhs\_shmem[threadIdx.x + 8 * threadIdx.y + 64 * threadIdx.z + 512 * 1];
00472       Scalar val2 = lhs\_shmem[threadIdx.x + 8 * threadIdx.y + 64 * threadIdx.z + 512 * 2];
00473       Scalar val3 = lhs\_shmem[threadIdx.x + 8 * threadIdx.y + 64 * threadIdx.z + 512 * 3];
00474       Scalar val4 = lhs\_shmem[threadIdx.x + 8 * threadIdx.y + 64 * threadIdx.z + 512 * 4];
00475       Scalar val5 = lhs\_shmem[threadIdx.x + 8 * threadIdx.y + 64 * threadIdx.z + 512 * 5];
00476       Scalar val6 = lhs\_shmem[threadIdx.x + 8 * threadIdx.y + 64 * threadIdx.z + 512 * 6];
00477       Scalar val7 = lhs\_shmem[threadIdx.x + 8 * threadIdx.y + 64 * threadIdx.z + 512 * 7];
00478 
00479       output(base\_m + threadIdx.y + 8 * threadIdx.x, base\_n + threadIdx.z + 8 * 0) = val0;
00480       output(base\_m + threadIdx.y + 8 * threadIdx.x, base\_n + threadIdx.z + 8 * 1) = val1;
00481       output(base\_m + threadIdx.y + 8 * threadIdx.x, base\_n + threadIdx.z + 8 * 2) = val2;
00482       output(base\_m + threadIdx.y + 8 * threadIdx.x, base\_n + threadIdx.z + 8 * 3) = val3;
00483       output(base\_m + threadIdx.y + 8 * threadIdx.x, base\_n + threadIdx.z + 8 * 4) = val4;
00484       output(base\_m + threadIdx.y + 8 * threadIdx.x, base\_n + threadIdx.z + 8 * 5) = val5;
00485       output(base\_m + threadIdx.y + 8 * threadIdx.x, base\_n + threadIdx.z + 8 * 6) = val6;
00486       output(base\_m + threadIdx.y + 8 * threadIdx.x, base\_n + threadIdx.z + 8 * 7) = val7;
00487     \} \textcolor{keywordflow}{else} \{
00488 \textcolor{preprocessor}{#pragma unroll 7}
00489       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < max\_j\_write; j++) \{
00490         Scalar val = lhs\_shmem[threadIdx.x + 8 * threadIdx.y + 64 * threadIdx.z + 512 * j];
00491         output(base\_m + threadIdx.y + 8 * threadIdx.x, base\_n + threadIdx.z + 8 * j) = val;
00492       \}
00493     \}
00494   \}
00495 \textcolor{preprocessor}{#undef res}
00496 \}
00497 
00498 
00499 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keyword}{typename} LhsMapper,
00500          \textcolor{keyword}{typename} RhsMapper, \textcolor{keyword}{typename} OutputMapper>
00501 \_\_global\_\_ \textcolor{keywordtype}{void}
00502 \_\_launch\_bounds\_\_(512)
00503 EigenContractionKernel(const LhsMapper lhs, const RhsMapper rhs,
00504                        const OutputMapper output,
00505                        const Index m\_size, const Index n\_size, const Index k\_size) \{
00506   \_\_shared\_\_ Scalar lhs\_shmem[72 * 64];
00507   \_\_shared\_\_ Scalar rhs\_shmem[72 * 64];
00508 
00509   \textcolor{keyword}{const} Index m\_block\_idx = blockIdx.x;
00510   \textcolor{keyword}{const} Index n\_block\_idx = blockIdx.y;
00511 
00512   \textcolor{keyword}{const} Index base\_m = 64 * m\_block\_idx;
00513   \textcolor{keyword}{const} Index base\_n = 64 * n\_block\_idx;
00514 
00515   \textcolor{keywordflow}{if} (base\_m + 63 < m\_size && base\_n + 63 < n\_size) \{
00516     EigenContractionKernelInternal<Scalar, Index, LhsMapper, RhsMapper, OutputMapper, false>(lhs, rhs, 
      output, lhs\_shmem, rhs\_shmem, m\_size, n\_size, k\_size);
00517   \} \textcolor{keywordflow}{else} \{
00518     EigenContractionKernelInternal<Scalar, Index, LhsMapper, RhsMapper, OutputMapper, true>(lhs, rhs, 
      output, lhs\_shmem, rhs\_shmem, m\_size, n\_size, k\_size);
00519   \}
00520 \}
00521 
00522 
00523 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keyword}{typename} LhsMapper,
00524          \textcolor{keyword}{typename} RhsMapper, \textcolor{keyword}{typename} OutputMapper, \textcolor{keywordtype}{bool} CHECK\_LHS\_BOUNDARY,
00525          \textcolor{keywordtype}{bool} CHECK\_RHS\_BOUNDARY>
00526 \_\_device\_\_ EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00527 EigenFloatContractionKernelInternal16x16(\textcolor{keyword}{const} LhsMapper lhs, \textcolor{keyword}{const} RhsMapper rhs,
00528                        \textcolor{keyword}{const} OutputMapper output, float2 lhs\_shmem2[][16],
00529                        float2 rhs\_shmem2[][8], \textcolor{keyword}{const} Index m\_size,
00530                        \textcolor{keyword}{const} Index n\_size, \textcolor{keyword}{const} Index k\_size,
00531                        \textcolor{keyword}{const} Index base\_m, \textcolor{keyword}{const} Index base\_n) \{
00532   \textcolor{keyword}{typedef} \textcolor{keywordtype}{float} Scalar;
00533 
00534   \textcolor{comment}{// prefetch registers}
00535   float4 lhs\_pf0, rhs\_pf0;
00536 
00537   float4 results[4];
00538   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < 4; i++) \{
00539     results[i].x = results[i].y = results[i].z = results[i].w = 0;
00540   \}
00541 
00542 
00543 \textcolor{preprocessor}{#define prefetch\_lhs(reg, row, col)                   \(\backslash\)}
00544 \textcolor{preprocessor}{    if (!CHECK\_LHS\_BOUNDARY) \{                        \(\backslash\)}
00545 \textcolor{preprocessor}{      if (col < k\_size) \{                             \(\backslash\)}
00546 \textcolor{preprocessor}{        reg =lhs.loadPacket<Unaligned>(row, col);     \(\backslash\)}
00547 \textcolor{preprocessor}{      \}                                               \(\backslash\)}
00548 \textcolor{preprocessor}{    \} else \{                                          \(\backslash\)}
00549 \textcolor{preprocessor}{      if (col < k\_size) \{                             \(\backslash\)}
00550 \textcolor{preprocessor}{        if (row + 3 < m\_size) \{                       \(\backslash\)}
00551 \textcolor{preprocessor}{          reg =lhs.loadPacket<Unaligned>(row, col);   \(\backslash\)}
00552 \textcolor{preprocessor}{        \} else if (row + 2 < m\_size) \{                \(\backslash\)}
00553 \textcolor{preprocessor}{          reg.x =lhs(row + 0, col);                   \(\backslash\)}
00554 \textcolor{preprocessor}{          reg.y =lhs(row + 1, col);                   \(\backslash\)}
00555 \textcolor{preprocessor}{          reg.z =lhs(row + 2, col);                   \(\backslash\)}
00556 \textcolor{preprocessor}{        \} else if (row + 1 < m\_size) \{                \(\backslash\)}
00557 \textcolor{preprocessor}{          reg.x =lhs(row + 0, col);                   \(\backslash\)}
00558 \textcolor{preprocessor}{          reg.y =lhs(row + 1, col);                   \(\backslash\)}
00559 \textcolor{preprocessor}{        \} else if (row  < m\_size) \{                   \(\backslash\)}
00560 \textcolor{preprocessor}{          reg.x =lhs(row + 0, col);                   \(\backslash\)}
00561 \textcolor{preprocessor}{        \}                                             \(\backslash\)}
00562 \textcolor{preprocessor}{      \}                                               \(\backslash\)}
00563 \textcolor{preprocessor}{    \}                                                 \(\backslash\)}
00564 \textcolor{preprocessor}{}
00565 
00566   Index lhs\_vert = base\_m+threadIdx.x*4;
00567 
00568   \textcolor{keywordflow}{for} (Index k = 0; k < k\_size; k += 16) \{
00569     lhs\_pf0 = internal::pset1<float4>(0);
00570     rhs\_pf0 = internal::pset1<float4>(0);
00571 
00572     Index lhs\_horiz = threadIdx.y+k;
00573     prefetch\_lhs(lhs\_pf0, lhs\_vert, lhs\_horiz)
00574 
00575     Index rhs\_vert = k+(threadIdx.x%4)*4;
00576     Index rhs\_horiz0 = (threadIdx.x>>2)+threadIdx.y*4+base\_n;
00577 
00578     if (!CHECK\_RHS\_BOUNDARY) \{
00579       \textcolor{keywordflow}{if} ((rhs\_vert + 3) < k\_size) \{
00580         \textcolor{comment}{// just CHECK\_RHS\_BOUNDARY}
00581         rhs\_pf0 = rhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(rhs\_vert, rhs\_horiz0);
00582       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rhs\_vert + 2 < k\_size) \{
00583         \textcolor{comment}{// just CHECK\_RHS\_BOUNDARY}
00584         rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00585         rhs\_pf0.y = rhs(rhs\_vert + 1, rhs\_horiz0);
00586         rhs\_pf0.z = rhs(rhs\_vert + 2, rhs\_horiz0);
00587       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rhs\_vert + 1 < k\_size) \{
00588         rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00589         rhs\_pf0.y = rhs(rhs\_vert + 1, rhs\_horiz0);
00590       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rhs\_vert  < k\_size) \{
00591         rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00592       \}
00593     \} \textcolor{keywordflow}{else} \{
00594       \textcolor{keywordflow}{if} (rhs\_horiz0 < n\_size) \{
00595         \textcolor{keywordflow}{if} ((rhs\_vert + 3) < k\_size) \{
00596           rhs\_pf0 = rhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(rhs\_vert, rhs\_horiz0);
00597         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((rhs\_vert + 2) < k\_size) \{
00598           rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00599           rhs\_pf0.y = rhs(rhs\_vert + 1, rhs\_horiz0);
00600           rhs\_pf0.z = rhs(rhs\_vert + 2, rhs\_horiz0);
00601         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((rhs\_vert + 1) < k\_size) \{
00602           rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00603           rhs\_pf0.y = rhs(rhs\_vert + 1, rhs\_horiz0);
00604         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rhs\_vert  < k\_size) \{
00605           rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00606         \}
00607       \}
00608     \}
00609     \textcolor{keywordtype}{float} x1, x2 ;
00610     \textcolor{comment}{// the following can be a bitwise operation..... some day.}
00611     \textcolor{keywordflow}{if}((threadIdx.x%8) < 4) \{
00612       x1 = rhs\_pf0.y;
00613       x2 = rhs\_pf0.w;
00614     \} \textcolor{keywordflow}{else} \{
00615       x1 = rhs\_pf0.x;
00616       x2 = rhs\_pf0.z;
00617     \}
00618     x1 = \_\_shfl\_xor(x1, 4);
00619     x2 = \_\_shfl\_xor(x2, 4);
00620     \textcolor{keywordflow}{if}((threadIdx.x%8) < 4) \{
00621       rhs\_pf0.y = x1;
00622       rhs\_pf0.w = x2;
00623     \} \textcolor{keywordflow}{else} \{
00624       rhs\_pf0.x = x1;
00625       rhs\_pf0.z = x2;
00626     \}
00627 
00628     \textcolor{comment}{// We have 64 features.}
00629     \textcolor{comment}{// Row 0 -> times (0, 4, 8, 12, 1, 5, 9, 13) for features 0, 1.}
00630     \textcolor{comment}{// Row 1 -> times (0, 4, 8, 12, 1, 5, 9, 13) for features 2, 3.}
00631     \textcolor{comment}{// ...}
00632     \textcolor{comment}{// Row 31 -> times (0, 4, 8, 12, 1, 5, 9, 13) for features 62, 63}
00633     \textcolor{comment}{// Row 32 -> times (2, 6, 10, 14, 3, 7, 11, 15) for features 0, 1}
00634     \textcolor{comment}{// ...}
00635     rhs\_shmem2[(threadIdx.x>>3)+ threadIdx.y*2][threadIdx.x%8] = make\_float2(rhs\_pf0.x, rhs\_pf0.y);
00636     rhs\_shmem2[(threadIdx.x>>3)+ threadIdx.y*2+32][threadIdx.x%8] = make\_float2(rhs\_pf0.z, rhs\_pf0.w);
00637 
00638     \textcolor{comment}{// Row 0 (time 0) -> features (0, 1), (4, 5), .. (28, 29), (32, 33), ..  (60, 61)}
00639     \textcolor{comment}{// Row 1 (time 1) -> features (0, 1), (4, 5), .. (28, 29), (32, 33), ..  (60, 61)}
00640     \textcolor{comment}{// ...}
00641     \textcolor{comment}{// Row 15 (time 15) -> features (0, 1), (4, 5), .. (28, 29), (32, 33), ..  (60, 61)}
00642     \textcolor{comment}{// Row 16 (time 0) -> features (2, 3), (6, 7), .. (30, 31), (34, 35), ..  (62, 63)}
00643     \textcolor{comment}{// ...}
00644 
00645     lhs\_shmem2[threadIdx.y][threadIdx.x] = make\_float2(lhs\_pf0.x, lhs\_pf0.y);
00646     lhs\_shmem2[threadIdx.y+16][threadIdx.x] = make\_float2(lhs\_pf0.z, lhs\_pf0.w);
00647 
00648 
00649 \textcolor{preprocessor}{#define add\_vals(fl1, fl2, fr1, fr2)\(\backslash\)}
00650 \textcolor{preprocessor}{    results[0].x += fl1.x * fr1.x;\(\backslash\)}
00651 \textcolor{preprocessor}{    results[0].y += fl1.y * fr1.x;\(\backslash\)}
00652 \textcolor{preprocessor}{    results[0].z += fl2.x * fr1.x;\(\backslash\)}
00653 \textcolor{preprocessor}{    results[0].w += fl2.y * fr1.x;\(\backslash\)}
00654 \textcolor{preprocessor}{\(\backslash\)}
00655 \textcolor{preprocessor}{    results[1].x += fl1.x * fr1.y;\(\backslash\)}
00656 \textcolor{preprocessor}{    results[1].y += fl1.y * fr1.y;\(\backslash\)}
00657 \textcolor{preprocessor}{    results[1].z += fl2.x * fr1.y;\(\backslash\)}
00658 \textcolor{preprocessor}{    results[1].w += fl2.y * fr1.y;\(\backslash\)}
00659 \textcolor{preprocessor}{\(\backslash\)}
00660 \textcolor{preprocessor}{    results[2].x += fl1.x * fr2.x;\(\backslash\)}
00661 \textcolor{preprocessor}{    results[2].y += fl1.y * fr2.x;\(\backslash\)}
00662 \textcolor{preprocessor}{    results[2].z += fl2.x * fr2.x;\(\backslash\)}
00663 \textcolor{preprocessor}{    results[2].w += fl2.y * fr2.x;\(\backslash\)}
00664 \textcolor{preprocessor}{\(\backslash\)}
00665 \textcolor{preprocessor}{    results[3].x += fl1.x * fr2.y;\(\backslash\)}
00666 \textcolor{preprocessor}{    results[3].y += fl1.y * fr2.y;\(\backslash\)}
00667 \textcolor{preprocessor}{    results[3].z += fl2.x * fr2.y;\(\backslash\)}
00668 \textcolor{preprocessor}{    results[3].w += fl2.y * fr2.y;\(\backslash\)}
00669 \textcolor{preprocessor}{}
00670     \_\_syncthreads();
00671 
00672     \textcolor{comment}{// Do the multiplies.}
00673 \textcolor{preprocessor}{    #pragma unroll}
00674     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} koff = 0; koff < 16; koff ++) \{
00675       \textcolor{comment}{// 32 x threads.}
00676       float2 fl1 = lhs\_shmem2[koff][threadIdx.x];
00677       float2 fl2 = lhs\_shmem2[koff + 16][threadIdx.x];
00678 
00679       \textcolor{keywordtype}{int} start\_feature = threadIdx.y * 4;
00680       float2 fr1 = rhs\_shmem2[(start\_feature>>1) + 32*((koff%4)/2)][koff/4 + (koff%2)*4];
00681       float2 fr2 = rhs\_shmem2[(start\_feature>>1) + 1 + 32*((koff%4)/2)][koff/4 + (koff%2)*4];
00682 
00683       add\_vals(fl1, fl2, fr1, fr2)
00684     \}
00685     \_\_syncthreads();
00686   \}
00687 
00688 \textcolor{preprocessor}{#undef prefetch\_lhs}
00689 \textcolor{preprocessor}{#undef add\_vals}
00690 
00691   Index horiz\_base = threadIdx.y*4+base\_n;
00692   \textcolor{keywordflow}{if} (!CHECK\_LHS\_BOUNDARY && !CHECK\_RHS\_BOUNDARY) \{
00693     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; i++) \{
00694       output(lhs\_vert, horiz\_base + i) = results[i].x;
00695       output(lhs\_vert + 1, horiz\_base + i) = results[i].y;
00696       output(lhs\_vert + 2, horiz\_base + i) = results[i].z;
00697       output(lhs\_vert + 3, horiz\_base + i) = results[i].w;
00698     \}
00699   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!CHECK\_RHS\_BOUNDARY) \{
00700     \textcolor{comment}{// CHECK LHS}
00701     \textcolor{keywordflow}{if} (lhs\_vert + 3 < m\_size) \{
00702       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; i++) \{
00703         output(lhs\_vert, horiz\_base + i) = results[i].x;
00704         output(lhs\_vert + 1, horiz\_base + i) = results[i].y;
00705         output(lhs\_vert + 2, horiz\_base + i) = results[i].z;
00706         output(lhs\_vert + 3, horiz\_base + i) = results[i].w;
00707       \}
00708     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lhs\_vert + 2 < m\_size) \{
00709       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; i++) \{
00710         output(lhs\_vert, horiz\_base + i) = results[i].x;
00711         output(lhs\_vert + 1, horiz\_base + i) = results[i].y;
00712         output(lhs\_vert + 2, horiz\_base + i) = results[i].z;
00713       \}
00714     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lhs\_vert + 1 < m\_size) \{
00715       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; i++) \{
00716         output(lhs\_vert, horiz\_base + i) = results[i].x;
00717         output(lhs\_vert + 1, horiz\_base + i) = results[i].y;
00718       \}
00719     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lhs\_vert  < m\_size) \{
00720       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; i++) \{
00721         output(lhs\_vert, horiz\_base + i) = results[i].x;
00722       \}
00723     \}
00724   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!CHECK\_LHS\_BOUNDARY) \{
00725     \textcolor{comment}{// CHECK RHS}
00726     \textcolor{comment}{/*}
00727 \textcolor{comment}{    int ncols\_rem = fminf(n\_size- horiz\_base, 4);}
00728 \textcolor{comment}{    for (int i = 0; i < ncols\_rem; i++) \{}
00729 \textcolor{comment}{      output(lhs\_vert, horiz\_base + i) = results[i].x;}
00730 \textcolor{comment}{      output(lhs\_vert + 1, horiz\_base + i) = results[i].y;}
00731 \textcolor{comment}{      output(lhs\_vert + 2, horiz\_base + i) = results[i].z;}
00732 \textcolor{comment}{      output(lhs\_vert + 3, horiz\_base + i) = results[i].w;}
00733 \textcolor{comment}{    \}*/}
00734     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; i++) \{
00735       \textcolor{keywordflow}{if} (horiz\_base+i < n\_size) \{
00736         output(lhs\_vert, horiz\_base + i) = results[i].x;
00737         output(lhs\_vert + 1, horiz\_base + i) = results[i].y;
00738         output(lhs\_vert + 2, horiz\_base + i) = results[i].z;
00739         output(lhs\_vert + 3, horiz\_base + i) = results[i].w;
00740        \}
00741     \}
00742   \} \textcolor{keywordflow}{else} \{
00743     \textcolor{comment}{// CHECK both boundaries.}
00744     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; i++) \{
00745       \textcolor{keywordflow}{if} (horiz\_base+i < n\_size) \{
00746         \textcolor{keywordflow}{if} (lhs\_vert < m\_size)
00747           output(lhs\_vert, horiz\_base + i) = results[i].x;
00748         \textcolor{keywordflow}{if} (lhs\_vert + 1 < m\_size)
00749           output(lhs\_vert + 1, horiz\_base + i) = results[i].y;
00750         \textcolor{keywordflow}{if} (lhs\_vert + 2 < m\_size)
00751           output(lhs\_vert + 2, horiz\_base + i) = results[i].z;
00752         \textcolor{keywordflow}{if} (lhs\_vert + 3 < m\_size)
00753           output(lhs\_vert + 3, horiz\_base + i) = results[i].w;
00754       \}
00755     \}
00756   \}
00757 \}
00758 
00759 
00760 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keyword}{typename} LhsMapper,
00761          \textcolor{keyword}{typename} RhsMapper, \textcolor{keyword}{typename} OutputMapper, \textcolor{keywordtype}{bool} CHECK\_LHS\_BOUNDARY,
00762          \textcolor{keywordtype}{bool} CHECK\_RHS\_BOUNDARY>
00763 \_\_device\_\_ EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00764 EigenFloatContractionKernelInternal(\textcolor{keyword}{const} LhsMapper lhs, \textcolor{keyword}{const} RhsMapper rhs,
00765                        \textcolor{keyword}{const} OutputMapper output, float2 lhs\_shmem2[][32],
00766                        float2 rhs\_shmem2[][8], \textcolor{keyword}{const} Index m\_size,
00767                        \textcolor{keyword}{const} Index n\_size, \textcolor{keyword}{const} Index k\_size,
00768                        \textcolor{keyword}{const} Index base\_m, \textcolor{keyword}{const} Index base\_n) \{
00769   \textcolor{keyword}{typedef} \textcolor{keywordtype}{float} Scalar;
00770 
00771   \textcolor{comment}{// prefetch registers}
00772   float4 lhs\_pf0, lhs\_pf1, lhs\_pf2, lhs\_pf3;
00773   float4 rhs\_pf0, rhs\_pf1;
00774 
00775   float4 results[8];
00776   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < 8; i++) \{
00777     results[i].x = results[i].y = results[i].z = results[i].w = 0;
00778   \}
00779 
00780 
00781   Index lhs\_vert = base\_m+threadIdx.x*4+(threadIdx.y%4)*32;
00782   \textcolor{keywordflow}{for} (Index k = 0; k < k\_size; k += 32) \{
00783     lhs\_pf0 = internal::pset1<float4>(0);
00784     lhs\_pf1 = internal::pset1<float4>(0);
00785     lhs\_pf2 = internal::pset1<float4>(0);
00786     lhs\_pf3 = internal::pset1<float4>(0);
00787 
00788     rhs\_pf0 = internal::pset1<float4>(0);
00789     rhs\_pf1 = internal::pset1<float4>(0);
00790 
00791      \textcolor{keywordflow}{if} (!CHECK\_LHS\_BOUNDARY) \{
00792       \textcolor{keywordflow}{if} ((threadIdx.y/4+k+24) < k\_size) \{
00793         lhs\_pf0 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k));
00794         lhs\_pf1 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k+8));
00795         lhs\_pf2 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k+16));
00796         lhs\_pf3 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k+24));
00797       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k+16) < k\_size) \{
00798         lhs\_pf0 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k));
00799         lhs\_pf1 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k+8));
00800         lhs\_pf2 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k+16));
00801       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k+8) < k\_size) \{
00802         lhs\_pf0 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k));
00803         lhs\_pf1 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k+8));
00804       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k) < k\_size) \{
00805         lhs\_pf0 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k));
00806       \}
00807     \} \textcolor{keywordflow}{else} \{
00808       \textcolor{comment}{// just CHECK\_LHS\_BOUNDARY}
00809       \textcolor{keywordflow}{if} (lhs\_vert + 3 < m\_size) \{
00810         \textcolor{keywordflow}{if} ((threadIdx.y/4+k+24) < k\_size) \{
00811           lhs\_pf0 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k));
00812           lhs\_pf1 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k+8));
00813           lhs\_pf2 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k+16));
00814           lhs\_pf3 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k+24));
00815         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k+16) < k\_size) \{
00816           lhs\_pf0 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k));
00817           lhs\_pf1 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k+8));
00818           lhs\_pf2 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k+16));
00819         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k+8) < k\_size) \{
00820           lhs\_pf0 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k));
00821           lhs\_pf1 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k+8));
00822         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k) < k\_size) \{
00823           lhs\_pf0 =lhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(lhs\_vert, (threadIdx.y/4+k));
00824         \}
00825       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lhs\_vert + 2 < m\_size) \{
00826         \textcolor{keywordflow}{if} ((threadIdx.y/4+k+24) < k\_size) \{
00827           lhs\_pf0.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k));
00828           lhs\_pf0.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k));
00829           lhs\_pf0.z =lhs(lhs\_vert + 2, (threadIdx.y/4+k));
00830           lhs\_pf1.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+8));
00831           lhs\_pf1.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k+8));
00832           lhs\_pf1.z =lhs(lhs\_vert + 2, (threadIdx.y/4+k+8));
00833           lhs\_pf2.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+16));
00834           lhs\_pf2.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k+16));
00835           lhs\_pf2.z =lhs(lhs\_vert + 2, (threadIdx.y/4+k+16));
00836           lhs\_pf3.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+24));
00837           lhs\_pf3.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k+24));
00838           lhs\_pf3.z =lhs(lhs\_vert + 2, (threadIdx.y/4+k+24));
00839         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k+16) < k\_size) \{
00840           lhs\_pf0.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k));
00841           lhs\_pf0.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k));
00842           lhs\_pf0.z =lhs(lhs\_vert + 2, (threadIdx.y/4+k));
00843           lhs\_pf1.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+8));
00844           lhs\_pf1.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k+8));
00845           lhs\_pf1.z =lhs(lhs\_vert + 2, (threadIdx.y/4+k+8));
00846           lhs\_pf2.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+16));
00847           lhs\_pf2.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k+16));
00848           lhs\_pf2.z =lhs(lhs\_vert + 2, (threadIdx.y/4+k+16));
00849         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k+8) < k\_size) \{
00850           lhs\_pf0.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k));
00851           lhs\_pf0.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k));
00852           lhs\_pf0.z =lhs(lhs\_vert + 2, (threadIdx.y/4+k));
00853           lhs\_pf1.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+8));
00854           lhs\_pf1.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k+8));
00855           lhs\_pf1.z =lhs(lhs\_vert + 2, (threadIdx.y/4+k+8));
00856         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k) < k\_size) \{
00857           lhs\_pf0.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k));
00858           lhs\_pf0.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k));
00859           lhs\_pf0.z =lhs(lhs\_vert + 2, (threadIdx.y/4+k));
00860         \}
00861       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lhs\_vert + 1 < m\_size) \{
00862         \textcolor{keywordflow}{if} ((threadIdx.y/4+k+24) < k\_size) \{
00863           lhs\_pf0.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k));
00864           lhs\_pf0.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k));
00865           lhs\_pf1.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+8));
00866           lhs\_pf1.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k+8));
00867           lhs\_pf2.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+16));
00868           lhs\_pf2.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k+16));
00869           lhs\_pf3.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+24));
00870           lhs\_pf3.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k+24));
00871         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k+16) < k\_size) \{
00872           lhs\_pf0.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k));
00873           lhs\_pf0.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k));
00874           lhs\_pf1.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+8));
00875           lhs\_pf1.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k+8));
00876           lhs\_pf2.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+16));
00877           lhs\_pf2.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k+16));
00878         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k+8) < k\_size) \{
00879           lhs\_pf0.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k));
00880           lhs\_pf0.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k));
00881           lhs\_pf1.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+8));
00882           lhs\_pf1.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k+8));
00883         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k) < k\_size) \{
00884           lhs\_pf0.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k));
00885           lhs\_pf0.y =lhs(lhs\_vert + 1, (threadIdx.y/4+k));
00886         \}
00887       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lhs\_vert < m\_size) \{
00888         \textcolor{keywordflow}{if} ((threadIdx.y/4+k+24) < k\_size) \{
00889           lhs\_pf0.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k));
00890           lhs\_pf1.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+8));
00891           lhs\_pf2.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+16));
00892           lhs\_pf3.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+24));
00893         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k+16) < k\_size) \{
00894           lhs\_pf0.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k));
00895           lhs\_pf1.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+8));
00896           lhs\_pf2.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+16));
00897         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k+8) < k\_size) \{
00898           lhs\_pf0.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k));
00899           lhs\_pf1.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k+8));
00900         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((threadIdx.y/4+k) < k\_size) \{
00901           lhs\_pf0.x =lhs(lhs\_vert + 0, (threadIdx.y/4+k));
00902         \}
00903       \}
00904     \}
00905     \_\_syncthreads();
00906     Index rhs\_vert = k+threadIdx.x*4;
00907     Index rhs\_horiz0 = threadIdx.y*2+base\_n;
00908     Index rhs\_horiz1 = threadIdx.y*2+1+base\_n;
00909     \textcolor{keywordflow}{if} (!CHECK\_RHS\_BOUNDARY) \{
00910       \textcolor{keywordflow}{if} ((rhs\_vert + 3) < k\_size) \{
00911         \textcolor{comment}{// just CHECK\_RHS\_BOUNDARY}
00912         rhs\_pf0 = rhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(rhs\_vert, rhs\_horiz0);
00913         rhs\_pf1 = rhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(rhs\_vert, rhs\_horiz1);
00914       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rhs\_vert + 2 < k\_size) \{
00915         \textcolor{comment}{// just CHECK\_RHS\_BOUNDARY}
00916         rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00917         rhs\_pf0.y = rhs(rhs\_vert + 1, rhs\_horiz0);
00918         rhs\_pf0.z = rhs(rhs\_vert + 2, rhs\_horiz0);
00919         rhs\_pf1.x = rhs(rhs\_vert, rhs\_horiz1);
00920         rhs\_pf1.y = rhs(rhs\_vert + 1, rhs\_horiz1);
00921         rhs\_pf1.z = rhs(rhs\_vert + 2, rhs\_horiz1);
00922       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rhs\_vert + 1 < k\_size) \{
00923         rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00924         rhs\_pf0.y = rhs(rhs\_vert + 1, rhs\_horiz0);
00925         rhs\_pf1.x = rhs(rhs\_vert, rhs\_horiz1);
00926         rhs\_pf1.y = rhs(rhs\_vert + 1, rhs\_horiz1);
00927       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rhs\_vert  < k\_size) \{
00928         rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00929         rhs\_pf1.x = rhs(rhs\_vert, rhs\_horiz1);
00930       \}
00931     \} \textcolor{keywordflow}{else} \{
00932       \textcolor{keywordflow}{if} (rhs\_horiz1 < n\_size) \{
00933         \textcolor{keywordflow}{if} ((rhs\_vert + 3) < k\_size) \{
00934           \textcolor{comment}{// just CHECK\_RHS\_BOUNDARY}
00935           rhs\_pf0 = rhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(rhs\_vert, rhs\_horiz0);
00936           rhs\_pf1 = rhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(rhs\_vert, rhs\_horiz1);
00937         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rhs\_vert + 2 < k\_size) \{
00938           \textcolor{comment}{// just CHECK\_RHS\_BOUNDARY}
00939           rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00940           rhs\_pf0.y = rhs(rhs\_vert + 1, rhs\_horiz0);
00941           rhs\_pf0.z = rhs(rhs\_vert + 2, rhs\_horiz0);
00942           rhs\_pf1.x = rhs(rhs\_vert, rhs\_horiz1);
00943           rhs\_pf1.y = rhs(rhs\_vert + 1, rhs\_horiz1);
00944           rhs\_pf1.z = rhs(rhs\_vert + 2, rhs\_horiz1);
00945         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (k+threadIdx.x*4 + 1 < k\_size) \{
00946           rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00947           rhs\_pf0.y = rhs(rhs\_vert + 1, rhs\_horiz0);
00948           rhs\_pf1.x = rhs(rhs\_vert, rhs\_horiz1);
00949           rhs\_pf1.y = rhs(rhs\_vert + 1, rhs\_horiz1);
00950         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (k+threadIdx.x*4  < k\_size) \{
00951           rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00952           rhs\_pf1.x = rhs(rhs\_vert, rhs\_horiz1);
00953         \}
00954       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rhs\_horiz0 < n\_size) \{
00955         \textcolor{keywordflow}{if} ((rhs\_vert + 3) < k\_size) \{
00956           \textcolor{comment}{// just CHECK\_RHS\_BOUNDARY}
00957           rhs\_pf0 = rhs.loadPacket<\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(rhs\_vert, rhs\_horiz0);
00958         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((rhs\_vert + 2) < k\_size) \{
00959           \textcolor{comment}{// just CHECK\_RHS\_BOUNDARY}
00960           rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00961           rhs\_pf0.y = rhs(rhs\_vert + 1, rhs\_horiz0);
00962           rhs\_pf0.z = rhs(rhs\_vert + 2, rhs\_horiz0);
00963         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((rhs\_vert + 1) < k\_size) \{
00964           rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00965           rhs\_pf0.y = rhs(rhs\_vert + 1, rhs\_horiz0);
00966         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rhs\_vert  < k\_size) \{
00967           rhs\_pf0.x = rhs(rhs\_vert, rhs\_horiz0);
00968         \}
00969       \}
00970     \}
00971     \_\_syncthreads();
00972     \textcolor{comment}{// Loaded. Do computation}
00973     \textcolor{comment}{// Row 0 -> times (0, 4, 8, .. 28) for features 0, 1.}
00974     \textcolor{comment}{// Row 1 -> times (0, 4, 8, .. 28) for features 2, 3.}
00975     \textcolor{comment}{// ..}
00976     \textcolor{comment}{// Row 31 -> times (0, 4, 8, .. 28) for features 62, 63}
00977     rhs\_shmem2[threadIdx.y][threadIdx.x] = make\_float2(rhs\_pf0.x, rhs\_pf1.x);
00978     \textcolor{comment}{// Row 32 -> times (1, 5, 9, .. 29) for features 0, 1.}
00979     \textcolor{comment}{// Row 33 -> times (1, 5, 9, .. 29) for features 2, 3.}
00980     \textcolor{comment}{// ..}
00981     rhs\_shmem2[threadIdx.y+32][threadIdx.x] = make\_float2(rhs\_pf0.y, rhs\_pf1.y);
00982     \textcolor{comment}{// Row 64 -> times (2, 6, 10, .. 30) for features 0, 1.}
00983     \textcolor{comment}{// Row 65 -> times (2, 6, 10, .. 30) for features 2, 3.}
00984     rhs\_shmem2[threadIdx.y+64][threadIdx.x] = make\_float2(rhs\_pf0.z, rhs\_pf1.z);
00985     \textcolor{comment}{// Row 96 -> times (3, 7, 11, .. 31) for features 0, 1.}
00986     \textcolor{comment}{// Row 97 -> times (3, 7, 11, .. 31) for features 2, 3.}
00987     rhs\_shmem2[threadIdx.y+96][threadIdx.x] = make\_float2(rhs\_pf0.w, rhs\_pf1.w);
00988 
00989     \textcolor{comment}{// LHS.}
00990     \textcolor{comment}{// Row 0 (time 0) -> features (0, 1), (4, 5), .. (28, 29), (32, 33), ..  (60, 61) .. (124, 125)}
00991     \textcolor{comment}{// Row 1 (time 1) -> features (0, 1), (4, 5), .. (28, 29), (32, 33), ..  (60, 61) .. (124, 125)}
00992     \textcolor{comment}{// ...}
00993     \textcolor{comment}{// Row 8 (time 0) -> features (2, 3), (6, 7), .. (30, 31), (34, 35), ..  (62, 63) .. (126, 127)}
00994     \textcolor{comment}{// Row 15 (time 7) -> features (2, 3), (6, 7), .. (30, 31), (34, 35), ..  (62, 63) .. (126, 127)}
00995 
00996 
00997 \textcolor{preprocessor}{#define add\_vals(a\_feat1, a\_feat2, f1, f2, f3, f4)\(\backslash\)}
00998 \textcolor{preprocessor}{      results[0].x += a\_feat1.x * f1.x;\(\backslash\)}
00999 \textcolor{preprocessor}{      results[1].x += a\_feat1.x * f1.y;\(\backslash\)}
01000 \textcolor{preprocessor}{      results[2].x += a\_feat1.x * f2.x;\(\backslash\)}
01001 \textcolor{preprocessor}{      results[3].x += a\_feat1.x * f2.y;\(\backslash\)}
01002 \textcolor{preprocessor}{      results[4].x += a\_feat1.x * f3.x;\(\backslash\)}
01003 \textcolor{preprocessor}{      results[5].x += a\_feat1.x * f3.y;\(\backslash\)}
01004 \textcolor{preprocessor}{      results[6].x += a\_feat1.x * f4.x;\(\backslash\)}
01005 \textcolor{preprocessor}{      results[7].x += a\_feat1.x * f4.y;\(\backslash\)}
01006 \textcolor{preprocessor}{\(\backslash\)}
01007 \textcolor{preprocessor}{      results[0].y += a\_feat1.y * f1.x;\(\backslash\)}
01008 \textcolor{preprocessor}{      results[1].y += a\_feat1.y * f1.y;\(\backslash\)}
01009 \textcolor{preprocessor}{      results[2].y += a\_feat1.y * f2.x;\(\backslash\)}
01010 \textcolor{preprocessor}{      results[3].y += a\_feat1.y * f2.y;\(\backslash\)}
01011 \textcolor{preprocessor}{      results[4].y += a\_feat1.y * f3.x;\(\backslash\)}
01012 \textcolor{preprocessor}{      results[5].y += a\_feat1.y * f3.y;\(\backslash\)}
01013 \textcolor{preprocessor}{      results[6].y += a\_feat1.y * f4.x;\(\backslash\)}
01014 \textcolor{preprocessor}{      results[7].y += a\_feat1.y * f4.y;\(\backslash\)}
01015 \textcolor{preprocessor}{\(\backslash\)}
01016 \textcolor{preprocessor}{      results[0].z += a\_feat2.x * f1.x;\(\backslash\)}
01017 \textcolor{preprocessor}{      results[1].z += a\_feat2.x * f1.y;\(\backslash\)}
01018 \textcolor{preprocessor}{      results[2].z += a\_feat2.x * f2.x;\(\backslash\)}
01019 \textcolor{preprocessor}{      results[3].z += a\_feat2.x * f2.y;\(\backslash\)}
01020 \textcolor{preprocessor}{      results[4].z += a\_feat2.x * f3.x;\(\backslash\)}
01021 \textcolor{preprocessor}{      results[5].z += a\_feat2.x * f3.y;\(\backslash\)}
01022 \textcolor{preprocessor}{      results[6].z += a\_feat2.x * f4.x;\(\backslash\)}
01023 \textcolor{preprocessor}{      results[7].z += a\_feat2.x * f4.y;\(\backslash\)}
01024 \textcolor{preprocessor}{\(\backslash\)}
01025 \textcolor{preprocessor}{      results[0].w += a\_feat2.y * f1.x;\(\backslash\)}
01026 \textcolor{preprocessor}{      results[1].w += a\_feat2.y * f1.y;\(\backslash\)}
01027 \textcolor{preprocessor}{      results[2].w += a\_feat2.y * f2.x;\(\backslash\)}
01028 \textcolor{preprocessor}{      results[3].w += a\_feat2.y * f2.y;\(\backslash\)}
01029 \textcolor{preprocessor}{      results[4].w += a\_feat2.y * f3.x;\(\backslash\)}
01030 \textcolor{preprocessor}{      results[5].w += a\_feat2.y * f3.y;\(\backslash\)}
01031 \textcolor{preprocessor}{      results[6].w += a\_feat2.y * f4.x;\(\backslash\)}
01032 \textcolor{preprocessor}{      results[7].w += a\_feat2.y * f4.y;\(\backslash\)}
01033 \textcolor{preprocessor}{}
01034     lhs\_shmem2[threadIdx.y/4][threadIdx.x+(threadIdx.y%4)*8] = make\_float2(lhs\_pf0.x, lhs\_pf0.y);
01035     lhs\_shmem2[threadIdx.y/4+8][threadIdx.x+(threadIdx.y%4)*8] = make\_float2(lhs\_pf1.x, lhs\_pf1.y);
01036     lhs\_shmem2[threadIdx.y/4+16][threadIdx.x+(threadIdx.y%4)*8] = make\_float2(lhs\_pf2.x, lhs\_pf2.y);
01037     lhs\_shmem2[threadIdx.y/4+24][threadIdx.x+(threadIdx.y%4)*8] = make\_float2(lhs\_pf3.x, lhs\_pf3.y);
01038 
01039     lhs\_shmem2[threadIdx.y/4 + 32][threadIdx.x+(threadIdx.y%4)*8] = make\_float2(lhs\_pf0.z, lhs\_pf0.w);
01040     lhs\_shmem2[threadIdx.y/4 + 40][threadIdx.x+(threadIdx.y%4)*8] = make\_float2(lhs\_pf1.z, lhs\_pf1.w);
01041     lhs\_shmem2[threadIdx.y/4 + 48][threadIdx.x+(threadIdx.y%4)*8] = make\_float2(lhs\_pf2.z, lhs\_pf2.w);
01042     lhs\_shmem2[threadIdx.y/4 + 56][threadIdx.x+(threadIdx.y%4)*8] = make\_float2(lhs\_pf3.z, lhs\_pf3.w);
01043 
01044     \_\_syncthreads();
01045 
01046     \textcolor{comment}{// Do the multiplies.}
01047 \textcolor{preprocessor}{    #pragma unroll}
01048     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} koff = 0; koff < 32; koff ++) \{
01049       float2 a3 = lhs\_shmem2[koff][threadIdx.x + (threadIdx.y % 4) * 8];
01050       float2 a4 = lhs\_shmem2[koff + 32][threadIdx.x + (threadIdx.y % 4) * 8];
01051 
01052       \textcolor{comment}{// first feature is at (threadIdx.y/4) * 8 last is at start + 8.}
01053       \textcolor{keywordtype}{int} start\_feature = (threadIdx.y / 4) * 8;
01054 
01055       float2 br1 = rhs\_shmem2[start\_feature/2 +     (koff % 4) * 32][koff/4];
01056       float2 br2 = rhs\_shmem2[start\_feature/2 + 1 + (koff % 4) * 32][koff/4];
01057       float2 br3 = rhs\_shmem2[start\_feature/2 + 2 + (koff % 4) * 32][koff/4];
01058       float2 br4 = rhs\_shmem2[start\_feature/2 + 3 + (koff % 4) * 32][koff/4];
01059 
01060       add\_vals(a3, a4, br1, br2, br3, br4)
01061     \}
01062     \_\_syncthreads();
01063   \} \textcolor{comment}{// end loop over k}
01064 
01065 
01066   \_\_syncthreads();
01067   Index horiz\_base = (threadIdx.y/4)*8+base\_n;
01068   \textcolor{keywordflow}{if} (!CHECK\_LHS\_BOUNDARY && !CHECK\_RHS\_BOUNDARY) \{
01069     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 8; i++) \{
01070       output(lhs\_vert, horiz\_base + i) = results[i].x;
01071       output(lhs\_vert + 1, horiz\_base + i) = results[i].y;
01072       output(lhs\_vert + 2, horiz\_base + i) = results[i].z;
01073       output(lhs\_vert + 3, horiz\_base + i) = results[i].w;
01074     \}
01075   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!CHECK\_RHS\_BOUNDARY) \{
01076     \textcolor{keywordflow}{if} (lhs\_vert + 3 < m\_size) \{
01077       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 8; i++) \{
01078         output(lhs\_vert, horiz\_base + i) = results[i].x;
01079         output(lhs\_vert + 1, horiz\_base + i) = results[i].y;
01080         output(lhs\_vert + 2, horiz\_base + i) = results[i].z;
01081         output(lhs\_vert + 3, horiz\_base + i) = results[i].w;
01082       \}
01083     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lhs\_vert + 2 < m\_size) \{
01084       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 8; i++) \{
01085         output(lhs\_vert, horiz\_base + i) = results[i].x;
01086         output(lhs\_vert + 1, horiz\_base + i) = results[i].y;
01087         output(lhs\_vert + 2, horiz\_base + i) = results[i].z;
01088       \}
01089     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lhs\_vert + 1 < m\_size) \{
01090       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 8; i++) \{
01091         output(lhs\_vert, horiz\_base + i) = results[i].x;
01092         output(lhs\_vert + 1, horiz\_base + i) = results[i].y;
01093       \}
01094     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lhs\_vert  < m\_size) \{
01095       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 8; i++) \{
01096         output(lhs\_vert, horiz\_base + i) = results[i].x;
01097       \}
01098     \}
01099   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!CHECK\_LHS\_BOUNDARY) \{
01100     \textcolor{comment}{// CHECK BOUNDARY\_B}
01101     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 8; i++) \{
01102       \textcolor{keywordflow}{if} (horiz\_base + i < n\_size) \{
01103         output(lhs\_vert, horiz\_base + i) = results[i].x;
01104         output(lhs\_vert + 1, horiz\_base + i) = results[i].y;
01105         output(lhs\_vert + 2, horiz\_base + i) = results[i].z;
01106         output(lhs\_vert + 3, horiz\_base + i) = results[i].w;
01107       \}
01108     \}
01109   \} \textcolor{keywordflow}{else} \{
01110     \textcolor{comment}{// CHECK both boundaries.}
01111     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 8; i++) \{
01112       \textcolor{keywordflow}{if} (horiz\_base + i < n\_size) \{
01113         \textcolor{keywordflow}{if} (lhs\_vert < m\_size)
01114           output(lhs\_vert, horiz\_base + i) = results[i].x;
01115         \textcolor{keywordflow}{if} (lhs\_vert + 1 < m\_size)
01116           output(lhs\_vert + 1, horiz\_base + i) = results[i].y;
01117         \textcolor{keywordflow}{if} (lhs\_vert + 2 < m\_size)
01118           output(lhs\_vert + 2, horiz\_base + i) = results[i].z;
01119         \textcolor{keywordflow}{if} (lhs\_vert + 3 < m\_size)
01120           output(lhs\_vert + 3, horiz\_base + i) = results[i].w;
01121       \}
01122     \}
01123   \}
01124 \}
01125 
01126 
01127 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keyword}{typename} LhsMapper,
01128          \textcolor{keyword}{typename} RhsMapper, \textcolor{keyword}{typename} OutputMapper>
01129 \_\_global\_\_ \textcolor{keywordtype}{void}
01130 \_\_launch\_bounds\_\_(256)
01131 EigenFloatContractionKernel(const LhsMapper lhs, const RhsMapper rhs,
01132                        const OutputMapper output,
01133                        const Index m\_size, const Index n\_size, const Index k\_size) \{
01134   \_\_shared\_\_ float2 lhs\_shmem[64*32];
01135   \_\_shared\_\_ float2 rhs\_shmem[128*8];
01136 
01137   \textcolor{keyword}{typedef} float2 LHS\_MEM[64][32];
01138   \textcolor{keyword}{typedef} float2 RHS\_MEM[128][8];
01139 
01140   \textcolor{keyword}{typedef} float2 LHS\_MEM16x16[32][16];
01141   \textcolor{keyword}{typedef} float2 RHS\_MEM16x16[64][8];
01142 
01143   \textcolor{keyword}{const} Index m\_block\_idx = blockIdx.x;
01144   \textcolor{keyword}{const} Index n\_block\_idx = blockIdx.y;
01145 
01146   \textcolor{keyword}{const} Index base\_m = 128 * m\_block\_idx;
01147   \textcolor{keyword}{const} Index base\_n = 64 * n\_block\_idx;
01148 
01149   \textcolor{keywordtype}{bool} check\_rhs = (base\_n + 63) >= n\_size;
01150   \textcolor{keywordtype}{bool} check\_lhs128 = (base\_m + 127) >= m\_size;
01151 
01152   \textcolor{keywordflow}{if} (!check\_rhs) \{
01153     \textcolor{keywordflow}{if} (!check\_lhs128) \{
01154       \textcolor{comment}{// >= 128 rows left}
01155       EigenFloatContractionKernelInternal<Index, LhsMapper, RhsMapper, OutputMapper, false, false>(
01156                      lhs, rhs, output, *((LHS\_MEM *) lhs\_shmem), *((RHS\_MEM *) rhs\_shmem), m\_size, n\_size, 
      k\_size, base\_m, base\_n);
01157     \} \textcolor{keywordflow}{else} \{
01158       EigenFloatContractionKernelInternal<Index, LhsMapper, RhsMapper, OutputMapper, true, false>(
01159                      lhs, rhs, output, *((LHS\_MEM *) lhs\_shmem), *((RHS\_MEM *) rhs\_shmem), m\_size, n\_size, 
      k\_size, base\_m, base\_n);
01160     \}
01161   \} \textcolor{keywordflow}{else} \{
01162     \textcolor{keywordflow}{if} (!check\_lhs128) \{
01163       \textcolor{comment}{// >= 128 rows left}
01164       EigenFloatContractionKernelInternal<Index, LhsMapper, RhsMapper, OutputMapper, false, true>(
01165                      lhs, rhs, output, *((LHS\_MEM *) lhs\_shmem), *((RHS\_MEM *) rhs\_shmem), m\_size, n\_size, 
      k\_size, base\_m, base\_n);
01166     \} \textcolor{keywordflow}{else} \{
01167       EigenFloatContractionKernelInternal<Index, LhsMapper, RhsMapper, OutputMapper, true, true>(
01168                      lhs, rhs, output, *((LHS\_MEM *) lhs\_shmem), *((RHS\_MEM *) rhs\_shmem), m\_size, n\_size, 
      k\_size, base\_m, base\_n);
01169     \}
01170   \}
01171 \}
01172 
01173 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keyword}{typename} LhsMapper,
01174          \textcolor{keyword}{typename} RhsMapper, \textcolor{keyword}{typename} OutputMapper>
01175 \_\_global\_\_ \textcolor{keywordtype}{void}
01176 \_\_launch\_bounds\_\_(256)
01177 EigenFloatContractionKernel16x16(const LhsMapper lhs, const RhsMapper rhs,
01178                        const OutputMapper output,
01179                        const Index m\_size, const Index n\_size, const Index k\_size) \{
01180   \_\_shared\_\_ float2 lhs\_shmem[32][16];
01181   \_\_shared\_\_ float2 rhs\_shmem[64][8];
01182 
01183   \textcolor{keyword}{const} Index m\_block\_idx = blockIdx.x;
01184   \textcolor{keyword}{const} Index n\_block\_idx = blockIdx.y;
01185 
01186   \textcolor{keyword}{const} Index base\_m = 64 * m\_block\_idx;
01187   \textcolor{keyword}{const} Index base\_n = 64 * n\_block\_idx;
01188 
01189   \textcolor{keywordflow}{if} (base\_m + 63 < m\_size) \{
01190     \textcolor{keywordflow}{if} (base\_n + 63 < n\_size) \{
01191       EigenFloatContractionKernelInternal16x16<Index, LhsMapper, RhsMapper, OutputMapper, false, false>(lhs
      , rhs, output, lhs\_shmem, rhs\_shmem, m\_size, n\_size, k\_size, base\_m, base\_n);
01192     \} \textcolor{keywordflow}{else} \{
01193       EigenFloatContractionKernelInternal16x16<Index, LhsMapper, RhsMapper, OutputMapper, false, true>(lhs,
       rhs, output, lhs\_shmem, rhs\_shmem, m\_size, n\_size, k\_size, base\_m, base\_n);
01194     \}
01195   \} \textcolor{keywordflow}{else} \{
01196     \textcolor{keywordflow}{if} (base\_n + 63 < n\_size) \{
01197       EigenFloatContractionKernelInternal16x16<Index, LhsMapper, RhsMapper, OutputMapper, true, false>(lhs,
       rhs, output, lhs\_shmem, rhs\_shmem, m\_size, n\_size, k\_size, base\_m, base\_n);
01198     \} \textcolor{keywordflow}{else} \{
01199       EigenFloatContractionKernelInternal16x16<Index, LhsMapper, RhsMapper, OutputMapper, true, true>(lhs, 
      rhs, output, lhs\_shmem, rhs\_shmem, m\_size, n\_size, k\_size, base\_m, base\_n);
01200     \}
01201   \}
01202 \}
01203 
01204 
01205 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Indices, \textcolor{keyword}{typename} LeftArgType, \textcolor{keyword}{typename} RightArgType>
01206 \textcolor{keyword}{struct }TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, GpuDevice> :
01207     \textcolor{keyword}{public} TensorContractionEvaluatorBase<TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, R
      ightArgType>, GpuDevice> > \{
01208 
01209   \textcolor{keyword}{typedef} GpuDevice Device;
01210 
01211   \textcolor{keyword}{typedef} TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, Device> Self;
01212   \textcolor{keyword}{typedef} TensorContractionEvaluatorBase<Self> Base;
01213 
01214   \textcolor{keyword}{typedef} TensorContractionOp<Indices, LeftArgType, RightArgType> XprType;
01215   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<typename XprType::Scalar>::type Scalar;
01216   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index Index;
01217   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
01218   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, GpuDevice>::type PacketReturnType;
01219 
01220   \textcolor{keyword}{enum} \{
01221     Layout = TensorEvaluator<LeftArgType, Device>::Layout,
01222   \};
01223 
01224   \textcolor{comment}{// Most of the code is assuming that both input tensors are ColMajor. If the}
01225   \textcolor{comment}{// inputs are RowMajor, we will "cheat" by swapping the LHS and RHS:}
01226   \textcolor{comment}{// If we want to compute A * B = C, where A is LHS and B is RHS, the code}
01227   \textcolor{comment}{// will pretend B is LHS and A is RHS.}
01228   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::conditional<
01229     \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}), LeftArgType, RightArgType>::type 
      EvalLeftArgType;
01230   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::conditional<
01231     \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}), RightArgType, LeftArgType>::type 
      EvalRightArgType;
01232 
01233   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} LDims =
01234       internal::array\_size<typename TensorEvaluator<EvalLeftArgType, Device>::Dimensions>::value;
01235   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} RDims =
01236       internal::array\_size<typename TensorEvaluator<EvalRightArgType, Device>::Dimensions>::value;
01237   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} ContractDims = internal::array\_size<Indices>::value;
01238 
01239   \textcolor{keyword}{typedef} array<Index, LDims> left\_dim\_mapper\_t;
01240   \textcolor{keyword}{typedef} array<Index, RDims> right\_dim\_mapper\_t;
01241 
01242   \textcolor{keyword}{typedef} array<Index, ContractDims> contract\_t;
01243   \textcolor{keyword}{typedef} array<Index, LDims - ContractDims> left\_nocontract\_t;
01244   \textcolor{keyword}{typedef} array<Index, RDims - ContractDims> right\_nocontract\_t;
01245 
01246   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = LDims + RDims - 2 * ContractDims;
01247 
01248   \textcolor{keyword}{typedef} DSizes<Index, NumDims> Dimensions;
01249 
01250   \textcolor{comment}{// typedefs needed in evalTo}
01251   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<typename EvalLeftArgType::Scalar>::type LhsScalar;
01252   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<typename EvalRightArgType::Scalar>::type RhsScalar;
01253 
01254   \textcolor{keyword}{typedef} TensorEvaluator<EvalLeftArgType, Device> LeftEvaluator;
01255   \textcolor{keyword}{typedef} TensorEvaluator<EvalRightArgType, Device> RightEvaluator;
01256 
01257   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LeftEvaluator::Dimensions LeftDimensions;
01258   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RightEvaluator::Dimensions RightDimensions;
01259 
01260   EIGEN\_DEVICE\_FUNC TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& \hyperlink{struct_eigen_1_1_tensor_evaluator_a98b51809ed8f7a1f736eb7b952b9636e}{device}) :
01261       Base(op, device) \{\}
01262 
01263   \textcolor{comment}{// We need to redefine this method to make nvcc happy}
01264   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* data) \{
01265     this->m\_leftImpl.evalSubExprsIfNeeded(NULL);
01266     this->m\_rightImpl.evalSubExprsIfNeeded(NULL);
01267     \textcolor{keywordflow}{if} (data) \{
01268       evalTo(data);
01269       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
01270     \} \textcolor{keywordflow}{else} \{
01271       this->m\_result = \textcolor{keyword}{static\_cast<}Scalar *\textcolor{keyword}{>}(this->m\_device.allocate(this->dimensions().TotalSize() * \textcolor{keyword}{
      sizeof}(Scalar)));
01272       evalTo(this->m\_result);
01273       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
01274     \}
01275   \}
01276 
01277   \textcolor{keywordtype}{void} evalTo(Scalar* buffer)\textcolor{keyword}{ const }\{
01278     \textcolor{keywordflow}{if} (this->m\_lhs\_inner\_dim\_contiguous) \{
01279       \textcolor{keywordflow}{if} (this->m\_rhs\_inner\_dim\_contiguous) \{
01280         \textcolor{keywordflow}{if} (this->m\_rhs\_inner\_dim\_reordered) \{
01281           evalTyped<true, true, true, Unaligned>(buffer);
01282         \}
01283         \textcolor{keywordflow}{else} \{
01284           evalTyped<true, true, false, Unaligned>(buffer);
01285         \}
01286       \}
01287       \textcolor{keywordflow}{else} \{
01288        \textcolor{keywordflow}{if} (this->m\_rhs\_inner\_dim\_reordered) \{
01289           evalTyped<true, false, true, Unaligned>(buffer);
01290         \}
01291         \textcolor{keywordflow}{else} \{
01292           evalTyped<true, false, false, Unaligned>(buffer);
01293         \}
01294       \}
01295     \}
01296     \textcolor{keywordflow}{else} \{
01297       \textcolor{keywordflow}{if} (this->m\_rhs\_inner\_dim\_contiguous) \{
01298         \textcolor{keywordflow}{if} (this->m\_rhs\_inner\_dim\_reordered) \{
01299           evalTyped<false, true, true, Unaligned>(buffer);
01300         \}
01301         \textcolor{keywordflow}{else} \{
01302           evalTyped<false, true, false, Unaligned>(buffer);
01303         \}
01304       \}
01305       \textcolor{keywordflow}{else} \{
01306        \textcolor{keywordflow}{if} (this->m\_rhs\_inner\_dim\_reordered) \{
01307           evalTyped<false, false, true, Unaligned>(buffer);
01308         \}
01309         \textcolor{keywordflow}{else} \{
01310           evalTyped<false, false, false, Unaligned>(buffer);
01311         \}
01312       \}
01313     \}
01314   \}
01315 
01316   \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} LhsMapper, \textcolor{keyword}{typename} RhsMapper,
       \textcolor{keyword}{typename} OutputMapper> \textcolor{keyword}{struct }LaunchKernels \{
01317     \textcolor{keyword}{static} \textcolor{keywordtype}{void} Run(\textcolor{keyword}{const} LhsMapper& lhs, \textcolor{keyword}{const} RhsMapper& rhs, \textcolor{keyword}{const} OutputMapper& output, Index m, Index 
      n, Index k, \textcolor{keyword}{const} GpuDevice& \hyperlink{struct_eigen_1_1_tensor_evaluator_a98b51809ed8f7a1f736eb7b952b9636e}{device}) \{
01318     \textcolor{keyword}{const} Index m\_blocks = (m + 63) / 64;
01319     \textcolor{keyword}{const} Index n\_blocks = (n + 63) / 64;
01320     \textcolor{keyword}{const} dim3 num\_blocks(m\_blocks, n\_blocks, 1);
01321     \textcolor{keyword}{const} dim3 block\_size(8, 8, 8);
01322     LAUNCH\_CUDA\_KERNEL((EigenContractionKernel<Scalar, Index, LhsMapper, RhsMapper, OutputMapper>), 
      num\_blocks, block\_size, 0, device, lhs, rhs, output, m, n, k);
01323     \}
01324   \};
01325 
01326   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} LhsMapper, \textcolor{keyword}{typename} RhsMapper, \textcolor{keyword}{typename} OutputMapper> \textcolor{keyword}{struct }
      LaunchKernels<float, float, Index, LhsMapper, RhsMapper, OutputMapper> \{
01327     \textcolor{keyword}{static} \textcolor{keywordtype}{void} Run(\textcolor{keyword}{const} LhsMapper& lhs, \textcolor{keyword}{const} RhsMapper& rhs, \textcolor{keyword}{const} OutputMapper& output, Index m, Index 
      n, Index k, \textcolor{keyword}{const} GpuDevice& \hyperlink{struct_eigen_1_1_tensor_evaluator_a98b51809ed8f7a1f736eb7b952b9636e}{device}) \{
01328       \textcolor{keywordflow}{if} (m < 768 || n < 768) \{
01329         \textcolor{keyword}{const} Index m\_blocks = (m + 63) / 64;
01330         \textcolor{keyword}{const} Index n\_blocks = (n + 63) / 64;
01331         \textcolor{keyword}{const} dim3 num\_blocks(m\_blocks, n\_blocks, 1);
01332         \textcolor{keyword}{const} dim3 block\_size(16, 16, 1);
01333         LAUNCH\_CUDA\_KERNEL((EigenFloatContractionKernel16x16<Index, LhsMapper, RhsMapper, OutputMapper>), 
      num\_blocks, block\_size, 0, device, lhs, rhs, output, m, n, k);
01334       \} \textcolor{keywordflow}{else} \{
01335         \textcolor{keyword}{const} Index m\_blocks = (m + 127) / 128;
01336         \textcolor{keyword}{const} Index n\_blocks = (n + 63) / 64;
01337         \textcolor{keyword}{const} dim3 num\_blocks(m\_blocks, n\_blocks, 1);
01338         \textcolor{keyword}{const} dim3 block\_size(8, 32, 1);
01339         LAUNCH\_CUDA\_KERNEL((EigenFloatContractionKernel<Index, LhsMapper, RhsMapper, OutputMapper>), 
      num\_blocks, block\_size, 0, device, lhs, rhs, output, m, n, k);
01340       \}
01341     \}
01342   \};
01343 
01344   \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} lhs\_inner\_dim\_contiguous, \textcolor{keywordtype}{bool} rhs\_inner\_dim\_contiguous, \textcolor{keywordtype}{bool} rhs\_inner\_dim\_reordered, \textcolor{keywordtype}{int}
       Alignment>
01345   \textcolor{keywordtype}{void} evalTyped(Scalar* buffer)\textcolor{keyword}{ const }\{
01346     \textcolor{comment}{// columns in left side, rows in right side}
01347     \textcolor{keyword}{const} Index k = this->m\_k\_size;
01348     EIGEN\_UNUSED\_VARIABLE(k)
01349 
01350     \textcolor{comment}{// rows in left side}
01351     \textcolor{keyword}{const} Index m = this->m\_i\_size;
01352 
01353     \textcolor{comment}{// columns in right side}
01354     \textcolor{keyword}{const} Index n = this->m\_j\_size;
01355 
01356     \textcolor{comment}{// zero out the result buffer (which must be of size at least m * n * sizeof(Scalar)}
01357     this->m\_device.memset(buffer, 0, m * n * \textcolor{keyword}{sizeof}(Scalar));
01358 
01359     \textcolor{keyword}{typedef} internal::TensorContractionInputMapper<LhsScalar, Index, internal::Lhs,
01360                                                    LeftEvaluator, left\_nocontract\_t,
01361                                                    contract\_t, 4,
01362                                                    lhs\_inner\_dim\_contiguous,
01363                                                    \textcolor{keyword}{false}, \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}> LhsMapper;
01364 
01365     \textcolor{keyword}{typedef} internal::TensorContractionInputMapper<RhsScalar, Index, internal::Rhs,
01366                                                    RightEvaluator, right\_nocontract\_t,
01367                                                    contract\_t, 4,
01368                                                    rhs\_inner\_dim\_contiguous,
01369                                                    rhs\_inner\_dim\_reordered, 
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}> RhsMapper;
01370 
01371     \textcolor{keyword}{typedef} internal::blas\_data\_mapper<Scalar, Index, ColMajor> OutputMapper;
01372 
01373 
01374     \textcolor{comment}{// initialize data mappers}
01375     LhsMapper lhs(this->m\_leftImpl, this->m\_left\_nocontract\_strides, this->m\_i\_strides,
01376                   this->m\_left\_contracting\_strides, this->m\_k\_strides);
01377 
01378     RhsMapper rhs(this->m\_rightImpl, this->m\_right\_nocontract\_strides, this->m\_j\_strides,
01379                   this->m\_right\_contracting\_strides, this->m\_k\_strides);
01380 
01381     OutputMapper output(buffer, m);
01382 
01383     setCudaSharedMemConfig(cudaSharedMemBankSizeEightByte);
01384     LaunchKernels<LhsScalar, RhsScalar, Index, LhsMapper, RhsMapper, OutputMapper>::Run(lhs, rhs, output,  
      m, n, k, this->m\_device);
01385   \}
01386 \};
01387 
01388 \} \textcolor{comment}{// end namespace Eigen}
01389 
01390 \textcolor{preprocessor}{#endif // EIGEN\_USE\_GPU and \_\_CUDACC\_\_}
01391 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_CONTRACTION\_CUDA\_H}
\end{DoxyCode}
