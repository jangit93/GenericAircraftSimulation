\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Reduction\+Sycl.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source}\index{Tensor\+Reduction\+Sycl.\+h@{Tensor\+Reduction\+Sycl.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Mehdi Goli    Codeplay Software Ltd.}
00005 \textcolor{comment}{// Ralph Potter  Codeplay Software Ltd.}
00006 \textcolor{comment}{// Luke Iwanski  Codeplay Software Ltd.}
00007 \textcolor{comment}{// Contact: <eigen@codeplay.com>}
00008 \textcolor{comment}{//}
00009 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00010 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00011 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00012 
00013 \textcolor{comment}{/*****************************************************************}
00014 \textcolor{comment}{ * TensorSyclPlaceHolderExpr.h}
00015 \textcolor{comment}{ *}
00016 \textcolor{comment}{ * \(\backslash\)brief:}
00017 \textcolor{comment}{ *  This is the specialisation of the placeholder expression based on the}
00018 \textcolor{comment}{ * operation type}
00019 \textcolor{comment}{ *}
00020 \textcolor{comment}{*****************************************************************/}
00021 
00022 \textcolor{preprocessor}{#ifndef UNSUPPORTED\_EIGEN\_CXX11\_SRC\_TENSOR\_TENSOR\_REDUCTION\_SYCL\_HPP}
00023 \textcolor{preprocessor}{#define UNSUPPORTED\_EIGEN\_CXX11\_SRC\_TENSOR\_TENSOR\_REDUCTION\_SYCL\_HPP}
00024 
00025 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00026 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00027 
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source_l00028}\hyperlink{struct_eigen_1_1internal_1_1sycl_generic_buffer_reducer}{00028} \textcolor{keyword}{template}<\textcolor{keyword}{typename} CoeffReturnType, \textcolor{keyword}{typename} KernelName> \textcolor{keyword}{struct }
      \hyperlink{struct_eigen_1_1internal_1_1sycl_generic_buffer_reducer}{syclGenericBufferReducer}\{
00029 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BufferTOut, \textcolor{keyword}{typename} BufferTIn>
00030 \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(BufferTOut* bufOut, BufferTIn& bufI, \textcolor{keyword}{const} Eigen::SyclDevice& dev, \textcolor{keywordtype}{size\_t} length, \textcolor{keywordtype}{size\_t} 
      local)\{
00031   \textcolor{keywordflow}{do} \{
00032           \textcolor{keyword}{auto} f = [length, local, bufOut, &bufI](cl::sycl::handler& h) \textcolor{keyword}{mutable} \{
00033             cl::sycl::nd\_range<1> r\{cl::sycl::range<1>\{std::max(length, local)\},
00034                                     cl::sycl::range<1>\{std::min(length, local)\}\};
00035             \textcolor{comment}{/* Two accessors are used: one to the buffer that is being reduced,}
00036 \textcolor{comment}{             * and a second to local memory, used to store intermediate data. */}
00037             \textcolor{keyword}{auto} aI =
00038                 bufI.template get\_access<cl::sycl::access::mode::read\_write>(h);
00039             \textcolor{keyword}{auto} aOut =
00040                 bufOut->template get\_access<cl::sycl::access::mode::discard\_write>(h);
00041             cl::sycl::accessor<CoeffReturnType, 1, cl::sycl::access::mode::read\_write,
00042                                cl::sycl::access::target::local>
00043                 scratch(cl::sycl::range<1>(local), h);
00044 
00045             \textcolor{comment}{/* The parallel\_for invocation chosen is the variant with an nd\_item}
00046 \textcolor{comment}{             * parameter, since the code requires barriers for correctness. */}
00047             h.parallel\_for<KernelName>(
00048                 r, [aOut, aI, scratch, local, length](cl::sycl::nd\_item<1> id) \{
00049                   \textcolor{keywordtype}{size\_t} globalid = \textcolor{keywordtype}{id}.get\_global(0);
00050                   \textcolor{keywordtype}{size\_t} localid = \textcolor{keywordtype}{id}.get\_local(0);
00051                   \textcolor{comment}{/* All threads collectively read from global memory into local.}
00052 \textcolor{comment}{                   * The barrier ensures all threads' IO is resolved before}
00053 \textcolor{comment}{                   * execution continues (strictly speaking, all threads within}
00054 \textcolor{comment}{                   * a single work-group - there is no co-ordination between}
00055 \textcolor{comment}{                   * work-groups, only work-items). */}
00056                   \textcolor{keywordflow}{if} (globalid < length) \{
00057                     scratch[localid] = aI[globalid];
00058                   \}
00059                   \textcolor{keywordtype}{id}.barrier(cl::sycl::access::fence\_space::local\_space);
00060 
00061                   \textcolor{comment}{/* Apply the reduction operation between the current local}
00062 \textcolor{comment}{                   * id and the one on the other half of the vector. */}
00063                   \textcolor{keywordflow}{if} (globalid < length) \{
00064                     \textcolor{keywordtype}{int} min = (length < local) ? length : local;
00065                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} offset = min / 2; offset > 0; offset /= 2) \{
00066                       \textcolor{keywordflow}{if} (localid < offset) \{
00067                         scratch[localid] += scratch[localid + offset];
00068                       \}
00069                       \textcolor{keywordtype}{id}.barrier(cl::sycl::access::fence\_space::local\_space);
00070                     \}
00071                     \textcolor{comment}{/* The final result will be stored in local id 0. */}
00072                     \textcolor{keywordflow}{if} (localid == 0) \{
00073                       aI[\textcolor{keywordtype}{id}.get\_group(0)] = scratch[localid];
00074                       \textcolor{keywordflow}{if}((length<=local) && globalid ==0)\{
00075                         aOut[globalid]=scratch[localid];
00076                       \}
00077                     \}
00078                   \}
00079                 \});
00080           \};
00081             dev.m\_queue.submit(f);
00082             dev.m\_queue.throw\_asynchronous();
00083 
00084           \textcolor{comment}{/* At this point, you could queue::wait\_and\_throw() to ensure that}
00085 \textcolor{comment}{           * errors are caught quickly. However, this would likely impact}
00086 \textcolor{comment}{           * performance negatively. */}
00087           length = length / local;
00088 
00089         \} \textcolor{keywordflow}{while} (length > 1);
00090 
00091 
00092 
00093 \}
00094 
00095 \};
00096 
00101 \textcolor{comment}{// a leafNode.}
00102 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op, \textcolor{keywordtype}{bool} Vectorizable>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source_l00103}\hyperlink{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4}{00103} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_full_reducer}{FullReducer}<Self, Op, const \hyperlink{namespace_eigen}{Eigen}::SyclDevice, Vectorizable> \{
00104 
00105   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Self::CoeffReturnType CoeffReturnType;
00106   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} HasOptimizedImplementation = \textcolor{keyword}{false};
00107 
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source_l00108}\hyperlink{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_aee608a1f9a8dca2b99477c2738357c05}{00108}   \textcolor{keyword}{static} \textcolor{keywordtype}{void} \hyperlink{struct_eigen_1_1internal_1_1_full_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_00_01_vectorizable_01_4_aee608a1f9a8dca2b99477c2738357c05}{run}(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, Op& reducer, \textcolor{keyword}{const} Eigen::SyclDevice& dev, CoeffReturnType* output) 
      \{
00109     \textcolor{keyword}{typedef} \textcolor{keyword}{const} \textcolor{keyword}{typename} Self::ChildType HostExpr; 
00110     \textcolor{keyword}{typedef}  \textcolor{keyword}{typename} TensorSycl::internal::createPlaceHolderExpression<HostExpr>::Type PlaceHolderExpr;
00111     \textcolor{keyword}{auto} functors = TensorSycl::internal::extractFunctors(\textcolor{keyword}{self}.impl());
00112     \textcolor{keywordtype}{int} red\_factor =256; 
00113     \textcolor{keywordtype}{size\_t} inputSize =\textcolor{keyword}{self}.impl().dimensions().TotalSize();
00114     \textcolor{keywordtype}{size\_t} rng = inputSize/red\_factor; \textcolor{comment}{// the total number of thread initially is half the size of the
       input}
00115     \textcolor{keywordtype}{size\_t} remaining = inputSize% red\_factor;
00116     \textcolor{keywordflow}{if}(rng ==0) \{
00117       red\_factor=1;
00118     \};
00119     \textcolor{keywordtype}{size\_t} tileSize =dev.m\_queue.get\_device(). \textcolor{keyword}{template} 
      get\_info<cl::sycl::info::device::max\_work\_group\_size>()/2;
00120     \textcolor{keywordtype}{size\_t} GRange=std::max((\textcolor{keywordtype}{size\_t} )1, rng);
00121 
00122     \textcolor{comment}{// convert global range to power of 2 for redecution}
00123     GRange--;
00124     GRange |= GRange >> 1;
00125     GRange |= GRange >> 2;
00126     GRange |= GRange >> 4;
00127     GRange |= GRange >> 8;
00128     GRange |= GRange >> 16;
00129 \textcolor{preprocessor}{#if \_\_x86\_64\_\_ || \_\_ppc64\_\_ || \_WIN64}
00130     GRange |= GRange >> 32;
00131 \textcolor{preprocessor}{#endif}
00132     GRange++;
00133     \textcolor{keywordtype}{size\_t}  outTileSize = tileSize;
00135     \textcolor{keywordflow}{if} (GRange < outTileSize) outTileSize=GRange;
00136     \textcolor{comment}{// getting final out buffer at the moment the created buffer is true because there is no need for
       assign}
00137     \textcolor{keyword}{auto} out\_buffer =dev.template get\_sycl\_buffer<typename
       Eigen::internal::remove\_all<CoeffReturnType>::type>(\textcolor{keyword}{self}.dimensions().TotalSize(), output);
00141     \textcolor{keyword}{auto} temp\_global\_buffer =cl::sycl::buffer<CoeffReturnType, 1>(cl::sycl::range<1>(GRange));
00142     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1remove__all}{Eigen::internal::remove\_all}<decltype(\textcolor{keyword}{self}.xprDims())>::type
       Dims;
00143     Dims dims= \textcolor{keyword}{self}.xprDims();
00144     Op functor = reducer;
00145     dev.m\_queue.submit([&](cl::sycl::handler &cgh) \{
00146       \textcolor{comment}{// create a tuple of accessors from Evaluator}
00147       \textcolor{keyword}{auto} tuple\_of\_accessors =  TensorSycl::internal::createTupleOfAccessors(cgh, \textcolor{keyword}{self}.impl());
00148       \textcolor{keyword}{auto} tmp\_global\_accessor = temp\_global\_buffer. \textcolor{keyword}{template} 
      get\_access<cl::sycl::access::mode::read\_write, cl::sycl::access::target::global\_buffer>(cgh);
00149 
00150       cgh.parallel\_for<PlaceHolderExpr>( cl::sycl::nd\_range<1>(cl::sycl::range<1>(GRange), 
      cl::sycl::range<1>(outTileSize)), [=](cl::sycl::nd\_item<1> itemID) \{
00151         \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1_tensor_sycl_1_1internal_1_1_convert_to_device_expression}{TensorSycl::internal::ConvertToDeviceExpression<const HostExpr>::Type}
       DevExpr;
00152         \textcolor{keyword}{auto} device\_expr = TensorSycl::internal::createDeviceExpression<DevExpr, PlaceHolderExpr>(functors,
       tuple\_of\_accessors);
00156         \textcolor{keyword}{const} \textcolor{keyword}{auto} device\_self\_expr= \hyperlink{class_eigen_1_1_tensor_reduction_op}{TensorReductionOp}<Op, Dims, decltype(device\_expr.expr
      ) ,MakeGlobalPointer>(device\_expr.expr, dims, functor);
00159         \textcolor{keyword}{auto} device\_self\_evaluator = 
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{Eigen::TensorEvaluator<decltype(device\_self\_expr), Eigen::DefaultDevice>}
      (device\_self\_expr, \hyperlink{struct_eigen_1_1_default_device}{Eigen::DefaultDevice}());
00161         \textcolor{keyword}{auto} globalid=itemID.get\_global\_linear\_id();
00162 
00163         \textcolor{keywordflow}{if}(globalid<rng)
00164           tmp\_global\_accessor.get\_pointer()[globalid]=
      \hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer}{InnerMostDimReducer<decltype(device\_self\_evaluator), Op, false>::reduce}
      (device\_self\_evaluator, red\_factor*globalid, red\_factor, \textcolor{keyword}{const\_cast<}Op&\textcolor{keyword}{>}(functor));
00165         \textcolor{keywordflow}{else}
00166           tmp\_global\_accessor.get\_pointer()[globalid]=\textcolor{keyword}{static\_cast<}CoeffReturnType\textcolor{keyword}{>}(0);
00167 
00168         \textcolor{keywordflow}{if}(remaining!=0 && globalid==0 )
00169           \textcolor{comment}{// this will add the rest of input buffer when the input size is not devidable to red\_factor.}
00170           tmp\_global\_accessor.get\_pointer()[globalid]+=
      \hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer}{InnerMostDimReducer<decltype(device\_self\_evaluator), Op, false>::reduce}
      (device\_self\_evaluator, red\_factor*(rng), remaining, const\_cast<Op&>(functor));
00171       \});
00172     \});
00173   dev.m\_queue.throw\_asynchronous();
00174 
00176   \hyperlink{struct_eigen_1_1internal_1_1sycl_generic_buffer_reducer}{syclGenericBufferReducer<CoeffReturnType,HostExpr>::run}
      (out\_buffer, temp\_global\_buffer,dev, GRange,  outTileSize);
00177   \}
00178 
00179 \};
00180 
00181 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source_l00182}\hyperlink{struct_eigen_1_1internal_1_1_inner_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_01_4}{00182} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_inner_reducer}{InnerReducer}<Self, Op, const \hyperlink{namespace_eigen}{Eigen}::SyclDevice> \{
00183 
00184   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Self::CoeffReturnType CoeffReturnType;
00185   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} HasOptimizedImplementation = \textcolor{keyword}{false};
00186 
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_sycl_8h_source_l00187}\hyperlink{struct_eigen_1_1internal_1_1_inner_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_01_4_a471bb175078f166e0d5c4040fc4494d9}{00187}   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} \hyperlink{struct_eigen_1_1internal_1_1_inner_reducer_3_01_self_00_01_op_00_01const_01_eigen_1_1_sycl_device_01_4_a471bb175078f166e0d5c4040fc4494d9}{run}(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, Op& reducer, \textcolor{keyword}{const} Eigen::SyclDevice& dev, CoeffReturnType* output, \textcolor{keyword}{
      typename} Self::Index , \textcolor{keyword}{typename} Self::Index num\_coeffs\_to\_preserve) \{
00188     \textcolor{keyword}{typedef} \textcolor{keyword}{const} \textcolor{keyword}{typename} Self::ChildType HostExpr; 
00189     \textcolor{keyword}{typedef}  \textcolor{keyword}{typename} TensorSycl::internal::createPlaceHolderExpression<HostExpr>::Type PlaceHolderExpr;
00190     \textcolor{keyword}{auto} functors = TensorSycl::internal::extractFunctors(\textcolor{keyword}{self}.impl());
00191 
00192     \textcolor{keywordtype}{size\_t} tileSize =dev.m\_queue.get\_device(). \textcolor{keyword}{template} 
      get\_info<cl::sycl::info::device::max\_work\_group\_size>()/2;
00193 
00194     \textcolor{keywordtype}{size\_t} GRange=num\_coeffs\_to\_preserve;
00195     \textcolor{keywordflow}{if} (tileSize>GRange) tileSize=GRange;
00196     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(GRange>tileSize)\{
00197       \textcolor{keywordtype}{size\_t} xMode = GRange % tileSize;
00198       \textcolor{keywordflow}{if} (xMode != 0) GRange += (tileSize - xMode);
00199     \}
00200     \textcolor{comment}{// getting final out buffer at the moment the created buffer is true because there is no need for
       assign}
00204 \textcolor{comment}{}    \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1remove__all}{Eigen::internal::remove\_all}<decltype(\textcolor{keyword}{self}.xprDims())>::type
       Dims;
00205     Dims dims= \textcolor{keyword}{self}.xprDims();
00206     Op functor = reducer;
00207 
00208     dev.m\_queue.submit([&](cl::sycl::handler &cgh) \{
00209       \textcolor{comment}{// create a tuple of accessors from Evaluator}
00210       \textcolor{keyword}{auto} tuple\_of\_accessors =  TensorSycl::internal::createTupleOfAccessors(cgh, \textcolor{keyword}{self}.impl());
00211       \textcolor{keyword}{auto} output\_accessor = dev.template get\_sycl\_accessor<cl::sycl::access::mode::discard\_write>(
      num\_coeffs\_to\_preserve,cgh, output);
00212 
00213       cgh.parallel\_for<Self>( cl::sycl::nd\_range<1>(cl::sycl::range<1>(GRange), cl::sycl::range<1>(tileSize
      )), [=](cl::sycl::nd\_item<1> itemID) \{
00214         \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1_tensor_sycl_1_1internal_1_1_convert_to_device_expression}{TensorSycl::internal::ConvertToDeviceExpression<const HostExpr>::Type}
       DevExpr;
00215         \textcolor{keyword}{auto} device\_expr = TensorSycl::internal::createDeviceExpression<DevExpr, PlaceHolderExpr>(functors,
       tuple\_of\_accessors);
00219         \textcolor{keyword}{const} \textcolor{keyword}{auto} device\_self\_expr= \hyperlink{class_eigen_1_1_tensor_reduction_op}{TensorReductionOp}<Op, Dims, decltype(device\_expr.expr
      ) ,MakeGlobalPointer>(device\_expr.expr, dims, functor);
00222         \textcolor{keyword}{typedef} 
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{Eigen::TensorEvaluator<decltype(device\_self\_expr), Eigen::DefaultDevice>}
       DeiceSelf;
00223         \textcolor{keyword}{auto} device\_self\_evaluator = 
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{Eigen::TensorEvaluator<decltype(device\_self\_expr), Eigen::DefaultDevice>}
      (device\_self\_expr, \hyperlink{struct_eigen_1_1_default_device}{Eigen::DefaultDevice}());
00225         \textcolor{keyword}{auto} globalid=itemID.get\_global\_linear\_id();
00226         \textcolor{keywordflow}{if} (globalid< static\_cast<size\_t>(num\_coeffs\_to\_preserve)) \{
00227           \textcolor{keyword}{typename} DeiceSelf::CoeffReturnType accum = functor.initialize();
00228           \hyperlink{struct_eigen_1_1internal_1_1_generic_dim_reducer}{GenericDimReducer<DeiceSelf::NumReducedDims-1, DeiceSelf, Op>::reduce}
      (device\_self\_evaluator, device\_self\_evaluator.firstInput(globalid),\textcolor{keyword}{const\_cast<}Op&\textcolor{keyword}{>}(functor), &accum);
00229           functor.finalize(accum);
00230           output\_accessor.get\_pointer()[globalid]= accum;
00231         \}
00232       \});
00233     \});
00234   dev.m\_queue.throw\_asynchronous();
00235     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00236   \}
00237 \};
00238 
00239 \}  \textcolor{comment}{// end namespace internal}
00240 \}  \textcolor{comment}{// namespace Eigen}
00241 
00242 \textcolor{preprocessor}{#endif  // UNSUPPORTED\_EIGEN\_CXX11\_SRC\_TENSOR\_TENSOR\_REDUCTION\_SYCL\_HPP}
\end{DoxyCode}
