\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2products_2_general_matrix_matrix_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/products/\+General\+Matrix\+Matrix.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2products_2_general_matrix_matrix_8h_source}\index{General\+Matrix\+Matrix.\+h@{General\+Matrix\+Matrix.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_GENERAL\_MATRIX\_MATRIX\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_GENERAL\_MATRIX\_MATRIX\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_LhsScalar, \textcolor{keyword}{typename} \_RhsScalar> \textcolor{keyword}{class }level3\_blocking;
00018 
00019 \textcolor{comment}{/* Specialization for a row-major destination matrix => simple transposition of the product */}
00020 \textcolor{keyword}{template}<
00021   \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00022   \textcolor{keyword}{typename} LhsScalar, \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00023   \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs>
00024 \textcolor{keyword}{struct }general\_matrix\_matrix\_product<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,
      RhsStorageOrder,ConjugateRhs,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}>
00025 \{
00026   \textcolor{keyword}{typedef} gebp\_traits<RhsScalar,LhsScalar> Traits;
00027 
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;
00029   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(
00030     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth,
00031     \textcolor{keyword}{const} LhsScalar* lhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lhsStride,
00032     \textcolor{keyword}{const} RhsScalar* rhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rhsStride,
00033     ResScalar* res, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} resStride,
00034     ResScalar alpha,
00035     level3\_blocking<RhsScalar,LhsScalar>& blocking,
00036     GemmParallelInfo<Index>* info = 0)
00037   \{
00038     \textcolor{comment}{// transpose the product such that the result is column major}
00039     general\_matrix\_matrix\_product<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00040       RhsScalar, RhsStorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}, ConjugateRhs,
00041       LhsScalar, LhsStorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}, ConjugateLhs,
00042       \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}>
00043     ::run(cols,rows,depth,rhs,rhsStride,lhs,lhsStride,res,resStride,alpha,blocking,info);
00044   \}
00045 \};
00046 
00047 \textcolor{comment}{/*  Specialization for a col-major destination matrix}
00048 \textcolor{comment}{ *    => Blocking algorithm following Goto's paper */}
00049 \textcolor{keyword}{template}<
00050   \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00051   \textcolor{keyword}{typename} LhsScalar, \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00052   \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs>
00053 \textcolor{keyword}{struct }general\_matrix\_matrix\_product<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,
      RhsStorageOrder,ConjugateRhs,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}>
00054 \{
00055 
00056 \textcolor{keyword}{typedef} gebp\_traits<LhsScalar,RhsScalar> Traits;
00057 
00058 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;
00059 \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth,
00060   \textcolor{keyword}{const} LhsScalar* \_lhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lhsStride,
00061   \textcolor{keyword}{const} RhsScalar* \_rhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rhsStride,
00062   ResScalar* \_res, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} resStride,
00063   ResScalar alpha,
00064   level3\_blocking<LhsScalar,RhsScalar>& blocking,
00065   GemmParallelInfo<Index>* info = 0)
00066 \{
00067   \textcolor{keyword}{typedef} const\_blas\_data\_mapper<LhsScalar, Index, LhsStorageOrder> LhsMapper;
00068   \textcolor{keyword}{typedef} const\_blas\_data\_mapper<RhsScalar, Index, RhsStorageOrder> RhsMapper;
00069   \textcolor{keyword}{typedef} blas\_data\_mapper<typename Traits::ResScalar, Index, ColMajor> ResMapper;
00070   LhsMapper lhs(\_lhs,lhsStride);
00071   RhsMapper rhs(\_rhs,rhsStride);
00072   ResMapper res(\_res, resStride);
00073 
00074   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} kc = blocking.kc();                   \textcolor{comment}{// cache block size along the K direction}
00075   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} mc = (std::min)(rows,blocking.mc());  \textcolor{comment}{// cache block size along the M direction}
00076   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nc = (std::min)(cols,blocking.nc());  \textcolor{comment}{// cache block size along the N direction}
00077 
00078   gemm\_pack\_lhs<LhsScalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack\_lhs;
00079   gemm\_pack\_rhs<RhsScalar, Index, RhsMapper, Traits::nr, RhsStorageOrder> pack\_rhs;
00080   gebp\_kernel<LhsScalar, RhsScalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> 
      gebp;
00081 
00082 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_OPENMP}
00083   \textcolor{keywordflow}{if}(info)
00084   \{
00085     \textcolor{comment}{// this is the parallel version!}
00086     \textcolor{keywordtype}{int} tid = omp\_get\_thread\_num();
00087     \textcolor{keywordtype}{int} threads = omp\_get\_num\_threads();
00088 
00089     LhsScalar* blockA = blocking.blockA();
00090     eigen\_internal\_assert(blockA!=0);
00091 
00092     std::size\_t sizeB = kc*nc;
00093     ei\_declare\_aligned\_stack\_constructed\_variable(RhsScalar, blockB, sizeB, 0);
00094 
00095     \textcolor{comment}{// For each horizontal panel of the rhs, and corresponding vertical panel of the lhs...}
00096     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<depth; k+=kc)
00097     \{
00098       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_kc = (std::min)(k+kc,depth)-k; \textcolor{comment}{// => rows of B', and cols of the A'}
00099 
00100       \textcolor{comment}{// In order to reduce the chance that a thread has to wait for the other,}
00101       \textcolor{comment}{// let's start by packing B'.}
00102       pack\_rhs(blockB, rhs.getSubMapper(k,0), actual\_kc, nc);
00103 
00104       \textcolor{comment}{// Pack A\_k to A' in a parallel fashion:}
00105       \textcolor{comment}{// each thread packs the sub block A\_k,i to A'\_i where i is the thread id.}
00106 
00107       \textcolor{comment}{// However, before copying to A'\_i, we have to make sure that no other thread is still using it,}
00108       \textcolor{comment}{// i.e., we test that info[tid].users equals 0.}
00109       \textcolor{comment}{// Then, we set info[tid].users to the number of threads to mark that all other threads are going to
       use it.}
00110       \textcolor{keywordflow}{while}(info[tid].users!=0) \{\}
00111       info[tid].users += threads;
00112 
00113       pack\_lhs(blockA+info[tid].lhs\_start*actual\_kc, lhs.getSubMapper(info[tid].lhs\_start,k), actual\_kc, 
      info[tid].lhs\_length);
00114 
00115       \textcolor{comment}{// Notify the other threads that the part A'\_i is ready to go.}
00116       info[tid].sync = k;
00117 
00118       \textcolor{comment}{// Computes C\_i += A' * B' per A'\_i}
00119       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} shift=0; shift<threads; ++shift)
00120       \{
00121         \textcolor{keywordtype}{int} i = (tid+shift)%threads;
00122 
00123         \textcolor{comment}{// At this point we have to make sure that A'\_i has been updated by the thread i,}
00124         \textcolor{comment}{// we use testAndSetOrdered to mimic a volatile access.}
00125         \textcolor{comment}{// However, no need to wait for the B' part which has been updated by the current thread!}
00126         \textcolor{keywordflow}{if} (shift>0) \{
00127           \textcolor{keywordflow}{while}(info[i].sync!=k) \{
00128           \}
00129         \}
00130 
00131         gebp(res.getSubMapper(info[i].lhs\_start, 0), blockA+info[i].lhs\_start*actual\_kc, blockB, info[i].
      lhs\_length, actual\_kc, nc, alpha);
00132       \}
00133 
00134       \textcolor{comment}{// Then keep going as usual with the remaining B'}
00135       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=nc; j<cols; j+=nc)
00136       \{
00137         \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_nc = (std::min)(j+nc,cols)-j;
00138 
00139         \textcolor{comment}{// pack B\_k,j to B'}
00140         pack\_rhs(blockB, rhs.getSubMapper(k,j), actual\_kc, actual\_nc);
00141 
00142         \textcolor{comment}{// C\_j += A' * B'}
00143         gebp(res.getSubMapper(0, j), blockA, blockB, rows, actual\_kc, actual\_nc, alpha);
00144       \}
00145 
00146       \textcolor{comment}{// Release all the sub blocks A'\_i of A' for the current thread,}
00147       \textcolor{comment}{// i.e., we simply decrement the number of users by 1}
00148       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<threads; ++i)
00149         #pragma omp atomic
00150         info[i].users -= 1;
00151     \}
00152   \}
00153   \textcolor{keywordflow}{else}
00154 \textcolor{preprocessor}{#endif // EIGEN\_HAS\_OPENMP}
00155   \{
00156     EIGEN\_UNUSED\_VARIABLE(info);
00157 
00158     \textcolor{comment}{// this is the sequential version!}
00159     std::size\_t sizeA = kc*mc;
00160     std::size\_t sizeB = kc*nc;
00161 
00162     ei\_declare\_aligned\_stack\_constructed\_variable(LhsScalar, blockA, sizeA, blocking.blockA());
00163     ei\_declare\_aligned\_stack\_constructed\_variable(RhsScalar, blockB, sizeB, blocking.blockB());
00164 
00165     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} pack\_rhs\_once = mc!=rows && kc==depth && nc==cols;
00166 
00167     \textcolor{comment}{// For each horizontal panel of the rhs, and corresponding panel of the lhs...}
00168     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i2=0; i2<rows; i2+=mc)
00169     \{
00170       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_mc = (std::min)(i2+mc,rows)-i2;
00171 
00172       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k2=0; k2<depth; k2+=kc)
00173       \{
00174         \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_kc = (std::min)(k2+kc,depth)-k2;
00175 
00176         \textcolor{comment}{// OK, here we have selected one horizontal panel of rhs and one vertical panel of lhs.}
00177         \textcolor{comment}{// => Pack lhs's panel into a sequential chunk of memory (L2/L3 caching)}
00178         \textcolor{comment}{// Note that this panel will be read as many times as the number of blocks in the rhs's}
00179         \textcolor{comment}{// horizontal panel which is, in practice, a very low number.}
00180         pack\_lhs(blockA, lhs.getSubMapper(i2,k2), actual\_kc, actual\_mc);
00181 
00182         \textcolor{comment}{// For each kc x nc block of the rhs's horizontal panel...}
00183         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=0; j2<cols; j2+=nc)
00184         \{
00185           \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_nc = (std::min)(j2+nc,cols)-j2;
00186 
00187           \textcolor{comment}{// We pack the rhs's block into a sequential chunk of memory (L2 caching)}
00188           \textcolor{comment}{// Note that this block will be read a very high number of times, which is equal to the number of}
00189           \textcolor{comment}{// micro horizontal panel of the large rhs's panel (e.g., rows/12 times).}
00190           \textcolor{keywordflow}{if}((!pack\_rhs\_once) || i2==0)
00191             pack\_rhs(blockB, rhs.getSubMapper(k2,j2), actual\_kc, actual\_nc);
00192 
00193           \textcolor{comment}{// Everything is packed, we can now call the panel * block kernel:}
00194           gebp(res.getSubMapper(i2, j2), blockA, blockB, actual\_mc, actual\_kc, actual\_nc, alpha);
00195         \}
00196       \}
00197     \}
00198   \}
00199 \}
00200 
00201 \};
00202 
00203 \textcolor{comment}{/*********************************************************************************}
00204 \textcolor{comment}{*  Specialization of generic\_product\_impl for "large" GEMM, i.e.,}
00205 \textcolor{comment}{*  implementation of the high level wrapper to general\_matrix\_matrix\_product}
00206 \textcolor{comment}{**********************************************************************************/}
00207 
00208 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} Gemm, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest, \textcolor{keyword}{
      typename} BlockingType>
00209 \textcolor{keyword}{struct }gemm\_functor
00210 \{
00211   gemm\_functor(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, Dest& dest, \textcolor{keyword}{const} Scalar& actualAlpha, BlockingType& 
      blocking)
00212     : m\_lhs(lhs), m\_rhs(rhs), m\_dest(dest), m\_actualAlpha(actualAlpha), m\_blocking(blocking)
00213   \{\}
00214 
00215   \textcolor{keywordtype}{void} initParallelSession(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} num\_threads)\textcolor{keyword}{ const}
00216 \textcolor{keyword}{  }\{
00217     m\_blocking.initParallel(m\_lhs.rows(), m\_rhs.cols(), m\_lhs.cols(), num\_threads);
00218     m\_blocking.allocateA();
00219   \}
00220 
00221   \textcolor{keywordtype}{void} operator() (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col=0, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols=-1, 
      GemmParallelInfo<Index>* info=0)\textcolor{keyword}{ const}
00222 \textcolor{keyword}{  }\{
00223     \textcolor{keywordflow}{if}(cols==-1)
00224       cols = m\_rhs.cols();
00225 
00226     Gemm::run(rows, cols, m\_lhs.cols(),
00227               &m\_lhs.coeffRef(row,0), m\_lhs.outerStride(),
00228               &m\_rhs.coeffRef(0,col), m\_rhs.outerStride(),
00229               (Scalar*)&(m\_dest.coeffRef(row,col)), m\_dest.outerStride(),
00230               m\_actualAlpha, m\_blocking, info);
00231   \}
00232 
00233   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Gemm::Traits Traits;
00234 
00235   \textcolor{keyword}{protected}:
00236     \textcolor{keyword}{const} Lhs& m\_lhs;
00237     \textcolor{keyword}{const} Rhs& m\_rhs;
00238     Dest& m\_dest;
00239     Scalar m\_actualAlpha;
00240     BlockingType& m\_blocking;
00241 \};
00242 
00243 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StorageOrder, \textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{int} MaxRows, \textcolor{keywordtype}{int} MaxCols, \textcolor{keywordtype}{int} MaxDepth, \textcolor{keywordtype}{
      int} KcFactor=1,
00244 \textcolor{keywordtype}{bool} FiniteAtCompileTime = MaxRows!=\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} && MaxCols!=\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} && MaxDepth != 
      \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}> \textcolor{keyword}{class }gemm\_blocking\_space;
00245 
00246 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_LhsScalar, \textcolor{keyword}{typename} \_RhsScalar>
00247 \textcolor{keyword}{class }level3\_blocking
00248 \{
00249     \textcolor{keyword}{typedef} \_LhsScalar LhsScalar;
00250     \textcolor{keyword}{typedef} \_RhsScalar RhsScalar;
00251 
00252   \textcolor{keyword}{protected}:
00253     LhsScalar* m\_blockA;
00254     RhsScalar* m\_blockB;
00255 
00256     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_mc;
00257     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_nc;
00258     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_kc;
00259 
00260   \textcolor{keyword}{public}:
00261 
00262     level3\_blocking()
00263       : m\_blockA(0), m\_blockB(0), m\_mc(0), m\_nc(0), m\_kc(0)
00264     \{\}
00265 
00266     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} mc()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_mc; \}
00267     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nc()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_nc; \}
00268     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} kc()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_kc; \}
00269 
00270     \textcolor{keyword}{inline} LhsScalar* blockA() \{ \textcolor{keywordflow}{return} m\_blockA; \}
00271     \textcolor{keyword}{inline} RhsScalar* blockB() \{ \textcolor{keywordflow}{return} m\_blockB; \}
00272 \};
00273 
00274 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StorageOrder, \textcolor{keyword}{typename} \_LhsScalar, \textcolor{keyword}{typename} \_RhsScalar, \textcolor{keywordtype}{int} MaxRows, \textcolor{keywordtype}{int} MaxCols, \textcolor{keywordtype}{int} MaxDepth
      , \textcolor{keywordtype}{int} KcFactor>
00275 \textcolor{keyword}{class }gemm\_blocking\_space<StorageOrder,\_LhsScalar,\_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, true \textcolor{comment}{/*
       == FiniteAtCompileTime */}>
00276   : \textcolor{keyword}{public} level3\_blocking<
00277       typename conditional<StorageOrder==RowMajor,\_RhsScalar,\_LhsScalar>::type,
00278       typename conditional<StorageOrder==RowMajor,\_LhsScalar,\_RhsScalar>::type>
00279 \{
00280     \textcolor{keyword}{enum} \{
00281       Transpose = StorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},
00282       ActualRows = Transpose ? MaxCols : MaxRows,
00283       ActualCols = Transpose ? MaxRows : MaxCols
00284     \};
00285     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Transpose,\_RhsScalar,\_LhsScalar>::type LhsScalar;
00286     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Transpose,\_LhsScalar,\_RhsScalar>::type RhsScalar;
00287     \textcolor{keyword}{typedef} gebp\_traits<LhsScalar,RhsScalar> Traits;
00288     \textcolor{keyword}{enum} \{
00289       SizeA = ActualRows * MaxDepth,
00290       SizeB = ActualCols * MaxDepth
00291     \};
00292 
00293 \textcolor{preprocessor}{#if EIGEN\_MAX\_STATIC\_ALIGN\_BYTES >= EIGEN\_DEFAULT\_ALIGN\_BYTES}
00294     EIGEN\_ALIGN\_MAX LhsScalar m\_staticA[SizeA];
00295     EIGEN\_ALIGN\_MAX RhsScalar m\_staticB[SizeB];
00296 \textcolor{preprocessor}{#else}
00297     EIGEN\_ALIGN\_MAX \textcolor{keywordtype}{char} m\_staticA[SizeA * \textcolor{keyword}{sizeof}(LhsScalar) + EIGEN\_DEFAULT\_ALIGN\_BYTES-1];
00298     EIGEN\_ALIGN\_MAX \textcolor{keywordtype}{char} m\_staticB[SizeB * \textcolor{keyword}{sizeof}(RhsScalar) + EIGEN\_DEFAULT\_ALIGN\_BYTES-1];
00299 \textcolor{preprocessor}{#endif}
00300 
00301   \textcolor{keyword}{public}:
00302 
00303     gemm\_blocking\_space(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \textcolor{comment}{/*rows*/}, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \textcolor{comment}{/*cols*/}, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \textcolor{comment}{/*depth*/}, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \textcolor{comment}{/*num\_threads*/}, \textcolor{keywordtype}{bool} \textcolor{comment}{/*full\_rows = false*/})
00304     \{
00305       this->m\_mc = ActualRows;
00306       this->m\_nc = ActualCols;
00307       this->m\_kc = MaxDepth;
00308 \textcolor{preprocessor}{#if EIGEN\_MAX\_STATIC\_ALIGN\_BYTES >= EIGEN\_DEFAULT\_ALIGN\_BYTES}
00309       this->m\_blockA = m\_staticA;
00310       this->m\_blockB = m\_staticB;
00311 \textcolor{preprocessor}{#else}
00312       this->m\_blockA = \textcolor{keyword}{reinterpret\_cast<}LhsScalar*\textcolor{keyword}{>}((internal::UIntPtr(m\_staticA) + (
      EIGEN\_DEFAULT\_ALIGN\_BYTES-1)) & ~\hyperlink{namespacestd}{std}::size\_t(EIGEN\_DEFAULT\_ALIGN\_BYTES-1));
00313       this->m\_blockB = \textcolor{keyword}{reinterpret\_cast<}RhsScalar*\textcolor{keyword}{>}((internal::UIntPtr(m\_staticB) + (
      EIGEN\_DEFAULT\_ALIGN\_BYTES-1)) & ~\hyperlink{namespacestd}{std}::size\_t(EIGEN\_DEFAULT\_ALIGN\_BYTES-1));
00314 \textcolor{preprocessor}{#endif}
00315     \}
00316 
00317     \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_a820c0e0460934cc17eb6dacbad54a9f5}{initParallel}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index})
00318     \{\}
00319 
00320     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} allocateA() \{\}
00321     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} allocateB() \{\}
00322     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} allocateAll() \{\}
00323 \};
00324 
00325 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StorageOrder, \textcolor{keyword}{typename} \_LhsScalar, \textcolor{keyword}{typename} \_RhsScalar, \textcolor{keywordtype}{int} MaxRows, \textcolor{keywordtype}{int} MaxCols, \textcolor{keywordtype}{int} MaxDepth
      , \textcolor{keywordtype}{int} KcFactor>
00326 \textcolor{keyword}{class }gemm\_blocking\_space<StorageOrder,\_LhsScalar,\_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, false>
00327   : \textcolor{keyword}{public} level3\_blocking<
00328       typename conditional<StorageOrder==RowMajor,\_RhsScalar,\_LhsScalar>::type,
00329       typename conditional<StorageOrder==RowMajor,\_LhsScalar,\_RhsScalar>::type>
00330 \{
00331     \textcolor{keyword}{enum} \{
00332       Transpose = StorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}
00333     \};
00334     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Transpose,\_RhsScalar,\_LhsScalar>::type LhsScalar;
00335     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Transpose,\_LhsScalar,\_RhsScalar>::type RhsScalar;
00336     \textcolor{keyword}{typedef} gebp\_traits<LhsScalar,RhsScalar> Traits;
00337 
00338     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_sizeA;
00339     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_sizeB;
00340 
00341   \textcolor{keyword}{public}:
00342 
00343     gemm\_blocking\_space(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} num\_threads, \textcolor{keywordtype}{bool} l3\_blocking)
00344     \{
00345       this->m\_mc = Transpose ? cols : rows;
00346       this->m\_nc = Transpose ? rows : cols;
00347       this->m\_kc = depth;
00348 
00349       \textcolor{keywordflow}{if}(l3\_blocking)
00350       \{
00351         computeProductBlockingSizes<LhsScalar,RhsScalar,KcFactor>(this->m\_kc, this->m\_mc, this->m\_nc, 
      num\_threads);
00352       \}
00353       \textcolor{keywordflow}{else}  \textcolor{comment}{// no l3 blocking}
00354       \{
00355         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = this->m\_nc;
00356         computeProductBlockingSizes<LhsScalar,RhsScalar,KcFactor>(this->m\_kc, this->m\_mc, n, num\_threads);
00357       \}
00358 
00359       m\_sizeA = this->m\_mc * this->m\_kc;
00360       m\_sizeB = this->m\_kc * this->m\_nc;
00361     \}
00362 
00363     \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_a820c0e0460934cc17eb6dacbad54a9f5}{initParallel}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} num\_threads)
00364     \{
00365       this->m\_mc = Transpose ? cols : rows;
00366       this->m\_nc = Transpose ? rows : cols;
00367       this->m\_kc = depth;
00368 
00369       eigen\_internal\_assert(this->m\_blockA==0 && this->m\_blockB==0);
00370       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m = this->m\_mc;
00371       computeProductBlockingSizes<LhsScalar,RhsScalar,KcFactor>(this->m\_kc, m, this->m\_nc, num\_threads);
00372       m\_sizeA = this->m\_mc * this->m\_kc;
00373       m\_sizeB = this->m\_kc * this->m\_nc;
00374     \}
00375 
00376     \textcolor{keywordtype}{void} allocateA()
00377     \{
00378       \textcolor{keywordflow}{if}(this->m\_blockA==0)
00379         this->m\_blockA = aligned\_new<LhsScalar>(m\_sizeA);
00380     \}
00381 
00382     \textcolor{keywordtype}{void} allocateB()
00383     \{
00384       \textcolor{keywordflow}{if}(this->m\_blockB==0)
00385         this->m\_blockB = aligned\_new<RhsScalar>(m\_sizeB);
00386     \}
00387 
00388     \textcolor{keywordtype}{void} allocateAll()
00389     \{
00390       allocateA();
00391       allocateB();
00392     \}
00393 
00394     ~gemm\_blocking\_space()
00395     \{
00396       aligned\_delete(this->m\_blockA, m\_sizeA);
00397       aligned\_delete(this->m\_blockB, m\_sizeB);
00398     \}
00399 \};
00400 
00401 \} \textcolor{comment}{// end namespace internal}
00402 
00403 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00404 
00405 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00406 \textcolor{keyword}{struct }generic\_product\_impl<Lhs,Rhs,DenseShape,DenseShape,GemmProduct>
00407   : generic\_product\_impl\_base<Lhs,Rhs,generic\_product\_impl<Lhs,Rhs,DenseShape,DenseShape,GemmProduct> >
00408 \{
00409   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Product<Lhs,Rhs>::Scalar Scalar;
00410   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Lhs::Scalar LhsScalar;
00411   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Rhs::Scalar RhsScalar;
00412 
00413   \textcolor{keyword}{typedef} internal::blas\_traits<Lhs> LhsBlasTraits;
00414   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsBlasTraits::DirectLinearAccessType ActualLhsType;
00415   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ActualLhsType>::type ActualLhsTypeCleaned;
00416 
00417   \textcolor{keyword}{typedef} internal::blas\_traits<Rhs> RhsBlasTraits;
00418   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsBlasTraits::DirectLinearAccessType ActualRhsType;
00419   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ActualRhsType>::type ActualRhsTypeCleaned;
00420 
00421   \textcolor{keyword}{enum} \{
00422     MaxDepthAtCompileTime = EIGEN\_SIZE\_MIN\_PREFER\_FIXED(Lhs::MaxColsAtCompileTime,Rhs::MaxRowsAtCompileTime
      )
00423   \};
00424 
00425   \textcolor{keyword}{typedef} generic\_product\_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode> lazyproduct;
00426 
00427   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst>
00428   \textcolor{keyword}{static} \textcolor{keywordtype}{void} evalTo(Dst& dst, \textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs)
00429   \{
00430     \textcolor{keywordflow}{if}((rhs.rows()+dst.rows()+dst.cols())<20 && rhs.rows()>0)
00431       lazyproduct::evalTo(dst, lhs, rhs);
00432     \textcolor{keywordflow}{else}
00433     \{
00434       dst.setZero();
00435       scaleAndAddTo(dst, lhs, rhs, Scalar(1));
00436     \}
00437   \}
00438 
00439   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst>
00440   \textcolor{keyword}{static} \textcolor{keywordtype}{void} addTo(Dst& dst, \textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs)
00441   \{
00442     \textcolor{keywordflow}{if}((rhs.rows()+dst.rows()+dst.cols())<20 && rhs.rows()>0)
00443       lazyproduct::addTo(dst, lhs, rhs);
00444     \textcolor{keywordflow}{else}
00445       scaleAndAddTo(dst,lhs, rhs, Scalar(1));
00446   \}
00447 
00448   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst>
00449   \textcolor{keyword}{static} \textcolor{keywordtype}{void} subTo(Dst& dst, \textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs)
00450   \{
00451     \textcolor{keywordflow}{if}((rhs.rows()+dst.rows()+dst.cols())<20 && rhs.rows()>0)
00452       lazyproduct::subTo(dst, lhs, rhs);
00453     \textcolor{keywordflow}{else}
00454       scaleAndAddTo(dst, lhs, rhs, Scalar(-1));
00455   \}
00456 
00457   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00458   \textcolor{keyword}{static} \textcolor{keywordtype}{void} scaleAndAddTo(Dest& dst, \textcolor{keyword}{const} Lhs& a\_lhs, \textcolor{keyword}{const} Rhs& a\_rhs, \textcolor{keyword}{const} Scalar& alpha)
00459   \{
00460     eigen\_assert(dst.rows()==a\_lhs.rows() && dst.cols()==a\_rhs.cols());
00461     \textcolor{keywordflow}{if}(a\_lhs.cols()==0 || a\_lhs.rows()==0 || a\_rhs.cols()==0)
00462       \textcolor{keywordflow}{return};
00463 
00464     \textcolor{keyword}{typename} internal::add\_const\_on\_value\_type<ActualLhsType>::type lhs = LhsBlasTraits::extract(a\_lhs);
00465     \textcolor{keyword}{typename} internal::add\_const\_on\_value\_type<ActualRhsType>::type rhs = RhsBlasTraits::extract(a\_rhs);
00466 
00467     Scalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(a\_lhs)
00468                                * RhsBlasTraits::extractScalarFactor(a\_rhs);
00469 
00470     \textcolor{keyword}{typedef} internal::gemm\_blocking\_space<(Dest::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},LhsScalar,RhsScalar,
00471             Dest::MaxRowsAtCompileTime,Dest::MaxColsAtCompileTime,MaxDepthAtCompileTime> BlockingType;
00472 
00473     \textcolor{keyword}{typedef} internal::gemm\_functor<
00474       Scalar, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00475       internal::general\_matrix\_matrix\_product<
00476         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00477         LhsScalar, (ActualLhsTypeCleaned::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : ColMajor, \textcolor{keywordtype}{bool}(LhsBlasTraits::NeedToConjugate),
00478         RhsScalar, (ActualRhsTypeCleaned::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : ColMajor, \textcolor{keywordtype}{bool}(RhsBlasTraits::NeedToConjugate),
00479         (Dest::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : ColMajor>,
00480       ActualLhsTypeCleaned, ActualRhsTypeCleaned, Dest, BlockingType> GemmFunctor;
00481 
00482     BlockingType blocking(dst.rows(), dst.cols(), lhs.cols(), 1, \textcolor{keyword}{true});
00483     internal::parallelize\_gemm<(Dest::MaxRowsAtCompileTime>32 || Dest::MaxRowsAtCompileTime==
      \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic})>
00484         (GemmFunctor(lhs, rhs, dst, actualAlpha, blocking), a\_lhs.rows(), a\_rhs.cols(), a\_lhs.cols(), 
      Dest::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit});
00485   \}
00486 \};
00487 
00488 \} \textcolor{comment}{// end namespace internal}
00489 
00490 \} \textcolor{comment}{// end namespace Eigen}
00491 
00492 \textcolor{preprocessor}{#endif // EIGEN\_GENERAL\_MATRIX\_MATRIX\_H}
\end{DoxyCode}
