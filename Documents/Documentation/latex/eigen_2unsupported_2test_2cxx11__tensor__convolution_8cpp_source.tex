\hypertarget{eigen_2unsupported_2test_2cxx11__tensor__convolution_8cpp_source}{}\section{eigen/unsupported/test/cxx11\+\_\+tensor\+\_\+convolution.cpp}
\label{eigen_2unsupported_2test_2cxx11__tensor__convolution_8cpp_source}\index{cxx11\+\_\+tensor\+\_\+convolution.\+cpp@{cxx11\+\_\+tensor\+\_\+convolution.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{preprocessor}{#include <Eigen/CXX11/Tensor>}
00013 
00014 \textcolor{keyword}{using} \hyperlink{class_eigen_1_1_tensor}{Eigen::Tensor};
00015 \textcolor{keyword}{using} \hyperlink{struct_eigen_1_1_default_device}{Eigen::DefaultDevice};
00016 
00017 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} DataLayout>
00018 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_evals()
00019 \{
00020   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 2, DataLayout>} input(3, 3);
00021   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 1, DataLayout>} kernel(2);
00022 
00023   input.setRandom();
00024   kernel.setRandom();
00025 
00026   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 2, DataLayout>} result(2,3);
00027   result.setZero();
00028   \hyperlink{class_eigen_1_1array}{Eigen::array<Tensor<float, 2>::Index}, 1> dims3\{\{0\}\};
00029 
00030   \textcolor{keyword}{typedef} TensorEvaluator<decltype(input.convolve(kernel, dims3)), \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}> Evaluator;
00031   Evaluator eval(input.convolve(kernel, dims3), \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}());
00032   eval.evalTo(result.data());
00033   EIGEN\_STATIC\_ASSERT(Evaluator::NumDims==2ul, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00034   VERIFY\_IS\_EQUAL(eval.dimensions()[0], 2);
00035   VERIFY\_IS\_EQUAL(eval.dimensions()[1], 3);
00036 
00037   VERIFY\_IS\_APPROX(result(0,0), input(0,0)*kernel(0) + input(1,0)*kernel(1));  \textcolor{comment}{// index 0}
00038   VERIFY\_IS\_APPROX(result(0,1), input(0,1)*kernel(0) + input(1,1)*kernel(1));  \textcolor{comment}{// index 2}
00039   VERIFY\_IS\_APPROX(result(0,2), input(0,2)*kernel(0) + input(1,2)*kernel(1));  \textcolor{comment}{// index 4}
00040   VERIFY\_IS\_APPROX(result(1,0), input(1,0)*kernel(0) + input(2,0)*kernel(1));  \textcolor{comment}{// index 1}
00041   VERIFY\_IS\_APPROX(result(1,1), input(1,1)*kernel(0) + input(2,1)*kernel(1));  \textcolor{comment}{// index 3}
00042   VERIFY\_IS\_APPROX(result(1,2), input(1,2)*kernel(0) + input(2,2)*kernel(1));  \textcolor{comment}{// index 5}
00043 \}
00044 
00045 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} DataLayout>
00046 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_expr()
00047 \{
00048   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 2, DataLayout>} input(3, 3);
00049   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 2, DataLayout>} kernel(2, 2);
00050   input.setRandom();
00051   kernel.setRandom();
00052 
00053   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 2, DataLayout>} result(2,2);
00054   \hyperlink{class_eigen_1_1array}{Eigen::array<ptrdiff\_t, 2>} dims;
00055   dims[0] = 0;
00056   dims[1] = 1;
00057   result = input.convolve(kernel, dims);
00058 
00059   VERIFY\_IS\_APPROX(result(0,0), input(0,0)*kernel(0,0) + input(0,1)*kernel(0,1) +
00060                                 input(1,0)*kernel(1,0) + input(1,1)*kernel(1,1));
00061   VERIFY\_IS\_APPROX(result(0,1), input(0,1)*kernel(0,0) + input(0,2)*kernel(0,1) +
00062                                 input(1,1)*kernel(1,0) + input(1,2)*kernel(1,1));
00063   VERIFY\_IS\_APPROX(result(1,0), input(1,0)*kernel(0,0) + input(1,1)*kernel(0,1) +
00064                                 input(2,0)*kernel(1,0) + input(2,1)*kernel(1,1));
00065   VERIFY\_IS\_APPROX(result(1,1), input(1,1)*kernel(0,0) + input(1,2)*kernel(0,1) +
00066                                 input(2,1)*kernel(1,0) + input(2,2)*kernel(1,1));
00067 \}
00068 
00069 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} DataLayout>
00070 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_modes() \{
00071   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 1, DataLayout>} input(3);
00072   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 1, DataLayout>} kernel(3);
00073   input(0) = 1.0f;
00074   input(1) = 2.0f;
00075   input(2) = 3.0f;
00076   kernel(0) = 0.5f;
00077   kernel(1) = 1.0f;
00078   kernel(2) = 0.0f;
00079 
00080   \hyperlink{class_eigen_1_1array}{Eigen::array<ptrdiff\_t, 1>} dims;
00081   dims[0] = 0;
00082   \hyperlink{class_eigen_1_1array}{Eigen::array<std::pair<ptrdiff\_t, ptrdiff\_t>}, 1> padding;
00083 
00084   \textcolor{comment}{// Emulate VALID mode (as defined in}
00085   \textcolor{comment}{// http://docs.scipy.org/doc/numpy/reference/generated/numpy.convolve.html).}
00086   padding[0] = std::make\_pair(0, 0);
00087   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 1, DataLayout>} valid(1);
00088   valid = input.pad(padding).convolve(kernel, dims);
00089   VERIFY\_IS\_EQUAL(valid.dimension(0), 1);
00090   VERIFY\_IS\_APPROX(valid(0), 2.5f);
00091 
00092   \textcolor{comment}{// Emulate SAME mode (as defined in}
00093   \textcolor{comment}{// http://docs.scipy.org/doc/numpy/reference/generated/numpy.convolve.html).}
00094   padding[0] = std::make\_pair(1, 1);
00095   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 1, DataLayout>} same(3);
00096   same = input.pad(padding).convolve(kernel, dims);
00097   VERIFY\_IS\_EQUAL(same.dimension(0), 3);
00098   VERIFY\_IS\_APPROX(same(0), 1.0f);
00099   VERIFY\_IS\_APPROX(same(1), 2.5f);
00100   VERIFY\_IS\_APPROX(same(2), 4.0f);
00101 
00102   \textcolor{comment}{// Emulate FULL mode (as defined in}
00103   \textcolor{comment}{// http://docs.scipy.org/doc/numpy/reference/generated/numpy.convolve.html).}
00104   padding[0] = std::make\_pair(2, 2);
00105   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 1, DataLayout>} full(5);
00106   full = input.pad(padding).convolve(kernel, dims);
00107   VERIFY\_IS\_EQUAL(full.dimension(0), 5);
00108   VERIFY\_IS\_APPROX(full(0), 0.0f);
00109   VERIFY\_IS\_APPROX(full(1), 1.0f);
00110   VERIFY\_IS\_APPROX(full(2), 2.5f);
00111   VERIFY\_IS\_APPROX(full(3), 4.0f);
00112   VERIFY\_IS\_APPROX(full(4), 1.5f);
00113 \}
00114 
00115 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} DataLayout>
00116 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_strides() \{
00117   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 1, DataLayout>} input(13);
00118   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 1, DataLayout>} kernel(3);
00119   input.setRandom();
00120   kernel.setRandom();
00121 
00122   \hyperlink{class_eigen_1_1array}{Eigen::array<ptrdiff\_t, 1>} dims;
00123   dims[0] = 0;
00124   \hyperlink{class_eigen_1_1array}{Eigen::array<ptrdiff\_t, 1>} stride\_of\_3;
00125   stride\_of\_3[0] = 3;
00126   \hyperlink{class_eigen_1_1array}{Eigen::array<ptrdiff\_t, 1>} stride\_of\_2;
00127   stride\_of\_2[0] = 2;
00128 
00129   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 1, DataLayout>} result;
00130   result = input.stride(stride\_of\_3).convolve(kernel, dims).stride(stride\_of\_2);
00131 
00132   VERIFY\_IS\_EQUAL(result.dimension(0), 2);
00133   VERIFY\_IS\_APPROX(result(0), (input(0)*kernel(0) + input(3)*kernel(1) +
00134                                input(6)*kernel(2)));
00135   VERIFY\_IS\_APPROX(result(1), (input(6)*kernel(0) + input(9)*kernel(1) +
00136                                input(12)*kernel(2)));
00137 \}
00138 
00139 \textcolor{keywordtype}{void} test\_cxx11\_tensor\_convolution()
00140 \{
00141   CALL\_SUBTEST(test\_evals<ColMajor>());
00142   CALL\_SUBTEST(test\_evals<RowMajor>());
00143   CALL\_SUBTEST(test\_expr<ColMajor>());
00144   CALL\_SUBTEST(test\_expr<RowMajor>());
00145   CALL\_SUBTEST(test\_modes<ColMajor>());
00146   CALL\_SUBTEST(test\_modes<RowMajor>());
00147   CALL\_SUBTEST(test\_strides<ColMajor>());
00148   CALL\_SUBTEST(test\_strides<RowMajor>());
00149 \}
\end{DoxyCode}
