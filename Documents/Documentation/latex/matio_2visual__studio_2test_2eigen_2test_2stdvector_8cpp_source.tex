\hypertarget{matio_2visual__studio_2test_2eigen_2test_2stdvector_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/stdvector.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2stdvector_8cpp_source}\index{stdvector.\+cpp@{stdvector.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 \textcolor{preprocessor}{#include <Eigen/StdVector>}
00012 \textcolor{preprocessor}{#include <Eigen/Geometry>}
00013 
00014 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00015 \textcolor{keywordtype}{void} check\_stdvector\_matrix(\textcolor{keyword}{const} MatrixType& m)
00016 \{
00017   \textcolor{keyword}{typename} MatrixType::Index rows = m.rows();
00018   \textcolor{keyword}{typename} MatrixType::Index cols = m.cols();
00019   MatrixType x = MatrixType::Random(rows,cols), y = MatrixType::Random(rows,cols);
00020   std::vector<MatrixType,Eigen::aligned\_allocator<MatrixType> > v(10, MatrixType(rows,cols)), w(20, y);
00021   v[5] = x;
00022   w[6] = v[5];
00023   VERIFY\_IS\_APPROX(w[6], v[5]);
00024   v = w;
00025   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00026   \{
00027     VERIFY\_IS\_APPROX(w[i], v[i]);
00028   \}
00029 
00030   v.resize(21);
00031   v[20] = x;
00032   VERIFY\_IS\_APPROX(v[20], x);
00033   v.resize(22,y);
00034   VERIFY\_IS\_APPROX(v[21], y);
00035   v.push\_back(x);
00036   VERIFY\_IS\_APPROX(v[22], x);
00037   VERIFY((internal::UIntPtr)&(v[22]) == (internal::UIntPtr)&(v[21]) + \textcolor{keyword}{sizeof}(MatrixType));
00038 
00039   \textcolor{comment}{// do a lot of push\_back such that the vector gets internally resized}
00040   \textcolor{comment}{// (with memory reallocation)}
00041   MatrixType* ref = &w[0];
00042   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<30 || ((ref==&w[0]) && i<300); ++i)
00043     v.push\_back(w[i%w.size()]);
00044   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=23; i<v.size(); ++i)
00045   \{
00046     VERIFY(v[i]==w[(i-23)%w.size()]);
00047   \}
00048 \}
00049 
00050 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TransformType>
00051 \textcolor{keywordtype}{void} check\_stdvector\_transform(\textcolor{keyword}{const} TransformType&)
00052 \{
00053   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} TransformType::MatrixType MatrixType;
00054   TransformType x(MatrixType::Random()), y(MatrixType::Random());
00055   std::vector<TransformType,Eigen::aligned\_allocator<TransformType> > v(10), w(20, y);
00056   v[5] = x;
00057   w[6] = v[5];
00058   VERIFY\_IS\_APPROX(w[6], v[5]);
00059   v = w;
00060   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00061   \{
00062     VERIFY\_IS\_APPROX(w[i], v[i]);
00063   \}
00064 
00065   v.resize(21);
00066   v[20] = x;
00067   VERIFY\_IS\_APPROX(v[20], x);
00068   v.resize(22,y);
00069   VERIFY\_IS\_APPROX(v[21], y);
00070   v.push\_back(x);
00071   VERIFY\_IS\_APPROX(v[22], x);
00072   VERIFY((internal::UIntPtr)&(v[22]) == (internal::UIntPtr)&(v[21]) + \textcolor{keyword}{sizeof}(TransformType));
00073 
00074   \textcolor{comment}{// do a lot of push\_back such that the vector gets internally resized}
00075   \textcolor{comment}{// (with memory reallocation)}
00076   TransformType* ref = &w[0];
00077   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<30 || ((ref==&w[0]) && i<300); ++i)
00078     v.push\_back(w[i%w.size()]);
00079   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=23; i<v.size(); ++i)
00080   \{
00081     VERIFY(v[i].matrix()==w[(i-23)%w.size()].matrix());
00082   \}
00083 \}
00084 
00085 \textcolor{keyword}{template}<\textcolor{keyword}{typename} QuaternionType>
00086 \textcolor{keywordtype}{void} check\_stdvector\_quaternion(\textcolor{keyword}{const} QuaternionType&)
00087 \{
00088   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} QuaternionType::Coefficients Coefficients;
00089   QuaternionType x(Coefficients::Random()), y(Coefficients::Random());
00090   std::vector<QuaternionType,Eigen::aligned\_allocator<QuaternionType> > v(10), w(20, y);
00091   v[5] = x;
00092   w[6] = v[5];
00093   VERIFY\_IS\_APPROX(w[6], v[5]);
00094   v = w;
00095   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00096   \{
00097     VERIFY\_IS\_APPROX(w[i], v[i]);
00098   \}
00099 
00100   v.resize(21);
00101   v[20] = x;
00102   VERIFY\_IS\_APPROX(v[20], x);
00103   v.resize(22,y);
00104   VERIFY\_IS\_APPROX(v[21], y);
00105   v.push\_back(x);
00106   VERIFY\_IS\_APPROX(v[22], x);
00107   VERIFY((internal::UIntPtr)&(v[22]) == (internal::UIntPtr)&(v[21]) + \textcolor{keyword}{sizeof}(QuaternionType));
00108 
00109   \textcolor{comment}{// do a lot of push\_back such that the vector gets internally resized}
00110   \textcolor{comment}{// (with memory reallocation)}
00111   QuaternionType* ref = &w[0];
00112   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<30 || ((ref==&w[0]) && i<300); ++i)
00113     v.push\_back(w[i%w.size()]);
00114   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=23; i<v.size(); ++i)
00115   \{
00116     VERIFY(v[i].coeffs()==w[(i-23)%w.size()].coeffs());
00117   \}
00118 \}
00119 
00120 \textcolor{keywordtype}{void} test\_stdvector()
00121 \{
00122   \textcolor{comment}{// some non vectorizable fixed sizes}
00123   CALL\_SUBTEST\_1(check\_stdvector\_matrix(Vector2f()));
00124   CALL\_SUBTEST\_1(check\_stdvector\_matrix(Matrix3f()));
00125   CALL\_SUBTEST\_2(check\_stdvector\_matrix(Matrix3d()));
00126 
00127   \textcolor{comment}{// some vectorizable fixed sizes}
00128   CALL\_SUBTEST\_1(check\_stdvector\_matrix(Matrix2f()));
00129   CALL\_SUBTEST\_1(check\_stdvector\_matrix(Vector4f()));
00130   CALL\_SUBTEST\_1(check\_stdvector\_matrix(Matrix4f()));
00131   CALL\_SUBTEST\_2(check\_stdvector\_matrix(Matrix4d()));
00132 
00133   \textcolor{comment}{// some dynamic sizes}
00134   CALL\_SUBTEST\_3(check\_stdvector\_matrix(MatrixXd(1,1)));
00135   CALL\_SUBTEST\_3(check\_stdvector\_matrix(VectorXd(20)));
00136   CALL\_SUBTEST\_3(check\_stdvector\_matrix(RowVectorXf(20)));
00137   CALL\_SUBTEST\_3(check\_stdvector\_matrix(MatrixXcf(10,10)));
00138 
00139   \textcolor{comment}{// some Transform}
00140   CALL\_SUBTEST\_4(check\_stdvector\_transform(\hyperlink{group___geometry___module_ga8c0a922ca75a04ef2f6c310dad0a4ab8}{Projective2f}()));
00141   CALL\_SUBTEST\_4(check\_stdvector\_transform(\hyperlink{group___geometry___module_gab14804071b7486b6666f3d324475a478}{Projective3f}()));
00142   CALL\_SUBTEST\_4(check\_stdvector\_transform(\hyperlink{group___geometry___module_gab9cec8c457da930391eb73370e07aaae}{Projective3d}()));
00143   \textcolor{comment}{//CALL\_SUBTEST(heck\_stdvector\_transform(Projective4d()));}
00144 
00145   \textcolor{comment}{// some Quaternion}
00146   CALL\_SUBTEST\_5(check\_stdvector\_quaternion(\hyperlink{group___geometry___module_ga785b13a5a87f9bf55d4eba51ead2dcf0}{Quaternionf}()));
00147   CALL\_SUBTEST\_5(check\_stdvector\_quaternion(\hyperlink{group___geometry___module_ga6e77eb8b6aae0e04be2db88107dbc642}{Quaterniond}()));
00148 \}
\end{DoxyCode}
