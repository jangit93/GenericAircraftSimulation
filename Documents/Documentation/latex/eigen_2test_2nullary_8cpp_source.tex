\hypertarget{eigen_2test_2nullary_8cpp_source}{}\section{eigen/test/nullary.cpp}
\label{eigen_2test_2nullary_8cpp_source}\index{nullary.\+cpp@{nullary.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2010-2011 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00005 \textcolor{comment}{// Copyright (C) 2016 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#include "main.h"}
00012 
00013 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00014 \textcolor{keywordtype}{bool} equalsIdentity(\textcolor{keyword}{const} MatrixType& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A})
00015 \{
00016   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00017   Scalar zero = \textcolor{keyword}{static\_cast<}Scalar\textcolor{keyword}{>}(0);
00018 
00019   \textcolor{keywordtype}{bool} offDiagOK = \textcolor{keyword}{true};
00020   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < A.rows(); ++i) \{
00021     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = i+1; j < A.cols(); ++j) \{
00022       offDiagOK = offDiagOK && (A(i,j) == zero);
00023     \}
00024   \}
00025   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < A.rows(); ++i) \{
00026     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < (std::min)(i, A.cols()); ++j) \{
00027       offDiagOK = offDiagOK && (A(i,j) == zero);
00028     \}
00029   \}
00030 
00031   \textcolor{keywordtype}{bool} diagOK = (A.diagonal().array() == 1).all();
00032   \textcolor{keywordflow}{return} offDiagOK && diagOK;
00033 
00034 \}
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} VectorType>
00037 \textcolor{keywordtype}{void} check\_extremity\_accuracy(\textcolor{keyword}{const} \hyperlink{struct_vector_type}{VectorType} &v, \textcolor{keyword}{const} \textcolor{keyword}{typename} VectorType::Scalar &low, \textcolor{keyword}{const} \textcolor{keyword}{
      typename} VectorType::Scalar &high)
00038 \{
00039   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::Scalar Scalar;
00040   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::RealScalar RealScalar;
00041 
00042   RealScalar prec = internal::is\_same<RealScalar,float>::value ? 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::dummy\_precision}()*10 : 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::dummy\_precision}()/10;
00043   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = v.size();
00044 
00045   \textcolor{keywordflow}{if}(size<20)
00046     \textcolor{keywordflow}{return};
00047 
00048   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00049   \{
00050     \textcolor{keywordflow}{if}(i<5 || i>size-6)
00051     \{
00052       Scalar ref = (low*RealScalar(size-i-1))/RealScalar(size-1) + (high*RealScalar(i))/RealScalar(size-1);
00053       \textcolor{keywordflow}{if}(std::abs(ref)>1)
00054       \{
00055         \textcolor{keywordflow}{if}(!internal::isApprox(v(i), ref, prec))
00056           std::cout << v(i) << \textcolor{stringliteral}{" != "} << ref << \textcolor{stringliteral}{"  ; relative error: "} << std::abs((v(i)-ref)/ref) << \textcolor{stringliteral}{"  ;
       required precision: "} << prec << \textcolor{stringliteral}{"  ; range: "} << low << \textcolor{stringliteral}{","} << high << \textcolor{stringliteral}{"  ; i: "} << i << \textcolor{stringliteral}{"\(\backslash\)n"};
00057         VERIFY(internal::isApprox(v(i), (low*RealScalar(size-i-1))/RealScalar(size-1) + (high*RealScalar(i)
      )/RealScalar(size-1), prec));
00058       \}
00059     \}
00060   \}
00061 \}
00062 
00063 \textcolor{keyword}{template}<\textcolor{keyword}{typename} VectorType>
00064 \textcolor{keywordtype}{void} testVectorType(\textcolor{keyword}{const} \hyperlink{struct_vector_type}{VectorType}& base)
00065 \{
00066   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::Scalar Scalar;
00067   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::RealScalar RealScalar;
00068 
00069   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = base.size();
00070   
00071   Scalar high = internal::random<Scalar>(-500,500);
00072   Scalar low = (size == 1 ? high : internal::random<Scalar>(-500,500));
00073   \textcolor{keywordflow}{if} (low>high) \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(low,high);
00074 
00075   \textcolor{comment}{// check low==high}
00076   \textcolor{keywordflow}{if}(internal::random<float>(0.f,1.f)<0.05f)
00077     low = high;
00078   \textcolor{comment}{// check abs(low) >> abs(high)}
00079   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(size>2 && std::numeric\_limits<RealScalar>::max\_exponent10>0 && internal::random<float>(0.f,1.f)<0
      .1f)
00080     low = -internal::random<Scalar>(1,2) * RealScalar(std::pow(RealScalar(10),
      std::numeric\_limits<RealScalar>::max\_exponent10/2));
00081 
00082   \textcolor{keyword}{const} Scalar step = ((size == 1) ? 1 : (high-low)/(size-1));
00083 
00084   \textcolor{comment}{// check whether the result yields what we expect it to do}
00085   \hyperlink{struct_vector_type}{VectorType} m(base);
00086   m.setLinSpaced(size,low,high);
00087 
00088   \textcolor{keywordflow}{if}(!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsInteger})
00089   \{
00090     \hyperlink{struct_vector_type}{VectorType} n(size);
00091     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00092       n(i) = low+i*step;
00093     VERIFY\_IS\_APPROX(m,n);
00094 
00095     CALL\_SUBTEST( check\_extremity\_accuracy(m, low, high) );
00096   \}
00097 
00098   \textcolor{keywordflow}{if}((!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsInteger}) || ((high-low)>=size && (
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(high-low)%(size-1))==0) || (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(high-low+1)<size && (size%
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(high-low+1))==0))
00099   \{
00100     \hyperlink{struct_vector_type}{VectorType} n(size);
00101     \textcolor{keywordflow}{if}((!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsInteger}) || (high-low>=size))
00102       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00103         n(i) = size==1 ? low : (low + ((high-low)*Scalar(i))/(size-1));
00104     \textcolor{keywordflow}{else}
00105       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00106         n(i) = size==1 ? low : low + Scalar((\textcolor{keywordtype}{double}(high-low+1)*\textcolor{keywordtype}{double}(i))/\textcolor{keywordtype}{double}(size));
00107     VERIFY\_IS\_APPROX(m,n);
00108 
00109     \textcolor{comment}{// random access version}
00110     m = VectorType::LinSpaced(size,low,high);
00111     VERIFY\_IS\_APPROX(m,n);
00112     VERIFY( internal::isApprox(m(m.size()-1),high) );
00113     VERIFY( size==1 || internal::isApprox(m(0),low) );
00114     VERIFY\_IS\_EQUAL(m(m.size()-1) , high);
00115     \textcolor{keywordflow}{if}(!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsInteger})
00116       CALL\_SUBTEST( check\_extremity\_accuracy(m, low, high) );
00117   \}
00118 
00119   VERIFY( m(m.size()-1) <= high );
00120   VERIFY( (m.array() <= high).all() );
00121   VERIFY( (m.array() >= low).all() );
00122 
00123 
00124   VERIFY( m(m.size()-1) >= low );
00125   \textcolor{keywordflow}{if}(size>=1)
00126   \{
00127     VERIFY( internal::isApprox(m(0),low) );
00128     VERIFY\_IS\_EQUAL(m(0) , low);
00129   \}
00130 
00131   \textcolor{comment}{// check whether everything works with row and col major vectors}
00132   \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} row\_vector(size);
00133   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,1,Dynamic>} col\_vector(size);
00134   row\_vector.setLinSpaced(size,low,high);
00135   col\_vector.setLinSpaced(size,low,high);
00136   \textcolor{comment}{// when using the extended precision (e.g., FPU) the relative error might exceed 1 bit}
00137   \textcolor{comment}{// when computing the squared sum in isApprox, thus the 2x factor.}
00138   VERIFY( row\_vector.isApprox(col\_vector.transpose(), Scalar(2)*
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}()));
00139 
00140   \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} size\_changer(size+50);
00141   size\_changer.setLinSpaced(size,low,high);
00142   VERIFY( size\_changer.size() == size );
00143 
00144   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,1,1>} ScalarMatrix;
00145   ScalarMatrix scalar;
00146   scalar.setLinSpaced(1,low,high);
00147   VERIFY\_IS\_APPROX( scalar, ScalarMatrix::Constant(high) );
00148   VERIFY\_IS\_APPROX( ScalarMatrix::LinSpaced(1,low,high), ScalarMatrix::Constant(high) );
00149 
00150   \textcolor{comment}{// regression test for bug 526 (linear vectorized transversal)}
00151   \textcolor{keywordflow}{if} (size > 1 && (!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsInteger})) \{
00152     m.tail(size-1).setLinSpaced(low, high);
00153     VERIFY\_IS\_APPROX(m(size-1), high);
00154   \}
00155 
00156   \textcolor{comment}{// regression test for bug 1383 (LinSpaced with empty size/range)}
00157   \{
00158     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n0 = VectorType::SizeAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} ? 0 : VectorType::SizeAtCompileTime;
00159     low = internal::random<Scalar>();
00160     m = VectorType::LinSpaced(n0,low,low-1);
00161     VERIFY(m.size()==n0);
00162 
00163     \textcolor{keywordflow}{if}(VectorType::SizeAtCompileTime==Dynamic)
00164     \{
00165       VERIFY\_IS\_EQUAL(VectorType::LinSpaced(n0,0,Scalar(n0-1)).sum(),Scalar(0));
00166       VERIFY\_IS\_EQUAL(VectorType::LinSpaced(n0,low,low-1).sum(),Scalar(0));
00167     \}
00168 
00169     m.setLinSpaced(n0,0,Scalar(n0-1));
00170     VERIFY(m.size()==n0);
00171     m.setLinSpaced(n0,low,low-1);
00172     VERIFY(m.size()==n0);
00173 
00174     \textcolor{comment}{// empty range only:}
00175     VERIFY\_IS\_APPROX(VectorType::LinSpaced(size,low,low),VectorType::Constant(size,low));
00176     m.setLinSpaced(size,low,low);
00177     VERIFY\_IS\_APPROX(m,VectorType::Constant(size,low));
00178 
00179     \textcolor{keywordflow}{if}(\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsInteger})
00180     \{
00181       VERIFY\_IS\_APPROX( VectorType::LinSpaced(size,low,Scalar(low+size-1)), VectorType::LinSpaced(size,
      Scalar(low+size-1),low).reverse() );
00182 
00183       \textcolor{keywordflow}{if}(VectorType::SizeAtCompileTime==Dynamic)
00184       \{
00185         \textcolor{comment}{// Check negative multiplicator path:}
00186         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=1; k<5; ++k)
00187           VERIFY\_IS\_APPROX( VectorType::LinSpaced(size,low,Scalar(low+(size-1)*k)), VectorType::LinSpaced(
      size,Scalar(low+(size-1)*k),low).reverse() );
00188         \textcolor{comment}{// Check negative divisor path:}
00189         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=1; k<5; ++k)
00190           VERIFY\_IS\_APPROX( VectorType::LinSpaced(size*k,low,Scalar(low+size-1)), VectorType::LinSpaced(
      size*k,Scalar(low+size-1),low).reverse() );
00191       \}
00192     \}
00193   \}
00194 \}
00195 
00196 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00197 \textcolor{keywordtype}{void} testMatrixType(\textcolor{keyword}{const} MatrixType& m)
00198 \{
00199   \textcolor{keyword}{using} std::abs;
00200   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows = m.rows();
00201   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols = m.cols();
00202   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00203   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00204 
00205   Scalar s1;
00206   \textcolor{keywordflow}{do} \{
00207     s1 = internal::random<Scalar>();
00208   \} \textcolor{keywordflow}{while}(abs(s1)<RealScalar(1e-5) && (!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsInteger}));
00209 
00210   MatrixType A;
00211   A.setIdentity(rows, cols);
00212   VERIFY(equalsIdentity(A));
00213   VERIFY(equalsIdentity(MatrixType::Identity(rows, cols)));
00214 
00215 
00216   A = MatrixType::Constant(rows,cols,s1);
00217   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = internal::random<Index>(0,rows-1);
00218   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = internal::random<Index>(0,cols-1);
00219   VERIFY\_IS\_APPROX( MatrixType::Constant(rows,cols,s1)(i,j), s1 );
00220   VERIFY\_IS\_APPROX( MatrixType::Constant(rows,cols,s1).coeff(i,j), s1 );
00221   VERIFY\_IS\_APPROX( A(i,j), s1 );
00222 \}
00223 
00224 \textcolor{keywordtype}{void} test\_nullary()
00225 \{
00226   CALL\_SUBTEST\_1( testMatrixType(Matrix2d()) );
00227   CALL\_SUBTEST\_2( testMatrixType(MatrixXcf(internal::random<int>(1,300),internal::random<int>(1,300))) );
00228   CALL\_SUBTEST\_3( testMatrixType(MatrixXf(internal::random<int>(1,300),internal::random<int>(1,300))) );
00229   
00230   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat*10; i++) \{
00231     CALL\_SUBTEST\_4( testVectorType(VectorXd(internal::random<int>(1,30000))) );
00232     CALL\_SUBTEST\_5( testVectorType(Vector4d()) );  \textcolor{comment}{// regression test for bug 232}
00233     CALL\_SUBTEST\_6( testVectorType(Vector3d()) );
00234     CALL\_SUBTEST\_7( testVectorType(VectorXf(internal::random<int>(1,30000))) );
00235     CALL\_SUBTEST\_8( testVectorType(Vector3f()) );
00236     CALL\_SUBTEST\_8( testVectorType(Vector4f()) );
00237     CALL\_SUBTEST\_8( testVectorType(\hyperlink{group___core___module}{Matrix<float,8,1>}()) );
00238     CALL\_SUBTEST\_8( testVectorType(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,1,1>}()) );
00239 
00240     CALL\_SUBTEST\_9( testVectorType(VectorXi(internal::random<int>(1,10))) );
00241     CALL\_SUBTEST\_9( testVectorType(VectorXi(internal::random<int>(9,300))) );
00242     CALL\_SUBTEST\_9( testVectorType(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<int,1,1>}()) );
00243   \}
00244 
00245 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_6}
00246   \textcolor{comment}{// Assignment of a RowVectorXd to a MatrixXd (regression test for bug #79).}
00247   VERIFY( (MatrixXd(RowVectorXd::LinSpaced(3, 0, 1)) - RowVector3d(0, 0.5, 1)).norm() < 
      std::numeric\_limits<double>::epsilon() );
00248 \textcolor{preprocessor}{#endif}
00249 
00250 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_9}
00251   \textcolor{comment}{// Check possible overflow issue}
00252   \{
00253     \textcolor{keywordtype}{int} n = 60000;
00254     ArrayXi a1(n), a2(n);
00255     a1.setLinSpaced(n, 0, n-1);
00256     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<n; ++i)
00257       a2(i) = i;
00258     VERIFY\_IS\_APPROX(a1,a2);
00259   \}
00260 \textcolor{preprocessor}{#endif}
00261 
00262 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_10}
00263   \textcolor{comment}{// check some internal logic}
00264   VERIFY((  internal::has\_nullary\_operator<internal::scalar\_constant\_op<double> >::value ));
00265   VERIFY(( !internal::has\_unary\_operator<internal::scalar\_constant\_op<double> >::value ));
00266   VERIFY(( !internal::has\_binary\_operator<internal::scalar\_constant\_op<double> >::value ));
00267   VERIFY((  internal::functor\_has\_linear\_access<internal::scalar\_constant\_op<double> >::ret ));
00268 
00269   VERIFY(( !internal::has\_nullary\_operator<internal::scalar\_identity\_op<double> >::value ));
00270   VERIFY(( !internal::has\_unary\_operator<internal::scalar\_identity\_op<double> >::value ));
00271   VERIFY((  internal::has\_binary\_operator<internal::scalar\_identity\_op<double> >::value ));
00272   VERIFY(( !internal::functor\_has\_linear\_access<internal::scalar\_identity\_op<double> >::ret ));
00273 
00274   VERIFY(( !internal::has\_nullary\_operator<internal::linspaced\_op<float,float> >::value ));
00275   VERIFY((  internal::has\_unary\_operator<internal::linspaced\_op<float,float> >::value ));
00276   VERIFY(( !internal::has\_binary\_operator<internal::linspaced\_op<float,float> >::value ));
00277   VERIFY((  internal::functor\_has\_linear\_access<internal::linspaced\_op<float,float> >::ret ));
00278 
00279   \textcolor{comment}{// Regression unit test for a weird MSVC bug.}
00280   \textcolor{comment}{// Search "nullary\_wrapper\_workaround\_msvc" in CoreEvaluators.h for the details.}
00281   \textcolor{comment}{// See also traits<Ref>::match.}
00282   \{
00283     MatrixXf A = MatrixXf::Random(3,3);
00284     \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const MatrixXf>} R = 2.0*A;
00285     VERIFY\_IS\_APPROX(R, A+A);
00286 
00287     \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const MatrixXf>} R1 = MatrixXf::Random(3,3)+A;
00288 
00289     VectorXi V = VectorXi::Random(3);
00290     \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const VectorXi>} R2 = VectorXi::LinSpaced(3,1,3)+V;
00291     VERIFY\_IS\_APPROX(R2, V+Vector3i(1,2,3));
00292 
00293     VERIFY((  internal::has\_nullary\_operator<internal::scalar\_constant\_op<float> >::value ));
00294     VERIFY(( !internal::has\_unary\_operator<internal::scalar\_constant\_op<float> >::value ));
00295     VERIFY(( !internal::has\_binary\_operator<internal::scalar\_constant\_op<float> >::value ));
00296     VERIFY((  internal::functor\_has\_linear\_access<internal::scalar\_constant\_op<float> >::ret ));
00297 
00298     VERIFY(( !internal::has\_nullary\_operator<internal::linspaced\_op<int,int> >::value ));
00299     VERIFY((  internal::has\_unary\_operator<internal::linspaced\_op<int,int> >::value ));
00300     VERIFY(( !internal::has\_binary\_operator<internal::linspaced\_op<int,int> >::value ));
00301     VERIFY((  internal::functor\_has\_linear\_access<internal::linspaced\_op<int,int> >::ret ));
00302   \}
00303 \textcolor{preprocessor}{#endif}
00304 \}
\end{DoxyCode}
