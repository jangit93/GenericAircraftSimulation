\hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source}{}\section{eigen/\+Eigen/src/\+Pa\+Sti\+X\+Support/\+Pa\+Sti\+X\+Support.h}
\label{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source}\index{Pa\+Sti\+X\+Support.\+h@{Pa\+Sti\+X\+Support.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_PASTIXSUPPORT\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_PASTIXSUPPORT\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{preprocessor}{#if defined(DCOMPLEX)}
00016 \textcolor{preprocessor}{  #define PASTIX\_COMPLEX  COMPLEX}
00017 \textcolor{preprocessor}{  #define PASTIX\_DCOMPLEX DCOMPLEX}
00018 \textcolor{preprocessor}{#else}
00019 \textcolor{preprocessor}{  #define PASTIX\_COMPLEX  std::complex<float>}
00020 \textcolor{preprocessor}{  #define PASTIX\_DCOMPLEX std::complex<double>}
00021 \textcolor{preprocessor}{#endif}
00022 
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00031}\hyperlink{class_eigen_1_1_pastix_l_u}{00031} \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{bool} IsStrSym = false> \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_pastix_l_u}{PastixLU};
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00032}\hyperlink{class_eigen_1_1_pastix_l_l_t}{00032} \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} Options> \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_pastix_l_l_t}{PastixLLT};
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00033}\hyperlink{class_eigen_1_1_pastix_l_d_l_t}{00033} \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} Options> \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_pastix_l_d_l_t}{PastixLDLT};
00034 
00035 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal}
00036 \{
00037     
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00038}\hyperlink{struct_eigen_1_1internal_1_1pastix__traits}{00038}   \textcolor{keyword}{template}<\textcolor{keyword}{class} Pastix> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1pastix__traits}{pastix\_traits};
00039 
00040   \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00041}\hyperlink{struct_eigen_1_1internal_1_1pastix__traits_3_01_pastix_l_u_3_01___matrix_type_01_4_01_4}{00041}   \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1pastix__traits}{pastix\_traits}< \hyperlink{class_eigen_1_1_pastix_l_u}{PastixLU}<\_MatrixType> >
00042   \{
00043     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00044     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \_MatrixType::Scalar Scalar;
00045     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \_MatrixType::RealScalar RealScalar;
00046     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \_MatrixType::StorageIndex StorageIndex;
00047   \};
00048 
00049   \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} Options>
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00050}\hyperlink{struct_eigen_1_1internal_1_1pastix__traits_3_01_pastix_l_l_t_3_01___matrix_type_00_01_options_01_4_01_4}{00050}   \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1pastix__traits}{pastix\_traits}< \hyperlink{class_eigen_1_1_pastix_l_l_t}{PastixLLT}<\_MatrixType,Options> >
00051   \{
00052     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00053     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \_MatrixType::Scalar Scalar;
00054     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \_MatrixType::RealScalar RealScalar;
00055     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \_MatrixType::StorageIndex StorageIndex;
00056   \};
00057 
00058   \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} Options>
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00059}\hyperlink{struct_eigen_1_1internal_1_1pastix__traits_3_01_pastix_l_d_l_t_3_01___matrix_type_00_01_options_01_4_01_4}{00059}   \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1pastix__traits}{pastix\_traits}< \hyperlink{class_eigen_1_1_pastix_l_d_l_t}{PastixLDLT}<\_MatrixType,Options> >
00060   \{
00061     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00062     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \_MatrixType::Scalar Scalar;
00063     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \_MatrixType::RealScalar RealScalar;
00064     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \_MatrixType::StorageIndex StorageIndex;
00065   \};
00066   
00067   \textcolor{keywordtype}{void} eigen\_pastix(pastix\_data\_t **pastix\_data, \textcolor{keywordtype}{int} pastix\_comm, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} *ptr, \textcolor{keywordtype}{int} *idx, \textcolor{keywordtype}{float} *vals, \textcolor{keywordtype}{
      int} *perm, \textcolor{keywordtype}{int} * invp, \textcolor{keywordtype}{float} *x, \textcolor{keywordtype}{int} nbrhs, \textcolor{keywordtype}{int} *iparm, \textcolor{keywordtype}{double} *dparm)
00068   \{
00069     \textcolor{keywordflow}{if} (n == 0) \{ ptr = NULL; idx = NULL; vals = NULL; \}
00070     \textcolor{keywordflow}{if} (nbrhs == 0) \{x = NULL; nbrhs=1;\}
00071     s\_pastix(pastix\_data, pastix\_comm, n, ptr, idx, vals, perm, invp, x, nbrhs, iparm, dparm); 
00072   \}
00073   
00074   \textcolor{keywordtype}{void} eigen\_pastix(pastix\_data\_t **pastix\_data, \textcolor{keywordtype}{int} pastix\_comm, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} *ptr, \textcolor{keywordtype}{int} *idx, \textcolor{keywordtype}{double} *vals, \textcolor{keywordtype}{
      int} *perm, \textcolor{keywordtype}{int} * invp, \textcolor{keywordtype}{double} *x, \textcolor{keywordtype}{int} nbrhs, \textcolor{keywordtype}{int} *iparm, \textcolor{keywordtype}{double} *dparm)
00075   \{
00076     \textcolor{keywordflow}{if} (n == 0) \{ ptr = NULL; idx = NULL; vals = NULL; \}
00077     \textcolor{keywordflow}{if} (nbrhs == 0) \{x = NULL; nbrhs=1;\}
00078     d\_pastix(pastix\_data, pastix\_comm, n, ptr, idx, vals, perm, invp, x, nbrhs, iparm, dparm); 
00079   \}
00080   
00081   \textcolor{keywordtype}{void} eigen\_pastix(pastix\_data\_t **pastix\_data, \textcolor{keywordtype}{int} pastix\_comm, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} *ptr, \textcolor{keywordtype}{int} *idx, 
      std::complex<float> *vals, \textcolor{keywordtype}{int} *perm, \textcolor{keywordtype}{int} * invp, std::complex<float> *x, \textcolor{keywordtype}{int} nbrhs, \textcolor{keywordtype}{int} *iparm, \textcolor{keywordtype}{double} *dparm)
00082   \{
00083     \textcolor{keywordflow}{if} (n == 0) \{ ptr = NULL; idx = NULL; vals = NULL; \}
00084     \textcolor{keywordflow}{if} (nbrhs == 0) \{x = NULL; nbrhs=1;\}
00085     c\_pastix(pastix\_data, pastix\_comm, n, ptr, idx, reinterpret\_cast<PASTIX\_COMPLEX*>(vals), perm, invp, 
      reinterpret\_cast<PASTIX\_COMPLEX*>(x), nbrhs, iparm, dparm); 
00086   \}
00087   
00088   \textcolor{keywordtype}{void} eigen\_pastix(pastix\_data\_t **pastix\_data, \textcolor{keywordtype}{int} pastix\_comm, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} *ptr, \textcolor{keywordtype}{int} *idx, 
      std::complex<double> *vals, \textcolor{keywordtype}{int} *perm, \textcolor{keywordtype}{int} * invp, std::complex<double> *x, \textcolor{keywordtype}{int} nbrhs, \textcolor{keywordtype}{int} *iparm, \textcolor{keywordtype}{double} *dparm)
00089   \{
00090     \textcolor{keywordflow}{if} (n == 0) \{ ptr = NULL; idx = NULL; vals = NULL; \}
00091     \textcolor{keywordflow}{if} (nbrhs == 0) \{x = NULL; nbrhs=1;\}
00092     z\_pastix(pastix\_data, pastix\_comm, n, ptr, idx, reinterpret\_cast<PASTIX\_DCOMPLEX*>(vals), perm, invp, 
      reinterpret\_cast<PASTIX\_DCOMPLEX*>(x), nbrhs, iparm, dparm); 
00093   \}
00094 
00095   \textcolor{comment}{// Convert the matrix  to Fortran-style Numbering}
00096   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00097   \textcolor{keywordtype}{void} c\_to\_fortran\_numbering (MatrixType& mat)
00098   \{
00099     \textcolor{keywordflow}{if} ( !(mat.outerIndexPtr()[0]) ) 
00100     \{ 
00101       \textcolor{keywordtype}{int} i;
00102       \textcolor{keywordflow}{for}(i = 0; i <= mat.rows(); ++i)
00103         ++mat.outerIndexPtr()[i];
00104       \textcolor{keywordflow}{for}(i = 0; i < mat.nonZeros(); ++i)
00105         ++mat.innerIndexPtr()[i];
00106     \}
00107   \}
00108   
00109   \textcolor{comment}{// Convert to C-style Numbering}
00110   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00111   \textcolor{keywordtype}{void} fortran\_to\_c\_numbering (MatrixType& mat)
00112   \{
00113     \textcolor{comment}{// Check the Numbering}
00114     \textcolor{keywordflow}{if} ( mat.outerIndexPtr()[0] == 1 ) 
00115     \{ \textcolor{comment}{// Convert to C-style numbering}
00116       \textcolor{keywordtype}{int} i;
00117       \textcolor{keywordflow}{for}(i = 0; i <= mat.rows(); ++i)
00118         --mat.outerIndexPtr()[i];
00119       \textcolor{keywordflow}{for}(i = 0; i < mat.nonZeros(); ++i)
00120         --mat.innerIndexPtr()[i];
00121     \}
00122   \}
00123 \}
00124 
00125 \textcolor{comment}{// This is the base class to interface with PaStiX functions. }
00126 \textcolor{comment}{// Users should not used this class directly. }
00127 \textcolor{keyword}{template} <\textcolor{keyword}{class} Derived>
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00128}\hyperlink{class_eigen_1_1_pastix_base}{00128} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_pastix_base}{PastixBase} : \textcolor{keyword}{public} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase}<Derived>
00129 \{
00130   \textcolor{keyword}{protected}:
00131     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase<Derived>} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{Base};
00132     \textcolor{keyword}{using} Base::derived;
00133     \textcolor{keyword}{using} Base::m\_isInitialized;
00134   \textcolor{keyword}{public}:
00135     \textcolor{keyword}{using} Base::\_solve\_impl;
00136     
00137     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1pastix__traits}{internal::pastix\_traits<Derived>::MatrixType}
       \_MatrixType;
00138     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00139     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00140     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00141     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00142     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} \hyperlink{group___core___module}{Vector};
00143     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar, ColMajor>} 
      \hyperlink{group___sparse_core___module}{ColSpMatrix};
00144     \textcolor{keyword}{enum} \{
00145       ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00146       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
00147     \};
00148     
00149   \textcolor{keyword}{public}:
00150     
00151     \hyperlink{class_eigen_1_1_pastix_base}{PastixBase}() : m\_initisOk(\textcolor{keyword}{false}), m\_analysisIsOk(\textcolor{keyword}{false}), m\_factorizationIsOk(\textcolor{keyword}{false}), 
      m\_pastixdata(0), m\_size(0)
00152     \{
00153       \hyperlink{structinit}{init}();
00154     \}
00155     
00156     ~\hyperlink{class_eigen_1_1_pastix_base}{PastixBase}() 
00157     \{
00158       clean();
00159     \}
00160     
00161     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs,\textcolor{keyword}{typename} Dest>
00162     \textcolor{keywordtype}{bool} \_solve\_impl(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>} &b, \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>} &x) \textcolor{keyword}{const};
00163     
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00169}\hyperlink{class_eigen_1_1_pastix_base_a38378e7b2b5c750a8a23e2c21a69146c}{00169}     \hyperlink{group___core___module_class_eigen_1_1_array}{Array<StorageIndex,IPARM\_SIZE,1>}& \hyperlink{class_eigen_1_1_pastix_base_a38378e7b2b5c750a8a23e2c21a69146c}{iparm}()
00170     \{
00171       \textcolor{keywordflow}{return} m\_iparm; 
00172     \}
00173     
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00178}\hyperlink{class_eigen_1_1_pastix_base_a5509ca8d6a9217fb95ab020363b9e0fb}{00178}     \textcolor{keywordtype}{int}& \hyperlink{class_eigen_1_1_pastix_base_a5509ca8d6a9217fb95ab020363b9e0fb}{iparm}(\textcolor{keywordtype}{int} idxparam)
00179     \{
00180       \textcolor{keywordflow}{return} m\_iparm(idxparam);
00181     \}
00182     
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00187}\hyperlink{class_eigen_1_1_pastix_base_af4a29373aa3e6a980738efde33f92a76}{00187}     \hyperlink{group___core___module}{Array<double,DPARM\_SIZE,1>}& \hyperlink{class_eigen_1_1_pastix_base_af4a29373aa3e6a980738efde33f92a76}{dparm}()
00188     \{
00189       \textcolor{keywordflow}{return} m\_dparm; 
00190     \}
00191     
00192     
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00196}\hyperlink{class_eigen_1_1_pastix_base_a6e7baecd4990d6df9b5713cb6499e940}{00196}     \textcolor{keywordtype}{double}& \hyperlink{class_eigen_1_1_pastix_base_a6e7baecd4990d6df9b5713cb6499e940}{dparm}(\textcolor{keywordtype}{int} idxparam)
00197     \{
00198       \textcolor{keywordflow}{return} m\_dparm(idxparam);
00199     \}
00200     
00201     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_size; \}
00202     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_size; \}
00203     
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00212}\hyperlink{class_eigen_1_1_pastix_base_a436e99a385c9c019be9627cc1fa884cf}{00212}     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} \hyperlink{class_eigen_1_1_pastix_base_a436e99a385c9c019be9627cc1fa884cf}{info}()\textcolor{keyword}{ const}
00213 \textcolor{keyword}{    }\{
00214       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"Decomposition is not initialized."});
00215       \textcolor{keywordflow}{return} m\_info;
00216     \}
00217     
00218   \textcolor{keyword}{protected}:
00219 
00220     \textcolor{comment}{// Initialize the Pastix data structure, check the matrix}
00221     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}(); 
00222     
00223     \textcolor{comment}{// Compute the ordering and the symbolic factorization}
00224     \textcolor{keywordtype}{void} analyzePattern(ColSpMatrix& mat);
00225     
00226     \textcolor{comment}{// Compute the numerical factorization}
00227     \textcolor{keywordtype}{void} factorize(ColSpMatrix& mat);
00228     
00229     \textcolor{comment}{// Free all the data allocated by Pastix}
00230     \textcolor{keywordtype}{void} clean()
00231     \{
00232       eigen\_assert(m\_initisOk && \textcolor{stringliteral}{"The Pastix structure should be allocated first"}); 
00233       m\_iparm(IPARM\_START\_TASK) = API\_TASK\_CLEAN;
00234       m\_iparm(IPARM\_END\_TASK) = API\_TASK\_CLEAN;
00235       internal::eigen\_pastix(&m\_pastixdata, MPI\_COMM\_WORLD, 0, 0, 0, (Scalar*)0,
00236                              m\_perm.data(), m\_invp.data(), 0, 0, m\_iparm.data(), m\_dparm.data());
00237     \}
00238     
00239     \textcolor{keywordtype}{void} compute(ColSpMatrix& mat);
00240     
00241     \textcolor{keywordtype}{int} m\_initisOk; 
00242     \textcolor{keywordtype}{int} m\_analysisIsOk;
00243     \textcolor{keywordtype}{int} m\_factorizationIsOk;
00244     \textcolor{keyword}{mutable} \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} m\_info; 
00245     \textcolor{keyword}{mutable} pastix\_data\_t *m\_pastixdata; \textcolor{comment}{// Data structure for pastix}
00246     \textcolor{keyword}{mutable} \textcolor{keywordtype}{int} m\_comm; \textcolor{comment}{// The MPI communicator identifier}
00247     \textcolor{keyword}{mutable} \hyperlink{group___core___module}{Array<int,IPARM\_SIZE,1>} m\_iparm; \textcolor{comment}{// integer vector for the input
       parameters}
00248     \textcolor{keyword}{mutable} \hyperlink{group___core___module}{Array<double,DPARM\_SIZE,1>} m\_dparm; \textcolor{comment}{// Scalar vector for the input
       parameters}
00249     \textcolor{keyword}{mutable} \hyperlink{group___core___module}{Matrix<StorageIndex,Dynamic,1>} m\_perm;  \textcolor{comment}{// Permutation vector}
00250     \textcolor{keyword}{mutable} \hyperlink{group___core___module}{Matrix<StorageIndex,Dynamic,1>} m\_invp;  \textcolor{comment}{// Inverse permutation
       vector}
00251     \textcolor{keyword}{mutable} \textcolor{keywordtype}{int} m\_size; \textcolor{comment}{// Size of the matrix }
00252 \}; 
00253 
00258 \textcolor{keyword}{template} <\textcolor{keyword}{class} Derived>
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00259}\hyperlink{class_eigen_1_1_pastix_base_ac6202714edd1943646e34f16ad384336}{00259} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_base_ac6202714edd1943646e34f16ad384336}{PastixBase<Derived>::init}()
00260 \{
00261   m\_size = 0; 
00262   m\_iparm.setZero(IPARM\_SIZE);
00263   m\_dparm.setZero(DPARM\_SIZE);
00264   
00265   m\_iparm(IPARM\_MODIFY\_PARAMETER) = API\_NO;
00266   pastix(&m\_pastixdata, MPI\_COMM\_WORLD,
00267          0, 0, 0, 0,
00268          0, 0, 0, 1, m\_iparm.data(), m\_dparm.data());
00269   
00270   m\_iparm[IPARM\_MATRIX\_VERIFICATION] = API\_NO;
00271   m\_iparm[IPARM\_VERBOSE]             = API\_VERBOSE\_NOT;
00272   m\_iparm[IPARM\_ORDERING]            = API\_ORDER\_SCOTCH;
00273   m\_iparm[IPARM\_INCOMPLETE]          = API\_NO;
00274   m\_iparm[IPARM\_OOC\_LIMIT]           = 2000;
00275   m\_iparm[IPARM\_RHS\_MAKING]          = API\_RHS\_B;
00276   m\_iparm(IPARM\_MATRIX\_VERIFICATION) = API\_NO;
00277   
00278   m\_iparm(IPARM\_START\_TASK) = API\_TASK\_INIT;
00279   m\_iparm(IPARM\_END\_TASK) = API\_TASK\_INIT;
00280   internal::eigen\_pastix(&m\_pastixdata, MPI\_COMM\_WORLD, 0, 0, 0, (Scalar*)0,
00281                          0, 0, 0, 0, m\_iparm.data(), m\_dparm.data());
00282   
00283   \textcolor{comment}{// Check the returned error}
00284   \textcolor{keywordflow}{if}(m\_iparm(IPARM\_ERROR\_NUMBER)) \{
00285     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434}{InvalidInput};
00286     m\_initisOk = \textcolor{keyword}{false};
00287   \}
00288   \textcolor{keywordflow}{else} \{ 
00289     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00290     m\_initisOk = \textcolor{keyword}{true};
00291   \}
00292 \}
00293 
00294 \textcolor{keyword}{template} <\textcolor{keyword}{class} Derived>
00295 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_base}{PastixBase<Derived>::compute}(\hyperlink{group___sparse_core___module}{ColSpMatrix}& mat)
00296 \{
00297   eigen\_assert(mat.\hyperlink{group___sparse_core___module_a62e61bb861eee306d5b069ce652b5aa5}{rows}() == mat.\hyperlink{group___sparse_core___module_aa391750e3c530227e4a5c3c52e959975}{cols}() && \textcolor{stringliteral}{"The input matrix should be squared"});
00298   
00299   analyzePattern(mat);  
00300   factorize(mat);
00301   
00302   m\_iparm(IPARM\_MATRIX\_VERIFICATION) = API\_NO;
00303 \}
00304 
00305 
00306 \textcolor{keyword}{template} <\textcolor{keyword}{class} Derived>
00307 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_base}{PastixBase<Derived>::analyzePattern}(
      \hyperlink{group___sparse_core___module}{ColSpMatrix}& mat)
00308 \{                         
00309   eigen\_assert(m\_initisOk && \textcolor{stringliteral}{"The initialization of PaSTiX failed"});
00310   
00311   \textcolor{comment}{// clean previous calls}
00312   \textcolor{keywordflow}{if}(m\_size>0)
00313     clean();
00314   
00315   m\_size = internal::convert\_index<int>(mat.\hyperlink{group___sparse_core___module_a62e61bb861eee306d5b069ce652b5aa5}{rows}());
00316   m\_perm.resize(m\_size);
00317   m\_invp.resize(m\_size);
00318   
00319   m\_iparm(IPARM\_START\_TASK) = API\_TASK\_ORDERING;
00320   m\_iparm(IPARM\_END\_TASK) = API\_TASK\_ANALYSE;
00321   internal::eigen\_pastix(&m\_pastixdata, MPI\_COMM\_WORLD, m\_size, mat.
      \hyperlink{group___sparse_core___module_a75506964d86d6badb32d0b4917acf2e2}{outerIndexPtr}(), mat.\hyperlink{group___sparse_core___module_ae7b804bd39745156d20ca1611a296b67}{innerIndexPtr}(),
00322                mat.\hyperlink{group___sparse_core___module_a9d4354d3f4d121d764bbed33cac05329}{valuePtr}(), m\_perm.data(), m\_invp.data(), 0, 0, m\_iparm.data(), m\_dparm.data());
00323   
00324   \textcolor{comment}{// Check the returned error}
00325   \textcolor{keywordflow}{if}(m\_iparm(IPARM\_ERROR\_NUMBER))
00326   \{
00327     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00328     m\_analysisIsOk = \textcolor{keyword}{false};
00329   \}
00330   \textcolor{keywordflow}{else}
00331   \{ 
00332     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00333     m\_analysisIsOk = \textcolor{keyword}{true};
00334   \}
00335 \}
00336 
00337 \textcolor{keyword}{template} <\textcolor{keyword}{class} Derived>
00338 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_base}{PastixBase<Derived>::factorize}(\hyperlink{group___sparse_core___module}{ColSpMatrix}& mat)
00339 \{
00340 \textcolor{comment}{//   if(&m\_cpyMat != &mat) m\_cpyMat = mat;}
00341   eigen\_assert(m\_analysisIsOk && \textcolor{stringliteral}{"The analysis phase should be called before the factorization phase"});
00342   m\_iparm(IPARM\_START\_TASK) = API\_TASK\_NUMFACT;
00343   m\_iparm(IPARM\_END\_TASK) = API\_TASK\_NUMFACT;
00344   m\_size = internal::convert\_index<int>(mat.\hyperlink{group___sparse_core___module_a62e61bb861eee306d5b069ce652b5aa5}{rows}());
00345   
00346   internal::eigen\_pastix(&m\_pastixdata, MPI\_COMM\_WORLD, m\_size, mat.
      \hyperlink{group___sparse_core___module_a75506964d86d6badb32d0b4917acf2e2}{outerIndexPtr}(), mat.\hyperlink{group___sparse_core___module_ae7b804bd39745156d20ca1611a296b67}{innerIndexPtr}(),
00347                mat.\hyperlink{group___sparse_core___module_a9d4354d3f4d121d764bbed33cac05329}{valuePtr}(), m\_perm.data(), m\_invp.data(), 0, 0, m\_iparm.data(), m\_dparm.data());
00348   
00349   \textcolor{comment}{// Check the returned error}
00350   \textcolor{keywordflow}{if}(m\_iparm(IPARM\_ERROR\_NUMBER))
00351   \{
00352     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00353     m\_factorizationIsOk = \textcolor{keyword}{false};
00354     m\_isInitialized = \textcolor{keyword}{false};
00355   \}
00356   \textcolor{keywordflow}{else}
00357   \{
00358     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00359     m\_factorizationIsOk = \textcolor{keyword}{true};
00360     m\_isInitialized = \textcolor{keyword}{true};
00361   \}
00362 \}
00363 
00364 \textcolor{comment}{/* Solve the system */}
00365 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Base>
00366 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs,\textcolor{keyword}{typename} Dest>
00367 \textcolor{keywordtype}{bool} \hyperlink{class_eigen_1_1_pastix_base}{PastixBase<Base>::\_solve\_impl}(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>} &b, \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>} &x)\textcolor{keyword}{ const}
00368 \textcolor{keyword}{}\{
00369   eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"The matrix should be factorized first"});
00370   EIGEN\_STATIC\_ASSERT((Dest::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==0,
00371                      THIS\_METHOD\_IS\_ONLY\_FOR\_COLUMN\_MAJOR\_MATRICES);
00372   \textcolor{keywordtype}{int} rhs = 1;
00373   
00374   x = b; \textcolor{comment}{/* on return, x is overwritten by the computed solution */}
00375   
00376   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < b.cols(); i++)\{
00377     m\_iparm[IPARM\_START\_TASK]          = API\_TASK\_SOLVE;
00378     m\_iparm[IPARM\_END\_TASK]            = API\_TASK\_REFINE;
00379   
00380     internal::eigen\_pastix(&m\_pastixdata, MPI\_COMM\_WORLD, internal::convert\_index<int>(x.rows()), 0, 0, 0,
00381                            m\_perm.data(), m\_invp.data(), &x(0, i), rhs, m\_iparm.data(), m\_dparm.data());
00382   \}
00383   
00384   \textcolor{comment}{// Check the returned error}
00385   m\_info = m\_iparm(IPARM\_ERROR\_NUMBER)==0 ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} : \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00386   
00387   \textcolor{keywordflow}{return} m\_iparm(IPARM\_ERROR\_NUMBER)==0;
00388 \}
00389 
00411 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{bool} IsStrSym>
00412 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_pastix_l_u}{PastixLU} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_pastix_base}{PastixBase}< PastixLU<\_MatrixType> >
00413 \{
00414   \textcolor{keyword}{public}:
00415     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00416     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_pastix_base}{PastixBase<PastixLU<MatrixType>} > 
      \hyperlink{group___sparse_core___module}{Base};
00417     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::ColSpMatrix \hyperlink{group___sparse_core___module}{ColSpMatrix};
00418     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00419     
00420   \textcolor{keyword}{public}:
00421     \hyperlink{class_eigen_1_1_pastix_l_u}{PastixLU}() : Base()
00422     \{
00423       \hyperlink{structinit}{init}();
00424     \}
00425     
00426     \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1_pastix_l_u}{PastixLU}(\textcolor{keyword}{const} MatrixType& matrix):Base()
00427     \{
00428       \hyperlink{structinit}{init}();
00429       compute(matrix);
00430     \}
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00436}\hyperlink{class_eigen_1_1_pastix_l_u_adc28ee2550086c7bdfe991d624bde2ee}{00436}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_l_u_adc28ee2550086c7bdfe991d624bde2ee}{compute} (\textcolor{keyword}{const} MatrixType& matrix)
00437     \{
00438       m\_structureIsUptodate = \textcolor{keyword}{false};
00439       ColSpMatrix temp;
00440       grabMatrix(matrix, temp);
00441       Base::compute(temp);
00442     \}
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00448}\hyperlink{class_eigen_1_1_pastix_l_u_abae3ca7f1254106d9e2d5e0f273189fa}{00448}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_l_u_abae3ca7f1254106d9e2d5e0f273189fa}{analyzePattern}(\textcolor{keyword}{const} MatrixType& matrix)
00449     \{
00450       m\_structureIsUptodate = \textcolor{keyword}{false};
00451       ColSpMatrix temp;
00452       grabMatrix(matrix, temp);
00453       Base::analyzePattern(temp);
00454     \}
00455 
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00461}\hyperlink{class_eigen_1_1_pastix_l_u_ac178a87b499a2210a402787fbfd98f26}{00461}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_l_u_ac178a87b499a2210a402787fbfd98f26}{factorize}(\textcolor{keyword}{const} MatrixType& matrix)
00462     \{
00463       ColSpMatrix temp;
00464       grabMatrix(matrix, temp);
00465       Base::factorize(temp);
00466     \}
00467   \textcolor{keyword}{protected}:
00468     
00469     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}()
00470     \{
00471       m\_structureIsUptodate = \textcolor{keyword}{false};
00472       m\_iparm(IPARM\_SYM) = API\_SYM\_NO;
00473       m\_iparm(IPARM\_FACTORIZATION) = API\_FACT\_LU;
00474     \}
00475     
00476     \textcolor{keywordtype}{void} grabMatrix(\textcolor{keyword}{const} MatrixType& matrix, ColSpMatrix& out)
00477     \{
00478       \textcolor{keywordflow}{if}(IsStrSym)
00479         out = matrix;
00480       \textcolor{keywordflow}{else}
00481       \{
00482         \textcolor{keywordflow}{if}(!m\_structureIsUptodate)
00483         \{
00484           \textcolor{comment}{// update the transposed structure}
00485           m\_transposedStructure = matrix.transpose();
00486           
00487           \textcolor{comment}{// Set the elements of the matrix to zero }
00488           \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<m\_transposedStructure.outerSize(); ++j) 
00489             \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} ColSpMatrix::InnerIterator it(m\_transposedStructure, j); it; ++it)
00490               it.valueRef() = 0.0;
00491 
00492           m\_structureIsUptodate = \textcolor{keyword}{true};
00493         \}
00494         
00495         out = m\_transposedStructure + matrix;
00496       \}
00497       internal::c\_to\_fortran\_numbering(out);
00498     \}
00499     
00500     \textcolor{keyword}{using} Base::m\_iparm;
00501     \textcolor{keyword}{using} Base::m\_dparm;
00502     
00503     ColSpMatrix m\_transposedStructure;
00504     \textcolor{keywordtype}{bool} m\_structureIsUptodate;
00505 \};
00506 
00523 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} \_UpLo>
00524 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_pastix_l_l_t}{PastixLLT} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_pastix_base}{PastixBase}< PastixLLT<\_MatrixType, \_UpLo> >
00525 \{
00526   \textcolor{keyword}{public}:
00527     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00528     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_pastix_base}{PastixBase<PastixLLT<MatrixType, \_UpLo>} > 
      \hyperlink{class_eigen_1_1_pastix_base}{Base};
00529     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Base::ColSpMatrix} \hyperlink{group___sparse_core___module}{ColSpMatrix};
00530     
00531   \textcolor{keyword}{public}:
00532     \textcolor{keyword}{enum} \{ UpLo = \_UpLo \};
00533     \hyperlink{class_eigen_1_1_pastix_l_l_t}{PastixLLT}() : Base()
00534     \{
00535       \hyperlink{structinit}{init}();
00536     \}
00537     
00538     \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1_pastix_l_l_t}{PastixLLT}(\textcolor{keyword}{const} MatrixType& matrix):Base()
00539     \{
00540       \hyperlink{structinit}{init}();
00541       compute(matrix);
00542     \}
00543 
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00547}\hyperlink{class_eigen_1_1_pastix_l_l_t_a54fcdef53903851e2d8113a6ed330b5c}{00547}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_l_l_t_a54fcdef53903851e2d8113a6ed330b5c}{compute} (\textcolor{keyword}{const} MatrixType& matrix)
00548     \{
00549       ColSpMatrix temp;
00550       grabMatrix(matrix, temp);
00551       Base::compute(temp);
00552     \}
00553 
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00558}\hyperlink{class_eigen_1_1_pastix_l_l_t_a671e8444ae2f04db3565e35caa958667}{00558}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_l_l_t_a671e8444ae2f04db3565e35caa958667}{analyzePattern}(\textcolor{keyword}{const} MatrixType& matrix)
00559     \{
00560       ColSpMatrix temp;
00561       grabMatrix(matrix, temp);
00562       Base::analyzePattern(temp);
00563     \}
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00567}\hyperlink{class_eigen_1_1_pastix_l_l_t_a63dac317804b18a4704a519d7bdfaaff}{00567}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_l_l_t_a63dac317804b18a4704a519d7bdfaaff}{factorize}(\textcolor{keyword}{const} MatrixType& matrix)
00568     \{
00569       ColSpMatrix temp;
00570       grabMatrix(matrix, temp);
00571       Base::factorize(temp);
00572     \}
00573   \textcolor{keyword}{protected}:
00574     \textcolor{keyword}{using} Base::m\_iparm;
00575     
00576     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}()
00577     \{
00578       m\_iparm(IPARM\_SYM) = API\_SYM\_YES;
00579       m\_iparm(IPARM\_FACTORIZATION) = API\_FACT\_LLT;
00580     \}
00581     
00582     \textcolor{keywordtype}{void} grabMatrix(\textcolor{keyword}{const} MatrixType& matrix, ColSpMatrix& out)
00583     \{
00584       out.\hyperlink{group___sparse_core___module_af88551f30202341b7cc24cfadabdec5c}{resize}(matrix.rows(), matrix.cols());
00585       \textcolor{comment}{// Pastix supports only lower, column-major matrices }
00586       out.template selfadjointView<Lower>() = matrix.template selfadjointView<UpLo>();
00587       internal::c\_to\_fortran\_numbering(out);
00588     \}
00589 \};
00590 
00607 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} \_UpLo>
00608 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_pastix_l_d_l_t}{PastixLDLT} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_pastix_base}{PastixBase}< PastixLDLT<\_MatrixType, \_UpLo> >
00609 \{
00610   \textcolor{keyword}{public}:
00611     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00612     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_pastix_base}{PastixBase<PastixLDLT<MatrixType, \_UpLo>} > 
      \hyperlink{class_eigen_1_1_pastix_base}{Base}; 
00613     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Base::ColSpMatrix} \hyperlink{group___sparse_core___module}{ColSpMatrix};
00614     
00615   \textcolor{keyword}{public}:
00616     \textcolor{keyword}{enum} \{ UpLo = \_UpLo \};
00617     \hyperlink{class_eigen_1_1_pastix_l_d_l_t}{PastixLDLT}():Base()
00618     \{
00619       \hyperlink{structinit}{init}();
00620     \}
00621     
00622     \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1_pastix_l_d_l_t}{PastixLDLT}(\textcolor{keyword}{const} MatrixType& matrix):Base()
00623     \{
00624       \hyperlink{structinit}{init}();
00625       compute(matrix);
00626     \}
00627 
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00631}\hyperlink{class_eigen_1_1_pastix_l_d_l_t_abf3135c2dc17d9df26fef80e6456a691}{00631}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_l_d_l_t_abf3135c2dc17d9df26fef80e6456a691}{compute} (\textcolor{keyword}{const} MatrixType& matrix)
00632     \{
00633       ColSpMatrix temp;
00634       grabMatrix(matrix, temp);
00635       Base::compute(temp);
00636     \}
00637 
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00642}\hyperlink{class_eigen_1_1_pastix_l_d_l_t_a01947862303ca404b9ce5033751a221b}{00642}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_l_d_l_t_a01947862303ca404b9ce5033751a221b}{analyzePattern}(\textcolor{keyword}{const} MatrixType& matrix)
00643     \{ 
00644       ColSpMatrix temp;
00645       grabMatrix(matrix, temp);
00646       Base::analyzePattern(temp);
00647     \}
\Hypertarget{eigen_2_eigen_2src_2_pa_sti_x_support_2_pa_sti_x_support_8h_source_l00651}\hyperlink{class_eigen_1_1_pastix_l_d_l_t_a182b0ee676a131413363cc73bc309ef7}{00651}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_pastix_l_d_l_t_a182b0ee676a131413363cc73bc309ef7}{factorize}(\textcolor{keyword}{const} MatrixType& matrix)
00652     \{
00653       ColSpMatrix temp;
00654       grabMatrix(matrix, temp);
00655       Base::factorize(temp);
00656     \}
00657 
00658   \textcolor{keyword}{protected}:
00659     \textcolor{keyword}{using} Base::m\_iparm;
00660     
00661     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}()
00662     \{
00663       m\_iparm(IPARM\_SYM) = API\_SYM\_YES;
00664       m\_iparm(IPARM\_FACTORIZATION) = API\_FACT\_LDLT;
00665     \}
00666     
00667     \textcolor{keywordtype}{void} grabMatrix(\textcolor{keyword}{const} MatrixType& matrix, ColSpMatrix& out)
00668     \{
00669       \textcolor{comment}{// Pastix supports only lower, column-major matrices }
00670       out.\hyperlink{group___sparse_core___module_af88551f30202341b7cc24cfadabdec5c}{resize}(matrix.rows(), matrix.cols());
00671       out.template selfadjointView<Lower>() = matrix.template selfadjointView<UpLo>();
00672       internal::c\_to\_fortran\_numbering(out);
00673     \}
00674 \};
00675 
00676 \} \textcolor{comment}{// end namespace Eigen}
00677 
00678 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
