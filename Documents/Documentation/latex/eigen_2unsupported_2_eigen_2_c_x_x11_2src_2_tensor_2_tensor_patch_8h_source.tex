\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_patch_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Patch.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_patch_8h_source}\index{Tensor\+Patch.\+h@{Tensor\+Patch.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_PATCH\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_PATCH\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PatchDim, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_patch_8h_source_l00024}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_patch_op_3_01_patch_dim_00_01_xpr_type_01_4_01_4}{00024} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_patch_op}{TensorPatchOp}<PatchDim, XprType> > : \textcolor{keyword}{public} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<XprType>
00025 \{
00026   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00027   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>} \hyperlink{struct_eigen_1_1internal_1_1traits}{XprTraits};
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<Nested>::type} 
      \hyperlink{group___sparse_core___module}{\_Nested};
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions + 1;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00034 \};
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PatchDim, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_patch_8h_source_l00037}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_patch_op_3_01_patch_dim_00_01_xpr_type_01_4_00_01_eigen_1_1_dense_01_4}{00037} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_patch_op}{TensorPatchOp}<PatchDim, XprType>, \hyperlink{namespace_eigen}{Eigen}::\hyperlink{struct_eigen_1_1_dense}{Dense}>
00038 \{
00039   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_patch_op}{TensorPatchOp<PatchDim, XprType>}& 
      \hyperlink{class_eigen_1_1_tensor_patch_op}{type};
00040 \};
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PatchDim, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_patch_8h_source_l00043}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_patch_op_3_01_patch_dim_00_01_xpr_type_01_4_00_017d8350baeaabc5f17d005b7a04cfaf28}{00043} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_patch_op}{TensorPatchOp}<PatchDim, XprType>, 1, typename 
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_patch_op}{TensorPatchOp}<PatchDim, XprType> >::\hyperlink{class_eigen_1_1_tensor_patch_op}{type}>
00044 \{
00045   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_patch_op}{TensorPatchOp<PatchDim, XprType>} \hyperlink{class_eigen_1_1_tensor_patch_op}{type};
00046 \};
00047 
00048 \}  \textcolor{comment}{// end namespace internal}
00049 
00050 
00051 
00052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PatchDim, \textcolor{keyword}{typename} XprType>
00053 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_patch_op}{TensorPatchOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorPatchOp<PatchDim, XprType>, ReadOnlyAc
      cessors>
00054 \{
00055   \textcolor{keyword}{public}:
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorPatchOp>::Scalar}
       Scalar;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorPatchOp>::type}
       Nested;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorPatchOp>::StorageKind}
       StorageKind;
00061   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorPatchOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00062 
00063   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_patch_op}{TensorPatchOp}(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} PatchDim& 
      patch\_dims)
00064       : m\_xpr(expr), m\_patch\_dims(patch\_dims) \{\}
00065 
00066     EIGEN\_DEVICE\_FUNC
00067     \textcolor{keyword}{const} PatchDim& patch\_dims()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_patch\_dims; \}
00068 
00069     EIGEN\_DEVICE\_FUNC
00070     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename XprType::Nested>::type}
      &
00071     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00072 
00073   \textcolor{keyword}{protected}:
00074     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00075     \textcolor{keyword}{const} PatchDim m\_patch\_dims;
00076 \};
00077 
00078 
00079 \textcolor{comment}{// Eval as rvalue}
00080 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PatchDim, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_patch_8h_source_l00081}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_patch_op_3_01_patch_dim_00_01_arg_type_01_4_00_01_device_01_4}{00081} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_patch_op}{TensorPatchOp}<PatchDim, ArgType>, Device>
00082 \{
00083   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_patch_op}{TensorPatchOp<PatchDim, ArgType>} 
      \hyperlink{class_eigen_1_1_tensor_patch_op}{XprType};
00084   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00085   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<ArgType, Device>::Dimensions}
      >::value + 1;
00086   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumDims>} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00087   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00088   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00089   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00090   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size};
00091 
00092 
00093   \textcolor{keyword}{enum} \{
00094     IsAligned = \textcolor{keyword}{false},
00095     PacketAccess = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::PacketAccess}
      ,
00096     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Layout},
00097     CoordAccess = \textcolor{keyword}{false},
00098     RawAccess = \textcolor{keyword}{false}
00099  \};
00100 
00101   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00102       : m\_impl(op.expression(), device)
00103   \{
00104     Index num\_patches = 1;
00105     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Dimensions}
      & input\_dims = m\_impl.dimensions();
00106     \textcolor{keyword}{const} PatchDim& patch\_dims = op.patch\_dims();
00107     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00108       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims-1; ++i) \{
00109         m\_dimensions[i] = patch\_dims[i];
00110         num\_patches *= (input\_dims[i] - patch\_dims[i] + 1);
00111       \}
00112       m\_dimensions[NumDims-1] = num\_patches;
00113 
00114       m\_inputStrides[0] = 1;
00115       m\_patchStrides[0] = 1;
00116       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims-1; ++i) \{
00117         m\_inputStrides[i] = m\_inputStrides[i-1] * input\_dims[i-1];
00118         m\_patchStrides[i] = m\_patchStrides[i-1] * (input\_dims[i-1] - patch\_dims[i-1] + 1);
00119       \}
00120       m\_outputStrides[0] = 1;
00121       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00122         m\_outputStrides[i] = m\_outputStrides[i-1] * m\_dimensions[i-1];
00123       \}
00124     \} \textcolor{keywordflow}{else} \{
00125       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims-1; ++i) \{
00126         m\_dimensions[i+1] = patch\_dims[i];
00127         num\_patches *= (input\_dims[i] - patch\_dims[i] + 1);
00128       \}
00129       m\_dimensions[0] = num\_patches;
00130 
00131       m\_inputStrides[NumDims-2] = 1;
00132       m\_patchStrides[NumDims-2] = 1;
00133       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims-3; i >= 0; --i) \{
00134         m\_inputStrides[i] = m\_inputStrides[i+1] * input\_dims[i+1];
00135         m\_patchStrides[i] = m\_patchStrides[i+1] * (input\_dims[i+1] - patch\_dims[i+1] + 1);
00136       \}
00137       m\_outputStrides[NumDims-1] = 1;
00138       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims-2; i >= 0; --i) \{
00139         m\_outputStrides[i] = m\_outputStrides[i+1] * m\_dimensions[i+1];
00140       \}
00141     \}
00142   \}
00143 
00144   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00145 
00146   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/}) \{
00147     m\_impl.evalSubExprsIfNeeded(NULL);
00148     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00149   \}
00150 
00151   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00152     m\_impl.cleanup();
00153   \}
00154 
00155   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00156 \textcolor{keyword}{  }\{
00157     Index output\_stride\_index = (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) ? NumDims - 1 : 0;
00158     \textcolor{comment}{// Find the location of the first element of the patch.}
00159     Index patchIndex = index / m\_outputStrides[output\_stride\_index];
00160     \textcolor{comment}{// Find the offset of the element wrt the location of the first element.}
00161     Index patchOffset = index - patchIndex * m\_outputStrides[output\_stride\_index];
00162     Index inputIndex = 0;
00163     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00164       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i > 0; --i) \{
00165         \textcolor{keyword}{const} Index patchIdx = patchIndex / m\_patchStrides[i];
00166         patchIndex -= patchIdx * m\_patchStrides[i];
00167         \textcolor{keyword}{const} Index offsetIdx = patchOffset / m\_outputStrides[i];
00168         patchOffset -= offsetIdx * m\_outputStrides[i];
00169         inputIndex += (patchIdx + offsetIdx) * m\_inputStrides[i];
00170       \}
00171     \} \textcolor{keywordflow}{else} \{
00172       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 2; ++i) \{
00173         \textcolor{keyword}{const} Index patchIdx = patchIndex / m\_patchStrides[i];
00174         patchIndex -= patchIdx * m\_patchStrides[i];
00175         \textcolor{keyword}{const} Index offsetIdx = patchOffset / m\_outputStrides[i+1];
00176         patchOffset -= offsetIdx * m\_outputStrides[i+1];
00177         inputIndex += (patchIdx + offsetIdx) * m\_inputStrides[i];
00178       \}
00179     \}
00180     inputIndex += (patchIndex + patchOffset);
00181     \textcolor{keywordflow}{return} m\_impl.coeff(inputIndex);
00182   \}
00183 
00184   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00185   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00186 \textcolor{keyword}{  }\{
00187     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00188     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00189 
00190     Index output\_stride\_index = (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) ? NumDims - 1 : 0;
00191     Index indices[2] = \{index, index + PacketSize - 1\};
00192     Index patchIndices[2] = \{indices[0] / m\_outputStrides[output\_stride\_index],
00193                              indices[1] / m\_outputStrides[output\_stride\_index]\};
00194     Index patchOffsets[2] = \{indices[0] - patchIndices[0] * m\_outputStrides[output\_stride\_index],
00195                              indices[1] - patchIndices[1] * m\_outputStrides[output\_stride\_index]\};
00196 
00197     Index inputIndices[2] = \{0, 0\};
00198     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00199       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i > 0; --i) \{
00200         \textcolor{keyword}{const} Index patchIdx[2] = \{patchIndices[0] / m\_patchStrides[i],
00201                                    patchIndices[1] / m\_patchStrides[i]\};
00202         patchIndices[0] -= patchIdx[0] * m\_patchStrides[i];
00203         patchIndices[1] -= patchIdx[1] * m\_patchStrides[i];
00204 
00205         \textcolor{keyword}{const} Index offsetIdx[2] = \{patchOffsets[0] / m\_outputStrides[i],
00206                                     patchOffsets[1] / m\_outputStrides[i]\};
00207         patchOffsets[0] -= offsetIdx[0] * m\_outputStrides[i];
00208         patchOffsets[1] -= offsetIdx[1] * m\_outputStrides[i];
00209 
00210         inputIndices[0] += (patchIdx[0] + offsetIdx[0]) * m\_inputStrides[i];
00211         inputIndices[1] += (patchIdx[1] + offsetIdx[1]) * m\_inputStrides[i];
00212       \}
00213     \} \textcolor{keywordflow}{else} \{
00214       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 2; ++i) \{
00215         \textcolor{keyword}{const} Index patchIdx[2] = \{patchIndices[0] / m\_patchStrides[i],
00216                                    patchIndices[1] / m\_patchStrides[i]\};
00217         patchIndices[0] -= patchIdx[0] * m\_patchStrides[i];
00218         patchIndices[1] -= patchIdx[1] * m\_patchStrides[i];
00219 
00220         \textcolor{keyword}{const} Index offsetIdx[2] = \{patchOffsets[0] / m\_outputStrides[i+1],
00221                                     patchOffsets[1] / m\_outputStrides[i+1]\};
00222         patchOffsets[0] -= offsetIdx[0] * m\_outputStrides[i+1];
00223         patchOffsets[1] -= offsetIdx[1] * m\_outputStrides[i+1];
00224 
00225         inputIndices[0] += (patchIdx[0] + offsetIdx[0]) * m\_inputStrides[i];
00226         inputIndices[1] += (patchIdx[1] + offsetIdx[1]) * m\_inputStrides[i];
00227       \}
00228     \}
00229     inputIndices[0] += (patchIndices[0] + patchOffsets[0]);
00230     inputIndices[1] += (patchIndices[1] + patchOffsets[1]);
00231 
00232     \textcolor{keywordflow}{if} (inputIndices[1] - inputIndices[0] == PacketSize - 1) \{
00233       PacketReturnType rslt = m\_impl.template packet<Unaligned>(inputIndices[0]);
00234       \textcolor{keywordflow}{return} rslt;
00235     \}
00236     \textcolor{keywordflow}{else} \{
00237       EIGEN\_ALIGN\_MAX CoeffReturnType values[PacketSize];
00238       values[0] = m\_impl.coeff(inputIndices[0]);
00239       values[PacketSize-1] = m\_impl.coeff(inputIndices[1]);
00240       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < PacketSize-1; ++i) \{
00241         values[i] = coeff(index+i);
00242       \}
00243       PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00244       \textcolor{keywordflow}{return} rslt;
00245     \}
00246   \}
00247 
00248   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost} costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00249     \textcolor{keyword}{const} \textcolor{keywordtype}{double} compute\_cost = NumDims * (TensorOpCost::DivCost<Index>() +
00250                                            TensorOpCost::MulCost<Index>() +
00251                                            2 * TensorOpCost::AddCost<Index>());
00252     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) +
00253            \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, compute\_cost, vectorized, PacketSize);
00254   \}
00255 
00256   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00257 
00258  \textcolor{keyword}{protected}:
00259   Dimensions m\_dimensions;
00260   \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} m\_outputStrides;
00261   \hyperlink{class_eigen_1_1array}{array}<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, NumDims-1> m\_inputStrides;
00262   \hyperlink{class_eigen_1_1array}{array}<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, NumDims-1> m\_patchStrides;
00263 
00264   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} m\_impl;
00265 \};
00266 
00267 \} \textcolor{comment}{// end namespace Eigen}
00268 
00269 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_PATCH\_H}
\end{DoxyCode}
