\hypertarget{eigen_2test_2qtvector_8cpp_source}{}\section{eigen/test/qtvector.cpp}
\label{eigen_2test_2qtvector_8cpp_source}\index{qtvector.\+cpp@{qtvector.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#define EIGEN\_WORK\_AROUND\_QT\_BUG\_CALLING\_WRONG\_OPERATOR\_NEW\_FIXED\_IN\_QT\_4\_5}
00012 
00013 \textcolor{preprocessor}{#include "main.h"}
00014 \textcolor{preprocessor}{#include <QtCore/QVector>}
00015 \textcolor{preprocessor}{#include <Eigen/Geometry>}
00016 \textcolor{preprocessor}{#include <Eigen/QtAlignedMalloc>}
00017 
00018 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00019 \textcolor{keywordtype}{void} check\_qtvector\_matrix(\textcolor{keyword}{const} MatrixType& m)
00020 \{
00021   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00022 
00023   Index rows = m.rows();
00024   Index cols = m.cols();
00025   MatrixType x = MatrixType::Random(rows,cols), y = MatrixType::Random(rows,cols);
00026   QVector<MatrixType> v(10, MatrixType(rows,cols)), w(20, y);
00027   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00028   \{
00029     VERIFY\_IS\_APPROX(w[i], y);
00030   \}
00031   v[5] = x;
00032   w[6] = v[5];
00033   VERIFY\_IS\_APPROX(w[6], v[5]);
00034   v = w;
00035   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00036   \{
00037     VERIFY\_IS\_APPROX(w[i], v[i]);
00038   \}
00039 
00040   v.resize(21);
00041   v[20] = x;
00042   VERIFY\_IS\_APPROX(v[20], x);
00043   v.fill(y,22);
00044   VERIFY\_IS\_APPROX(v[21], y);
00045   v.push\_back(x);
00046   VERIFY\_IS\_APPROX(v[22], x);
00047   VERIFY((\textcolor{keywordtype}{size\_t})&(v[22]) == (\textcolor{keywordtype}{size\_t})&(v[21]) + \textcolor{keyword}{sizeof}(MatrixType));
00048 
00049   \textcolor{comment}{// do a lot of push\_back such that the vector gets internally resized}
00050   \textcolor{comment}{// (with memory reallocation)}
00051   MatrixType* ref = &w[0];
00052   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<30 || ((ref==&w[0]) && i<300); ++i)
00053     v.push\_back(w[i%w.size()]);
00054   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=23; i<v.size(); ++i)
00055   \{
00056     VERIFY(v[i]==w[(i-23)%w.size()]);
00057   \}
00058 \}
00059 
00060 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TransformType>
00061 \textcolor{keywordtype}{void} check\_qtvector\_transform(\textcolor{keyword}{const} TransformType&)
00062 \{
00063   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} TransformType::MatrixType MatrixType;
00064   TransformType x(MatrixType::Random()), y(MatrixType::Random());
00065   QVector<TransformType> v(10), w(20, y);
00066   v[5] = x;
00067   w[6] = v[5];
00068   VERIFY\_IS\_APPROX(w[6], v[5]);
00069   v = w;
00070   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00071   \{
00072     VERIFY\_IS\_APPROX(w[i], v[i]);
00073   \}
00074 
00075   v.resize(21);
00076   v[20] = x;
00077   VERIFY\_IS\_APPROX(v[20], x);
00078   v.fill(y,22);
00079   VERIFY\_IS\_APPROX(v[21], y);
00080   v.push\_back(x);
00081   VERIFY\_IS\_APPROX(v[22], x);
00082   VERIFY((\textcolor{keywordtype}{size\_t})&(v[22]) == (\textcolor{keywordtype}{size\_t})&(v[21]) + \textcolor{keyword}{sizeof}(TransformType));
00083 
00084   \textcolor{comment}{// do a lot of push\_back such that the vector gets internally resized}
00085   \textcolor{comment}{// (with memory reallocation)}
00086   TransformType* ref = &w[0];
00087   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<30 || ((ref==&w[0]) && i<300); ++i)
00088     v.push\_back(w[i%w.size()]);
00089   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=23; int(i)<v.size(); ++i)
00090   \{
00091     VERIFY(v[i].matrix()==w[(i-23)%w.size()].matrix());
00092   \}
00093 \}
00094 
00095 \textcolor{keyword}{template}<\textcolor{keyword}{typename} QuaternionType>
00096 \textcolor{keywordtype}{void} check\_qtvector\_quaternion(\textcolor{keyword}{const} QuaternionType&)
00097 \{
00098   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} QuaternionType::Coefficients Coefficients;
00099   QuaternionType x(Coefficients::Random()), y(Coefficients::Random());
00100   QVector<QuaternionType> v(10), w(20, y);
00101   v[5] = x;
00102   w[6] = v[5];
00103   VERIFY\_IS\_APPROX(w[6], v[5]);
00104   v = w;
00105   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00106   \{
00107     VERIFY\_IS\_APPROX(w[i], v[i]);
00108   \}
00109 
00110   v.resize(21);
00111   v[20] = x;
00112   VERIFY\_IS\_APPROX(v[20], x);
00113   v.fill(y,22);
00114   VERIFY\_IS\_APPROX(v[21], y);
00115   v.push\_back(x);
00116   VERIFY\_IS\_APPROX(v[22], x);
00117   VERIFY((\textcolor{keywordtype}{size\_t})&(v[22]) == (\textcolor{keywordtype}{size\_t})&(v[21]) + \textcolor{keyword}{sizeof}(QuaternionType));
00118 
00119   \textcolor{comment}{// do a lot of push\_back such that the vector gets internally resized}
00120   \textcolor{comment}{// (with memory reallocation)}
00121   QuaternionType* ref = &w[0];
00122   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<30 || ((ref==&w[0]) && i<300); ++i)
00123     v.push\_back(w[i%w.size()]);
00124   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=23; int(i)<v.size(); ++i)
00125   \{
00126     VERIFY(v[i].coeffs()==w[(i-23)%w.size()].coeffs());
00127   \}
00128 \}
00129 
00130 \textcolor{keywordtype}{void} test\_qtvector()
00131 \{
00132   \textcolor{comment}{// some non vectorizable fixed sizes}
00133   CALL\_SUBTEST(check\_qtvector\_matrix(Vector2f()));
00134   CALL\_SUBTEST(check\_qtvector\_matrix(Matrix3f()));
00135   CALL\_SUBTEST(check\_qtvector\_matrix(Matrix3d()));
00136 
00137   \textcolor{comment}{// some vectorizable fixed sizes}
00138   CALL\_SUBTEST(check\_qtvector\_matrix(Matrix2f()));
00139   CALL\_SUBTEST(check\_qtvector\_matrix(Vector4f()));
00140   CALL\_SUBTEST(check\_qtvector\_matrix(Matrix4f()));
00141   CALL\_SUBTEST(check\_qtvector\_matrix(Matrix4d()));
00142 
00143   \textcolor{comment}{// some dynamic sizes}
00144   CALL\_SUBTEST(check\_qtvector\_matrix(MatrixXd(1,1)));
00145   CALL\_SUBTEST(check\_qtvector\_matrix(VectorXd(20)));
00146   CALL\_SUBTEST(check\_qtvector\_matrix(RowVectorXf(20)));
00147   CALL\_SUBTEST(check\_qtvector\_matrix(MatrixXcf(10,10)));
00148 
00149   \textcolor{comment}{// some Transform}
00150   CALL\_SUBTEST(check\_qtvector\_transform(\hyperlink{group___geometry___module_ga2c1ea05a21899654ee3a2e3f91fa30e0}{Affine2f}()));
00151   CALL\_SUBTEST(check\_qtvector\_transform(\hyperlink{group___geometry___module_ga17e901de8ff882aea7845c5457db6a4f}{Affine3f}()));
00152   CALL\_SUBTEST(check\_qtvector\_transform(\hyperlink{group___geometry___module_gaaffa69d3143826efeb84e5d6c56a4c78}{Affine3d}()));
00153   \textcolor{comment}{//CALL\_SUBTEST(check\_qtvector\_transform(Transform4d()));}
00154 
00155   \textcolor{comment}{// some Quaternion}
00156   CALL\_SUBTEST(check\_qtvector\_quaternion(\hyperlink{group___geometry___module_ga785b13a5a87f9bf55d4eba51ead2dcf0}{Quaternionf}()));
00157   CALL\_SUBTEST(check\_qtvector\_quaternion(\hyperlink{group___geometry___module_ga785b13a5a87f9bf55d4eba51ead2dcf0}{Quaternionf}()));
00158 \}
\end{DoxyCode}
