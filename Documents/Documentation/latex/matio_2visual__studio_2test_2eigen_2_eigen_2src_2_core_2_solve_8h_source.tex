\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_solve_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/\+Solve.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_solve_8h_source}\index{Solve.\+h@{Solve.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SOLVE\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SOLVE\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Decomposition, \textcolor{keyword}{typename} RhsType, \textcolor{keyword}{typename} StorageKind> \textcolor{keyword}{class }SolveImpl;
00016   
00029 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00030 
00031 \textcolor{comment}{// this solve\_traits class permits to determine the evaluation type with respect to storage kind (Dense vs
       Sparse)}
00032 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Decomposition, \textcolor{keyword}{typename} RhsType,\textcolor{keyword}{typename} StorageKind> \textcolor{keyword}{struct }solve\_traits;
00033 
00034 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Decomposition, \textcolor{keyword}{typename} RhsType>
00035 \textcolor{keyword}{struct }solve\_traits<Decomposition,RhsType,Dense>
00036 \{
00037   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} make\_proper\_matrix\_type<\textcolor{keyword}{typename} RhsType::Scalar,
00038                  Decomposition::ColsAtCompileTime,
00039                  RhsType::ColsAtCompileTime,
00040                  RhsType::PlainObject::Options,
00041                  Decomposition::MaxColsAtCompileTime,
00042                  RhsType::MaxColsAtCompileTime>::type PlainObject;
00043 \};
00044 
00045 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Decomposition, \textcolor{keyword}{typename} RhsType>
00046 \textcolor{keyword}{struct }traits<Solve<Decomposition, RhsType> >
00047   : traits<typename solve\_traits<Decomposition,RhsType,typename internal::traits<RhsType>::StorageKind>::Pl
      ainObject>
00048 \{
00049   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} solve\_traits<Decomposition,RhsType,typename internal::traits<RhsType>::StorageKind>
      ::PlainObject PlainObject;
00050   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} promote\_index\_type<typename Decomposition::StorageIndex, typename
       RhsType::StorageIndex>::type StorageIndex;
00051   \textcolor{keyword}{typedef} traits<PlainObject> BaseTraits;
00052   \textcolor{keyword}{enum} \{
00053     Flags = BaseTraits::Flags & \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit},
00054     CoeffReadCost = \hyperlink{namespace_eigen_a3163430a1c13173faffde69016b48aaf}{HugeCost}
00055   \};
00056 \};
00057 
00058 \}
00059 
00060 
00061 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Decomposition, \textcolor{keyword}{typename} RhsType>
00062 \textcolor{keyword}{class }Solve : \textcolor{keyword}{public} SolveImpl<Decomposition,RhsType,typename internal::traits<RhsType>::StorageKind>
00063 \{
00064 \textcolor{keyword}{public}:
00065   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<Solve>::PlainObject PlainObject;
00066   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<Solve>::StorageIndex StorageIndex;
00067   
00068   Solve(\textcolor{keyword}{const} Decomposition &dec, \textcolor{keyword}{const} RhsType &rhs)
00069     : m\_dec(dec), m\_rhs(rhs)
00070   \{\}
00071   
00072   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dec.cols(); \}
00073   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rhs.cols(); \}
00074 
00075   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} Decomposition& dec()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dec; \}
00076   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} RhsType&       rhs()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rhs; \}
00077 
00078 \textcolor{keyword}{protected}:
00079   \textcolor{keyword}{const} Decomposition &m\_dec;
00080   \textcolor{keyword}{const} RhsType       &m\_rhs;
00081 \};
00082 
00083 
00084 \textcolor{comment}{// Specialization of the Solve expression for dense results}
00085 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Decomposition, \textcolor{keyword}{typename} RhsType>
00086 \textcolor{keyword}{class }SolveImpl<Decomposition,RhsType,Dense>
00087   : \textcolor{keyword}{public} MatrixBase<Solve<Decomposition,RhsType> >
00088 \{
00089   \textcolor{keyword}{typedef} Solve<Decomposition,RhsType> Derived;
00090   
00091 \textcolor{keyword}{public}:
00092   
00093   \textcolor{keyword}{typedef} MatrixBase<Solve<Decomposition,RhsType> > Base;
00094   EIGEN\_DENSE\_PUBLIC\_INTERFACE(Derived)
00095 
00096 \textcolor{keyword}{private}:
00097   
00098   Scalar coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col) \textcolor{keyword}{const};
00099   Scalar coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i) \textcolor{keyword}{const};
00100 \};
00101 
00102 \textcolor{comment}{// Generic API dispatcher}
00103 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Decomposition, \textcolor{keyword}{typename} RhsType, \textcolor{keyword}{typename} StorageKind>
00104 \textcolor{keyword}{class }SolveImpl : \textcolor{keyword}{public} internal::generic\_xpr\_base<Solve<Decomposition,RhsType>, MatrixXpr, StorageKind>
      ::type
00105 \{
00106   \textcolor{keyword}{public}:
00107     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::generic\_xpr\_base<Solve<Decomposition,RhsType>, MatrixXpr, StorageKind>::type
       Base;
00108 \};
00109 
00110 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00111 
00112 \textcolor{comment}{// Evaluator of Solve -> eval into a temporary}
00113 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Decomposition, \textcolor{keyword}{typename} RhsType>
00114 \textcolor{keyword}{struct }evaluator<Solve<Decomposition,RhsType> >
00115   : \textcolor{keyword}{public} evaluator<typename Solve<Decomposition,RhsType>::PlainObject>
00116 \{
00117   \textcolor{keyword}{typedef} Solve<Decomposition,RhsType> SolveType;
00118   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SolveType::PlainObject PlainObject;
00119   \textcolor{keyword}{typedef} evaluator<PlainObject> Base;
00120 
00121   \textcolor{keyword}{enum} \{ Flags = Base::Flags | \hyperlink{group__flags_gaa34e83bae46a8eeae4e69ebe3aaecbed}{EvalBeforeNestingBit} \};
00122   
00123   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} SolveType& solve)
00124     : m\_result(solve.rows(), solve.cols())
00125   \{
00126     ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(m\_result);
00127     solve.dec().\_solve\_impl(solve.rhs(), m\_result);
00128   \}
00129   
00130 protected:  
00131   PlainObject m\_result;
00132 \};
00133 
00134 \textcolor{comment}{// Specialization for "dst = dec.solve(rhs)"}
00135 \textcolor{comment}{// NOTE we need to specialize it for Dense2Dense to avoid ambiguous specialization error and a
       Sparse2Sparse specialization must exist somewhere}
00136 template<typename DstXprType, typename DecType, typename RhsType, typename Scalar>
00137 struct Assignment<DstXprType, Solve<DecType,RhsType>, \hyperlink{namespaceinternal}{internal}::assign\_op<Scalar,Scalar>, 
      Dense2Dense>
00138 \{
00139   \textcolor{keyword}{typedef} Solve<DecType,RhsType> SrcXprType;
00140   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} internal::assign\_op<Scalar,Scalar> &)
00141   \{
00142     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstRows = src.rows();
00143     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstCols = src.cols();
00144     \textcolor{keywordflow}{if}((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
00145       dst.resize(dstRows, dstCols);
00146 
00147     src.dec().\_solve\_impl(src.rhs(), dst);
00148   \}
00149 \};
00150 
00151 \textcolor{comment}{// Specialization for "dst = dec.transpose().solve(rhs)"}
00152 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} DecType, \textcolor{keyword}{typename} RhsType, \textcolor{keyword}{typename} Scalar>
00153 \textcolor{keyword}{struct }Assignment<DstXprType, Solve<Transpose<const DecType>,RhsType>, \hyperlink{namespaceinternal}{internal}::assign\_op<Scalar,S
      calar>, Dense2Dense>
00154 \{
00155   \textcolor{keyword}{typedef} Solve<Transpose<const DecType>,RhsType> SrcXprType;
00156   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} internal::assign\_op<Scalar,Scalar> &)
00157   \{
00158     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstRows = src.rows();
00159     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstCols = src.cols();
00160     \textcolor{keywordflow}{if}((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
00161       dst.resize(dstRows, dstCols);
00162 
00163     src.dec().nestedExpression().template \_solve\_impl\_transposed<false>(src.rhs(), dst);
00164   \}
00165 \};
00166 
00167 \textcolor{comment}{// Specialization for "dst = dec.adjoint().solve(rhs)"}
00168 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} DecType, \textcolor{keyword}{typename} RhsType, \textcolor{keyword}{typename} Scalar>
00169 \textcolor{keyword}{struct }Assignment<DstXprType, Solve<CwiseUnaryOp<\hyperlink{namespaceinternal}{internal}::scalar\_conjugate\_op<typename DecType::Sc
      alar>, const Transpose<const DecType> >,RhsType>,
00170                   internal::assign\_op<Scalar,Scalar>, Dense2Dense>
00171 \{
00172   \textcolor{keyword}{typedef} Solve<CwiseUnaryOp<internal::scalar\_conjugate\_op<typename DecType::Scalar>, \textcolor{keyword}{const} Transpose<const
       DecType> >,RhsType> SrcXprType;
00173   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} internal::assign\_op<Scalar,Scalar> &)
00174   \{
00175     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstRows = src.rows();
00176     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstCols = src.cols();
00177     \textcolor{keywordflow}{if}((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
00178       dst.resize(dstRows, dstCols);
00179     
00180     src.dec().nestedExpression().nestedExpression().template \_solve\_impl\_transposed<true>(src.rhs(), dst);
00181   \}
00182 \};
00183 
00184 \} \textcolor{comment}{// end namepsace internal}
00185 
00186 \} \textcolor{comment}{// end namespace Eigen}
00187 
00188 \textcolor{preprocessor}{#endif // EIGEN\_SOLVE\_H}
\end{DoxyCode}
