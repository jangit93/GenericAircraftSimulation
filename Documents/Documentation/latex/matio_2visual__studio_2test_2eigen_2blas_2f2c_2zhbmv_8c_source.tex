\hypertarget{matio_2visual__studio_2test_2eigen_2blas_2f2c_2zhbmv_8c_source}{}\section{matio/visual\+\_\+studio/test/eigen/blas/f2c/zhbmv.c}
\label{matio_2visual__studio_2test_2eigen_2blas_2f2c_2zhbmv_8c_source}\index{zhbmv.\+c@{zhbmv.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* zhbmv.f -- translated by f2c (version 20100827).}
00002 \textcolor{comment}{   You must link the resulting object file with libf2c:}
00003 \textcolor{comment}{    on Microsoft Windows system, link with libf2c.lib;}
00004 \textcolor{comment}{    on Linux or Unix systems, link with .../path/to/libf2c.a -lm}
00005 \textcolor{comment}{    or, if you install libf2c.a in a standard place, with -lf2c -lm}
00006 \textcolor{comment}{    -- in that order, at the end of the command line, as in}
00007 \textcolor{comment}{        cc *.o -lf2c -lm}
00008 \textcolor{comment}{    Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,}
00009 \textcolor{comment}{}
00010 \textcolor{comment}{        http://www.netlib.org/f2c/libf2c.zip}
00011 \textcolor{comment}{*/}
00012 
00013 \textcolor{preprocessor}{#include "datatypes.h"}
00014 
00015 \textcolor{comment}{/* Subroutine */} \textcolor{keywordtype}{int} zhbmv\_(\textcolor{keywordtype}{char} *uplo, integer *n, integer *k, \hyperlink{structdoublecomplex}{doublecomplex} 
00016     *alpha, \hyperlink{structdoublecomplex}{doublecomplex} *a, integer *lda, \hyperlink{structdoublecomplex}{doublecomplex} *x, integer *
00017     incx, \hyperlink{structdoublecomplex}{doublecomplex} *beta, \hyperlink{structdoublecomplex}{doublecomplex} *y, integer *incy, ftnlen 
00018     uplo\_len)
00019 \{
00020     \textcolor{comment}{/* System generated locals */}
00021     integer a\_dim1, a\_offset, i\_\_1, i\_\_2, i\_\_3, i\_\_4, i\_\_5;
00022     doublereal d\_\_1;
00023     \hyperlink{structdoublecomplex}{doublecomplex} z\_\_1, z\_\_2, z\_\_3, z\_\_4;
00024 
00025     \textcolor{comment}{/* Builtin functions */}
00026     \textcolor{keywordtype}{void} d\_cnjg(\hyperlink{structdoublecomplex}{doublecomplex} *, \hyperlink{structdoublecomplex}{doublecomplex} *);
00027 
00028     \textcolor{comment}{/* Local variables */}
00029     integer i\_\_, j, l, ix, iy, jx, jy, kx, ky, info;
00030     \hyperlink{structdoublecomplex}{doublecomplex} temp1, temp2;
00031     \textcolor{keyword}{extern} logical lsame\_(\textcolor{keywordtype}{char} *, \textcolor{keywordtype}{char} *, ftnlen, ftnlen);
00032     integer kplus1;
00033     \textcolor{keyword}{extern} \textcolor{comment}{/* Subroutine */} \textcolor{keywordtype}{int} xerbla\_(\textcolor{keywordtype}{char} *, integer *, ftnlen);
00034 
00035 \textcolor{comment}{/*     .. Scalar Arguments .. */}
00036 \textcolor{comment}{/*     .. */}
00037 \textcolor{comment}{/*     .. Array Arguments .. */}
00038 \textcolor{comment}{/*     .. */}
00039 
00040 \textcolor{comment}{/*  Purpose */}
00041 \textcolor{comment}{/*  ======= */}
00042 
00043 \textcolor{comment}{/*  ZHBMV  performs the matrix-vector  operation */}
00044 
00045 \textcolor{comment}{/*     y := alpha*A*x + beta*y, */}
00046 
00047 \textcolor{comment}{/*  where alpha and beta are scalars, x and y are n element vectors and */}
00048 \textcolor{comment}{/*  A is an n by n hermitian band matrix, with k super-diagonals. */}
00049 
00050 \textcolor{comment}{/*  Arguments */}
00051 \textcolor{comment}{/*  ========== */}
00052 
00053 \textcolor{comment}{/*  UPLO   - CHARACTER*1. */}
00054 \textcolor{comment}{/*           On entry, UPLO specifies whether the upper or lower */}
00055 \textcolor{comment}{/*           triangular part of the band matrix A is being supplied as */}
00056 \textcolor{comment}{/*           follows: */}
00057 
00058 \textcolor{comment}{/*              UPLO = 'U' or 'u'   The upper triangular part of A is */}
00059 \textcolor{comment}{/*                                  being supplied. */}
00060 
00061 \textcolor{comment}{/*              UPLO = 'L' or 'l'   The lower triangular part of A is */}
00062 \textcolor{comment}{/*                                  being supplied. */}
00063 
00064 \textcolor{comment}{/*           Unchanged on exit. */}
00065 
00066 \textcolor{comment}{/*  N      - INTEGER. */}
00067 \textcolor{comment}{/*           On entry, N specifies the order of the matrix A. */}
00068 \textcolor{comment}{/*           N must be at least zero. */}
00069 \textcolor{comment}{/*           Unchanged on exit. */}
00070 
00071 \textcolor{comment}{/*  K      - INTEGER. */}
00072 \textcolor{comment}{/*           On entry, K specifies the number of super-diagonals of the */}
00073 \textcolor{comment}{/*           matrix A. K must satisfy  0 .le. K. */}
00074 \textcolor{comment}{/*           Unchanged on exit. */}
00075 
00076 \textcolor{comment}{/*  ALPHA  - COMPLEX*16      . */}
00077 \textcolor{comment}{/*           On entry, ALPHA specifies the scalar alpha. */}
00078 \textcolor{comment}{/*           Unchanged on exit. */}
00079 
00080 \textcolor{comment}{/*  A      - COMPLEX*16       array of DIMENSION ( LDA, n ). */}
00081 \textcolor{comment}{/*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) */}
00082 \textcolor{comment}{/*           by n part of the array A must contain the upper triangular */}
00083 \textcolor{comment}{/*           band part of the hermitian matrix, supplied column by */}
00084 \textcolor{comment}{/*           column, with the leading diagonal of the matrix in row */}
00085 \textcolor{comment}{/*           ( k + 1 ) of the array, the first super-diagonal starting at */}
00086 \textcolor{comment}{/*           position 2 in row k, and so on. The top left k by k triangle */}
00087 \textcolor{comment}{/*           of the array A is not referenced. */}
00088 \textcolor{comment}{/*           The following program segment will transfer the upper */}
00089 \textcolor{comment}{/*           triangular part of a hermitian band matrix from conventional */}
00090 \textcolor{comment}{/*           full matrix storage to band storage: */}
00091 
00092 \textcolor{comment}{/*                 DO 20, J = 1, N */}
00093 \textcolor{comment}{/*                    M = K + 1 - J */}
00094 \textcolor{comment}{/*                    DO 10, I = MAX( 1, J - K ), J */}
00095 \textcolor{comment}{/*                       A( M + I, J ) = matrix( I, J ) */}
00096 \textcolor{comment}{/*              10    CONTINUE */}
00097 \textcolor{comment}{/*              20 CONTINUE */}
00098 
00099 \textcolor{comment}{/*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) */}
00100 \textcolor{comment}{/*           by n part of the array A must contain the lower triangular */}
00101 \textcolor{comment}{/*           band part of the hermitian matrix, supplied column by */}
00102 \textcolor{comment}{/*           column, with the leading diagonal of the matrix in row 1 of */}
00103 \textcolor{comment}{/*           the array, the first sub-diagonal starting at position 1 in */}
00104 \textcolor{comment}{/*           row 2, and so on. The bottom right k by k triangle of the */}
00105 \textcolor{comment}{/*           array A is not referenced. */}
00106 \textcolor{comment}{/*           The following program segment will transfer the lower */}
00107 \textcolor{comment}{/*           triangular part of a hermitian band matrix from conventional */}
00108 \textcolor{comment}{/*           full matrix storage to band storage: */}
00109 
00110 \textcolor{comment}{/*                 DO 20, J = 1, N */}
00111 \textcolor{comment}{/*                    M = 1 - J */}
00112 \textcolor{comment}{/*                    DO 10, I = J, MIN( N, J + K ) */}
00113 \textcolor{comment}{/*                       A( M + I, J ) = matrix( I, J ) */}
00114 \textcolor{comment}{/*              10    CONTINUE */}
00115 \textcolor{comment}{/*              20 CONTINUE */}
00116 
00117 \textcolor{comment}{/*           Note that the imaginary parts of the diagonal elements need */}
00118 \textcolor{comment}{/*           not be set and are assumed to be zero. */}
00119 \textcolor{comment}{/*           Unchanged on exit. */}
00120 
00121 \textcolor{comment}{/*  LDA    - INTEGER. */}
00122 \textcolor{comment}{/*           On entry, LDA specifies the first dimension of A as declared */}
00123 \textcolor{comment}{/*           in the calling (sub) program. LDA must be at least */}
00124 \textcolor{comment}{/*           ( k + 1 ). */}
00125 \textcolor{comment}{/*           Unchanged on exit. */}
00126 
00127 \textcolor{comment}{/*  X      - COMPLEX*16       array of DIMENSION at least */}
00128 \textcolor{comment}{/*           ( 1 + ( n - 1 )*abs( INCX ) ). */}
00129 \textcolor{comment}{/*           Before entry, the incremented array X must contain the */}
00130 \textcolor{comment}{/*           vector x. */}
00131 \textcolor{comment}{/*           Unchanged on exit. */}
00132 
00133 \textcolor{comment}{/*  INCX   - INTEGER. */}
00134 \textcolor{comment}{/*           On entry, INCX specifies the increment for the elements of */}
00135 \textcolor{comment}{/*           X. INCX must not be zero. */}
00136 \textcolor{comment}{/*           Unchanged on exit. */}
00137 
00138 \textcolor{comment}{/*  BETA   - COMPLEX*16      . */}
00139 \textcolor{comment}{/*           On entry, BETA specifies the scalar beta. */}
00140 \textcolor{comment}{/*           Unchanged on exit. */}
00141 
00142 \textcolor{comment}{/*  Y      - COMPLEX*16       array of DIMENSION at least */}
00143 \textcolor{comment}{/*           ( 1 + ( n - 1 )*abs( INCY ) ). */}
00144 \textcolor{comment}{/*           Before entry, the incremented array Y must contain the */}
00145 \textcolor{comment}{/*           vector y. On exit, Y is overwritten by the updated vector y. */}
00146 
00147 \textcolor{comment}{/*  INCY   - INTEGER. */}
00148 \textcolor{comment}{/*           On entry, INCY specifies the increment for the elements of */}
00149 \textcolor{comment}{/*           Y. INCY must not be zero. */}
00150 \textcolor{comment}{/*           Unchanged on exit. */}
00151 
00152 \textcolor{comment}{/*  Further Details */}
00153 \textcolor{comment}{/*  =============== */}
00154 
00155 \textcolor{comment}{/*  Level 2 Blas routine. */}
00156 
00157 \textcolor{comment}{/*  -- Written on 22-October-1986. */}
00158 \textcolor{comment}{/*     Jack Dongarra, Argonne National Lab. */}
00159 \textcolor{comment}{/*     Jeremy Du Croz, Nag Central Office. */}
00160 \textcolor{comment}{/*     Sven Hammarling, Nag Central Office. */}
00161 \textcolor{comment}{/*     Richard Hanson, Sandia National Labs. */}
00162 
00163 \textcolor{comment}{/*  ===================================================================== */}
00164 
00165 \textcolor{comment}{/*     .. Parameters .. */}
00166 \textcolor{comment}{/*     .. */}
00167 \textcolor{comment}{/*     .. Local Scalars .. */}
00168 \textcolor{comment}{/*     .. */}
00169 \textcolor{comment}{/*     .. External Functions .. */}
00170 \textcolor{comment}{/*     .. */}
00171 \textcolor{comment}{/*     .. External Subroutines .. */}
00172 \textcolor{comment}{/*     .. */}
00173 \textcolor{comment}{/*     .. Intrinsic Functions .. */}
00174 \textcolor{comment}{/*     .. */}
00175 
00176 \textcolor{comment}{/*     Test the input parameters. */}
00177 
00178     \textcolor{comment}{/* Parameter adjustments */}
00179     a\_dim1 = *lda;
00180     a\_offset = 1 + a\_dim1;
00181     a -= a\_offset;
00182     --x;
00183     --y;
00184 
00185     \textcolor{comment}{/* Function Body */}
00186     info = 0;
00187     \textcolor{keywordflow}{if} (! lsame\_(uplo, \textcolor{stringliteral}{"U"}, (ftnlen)1, (ftnlen)1) && ! lsame\_(uplo, \textcolor{stringliteral}{"L"}, (
00188         ftnlen)1, (ftnlen)1)) \{
00189     info = 1;
00190     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*n < 0) \{
00191     info = 2;
00192     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*k < 0) \{
00193     info = 3;
00194     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*lda < *k + 1) \{
00195     info = 6;
00196     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*incx == 0) \{
00197     info = 8;
00198     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*incy == 0) \{
00199     info = 11;
00200     \}
00201     \textcolor{keywordflow}{if} (info != 0) \{
00202     xerbla\_(\textcolor{stringliteral}{"ZHBMV "}, &info, (ftnlen)6);
00203     \textcolor{keywordflow}{return} 0;
00204     \}
00205 
00206 \textcolor{comment}{/*     Quick return if possible. */}
00207 
00208     \textcolor{keywordflow}{if} (*n == 0 || (alpha->r == 0. && alpha->i == 0. && (beta->r == 1. && 
00209                                                          beta->i == 0.))) \{
00210     \textcolor{keywordflow}{return} 0;
00211     \}
00212 
00213 \textcolor{comment}{/*     Set up the start points in  X  and  Y. */}
00214 
00215     \textcolor{keywordflow}{if} (*incx > 0) \{
00216     kx = 1;
00217     \} \textcolor{keywordflow}{else} \{
00218     kx = 1 - (*n - 1) * *incx;
00219     \}
00220     \textcolor{keywordflow}{if} (*incy > 0) \{
00221     ky = 1;
00222     \} \textcolor{keywordflow}{else} \{
00223     ky = 1 - (*n - 1) * *incy;
00224     \}
00225 
00226 \textcolor{comment}{/*     Start the operations. In this version the elements of the array A */}
00227 \textcolor{comment}{/*     are accessed sequentially with one pass through A. */}
00228 
00229 \textcolor{comment}{/*     First form  y := beta*y. */}
00230 
00231     \textcolor{keywordflow}{if} (beta->r != 1. || beta->i != 0.) \{
00232     \textcolor{keywordflow}{if} (*incy == 1) \{
00233         \textcolor{keywordflow}{if} (beta->r == 0. && beta->i == 0.) \{
00234         i\_\_1 = *n;
00235         \textcolor{keywordflow}{for} (i\_\_ = 1; i\_\_ <= i\_\_1; ++i\_\_) \{
00236             i\_\_2 = i\_\_;
00237             y[i\_\_2].r = 0., y[i\_\_2].i = 0.;
00238 \textcolor{comment}{/* L10: */}
00239         \}
00240         \} \textcolor{keywordflow}{else} \{
00241         i\_\_1 = *n;
00242         \textcolor{keywordflow}{for} (i\_\_ = 1; i\_\_ <= i\_\_1; ++i\_\_) \{
00243             i\_\_2 = i\_\_;
00244             i\_\_3 = i\_\_;
00245             z\_\_1.r = beta->r * y[i\_\_3].r - beta->i * y[i\_\_3].i, 
00246                 z\_\_1.i = beta->r * y[i\_\_3].i + beta->i * y[i\_\_3]
00247                 .r;
00248             y[i\_\_2].r = z\_\_1.r, y[i\_\_2].i = z\_\_1.i;
00249 \textcolor{comment}{/* L20: */}
00250         \}
00251         \}
00252     \} \textcolor{keywordflow}{else} \{
00253         iy = ky;
00254         \textcolor{keywordflow}{if} (beta->r == 0. && beta->i == 0.) \{
00255         i\_\_1 = *n;
00256         \textcolor{keywordflow}{for} (i\_\_ = 1; i\_\_ <= i\_\_1; ++i\_\_) \{
00257             i\_\_2 = iy;
00258             y[i\_\_2].r = 0., y[i\_\_2].i = 0.;
00259             iy += *incy;
00260 \textcolor{comment}{/* L30: */}
00261         \}
00262         \} \textcolor{keywordflow}{else} \{
00263         i\_\_1 = *n;
00264         \textcolor{keywordflow}{for} (i\_\_ = 1; i\_\_ <= i\_\_1; ++i\_\_) \{
00265             i\_\_2 = iy;
00266             i\_\_3 = iy;
00267             z\_\_1.r = beta->r * y[i\_\_3].r - beta->i * y[i\_\_3].i, 
00268                 z\_\_1.i = beta->r * y[i\_\_3].i + beta->i * y[i\_\_3]
00269                 .r;
00270             y[i\_\_2].r = z\_\_1.r, y[i\_\_2].i = z\_\_1.i;
00271             iy += *incy;
00272 \textcolor{comment}{/* L40: */}
00273         \}
00274         \}
00275     \}
00276     \}
00277     \textcolor{keywordflow}{if} (alpha->r == 0. && alpha->i == 0.) \{
00278     \textcolor{keywordflow}{return} 0;
00279     \}
00280     \textcolor{keywordflow}{if} (lsame\_(uplo, \textcolor{stringliteral}{"U"}, (ftnlen)1, (ftnlen)1)) \{
00281 
00282 \textcolor{comment}{/*        Form  y  when upper triangle of A is stored. */}
00283 
00284     kplus1 = *k + 1;
00285     \textcolor{keywordflow}{if} (*incx == 1 && *incy == 1) \{
00286         i\_\_1 = *n;
00287         \textcolor{keywordflow}{for} (j = 1; j <= i\_\_1; ++j) \{
00288         i\_\_2 = j;
00289         z\_\_1.r = alpha->r * x[i\_\_2].r - alpha->i * x[i\_\_2].i, z\_\_1.i =
00290              alpha->r * x[i\_\_2].i + alpha->i * x[i\_\_2].r;
00291         temp1.r = z\_\_1.r, temp1.i = z\_\_1.i;
00292         temp2.r = 0., temp2.i = 0.;
00293         l = kplus1 - j;
00294 \textcolor{comment}{/* Computing MAX */}
00295         i\_\_2 = 1, i\_\_3 = j - *k;
00296         i\_\_4 = j - 1;
00297         \textcolor{keywordflow}{for} (i\_\_ = max(i\_\_2,i\_\_3); i\_\_ <= i\_\_4; ++i\_\_) \{
00298             i\_\_2 = i\_\_;
00299             i\_\_3 = i\_\_;
00300             i\_\_5 = l + i\_\_ + j * a\_dim1;
00301             z\_\_2.r = temp1.r * a[i\_\_5].r - temp1.i * a[i\_\_5].i, 
00302                 z\_\_2.i = temp1.r * a[i\_\_5].i + temp1.i * a[i\_\_5]
00303                 .r;
00304             z\_\_1.r = y[i\_\_3].r + z\_\_2.r, z\_\_1.i = y[i\_\_3].i + z\_\_2.i;
00305             y[i\_\_2].r = z\_\_1.r, y[i\_\_2].i = z\_\_1.i;
00306             d\_cnjg(&z\_\_3, &a[l + i\_\_ + j * a\_dim1]);
00307             i\_\_2 = i\_\_;
00308             z\_\_2.r = z\_\_3.r * x[i\_\_2].r - z\_\_3.i * x[i\_\_2].i, z\_\_2.i =
00309                  z\_\_3.r * x[i\_\_2].i + z\_\_3.i * x[i\_\_2].r;
00310             z\_\_1.r = temp2.r + z\_\_2.r, z\_\_1.i = temp2.i + z\_\_2.i;
00311             temp2.r = z\_\_1.r, temp2.i = z\_\_1.i;
00312 \textcolor{comment}{/* L50: */}
00313         \}
00314         i\_\_4 = j;
00315         i\_\_2 = j;
00316         i\_\_3 = kplus1 + j * a\_dim1;
00317         d\_\_1 = a[i\_\_3].r;
00318         z\_\_3.r = d\_\_1 * temp1.r, z\_\_3.i = d\_\_1 * temp1.i;
00319         z\_\_2.r = y[i\_\_2].r + z\_\_3.r, z\_\_2.i = y[i\_\_2].i + z\_\_3.i;
00320         z\_\_4.r = alpha->r * temp2.r - alpha->i * temp2.i, z\_\_4.i = 
00321             alpha->r * temp2.i + alpha->i * temp2.r;
00322         z\_\_1.r = z\_\_2.r + z\_\_4.r, z\_\_1.i = z\_\_2.i + z\_\_4.i;
00323         y[i\_\_4].r = z\_\_1.r, y[i\_\_4].i = z\_\_1.i;
00324 \textcolor{comment}{/* L60: */}
00325         \}
00326     \} \textcolor{keywordflow}{else} \{
00327         jx = kx;
00328         jy = ky;
00329         i\_\_1 = *n;
00330         \textcolor{keywordflow}{for} (j = 1; j <= i\_\_1; ++j) \{
00331         i\_\_4 = jx;
00332         z\_\_1.r = alpha->r * x[i\_\_4].r - alpha->i * x[i\_\_4].i, z\_\_1.i =
00333              alpha->r * x[i\_\_4].i + alpha->i * x[i\_\_4].r;
00334         temp1.r = z\_\_1.r, temp1.i = z\_\_1.i;
00335         temp2.r = 0., temp2.i = 0.;
00336         ix = kx;
00337         iy = ky;
00338         l = kplus1 - j;
00339 \textcolor{comment}{/* Computing MAX */}
00340         i\_\_4 = 1, i\_\_2 = j - *k;
00341         i\_\_3 = j - 1;
00342         \textcolor{keywordflow}{for} (i\_\_ = max(i\_\_4,i\_\_2); i\_\_ <= i\_\_3; ++i\_\_) \{
00343             i\_\_4 = iy;
00344             i\_\_2 = iy;
00345             i\_\_5 = l + i\_\_ + j * a\_dim1;
00346             z\_\_2.r = temp1.r * a[i\_\_5].r - temp1.i * a[i\_\_5].i, 
00347                 z\_\_2.i = temp1.r * a[i\_\_5].i + temp1.i * a[i\_\_5]
00348                 .r;
00349             z\_\_1.r = y[i\_\_2].r + z\_\_2.r, z\_\_1.i = y[i\_\_2].i + z\_\_2.i;
00350             y[i\_\_4].r = z\_\_1.r, y[i\_\_4].i = z\_\_1.i;
00351             d\_cnjg(&z\_\_3, &a[l + i\_\_ + j * a\_dim1]);
00352             i\_\_4 = ix;
00353             z\_\_2.r = z\_\_3.r * x[i\_\_4].r - z\_\_3.i * x[i\_\_4].i, z\_\_2.i =
00354                  z\_\_3.r * x[i\_\_4].i + z\_\_3.i * x[i\_\_4].r;
00355             z\_\_1.r = temp2.r + z\_\_2.r, z\_\_1.i = temp2.i + z\_\_2.i;
00356             temp2.r = z\_\_1.r, temp2.i = z\_\_1.i;
00357             ix += *incx;
00358             iy += *incy;
00359 \textcolor{comment}{/* L70: */}
00360         \}
00361         i\_\_3 = jy;
00362         i\_\_4 = jy;
00363         i\_\_2 = kplus1 + j * a\_dim1;
00364         d\_\_1 = a[i\_\_2].r;
00365         z\_\_3.r = d\_\_1 * temp1.r, z\_\_3.i = d\_\_1 * temp1.i;
00366         z\_\_2.r = y[i\_\_4].r + z\_\_3.r, z\_\_2.i = y[i\_\_4].i + z\_\_3.i;
00367         z\_\_4.r = alpha->r * temp2.r - alpha->i * temp2.i, z\_\_4.i = 
00368             alpha->r * temp2.i + alpha->i * temp2.r;
00369         z\_\_1.r = z\_\_2.r + z\_\_4.r, z\_\_1.i = z\_\_2.i + z\_\_4.i;
00370         y[i\_\_3].r = z\_\_1.r, y[i\_\_3].i = z\_\_1.i;
00371         jx += *incx;
00372         jy += *incy;
00373         \textcolor{keywordflow}{if} (j > *k) \{
00374             kx += *incx;
00375             ky += *incy;
00376         \}
00377 \textcolor{comment}{/* L80: */}
00378         \}
00379     \}
00380     \} \textcolor{keywordflow}{else} \{
00381 
00382 \textcolor{comment}{/*        Form  y  when lower triangle of A is stored. */}
00383 
00384     \textcolor{keywordflow}{if} (*incx == 1 && *incy == 1) \{
00385         i\_\_1 = *n;
00386         \textcolor{keywordflow}{for} (j = 1; j <= i\_\_1; ++j) \{
00387         i\_\_3 = j;
00388         z\_\_1.r = alpha->r * x[i\_\_3].r - alpha->i * x[i\_\_3].i, z\_\_1.i =
00389              alpha->r * x[i\_\_3].i + alpha->i * x[i\_\_3].r;
00390         temp1.r = z\_\_1.r, temp1.i = z\_\_1.i;
00391         temp2.r = 0., temp2.i = 0.;
00392         i\_\_3 = j;
00393         i\_\_4 = j;
00394         i\_\_2 = j * a\_dim1 + 1;
00395         d\_\_1 = a[i\_\_2].r;
00396         z\_\_2.r = d\_\_1 * temp1.r, z\_\_2.i = d\_\_1 * temp1.i;
00397         z\_\_1.r = y[i\_\_4].r + z\_\_2.r, z\_\_1.i = y[i\_\_4].i + z\_\_2.i;
00398         y[i\_\_3].r = z\_\_1.r, y[i\_\_3].i = z\_\_1.i;
00399         l = 1 - j;
00400 \textcolor{comment}{/* Computing MIN */}
00401         i\_\_4 = *n, i\_\_2 = j + *k;
00402         i\_\_3 = min(i\_\_4,i\_\_2);
00403         \textcolor{keywordflow}{for} (i\_\_ = j + 1; i\_\_ <= i\_\_3; ++i\_\_) \{
00404             i\_\_4 = i\_\_;
00405             i\_\_2 = i\_\_;
00406             i\_\_5 = l + i\_\_ + j * a\_dim1;
00407             z\_\_2.r = temp1.r * a[i\_\_5].r - temp1.i * a[i\_\_5].i, 
00408                 z\_\_2.i = temp1.r * a[i\_\_5].i + temp1.i * a[i\_\_5]
00409                 .r;
00410             z\_\_1.r = y[i\_\_2].r + z\_\_2.r, z\_\_1.i = y[i\_\_2].i + z\_\_2.i;
00411             y[i\_\_4].r = z\_\_1.r, y[i\_\_4].i = z\_\_1.i;
00412             d\_cnjg(&z\_\_3, &a[l + i\_\_ + j * a\_dim1]);
00413             i\_\_4 = i\_\_;
00414             z\_\_2.r = z\_\_3.r * x[i\_\_4].r - z\_\_3.i * x[i\_\_4].i, z\_\_2.i =
00415                  z\_\_3.r * x[i\_\_4].i + z\_\_3.i * x[i\_\_4].r;
00416             z\_\_1.r = temp2.r + z\_\_2.r, z\_\_1.i = temp2.i + z\_\_2.i;
00417             temp2.r = z\_\_1.r, temp2.i = z\_\_1.i;
00418 \textcolor{comment}{/* L90: */}
00419         \}
00420         i\_\_3 = j;
00421         i\_\_4 = j;
00422         z\_\_2.r = alpha->r * temp2.r - alpha->i * temp2.i, z\_\_2.i = 
00423             alpha->r * temp2.i + alpha->i * temp2.r;
00424         z\_\_1.r = y[i\_\_4].r + z\_\_2.r, z\_\_1.i = y[i\_\_4].i + z\_\_2.i;
00425         y[i\_\_3].r = z\_\_1.r, y[i\_\_3].i = z\_\_1.i;
00426 \textcolor{comment}{/* L100: */}
00427         \}
00428     \} \textcolor{keywordflow}{else} \{
00429         jx = kx;
00430         jy = ky;
00431         i\_\_1 = *n;
00432         \textcolor{keywordflow}{for} (j = 1; j <= i\_\_1; ++j) \{
00433         i\_\_3 = jx;
00434         z\_\_1.r = alpha->r * x[i\_\_3].r - alpha->i * x[i\_\_3].i, z\_\_1.i =
00435              alpha->r * x[i\_\_3].i + alpha->i * x[i\_\_3].r;
00436         temp1.r = z\_\_1.r, temp1.i = z\_\_1.i;
00437         temp2.r = 0., temp2.i = 0.;
00438         i\_\_3 = jy;
00439         i\_\_4 = jy;
00440         i\_\_2 = j * a\_dim1 + 1;
00441         d\_\_1 = a[i\_\_2].r;
00442         z\_\_2.r = d\_\_1 * temp1.r, z\_\_2.i = d\_\_1 * temp1.i;
00443         z\_\_1.r = y[i\_\_4].r + z\_\_2.r, z\_\_1.i = y[i\_\_4].i + z\_\_2.i;
00444         y[i\_\_3].r = z\_\_1.r, y[i\_\_3].i = z\_\_1.i;
00445         l = 1 - j;
00446         ix = jx;
00447         iy = jy;
00448 \textcolor{comment}{/* Computing MIN */}
00449         i\_\_4 = *n, i\_\_2 = j + *k;
00450         i\_\_3 = min(i\_\_4,i\_\_2);
00451         \textcolor{keywordflow}{for} (i\_\_ = j + 1; i\_\_ <= i\_\_3; ++i\_\_) \{
00452             ix += *incx;
00453             iy += *incy;
00454             i\_\_4 = iy;
00455             i\_\_2 = iy;
00456             i\_\_5 = l + i\_\_ + j * a\_dim1;
00457             z\_\_2.r = temp1.r * a[i\_\_5].r - temp1.i * a[i\_\_5].i, 
00458                 z\_\_2.i = temp1.r * a[i\_\_5].i + temp1.i * a[i\_\_5]
00459                 .r;
00460             z\_\_1.r = y[i\_\_2].r + z\_\_2.r, z\_\_1.i = y[i\_\_2].i + z\_\_2.i;
00461             y[i\_\_4].r = z\_\_1.r, y[i\_\_4].i = z\_\_1.i;
00462             d\_cnjg(&z\_\_3, &a[l + i\_\_ + j * a\_dim1]);
00463             i\_\_4 = ix;
00464             z\_\_2.r = z\_\_3.r * x[i\_\_4].r - z\_\_3.i * x[i\_\_4].i, z\_\_2.i =
00465                  z\_\_3.r * x[i\_\_4].i + z\_\_3.i * x[i\_\_4].r;
00466             z\_\_1.r = temp2.r + z\_\_2.r, z\_\_1.i = temp2.i + z\_\_2.i;
00467             temp2.r = z\_\_1.r, temp2.i = z\_\_1.i;
00468 \textcolor{comment}{/* L110: */}
00469         \}
00470         i\_\_3 = jy;
00471         i\_\_4 = jy;
00472         z\_\_2.r = alpha->r * temp2.r - alpha->i * temp2.i, z\_\_2.i = 
00473             alpha->r * temp2.i + alpha->i * temp2.r;
00474         z\_\_1.r = y[i\_\_4].r + z\_\_2.r, z\_\_1.i = y[i\_\_4].i + z\_\_2.i;
00475         y[i\_\_3].r = z\_\_1.r, y[i\_\_3].i = z\_\_1.i;
00476         jx += *incx;
00477         jy += *incy;
00478 \textcolor{comment}{/* L120: */}
00479         \}
00480     \}
00481     \}
00482 
00483     \textcolor{keywordflow}{return} 0;
00484 
00485 \textcolor{comment}{/*     End of ZHBMV . */}
00486 
00487 \} \textcolor{comment}{/* zhbmv\_ */}
00488 
\end{DoxyCode}
