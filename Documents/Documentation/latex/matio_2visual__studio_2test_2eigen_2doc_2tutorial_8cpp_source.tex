\hypertarget{matio_2visual__studio_2test_2eigen_2doc_2tutorial_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/doc/tutorial.cpp}
\label{matio_2visual__studio_2test_2eigen_2doc_2tutorial_8cpp_source}\index{tutorial.\+cpp@{tutorial.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#include <Eigen/Array>}
00002 
00003 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[])
00004 \{
00005   std::cout.precision(2);
00006 
00007   \textcolor{comment}{// demo static functions}
00008   Eigen::Matrix3f m3 = Eigen::Matrix3f::Random();
00009   Eigen::Matrix4f m4 = Eigen::Matrix4f::Identity();
00010 
00011   std::cout << \textcolor{stringliteral}{"*** Step 1 ***\(\backslash\)nm3:\(\backslash\)n"} << m3 << \textcolor{stringliteral}{"\(\backslash\)nm4:\(\backslash\)n"} << m4 << std::endl;
00012 
00013   \textcolor{comment}{// demo non-static set... functions}
00014   m4.setZero();
00015   m3.diagonal().setOnes();
00016   
00017   std::cout << \textcolor{stringliteral}{"*** Step 2 ***\(\backslash\)nm3:\(\backslash\)n"} << m3 << \textcolor{stringliteral}{"\(\backslash\)nm4:\(\backslash\)n"} << m4 << std::endl;
00018 
00019   \textcolor{comment}{// demo fixed-size block() expression as lvalue and as rvalue}
00020   m4.block<3,3>(0,1) = m3;
00021   m3.row(2) = m4.block<1,3>(2,0);
00022 
00023   std::cout << \textcolor{stringliteral}{"*** Step 3 ***\(\backslash\)nm3:\(\backslash\)n"} << m3 << \textcolor{stringliteral}{"\(\backslash\)nm4:\(\backslash\)n"} << m4 << std::endl;
00024 
00025   \textcolor{comment}{// demo dynamic-size block()}
00026   \{
00027     \textcolor{keywordtype}{int} rows = 3, cols = 3;
00028     m4.block(0,1,3,3).setIdentity();
00029     std::cout << \textcolor{stringliteral}{"*** Step 4 ***\(\backslash\)nm4:\(\backslash\)n"} << m4 << std::endl;
00030   \}
00031 
00032   \textcolor{comment}{// demo vector blocks}
00033   m4.diagonal().block(1,2).setOnes();
00034   std::cout << \textcolor{stringliteral}{"*** Step 5 ***\(\backslash\)nm4.diagonal():\(\backslash\)n"} << m4.diagonal() << std::endl;
00035   std::cout << \textcolor{stringliteral}{"m4.diagonal().start(3)\(\backslash\)n"} << m4.diagonal().start(3) << std::endl;
00036 
00037   \textcolor{comment}{// demo coeff-wise operations}
00038   m4 = m4.cwise()*m4;
00039   m3 = m3.cwise().cos();
00040   std::cout << \textcolor{stringliteral}{"*** Step 6 ***\(\backslash\)nm3:\(\backslash\)n"} << m3 << \textcolor{stringliteral}{"\(\backslash\)nm4:\(\backslash\)n"} << m4 << std::endl;
00041 
00042   \textcolor{comment}{// sums of coefficients}
00043   std::cout << \textcolor{stringliteral}{"*** Step 7 ***\(\backslash\)n m4.sum(): "} << m4.sum() << std::endl;
00044   std::cout << \textcolor{stringliteral}{"m4.col(2).sum(): "} << m4.col(2).sum() << std::endl;
00045   std::cout << \textcolor{stringliteral}{"m4.colwise().sum():\(\backslash\)n"} << m4.colwise().sum() << std::endl;
00046   std::cout << \textcolor{stringliteral}{"m4.rowwise().sum():\(\backslash\)n"} << m4.rowwise().sum() << std::endl;
00047 
00048   \textcolor{comment}{// demo intelligent auto-evaluation}
00049   m4 = m4 * m4; \textcolor{comment}{// auto-evaluates so no aliasing problem (performance penalty is low)}
00050   Eigen::Matrix4f other = (m4 * m4).lazy(); \textcolor{comment}{// forces lazy evaluation}
00051   m4 = m4 + m4; \textcolor{comment}{// here Eigen goes for lazy evaluation, as with most expressions}
00052   m4 = -m4 + m4 + 5 * m4; \textcolor{comment}{// same here, Eigen chooses lazy evaluation for all that.}
00053   m4 = m4 * (m4 + m4); \textcolor{comment}{// here Eigen chooses to first evaluate m4 + m4 into a temporary.}
00054                        \textcolor{comment}{// indeed, here it is an optimization to cache this intermediate result.}
00055   m3 = m3 * m4.block<3,3>(1,1); \textcolor{comment}{// here Eigen chooses NOT to evaluate block() into a temporary}
00056     \textcolor{comment}{// because accessing coefficients of that block expression is not more costly than accessing}
00057     \textcolor{comment}{// coefficients of a plain matrix.}
00058   m4 = m4 * m4.transpose(); \textcolor{comment}{// same here, lazy evaluation of the transpose.}
00059   m4 = m4 * m4.transpose().eval(); \textcolor{comment}{// forces immediate evaluation of the transpose}
00060 
00061   std::cout << \textcolor{stringliteral}{"*** Step 8 ***\(\backslash\)nm3:\(\backslash\)n"} << m3 << \textcolor{stringliteral}{"\(\backslash\)nm4:\(\backslash\)n"} << m4 << std::endl;
00062 \}
\end{DoxyCode}
