\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/util/\+Blas\+Util.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source}\index{Blas\+Util.\+h@{Blas\+Util.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_BLASUTIL\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_BLASUTIL\_H}
00012 
00013 \textcolor{comment}{// This file contains many lightweight helper classes used to}
00014 \textcolor{comment}{// implement and control fast level 2 and level 3 BLAS-like routines.}
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00017 
00018 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00019 
00020 \textcolor{comment}{// forward declarations}
00021 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} mr, \textcolor{keywordtype}{int} nr, \textcolor{keywordtype}{bool} 
      ConjugateLhs=false, \textcolor{keywordtype}{bool} ConjugateRhs=false>
00022 \textcolor{keyword}{struct }gebp\_kernel;
00023 
00024 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} nr, \textcolor{keywordtype}{int} StorageOrder, \textcolor{keywordtype}{bool} Conjugate = f
      alse, \textcolor{keywordtype}{bool} PanelMode=false>
00025 \textcolor{keyword}{struct }gemm\_pack\_rhs;
00026 
00027 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} Pack1, \textcolor{keywordtype}{int} Pack2, \textcolor{keywordtype}{int} StorageOrder, \textcolor{keywordtype}{bool}
       Conjugate = false, \textcolor{keywordtype}{bool} PanelMode = false>
00028 \textcolor{keyword}{struct }gemm\_pack\_lhs;
00029 
00030 \textcolor{keyword}{template}<
00031   \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00032   \textcolor{keyword}{typename} LhsScalar, \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00033   \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs,
00034   \textcolor{keywordtype}{int} ResStorageOrder>
00035 \textcolor{keyword}{struct }general\_matrix\_matrix\_product;
00036 
00037 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00038          \textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} LhsMapper, \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00039          \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{typename} RhsMapper, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int} Version=Specialized>
00040 \textcolor{keyword}{struct }general\_matrix\_vector\_product;
00041 
00042 
00043 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Conjugate> \textcolor{keyword}{struct }conj\_if;
00044 
00045 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_if<true> \{
00046   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00047   \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} operator()(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& x)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::conj(x); \}
00048   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00049   \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} pconj(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& x)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::pconj(x); \}
00050 \};
00051 
00052 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_if<false> \{
00053   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00054   \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& operator()(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& x)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} x; \}
00055   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00056   \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& pconj(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& x)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} x; \}
00057 \};
00058 
00059 \textcolor{comment}{// Generic implementation for custom complex types.}
00060 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{bool} ConjLhs, \textcolor{keywordtype}{bool} ConjRhs>
00061 \textcolor{keyword}{struct }conj\_helper
00062 \{
00063   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar,RhsScalar>::ReturnType Scalar;
00064 
00065   EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} LhsScalar& x, \textcolor{keyword}{const} RhsScalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{ const}
00066 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00067 
00068   EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} LhsScalar& x, \textcolor{keyword}{const} RhsScalar& y)\textcolor{keyword}{ const}
00069 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} conj\_if<ConjLhs>()(x) *  conj\_if<ConjRhs>()(y); \}
00070 \};
00071 
00072 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }conj\_helper<Scalar,Scalar,false,false>
00073 \{
00074   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{
       const }\{ \textcolor{keywordflow}{return} internal::pmadd(x,y,c); \}
00075   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 
      internal::pmul(x,y); \}
00076 \};
00077 
00078 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar> \textcolor{keyword}{struct }conj\_helper<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<RealScalar>, std::complex<RealScala
      r>, false,true>
00079 \{
00080   \textcolor{keyword}{typedef} std::complex<RealScalar> Scalar;
00081   EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{ const}
00082 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} c + pmul(x,y); \}
00083 
00084   EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y)\textcolor{keyword}{ const}
00085 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} Scalar(numext::real(x)*numext::real(y) + numext::imag(x)*numext::imag(y), numext::imag(x)*
      numext::real(y) - numext::real(x)*numext::imag(y)); \}
00086 \};
00087 
00088 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar> \textcolor{keyword}{struct }conj\_helper<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<RealScalar>, std::complex<RealScala
      r>, true,false>
00089 \{
00090   \textcolor{keyword}{typedef} std::complex<RealScalar> Scalar;
00091   EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{ const}
00092 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} c + pmul(x,y); \}
00093 
00094   EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y)\textcolor{keyword}{ const}
00095 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} Scalar(numext::real(x)*numext::real(y) + numext::imag(x)*numext::imag(y), numext::real(x)*
      numext::imag(y) - numext::imag(x)*numext::real(y)); \}
00096 \};
00097 
00098 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar> \textcolor{keyword}{struct }conj\_helper<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<RealScalar>, std::complex<RealScala
      r>, true,true>
00099 \{
00100   \textcolor{keyword}{typedef} std::complex<RealScalar> Scalar;
00101   EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{ const}
00102 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} c + pmul(x,y); \}
00103 
00104   EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y)\textcolor{keyword}{ const}
00105 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} Scalar(numext::real(x)*numext::real(y) - numext::imag(x)*numext::imag(y), - numext::real(x)*
      numext::imag(y) - numext::imag(x)*numext::real(y)); \}
00106 \};
00107 
00108 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar,\textcolor{keywordtype}{bool} Conj> \textcolor{keyword}{struct }conj\_helper<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<RealScalar>, RealScalar, 
      Conj,false>
00109 \{
00110   \textcolor{keyword}{typedef} std::complex<RealScalar> Scalar;
00111   EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} RealScalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{ const}
00112 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00113   EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} RealScalar& y)\textcolor{keyword}{ const}
00114 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} conj\_if<Conj>()(x)*y; \}
00115 \};
00116 
00117 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar,\textcolor{keywordtype}{bool} Conj> \textcolor{keyword}{struct }conj\_helper<RealScalar, \hyperlink{namespacestd}{std}::
      \hyperlink{structcomplex}{complex}<RealScalar>, false,Conj>
00118 \{
00119   \textcolor{keyword}{typedef} std::complex<RealScalar> Scalar;
00120   EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} RealScalar& x, \textcolor{keyword}{const} Scalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{ const}
00121 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00122   EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} RealScalar& x, \textcolor{keyword}{const} Scalar& y)\textcolor{keyword}{ const}
00123 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} x*conj\_if<Conj>()(y); \}
00124 \};
00125 
00126 \textcolor{keyword}{template}<\textcolor{keyword}{typename} From,\textcolor{keyword}{typename} To> \textcolor{keyword}{struct }get\_factor \{
00127   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE To run(\textcolor{keyword}{const} From& x) \{ \textcolor{keywordflow}{return} To(x); \}
00128 \};
00129 
00130 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }get\_factor<Scalar,typename NumTraits<Scalar>::Real> \{
00131   EIGEN\_DEVICE\_FUNC
00132   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} NumTraits<Scalar>::Real run(\textcolor{keyword}{const} Scalar& x) \{ \textcolor{keywordflow}{return} numext::real(x)
      ; \}
00133 \};
00134 
00135 
00136 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index>
00137 \textcolor{keyword}{class }BlasVectorMapper \{
00138   \textcolor{keyword}{public}:
00139   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE BlasVectorMapper(Scalar *data) : m\_data(data) \{\}
00140 
00141   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE Scalar operator()(Index i)\textcolor{keyword}{ const }\{
00142     \textcolor{keywordflow}{return} m\_data[i];
00143   \}
00144   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet, \textcolor{keywordtype}{int} AlignmentType>
00145   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE Packet load(Index i)\textcolor{keyword}{ const }\{
00146     \textcolor{keywordflow}{return} ploadt<Packet, AlignmentType>(m\_data + i);
00147   \}
00148 
00149   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00150   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{bool} aligned(Index i)\textcolor{keyword}{ const }\{
00151     \textcolor{keywordflow}{return} (UIntPtr(m\_data+i)%\textcolor{keyword}{sizeof}(Packet))==0;
00152   \}
00153 
00154   \textcolor{keyword}{protected}:
00155   Scalar* m\_data;
00156 \};
00157 
00158 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} AlignmentType>
00159 \textcolor{keyword}{class }BlasLinearMapper \{
00160   \textcolor{keyword}{public}:
00161   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::type Packet;
00162   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::half HalfPacket;
00163 
00164   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE BlasLinearMapper(Scalar *data) : m\_data(data) \{\}
00165 
00166   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \textcolor{keywordtype}{void} prefetch(\textcolor{keywordtype}{int} i)\textcolor{keyword}{ const }\{
00167     internal::prefetch(&\textcolor{keyword}{operator}()(i));
00168   \}
00169 
00170   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE Scalar& operator()(Index i)\textcolor{keyword}{ const }\{
00171     \textcolor{keywordflow}{return} m\_data[i];
00172   \}
00173 
00174   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE Packet loadPacket(Index i)\textcolor{keyword}{ const }\{
00175     \textcolor{keywordflow}{return} ploadt<Packet, AlignmentType>(m\_data + i);
00176   \}
00177 
00178   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE HalfPacket loadHalfPacket(Index i)\textcolor{keyword}{ const }\{
00179     \textcolor{keywordflow}{return} ploadt<HalfPacket, AlignmentType>(m\_data + i);
00180   \}
00181 
00182   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \textcolor{keywordtype}{void} storePacket(Index i, \textcolor{keyword}{const} Packet &p)\textcolor{keyword}{ const }\{
00183     pstoret<Scalar, Packet, AlignmentType>(m\_data + i, p);
00184   \}
00185 
00186   \textcolor{keyword}{protected}:
00187   Scalar *m\_data;
00188 \};
00189 
00190 \textcolor{comment}{// Lightweight helper class to access matrix coefficients.}
00191 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} StorageOrder, \textcolor{keywordtype}{int} AlignmentType = Unaligned>
00192 \textcolor{keyword}{class }blas\_data\_mapper \{
00193   \textcolor{keyword}{public}:
00194   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::type Packet;
00195   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::half HalfPacket;
00196 
00197   \textcolor{keyword}{typedef} BlasLinearMapper<Scalar, Index, AlignmentType> LinearMapper;
00198   \textcolor{keyword}{typedef} BlasVectorMapper<Scalar, Index> VectorMapper;
00199 
00200   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE blas\_data\_mapper(Scalar* data, Index stride) : m\_data(data), 
      m\_stride(stride) \{\}
00201 
00202   EIGEN\_DEVICE\_FUNC  EIGEN\_ALWAYS\_INLINE blas\_data\_mapper<Scalar, Index, StorageOrder, AlignmentType>
00203   getSubMapper(Index i, Index j)\textcolor{keyword}{ const }\{
00204     \textcolor{keywordflow}{return} blas\_data\_mapper<Scalar, Index, StorageOrder, AlignmentType>(&operator()(i, j), m\_stride);
00205   \}
00206 
00207   EIGEN\_DEVICE\_FUNC  EIGEN\_ALWAYS\_INLINE LinearMapper getLinearMapper(Index i, Index j)\textcolor{keyword}{ const }\{
00208     \textcolor{keywordflow}{return} LinearMapper(&\textcolor{keyword}{operator}()(i, j));
00209   \}
00210 
00211   EIGEN\_DEVICE\_FUNC  EIGEN\_ALWAYS\_INLINE VectorMapper getVectorMapper(Index i, Index j)\textcolor{keyword}{ const }\{
00212     \textcolor{keywordflow}{return} VectorMapper(&\textcolor{keyword}{operator}()(i, j));
00213   \}
00214 
00215 
00216   EIGEN\_DEVICE\_FUNC
00217   EIGEN\_ALWAYS\_INLINE Scalar& operator()(Index i, Index j)\textcolor{keyword}{ const }\{
00218     \textcolor{keywordflow}{return} m\_data[StorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? j + i*m\_stride : i + j*m\_stride];
00219   \}
00220 
00221   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE Packet loadPacket(Index i, Index j)\textcolor{keyword}{ const }\{
00222     \textcolor{keywordflow}{return} ploadt<Packet, AlignmentType>(&operator()(i, j));
00223   \}
00224 
00225   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE HalfPacket loadHalfPacket(Index i, Index j)\textcolor{keyword}{ const }\{
00226     \textcolor{keywordflow}{return} ploadt<HalfPacket, AlignmentType>(&operator()(i, j));
00227   \}
00228 
00229   \textcolor{keyword}{template}<\textcolor{keyword}{typename} SubPacket>
00230   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \textcolor{keywordtype}{void} scatterPacket(Index i, Index j, \textcolor{keyword}{const} SubPacket &p)\textcolor{keyword}{ const }\{
00231     pscatter<Scalar, SubPacket>(&operator()(i, j), p, m\_stride);
00232   \}
00233 
00234   \textcolor{keyword}{template}<\textcolor{keyword}{typename} SubPacket>
00235   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE SubPacket gatherPacket(Index i, Index j)\textcolor{keyword}{ const }\{
00236     \textcolor{keywordflow}{return} pgather<Scalar, SubPacket>(&operator()(i, j), m\_stride);
00237   \}
00238 
00239   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} Index stride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_stride; \}
00240   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data; \}
00241 
00242   EIGEN\_DEVICE\_FUNC Index firstAligned(Index size)\textcolor{keyword}{ const }\{
00243     \textcolor{keywordflow}{if} (UIntPtr(m\_data)%\textcolor{keyword}{sizeof}(Scalar)) \{
00244       \textcolor{keywordflow}{return} -1;
00245     \}
00246     \textcolor{keywordflow}{return} internal::first\_default\_aligned(m\_data, size);
00247   \}
00248 
00249   \textcolor{keyword}{protected}:
00250   Scalar* EIGEN\_RESTRICT m\_data;
00251   \textcolor{keyword}{const} Index m\_stride;
00252 \};
00253 
00254 \textcolor{comment}{// lightweight helper class to access matrix coefficients (const version)}
00255 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} StorageOrder>
00256 \textcolor{keyword}{class }const\_blas\_data\_mapper : \textcolor{keyword}{public} blas\_data\_mapper<const Scalar, Index, StorageOrder> \{
00257   \textcolor{keyword}{public}:
00258   EIGEN\_ALWAYS\_INLINE const\_blas\_data\_mapper(\textcolor{keyword}{const} Scalar *data, Index stride) : blas\_data\_mapper<const 
      Scalar, Index, StorageOrder>(data, stride) \{\}
00259 
00260   EIGEN\_ALWAYS\_INLINE const\_blas\_data\_mapper<Scalar, Index, StorageOrder> getSubMapper(Index i, Index j)\textcolor{keyword}{
       const }\{
00261     \textcolor{keywordflow}{return} const\_blas\_data\_mapper<Scalar, Index, StorageOrder>(&(this->operator()(i, j)), this->m\_stride);
00262   \}
00263 \};
00264 
00265 
00266 \textcolor{comment}{/* Helper class to analyze the factors of a Product expression.}
00267 \textcolor{comment}{ * In particular it allows to pop out operator-, scalar multiples,}
00268 \textcolor{comment}{ * and conjugate */}
00269 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType> \textcolor{keyword}{struct }blas\_traits
00270 \{
00271   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<XprType>::Scalar Scalar;
00272   \textcolor{keyword}{typedef} \textcolor{keyword}{const} XprType& ExtractType;
00273   \textcolor{keyword}{typedef} XprType \_ExtractType;
00274   \textcolor{keyword}{enum} \{
00275     IsComplex = NumTraits<Scalar>::IsComplex,
00276     IsTransposed = \textcolor{keyword}{false},
00277     NeedToConjugate = \textcolor{keyword}{false},
00278     HasUsableDirectAccess = (    (int(XprType::Flags)&\hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit})
00279                               && (   \textcolor{keywordtype}{bool}(XprType::IsVectorAtCompileTime)
00280                                   || int(inner\_stride\_at\_compile\_time<XprType>::ret) == 1)
00281                              ) ?  1 : 0
00282   \};
00283   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<bool(HasUsableDirectAccess),
00284     ExtractType,
00285     \textcolor{keyword}{typename} \_ExtractType::PlainObject
00286     >::type DirectLinearAccessType;
00287   \textcolor{keyword}{static} \textcolor{keyword}{inline} ExtractType extract(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} x; \}
00288   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar extractScalarFactor(\textcolor{keyword}{const} XprType&) \{ \textcolor{keywordflow}{return} Scalar(1); \}
00289 \};
00290 
00291 \textcolor{comment}{// pop conjugate}
00292 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} NestedXpr>
00293 \textcolor{keyword}{struct }blas\_traits<CwiseUnaryOp<scalar\_conjugate\_op<Scalar>, NestedXpr> >
00294  : blas\_traits<NestedXpr>
00295 \{
00296   \textcolor{keyword}{typedef} blas\_traits<NestedXpr> Base;
00297   \textcolor{keyword}{typedef} CwiseUnaryOp<scalar\_conjugate\_op<Scalar>, NestedXpr> XprType;
00298   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::ExtractType ExtractType;
00299 
00300   \textcolor{keyword}{enum} \{
00301     IsComplex = NumTraits<Scalar>::IsComplex,
00302     NeedToConjugate = Base::NeedToConjugate ? 0 : IsComplex
00303   \};
00304   \textcolor{keyword}{static} \textcolor{keyword}{inline} ExtractType extract(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} Base::extract(x.nestedExpression()); \}
00305   \textcolor{keyword}{static} \textcolor{keyword}{inline} Scalar extractScalarFactor(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} conj(Base::extractScalarFactor(x.
      nestedExpression())); \}
00306 \};
00307 
00308 \textcolor{comment}{// pop scalar multiple}
00309 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} NestedXpr, \textcolor{keyword}{typename} Plain>
00310 \textcolor{keyword}{struct }blas\_traits<CwiseBinaryOp<scalar\_product\_op<Scalar>, const CwiseNullaryOp<scalar\_constant\_op<Scalar>
      ,Plain>, NestedXpr> >
00311  : blas\_traits<NestedXpr>
00312 \{
00313   \textcolor{keyword}{typedef} blas\_traits<NestedXpr> Base;
00314   \textcolor{keyword}{typedef} CwiseBinaryOp<scalar\_product\_op<Scalar>, \textcolor{keyword}{const} CwiseNullaryOp<scalar\_constant\_op<Scalar>,Plain>, 
      NestedXpr> XprType;
00315   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::ExtractType ExtractType;
00316   \textcolor{keyword}{static} \textcolor{keyword}{inline} ExtractType extract(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} Base::extract(x.rhs()); \}
00317   \textcolor{keyword}{static} \textcolor{keyword}{inline} Scalar extractScalarFactor(\textcolor{keyword}{const} XprType& x)
00318   \{ \textcolor{keywordflow}{return} x.lhs().functor().m\_other * Base::extractScalarFactor(x.rhs()); \}
00319 \};
00320 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} NestedXpr, \textcolor{keyword}{typename} Plain>
00321 \textcolor{keyword}{struct }blas\_traits<CwiseBinaryOp<scalar\_product\_op<Scalar>, NestedXpr, const CwiseNullaryOp<
      scalar\_constant\_op<Scalar>,Plain> > >
00322  : blas\_traits<NestedXpr>
00323 \{
00324   \textcolor{keyword}{typedef} blas\_traits<NestedXpr> Base;
00325   \textcolor{keyword}{typedef} CwiseBinaryOp<scalar\_product\_op<Scalar>, NestedXpr, \textcolor{keyword}{const} 
      CwiseNullaryOp<scalar\_constant\_op<Scalar>,Plain> > XprType;
00326   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::ExtractType ExtractType;
00327   \textcolor{keyword}{static} \textcolor{keyword}{inline} ExtractType extract(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} Base::extract(x.lhs()); \}
00328   \textcolor{keyword}{static} \textcolor{keyword}{inline} Scalar extractScalarFactor(\textcolor{keyword}{const} XprType& x)
00329   \{ \textcolor{keywordflow}{return} Base::extractScalarFactor(x.lhs()) * x.rhs().functor().m\_other; \}
00330 \};
00331 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Plain1, \textcolor{keyword}{typename} Plain2>
00332 \textcolor{keyword}{struct }blas\_traits<CwiseBinaryOp<scalar\_product\_op<Scalar>, const CwiseNullaryOp<scalar\_constant\_op<Scalar>
      ,Plain1>,
00333                                                             const CwiseNullaryOp<scalar\_constant\_op<Scalar>
      ,Plain2> > >
00334  : blas\_traits<CwiseNullaryOp<scalar\_constant\_op<Scalar>,Plain1> >
00335 \{\};
00336 
00337 \textcolor{comment}{// pop opposite}
00338 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} NestedXpr>
00339 \textcolor{keyword}{struct }blas\_traits<CwiseUnaryOp<scalar\_opposite\_op<Scalar>, NestedXpr> >
00340  : blas\_traits<NestedXpr>
00341 \{
00342   \textcolor{keyword}{typedef} blas\_traits<NestedXpr> Base;
00343   \textcolor{keyword}{typedef} CwiseUnaryOp<scalar\_opposite\_op<Scalar>, NestedXpr> XprType;
00344   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::ExtractType ExtractType;
00345   \textcolor{keyword}{static} \textcolor{keyword}{inline} ExtractType extract(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} Base::extract(x.nestedExpression()); \}
00346   \textcolor{keyword}{static} \textcolor{keyword}{inline} Scalar extractScalarFactor(\textcolor{keyword}{const} XprType& x)
00347   \{ \textcolor{keywordflow}{return} - Base::extractScalarFactor(x.nestedExpression()); \}
00348 \};
00349 
00350 \textcolor{comment}{// pop/push transpose}
00351 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NestedXpr>
00352 \textcolor{keyword}{struct }blas\_traits<Transpose<NestedXpr> >
00353  : blas\_traits<NestedXpr>
00354 \{
00355   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NestedXpr::Scalar Scalar;
00356   \textcolor{keyword}{typedef} blas\_traits<NestedXpr> Base;
00357   \textcolor{keyword}{typedef} Transpose<NestedXpr> XprType;
00358   \textcolor{keyword}{typedef} Transpose<const typename Base::\_ExtractType>  ExtractType; \textcolor{comment}{// const to get rid of a compile
       error; anyway blas traits are only used on the RHS}
00359   \textcolor{keyword}{typedef} Transpose<const typename Base::\_ExtractType> \_ExtractType;
00360   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<bool(Base::HasUsableDirectAccess),
00361     ExtractType,
00362     \textcolor{keyword}{typename} ExtractType::PlainObject
00363     >::type DirectLinearAccessType;
00364   \textcolor{keyword}{enum} \{
00365     IsTransposed = Base::IsTransposed ? 0 : 1
00366   \};
00367   \textcolor{keyword}{static} \textcolor{keyword}{inline} ExtractType extract(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} ExtractType(Base::extract(x.nestedExpression
      ())); \}
00368   \textcolor{keyword}{static} \textcolor{keyword}{inline} Scalar extractScalarFactor(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} Base::extractScalarFactor(x.
      nestedExpression()); \}
00369 \};
00370 
00371 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00372 \textcolor{keyword}{struct }blas\_traits<const \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}>
00373      : blas\_traits<T>
00374 \{\};
00375 
00376 template<typename T, bool HasUsableDirectAccess=blas\_traits<T>::HasUsableDirectAccess>
00377 \textcolor{keyword}{struct }extract\_data\_selector \{
00378   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{typename} T::Scalar* run(\textcolor{keyword}{const} T& m)
00379   \{
00380     \textcolor{keywordflow}{return} blas\_traits<T>::extract(m).data();
00381   \}
00382 \};
00383 
00384 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00385 \textcolor{keyword}{struct }extract\_data\_selector<T,false> \{
00386   \textcolor{keyword}{static} \textcolor{keyword}{typename} T::Scalar* run(\textcolor{keyword}{const} T&) \{ \textcolor{keywordflow}{return} 0; \}
00387 \};
00388 
00389 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{const} \textcolor{keyword}{typename} T::Scalar* extract\_data(\textcolor{keyword}{const} T& m)
00390 \{
00391   \textcolor{keywordflow}{return} extract\_data\_selector<T>::run(m);
00392 \}
00393 
00394 \} \textcolor{comment}{// end namespace internal}
00395 
00396 \} \textcolor{comment}{// end namespace Eigen}
00397 
00398 \textcolor{preprocessor}{#endif // EIGEN\_BLASUTIL\_H}
\end{DoxyCode}
