\hypertarget{matio_2visual__studio_2test_2eigen_2test_2product__syrk_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/product\+\_\+syrk.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2product__syrk_8cpp_source}\index{product\+\_\+syrk.\+cpp@{product\+\_\+syrk.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} syrk(\textcolor{keyword}{const} MatrixType& m)
00013 \{
00014   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00015   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00016   \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, MatrixType::ColsAtCompileTime, RowMajor>}
       RMatrixType;
00017   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::ColsAtCompileTime, Dynamic>}
       Rhs1;
00018   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, MatrixType::RowsAtCompileTime>}
       Rhs2;
00019   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::ColsAtCompileTime, Dynamic,RowMajor>}
       Rhs3;
00020 
00021   Index rows = m.rows();
00022   Index cols = m.cols();
00023 
00024   MatrixType m1 = MatrixType::Random(rows, cols),
00025              m2 = MatrixType::Random(rows, cols),
00026              m3 = MatrixType::Random(rows, cols);
00027   RMatrixType rm2 = MatrixType::Random(rows, cols);
00028 
00029   Rhs1 rhs1 = Rhs1::Random(internal::random<int>(1,320), cols); Rhs1 rhs11 = Rhs1::Random(rhs1.rows(), cols
      );
00030   Rhs2 rhs2 = Rhs2::Random(rows, internal::random<int>(1,320)); Rhs2 rhs22 = Rhs2::Random(rows, rhs2.cols()
      );
00031   Rhs3 rhs3 = Rhs3::Random(internal::random<int>(1,320), rows);
00032 
00033   Scalar s1 = internal::random<Scalar>();
00034   
00035   Index c = internal::random<Index>(0,cols-1);
00036 
00037   m2.setZero();
00038   VERIFY\_IS\_APPROX((m2.template selfadjointView<Lower>().rankUpdate(rhs2,s1).\_expression()),
00039                    ((s1 * rhs2 * rhs2.adjoint()).eval().template triangularView<Lower>().toDenseMatrix()));
00040   m2.setZero();
00041   VERIFY\_IS\_APPROX(((m2.template triangularView<Lower>() += s1 * rhs2  * rhs22.adjoint()).nestedExpression(
      )),
00042                    ((s1 * rhs2 * rhs22.adjoint()).eval().template triangularView<Lower>().toDenseMatrix()))
      ;
00043 
00044   
00045   m2.setZero();
00046   VERIFY\_IS\_APPROX(m2.template selfadjointView<Upper>().rankUpdate(rhs2,s1).\_expression(),
00047                    (s1 * rhs2 * rhs2.adjoint()).eval().template triangularView<Upper>().toDenseMatrix());
00048   m2.setZero();
00049   VERIFY\_IS\_APPROX((m2.template triangularView<Upper>() += s1 * rhs22 * rhs2.adjoint()).nestedExpression(),
00050                    (s1 * rhs22 * rhs2.adjoint()).eval().template triangularView<Upper>().toDenseMatrix());
00051 
00052   
00053   m2.setZero();
00054   VERIFY\_IS\_APPROX(m2.template selfadjointView<Lower>().rankUpdate(rhs1.adjoint(),s1).\_expression(),
00055                    (s1 * rhs1.adjoint() * rhs1).eval().template triangularView<Lower>().toDenseMatrix());
00056   m2.setZero();
00057   VERIFY\_IS\_APPROX((m2.template triangularView<Lower>() += s1 * rhs11.adjoint() * rhs1).nestedExpression(),
00058                    (s1 * rhs11.adjoint() * rhs1).eval().template triangularView<Lower>().toDenseMatrix());
00059   
00060   
00061   m2.setZero();
00062   VERIFY\_IS\_APPROX(m2.template selfadjointView<Upper>().rankUpdate(rhs1.adjoint(),s1).\_expression(),
00063                    (s1 * rhs1.adjoint() * rhs1).eval().template triangularView<Upper>().toDenseMatrix());
00064   VERIFY\_IS\_APPROX((m2.template triangularView<Upper>() = s1 * rhs1.adjoint() * rhs11).nestedExpression(),
00065                    (s1 * rhs1.adjoint() * rhs11).eval().template triangularView<Upper>().toDenseMatrix());
00066 
00067   
00068   m2.setZero();
00069   VERIFY\_IS\_APPROX(m2.template selfadjointView<Lower>().rankUpdate(rhs3.adjoint(),s1).\_expression(),
00070                    (s1 * rhs3.adjoint() * rhs3).eval().template triangularView<Lower>().toDenseMatrix());
00071 
00072   m2.setZero();
00073   VERIFY\_IS\_APPROX(m2.template selfadjointView<Upper>().rankUpdate(rhs3.adjoint(),s1).\_expression(),
00074                    (s1 * rhs3.adjoint() * rhs3).eval().template triangularView<Upper>().toDenseMatrix());
00075                    
00076   m2.setZero();
00077   VERIFY\_IS\_APPROX((m2.template selfadjointView<Lower>().rankUpdate(m1.col(c),s1).\_expression()),
00078                    ((s1 * m1.col(c) * m1.col(c).adjoint()).eval().template triangularView<Lower>().
      toDenseMatrix()));
00079                    
00080   m2.setZero();
00081   VERIFY\_IS\_APPROX((m2.template selfadjointView<Upper>().rankUpdate(m1.col(c),s1).\_expression()),
00082                    ((s1 * m1.col(c) * m1.col(c).adjoint()).eval().template triangularView<Upper>().
      toDenseMatrix()));
00083   rm2.setZero();
00084   VERIFY\_IS\_APPROX((rm2.template selfadjointView<Upper>().rankUpdate(m1.col(c),s1).\_expression()),
00085                    ((s1 * m1.col(c) * m1.col(c).adjoint()).eval().template triangularView<Upper>().
      toDenseMatrix()));
00086   m2.setZero();
00087   VERIFY\_IS\_APPROX((m2.template triangularView<Upper>() += s1 * m3.col(c) * m1.col(c).adjoint()).
      nestedExpression(),
00088                    ((s1 * m3.col(c) * m1.col(c).adjoint()).eval().template triangularView<Upper>().
      toDenseMatrix()));
00089   rm2.setZero();
00090   VERIFY\_IS\_APPROX((rm2.template triangularView<Upper>() += s1 * m1.col(c) * m3.col(c).adjoint()).
      nestedExpression(),
00091                    ((s1 * m1.col(c) * m3.col(c).adjoint()).eval().template triangularView<Upper>().
      toDenseMatrix()));
00092   
00093   m2.setZero();
00094   VERIFY\_IS\_APPROX((m2.template selfadjointView<Lower>().rankUpdate(m1.col(c).conjugate(),s1).\_expression()
      ),
00095                    ((s1 * m1.col(c).conjugate() * m1.col(c).conjugate().adjoint()).eval().template 
      triangularView<Lower>().toDenseMatrix()));
00096                    
00097   m2.setZero();
00098   VERIFY\_IS\_APPROX((m2.template selfadjointView<Upper>().rankUpdate(m1.col(c).conjugate(),s1).\_expression()
      ),
00099                    ((s1 * m1.col(c).conjugate() * m1.col(c).conjugate().adjoint()).eval().template 
      triangularView<Upper>().toDenseMatrix()));
00100   
00101   
00102   m2.setZero();
00103   VERIFY\_IS\_APPROX((m2.template selfadjointView<Lower>().rankUpdate(m1.row(c),s1).\_expression()),
00104                    ((s1 * m1.row(c).transpose() * m1.row(c).transpose().adjoint()).eval().template 
      triangularView<Lower>().toDenseMatrix()));
00105   rm2.setZero();
00106   VERIFY\_IS\_APPROX((rm2.template selfadjointView<Lower>().rankUpdate(m1.row(c),s1).\_expression()),
00107                    ((s1 * m1.row(c).transpose() * m1.row(c).transpose().adjoint()).eval().template 
      triangularView<Lower>().toDenseMatrix()));
00108   m2.setZero();
00109   VERIFY\_IS\_APPROX((m2.template triangularView<Lower>() += s1 * m3.row(c).transpose() * m1.row(c).transpose
      ().adjoint()).nestedExpression(),
00110                    ((s1 * m3.row(c).transpose() * m1.row(c).transpose().adjoint()).eval().template 
      triangularView<Lower>().toDenseMatrix()));
00111   rm2.setZero();
00112   VERIFY\_IS\_APPROX((rm2.template triangularView<Lower>() += s1 * m3.row(c).transpose() * m1.row(c).
      transpose().adjoint()).nestedExpression(),
00113                    ((s1 * m3.row(c).transpose() * m1.row(c).transpose().adjoint()).eval().template 
      triangularView<Lower>().toDenseMatrix()));
00114   
00115   
00116   m2.setZero();
00117   VERIFY\_IS\_APPROX((m2.template selfadjointView<Upper>().rankUpdate(m1.row(c).adjoint(),s1).\_expression()),
00118                    ((s1 * m1.row(c).adjoint() * m1.row(c).adjoint().adjoint()).eval().template 
      triangularView<Upper>().toDenseMatrix()));
00119 \}
00120 
00121 \textcolor{keywordtype}{void} test\_product\_syrk()
00122 \{
00123   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat ; i++)
00124   \{
00125     \textcolor{keywordtype}{int} s;
00126     s = internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE);
00127     CALL\_SUBTEST\_1( syrk(MatrixXf(s, s)) );
00128     CALL\_SUBTEST\_2( syrk(MatrixXd(s, s)) );
00129     TEST\_SET\_BUT\_UNUSED\_VARIABLE(s)
00130     
00131     s = internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2);
00132     CALL\_SUBTEST\_3( syrk(MatrixXcf(s, s)) );
00133     CALL\_SUBTEST\_4( syrk(MatrixXcd(s, s)) );
00134     TEST\_SET\_BUT\_UNUSED\_VARIABLE(s)
00135   \}
00136 \}
\end{DoxyCode}
