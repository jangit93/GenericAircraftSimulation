\hypertarget{zlib_2examples_2gzjoin_8c_source}{}\section{zlib/examples/gzjoin.c}
\label{zlib_2examples_2gzjoin_8c_source}\index{gzjoin.\+c@{gzjoin.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* gzjoin -- command to join gzip files into one gzip file}
00002 \textcolor{comment}{}
00003 \textcolor{comment}{  Copyright (C) 2004, 2005, 2012 Mark Adler, all rights reserved}
00004 \textcolor{comment}{  version 1.2, 14 Aug 2012}
00005 \textcolor{comment}{}
00006 \textcolor{comment}{  This software is provided 'as-is', without any express or implied}
00007 \textcolor{comment}{  warranty.  In no event will the author be held liable for any damages}
00008 \textcolor{comment}{  arising from the use of this software.}
00009 \textcolor{comment}{}
00010 \textcolor{comment}{  Permission is granted to anyone to use this software for any purpose,}
00011 \textcolor{comment}{  including commercial applications, and to alter it and redistribute it}
00012 \textcolor{comment}{  freely, subject to the following restrictions:}
00013 \textcolor{comment}{}
00014 \textcolor{comment}{  1. The origin of this software must not be misrepresented; you must not}
00015 \textcolor{comment}{     claim that you wrote the original software. If you use this software}
00016 \textcolor{comment}{     in a product, an acknowledgment in the product documentation would be}
00017 \textcolor{comment}{     appreciated but is not required.}
00018 \textcolor{comment}{  2. Altered source versions must be plainly marked as such, and must not be}
00019 \textcolor{comment}{     misrepresented as being the original software.}
00020 \textcolor{comment}{  3. This notice may not be removed or altered from any source distribution.}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{  Mark Adler    madler@alumni.caltech.edu}
00023 \textcolor{comment}{ */}
00024 
00025 \textcolor{comment}{/*}
00026 \textcolor{comment}{ * Change history:}
00027 \textcolor{comment}{ *}
00028 \textcolor{comment}{ * 1.0  11 Dec 2004     - First version}
00029 \textcolor{comment}{ * 1.1  12 Jun 2005     - Changed ssize\_t to long for portability}
00030 \textcolor{comment}{ * 1.2  14 Aug 2012     - Clean up for z\_const usage}
00031 \textcolor{comment}{ */}
00032 
00033 \textcolor{comment}{/*}
00034 \textcolor{comment}{   gzjoin takes one or more gzip files on the command line and writes out a}
00035 \textcolor{comment}{   single gzip file that will uncompress to the concatenation of the}
00036 \textcolor{comment}{   uncompressed data from the individual gzip files.  gzjoin does this without}
00037 \textcolor{comment}{   having to recompress any of the data and without having to calculate a new}
00038 \textcolor{comment}{   crc32 for the concatenated uncompressed data.  gzjoin does however have to}
00039 \textcolor{comment}{   decompress all of the input data in order to find the bits in the compressed}
00040 \textcolor{comment}{   data that need to be modified to concatenate the streams.}
00041 \textcolor{comment}{}
00042 \textcolor{comment}{   gzjoin does not do an integrity check on the input gzip files other than}
00043 \textcolor{comment}{   checking the gzip header and decompressing the compressed data.  They are}
00044 \textcolor{comment}{   otherwise assumed to be complete and correct.}
00045 \textcolor{comment}{}
00046 \textcolor{comment}{   Each joint between gzip files removes at least 18 bytes of previous trailer}
00047 \textcolor{comment}{   and subsequent header, and inserts an average of about three bytes to the}
00048 \textcolor{comment}{   compressed data in order to connect the streams.  The output gzip file}
00049 \textcolor{comment}{   has a minimal ten-byte gzip header with no file name or modification time.}
00050 \textcolor{comment}{}
00051 \textcolor{comment}{   This program was written to illustrate the use of the Z\_BLOCK option of}
00052 \textcolor{comment}{   inflate() and the crc32\_combine() function.  gzjoin will not compile with}
00053 \textcolor{comment}{   versions of zlib earlier than 1.2.3.}
00054 \textcolor{comment}{ */}
00055 
00056 \textcolor{preprocessor}{#include <stdio.h>}      \textcolor{comment}{/* fputs(), fprintf(), fwrite(), putc() */}
00057 \textcolor{preprocessor}{#include <stdlib.h>}     \textcolor{comment}{/* exit(), malloc(), free() */}
00058 \textcolor{preprocessor}{#include <fcntl.h>}      \textcolor{comment}{/* open() */}
00059 \textcolor{preprocessor}{#include <unistd.h>}     \textcolor{comment}{/* close(), read(), lseek() */}
00060 \textcolor{preprocessor}{#include "zlib.h"}
00061     \textcolor{comment}{/* crc32(), crc32\_combine(), inflateInit2(), inflate(), inflateEnd() */}
00062 
00063 \textcolor{preprocessor}{#define local static}
00064 
00065 \textcolor{comment}{/* exit with an error (return a value to allow use in an expression) */}
00066 local \textcolor{keywordtype}{int} bail(\textcolor{keywordtype}{char} *why1, \textcolor{keywordtype}{char} *why2)
00067 \{
00068     fprintf(stderr, \textcolor{stringliteral}{"gzjoin error: %s%s, output incomplete\(\backslash\)n"}, why1, why2);
00069     exit(1);
00070     \textcolor{keywordflow}{return} 0;
00071 \}
00072 
00073 \textcolor{comment}{/* -- simple buffered file input with access to the buffer -- */}
00074 
00075 \textcolor{preprocessor}{#define CHUNK 32768         }\textcolor{comment}{/* must be a power of two and fit in unsigned */}\textcolor{preprocessor}{}
00076 
00077 \textcolor{comment}{/* bin buffered input file type */}
00078 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
00079     \textcolor{keywordtype}{char} *name;             \textcolor{comment}{/* name of file for error messages */}
00080     \textcolor{keywordtype}{int} fd;                 \textcolor{comment}{/* file descriptor */}
00081     \textcolor{keywordtype}{unsigned} left;          \textcolor{comment}{/* bytes remaining at next */}
00082     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *next;    \textcolor{comment}{/* next byte to read */}
00083     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf;     \textcolor{comment}{/* allocated buffer of length CHUNK */}
00084 \} \hyperlink{structbin}{bin};
00085 
00086 \textcolor{comment}{/* close a buffered file and free allocated memory */}
00087 local \textcolor{keywordtype}{void} bclose(\hyperlink{structbin}{bin} *in)
00088 \{
00089     \textcolor{keywordflow}{if} (in != NULL) \{
00090         \textcolor{keywordflow}{if} (in->fd != -1)
00091             close(in->fd);
00092         \textcolor{keywordflow}{if} (in->buf != NULL)
00093             free(in->buf);
00094         free(in);
00095     \}
00096 \}
00097 
00098 \textcolor{comment}{/* open a buffered file for input, return a pointer to type bin, or NULL on}
00099 \textcolor{comment}{   failure */}
00100 local \hyperlink{structbin}{bin} *bopen(\textcolor{keywordtype}{char} *name)
00101 \{
00102     \hyperlink{structbin}{bin} *in;
00103 
00104     in = malloc(\textcolor{keyword}{sizeof}(\hyperlink{structbin}{bin}));
00105     \textcolor{keywordflow}{if} (in == NULL)
00106         \textcolor{keywordflow}{return} NULL;
00107     in->buf = malloc(CHUNK);
00108     in->fd = open(name, O\_RDONLY, 0);
00109     \textcolor{keywordflow}{if} (in->buf == NULL || in->fd == -1) \{
00110         bclose(in);
00111         \textcolor{keywordflow}{return} NULL;
00112     \}
00113     in->left = 0;
00114     in->next = in->buf;
00115     in->name = name;
00116     \textcolor{keywordflow}{return} in;
00117 \}
00118 
00119 \textcolor{comment}{/* load buffer from file, return -1 on read error, 0 or 1 on success, with}
00120 \textcolor{comment}{   1 indicating that end-of-file was reached */}
00121 local \textcolor{keywordtype}{int} bload(\hyperlink{structbin}{bin} *in)
00122 \{
00123     \textcolor{keywordtype}{long} len;
00124 
00125     \textcolor{keywordflow}{if} (in == NULL)
00126         \textcolor{keywordflow}{return} -1;
00127     \textcolor{keywordflow}{if} (in->left != 0)
00128         \textcolor{keywordflow}{return} 0;
00129     in->next = in->buf;
00130     \textcolor{keywordflow}{do} \{
00131         len = (long)read(in->fd, in->buf + in->left, CHUNK - in->left);
00132         \textcolor{keywordflow}{if} (len < 0)
00133             \textcolor{keywordflow}{return} -1;
00134         in->left += (unsigned)len;
00135     \} \textcolor{keywordflow}{while} (len != 0 && in->left < CHUNK);
00136     \textcolor{keywordflow}{return} len == 0 ? 1 : 0;
00137 \}
00138 
00139 \textcolor{comment}{/* get a byte from the file, bail if end of file */}
00140 \textcolor{preprocessor}{#define bget(in) (in->left ? 0 : bload(in), \(\backslash\)}
00141 \textcolor{preprocessor}{                  in->left ? (in->left--, *(in->next)++) : \(\backslash\)}
00142 \textcolor{preprocessor}{                    bail("unexpected end of file on ", in->name))}
00143 
00144 \textcolor{comment}{/* get a four-byte little-endian unsigned integer from file */}
00145 local \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} bget4(\hyperlink{structbin}{bin} *in)
00146 \{
00147     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} val;
00148 
00149     val = bget(in);
00150     val += (\textcolor{keywordtype}{unsigned} long)(bget(in)) << 8;
00151     val += (\textcolor{keywordtype}{unsigned} long)(bget(in)) << 16;
00152     val += (\textcolor{keywordtype}{unsigned} long)(bget(in)) << 24;
00153     \textcolor{keywordflow}{return} val;
00154 \}
00155 
00156 \textcolor{comment}{/* skip bytes in file */}
00157 local \textcolor{keywordtype}{void} bskip(\hyperlink{structbin}{bin} *in, \textcolor{keywordtype}{unsigned} skip)
00158 \{
00159     \textcolor{comment}{/* check pointer */}
00160     \textcolor{keywordflow}{if} (in == NULL)
00161         \textcolor{keywordflow}{return};
00162 
00163     \textcolor{comment}{/* easy case -- skip bytes in buffer */}
00164     \textcolor{keywordflow}{if} (skip <= in->left) \{
00165         in->left -= skip;
00166         in->next += skip;
00167         \textcolor{keywordflow}{return};
00168     \}
00169 
00170     \textcolor{comment}{/* skip what's in buffer, discard buffer contents */}
00171     skip -= in->left;
00172     in->left = 0;
00173 
00174     \textcolor{comment}{/* seek past multiples of CHUNK bytes */}
00175     \textcolor{keywordflow}{if} (skip > CHUNK) \{
00176         \textcolor{keywordtype}{unsigned} left;
00177 
00178         left = skip & (CHUNK - 1);
00179         \textcolor{keywordflow}{if} (left == 0) \{
00180             \textcolor{comment}{/* exact number of chunks: seek all the way minus one byte to check}
00181 \textcolor{comment}{               for end-of-file with a read */}
00182             lseek(in->fd, skip - 1, SEEK\_CUR);
00183             \textcolor{keywordflow}{if} (read(in->fd, in->buf, 1) != 1)
00184                 bail(\textcolor{stringliteral}{"unexpected end of file on "}, in->name);
00185             \textcolor{keywordflow}{return};
00186         \}
00187 
00188         \textcolor{comment}{/* skip the integral chunks, update skip with remainder */}
00189         lseek(in->fd, skip - left, SEEK\_CUR);
00190         skip = left;
00191     \}
00192 
00193     \textcolor{comment}{/* read more input and skip remainder */}
00194     bload(in);
00195     \textcolor{keywordflow}{if} (skip > in->left)
00196         bail(\textcolor{stringliteral}{"unexpected end of file on "}, in->name);
00197     in->left -= skip;
00198     in->next += skip;
00199 \}
00200 
00201 \textcolor{comment}{/* -- end of buffered input functions -- */}
00202 
00203 \textcolor{comment}{/* skip the gzip header from file in */}
00204 local \textcolor{keywordtype}{void} gzhead(\hyperlink{structbin}{bin} *in)
00205 \{
00206     \textcolor{keywordtype}{int} flags;
00207 
00208     \textcolor{comment}{/* verify gzip magic header and compression method */}
00209     \textcolor{keywordflow}{if} (bget(in) != 0x1f || bget(in) != 0x8b || bget(in) != 8)
00210         bail(in->name, \textcolor{stringliteral}{" is not a valid gzip file"});
00211 
00212     \textcolor{comment}{/* get and verify flags */}
00213     flags = bget(in);
00214     \textcolor{keywordflow}{if} ((flags & 0xe0) != 0)
00215         bail(\textcolor{stringliteral}{"unknown reserved bits set in "}, in->name);
00216 
00217     \textcolor{comment}{/* skip modification time, extra flags, and os */}
00218     bskip(in, 6);
00219 
00220     \textcolor{comment}{/* skip extra field if present */}
00221     \textcolor{keywordflow}{if} (flags & 4) \{
00222         \textcolor{keywordtype}{unsigned} len;
00223 
00224         len = bget(in);
00225         len += (unsigned)(bget(in)) << 8;
00226         bskip(in, len);
00227     \}
00228 
00229     \textcolor{comment}{/* skip file name if present */}
00230     \textcolor{keywordflow}{if} (flags & 8)
00231         \textcolor{keywordflow}{while} (bget(in) != 0)
00232             ;
00233 
00234     \textcolor{comment}{/* skip comment if present */}
00235     \textcolor{keywordflow}{if} (flags & 16)
00236         \textcolor{keywordflow}{while} (bget(in) != 0)
00237             ;
00238 
00239     \textcolor{comment}{/* skip header crc if present */}
00240     \textcolor{keywordflow}{if} (flags & 2)
00241         bskip(in, 2);
00242 \}
00243 
00244 \textcolor{comment}{/* write a four-byte little-endian unsigned integer to out */}
00245 local \textcolor{keywordtype}{void} put4(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} val, FILE *out)
00246 \{
00247     putc(val & 0xff, out);
00248     putc((val >> 8) & 0xff, out);
00249     putc((val >> 16) & 0xff, out);
00250     putc((val >> 24) & 0xff, out);
00251 \}
00252 
00253 \textcolor{comment}{/* Load up zlib stream from buffered input, bail if end of file */}
00254 local \textcolor{keywordtype}{void} zpull(z\_streamp strm, \hyperlink{structbin}{bin} *in)
00255 \{
00256     \textcolor{keywordflow}{if} (in->left == 0)
00257         bload(in);
00258     \textcolor{keywordflow}{if} (in->left == 0)
00259         bail(\textcolor{stringliteral}{"unexpected end of file on "}, in->name);
00260     strm->avail\_in = in->left;
00261     strm->next\_in = in->next;
00262 \}
00263 
00264 \textcolor{comment}{/* Write header for gzip file to out and initialize trailer. */}
00265 local \textcolor{keywordtype}{void} gzinit(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *crc, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *tot, FILE *out)
00266 \{
00267     fwrite(\textcolor{stringliteral}{"\(\backslash\)x1f\(\backslash\)x8b\(\backslash\)x08\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)xff"}, 1, 10, out);
00268     *crc = crc32(0L, Z\_NULL, 0);
00269     *tot = 0;
00270 \}
00271 
00272 \textcolor{comment}{/* Copy the compressed data from name, zeroing the last block bit of the last}
00273 \textcolor{comment}{   block if clr is true, and adding empty blocks as needed to get to a byte}
00274 \textcolor{comment}{   boundary.  If clr is false, then the last block becomes the last block of}
00275 \textcolor{comment}{   the output, and the gzip trailer is written.  crc and tot maintains the}
00276 \textcolor{comment}{   crc and length (modulo 2^32) of the output for the trailer.  The resulting}
00277 \textcolor{comment}{   gzip file is written to out.  gzinit() must be called before the first call}
00278 \textcolor{comment}{   of gzcopy() to write the gzip header and to initialize crc and tot. */}
00279 local \textcolor{keywordtype}{void} gzcopy(\textcolor{keywordtype}{char} *name, \textcolor{keywordtype}{int} clr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *crc, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *tot,
00280                   FILE *out)
00281 \{
00282     \textcolor{keywordtype}{int} ret;                \textcolor{comment}{/* return value from zlib functions */}
00283     \textcolor{keywordtype}{int} pos;                \textcolor{comment}{/* where the "last block" bit is in byte */}
00284     \textcolor{keywordtype}{int} last;               \textcolor{comment}{/* true if processing the last block */}
00285     \hyperlink{structbin}{bin} *in;                \textcolor{comment}{/* buffered input file */}
00286     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *start;   \textcolor{comment}{/* start of compressed data in buffer */}
00287     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *junk;    \textcolor{comment}{/* buffer for uncompressed data -- discarded */}
00288     z\_off\_t len;            \textcolor{comment}{/* length of uncompressed data (support > 4 GB) */}
00289     \hyperlink{structz__stream__s}{z\_stream} strm;          \textcolor{comment}{/* zlib inflate stream */}
00290 
00291     \textcolor{comment}{/* open gzip file and skip header */}
00292     in = bopen(name);
00293     \textcolor{keywordflow}{if} (in == NULL)
00294         bail(\textcolor{stringliteral}{"could not open "}, name);
00295     gzhead(in);
00296 
00297     \textcolor{comment}{/* allocate buffer for uncompressed data and initialize raw inflate}
00298 \textcolor{comment}{       stream */}
00299     junk = malloc(CHUNK);
00300     strm.zalloc = Z\_NULL;
00301     strm.zfree = Z\_NULL;
00302     strm.opaque = Z\_NULL;
00303     strm.avail\_in = 0;
00304     strm.next\_in = Z\_NULL;
00305     ret = inflateInit2(&strm, -15);
00306     \textcolor{keywordflow}{if} (junk == NULL || ret != Z\_OK)
00307         bail(\textcolor{stringliteral}{"out of memory"}, \textcolor{stringliteral}{""});
00308 
00309     \textcolor{comment}{/* inflate and copy compressed data, clear last-block bit if requested */}
00310     len = 0;
00311     zpull(&strm, in);
00312     start = in->next;
00313     last = start[0] & 1;
00314     \textcolor{keywordflow}{if} (last && clr)
00315         start[0] &= ~1;
00316     strm.avail\_out = 0;
00317     \textcolor{keywordflow}{for} (;;) \{
00318         \textcolor{comment}{/* if input used and output done, write used input and get more */}
00319         \textcolor{keywordflow}{if} (strm.avail\_in == 0 && strm.avail\_out != 0) \{
00320             fwrite(start, 1, strm.next\_in - start, out);
00321             start = in->buf;
00322             in->left = 0;
00323             zpull(&strm, in);
00324         \}
00325 
00326         \textcolor{comment}{/* decompress -- return early when end-of-block reached */}
00327         strm.avail\_out = CHUNK;
00328         strm.next\_out = junk;
00329         ret = inflate(&strm, Z\_BLOCK);
00330         \textcolor{keywordflow}{switch} (ret) \{
00331         \textcolor{keywordflow}{case} Z\_MEM\_ERROR:
00332             bail(\textcolor{stringliteral}{"out of memory"}, \textcolor{stringliteral}{""});
00333         \textcolor{keywordflow}{case} Z\_DATA\_ERROR:
00334             bail(\textcolor{stringliteral}{"invalid compressed data in "}, in->name);
00335         \}
00336 
00337         \textcolor{comment}{/* update length of uncompressed data */}
00338         len += CHUNK - strm.avail\_out;
00339 
00340         \textcolor{comment}{/* check for block boundary (only get this when block copied out) */}
00341         \textcolor{keywordflow}{if} (strm.data\_type & 128) \{
00342             \textcolor{comment}{/* if that was the last block, then done */}
00343             \textcolor{keywordflow}{if} (last)
00344                 \textcolor{keywordflow}{break};
00345 
00346             \textcolor{comment}{/* number of unused bits in last byte */}
00347             pos = strm.data\_type & 7;
00348 
00349             \textcolor{comment}{/* find the next last-block bit */}
00350             \textcolor{keywordflow}{if} (pos != 0) \{
00351                 \textcolor{comment}{/* next last-block bit is in last used byte */}
00352                 pos = 0x100 >> pos;
00353                 last = strm.next\_in[-1] & pos;
00354                 \textcolor{keywordflow}{if} (last && clr)
00355                     in->buf[strm.next\_in - in->buf - 1] &= ~pos;
00356             \}
00357             \textcolor{keywordflow}{else} \{
00358                 \textcolor{comment}{/* next last-block bit is in next unused byte */}
00359                 \textcolor{keywordflow}{if} (strm.avail\_in == 0) \{
00360                     \textcolor{comment}{/* don't have that byte yet -- get it */}
00361                     fwrite(start, 1, strm.next\_in - start, out);
00362                     start = in->buf;
00363                     in->left = 0;
00364                     zpull(&strm, in);
00365                 \}
00366                 last = strm.next\_in[0] & 1;
00367                 \textcolor{keywordflow}{if} (last && clr)
00368                     in->buf[strm.next\_in - in->buf] &= ~1;
00369             \}
00370         \}
00371     \}
00372 
00373     \textcolor{comment}{/* update buffer with unused input */}
00374     in->left = strm.avail\_in;
00375     in->next = in->buf + (strm.next\_in - in->buf);
00376 
00377     \textcolor{comment}{/* copy used input, write empty blocks to get to byte boundary */}
00378     pos = strm.data\_type & 7;
00379     fwrite(start, 1, in->next - start - 1, out);
00380     last = in->next[-1];
00381     \textcolor{keywordflow}{if} (pos == 0 || !clr)
00382         \textcolor{comment}{/* already at byte boundary, or last file: write last byte */}
00383         putc(last, out);
00384     \textcolor{keywordflow}{else} \{
00385         \textcolor{comment}{/* append empty blocks to last byte */}
00386         last &= ((0x100 >> pos) - 1);       \textcolor{comment}{/* assure unused bits are zero */}
00387         \textcolor{keywordflow}{if} (pos & 1) \{
00388             \textcolor{comment}{/* odd -- append an empty stored block */}
00389             putc(last, out);
00390             \textcolor{keywordflow}{if} (pos == 1)
00391                 putc(0, out);               \textcolor{comment}{/* two more bits in block header */}
00392             fwrite(\textcolor{stringliteral}{"\(\backslash\)0\(\backslash\)0\(\backslash\)xff\(\backslash\)xff"}, 1, 4, out);
00393         \}
00394         \textcolor{keywordflow}{else} \{
00395             \textcolor{comment}{/* even -- append 1, 2, or 3 empty fixed blocks */}
00396             \textcolor{keywordflow}{switch} (pos) \{
00397             \textcolor{keywordflow}{case} 6:
00398                 putc(last | 8, out);
00399                 last = 0;
00400             \textcolor{keywordflow}{case} 4:
00401                 putc(last | 0x20, out);
00402                 last = 0;
00403             \textcolor{keywordflow}{case} 2:
00404                 putc(last | 0x80, out);
00405                 putc(0, out);
00406             \}
00407         \}
00408     \}
00409 
00410     \textcolor{comment}{/* update crc and tot */}
00411     *crc = crc32\_combine(*crc, bget4(in), len);
00412     *tot += (\textcolor{keywordtype}{unsigned} long)len;
00413 
00414     \textcolor{comment}{/* clean up */}
00415     inflateEnd(&strm);
00416     free(junk);
00417     bclose(in);
00418 
00419     \textcolor{comment}{/* write trailer if this is the last gzip file */}
00420     \textcolor{keywordflow}{if} (!clr) \{
00421         put4(*crc, out);
00422         put4(*tot, out);
00423     \}
00424 \}
00425 
00426 \textcolor{comment}{/* join the gzip files on the command line, write result to stdout */}
00427 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
00428 \{
00429     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} crc, tot;     \textcolor{comment}{/* running crc and total uncompressed length */}
00430 
00431     \textcolor{comment}{/* skip command name */}
00432     argc--;
00433     argv++;
00434 
00435     \textcolor{comment}{/* show usage if no arguments */}
00436     \textcolor{keywordflow}{if} (argc == 0) \{
00437         fputs(\textcolor{stringliteral}{"gzjoin usage: gzjoin f1.gz [f2.gz [f3.gz ...]] > fjoin.gz\(\backslash\)n"},
00438               stderr);
00439         \textcolor{keywordflow}{return} 0;
00440     \}
00441 
00442     \textcolor{comment}{/* join gzip files on command line and write to stdout */}
00443     gzinit(&crc, &tot, stdout);
00444     \textcolor{keywordflow}{while} (argc--)
00445         gzcopy(*argv++, argc, &crc, &tot, stdout);
00446 
00447     \textcolor{comment}{/* done */}
00448     \textcolor{keywordflow}{return} 0;
00449 \}
\end{DoxyCode}
