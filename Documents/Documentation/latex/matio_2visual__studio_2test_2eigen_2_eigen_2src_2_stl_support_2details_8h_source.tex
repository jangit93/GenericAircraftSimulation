\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_stl_support_2details_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Stl\+Support/details.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_stl_support_2details_8h_source}\index{details.\+h@{details.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2009 Hauke Heibel <hauke.heibel@googlemail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_STL\_DETAILS\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_STL\_DETAILS\_H}
00013 
00014 \textcolor{preprocessor}{#ifndef EIGEN\_ALIGNED\_ALLOCATOR}
00015 \textcolor{preprocessor}{  #define EIGEN\_ALIGNED\_ALLOCATOR Eigen::aligned\_allocator}
00016 \textcolor{preprocessor}{#endif}
00017 
00018 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00019 
00020   \textcolor{comment}{// This one is needed to prevent reimplementing the whole std::vector.}
00021   \textcolor{keyword}{template} <\textcolor{keyword}{class} T>
00022   \textcolor{keyword}{class }aligned\_allocator\_indirection : \textcolor{keyword}{public} EIGEN\_ALIGNED\_ALLOCATOR<T>
00023   \{
00024   \textcolor{keyword}{public}:
00025     \textcolor{keyword}{typedef} std::size\_t     size\_type;
00026     \textcolor{keyword}{typedef} std::ptrdiff\_t  difference\_type;
00027     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*              pointer;
00028     \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*        const\_pointer;
00029     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&              reference;
00030     \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&        const\_reference;
00031     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}               value\_type;
00032 
00033     \textcolor{keyword}{template}<\textcolor{keyword}{class} U>
00034     \textcolor{keyword}{struct }rebind
00035     \{
00036       \textcolor{keyword}{typedef} aligned\_allocator\_indirection<U> other;
00037     \};
00038 
00039     aligned\_allocator\_indirection() \{\}
00040     aligned\_allocator\_indirection(\textcolor{keyword}{const} aligned\_allocator\_indirection& ) : EIGEN\_ALIGNED\_ALLOCATOR<
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}>() \{\}
00041     aligned\_allocator\_indirection(\textcolor{keyword}{const} EIGEN\_ALIGNED\_ALLOCATOR<T>& ) \{\}
00042     \textcolor{keyword}{template}<\textcolor{keyword}{class} U>
00043     aligned\_allocator\_indirection(\textcolor{keyword}{const} aligned\_allocator\_indirection<U>& ) \{\}
00044     \textcolor{keyword}{template}<\textcolor{keyword}{class} U>
00045     aligned\_allocator\_indirection(\textcolor{keyword}{const} EIGEN\_ALIGNED\_ALLOCATOR<U>& ) \{\}
00046     ~aligned\_allocator\_indirection() \{\}
00047   \};
00048 
00049 \textcolor{preprocessor}{#if EIGEN\_COMP\_MSVC}
00050 
00051   \textcolor{comment}{// sometimes, MSVC detects, at compile time, that the argument x}
00052   \textcolor{comment}{// in std::vector::resize(size\_t s,T x) won't be aligned and generate an error}
00053   \textcolor{comment}{// even if this function is never called. Whence this little wrapper.}
00054 \textcolor{preprocessor}{#define EIGEN\_WORKAROUND\_MSVC\_STL\_SUPPORT(T) \(\backslash\)}
00055 \textcolor{preprocessor}{  typename Eigen::internal::conditional< \(\backslash\)}
00056 \textcolor{preprocessor}{    Eigen::internal::is\_arithmetic<T>::value, \(\backslash\)}
00057 \textcolor{preprocessor}{    T, \(\backslash\)}
00058 \textcolor{preprocessor}{    Eigen::internal::workaround\_msvc\_stl\_support<T> \(\backslash\)}
00059 \textcolor{preprocessor}{  >::type}
00060 
00061   \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00062   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }workaround\_msvc\_stl\_support : \textcolor{keyword}{public} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}
00063   \{
00064     \textcolor{keyword}{inline} workaround\_msvc\_stl\_support() : \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}() \{\}
00065     \textcolor{keyword}{inline} workaround\_msvc\_stl\_support(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& other) : \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}(other) \{\}
00066     \textcolor{keyword}{inline} \textcolor{keyword}{operator} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& () \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*\textcolor{keyword}{>}(\textcolor{keyword}{this}); \}
00067     \textcolor{keyword}{inline} \textcolor{keyword}{operator} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& () \textcolor{keyword}{const} \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*\textcolor{keyword}{>}(\textcolor{keyword}{this}); \}
00068     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherT>
00069     \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& operator=(\textcolor{keyword}{const} OtherT& other)
00070     \{ T::operator=(other); \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}
00071     \textcolor{keyword}{inline} workaround\_msvc\_stl\_support& operator=(\textcolor{keyword}{const} workaround\_msvc\_stl\_support& other)
00072     \{ T::operator=(other); \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}
00073   \};
00074   \}
00075 
00076 \textcolor{preprocessor}{#else}
00077 
00078 \textcolor{preprocessor}{#define EIGEN\_WORKAROUND\_MSVC\_STL\_SUPPORT(T) T}
00079 
00080 \textcolor{preprocessor}{#endif}
00081 
00082 \}
00083 
00084 \textcolor{preprocessor}{#endif // EIGEN\_STL\_DETAILS\_H}
\end{DoxyCode}
