\hypertarget{eigen_2blas_2level1__impl_8h_source}{}\section{eigen/blas/level1\+\_\+impl.h}
\label{eigen_2blas_2level1__impl_8h_source}\index{level1\+\_\+impl.\+h@{level1\+\_\+impl.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "common.h"}
00011 
00012 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(axpy)(\textcolor{keyword}{const} \textcolor{keywordtype}{int} *n, \textcolor{keyword}{const} RealScalar *palpha, \textcolor{keyword}{const} RealScalar *px, \textcolor{keyword}{const} \textcolor{keywordtype}{int} *incx, 
      RealScalar *py, \textcolor{keyword}{const} \textcolor{keywordtype}{int} *incy)
00013 \{
00014   \textcolor{keyword}{const} Scalar* x = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }Scalar*\textcolor{keyword}{>}(px);
00015   Scalar* y = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(py);
00016   Scalar alpha  = *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }Scalar*\textcolor{keyword}{>}(palpha);
00017 
00018   \textcolor{keywordflow}{if}(*n<=0) \textcolor{keywordflow}{return} 0;
00019 
00020   \textcolor{keywordflow}{if}(*incx==1 && *incy==1)    make\_vector(y,*n) += alpha * make\_vector(x,*n);
00021   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx>0 && *incy>0) make\_vector(y,*n,*incy) += alpha * make\_vector(x,*n,*incx);
00022   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx>0 && *incy<0) make\_vector(y,*n,-*incy).reverse() += alpha * make\_vector(x,*n,*incx);
00023   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx<0 && *incy>0) make\_vector(y,*n,*incy) += alpha * make\_vector(x,*n,-*incx).reverse();
00024   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx<0 && *incy<0) make\_vector(y,*n,-*incy).reverse() += alpha * make\_vector(x,*n,-*incx).
      reverse();
00025 
00026   \textcolor{keywordflow}{return} 0;
00027 \}
00028 
00029 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(copy)(\textcolor{keywordtype}{int} *n, RealScalar *px, \textcolor{keywordtype}{int} *incx, RealScalar *py, \textcolor{keywordtype}{int} *incy)
00030 \{
00031   \textcolor{keywordflow}{if}(*n<=0) \textcolor{keywordflow}{return} 0;
00032 
00033   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00034   Scalar* y = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(py);
00035 
00036   \textcolor{comment}{// be carefull, *incx==0 is allowed !!}
00037   \textcolor{keywordflow}{if}(*incx==1 && *incy==1)
00038     make\_vector(y,*n) = make\_vector(x,*n);
00039   \textcolor{keywordflow}{else}
00040   \{
00041     \textcolor{keywordflow}{if}(*incx<0) x = x - (*n-1)*(*incx);
00042     \textcolor{keywordflow}{if}(*incy<0) y = y - (*n-1)*(*incy);
00043     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<*n;++i)
00044     \{
00045       *y = *x;
00046       x += *incx;
00047       y += *incy;
00048     \}
00049   \}
00050 
00051   \textcolor{keywordflow}{return} 0;
00052 \}
00053 
00054 \textcolor{keywordtype}{int} EIGEN\_CAT(EIGEN\_CAT(i,SCALAR\_SUFFIX),amax\_)(\textcolor{keywordtype}{int} *n, RealScalar *px, \textcolor{keywordtype}{int} *incx)
00055 \{
00056   \textcolor{keywordflow}{if}(*n<=0) \textcolor{keywordflow}{return} 0;
00057   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00058 
00059   DenseIndex ret;
00060   \textcolor{keywordflow}{if}(*incx==1)  make\_vector(x,*n).cwiseAbs().maxCoeff(&ret);
00061   \textcolor{keywordflow}{else}          make\_vector(x,*n,std::abs(*incx)).cwiseAbs().maxCoeff(&ret);
00062   \textcolor{keywordflow}{return} int(ret)+1;
00063 \}
00064 
00065 \textcolor{keywordtype}{int} EIGEN\_CAT(EIGEN\_CAT(i,SCALAR\_SUFFIX),amin\_)(\textcolor{keywordtype}{int} *n, RealScalar *px, \textcolor{keywordtype}{int} *incx)
00066 \{
00067   \textcolor{keywordflow}{if}(*n<=0) \textcolor{keywordflow}{return} 0;
00068   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00069 
00070   DenseIndex ret;
00071   \textcolor{keywordflow}{if}(*incx==1)  make\_vector(x,*n).cwiseAbs().minCoeff(&ret);
00072   \textcolor{keywordflow}{else}          make\_vector(x,*n,std::abs(*incx)).cwiseAbs().minCoeff(&ret);
00073   \textcolor{keywordflow}{return} int(ret)+1;
00074 \}
00075 
00076 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(rotg)(RealScalar *pa, RealScalar *pb, RealScalar *pc, RealScalar *ps)
00077 \{
00078   \textcolor{keyword}{using} std::sqrt;
00079   \textcolor{keyword}{using} std::abs;
00080 
00081   Scalar& a = *\textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(pa);
00082   Scalar& b = *\textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(pb);
00083   RealScalar* c = pc;
00084   Scalar* s = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(ps);
00085 
00086 \textcolor{preprocessor}{  #if !ISCOMPLEX}
00087   Scalar r,z;
00088   Scalar aa = abs(a);
00089   Scalar ab = abs(b);
00090   \textcolor{keywordflow}{if}((aa+ab)==Scalar(0))
00091   \{
00092     *c = 1;
00093     *s = 0;
00094     r = 0;
00095     z = 0;
00096   \}
00097   \textcolor{keywordflow}{else}
00098   \{
00099     r = sqrt(a*a + b*b);
00100     Scalar amax = aa>ab ? a : b;
00101     r = amax>0 ? r : -r;
00102     *c = a/r;
00103     *s = b/r;
00104     z = 1;
00105     \textcolor{keywordflow}{if} (aa > ab) z = *s;
00106     \textcolor{keywordflow}{if} (ab > aa && *c!=RealScalar(0))
00107       z = Scalar(1)/ *c;
00108   \}
00109   *pa = r;
00110   *pb = z;
00111 \textcolor{preprocessor}{  #else}
00112   Scalar alpha;
00113   RealScalar norm,scale;
00114   \textcolor{keywordflow}{if}(abs(a)==RealScalar(0))
00115   \{
00116     *c = RealScalar(0);
00117     *s = Scalar(1);
00118     a = b;
00119   \}
00120   \textcolor{keywordflow}{else}
00121   \{
00122     scale = abs(a) + abs(b);
00123     norm = scale*sqrt((numext::abs2(a/scale)) + (numext::abs2(b/scale)));
00124     alpha = a/abs(a);
00125     *c = abs(a)/norm;
00126     *s = alpha*numext::conj(b)/norm;
00127     a = alpha*norm;
00128   \}
00129 \textcolor{preprocessor}{  #endif}
00130 
00131 \textcolor{comment}{//   JacobiRotation<Scalar> r;}
00132 \textcolor{comment}{//   r.makeGivens(a,b);}
00133 \textcolor{comment}{//   *c = r.c();}
00134 \textcolor{comment}{//   *s = r.s();}
00135 
00136   \textcolor{keywordflow}{return} 0;
00137 \}
00138 
00139 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(scal)(\textcolor{keywordtype}{int} *n, RealScalar *palpha, RealScalar *px, \textcolor{keywordtype}{int} *incx)
00140 \{
00141   \textcolor{keywordflow}{if}(*n<=0) \textcolor{keywordflow}{return} 0;
00142 
00143   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00144   Scalar alpha = *\textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(palpha);
00145 
00146   \textcolor{keywordflow}{if}(*incx==1)  make\_vector(x,*n) *= alpha;
00147   \textcolor{keywordflow}{else}          make\_vector(x,*n,std::abs(*incx)) *= alpha;
00148 
00149   \textcolor{keywordflow}{return} 0;
00150 \}
00151 
00152 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(\hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap})(\textcolor{keywordtype}{int} *n, RealScalar *px, \textcolor{keywordtype}{int} *incx, RealScalar *py, \textcolor{keywordtype}{int} *incy)
00153 \{
00154   \textcolor{keywordflow}{if}(*n<=0) \textcolor{keywordflow}{return} 0;
00155 
00156   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00157   Scalar* y = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(py);
00158 
00159   \textcolor{keywordflow}{if}(*incx==1 && *incy==1)    make\_vector(y,*n).swap(make\_vector(x,*n));
00160   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx>0 && *incy>0) make\_vector(y,*n,*incy).swap(make\_vector(x,*n,*incx));
00161   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx>0 && *incy<0) make\_vector(y,*n,-*incy).reverse().swap(make\_vector(x,*n,*incx));
00162   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx<0 && *incy>0) make\_vector(y,*n,*incy).swap(make\_vector(x,*n,-*incx).reverse());
00163   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx<0 && *incy<0) make\_vector(y,*n,-*incy).reverse().swap(make\_vector(x,*n,-*incx).reverse());
00164 
00165   \textcolor{keywordflow}{return} 1;
00166 \}
\end{DoxyCode}
