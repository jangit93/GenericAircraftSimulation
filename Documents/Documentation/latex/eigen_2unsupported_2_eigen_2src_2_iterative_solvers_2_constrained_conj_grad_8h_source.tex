\hypertarget{eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_constrained_conj_grad_8h_source}{}\section{eigen/unsupported/\+Eigen/src/\+Iterative\+Solvers/\+Constrained\+Conj\+Grad.h}
\label{eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_constrained_conj_grad_8h_source}\index{Constrained\+Conj\+Grad.\+h@{Constrained\+Conj\+Grad.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 
00006 \textcolor{comment}{/* NOTE The functions of this file have been adapted from the GMM++ library */}
00007 
00008 \textcolor{comment}{//========================================================================}
00009 \textcolor{comment}{//}
00010 \textcolor{comment}{// Copyright (C) 2002-2007 Yves Renard}
00011 \textcolor{comment}{//}
00012 \textcolor{comment}{// This file is a part of GETFEM++}
00013 \textcolor{comment}{//}
00014 \textcolor{comment}{// Getfem++ is free software; you can redistribute it and/or modify}
00015 \textcolor{comment}{// it under the terms of the GNU Lesser General Public License as}
00016 \textcolor{comment}{// published by the Free Software Foundation; version 2.1 of the License.}
00017 \textcolor{comment}{//}
00018 \textcolor{comment}{// This program is distributed in the hope that it will be useful,}
00019 \textcolor{comment}{// but WITHOUT ANY WARRANTY; without even the implied warranty of}
00020 \textcolor{comment}{// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
00021 \textcolor{comment}{// GNU Lesser General Public License for more details.}
00022 \textcolor{comment}{// You should have received a copy of the GNU Lesser General Public}
00023 \textcolor{comment}{// License along with this program; if not, write to the Free Software}
00024 \textcolor{comment}{// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301,}
00025 \textcolor{comment}{// USA.}
00026 \textcolor{comment}{//}
00027 \textcolor{comment}{//========================================================================}
00028 
00029 \textcolor{preprocessor}{#include "../../../../Eigen/src/Core/util/NonMPL2.h"}
00030 
00031 \textcolor{preprocessor}{#ifndef EIGEN\_CONSTRAINEDCG\_H}
00032 \textcolor{preprocessor}{#define EIGEN\_CONSTRAINEDCG\_H}
00033 
00034 \textcolor{preprocessor}{#include <Eigen/Core>}
00035 
00036 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00037 
00038 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00039 
00046 \textcolor{keyword}{template} <\textcolor{keyword}{typename} CMatrix, \textcolor{keyword}{typename} CINVMatrix>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_constrained_conj_grad_8h_source_l00047}\hyperlink{namespace_eigen_1_1internal_a58a0ccf0e71d88beeb5dcf72ed0bdd5f}{00047} \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a58a0ccf0e71d88beeb5dcf72ed0bdd5f}{pseudo\_inverse}(\textcolor{keyword}{const} CMatrix &\hyperlink{group___core___module_class_eigen_1_1_matrix}{C}, CINVMatrix &CINV)
00048 \{
00049   \textcolor{comment}{// optimisable : copie de la ligne, precalcul de C * trans(C).}
00050   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} CMatrix::Scalar Scalar;
00051   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} CMatrix::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00052   \textcolor{comment}{// FIXME use sparse vectors ?}
00053   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} TmpVec;
00054 
00055   Index rows = C.rows(), cols = C.cols();
00056 
00057   TmpVec d(rows), e(rows), l(cols), p(rows), q(rows), r(rows);
00058   Scalar rho, rho\_1, alpha;
00059   d.setZero();
00060 
00061   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{Triplet<double>} \hyperlink{group___sparse_core___module}{T};
00062   std::vector<T> tripletList;
00063     
00064   \textcolor{keywordflow}{for} (Index i = 0; i < rows; ++i)
00065   \{
00066     d[i] = 1.0;
00067     rho = 1.0;
00068     e.setZero();
00069     r = d;
00070     p = d;
00071 
00072     \textcolor{keywordflow}{while} (rho >= 1e-38)
00073     \{ \textcolor{comment}{/* conjugate gradient to compute e             */}
00074       \textcolor{comment}{/* which is the i-th row of inv(C * trans(C))  */}
00075       l = C.transpose() * p;
00076       q = C * l;
00077       alpha = rho / p.dot(q);
00078       e +=  alpha * p;
00079       r += -alpha * q;
00080       rho\_1 = rho;
00081       rho = r.dot(r);
00082       p = (rho/rho\_1) * p + r;
00083     \}
00084 
00085     l = C.transpose() * e; \textcolor{comment}{// l is the i-th row of CINV}
00086     \textcolor{comment}{// FIXME add a generic "prune/filter" expression for both dense and sparse object to sparse}
00087     \textcolor{keywordflow}{for} (Index j=0; j<l.size(); ++j)
00088       \textcolor{keywordflow}{if} (l[j]<1e-15)
00089     tripletList.push\_back(T(i,j,l(j)));
00090 
00091     
00092     d[i] = 0.0;
00093   \}
00094   CINV.setFromTriplets(tripletList.begin(), tripletList.end());
00095 \}
00096 
00097 
00098 
00104 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TMatrix, \textcolor{keyword}{typename} CMatrix,
00105          \textcolor{keyword}{typename} VectorX, \textcolor{keyword}{typename} VectorB, \textcolor{keyword}{typename} VectorF>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_constrained_conj_grad_8h_source_l00106}\hyperlink{namespace_eigen_1_1internal_a1c2f99746877fd46158af4a6b7dce2f9}{00106} \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a1c2f99746877fd46158af4a6b7dce2f9}{constrained\_cg}(\textcolor{keyword}{const} TMatrix& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, \textcolor{keyword}{const} CMatrix& \hyperlink{group___core___module_class_eigen_1_1_matrix}{C}, VectorX& x,
00107                        \textcolor{keyword}{const} VectorB& b, \textcolor{keyword}{const} VectorF& f, \hyperlink{class_eigen_1_1_iteration_controller}{IterationController} &iter)
00108 \{
00109   \textcolor{keyword}{using} std::sqrt;
00110   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} TMatrix::Scalar Scalar;
00111   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} TMatrix::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00112   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>}  TmpVec;
00113 
00114   Scalar rho = 1.0, rho\_1, lambda, gamma;
00115   Index xSize = x.size();
00116   TmpVec  p(xSize), q(xSize), q2(xSize),
00117           r(xSize), old\_z(xSize), z(xSize),
00118           memox(xSize);
00119   std::vector<bool> satured(C.rows());
00120   p.setZero();
00121   iter.setRhsNorm(sqrt(b.dot(b))); \textcolor{comment}{// gael vect\_sp(PS, b, b)}
00122   \textcolor{keywordflow}{if} (iter.rhsNorm() == 0.0) iter.setRhsNorm(1.0);
00123 
00124   \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar,RowMajor>} CINV(C.rows(), C.cols());
00125   \hyperlink{namespace_eigen_1_1internal_a58a0ccf0e71d88beeb5dcf72ed0bdd5f}{pseudo\_inverse}(C, CINV);
00126 
00127   \textcolor{keywordflow}{while}(\textcolor{keyword}{true})
00128   \{
00129     \textcolor{comment}{// computation of residual}
00130     old\_z = z;
00131     memox = x;
00132     r = b;
00133     r += A * -x;
00134     z = r;
00135     \textcolor{keywordtype}{bool} transition = \textcolor{keyword}{false};
00136     \textcolor{keywordflow}{for} (Index i = 0; i < C.rows(); ++i)
00137     \{
00138       Scalar al = C.row(i).dot(x) - f.coeff(i);
00139       \textcolor{keywordflow}{if} (al >= -1.0E-15)
00140       \{
00141         \textcolor{keywordflow}{if} (!satured[i])
00142         \{
00143           satured[i] = \textcolor{keyword}{true};
00144           transition = \textcolor{keyword}{true};
00145         \}
00146         Scalar bb = CINV.row(i).dot(z);
00147         \textcolor{keywordflow}{if} (bb > 0.0)
00148           \textcolor{comment}{// FIXME: we should allow that: z += -bb * C.row(i);}
00149           \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} CMatrix::InnerIterator it(C,i); it; ++it)
00150             z.coeffRef(it.index()) -= bb*it.value();
00151       \}
00152       \textcolor{keywordflow}{else}
00153         satured[i] = \textcolor{keyword}{false};
00154     \}
00155 
00156     \textcolor{comment}{// descent direction}
00157     rho\_1 = rho;
00158     rho = r.dot(z);
00159 
00160     \textcolor{keywordflow}{if} (iter.finished(rho)) \textcolor{keywordflow}{break};
00161 
00162     \textcolor{keywordflow}{if} (iter.noiseLevel() > 0 && transition) std::cerr << \textcolor{stringliteral}{"CCG: transition\(\backslash\)n"};
00163     \textcolor{keywordflow}{if} (transition || iter.first()) gamma = 0.0;
00164     \textcolor{keywordflow}{else} gamma = (std::max)(0.0, (rho - old\_z.dot(z)) / rho\_1);
00165     p = z + gamma*p;
00166 
00167     ++iter;
00168     \textcolor{comment}{// one dimensionnal optimization}
00169     q = A * p;
00170     lambda = rho / q.dot(p);
00171     \textcolor{keywordflow}{for} (Index i = 0; i < C.rows(); ++i)
00172     \{
00173       \textcolor{keywordflow}{if} (!satured[i])
00174       \{
00175         Scalar bb = C.row(i).dot(p) - f[i];
00176         \textcolor{keywordflow}{if} (bb > 0.0)
00177           lambda = (std::min)(lambda, (f.coeff(i)-C.row(i).dot(x)) / bb);
00178       \}
00179     \}
00180     x += lambda * p;
00181     memox -= x;
00182   \}
00183 \}
00184 
00185 \} \textcolor{comment}{// end namespace internal}
00186 
00187 \} \textcolor{comment}{// end namespace Eigen}
00188 
00189 \textcolor{preprocessor}{#endif // EIGEN\_CONSTRAINEDCG\_H}
\end{DoxyCode}
