\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+L\+U/\+Sparse\+LU.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source}\index{Sparse\+L\+U.\+h@{Sparse\+L\+U.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2012-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 
00012 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSE\_LU\_H}
00013 \textcolor{preprocessor}{#define EIGEN\_SPARSE\_LU\_H}
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00016 
00017 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_OrderingType = COLAMDOrdering<\textcolor{keyword}{typename} \_MatrixType::StorageIndex>
       > \textcolor{keyword}{class }SparseLU;
00018 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MappedSparseMatrixType> \textcolor{keyword}{struct }SparseLUMatrixLReturnType;
00019 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixLType, \textcolor{keyword}{typename} MatrixUType> \textcolor{keyword}{struct }SparseLUMatrixUReturnType;
00020 
00073 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_OrderingType>
00074 \textcolor{keyword}{class }SparseLU : \textcolor{keyword}{public} SparseSolverBase<SparseLU<\_MatrixType,\_OrderingType> >, \textcolor{keyword}{public} 
      internal::SparseLUImpl<typename \_MatrixType::Scalar, typename \_MatrixType::StorageIndex>
00075 \{
00076   \textcolor{keyword}{protected}:
00077     \textcolor{keyword}{typedef} SparseSolverBase<SparseLU<\_MatrixType,\_OrderingType> > APIBase;
00078     \textcolor{keyword}{using} APIBase::m\_isInitialized;
00079   \textcolor{keyword}{public}:
00080     \textcolor{keyword}{using} APIBase::\_solve\_impl;
00081     
00082     \textcolor{keyword}{typedef} \_MatrixType MatrixType; 
00083     \textcolor{keyword}{typedef} \_OrderingType OrderingType;
00084     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar; 
00085     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar; 
00086     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00087     \textcolor{keyword}{typedef} SparseMatrix<Scalar,ColMajor,StorageIndex> NCMatrix;
00088     \textcolor{keyword}{typedef} internal::MappedSuperNodalMatrix<Scalar, StorageIndex> SCMatrix;
00089     \textcolor{keyword}{typedef} Matrix<Scalar,Dynamic,1> ScalarVector;
00090     \textcolor{keyword}{typedef} Matrix<StorageIndex,Dynamic,1> IndexVector;
00091     \textcolor{keyword}{typedef} PermutationMatrix<Dynamic, Dynamic, StorageIndex> PermutationType;
00092     \textcolor{keyword}{typedef} internal::SparseLUImpl<Scalar, StorageIndex> Base;
00093 
00094     \textcolor{keyword}{enum} \{
00095       ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00096       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
00097     \};
00098     
00099   \textcolor{keyword}{public}:
00100     SparseLU():m\_lastError(\textcolor{stringliteral}{""}),m\_Ustore(0,0,0,0,0,0),m\_symmetricmode(false),m\_diagpivotthresh(1.0),
      m\_detPermR(1)
00101     \{
00102       initperfvalues(); 
00103     \}
00104     \textcolor{keyword}{explicit} SparseLU(\textcolor{keyword}{const} MatrixType& matrix)
00105       : m\_lastError(\textcolor{stringliteral}{""}),m\_Ustore(0,0,0,0,0,0),m\_symmetricmode(false),m\_diagpivotthresh(1.0),m\_detPermR(1)
00106     \{
00107       initperfvalues(); 
00108       \hyperlink{group___sparse_l_u___module_a96a8dcb02015ab9be5777d4ba9173266}{compute}(matrix);
00109     \}
00110     
00111     ~SparseLU()
00112     \{
00113       \textcolor{comment}{// Free all explicit dynamic pointers }
00114     \}
00115     
00116     \textcolor{keywordtype}{void} \hyperlink{group___sparse_l_u___module_aa907ff958c4f4855145091d2686f3a8a}{analyzePattern} (\textcolor{keyword}{const} MatrixType& matrix);
00117     \textcolor{keywordtype}{void} \hyperlink{group___sparse_l_u___module_a39858b0e72f2659d596364e252b34cbc}{factorize} (\textcolor{keyword}{const} MatrixType& matrix);
00118     \textcolor{keywordtype}{void} simplicialfactorize(\textcolor{keyword}{const} MatrixType& matrix);
00119     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00124}\hyperlink{group___sparse_l_u___module_a96a8dcb02015ab9be5777d4ba9173266}{00124}     \textcolor{keywordtype}{void} \hyperlink{group___sparse_l_u___module_a96a8dcb02015ab9be5777d4ba9173266}{compute} (\textcolor{keyword}{const} MatrixType& matrix)
00125     \{
00126       \textcolor{comment}{// Analyze }
00127       \hyperlink{group___sparse_l_u___module_aa907ff958c4f4855145091d2686f3a8a}{analyzePattern}(matrix); 
00128       \textcolor{comment}{//Factorize}
00129       \hyperlink{group___sparse_l_u___module_a39858b0e72f2659d596364e252b34cbc}{factorize}(matrix);
00130     \} 
00131     
00132     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_mat.\hyperlink{group___sparse_core___module_a62e61bb861eee306d5b069ce652b5aa5}{rows}(); \}
00133     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_mat.\hyperlink{group___sparse_core___module_aa391750e3c530227e4a5c3c52e959975}{cols}(); \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00135}\hyperlink{group___sparse_l_u___module_afff3bd506cd78172e5219c707562729f}{00135}     \textcolor{keywordtype}{void} \hyperlink{group___sparse_l_u___module_afff3bd506cd78172e5219c707562729f}{isSymmetric}(\textcolor{keywordtype}{bool} sym)
00136     \{
00137       m\_symmetricmode = sym;
00138     \}
00139     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00146}\hyperlink{group___sparse_l_u___module_a634abe55e5a076f2e10db78871105a8f}{00146}     \hyperlink{struct_eigen_1_1_sparse_l_u_matrix_l_return_type}{SparseLUMatrixLReturnType<SCMatrix>} 
      \hyperlink{group___sparse_l_u___module_a634abe55e5a076f2e10db78871105a8f}{matrixL}()\textcolor{keyword}{ const}
00147 \textcolor{keyword}{    }\{
00148       \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_sparse_l_u_matrix_l_return_type}{SparseLUMatrixLReturnType<SCMatrix>}(m\_Lstore);
00149     \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00156}\hyperlink{group___sparse_l_u___module_aaf395a8fca527144215ff19cc7b8b637}{00156}     
      \hyperlink{struct_eigen_1_1_sparse_l_u_matrix_u_return_type}{SparseLUMatrixUReturnType<SCMatrix,MappedSparseMatrix<Scalar,ColMajor,StorageIndex>}
       > \hyperlink{group___sparse_l_u___module_aaf395a8fca527144215ff19cc7b8b637}{matrixU}()\textcolor{keyword}{ const}
00157 \textcolor{keyword}{    }\{
00158       \textcolor{keywordflow}{return} 
      \hyperlink{struct_eigen_1_1_sparse_l_u_matrix_u_return_type}{SparseLUMatrixUReturnType<SCMatrix, MappedSparseMatrix<Scalar,ColMajor,StorageIndex>}
       >(m\_Lstore, m\_Ustore);
00159     \}
00160 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00165}\hyperlink{group___sparse_l_u___module_a691295e65c06df599876d78ac2c7fada}{00165}     \textcolor{keyword}{inline} \textcolor{keyword}{const} PermutationType& \hyperlink{group___sparse_l_u___module_a691295e65c06df599876d78ac2c7fada}{rowsPermutation}()\textcolor{keyword}{ const}
00166 \textcolor{keyword}{    }\{
00167       \textcolor{keywordflow}{return} m\_perm\_r;
00168     \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00173}\hyperlink{group___sparse_l_u___module_ab7b0d15d0d9fd1faa164298f92ca59cd}{00173}     \textcolor{keyword}{inline} \textcolor{keyword}{const} PermutationType& \hyperlink{group___sparse_l_u___module_ab7b0d15d0d9fd1faa164298f92ca59cd}{colsPermutation}()\textcolor{keyword}{ const}
00174 \textcolor{keyword}{    }\{
00175       \textcolor{keywordflow}{return} m\_perm\_c;
00176     \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00178}\hyperlink{group___sparse_l_u___module_a94c726c9ebb71a60b529fe47d942ad57}{00178}     \textcolor{keywordtype}{void} \hyperlink{group___sparse_l_u___module_a94c726c9ebb71a60b529fe47d942ad57}{setPivotThreshold}(\textcolor{keyword}{const} RealScalar& thresh)
00179     \{
00180       m\_diagpivotthresh = thresh; 
00181     \}
00182 
00183 \textcolor{preprocessor}{#ifdef EIGEN\_PARSED\_BY\_DOXYGEN}
00184 
00190     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs>
00191     \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_solve}{Solve<SparseLU, Rhs>} \hyperlink{group___sparse_core___module_a4a66e9498b06e3ec4ec36f06b26d4e8f}{solve}(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>}& \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}) \textcolor{keyword}{const};
00192 \textcolor{preprocessor}{#endif // EIGEN\_PARSED\_BY\_DOXYGEN}
00193     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00202}\hyperlink{group___sparse_l_u___module_ab0d0c1744ffd5a1dff578a44bcef2a3d}{00202}     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} \hyperlink{group___sparse_l_u___module_ab0d0c1744ffd5a1dff578a44bcef2a3d}{info}()\textcolor{keyword}{ const}
00203 \textcolor{keyword}{    }\{
00204       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"Decomposition is not initialized."});
00205       \textcolor{keywordflow}{return} m\_info;
00206     \}
00207     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00211}\hyperlink{group___sparse_l_u___module_a5458c4e851d7d75c8ca92c4fd02d2adb}{00211}     std::string \hyperlink{group___sparse_l_u___module_a5458c4e851d7d75c8ca92c4fd02d2adb}{lastErrorMessage}()\textcolor{keyword}{ const}
00212 \textcolor{keyword}{    }\{
00213       \textcolor{keywordflow}{return} m\_lastError; 
00214     \}
00215 
00216     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest>
00217     \textcolor{keywordtype}{bool} \_solve\_impl(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>} &B, \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>} &X\_base)\textcolor{keyword}{
       const}
00218 \textcolor{keyword}{    }\{
00219       Dest& X(X\_base.derived());
00220       eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"The matrix should be factorized first"});
00221       EIGEN\_STATIC\_ASSERT((Dest::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==0,
00222                         THIS\_METHOD\_IS\_ONLY\_FOR\_COLUMN\_MAJOR\_MATRICES);
00223       
00224       \textcolor{comment}{// Permute the right hand side to form X = Pr*B}
00225       \textcolor{comment}{// on return, X is overwritten by the computed solution}
00226       X.resize(B.rows(),B.cols());
00227 
00228       \textcolor{comment}{// this ugly const\_cast\_derived() helps to detect aliasing when applying the permutations}
00229       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < B.cols(); ++j)
00230         X.col(j) = \hyperlink{group___sparse_l_u___module_a691295e65c06df599876d78ac2c7fada}{rowsPermutation}() * B.const\_cast\_derived().\hyperlink{group___core___module_a469583ed90462820888344e63ebe1a80}{col}(j);
00231       
00232       \textcolor{comment}{//Forward substitution with L}
00233       this->\hyperlink{group___sparse_l_u___module_a634abe55e5a076f2e10db78871105a8f}{matrixL}().solveInPlace(X);
00234       this->\hyperlink{group___sparse_l_u___module_aaf395a8fca527144215ff19cc7b8b637}{matrixU}().solveInPlace(X);
00235       
00236       \textcolor{comment}{// Permute back the solution }
00237       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < B.cols(); ++j)
00238         X.col(j) = \hyperlink{group___sparse_l_u___module_ab7b0d15d0d9fd1faa164298f92ca59cd}{colsPermutation}().\hyperlink{group___core___module_adb9af427f317202366c2832876064eb3}{inverse}() * X.col(j);
00239       
00240       \textcolor{keywordflow}{return} \textcolor{keyword}{true}; 
00241     \}
00242     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00253}\hyperlink{group___sparse_l_u___module_a06fa89424239fb169d408f08252426d0}{00253}     Scalar \hyperlink{group___sparse_l_u___module_a06fa89424239fb169d408f08252426d0}{absDeterminant}()
00254     \{
00255       \textcolor{keyword}{using} std::abs;
00256       eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"The matrix should be factorized first."});
00257       \textcolor{comment}{// Initialize with the determinant of the row matrix}
00258       Scalar det = Scalar(1.);
00259       \textcolor{comment}{// Note that the diagonal blocks of U are stored in supernodes,}
00260       \textcolor{comment}{// which are available in the  L part :)}
00261       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < this->cols(); ++j)
00262       \{
00263         \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} SCMatrix::InnerIterator it(m\_Lstore, j); it; ++it)
00264         \{
00265           \textcolor{keywordflow}{if}(it.index() == j)
00266           \{
00267             det *= abs(it.value());
00268             \textcolor{keywordflow}{break};
00269           \}
00270         \}
00271       \}
00272       \textcolor{keywordflow}{return} det;
00273     \}
00274 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00283}\hyperlink{group___sparse_l_u___module_a89e30a7df205596784a5a73f4768eaec}{00283}     Scalar \hyperlink{group___sparse_l_u___module_a89e30a7df205596784a5a73f4768eaec}{logAbsDeterminant}()\textcolor{keyword}{ const}
00284 \textcolor{keyword}{    }\{
00285       \textcolor{keyword}{using} std::log;
00286       \textcolor{keyword}{using} std::abs;
00287 
00288       eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"The matrix should be factorized first."});
00289       Scalar det = Scalar(0.);
00290       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < this->cols(); ++j)
00291       \{
00292         \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} SCMatrix::InnerIterator it(m\_Lstore, j); it; ++it)
00293         \{
00294           \textcolor{keywordflow}{if}(it.row() < j) \textcolor{keywordflow}{continue};
00295           \textcolor{keywordflow}{if}(it.row() == j)
00296           \{
00297             det += \hyperlink{structlog}{log}(abs(it.value()));
00298             \textcolor{keywordflow}{break};
00299           \}
00300         \}
00301       \}
00302       \textcolor{keywordflow}{return} det;
00303     \}
00304 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00309}\hyperlink{group___sparse_l_u___module_a6651143e3b18fa90cfb3808b6fd23c4e}{00309}     Scalar \hyperlink{group___sparse_l_u___module_a6651143e3b18fa90cfb3808b6fd23c4e}{signDeterminant}()
00310     \{
00311       eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"The matrix should be factorized first."});
00312       \textcolor{comment}{// Initialize with the determinant of the row matrix}
00313       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} det = 1;
00314       \textcolor{comment}{// Note that the diagonal blocks of U are stored in supernodes,}
00315       \textcolor{comment}{// which are available in the  L part :)}
00316       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < this->cols(); ++j)
00317       \{
00318         \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} SCMatrix::InnerIterator it(m\_Lstore, j); it; ++it)
00319         \{
00320           \textcolor{keywordflow}{if}(it.index() == j)
00321           \{
00322             \textcolor{keywordflow}{if}(it.value()<0)
00323               det = -det;
00324             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(it.value()==0)
00325               \textcolor{keywordflow}{return} 0;
00326             \textcolor{keywordflow}{break};
00327           \}
00328         \}
00329       \}
00330       \textcolor{keywordflow}{return} det * m\_detPermR * m\_detPermC;
00331     \}
00332     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u_8h_source_l00337}\hyperlink{group___sparse_l_u___module_a02d63d242d27211b5c5827f5d4fd99ff}{00337}     Scalar \hyperlink{group___sparse_l_u___module_a02d63d242d27211b5c5827f5d4fd99ff}{determinant}()
00338     \{
00339       eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"The matrix should be factorized first."});
00340       \textcolor{comment}{// Initialize with the determinant of the row matrix}
00341       Scalar det = Scalar(1.);
00342       \textcolor{comment}{// Note that the diagonal blocks of U are stored in supernodes,}
00343       \textcolor{comment}{// which are available in the  L part :)}
00344       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < this->cols(); ++j)
00345       \{
00346         \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} SCMatrix::InnerIterator it(m\_Lstore, j); it; ++it)
00347         \{
00348           \textcolor{keywordflow}{if}(it.index() == j)
00349           \{
00350             det *= it.value();
00351             \textcolor{keywordflow}{break};
00352           \}
00353         \}
00354       \}
00355       \textcolor{keywordflow}{return} (m\_detPermR * m\_detPermC) > 0 ? det : -det;
00356     \}
00357 
00358   \textcolor{keyword}{protected}:
00359     \textcolor{comment}{// Functions }
00360     \textcolor{keywordtype}{void} initperfvalues()
00361     \{
00362       m\_perfv.panel\_size = 16;
00363       m\_perfv.relax = 1; 
00364       m\_perfv.maxsuper = 128; 
00365       m\_perfv.rowblk = 16; 
00366       m\_perfv.colblk = 8; 
00367       m\_perfv.fillfactor = 20;  
00368     \}
00369       
00370     \textcolor{comment}{// Variables }
00371     \textcolor{keyword}{mutable} \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} m\_info;
00372     \textcolor{keywordtype}{bool} m\_factorizationIsOk;
00373     \textcolor{keywordtype}{bool} m\_analysisIsOk;
00374     std::string m\_lastError;
00375     NCMatrix m\_mat; \textcolor{comment}{// The input (permuted ) matrix }
00376     SCMatrix m\_Lstore; \textcolor{comment}{// The lower triangular matrix (supernodal)}
00377     \hyperlink{class_eigen_1_1_mapped_sparse_matrix}{MappedSparseMatrix<Scalar,ColMajor,StorageIndex>} 
      m\_Ustore; \textcolor{comment}{// The upper triangular matrix}
00378     PermutationType m\_perm\_c; \textcolor{comment}{// Column permutation }
00379     PermutationType m\_perm\_r ; \textcolor{comment}{// Row permutation}
00380     IndexVector m\_etree; \textcolor{comment}{// Column elimination tree }
00381     
00382     \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1_l_u___global_l_u__t}{Base::GlobalLU\_t} m\_glu; 
00383                                
00384     \textcolor{comment}{// SparseLU options }
00385     \textcolor{keywordtype}{bool} m\_symmetricmode;
00386     \textcolor{comment}{// values for performance }
00387     \hyperlink{struct_eigen_1_1internal_1_1perfvalues}{internal::perfvalues} m\_perfv;
00388     RealScalar m\_diagpivotthresh; \textcolor{comment}{// Specifies the threshold used for a diagonal entry to be an acceptable
       pivot}
00389     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_nnzL, m\_nnzU; \textcolor{comment}{// Nonzeros in L and U factors}
00390     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_detPermR, m\_detPermC; \textcolor{comment}{// Determinants of the permutation matrices}
00391   \textcolor{keyword}{private}:
00392     \textcolor{comment}{// Disable copy constructor }
00393     \hyperlink{group___sparse_l_u___module_class_eigen_1_1_sparse_l_u}{SparseLU} (\textcolor{keyword}{const} \hyperlink{group___sparse_l_u___module_class_eigen_1_1_sparse_l_u}{SparseLU}& );
00394   
00395 \}; \textcolor{comment}{// End class SparseLU}
00396 
00397 
00398 
00399 \textcolor{comment}{// Functions needed by the anaysis phase}
00410 \textcolor{comment}{}\textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} OrderingType>
00411 \textcolor{keywordtype}{void} \hyperlink{group___sparse_l_u___module_aa907ff958c4f4855145091d2686f3a8a}{SparseLU<MatrixType, OrderingType>::analyzePattern}(\textcolor{keyword}{
      const} MatrixType& mat)
00412 \{
00413   
00414   \textcolor{comment}{//TODO  It is possible as in SuperLU to compute row and columns scaling vectors to equilibrate the matrix
       mat.}
00415   
00416   \textcolor{comment}{// Firstly, copy the whole input matrix. }
00417   m\_mat = mat;
00418   
00419   \textcolor{comment}{// Compute fill-in ordering}
00420   OrderingType ord; 
00421   ord(m\_mat,m\_perm\_c);
00422   
00423   \textcolor{comment}{// Apply the permutation to the column of the input  matrix}
00424   \textcolor{keywordflow}{if} (m\_perm\_c.\hyperlink{group___core___module_a2216f9ce7b453ac39c46ff0323daeac9}{size}())
00425   \{
00426     m\_mat.\hyperlink{group___sparse_core___module_a7e560ebda035e992d2c99875cc7c3af3}{uncompress}(); \textcolor{comment}{//NOTE: The effect of this command is only to create the InnerNonzeros
       pointers. FIXME : This vector is filled but not subsequently used.  }
00427     \textcolor{comment}{// Then, permute only the column pointers}
00428     ei\_declare\_aligned\_stack\_constructed\_variable(StorageIndex,outerIndexPtr,mat.cols()+1,mat.isCompressed(
      )?\textcolor{keyword}{const\_cast<}StorageIndex*\textcolor{keyword}{>}(mat.outerIndexPtr()):0);
00429     
00430     \textcolor{comment}{// If the input matrix 'mat' is uncompressed, then the outer-indices do not match the ones of m\_mat,
       and a copy is thus needed.}
00431     \textcolor{keywordflow}{if}(!mat.isCompressed()) 
00432       IndexVector::Map(outerIndexPtr, mat.cols()+1) = IndexVector::Map(m\_mat.
      \hyperlink{group___sparse_core___module_a75506964d86d6badb32d0b4917acf2e2}{outerIndexPtr}(),mat.cols()+1);
00433     
00434     \textcolor{comment}{// Apply the permutation and compute the nnz per column.}
00435     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < mat.cols(); i++)
00436     \{
00437       m\_mat.\hyperlink{group___sparse_core___module_a75506964d86d6badb32d0b4917acf2e2}{outerIndexPtr}()[m\_perm\_c.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}()(i)] = outerIndexPtr[i];
00438       m\_mat.\hyperlink{group___sparse_core___module_a218204b051a24f579c394454786eeda0}{innerNonZeroPtr}()[m\_perm\_c.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}()(i)] = outerIndexPtr[i+1] - 
      outerIndexPtr[i];
00439     \}
00440   \}
00441   
00442   \textcolor{comment}{// Compute the column elimination tree of the permuted matrix }
00443   \hyperlink{group___core___module}{IndexVector} firstRowElt;
00444   \hyperlink{namespace_eigen_1_1internal_a86181db74ba596a7afbfd89efcc5788c}{internal::coletree}(m\_mat, m\_etree,firstRowElt); 
00445      
00446   \textcolor{comment}{// In symmetric mode, do not do postorder here}
00447   \textcolor{keywordflow}{if} (!m\_symmetricmode) \{
00448     \hyperlink{group___core___module}{IndexVector} post, iwork; 
00449     \textcolor{comment}{// Post order etree}
00450     \hyperlink{namespace_eigen_1_1internal_ab414b5990bd6c865958a9231ff418d20}{internal::treePostorder}(StorageIndex(m\_mat.\hyperlink{group___sparse_core___module_aa391750e3c530227e4a5c3c52e959975}{cols}()), m\_etree, post); 
00451       
00452    
00453     \textcolor{comment}{// Renumber etree in postorder }
00454     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m = m\_mat.\hyperlink{group___sparse_core___module_aa391750e3c530227e4a5c3c52e959975}{cols}(); 
00455     iwork.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(m+1);
00456     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < m; ++i) iwork(post(i)) = post(m\_etree(i));
00457     m\_etree = iwork;
00458     
00459     \textcolor{comment}{// Postmultiply A*Pc by post, i.e reorder the matrix according to the postorder of the etree}
00460     \hyperlink{group___core___module}{PermutationType} post\_perm(m); 
00461     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < m; i++) 
00462       post\_perm.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}()(i) = post(i); 
00463         
00464     \textcolor{comment}{// Combine the two permutations : postorder the permutation for future use}
00465     \textcolor{keywordflow}{if}(m\_perm\_c.\hyperlink{group___core___module_a2216f9ce7b453ac39c46ff0323daeac9}{size}()) \{
00466       m\_perm\_c = post\_perm * m\_perm\_c;
00467     \}
00468     
00469   \} \textcolor{comment}{// end postordering }
00470   
00471   m\_analysisIsOk = \textcolor{keyword}{true}; 
00472 \}
00473 
00474 \textcolor{comment}{// Functions needed by the numerical factorization phase}
00475 
00476 
00495 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} OrderingType>
00496 \textcolor{keywordtype}{void} \hyperlink{group___sparse_l_u___module_a39858b0e72f2659d596364e252b34cbc}{SparseLU<MatrixType, OrderingType>::factorize}(\textcolor{keyword}{const} 
      MatrixType& matrix)
00497 \{
00498   \textcolor{keyword}{using} internal::emptyIdxLU;
00499   eigen\_assert(m\_analysisIsOk && \textcolor{stringliteral}{"analyzePattern() should be called first"}); 
00500   eigen\_assert((matrix.rows() == matrix.cols()) && \textcolor{stringliteral}{"Only for squared matrices"});
00501   
00502   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} IndexVector::Scalar StorageIndex; 
00503   
00504   m\_isInitialized = \textcolor{keyword}{true};
00505   
00506   
00507   \textcolor{comment}{// Apply the column permutation computed in analyzepattern()}
00508   \textcolor{comment}{//   m\_mat = matrix * m\_perm\_c.inverse(); }
00509   m\_mat = matrix;
00510   \textcolor{keywordflow}{if} (m\_perm\_c.\hyperlink{group___core___module_a2216f9ce7b453ac39c46ff0323daeac9}{size}()) 
00511   \{
00512     m\_mat.\hyperlink{group___sparse_core___module_a7e560ebda035e992d2c99875cc7c3af3}{uncompress}(); \textcolor{comment}{//NOTE: The effect of this command is only to create the InnerNonzeros
       pointers.}
00513     \textcolor{comment}{//Then, permute only the column pointers}
00514     \textcolor{keyword}{const} StorageIndex * outerIndexPtr;
00515     \textcolor{keywordflow}{if} (matrix.isCompressed()) outerIndexPtr = matrix.outerIndexPtr();
00516     \textcolor{keywordflow}{else}
00517     \{
00518       StorageIndex* outerIndexPtr\_t = \textcolor{keyword}{new} StorageIndex[matrix.cols()+1];
00519       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i <= matrix.cols(); i++) outerIndexPtr\_t[i] = m\_mat.
      \hyperlink{group___sparse_core___module_a75506964d86d6badb32d0b4917acf2e2}{outerIndexPtr}()[i];
00520       outerIndexPtr = outerIndexPtr\_t;
00521     \}
00522     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < matrix.cols(); i++)
00523     \{
00524       m\_mat.\hyperlink{group___sparse_core___module_a75506964d86d6badb32d0b4917acf2e2}{outerIndexPtr}()[m\_perm\_c.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}()(i)] = outerIndexPtr[i];
00525       m\_mat.\hyperlink{group___sparse_core___module_a218204b051a24f579c394454786eeda0}{innerNonZeroPtr}()[m\_perm\_c.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}()(i)] = outerIndexPtr[i+1] - 
      outerIndexPtr[i];
00526     \}
00527     \textcolor{keywordflow}{if}(!matrix.isCompressed()) \textcolor{keyword}{delete}[] outerIndexPtr;
00528   \} 
00529   \textcolor{keywordflow}{else} 
00530   \{ \textcolor{comment}{//FIXME This should not be needed if the empty permutation is handled transparently}
00531     m\_perm\_c.\hyperlink{group___core___module_a0e0fda6e84d69e02432e4770359bb532}{resize}(matrix.cols());
00532     \textcolor{keywordflow}{for}(StorageIndex i = 0; i < matrix.cols(); ++i) m\_perm\_c.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}()(i) = i;
00533   \}
00534   
00535   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m = m\_mat.\hyperlink{group___sparse_core___module_a62e61bb861eee306d5b069ce652b5aa5}{rows}();
00536   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = m\_mat.\hyperlink{group___sparse_core___module_aa391750e3c530227e4a5c3c52e959975}{cols}();
00537   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nnz = m\_mat.\hyperlink{group___sparse_core___module_a03de8b3da2c142ce8698a76123b3e7d3}{nonZeros}();
00538   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} maxpanel = m\_perfv.panel\_size * m;
00539   \textcolor{comment}{// Allocate working storage common to the factor routines}
00540   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lwork = 0;
00541   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{group___sparse_l_u___module_ab0d0c1744ffd5a1dff578a44bcef2a3d}{info} = \hyperlink{group___sparse_l_u___module_ac018b8ed9664d4e19e34f1ff2d6c578a}{Base::memInit}(m, n, nnz, lwork, m\_perfv.fillfactor, m\_perfv.panel\_size
      , m\_glu); 
00542   \textcolor{keywordflow}{if} (info) 
00543   \{
00544     m\_lastError = \textcolor{stringliteral}{"UNABLE TO ALLOCATE WORKING MEMORY\(\backslash\)n\(\backslash\)n"} ;
00545     m\_factorizationIsOk = \textcolor{keyword}{false};
00546     return ; 
00547   \}
00548   
00549   \textcolor{comment}{// Set up pointers for integer working arrays }
00550   \hyperlink{group___core___module}{IndexVector} segrep(m); segrep.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00551   \hyperlink{group___core___module}{IndexVector} parent(m); parent.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00552   \hyperlink{group___core___module}{IndexVector} xplore(m); xplore.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00553   \hyperlink{group___core___module}{IndexVector} repfnz(maxpanel);
00554   \hyperlink{group___core___module}{IndexVector} panel\_lsub(maxpanel);
00555   \hyperlink{group___core___module}{IndexVector} xprune(n); xprune.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00556   \hyperlink{group___core___module}{IndexVector} marker(m*internal::LUNoMarker); marker.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00557   
00558   repfnz.\hyperlink{class_eigen_1_1_plain_object_base_ac8dea1df3d92b752cc683ff42abf6f9b}{setConstant}(-1); 
00559   panel\_lsub.\hyperlink{class_eigen_1_1_plain_object_base_ac8dea1df3d92b752cc683ff42abf6f9b}{setConstant}(-1);
00560   
00561   \textcolor{comment}{// Set up pointers for scalar working arrays }
00562   \hyperlink{group___core___module}{ScalarVector} dense; 
00563   dense.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}(maxpanel);
00564   \hyperlink{group___core___module}{ScalarVector} tempv; 
00565   tempv.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}(internal::LUnumTempV(m, m\_perfv.panel\_size, m\_perfv.maxsuper, \textcolor{comment}{/*m\_perfv.rowblk*/}m) )
      ;
00566   
00567   \textcolor{comment}{// Compute the inverse of perm\_c}
00568   \hyperlink{group___core___module}{PermutationType} iperm\_c(m\_perm\_c.\hyperlink{group___core___module_adb9af427f317202366c2832876064eb3}{inverse}()); 
00569   
00570   \textcolor{comment}{// Identify initial relaxed snodes}
00571   \hyperlink{group___core___module}{IndexVector} relax\_end(n);
00572   \textcolor{keywordflow}{if} ( m\_symmetricmode == \textcolor{keyword}{true} ) 
00573     \hyperlink{group___sparse_l_u___module_a88952ce33c968374b149e31d0539178d}{Base::heap\_relax\_snode}(n, m\_etree, m\_perfv.relax, marker, relax\_end);
00574   \textcolor{keywordflow}{else}
00575     \hyperlink{group___sparse_l_u___module_a33672df380f94e774c5a6919d3474af4}{Base::relax\_snode}(n, m\_etree, m\_perfv.relax, marker, relax\_end);
00576   
00577   
00578   m\_perm\_r.\hyperlink{group___core___module_a0e0fda6e84d69e02432e4770359bb532}{resize}(m); 
00579   m\_perm\_r.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}().setConstant(-1);
00580   marker.\hyperlink{class_eigen_1_1_plain_object_base_ac8dea1df3d92b752cc683ff42abf6f9b}{setConstant}(-1);
00581   m\_detPermR = 1; \textcolor{comment}{// Record the determinant of the row permutation}
00582   
00583   m\_glu.supno(0) = emptyIdxLU; m\_glu.xsup.\hyperlink{class_eigen_1_1_plain_object_base_ac8dea1df3d92b752cc683ff42abf6f9b}{setConstant}(0);
00584   m\_glu.xsup(0) = m\_glu.xlsub(0) = m\_glu.xusub(0) = m\_glu.xlusup(0) = \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(0);
00585   
00586   \textcolor{comment}{// Work on one 'panel' at a time. A panel is one of the following :}
00587   \textcolor{comment}{//  (a) a relaxed supernode at the bottom of the etree, or}
00588   \textcolor{comment}{//  (b) panel\_size contiguous columns, <panel\_size> defined by the user}
00589   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} jcol; 
00590   \hyperlink{group___core___module}{IndexVector} panel\_histo(n);
00591   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} pivrow; \textcolor{comment}{// Pivotal row number in the original row matrix}
00592   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nseg1; \textcolor{comment}{// Number of segments in U-column above panel row jcol}
00593   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nseg; \textcolor{comment}{// Number of segments in each U-column }
00594   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} irep; 
00595   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, k, jj; 
00596   \textcolor{keywordflow}{for} (jcol = 0; jcol < n; )
00597   \{
00598     \textcolor{comment}{// Adjust panel size so that a panel won't overlap with the next relaxed snode. }
00599     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} panel\_size = m\_perfv.panel\_size; \textcolor{comment}{// upper bound on panel width}
00600     \textcolor{keywordflow}{for} (k = jcol + 1; k < (std::min)(jcol+panel\_size, n); k++)
00601     \{
00602       \textcolor{keywordflow}{if} (relax\_end(k) != emptyIdxLU) 
00603       \{
00604         panel\_size = k - jcol; 
00605         \textcolor{keywordflow}{break}; 
00606       \}
00607     \}
00608     \textcolor{keywordflow}{if} (k == n) 
00609       panel\_size = n - jcol; 
00610       
00611     \textcolor{comment}{// Symbolic outer factorization on a panel of columns }
00612     \hyperlink{group___sparse_l_u___module_acaf62fda387ea03e9caa2734e4e7b0c9}{Base::panel\_dfs}(m, panel\_size, jcol, m\_mat, m\_perm\_r.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}(), nseg1, dense, 
      panel\_lsub, segrep, repfnz, xprune, marker, parent, xplore, m\_glu); 
00613     
00614     \textcolor{comment}{// Numeric sup-panel updates in topological order }
00615     \hyperlink{group___sparse_l_u___module_a277936738db49e25285164ac25c498c3}{Base::panel\_bmod}(m, panel\_size, jcol, nseg1, dense, tempv, segrep, repfnz, m\_glu); 
00616     
00617     \textcolor{comment}{// Sparse LU within the panel, and below the panel diagonal }
00618     \textcolor{keywordflow}{for} ( jj = jcol; jj< jcol + panel\_size; jj++) 
00619     \{
00620       k = (jj - jcol) * m; \textcolor{comment}{// Column index for w-wide arrays }
00621       
00622       nseg = nseg1; \textcolor{comment}{// begin after all the panel segments}
00623       \textcolor{comment}{//Depth-first-search for the current column}
00624       \hyperlink{group___core___module_class_eigen_1_1_vector_block}{VectorBlock<IndexVector>} panel\_lsubk(panel\_lsub, k, m);
00625       \hyperlink{group___core___module_class_eigen_1_1_vector_block}{VectorBlock<IndexVector>} repfnz\_k(repfnz, k, m); 
00626       info = \hyperlink{group___sparse_l_u___module_a6f543ae02eb6467e9bcc1e5cec8ccdd2}{Base::column\_dfs}(m, jj, m\_perm\_r.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}(), m\_perfv.maxsuper, nseg, 
      panel\_lsubk, segrep, repfnz\_k, xprune, marker, parent, xplore, m\_glu); 
00627       \textcolor{keywordflow}{if} ( info ) 
00628       \{
00629         m\_lastError =  \textcolor{stringliteral}{"UNABLE TO EXPAND MEMORY IN COLUMN\_DFS() "};
00630         m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue}; 
00631         m\_factorizationIsOk = \textcolor{keyword}{false}; 
00632         \textcolor{keywordflow}{return}; 
00633       \}
00634       \textcolor{comment}{// Numeric updates to this column }
00635       \hyperlink{group___core___module_class_eigen_1_1_vector_block}{VectorBlock<ScalarVector>} dense\_k(dense, k, m); 
00636       \hyperlink{group___core___module_class_eigen_1_1_vector_block}{VectorBlock<IndexVector>} segrep\_k(segrep, nseg1, m-nseg1); 
00637       info = \hyperlink{group___sparse_l_u___module_ae34275602cf12560edfcaf7cd5cbe932}{Base::column\_bmod}(jj, (nseg - nseg1), dense\_k, tempv, segrep\_k, repfnz\_k, 
      jcol, m\_glu); 
00638       \textcolor{keywordflow}{if} ( info ) 
00639       \{
00640         m\_lastError = \textcolor{stringliteral}{"UNABLE TO EXPAND MEMORY IN COLUMN\_BMOD() "};
00641         m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue}; 
00642         m\_factorizationIsOk = \textcolor{keyword}{false}; 
00643         \textcolor{keywordflow}{return}; 
00644       \}
00645       
00646       \textcolor{comment}{// Copy the U-segments to ucol(*)}
00647       info = \hyperlink{group___sparse_l_u___module_ae4867ed1d5f104f9245411c356416a21}{Base::copy\_to\_ucol}(jj, nseg, segrep, repfnz\_k ,m\_perm\_r.
      \hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}(), dense\_k, m\_glu); 
00648       \textcolor{keywordflow}{if} ( info ) 
00649       \{
00650         m\_lastError = \textcolor{stringliteral}{"UNABLE TO EXPAND MEMORY IN COPY\_TO\_UCOL() "};
00651         m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue}; 
00652         m\_factorizationIsOk = \textcolor{keyword}{false}; 
00653         \textcolor{keywordflow}{return}; 
00654       \}
00655       
00656       \textcolor{comment}{// Form the L-segment }
00657       info = \hyperlink{group___sparse_l_u___module_ab5f56947465b829f8d523575724c3ac6}{Base::pivotL}(jj, m\_diagpivotthresh, m\_perm\_r.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}(), iperm\_c.indices(), 
      pivrow, m\_glu);
00658       \textcolor{keywordflow}{if} ( info ) 
00659       \{
00660         m\_lastError = \textcolor{stringliteral}{"THE MATRIX IS STRUCTURALLY SINGULAR ... ZERO COLUMN AT "};
00661         std::ostringstream returnInfo;
00662         returnInfo << \hyperlink{group___sparse_l_u___module_ab0d0c1744ffd5a1dff578a44bcef2a3d}{info}; 
00663         m\_lastError += returnInfo.str();
00664         m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue}; 
00665         m\_factorizationIsOk = \textcolor{keyword}{false}; 
00666         \textcolor{keywordflow}{return}; 
00667       \}
00668       
00669       \textcolor{comment}{// Update the determinant of the row permutation matrix}
00670       \textcolor{comment}{// FIXME: the following test is not correct, we should probably take iperm\_c into account and pivrow
       is not directly the row pivot.}
00671       \textcolor{keywordflow}{if} (pivrow != jj) m\_detPermR = -m\_detPermR;
00672 
00673       \textcolor{comment}{// Prune columns (0:jj-1) using column jj}
00674       \hyperlink{group___sparse_l_u___module_a350464d1c83182fbd7da8a5a74bdfde8}{Base::pruneL}(jj, m\_perm\_r.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}(), pivrow, nseg, segrep, repfnz\_k, xprune, m\_glu
      ); 
00675       
00676       \textcolor{comment}{// Reset repfnz for this column }
00677       \textcolor{keywordflow}{for} (i = 0; i < nseg; i++)
00678       \{
00679         irep = segrep(i); 
00680         repfnz\_k(irep) = emptyIdxLU; 
00681       \}
00682     \} \textcolor{comment}{// end SparseLU within the panel  }
00683     jcol += panel\_size;  \textcolor{comment}{// Move to the next panel}
00684   \} \textcolor{comment}{// end for -- end elimination }
00685   
00686   m\_detPermR = m\_perm\_r.\hyperlink{group___core___module_a1fc7a5823544700c2e0795e87f9c6d09}{determinant}();
00687   m\_detPermC = m\_perm\_c.\hyperlink{group___core___module_a1fc7a5823544700c2e0795e87f9c6d09}{determinant}();
00688   
00689   \textcolor{comment}{// Count the number of nonzeros in factors }
00690   \hyperlink{group___sparse_l_u___module_acbede3f259186d48ad42ca093f80b64b}{Base::countnz}(n, m\_nnzL, m\_nnzU, m\_glu); 
00691   \textcolor{comment}{// Apply permutation  to the L subscripts }
00692   \hyperlink{group___sparse_l_u___module_ae1d1ed091956ff4e5734b4e3f79f866e}{Base::fixupL}(n, m\_perm\_r.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}(), m\_glu);
00693   
00694   \textcolor{comment}{// Create supernode matrix L }
00695   m\_Lstore.\hyperlink{group___sparse_l_u___module_af1427486564e2c75b9da68f98bd04e63}{setInfos}(m, n, m\_glu.lusup, m\_glu.xlusup, m\_glu.lsub, m\_glu.xlsub, m\_glu.supno, m\_glu.
      xsup); 
00696   \textcolor{comment}{// Create the column major upper sparse matrix  U; }
00697   \textcolor{keyword}{new} (&m\_Ustore) \hyperlink{class_eigen_1_1_mapped_sparse_matrix}{MappedSparseMatrix<Scalar, ColMajor, StorageIndex>}
       ( m, n, m\_nnzU, m\_glu.xusub.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(), m\_glu.usub.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}(), m\_glu.ucol.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}() );
00698   
00699   m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00700   m\_factorizationIsOk = \textcolor{keyword}{true};
00701 \}
00702 
00703 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MappedSupernodalType>
00704 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_sparse_l_u_matrix_l_return_type}{SparseLUMatrixLReturnType} : 
      \hyperlink{class_eigen_1_1internal_1_1no__assignment__operator}{internal::no\_assignment\_operator}
00705 \{
00706   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MappedSupernodalType::Scalar Scalar;
00707   \textcolor{keyword}{explicit} \hyperlink{struct_eigen_1_1_sparse_l_u_matrix_l_return_type}{SparseLUMatrixLReturnType}(\textcolor{keyword}{const} MappedSupernodalType& mapL) : m\_mapL(
      mapL)
00708   \{ \}
00709   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows() \{ \textcolor{keywordflow}{return} m\_mapL.rows(); \}
00710   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols() \{ \textcolor{keywordflow}{return} m\_mapL.cols(); \}
00711   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00712   \textcolor{keywordtype}{void} solveInPlace( \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>} &X)\textcolor{keyword}{ const}
00713 \textcolor{keyword}{  }\{
00714     m\_mapL.solveInPlace(X);
00715   \}
00716   \textcolor{keyword}{const} MappedSupernodalType& m\_mapL;
00717 \};
00718 
00719 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixLType, \textcolor{keyword}{typename} MatrixUType>
00720 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_sparse_l_u_matrix_u_return_type}{SparseLUMatrixUReturnType} : 
      \hyperlink{class_eigen_1_1internal_1_1no__assignment__operator}{internal::no\_assignment\_operator}
00721 \{
00722   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixLType::Scalar Scalar;
00723   \hyperlink{struct_eigen_1_1_sparse_l_u_matrix_u_return_type}{SparseLUMatrixUReturnType}(\textcolor{keyword}{const} MatrixLType& mapL, \textcolor{keyword}{const} MatrixUType& mapU)
00724   : m\_mapL(mapL),m\_mapU(mapU)
00725   \{ \}
00726   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows() \{ \textcolor{keywordflow}{return} m\_mapL.rows(); \}
00727   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols() \{ \textcolor{keywordflow}{return} m\_mapL.cols(); \}
00728 
00729   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>   \textcolor{keywordtype}{void} solveInPlace(\hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>} &X)\textcolor{keyword}{ const}
00730 \textcolor{keyword}{  }\{
00731     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nrhs = X.cols();
00732     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n    = X.rows();
00733     \textcolor{comment}{// Backward solve with U}
00734     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = m\_mapL.nsuper(); k >= 0; k--)
00735     \{
00736       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} fsupc = m\_mapL.supToCol()[k];
00737       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lda = m\_mapL.colIndexPtr()[fsupc+1] - m\_mapL.colIndexPtr()[fsupc]; \textcolor{comment}{// leading dimension}
00738       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nsupc = m\_mapL.supToCol()[k+1] - fsupc;
00739       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} luptr = m\_mapL.colIndexPtr()[fsupc];
00740 
00741       \textcolor{keywordflow}{if} (nsupc == 1)
00742       \{
00743         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < nrhs; j++)
00744         \{
00745           X(fsupc, j) /= m\_mapL.valuePtr()[luptr];
00746         \}
00747       \}
00748       \textcolor{keywordflow}{else}
00749       \{
00750         \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Matrix<Scalar,Dynamic,Dynamic, ColMajor>}
      , 0, \hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>} > \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}( &(m\_mapL.valuePtr()[luptr]), nsupc, nsupc, 
      \hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>}(lda) );
00751         \hyperlink{group___core___module_class_eigen_1_1_map}{Map< Matrix<Scalar,Dynamic,Dest::ColsAtCompileTime, ColMajor>}
      , 0, \hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>} > U (&(X(fsupc,0)), nsupc, nrhs, \hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>}(n) );
00752         U = \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}.template triangularView<Upper>().\hyperlink{group___sparse_core___module_a4a66e9498b06e3ec4ec36f06b26d4e8f}{solve}(U);
00753       \}
00754 
00755       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < nrhs; ++j)
00756       \{
00757         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} jcol = fsupc; jcol < fsupc + nsupc; jcol++)
00758         \{
00759           \textcolor{keyword}{typename} MatrixUType::InnerIterator it(m\_mapU, jcol);
00760           \textcolor{keywordflow}{for} ( ; it; ++it)
00761           \{
00762             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} irow = it.index();
00763             X(irow, j) -= X(jcol, j) * it.\hyperlink{group___core___module_a8da735a6bfc7012606acf787156d10a0}{value}();
00764           \}
00765         \}
00766       \}
00767     \} \textcolor{comment}{// End For U-solve}
00768   \}
00769   \textcolor{keyword}{const} MatrixLType& m\_mapL;
00770   \textcolor{keyword}{const} MatrixUType& m\_mapU;
00771 \};
00772 
00773 \} \textcolor{comment}{// End namespace Eigen }
00774 
00775 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
