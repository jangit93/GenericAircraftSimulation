\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_symmetry_2_symmetry_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor\+Symmetry/\+Symmetry.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_symmetry_2_symmetry_8h_source}\index{Symmetry.\+h@{Symmetry.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2013 Christian Seiler <christian@iwakd.de>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSORSYMMETRY\_SYMMETRY\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSORSYMMETRY\_SYMMETRY\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{enum} \{
00016   NegationFlag           = 0x01,
00017   ConjugationFlag        = 0x02
00018 \};
00019 
00020 \textcolor{keyword}{enum} \{
00021   GlobalRealFlag         = 0x01,
00022   GlobalImagFlag         = 0x02,
00023   GlobalZeroFlag         = 0x03
00024 \};
00025 
00026 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00027 
00028 \textcolor{keyword}{template}<std::size\_t NumIndices, \textcolor{keyword}{typename}... Sym>                   \textcolor{keyword}{struct }tensor\_symmetry\_pre\_analysis;
00029 \textcolor{keyword}{template}<std::size\_t NumIndices, \textcolor{keyword}{typename}... Sym>                   \textcolor{keyword}{struct }tensor\_static\_symgroup;
00030 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} instantiate, std::size\_t NumIndices, \textcolor{keyword}{typename}... Sym> \textcolor{keyword}{struct }tensor\_static\_symgroup\_if;
00031 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Tensor\_> \textcolor{keyword}{struct }tensor\_symmetry\_calculate\_flags;
00032 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Tensor\_> \textcolor{keyword}{struct }tensor\_symmetry\_assign\_value;
00033 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Sym> \textcolor{keyword}{struct }tensor\_symmetry\_num\_indices;
00034 
00035 \} \textcolor{comment}{// end namespace internal}
00036 
00037 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} One\_, \textcolor{keywordtype}{int} Two\_>
00038 \textcolor{keyword}{struct }Symmetry
00039 \{
00040   static\_assert(One\_ != Two\_, \textcolor{stringliteral}{"Symmetries must cover distinct indices."});
00041   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} One = One\_;
00042   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} Two = Two\_;
00043   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} Flags = 0;
00044 \};
00045 
00046 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} One\_, \textcolor{keywordtype}{int} Two\_>
00047 \textcolor{keyword}{struct }AntiSymmetry
00048 \{
00049   static\_assert(One\_ != Two\_, \textcolor{stringliteral}{"Symmetries must cover distinct indices."});
00050   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} One = One\_;
00051   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} Two = Two\_;
00052   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} Flags = NegationFlag;
00053 \};
00054 
00055 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} One\_, \textcolor{keywordtype}{int} Two\_>
00056 \textcolor{keyword}{struct }Hermiticity
00057 \{
00058   static\_assert(One\_ != Two\_, \textcolor{stringliteral}{"Symmetries must cover distinct indices."});
00059   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} One = One\_;
00060   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} Two = Two\_;
00061   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} Flags = ConjugationFlag;
00062 \};
00063 
00064 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} One\_, \textcolor{keywordtype}{int} Two\_>
00065 \textcolor{keyword}{struct }AntiHermiticity
00066 \{
00067   static\_assert(One\_ != Two\_, \textcolor{stringliteral}{"Symmetries must cover distinct indices."});
00068   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} One = One\_;
00069   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} Two = Two\_;
00070   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} Flags = ConjugationFlag | NegationFlag;
00071 \};
00072 
00086 \textcolor{keyword}{class }DynamicSGroup;
00087 
00098 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Gen>
00099 \textcolor{keyword}{class }DynamicSGroupFromTemplateArgs;
00100 
00120 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Gen>
00121 \textcolor{keyword}{class }StaticSGroup;
00122 
00135 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Gen>
00136 \textcolor{keyword}{class }SGroup : \textcolor{keyword}{public} internal::tensor\_symmetry\_pre\_analysis<internal::tensor\_symmetry\_num\_indices<Gen...>:
      :value, Gen...>::root\_type
00137 \{
00138   \textcolor{keyword}{public}:
00139     constexpr \textcolor{keyword}{static} std::size\_t NumIndices = internal::tensor\_symmetry\_num\_indices<Gen...>::value;
00140     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::tensor\_symmetry\_pre\_analysis<NumIndices, Gen...>::root\_type Base;
00141 
00142     \textcolor{comment}{// make standard constructors + assignment operators public}
00143     \textcolor{keyword}{inline} SGroup() : Base() \{ \}
00144     \textcolor{keyword}{inline} SGroup(\textcolor{keyword}{const} SGroup<Gen...>& other) : Base(other) \{ \}
00145     \textcolor{keyword}{inline} SGroup(SGroup<Gen...>&& other) : Base(other) \{ \}
00146     \textcolor{keyword}{inline} SGroup<Gen...>& operator=(\textcolor{keyword}{const} SGroup<Gen...>& other) \{ Base::operator=(other); \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}
00147     \textcolor{keyword}{inline} SGroup<Gen...>& operator=(SGroup<Gen...>&& other) \{ Base::operator=(other); \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}
00148 
00149     \textcolor{comment}{// all else is defined in the base class}
00150 \};
00151 
00152 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00153 
00154 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Sym> \textcolor{keyword}{struct }tensor\_symmetry\_num\_indices
00155 \{
00156   constexpr \textcolor{keyword}{static} std::size\_t value = 1;
00157 \};
00158 
00159 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} One\_, \textcolor{keywordtype}{int} Two\_, \textcolor{keyword}{typename}... Sym> \textcolor{keyword}{struct }tensor\_symmetry\_num\_indices<Symmetry<One\_, Two\_>, Sym.
      ..>
00160 \{
00161 \textcolor{keyword}{private}:
00162   constexpr \textcolor{keyword}{static} std::size\_t One = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(One\_);
00163   constexpr \textcolor{keyword}{static} std::size\_t Two = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(Two\_);
00164   constexpr \textcolor{keyword}{static} std::size\_t Three = tensor\_symmetry\_num\_indices<Sym...>::value;
00165 
00166   \textcolor{comment}{// don't use std::max, since it's not constexpr until C++14...}
00167   constexpr \textcolor{keyword}{static} std::size\_t maxOneTwoPlusOne = ((One > Two) ? One : Two) + 1;
00168 \textcolor{keyword}{public}:
00169   constexpr \textcolor{keyword}{static} std::size\_t value = (maxOneTwoPlusOne > Three) ? maxOneTwoPlusOne : Three;
00170 \};
00171 
00172 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} One\_, \textcolor{keywordtype}{int} Two\_, \textcolor{keyword}{typename}... Sym> \textcolor{keyword}{struct }tensor\_symmetry\_num\_indices<AntiSymmetry<One\_, Two\_>, 
      Sym...>
00173   : \textcolor{keyword}{public} tensor\_symmetry\_num\_indices<Symmetry<One\_, Two\_>, Sym...> \{\};
00174 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} One\_, \textcolor{keywordtype}{int} Two\_, \textcolor{keyword}{typename}... Sym> \textcolor{keyword}{struct }tensor\_symmetry\_num\_indices<Hermiticity<One\_, Two\_>, 
      Sym...>
00175   : \textcolor{keyword}{public} tensor\_symmetry\_num\_indices<Symmetry<One\_, Two\_>, Sym...> \{\};
00176 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} One\_, \textcolor{keywordtype}{int} Two\_, \textcolor{keyword}{typename}... Sym> \textcolor{keyword}{struct }tensor\_symmetry\_num\_indices<AntiHermiticity<One\_, Two\_
      >, Sym...>
00177   : \textcolor{keyword}{public} tensor\_symmetry\_num\_indices<Symmetry<One\_, Two\_>, Sym...> \{\};
00178 
00226 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} NumIndices>
00227 \textcolor{keyword}{struct }tensor\_symmetry\_pre\_analysis<NumIndices>
00228 \{
00229   \textcolor{keyword}{typedef} StaticSGroup<> root\_type;
00230 \};
00231 
00232 \textcolor{keyword}{template}<std::size\_t NumIndices, \textcolor{keyword}{typename} Gen\_, \textcolor{keyword}{typename}... Gens\_>
00233 \textcolor{keyword}{struct }tensor\_symmetry\_pre\_analysis<NumIndices, Gen\_, Gens\_...>
00234 \{
00235   constexpr \textcolor{keyword}{static} std::size\_t max\_static\_generators = 4;
00236   constexpr \textcolor{keyword}{static} std::size\_t max\_static\_elements = 16;
00237   \textcolor{keyword}{typedef} tensor\_static\_symgroup\_if<(\textcolor{keyword}{sizeof}...(Gens\_) + 1 <= max\_static\_generators), NumIndices, Gen\_, 
      Gens\_...> helper;
00238   constexpr \textcolor{keyword}{static} std::size\_t possible\_size = helper::size;
00239 
00240   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<
00241     possible\_size == 0 || possible\_size >= max\_static\_elements,
00242     DynamicSGroupFromTemplateArgs<Gen\_, Gens\_...>,
00243     \textcolor{keyword}{typename} helper::type
00244   >::type root\_type;
00245 \};
00246 
00247 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} instantiate, std::size\_t NumIndices, \textcolor{keyword}{typename}... Gens>
00248 \textcolor{keyword}{struct }tensor\_static\_symgroup\_if
00249 \{
00250   constexpr \textcolor{keyword}{static} std::size\_t size = 0;
00251   \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} type;
00252 \};
00253 
00254 \textcolor{keyword}{template}<std::size\_t NumIndices, \textcolor{keyword}{typename}... Gens>
00255 \textcolor{keyword}{struct }tensor\_static\_symgroup\_if<true, NumIndices, Gens...> : tensor\_static\_symgroup<NumIndices, Gens...> \{
      \};
00256 
00257 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Tensor\_>
00258 \textcolor{keyword}{struct }tensor\_symmetry\_assign\_value
00259 \{
00260   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Tensor\_::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00261   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Tensor\_::Scalar Scalar;
00262   constexpr \textcolor{keyword}{static} std::size\_t NumIndices = Tensor\_::NumIndices;
00263 
00264   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} run(\textcolor{keyword}{const} std::array<Index, NumIndices>& transformed\_indices, \textcolor{keywordtype}{int} transformation\_flags,
       \textcolor{keywordtype}{int} dummy, Tensor\_& tensor, \textcolor{keyword}{const} Scalar& value\_)
00265   \{
00266     Scalar value(value\_);
00267     \textcolor{keywordflow}{if} (transformation\_flags & ConjugationFlag)
00268       value = numext::conj(value);
00269     \textcolor{keywordflow}{if} (transformation\_flags & NegationFlag)
00270       value = -value;
00271     tensor.coeffRef(transformed\_indices) = value;
00272     \textcolor{keywordflow}{return} dummy;
00273   \}
00274 \};
00275 
00276 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Tensor\_>
00277 \textcolor{keyword}{struct }tensor\_symmetry\_calculate\_flags
00278 \{
00279   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Tensor\_::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00280   constexpr \textcolor{keyword}{static} std::size\_t NumIndices = Tensor\_::NumIndices;
00281 
00282   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} run(\textcolor{keyword}{const} std::array<Index, NumIndices>& transformed\_indices, \textcolor{keywordtype}{int} transform\_flags, \textcolor{keywordtype}{int} 
      current\_flags, \textcolor{keyword}{const} std::array<Index, NumIndices>& orig\_indices)
00283   \{
00284     \textcolor{keywordflow}{if} (transformed\_indices == orig\_indices) \{
00285       \textcolor{keywordflow}{if} (transform\_flags & (ConjugationFlag | NegationFlag))
00286         \textcolor{keywordflow}{return} current\_flags | GlobalImagFlag; \textcolor{comment}{// anti-hermitian diagonal}
00287       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (transform\_flags & ConjugationFlag)
00288         \textcolor{keywordflow}{return} current\_flags | GlobalRealFlag; \textcolor{comment}{// hermitian diagonal}
00289       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (transform\_flags & NegationFlag)
00290         \textcolor{keywordflow}{return} current\_flags | GlobalZeroFlag; \textcolor{comment}{// anti-symmetric diagonal}
00291     \}
00292     \textcolor{keywordflow}{return} current\_flags;
00293   \}
00294 \};
00295 
00296 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Tensor\_, \textcolor{keyword}{typename} Symmetry\_, \textcolor{keywordtype}{int} Flags = 0>
00297 \textcolor{keyword}{class }tensor\_symmetry\_value\_setter
00298 \{
00299   \textcolor{keyword}{public}:
00300     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Tensor\_::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00301     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Tensor\_::Scalar Scalar;
00302     constexpr \textcolor{keyword}{static} std::size\_t NumIndices = Tensor\_::NumIndices;
00303 
00304     \textcolor{keyword}{inline} tensor\_symmetry\_value\_setter(Tensor\_& tensor, Symmetry\_ \textcolor{keyword}{const}& symmetry, std::array<Index,
       NumIndices> \textcolor{keyword}{const}& indices)
00305       : m\_tensor(tensor), m\_symmetry(symmetry), m\_indices(indices) \{ \}
00306 
00307     \textcolor{keyword}{inline} tensor\_symmetry\_value\_setter<Tensor\_, Symmetry\_, Flags>& operator=(Scalar \textcolor{keyword}{const}& value)
00308     \{
00309       doAssign(value);
00310       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00311     \}
00312   \textcolor{keyword}{private}:
00313     Tensor\_& m\_tensor;
00314     Symmetry\_ m\_symmetry;
00315     std::array<Index, NumIndices> m\_indices;
00316 
00317     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} doAssign(Scalar \textcolor{keyword}{const}& value)
00318     \{
00319 \textcolor{preprocessor}{      #ifdef EIGEN\_TENSOR\_SYMMETRY\_CHECK\_VALUES}
00320         \textcolor{keywordtype}{int} value\_flags = m\_symmetry.template apply<internal::tensor\_symmetry\_calculate\_flags<Tensor\_>, \textcolor{keywordtype}{int}
      >(m\_indices, m\_symmetry.globalFlags(), m\_indices);
00321         \textcolor{keywordflow}{if} (value\_flags & GlobalRealFlag)
00322           eigen\_assert(numext::imag(value) == 0);
00323         \textcolor{keywordflow}{if} (value\_flags & GlobalImagFlag)
00324           eigen\_assert(numext::real(value) == 0);
00325 \textcolor{preprocessor}{      #endif}
00326       m\_symmetry.template apply<internal::tensor\_symmetry\_assign\_value<Tensor\_>, \textcolor{keywordtype}{int}>(m\_indices, 0, 
      m\_tensor, value);
00327     \}
00328 \};
00329 
00330 \} \textcolor{comment}{// end namespace internal}
00331 
00332 \} \textcolor{comment}{// end namespace Eigen}
00333 
00334 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSORSYMMETRY\_SYMMETRY\_H}
00335 
00336 \textcolor{comment}{/*}
00337 \textcolor{comment}{ * kate: space-indent on; indent-width 2; mixedindent off; indent-mode cstyle;}
00338 \textcolor{comment}{ */}
\end{DoxyCode}
