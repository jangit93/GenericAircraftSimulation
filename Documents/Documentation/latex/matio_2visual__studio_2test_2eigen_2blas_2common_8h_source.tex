\hypertarget{matio_2visual__studio_2test_2eigen_2blas_2common_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/blas/common.h}
\label{matio_2visual__studio_2test_2eigen_2blas_2common_8h_source}\index{common.\+h@{common.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_BLAS\_COMMON\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_BLAS\_COMMON\_H}
00012 
00013 \textcolor{preprocessor}{#include "../Eigen/Core"}
00014 \textcolor{preprocessor}{#include "../Eigen/Jacobi"}
00015 
00016 \textcolor{preprocessor}{#include <complex>}
00017 
00018 \textcolor{preprocessor}{#ifndef SCALAR}
00019 \textcolor{preprocessor}{#error the token SCALAR must be defined to compile this file}
00020 \textcolor{preprocessor}{#endif}
00021 
00022 \textcolor{preprocessor}{#include "../Eigen/src/misc/blas.h"}
00023 
00024 \textcolor{preprocessor}{#define NOTR    0}
00025 \textcolor{preprocessor}{#define TR      1}
00026 \textcolor{preprocessor}{#define ADJ     2}
00027 
00028 \textcolor{preprocessor}{#define LEFT    0}
00029 \textcolor{preprocessor}{#define RIGHT   1}
00030 
00031 \textcolor{preprocessor}{#define UP      0}
00032 \textcolor{preprocessor}{#define LO      1}
00033 
00034 \textcolor{preprocessor}{#define NUNIT   0}
00035 \textcolor{preprocessor}{#define UNIT    1}
00036 
00037 \textcolor{preprocessor}{#define INVALID 0xff}
00038 
00039 \textcolor{preprocessor}{#define OP(X)   (   ((X)=='N' || (X)=='n') ? NOTR   \(\backslash\)}
00040 \textcolor{preprocessor}{                  : ((X)=='T' || (X)=='t') ? TR     \(\backslash\)}
00041 \textcolor{preprocessor}{                  : ((X)=='C' || (X)=='c') ? ADJ    \(\backslash\)}
00042 \textcolor{preprocessor}{                  : INVALID)}
00043 
00044 \textcolor{preprocessor}{#define SIDE(X) (   ((X)=='L' || (X)=='l') ? LEFT   \(\backslash\)}
00045 \textcolor{preprocessor}{                  : ((X)=='R' || (X)=='r') ? RIGHT  \(\backslash\)}
00046 \textcolor{preprocessor}{                  : INVALID)}
00047 
00048 \textcolor{preprocessor}{#define UPLO(X) (   ((X)=='U' || (X)=='u') ? UP     \(\backslash\)}
00049 \textcolor{preprocessor}{                  : ((X)=='L' || (X)=='l') ? LO     \(\backslash\)}
00050 \textcolor{preprocessor}{                  : INVALID)}
00051 
00052 \textcolor{preprocessor}{#define DIAG(X) (   ((X)=='N' || (X)=='n') ? NUNIT  \(\backslash\)}
00053 \textcolor{preprocessor}{                  : ((X)=='U' || (X)=='u') ? UNIT   \(\backslash\)}
00054 \textcolor{preprocessor}{                  : INVALID)}
00055 
00056 
00057 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} check\_op(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* op)
00058 \{
00059   \textcolor{keywordflow}{return} OP(*op)!=0xff;
00060 \}
00061 
00062 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} check\_side(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* side)
00063 \{
00064   \textcolor{keywordflow}{return} SIDE(*side)!=0xff;
00065 \}
00066 
00067 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} check\_uplo(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* uplo)
00068 \{
00069   \textcolor{keywordflow}{return} UPLO(*uplo)!=0xff;
00070 \}
00071 
00072 
00073 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00074 \textcolor{preprocessor}{#include "BandTriangularSolver.h"}
00075 \textcolor{preprocessor}{#include "GeneralRank1Update.h"}
00076 \textcolor{preprocessor}{#include "PackedSelfadjointProduct.h"}
00077 \textcolor{preprocessor}{#include "PackedTriangularMatrixVector.h"}
00078 \textcolor{preprocessor}{#include "PackedTriangularSolverVector.h"}
00079 \textcolor{preprocessor}{#include "Rank2Update.h"}
00080 \}
00081 
00082 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00083 
00084 \textcolor{keyword}{typedef} SCALAR Scalar;
00085 \textcolor{keyword}{typedef} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00086 \textcolor{keyword}{typedef} std::complex<RealScalar> Complex;
00087 
00088 \textcolor{keyword}{enum}
00089 \{
00090   IsComplex = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{Eigen::NumTraits<SCALAR>::IsComplex},
00091   Conj = IsComplex
00092 \};
00093 
00094 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Dynamic,Dynamic,ColMajor>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{PlainMatrixType};
00095 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<Scalar,Dynamic,Dynamic,ColMajor>}, 0, 
      \hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>} > MatrixType;
00096 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Matrix<Scalar,Dynamic,Dynamic,ColMajor>},
       0, \hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>} > \hyperlink{group___core___module_class_eigen_1_1_map}{ConstMatrixType};
00097 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<Scalar,Dynamic,1>}, 0, 
      \hyperlink{class_eigen_1_1_inner_stride}{InnerStride<Dynamic>} > \hyperlink{group___core___module_class_eigen_1_1_map}{StridedVectorType};
00098 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<Scalar,Dynamic,1>} > 
      \hyperlink{group___core___module_class_eigen_1_1_map}{CompactVectorType};
00099 
00100 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00101 \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<T,Dynamic,Dynamic,ColMajor>}, 0, 
      \hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>} >
00102 matrix(\hyperlink{group___sparse_core___module}{T}* data, \textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int} cols, \textcolor{keywordtype}{int} stride)
00103 \{
00104   \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<T,Dynamic,Dynamic,ColMajor>}, 0, 
      \hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>} >(data, rows, cols, \hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>}(stride));
00105 \}
00106 
00107 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00108 \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Matrix<T,Dynamic,Dynamic,ColMajor>}, 0, 
      \hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>} >
00109 matrix(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}* data, \textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int} cols, \textcolor{keywordtype}{int} stride)
00110 \{
00111   \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Matrix<T,Dynamic,Dynamic,ColMajor>}, 0, 
      \hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>} >(data, rows, cols, \hyperlink{class_eigen_1_1_outer_stride}{OuterStride<>}(stride));
00112 \}
00113 
00114 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00115 \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<T,Dynamic,1>}, 0, \hyperlink{class_eigen_1_1_inner_stride}{InnerStride<Dynamic>} > make\_vector(
      \hyperlink{group___sparse_core___module}{T}* data, \textcolor{keywordtype}{int} size, \textcolor{keywordtype}{int} incr)
00116 \{
00117   \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<T,Dynamic,1>}, 0, \hyperlink{class_eigen_1_1_inner_stride}{InnerStride<Dynamic>} >(data
      , size, \hyperlink{class_eigen_1_1_inner_stride}{InnerStride<Dynamic>}(incr));
00118 \}
00119 
00120 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00121 \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Matrix<T,Dynamic,1>}, 0, 
      \hyperlink{class_eigen_1_1_inner_stride}{InnerStride<Dynamic>} > make\_vector(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}* data, \textcolor{keywordtype}{int} size, \textcolor{keywordtype}{int} incr)
00122 \{
00123   \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Matrix<T,Dynamic,1>}, 0, 
      \hyperlink{class_eigen_1_1_inner_stride}{InnerStride<Dynamic>} >(data, size, \hyperlink{class_eigen_1_1_inner_stride}{InnerStride<Dynamic>}(incr));
00124 \}
00125 
00126 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00127 \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<T,Dynamic,1>} > make\_vector(\hyperlink{group___sparse_core___module}{T}* data, \textcolor{keywordtype}{int} size)
00128 \{
00129   \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<T,Dynamic,1>} >(data, size);
00130 \}
00131 
00132 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00133 \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Matrix<T,Dynamic,1>} > make\_vector(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}* data, \textcolor{keywordtype}{int} size)
00134 \{
00135   \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Matrix<T,Dynamic,1>} >(data, size);
00136 \}
00137 
00138 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00139 \hyperlink{group___sparse_core___module}{T}* get\_compact\_vector(\hyperlink{group___sparse_core___module}{T}* x, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} incx)
00140 \{
00141   \textcolor{keywordflow}{if}(incx==1)
00142     \textcolor{keywordflow}{return} x;
00143 
00144   \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::internal::remove\_const<T>::type}* ret = \textcolor{keyword}{new} Scalar[n
      ];
00145   \textcolor{keywordflow}{if}(incx<0) make\_vector(ret,n) = make\_vector(x,n,-incx).reverse();
00146   \textcolor{keywordflow}{else}       make\_vector(ret,n) = make\_vector(x,n, incx);
00147   \textcolor{keywordflow}{return} ret;
00148 \}
00149 
00150 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00151 \hyperlink{group___sparse_core___module}{T}* copy\_back(\hyperlink{group___sparse_core___module}{T}* x\_cpy, \hyperlink{group___sparse_core___module}{T}* x, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} incx)
00152 \{
00153   \textcolor{keywordflow}{if}(x\_cpy==x)
00154     \textcolor{keywordflow}{return} 0;
00155 
00156   \textcolor{keywordflow}{if}(incx<0) make\_vector(x,n,-incx).reverse() = make\_vector(x\_cpy,n);
00157   \textcolor{keywordflow}{else}       make\_vector(x,n, incx)           = make\_vector(x\_cpy,n);
00158   \textcolor{keywordflow}{return} x\_cpy;
00159 \}
00160 
00161 \textcolor{preprocessor}{#define EIGEN\_BLAS\_FUNC(X) EIGEN\_CAT(SCALAR\_SUFFIX,X##\_)}
00162 
00163 \textcolor{preprocessor}{#endif // EIGEN\_BLAS\_COMMON\_H}
\end{DoxyCode}
