\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_non_linear_optimization_2_l_mpar_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+Non\+Linear\+Optimization/\+L\+Mpar.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_non_linear_optimization_2_l_mpar_8h_source}\index{lmpar.\+h@{lmpar.\+h}}

\begin{DoxyCode}
00001 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00002 
00003 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00004 
00005 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00006 \textcolor{keywordtype}{void} lmpar(
00007         \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, Dynamic >} &r,
00008         \textcolor{keyword}{const} VectorXi &ipvt,
00009         \textcolor{keyword}{const} \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  &diag,
00010         \textcolor{keyword}{const} \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  &qtb,
00011         Scalar delta,
00012         Scalar &par,
00013         \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  &x)
00014 \{
00015     \textcolor{keyword}{using} std::abs;
00016     \textcolor{keyword}{using} std::sqrt;
00017     \textcolor{keyword}{typedef} DenseIndex \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00018 
00019     \textcolor{comment}{/* Local variables */}
00020     Index i, j, l;
00021     Scalar fp;
00022     Scalar parc, parl;
00023     Index iter;
00024     Scalar temp, paru;
00025     Scalar gnorm;
00026     Scalar dxnorm;
00027 
00028 
00029     \textcolor{comment}{/* Function Body */}
00030     \textcolor{keyword}{const} Scalar dwarf = (std::numeric\_limits<Scalar>::min)();
00031     \textcolor{keyword}{const} Index n = r.cols();
00032     eigen\_assert(n==diag.size());
00033     eigen\_assert(n==qtb.size());
00034     eigen\_assert(n==x.size());
00035 
00036     \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  wa1, wa2;
00037 
00038     \textcolor{comment}{/* compute and store in x the gauss-newton direction. if the */}
00039     \textcolor{comment}{/* jacobian is rank-deficient, obtain a least squares solution. */}
00040     Index nsing = n-1;
00041     wa1 = qtb;
00042     \textcolor{keywordflow}{for} (j = 0; j < n; ++j) \{
00043         \textcolor{keywordflow}{if} (r(j,j) == 0. && nsing == n-1)
00044             nsing = j - 1;
00045         \textcolor{keywordflow}{if} (nsing < n-1)
00046             wa1[j] = 0.;
00047     \}
00048     \textcolor{keywordflow}{for} (j = nsing; j>=0; --j) \{
00049         wa1[j] /= r(j,j);
00050         temp = wa1[j];
00051         \textcolor{keywordflow}{for} (i = 0; i < j ; ++i)
00052             wa1[i] -= r(i,j) * temp;
00053     \}
00054 
00055     \textcolor{keywordflow}{for} (j = 0; j < n; ++j)
00056         x[ipvt[j]] = wa1[j];
00057 
00058     \textcolor{comment}{/* initialize the iteration counter. */}
00059     \textcolor{comment}{/* evaluate the function at the origin, and test */}
00060     \textcolor{comment}{/* for acceptance of the gauss-newton direction. */}
00061     iter = 0;
00062     wa2 = diag.cwiseProduct(x);
00063     dxnorm = wa2.blueNorm();
00064     fp = dxnorm - delta;
00065     \textcolor{keywordflow}{if} (fp <= Scalar(0.1) * delta) \{
00066         par = 0;
00067         \textcolor{keywordflow}{return};
00068     \}
00069 
00070     \textcolor{comment}{/* if the jacobian is not rank deficient, the newton */}
00071     \textcolor{comment}{/* step provides a lower bound, parl, for the zero of */}
00072     \textcolor{comment}{/* the function. otherwise set this bound to zero. */}
00073     parl = 0.;
00074     \textcolor{keywordflow}{if} (nsing >= n-1) \{
00075         \textcolor{keywordflow}{for} (j = 0; j < n; ++j) \{
00076             l = ipvt[j];
00077             wa1[j] = diag[l] * (wa2[l] / dxnorm);
00078         \}
00079         \textcolor{comment}{// it's actually a triangularView.solveInplace(), though in a weird}
00080         \textcolor{comment}{// way:}
00081         \textcolor{keywordflow}{for} (j = 0; j < n; ++j) \{
00082             Scalar sum = 0.;
00083             \textcolor{keywordflow}{for} (i = 0; i < j; ++i)
00084                 sum += r(i,j) * wa1[i];
00085             wa1[j] = (wa1[j] - sum) / r(j,j);
00086         \}
00087         temp = wa1.blueNorm();
00088         parl = fp / delta / temp / temp;
00089     \}
00090 
00091     \textcolor{comment}{/* calculate an upper bound, paru, for the zero of the function. */}
00092     \textcolor{keywordflow}{for} (j = 0; j < n; ++j)
00093         wa1[j] = r.col(j).head(j+1).dot(qtb.head(j+1)) / diag[ipvt[j]];
00094 
00095     gnorm = wa1.stableNorm();
00096     paru = gnorm / delta;
00097     \textcolor{keywordflow}{if} (paru == 0.)
00098         paru = dwarf / (std::min)(delta,Scalar(0.1));
00099 
00100     \textcolor{comment}{/* if the input par lies outside of the interval (parl,paru), */}
00101     \textcolor{comment}{/* set par to the closer endpoint. */}
00102     par = (std::max)(par,parl);
00103     par = (std::min)(par,paru);
00104     \textcolor{keywordflow}{if} (par == 0.)
00105         par = gnorm / dxnorm;
00106 
00107     \textcolor{comment}{/* beginning of an iteration. */}
00108     \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
00109         ++iter;
00110 
00111         \textcolor{comment}{/* evaluate the function at the current value of par. */}
00112         \textcolor{keywordflow}{if} (par == 0.)
00113             par = (std::max)(dwarf,Scalar(.001) * paru); \textcolor{comment}{/* Computing MAX */}
00114         wa1 = sqrt(par)* diag;
00115 
00116         \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >} sdiag(n);
00117         qrsolv<Scalar>(r, ipvt, wa1, qtb, x, sdiag);
00118 
00119         wa2 = diag.cwiseProduct(x);
00120         dxnorm = wa2.blueNorm();
00121         temp = fp;
00122         fp = dxnorm - delta;
00123 
00124         \textcolor{comment}{/* if the function is small enough, accept the current value */}
00125         \textcolor{comment}{/* of par. also test for the exceptional cases where parl */}
00126         \textcolor{comment}{/* is zero or the number of iterations has reached 10. */}
00127         \textcolor{keywordflow}{if} (abs(fp) <= Scalar(0.1) * delta || (parl == 0. && fp <= temp && temp < 0.) || iter == 10)
00128             \textcolor{keywordflow}{break};
00129 
00130         \textcolor{comment}{/* compute the newton correction. */}
00131         \textcolor{keywordflow}{for} (j = 0; j < n; ++j) \{
00132             l = ipvt[j];
00133             wa1[j] = diag[l] * (wa2[l] / dxnorm);
00134         \}
00135         \textcolor{keywordflow}{for} (j = 0; j < n; ++j) \{
00136             wa1[j] /= sdiag[j];
00137             temp = wa1[j];
00138             \textcolor{keywordflow}{for} (i = j+1; i < n; ++i)
00139                 wa1[i] -= r(i,j) * temp;
00140         \}
00141         temp = wa1.blueNorm();
00142         parc = fp / delta / temp / temp;
00143 
00144         \textcolor{comment}{/* depending on the sign of the function, update parl or paru. */}
00145         \textcolor{keywordflow}{if} (fp > 0.)
00146             parl = (std::max)(parl,par);
00147         \textcolor{keywordflow}{if} (fp < 0.)
00148             paru = (std::min)(paru,par);
00149 
00150         \textcolor{comment}{/* compute an improved estimate for par. */}
00151         \textcolor{comment}{/* Computing MAX */}
00152         par = (std::max)(parl,par+parc);
00153 
00154         \textcolor{comment}{/* end of an iteration. */}
00155     \}
00156 
00157     \textcolor{comment}{/* termination. */}
00158     \textcolor{keywordflow}{if} (iter == 0)
00159         par = 0.;
00160     \textcolor{keywordflow}{return};
00161 \}
00162 
00163 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00164 \textcolor{keywordtype}{void} lmpar2(
00165         \textcolor{keyword}{const} ColPivHouseholderQR<Matrix< Scalar, Dynamic, Dynamic> > &qr,
00166         \textcolor{keyword}{const} \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  &diag,
00167         \textcolor{keyword}{const} \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  &qtb,
00168         Scalar delta,
00169         Scalar &par,
00170         \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  &x)
00171 
00172 \{
00173     \textcolor{keyword}{using} std::sqrt;
00174     \textcolor{keyword}{using} std::abs;
00175     \textcolor{keyword}{typedef} DenseIndex \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00176 
00177     \textcolor{comment}{/* Local variables */}
00178     Index j;
00179     Scalar fp;
00180     Scalar parc, parl;
00181     Index iter;
00182     Scalar temp, paru;
00183     Scalar gnorm;
00184     Scalar dxnorm;
00185 
00186 
00187     \textcolor{comment}{/* Function Body */}
00188     \textcolor{keyword}{const} Scalar dwarf = (std::numeric\_limits<Scalar>::min)();
00189     \textcolor{keyword}{const} Index n = qr.matrixQR().cols();
00190     eigen\_assert(n==diag.size());
00191     eigen\_assert(n==qtb.size());
00192 
00193     \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  wa1, wa2;
00194 
00195     \textcolor{comment}{/* compute and store in x the gauss-newton direction. if the */}
00196     \textcolor{comment}{/* jacobian is rank-deficient, obtain a least squares solution. */}
00197 
00198 \textcolor{comment}{//    const Index rank = qr.nonzeroPivots(); // exactly double(0.)}
00199     \textcolor{keyword}{const} Index rank = qr.rank(); \textcolor{comment}{// use a threshold}
00200     wa1 = qtb;
00201     wa1.tail(n-rank).\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00202     qr.matrixQR().topLeftCorner(rank, rank).template triangularView<Upper>().solveInPlace(wa1.head(rank));
00203 
00204     x = qr.colsPermutation()*wa1;
00205 
00206     \textcolor{comment}{/* initialize the iteration counter. */}
00207     \textcolor{comment}{/* evaluate the function at the origin, and test */}
00208     \textcolor{comment}{/* for acceptance of the gauss-newton direction. */}
00209     iter = 0;
00210     wa2 = diag.cwiseProduct(x);
00211     dxnorm = wa2.blueNorm();
00212     fp = dxnorm - delta;
00213     \textcolor{keywordflow}{if} (fp <= Scalar(0.1) * delta) \{
00214         par = 0;
00215         \textcolor{keywordflow}{return};
00216     \}
00217 
00218     \textcolor{comment}{/* if the jacobian is not rank deficient, the newton */}
00219     \textcolor{comment}{/* step provides a lower bound, parl, for the zero of */}
00220     \textcolor{comment}{/* the function. otherwise set this bound to zero. */}
00221     parl = 0.;
00222     \textcolor{keywordflow}{if} (rank==n) \{
00223         wa1 = qr.colsPermutation().inverse() *  diag.cwiseProduct(wa2)/dxnorm;
00224         qr.matrixQR().topLeftCorner(n, n).transpose().template triangularView<Lower>().solveInPlace(wa1);
00225         temp = wa1.blueNorm();
00226         parl = fp / delta / temp / temp;
00227     \}
00228 
00229     \textcolor{comment}{/* calculate an upper bound, paru, for the zero of the function. */}
00230     \textcolor{keywordflow}{for} (j = 0; j < n; ++j)
00231         wa1[j] = qr.matrixQR().col(j).head(j+1).dot(qtb.head(j+1)) / diag[qr.colsPermutation().indices()(j)
      ];
00232 
00233     gnorm = wa1.stableNorm();
00234     paru = gnorm / delta;
00235     \textcolor{keywordflow}{if} (paru == 0.)
00236         paru = dwarf / (std::min)(delta,Scalar(0.1));
00237 
00238     \textcolor{comment}{/* if the input par lies outside of the interval (parl,paru), */}
00239     \textcolor{comment}{/* set par to the closer endpoint. */}
00240     par = (std::max)(par,parl);
00241     par = (std::min)(par,paru);
00242     \textcolor{keywordflow}{if} (par == 0.)
00243         par = gnorm / dxnorm;
00244 
00245     \textcolor{comment}{/* beginning of an iteration. */}
00246     \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, Dynamic >} s = qr.matrixQR();
00247     \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
00248         ++iter;
00249 
00250         \textcolor{comment}{/* evaluate the function at the current value of par. */}
00251         \textcolor{keywordflow}{if} (par == 0.)
00252             par = (std::max)(dwarf,Scalar(.001) * paru); \textcolor{comment}{/* Computing MAX */}
00253         wa1 = sqrt(par)* diag;
00254 
00255         \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >} sdiag(n);
00256         qrsolv<Scalar>(s, qr.colsPermutation().indices(), wa1, qtb, x, sdiag);
00257 
00258         wa2 = diag.cwiseProduct(x);
00259         dxnorm = wa2.blueNorm();
00260         temp = fp;
00261         fp = dxnorm - delta;
00262 
00263         \textcolor{comment}{/* if the function is small enough, accept the current value */}
00264         \textcolor{comment}{/* of par. also test for the exceptional cases where parl */}
00265         \textcolor{comment}{/* is zero or the number of iterations has reached 10. */}
00266         \textcolor{keywordflow}{if} (abs(fp) <= Scalar(0.1) * delta || (parl == 0. && fp <= temp && temp < 0.) || iter == 10)
00267             \textcolor{keywordflow}{break};
00268 
00269         \textcolor{comment}{/* compute the newton correction. */}
00270         wa1 = qr.colsPermutation().inverse() * diag.cwiseProduct(wa2/dxnorm);
00271         \textcolor{comment}{// we could almost use this here, but the diagonal is outside qr, in sdiag[]}
00272         \textcolor{comment}{// qr.matrixQR().topLeftCorner(n, n).transpose().template
       triangularView<Lower>().solveInPlace(wa1);}
00273         \textcolor{keywordflow}{for} (j = 0; j < n; ++j) \{
00274             wa1[j] /= sdiag[j];
00275             temp = wa1[j];
00276             \textcolor{keywordflow}{for} (Index i = j+1; i < n; ++i)
00277                 wa1[i] -= s(i,j) * temp;
00278         \}
00279         temp = wa1.blueNorm();
00280         parc = fp / delta / temp / temp;
00281 
00282         \textcolor{comment}{/* depending on the sign of the function, update parl or paru. */}
00283         \textcolor{keywordflow}{if} (fp > 0.)
00284             parl = (std::max)(parl,par);
00285         \textcolor{keywordflow}{if} (fp < 0.)
00286             paru = (std::min)(paru,par);
00287 
00288         \textcolor{comment}{/* compute an improved estimate for par. */}
00289         par = (std::max)(parl,par+parc);
00290     \}
00291     \textcolor{keywordflow}{if} (iter == 0)
00292         par = 0.;
00293     \textcolor{keywordflow}{return};
00294 \}
00295 
00296 \} \textcolor{comment}{// end namespace internal}
00297 
00298 \} \textcolor{comment}{// end namespace Eigen}
\end{DoxyCode}
