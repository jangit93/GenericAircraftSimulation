\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_ordering_methods_2_eigen___colamd_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Ordering\+Methods/\+Eigen\+\_\+\+Colamd.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_ordering_methods_2_eigen___colamd_8h_source}\index{Eigen\+\_\+\+Colamd.\+h@{Eigen\+\_\+\+Colamd.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// // This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Desire Nuentsa Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{comment}{// This file is modified from the colamd/symamd library. The copyright is below}
00011 
00012 \textcolor{comment}{//   The authors of the code itself are Stefan I. Larimore and Timothy A.}
00013 \textcolor{comment}{//   Davis (davis@cise.ufl.edu), University of Florida.  The algorithm was}
00014 \textcolor{comment}{//   developed in collaboration with John Gilbert, Xerox PARC, and Esmond}
00015 \textcolor{comment}{//   Ng, Oak Ridge National Laboratory.}
00016 \textcolor{comment}{// }
00017 \textcolor{comment}{//     Date:}
00018 \textcolor{comment}{// }
00019 \textcolor{comment}{//   September 8, 2003.  Version 2.3.}
00020 \textcolor{comment}{// }
00021 \textcolor{comment}{//     Acknowledgements:}
00022 \textcolor{comment}{// }
00023 \textcolor{comment}{//   This work was supported by the National Science Foundation, under}
00024 \textcolor{comment}{//   grants DMS-9504974 and DMS-9803599.}
00025 \textcolor{comment}{// }
00026 \textcolor{comment}{//     Notice:}
00027 \textcolor{comment}{// }
00028 \textcolor{comment}{//   Copyright (c) 1998-2003 by the University of Florida.}
00029 \textcolor{comment}{//   All Rights Reserved.}
00030 \textcolor{comment}{// }
00031 \textcolor{comment}{//   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY}
00032 \textcolor{comment}{//   EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.}
00033 \textcolor{comment}{// }
00034 \textcolor{comment}{//   Permission is hereby granted to use, copy, modify, and/or distribute}
00035 \textcolor{comment}{//   this program, provided that the Copyright, this License, and the}
00036 \textcolor{comment}{//   Availability of the original version is retained on all copies and made}
00037 \textcolor{comment}{//   accessible to the end-user of any code or package that includes COLAMD}
00038 \textcolor{comment}{//   or any modified version of COLAMD. }
00039 \textcolor{comment}{// }
00040 \textcolor{comment}{//     Availability:}
00041 \textcolor{comment}{// }
00042 \textcolor{comment}{//   The colamd/symamd library is available at}
00043 \textcolor{comment}{// }
00044 \textcolor{comment}{//       http://www.suitesparse.com}
00045 
00046   
00047 \textcolor{preprocessor}{#ifndef EIGEN\_COLAMD\_H}
00048 \textcolor{preprocessor}{#define EIGEN\_COLAMD\_H}
00049 
00050 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00051 \textcolor{comment}{/* Ensure that debugging is turned off: */}
00052 \textcolor{preprocessor}{#ifndef COLAMD\_NDEBUG}
00053 \textcolor{preprocessor}{#define COLAMD\_NDEBUG}
00054 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* NDEBUG */}\textcolor{preprocessor}{}
00055 \textcolor{comment}{/* ========================================================================== */}
00056 \textcolor{comment}{/* === Knob and statistics definitions ====================================== */}
00057 \textcolor{comment}{/* ========================================================================== */}
00058 
00059 \textcolor{comment}{/* size of the knobs [ ] array.  Only knobs [0..1] are currently used. */}
00060 \textcolor{preprocessor}{#define COLAMD\_KNOBS 20}
00061 
00062 \textcolor{comment}{/* number of output statistics.  Only stats [0..6] are currently used. */}
00063 \textcolor{preprocessor}{#define COLAMD\_STATS 20 }
00064 
00065 \textcolor{comment}{/* knobs [0] and stats [0]: dense row knob and output statistic. */}
00066 \textcolor{preprocessor}{#define COLAMD\_DENSE\_ROW 0}
00067 
00068 \textcolor{comment}{/* knobs [1] and stats [1]: dense column knob and output statistic. */}
00069 \textcolor{preprocessor}{#define COLAMD\_DENSE\_COL 1}
00070 
00071 \textcolor{comment}{/* stats [2]: memory defragmentation count output statistic */}
00072 \textcolor{preprocessor}{#define COLAMD\_DEFRAG\_COUNT 2}
00073 
00074 \textcolor{comment}{/* stats [3]: colamd status:  zero OK, > 0 warning or notice, < 0 error */}
00075 \textcolor{preprocessor}{#define COLAMD\_STATUS 3}
00076 
00077 \textcolor{comment}{/* stats [4..6]: error info, or info on jumbled columns */} 
00078 \textcolor{preprocessor}{#define COLAMD\_INFO1 4}
00079 \textcolor{preprocessor}{#define COLAMD\_INFO2 5}
00080 \textcolor{preprocessor}{#define COLAMD\_INFO3 6}
00081 
00082 \textcolor{comment}{/* error codes returned in stats [3]: */}
00083 \textcolor{preprocessor}{#define COLAMD\_OK       (0)}
00084 \textcolor{preprocessor}{#define COLAMD\_OK\_BUT\_JUMBLED     (1)}
00085 \textcolor{preprocessor}{#define COLAMD\_ERROR\_A\_not\_present    (-1)}
00086 \textcolor{preprocessor}{#define COLAMD\_ERROR\_p\_not\_present    (-2)}
00087 \textcolor{preprocessor}{#define COLAMD\_ERROR\_nrow\_negative    (-3)}
00088 \textcolor{preprocessor}{#define COLAMD\_ERROR\_ncol\_negative    (-4)}
00089 \textcolor{preprocessor}{#define COLAMD\_ERROR\_nnz\_negative   (-5)}
00090 \textcolor{preprocessor}{#define COLAMD\_ERROR\_p0\_nonzero     (-6)}
00091 \textcolor{preprocessor}{#define COLAMD\_ERROR\_A\_too\_small    (-7)}
00092 \textcolor{preprocessor}{#define COLAMD\_ERROR\_col\_length\_negative  (-8)}
00093 \textcolor{preprocessor}{#define COLAMD\_ERROR\_row\_index\_out\_of\_bounds  (-9)}
00094 \textcolor{preprocessor}{#define COLAMD\_ERROR\_out\_of\_memory    (-10)}
00095 \textcolor{preprocessor}{#define COLAMD\_ERROR\_internal\_error   (-999)}
00096 
00097 \textcolor{comment}{/* ========================================================================== */}
00098 \textcolor{comment}{/* === Definitions ========================================================== */}
00099 \textcolor{comment}{/* ========================================================================== */}
00100 
00101 \textcolor{preprocessor}{#define ONES\_COMPLEMENT(r) (-(r)-1)}
00102 
00103 \textcolor{comment}{/* -------------------------------------------------------------------------- */}
00104 
00105 \textcolor{preprocessor}{#define COLAMD\_EMPTY (-1)}
00106 
00107 \textcolor{comment}{/* Row and column status */}
00108 \textcolor{preprocessor}{#define ALIVE (0)}
00109 \textcolor{preprocessor}{#define DEAD  (-1)}
00110 
00111 \textcolor{comment}{/* Column status */}
00112 \textcolor{preprocessor}{#define DEAD\_PRINCIPAL    (-1)}
00113 \textcolor{preprocessor}{#define DEAD\_NON\_PRINCIPAL  (-2)}
00114 
00115 \textcolor{comment}{/* Macros for row and column status update and checking. */}
00116 \textcolor{preprocessor}{#define ROW\_IS\_DEAD(r)      ROW\_IS\_MARKED\_DEAD (Row[r].shared2.mark)}
00117 \textcolor{preprocessor}{#define ROW\_IS\_MARKED\_DEAD(row\_mark)  (row\_mark < ALIVE)}
00118 \textcolor{preprocessor}{#define ROW\_IS\_ALIVE(r)     (Row [r].shared2.mark >= ALIVE)}
00119 \textcolor{preprocessor}{#define COL\_IS\_DEAD(c)      (Col [c].start < ALIVE)}
00120 \textcolor{preprocessor}{#define COL\_IS\_ALIVE(c)     (Col [c].start >= ALIVE)}
00121 \textcolor{preprocessor}{#define COL\_IS\_DEAD\_PRINCIPAL(c)  (Col [c].start == DEAD\_PRINCIPAL)}
00122 \textcolor{preprocessor}{#define KILL\_ROW(r)     \{ Row [r].shared2.mark = DEAD ; \}}
00123 \textcolor{preprocessor}{#define KILL\_PRINCIPAL\_COL(c)   \{ Col [c].start = DEAD\_PRINCIPAL ; \}}
00124 \textcolor{preprocessor}{#define KILL\_NON\_PRINCIPAL\_COL(c) \{ Col [c].start = DEAD\_NON\_PRINCIPAL ; \}}
00125 
00126 \textcolor{comment}{/* ========================================================================== */}
00127 \textcolor{comment}{/* === Colamd reporting mechanism =========================================== */}
00128 \textcolor{comment}{/* ========================================================================== */}
00129 
00130 \textcolor{comment}{// == Row and Column structures ==}
00131 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00132 \textcolor{keyword}{struct }colamd\_col
00133 \{
00134   IndexType start ;   \textcolor{comment}{/* index for A of first row in this column, or DEAD */}
00135   \textcolor{comment}{/* if column is dead */}
00136   IndexType length ;  \textcolor{comment}{/* number of rows in this column */}
00137   \textcolor{keyword}{union}
00138   \{
00139     IndexType thickness ; \textcolor{comment}{/* number of original columns represented by this */}
00140     \textcolor{comment}{/* col, if the column is alive */}
00141     IndexType parent ;  \textcolor{comment}{/* parent in parent tree super-column structure, if */}
00142     \textcolor{comment}{/* the column is dead */}
00143   \} shared1 ;
00144   \textcolor{keyword}{union}
00145   \{
00146     IndexType score ; \textcolor{comment}{/* the score used to maintain heap, if col is alive */}
00147     IndexType order ; \textcolor{comment}{/* pivot ordering of this column, if col is dead */}
00148   \} shared2 ;
00149   \textcolor{keyword}{union}
00150   \{
00151     IndexType headhash ;  \textcolor{comment}{/* head of a hash bucket, if col is at the head of */}
00152     \textcolor{comment}{/* a degree list */}
00153     IndexType hash ;  \textcolor{comment}{/* hash value, if col is not in a degree list */}
00154     IndexType prev ;  \textcolor{comment}{/* previous column in degree list, if col is in a */}
00155     \textcolor{comment}{/* degree list (but not at the head of a degree list) */}
00156   \} shared3 ;
00157   \textcolor{keyword}{union}
00158   \{
00159     IndexType degree\_next ; \textcolor{comment}{/* next column, if col is in a degree list */}
00160     IndexType hash\_next ;   \textcolor{comment}{/* next column, if col is in a hash list */}
00161   \} shared4 ;
00162   
00163 \};
00164  
00165 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00166 \textcolor{keyword}{struct }Colamd\_Row
00167 \{
00168   IndexType start ;   \textcolor{comment}{/* index for A of first col in this row */}
00169   IndexType length ;  \textcolor{comment}{/* number of principal columns in this row */}
00170   \textcolor{keyword}{union}
00171   \{
00172     IndexType degree ;  \textcolor{comment}{/* number of principal & non-principal columns in row */}
00173     IndexType p ;   \textcolor{comment}{/* used as a row pointer in init\_rows\_cols () */}
00174   \} shared1 ;
00175   \textcolor{keyword}{union}
00176   \{
00177     IndexType mark ;  \textcolor{comment}{/* for computing set differences and marking dead rows*/}
00178     IndexType first\_column ;\textcolor{comment}{/* first column in row (used in garbage collection) */}
00179   \} shared2 ;
00180   
00181 \};
00182  
00183 \textcolor{comment}{/* ========================================================================== */}
00184 \textcolor{comment}{/* === Colamd recommended memory size ======================================= */}
00185 \textcolor{comment}{/* ========================================================================== */}
00186  
00187 \textcolor{comment}{/*}
00188 \textcolor{comment}{  The recommended length Alen of the array A passed to colamd is given by}
00189 \textcolor{comment}{  the COLAMD\_RECOMMENDED (nnz, n\_row, n\_col) macro.  It returns -1 if any}
00190 \textcolor{comment}{  argument is negative.  2*nnz space is required for the row and column}
00191 \textcolor{comment}{  indices of the matrix. colamd\_c (n\_col) + colamd\_r (n\_row) space is}
00192 \textcolor{comment}{  required for the Col and Row arrays, respectively, which are internal to}
00193 \textcolor{comment}{  colamd.  An additional n\_col space is the minimal amount of "elbow room",}
00194 \textcolor{comment}{  and nnz/5 more space is recommended for run time efficiency.}
00195 \textcolor{comment}{  }
00196 \textcolor{comment}{  This macro is not needed when using symamd.}
00197 \textcolor{comment}{  }
00198 \textcolor{comment}{  Explicit typecast to IndexType added Sept. 23, 2002, COLAMD version 2.2, to avoid}
00199 \textcolor{comment}{  gcc -pedantic warning messages.}
00200 \textcolor{comment}{*/}
00201 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00202 \textcolor{keyword}{inline} IndexType colamd\_c(IndexType n\_col) 
00203 \{ \textcolor{keywordflow}{return} IndexType( ((n\_col) + 1) * \textcolor{keyword}{sizeof} (colamd\_col<IndexType>) / \textcolor{keyword}{sizeof} (IndexType) ) ; \}
00204 
00205 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00206 \textcolor{keyword}{inline} IndexType  colamd\_r(IndexType n\_row)
00207 \{ \textcolor{keywordflow}{return} IndexType(((n\_row) + 1) * \textcolor{keyword}{sizeof} (Colamd\_Row<IndexType>) / \textcolor{keyword}{sizeof} (IndexType)); \}
00208 
00209 \textcolor{comment}{// Prototypes of non-user callable routines}
00210 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00211 \textcolor{keyword}{static} IndexType init\_rows\_cols (IndexType n\_row, IndexType n\_col, Colamd\_Row<IndexType> Row [], 
      colamd\_col<IndexType> col [], IndexType A [], IndexType p [], IndexType stats[COLAMD\_STATS] ); 
00212 
00213 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00214 \textcolor{keyword}{static} \textcolor{keywordtype}{void} init\_scoring (IndexType n\_row, IndexType n\_col, Colamd\_Row<IndexType> Row [], 
      colamd\_col<IndexType> Col [], IndexType A [], IndexType head [], \textcolor{keywordtype}{double} knobs[COLAMD\_KNOBS], IndexType *p\_n\_row2, IndexType *
      p\_n\_col2, IndexType *p\_max\_deg);
00215 
00216 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00217 \textcolor{keyword}{static} IndexType find\_ordering (IndexType n\_row, IndexType n\_col, IndexType Alen, Colamd\_Row<IndexType> Row
       [], colamd\_col<IndexType> Col [], IndexType A [], IndexType head [], IndexType n\_col2, IndexType max\_deg, 
      IndexType pfree);
00218 
00219 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00220 \textcolor{keyword}{static} \textcolor{keywordtype}{void} order\_children (IndexType n\_col, colamd\_col<IndexType> Col [], IndexType p []);
00221 
00222 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00223 \textcolor{keyword}{static} \textcolor{keywordtype}{void} detect\_super\_cols (colamd\_col<IndexType> Col [], IndexType A [], IndexType head [], IndexType 
      row\_start, IndexType row\_length ) ;
00224 
00225 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00226 \textcolor{keyword}{static} IndexType garbage\_collection (IndexType n\_row, IndexType n\_col, Colamd\_Row<IndexType> Row [], 
      colamd\_col<IndexType> Col [], IndexType A [], IndexType *pfree) ;
00227 
00228 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00229 \textcolor{keyword}{static} \textcolor{keyword}{inline}  IndexType clear\_mark (IndexType n\_row, Colamd\_Row<IndexType> Row [] ) ;
00230 
00231 \textcolor{comment}{/* === No debugging ========================================================= */}
00232 
00233 \textcolor{preprocessor}{#define COLAMD\_DEBUG0(params) ;}
00234 \textcolor{preprocessor}{#define COLAMD\_DEBUG1(params) ;}
00235 \textcolor{preprocessor}{#define COLAMD\_DEBUG2(params) ;}
00236 \textcolor{preprocessor}{#define COLAMD\_DEBUG3(params) ;}
00237 \textcolor{preprocessor}{#define COLAMD\_DEBUG4(params) ;}
00238 
00239 \textcolor{preprocessor}{#define COLAMD\_ASSERT(expression) ((void) 0)}
00240 
00241 
00256 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00257 \textcolor{keyword}{inline} IndexType colamd\_recommended ( IndexType nnz, IndexType n\_row, IndexType n\_col)
00258 \{
00259   \textcolor{keywordflow}{if} ((nnz) < 0 || (n\_row) < 0 || (n\_col) < 0)
00260     \textcolor{keywordflow}{return} (-1);
00261   \textcolor{keywordflow}{else}
00262     \textcolor{keywordflow}{return} (2 * (nnz) + colamd\_c (n\_col) + colamd\_r (n\_row) + (n\_col) + ((nnz) / 5)); 
00263 \}
00264 
00286 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} colamd\_set\_defaults(\textcolor{keywordtype}{double} knobs[COLAMD\_KNOBS])
00287 \{
00288   \textcolor{comment}{/* === Local variables ================================================== */}
00289   
00290   \textcolor{keywordtype}{int} i ;
00291 
00292   \textcolor{keywordflow}{if} (!knobs)
00293   \{
00294     return ;      \textcolor{comment}{/* no knobs to initialize */}
00295   \}
00296   \textcolor{keywordflow}{for} (i = 0 ; i < COLAMD\_KNOBS ; i++)
00297   \{
00298     knobs [i] = 0 ;
00299   \}
00300   knobs [COLAMD\_DENSE\_ROW] = 0.5 ;  \textcolor{comment}{/* ignore rows over 50% dense */}
00301   knobs [COLAMD\_DENSE\_COL] = 0.5 ;  \textcolor{comment}{/* ignore columns over 50% dense */}
00302 \}
00303 
00321 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00322 \textcolor{keyword}{static} \textcolor{keywordtype}{bool} colamd(IndexType n\_row, IndexType n\_col, IndexType Alen, IndexType *A, IndexType *p, \textcolor{keywordtype}{double} 
      knobs[COLAMD\_KNOBS], IndexType stats[COLAMD\_STATS])
00323 \{
00324   \textcolor{comment}{/* === Local variables ================================================== */}
00325   
00326   IndexType i ;     \textcolor{comment}{/* loop index */}
00327   IndexType nnz ;     \textcolor{comment}{/* nonzeros in A */}
00328   IndexType Row\_size ;    \textcolor{comment}{/* size of Row [], in integers */}
00329   IndexType Col\_size ;    \textcolor{comment}{/* size of Col [], in integers */}
00330   IndexType need ;      \textcolor{comment}{/* minimum required length of A */}
00331   Colamd\_Row<IndexType> *Row ;   \textcolor{comment}{/* pointer into A of Row [0..n\_row] array */}
00332   colamd\_col<IndexType> *Col ;   \textcolor{comment}{/* pointer into A of Col [0..n\_col] array */}
00333   IndexType n\_col2 ;    \textcolor{comment}{/* number of non-dense, non-empty columns */}
00334   IndexType n\_row2 ;    \textcolor{comment}{/* number of non-dense, non-empty rows */}
00335   IndexType ngarbage ;    \textcolor{comment}{/* number of garbage collections performed */}
00336   IndexType max\_deg ;   \textcolor{comment}{/* maximum row degree */}
00337   \textcolor{keywordtype}{double} default\_knobs [COLAMD\_KNOBS] ; \textcolor{comment}{/* default knobs array */}
00338   
00339   
00340   \textcolor{comment}{/* === Check the input arguments ======================================== */}
00341   
00342   \textcolor{keywordflow}{if} (!stats)
00343   \{
00344     COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: stats not present\(\backslash\)n"})) ;
00345     \textcolor{keywordflow}{return} (\textcolor{keyword}{false}) ;
00346   \}
00347   \textcolor{keywordflow}{for} (i = 0 ; i < COLAMD\_STATS ; i++)
00348   \{
00349     stats [i] = 0 ;
00350   \}
00351   stats [COLAMD\_STATUS] = COLAMD\_OK ;
00352   stats [COLAMD\_INFO1] = -1 ;
00353   stats [COLAMD\_INFO2] = -1 ;
00354   
00355   \textcolor{keywordflow}{if} (!A)   \textcolor{comment}{/* A is not present */}
00356   \{
00357     stats [COLAMD\_STATUS] = COLAMD\_ERROR\_A\_not\_present ;
00358     COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: A not present\(\backslash\)n"})) ;
00359     \textcolor{keywordflow}{return} (\textcolor{keyword}{false}) ;
00360   \}
00361   
00362   \textcolor{keywordflow}{if} (!p)   \textcolor{comment}{/* p is not present */}
00363   \{
00364     stats [COLAMD\_STATUS] = COLAMD\_ERROR\_p\_not\_present ;
00365     COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: p not present\(\backslash\)n"})) ;
00366     \textcolor{keywordflow}{return} (\textcolor{keyword}{false}) ;
00367   \}
00368   
00369   \textcolor{keywordflow}{if} (n\_row < 0)  \textcolor{comment}{/* n\_row must be >= 0 */}
00370   \{
00371     stats [COLAMD\_STATUS] = COLAMD\_ERROR\_nrow\_negative ;
00372     stats [COLAMD\_INFO1] = n\_row ;
00373     COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: nrow negative %d\(\backslash\)n"}, n\_row)) ;
00374     \textcolor{keywordflow}{return} (\textcolor{keyword}{false}) ;
00375   \}
00376   
00377   \textcolor{keywordflow}{if} (n\_col < 0)  \textcolor{comment}{/* n\_col must be >= 0 */}
00378   \{
00379     stats [COLAMD\_STATUS] = COLAMD\_ERROR\_ncol\_negative ;
00380     stats [COLAMD\_INFO1] = n\_col ;
00381     COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: ncol negative %d\(\backslash\)n"}, n\_col)) ;
00382     \textcolor{keywordflow}{return} (\textcolor{keyword}{false}) ;
00383   \}
00384   
00385   nnz = p [n\_col] ;
00386   \textcolor{keywordflow}{if} (nnz < 0)  \textcolor{comment}{/* nnz must be >= 0 */}
00387   \{
00388     stats [COLAMD\_STATUS] = COLAMD\_ERROR\_nnz\_negative ;
00389     stats [COLAMD\_INFO1] = nnz ;
00390     COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: number of entries negative %d\(\backslash\)n"}, nnz)) ;
00391     \textcolor{keywordflow}{return} (\textcolor{keyword}{false}) ;
00392   \}
00393   
00394   \textcolor{keywordflow}{if} (p [0] != 0)
00395   \{
00396     stats [COLAMD\_STATUS] = COLAMD\_ERROR\_p0\_nonzero ;
00397     stats [COLAMD\_INFO1] = p [0] ;
00398     COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: p[0] not zero %d\(\backslash\)n"}, p [0])) ;
00399     \textcolor{keywordflow}{return} (\textcolor{keyword}{false}) ;
00400   \}
00401   
00402   \textcolor{comment}{/* === If no knobs, set default knobs =================================== */}
00403   
00404   \textcolor{keywordflow}{if} (!knobs)
00405   \{
00406     colamd\_set\_defaults (default\_knobs) ;
00407     knobs = default\_knobs ;
00408   \}
00409   
00410   \textcolor{comment}{/* === Allocate the Row and Col arrays from array A ===================== */}
00411   
00412   Col\_size = colamd\_c (n\_col) ;
00413   Row\_size = colamd\_r (n\_row) ;
00414   need = 2*nnz + n\_col + Col\_size + Row\_size ;
00415   
00416   \textcolor{keywordflow}{if} (need > Alen)
00417   \{
00418     \textcolor{comment}{/* not enough space in array A to perform the ordering */}
00419     stats [COLAMD\_STATUS] = COLAMD\_ERROR\_A\_too\_small ;
00420     stats [COLAMD\_INFO1] = need ;
00421     stats [COLAMD\_INFO2] = Alen ;
00422     COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: Need Alen >= %d, given only Alen = %d\(\backslash\)n"}, need,Alen));
00423     \textcolor{keywordflow}{return} (\textcolor{keyword}{false}) ;
00424   \}
00425   
00426   Alen -= Col\_size + Row\_size ;
00427   Col = (colamd\_col<IndexType> *) &A [Alen] ;
00428   Row = (Colamd\_Row<IndexType> *) &A [Alen + Col\_size] ;
00429 
00430   \textcolor{comment}{/* === Construct the row and column data structures ===================== */}
00431   
00432   \textcolor{keywordflow}{if} (!Eigen::internal::init\_rows\_cols (n\_row, n\_col, Row, Col, A, p, stats))
00433   \{
00434     \textcolor{comment}{/* input matrix is invalid */}
00435     COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: Matrix invalid\(\backslash\)n"})) ;
00436     \textcolor{keywordflow}{return} (\textcolor{keyword}{false}) ;
00437   \}
00438   
00439   \textcolor{comment}{/* === Initialize scores, kill dense rows/columns ======================= */}
00440 
00441   Eigen::internal::init\_scoring (n\_row, n\_col, Row, Col, A, p, knobs,
00442         &n\_row2, &n\_col2, &max\_deg) ;
00443   
00444   \textcolor{comment}{/* === Order the supercolumns =========================================== */}
00445   
00446   ngarbage = Eigen::internal::find\_ordering (n\_row, n\_col, Alen, Row, Col, A, p,
00447                 n\_col2, max\_deg, 2*nnz) ;
00448   
00449   \textcolor{comment}{/* === Order the non-principal columns ================================== */}
00450   
00451   Eigen::internal::order\_children (n\_col, Col, p) ;
00452   
00453   \textcolor{comment}{/* === Return statistics in stats ======================================= */}
00454   
00455   stats [COLAMD\_DENSE\_ROW] = n\_row - n\_row2 ;
00456   stats [COLAMD\_DENSE\_COL] = n\_col - n\_col2 ;
00457   stats [COLAMD\_DEFRAG\_COUNT] = ngarbage ;
00458   COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: done.\(\backslash\)n"})) ; 
00459   \textcolor{keywordflow}{return} (\textcolor{keyword}{true}) ;
00460 \}
00461 
00462 \textcolor{comment}{/* ========================================================================== */}
00463 \textcolor{comment}{/* === NON-USER-CALLABLE ROUTINES: ========================================== */}
00464 \textcolor{comment}{/* ========================================================================== */}
00465 
00466 \textcolor{comment}{/* There are no user-callable routines beyond this point in the file */}
00467 
00468 
00469 \textcolor{comment}{/* ========================================================================== */}
00470 \textcolor{comment}{/* === init\_rows\_cols ======================================================= */}
00471 \textcolor{comment}{/* ========================================================================== */}
00472 
00473 \textcolor{comment}{/*}
00474 \textcolor{comment}{  Takes the column form of the matrix in A and creates the row form of the}
00475 \textcolor{comment}{  matrix.  Also, row and column attributes are stored in the Col and Row}
00476 \textcolor{comment}{  structs.  If the columns are un-sorted or contain duplicate row indices,}
00477 \textcolor{comment}{  this routine will also sort and remove duplicate row indices from the}
00478 \textcolor{comment}{  column form of the matrix.  Returns false if the matrix is invalid,}
00479 \textcolor{comment}{  true otherwise.  Not user-callable.}
00480 \textcolor{comment}{*/}
00481 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00482 \textcolor{keyword}{static} IndexType init\_rows\_cols  \textcolor{comment}{/* returns true if OK, or false otherwise */}
00483   (
00484     \textcolor{comment}{/* === Parameters ======================================================= */}
00485 
00486     IndexType n\_row,      \textcolor{comment}{/* number of rows of A */}
00487     IndexType n\_col,      \textcolor{comment}{/* number of columns of A */}
00488     Colamd\_Row<IndexType> Row [],    \textcolor{comment}{/* of size n\_row+1 */}
00489     colamd\_col<IndexType> Col [],    \textcolor{comment}{/* of size n\_col+1 */}
00490     IndexType A [],     \textcolor{comment}{/* row indices of A, of size Alen */}
00491     IndexType p [],     \textcolor{comment}{/* pointers to columns in A, of size n\_col+1 */}
00492     IndexType stats [COLAMD\_STATS]  \textcolor{comment}{/* colamd statistics */} 
00493     )
00494 \{
00495   \textcolor{comment}{/* === Local variables ================================================== */}
00496 
00497   IndexType col ;     \textcolor{comment}{/* a column index */}
00498   IndexType row ;     \textcolor{comment}{/* a row index */}
00499   IndexType *cp ;     \textcolor{comment}{/* a column pointer */}
00500   IndexType *cp\_end ;   \textcolor{comment}{/* a pointer to the end of a column */}
00501   IndexType *rp ;     \textcolor{comment}{/* a row pointer */}
00502   IndexType *rp\_end ;   \textcolor{comment}{/* a pointer to the end of a row */}
00503   IndexType last\_row ;    \textcolor{comment}{/* previous row */}
00504 
00505   \textcolor{comment}{/* === Initialize columns, and check column pointers ==================== */}
00506 
00507   \textcolor{keywordflow}{for} (col = 0 ; col < n\_col ; col++)
00508   \{
00509     Col [col].start = p [col] ;
00510     Col [col].length = p [col+1] - p [col] ;
00511 
00512     \textcolor{keywordflow}{if} ((Col [col].length) < 0) \textcolor{comment}{// extra parentheses to work-around gcc bug 10200}
00513     \{
00514       \textcolor{comment}{/* column pointers must be non-decreasing */}
00515       stats [COLAMD\_STATUS] = COLAMD\_ERROR\_col\_length\_negative ;
00516       stats [COLAMD\_INFO1] = col ;
00517       stats [COLAMD\_INFO2] = Col [col].length ;
00518       COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: col %d length %d < 0\(\backslash\)n"}, col, Col [col].length)) ;
00519       \textcolor{keywordflow}{return} (\textcolor{keyword}{false}) ;
00520     \}
00521 
00522     Col [col].shared1.thickness = 1 ;
00523     Col [col].shared2.score = 0 ;
00524     Col [col].shared3.prev = COLAMD\_EMPTY ;
00525     Col [col].shared4.degree\_next = COLAMD\_EMPTY ;
00526   \}
00527 
00528   \textcolor{comment}{/* p [0..n\_col] no longer needed, used as "head" in subsequent routines */}
00529 
00530   \textcolor{comment}{/* === Scan columns, compute row degrees, and check row indices ========= */}
00531 
00532   stats [COLAMD\_INFO3] = 0 ;  \textcolor{comment}{/* number of duplicate or unsorted row indices*/}
00533 
00534   \textcolor{keywordflow}{for} (row = 0 ; row < n\_row ; row++)
00535   \{
00536     Row [row].length = 0 ;
00537     Row [row].shared2.mark = -1 ;
00538   \}
00539 
00540   \textcolor{keywordflow}{for} (col = 0 ; col < n\_col ; col++)
00541   \{
00542     last\_row = -1 ;
00543 
00544     cp = &A [p [col]] ;
00545     cp\_end = &A [p [col+1]] ;
00546 
00547     \textcolor{keywordflow}{while} (cp < cp\_end)
00548     \{
00549       row = *cp++ ;
00550 
00551       \textcolor{comment}{/* make sure row indices within range */}
00552       \textcolor{keywordflow}{if} (row < 0 || row >= n\_row)
00553       \{
00554     stats [COLAMD\_STATUS] = COLAMD\_ERROR\_row\_index\_out\_of\_bounds ;
00555     stats [COLAMD\_INFO1] = col ;
00556     stats [COLAMD\_INFO2] = row ;
00557     stats [COLAMD\_INFO3] = n\_row ;
00558     COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: row %d col %d out of bounds\(\backslash\)n"}, row, col)) ;
00559     \textcolor{keywordflow}{return} (\textcolor{keyword}{false}) ;
00560       \}
00561 
00562       \textcolor{keywordflow}{if} (row <= last\_row || Row [row].shared2.mark == col)
00563       \{
00564     \textcolor{comment}{/* row index are unsorted or repeated (or both), thus col */}
00565     \textcolor{comment}{/* is jumbled.  This is a notice, not an error condition. */}
00566     stats [COLAMD\_STATUS] = COLAMD\_OK\_BUT\_JUMBLED ;
00567     stats [COLAMD\_INFO1] = col ;
00568     stats [COLAMD\_INFO2] = row ;
00569     (stats [COLAMD\_INFO3]) ++ ;
00570     COLAMD\_DEBUG1 ((\textcolor{stringliteral}{"colamd: row %d col %d unsorted/duplicate\(\backslash\)n"},row,col));
00571       \}
00572 
00573       \textcolor{keywordflow}{if} (Row [row].shared2.mark != col)
00574       \{
00575     Row [row].length++ ;
00576       \}
00577       \textcolor{keywordflow}{else}
00578       \{
00579     \textcolor{comment}{/* this is a repeated entry in the column, */}
00580     \textcolor{comment}{/* it will be removed */}
00581     Col [col].length-- ;
00582       \}
00583 
00584       \textcolor{comment}{/* mark the row as having been seen in this column */}
00585       Row [row].shared2.mark = col ;
00586 
00587       last\_row = row ;
00588     \}
00589   \}
00590 
00591   \textcolor{comment}{/* === Compute row pointers ============================================= */}
00592 
00593   \textcolor{comment}{/* row form of the matrix starts directly after the column */}
00594   \textcolor{comment}{/* form of matrix in A */}
00595   Row [0].start = p [n\_col] ;
00596   Row [0].shared1.p = Row [0].start ;
00597   Row [0].shared2.mark = -1 ;
00598   \textcolor{keywordflow}{for} (row = 1 ; row < n\_row ; row++)
00599   \{
00600     Row [row].start = Row [row-1].start + Row [row-1].length ;
00601     Row [row].shared1.p = Row [row].start ;
00602     Row [row].shared2.mark = -1 ;
00603   \}
00604 
00605   \textcolor{comment}{/* === Create row form ================================================== */}
00606 
00607   \textcolor{keywordflow}{if} (stats [COLAMD\_STATUS] == COLAMD\_OK\_BUT\_JUMBLED)
00608   \{
00609     \textcolor{comment}{/* if cols jumbled, watch for repeated row indices */}
00610     \textcolor{keywordflow}{for} (col = 0 ; col < n\_col ; col++)
00611     \{
00612       cp = &A [p [col]] ;
00613       cp\_end = &A [p [col+1]] ;
00614       \textcolor{keywordflow}{while} (cp < cp\_end)
00615       \{
00616     row = *cp++ ;
00617     \textcolor{keywordflow}{if} (Row [row].shared2.mark != col)
00618     \{
00619       A [(Row [row].shared1.p)++] = col ;
00620       Row [row].shared2.mark = col ;
00621     \}
00622       \}
00623     \}
00624   \}
00625   \textcolor{keywordflow}{else}
00626   \{
00627     \textcolor{comment}{/* if cols not jumbled, we don't need the mark (this is faster) */}
00628     \textcolor{keywordflow}{for} (col = 0 ; col < n\_col ; col++)
00629     \{
00630       cp = &A [p [col]] ;
00631       cp\_end = &A [p [col+1]] ;
00632       \textcolor{keywordflow}{while} (cp < cp\_end)
00633       \{
00634     A [(Row [*cp++].shared1.p)++] = col ;
00635       \}
00636     \}
00637   \}
00638 
00639   \textcolor{comment}{/* === Clear the row marks and set row degrees ========================== */}
00640 
00641   \textcolor{keywordflow}{for} (row = 0 ; row < n\_row ; row++)
00642   \{
00643     Row [row].shared2.mark = 0 ;
00644     Row [row].shared1.degree = Row [row].length ;
00645   \}
00646 
00647   \textcolor{comment}{/* === See if we need to re-create columns ============================== */}
00648 
00649   \textcolor{keywordflow}{if} (stats [COLAMD\_STATUS] == COLAMD\_OK\_BUT\_JUMBLED)
00650   \{
00651     COLAMD\_DEBUG0 ((\textcolor{stringliteral}{"colamd: reconstructing column form, matrix jumbled\(\backslash\)n"})) ;
00652 
00653 
00654     \textcolor{comment}{/* === Compute col pointers ========================================= */}
00655 
00656     \textcolor{comment}{/* col form of the matrix starts at A [0]. */}
00657     \textcolor{comment}{/* Note, we may have a gap between the col form and the row */}
00658     \textcolor{comment}{/* form if there were duplicate entries, if so, it will be */}
00659     \textcolor{comment}{/* removed upon the first garbage collection */}
00660     Col [0].start = 0 ;
00661     p [0] = Col [0].start ;
00662     \textcolor{keywordflow}{for} (col = 1 ; col < n\_col ; col++)
00663     \{
00664       \textcolor{comment}{/* note that the lengths here are for pruned columns, i.e. */}
00665       \textcolor{comment}{/* no duplicate row indices will exist for these columns */}
00666       Col [col].start = Col [col-1].start + Col [col-1].length ;
00667       p [col] = Col [col].start ;
00668     \}
00669 
00670     \textcolor{comment}{/* === Re-create col form =========================================== */}
00671 
00672     \textcolor{keywordflow}{for} (row = 0 ; row < n\_row ; row++)
00673     \{
00674       rp = &A [Row [row].start] ;
00675       rp\_end = rp + Row [row].length ;
00676       \textcolor{keywordflow}{while} (rp < rp\_end)
00677       \{
00678     A [(p [*rp++])++] = row ;
00679       \}
00680     \}
00681   \}
00682 
00683   \textcolor{comment}{/* === Done.  Matrix is not (or no longer) jumbled ====================== */}
00684 
00685   \textcolor{keywordflow}{return} (\textcolor{keyword}{true}) ;
00686 \}
00687 
00688 
00689 \textcolor{comment}{/* ========================================================================== */}
00690 \textcolor{comment}{/* === init\_scoring ========================================================= */}
00691 \textcolor{comment}{/* ========================================================================== */}
00692 
00693 \textcolor{comment}{/*}
00694 \textcolor{comment}{  Kills dense or empty columns and rows, calculates an initial score for}
00695 \textcolor{comment}{  each column, and places all columns in the degree lists.  Not user-callable.}
00696 \textcolor{comment}{*/}
00697 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00698 \textcolor{keyword}{static} \textcolor{keywordtype}{void} init\_scoring
00699   (
00700     \textcolor{comment}{/* === Parameters ======================================================= */}
00701 
00702     IndexType n\_row,      \textcolor{comment}{/* number of rows of A */}
00703     IndexType n\_col,      \textcolor{comment}{/* number of columns of A */}
00704     Colamd\_Row<IndexType> Row [],    \textcolor{comment}{/* of size n\_row+1 */}
00705     colamd\_col<IndexType> Col [],    \textcolor{comment}{/* of size n\_col+1 */}
00706     IndexType A [],     \textcolor{comment}{/* column form and row form of A */}
00707     IndexType head [],    \textcolor{comment}{/* of size n\_col+1 */}
00708     \textcolor{keywordtype}{double} knobs [COLAMD\_KNOBS],\textcolor{comment}{/* parameters */}
00709     IndexType *p\_n\_row2,    \textcolor{comment}{/* number of non-dense, non-empty rows */}
00710     IndexType *p\_n\_col2,    \textcolor{comment}{/* number of non-dense, non-empty columns */}
00711     IndexType *p\_max\_deg    \textcolor{comment}{/* maximum row degree */}
00712     )
00713 \{
00714   \textcolor{comment}{/* === Local variables ================================================== */}
00715 
00716   IndexType c ;     \textcolor{comment}{/* a column index */}
00717   IndexType r, row ;    \textcolor{comment}{/* a row index */}
00718   IndexType *cp ;     \textcolor{comment}{/* a column pointer */}
00719   IndexType deg ;     \textcolor{comment}{/* degree of a row or column */}
00720   IndexType *cp\_end ;   \textcolor{comment}{/* a pointer to the end of a column */}
00721   IndexType *new\_cp ;   \textcolor{comment}{/* new column pointer */}
00722   IndexType col\_length ;    \textcolor{comment}{/* length of pruned column */}
00723   IndexType score ;     \textcolor{comment}{/* current column score */}
00724   IndexType n\_col2 ;    \textcolor{comment}{/* number of non-dense, non-empty columns */}
00725   IndexType n\_row2 ;    \textcolor{comment}{/* number of non-dense, non-empty rows */}
00726   IndexType dense\_row\_count ; \textcolor{comment}{/* remove rows with more entries than this */}
00727   IndexType dense\_col\_count ; \textcolor{comment}{/* remove cols with more entries than this */}
00728   IndexType min\_score ;   \textcolor{comment}{/* smallest column score */}
00729   IndexType max\_deg ;   \textcolor{comment}{/* maximum row degree */}
00730   IndexType next\_col ;    \textcolor{comment}{/* Used to add to degree list.*/}
00731 
00732 
00733   \textcolor{comment}{/* === Extract knobs ==================================================== */}
00734 
00735   dense\_row\_count = numext::maxi(IndexType(0), numext::mini(IndexType(knobs [COLAMD\_DENSE\_ROW] * n\_col), 
      n\_col)) ;
00736   dense\_col\_count = numext::maxi(IndexType(0), numext::mini(IndexType(knobs [COLAMD\_DENSE\_COL] * n\_row), 
      n\_row)) ;
00737   COLAMD\_DEBUG1 ((\textcolor{stringliteral}{"colamd: densecount: %d %d\(\backslash\)n"}, dense\_row\_count, dense\_col\_count)) ;
00738   max\_deg = 0 ;
00739   n\_col2 = n\_col ;
00740   n\_row2 = n\_row ;
00741 
00742   \textcolor{comment}{/* === Kill empty columns =============================================== */}
00743 
00744   \textcolor{comment}{/* Put the empty columns at the end in their natural order, so that LU */}
00745   \textcolor{comment}{/* factorization can proceed as far as possible. */}
00746   \textcolor{keywordflow}{for} (c = n\_col-1 ; c >= 0 ; c--)
00747   \{
00748     deg = Col [c].length ;
00749     \textcolor{keywordflow}{if} (deg == 0)
00750     \{
00751       \textcolor{comment}{/* this is a empty column, kill and order it last */}
00752       Col [c].shared2.order = --n\_col2 ;
00753       KILL\_PRINCIPAL\_COL (c) ;
00754     \}
00755   \}
00756   COLAMD\_DEBUG1 ((\textcolor{stringliteral}{"colamd: null columns killed: %d\(\backslash\)n"}, n\_col - n\_col2)) ;
00757 
00758   \textcolor{comment}{/* === Kill dense columns =============================================== */}
00759 
00760   \textcolor{comment}{/* Put the dense columns at the end, in their natural order */}
00761   \textcolor{keywordflow}{for} (c = n\_col-1 ; c >= 0 ; c--)
00762   \{
00763     \textcolor{comment}{/* skip any dead columns */}
00764     \textcolor{keywordflow}{if} (COL\_IS\_DEAD (c))
00765     \{
00766       continue ;
00767     \}
00768     deg = Col [c].length ;
00769     \textcolor{keywordflow}{if} (deg > dense\_col\_count)
00770     \{
00771       \textcolor{comment}{/* this is a dense column, kill and order it last */}
00772       Col [c].shared2.order = --n\_col2 ;
00773       \textcolor{comment}{/* decrement the row degrees */}
00774       cp = &A [Col [c].start] ;
00775       cp\_end = cp + Col [c].length ;
00776       \textcolor{keywordflow}{while} (cp < cp\_end)
00777       \{
00778     Row [*cp++].shared1.degree-- ;
00779       \}
00780       KILL\_PRINCIPAL\_COL (c) ;
00781     \}
00782   \}
00783   COLAMD\_DEBUG1 ((\textcolor{stringliteral}{"colamd: Dense and null columns killed: %d\(\backslash\)n"}, n\_col - n\_col2)) ;
00784 
00785   \textcolor{comment}{/* === Kill dense and empty rows ======================================== */}
00786 
00787   \textcolor{keywordflow}{for} (r = 0 ; r < n\_row ; r++)
00788   \{
00789     deg = Row [r].shared1.degree ;
00790     COLAMD\_ASSERT (deg >= 0 && deg <= n\_col) ;
00791     \textcolor{keywordflow}{if} (deg > dense\_row\_count || deg == 0)
00792     \{
00793       \textcolor{comment}{/* kill a dense or empty row */}
00794       KILL\_ROW (r) ;
00795       --n\_row2 ;
00796     \}
00797     \textcolor{keywordflow}{else}
00798     \{
00799       \textcolor{comment}{/* keep track of max degree of remaining rows */}
00800       max\_deg = numext::maxi(max\_deg, deg) ;
00801     \}
00802   \}
00803   COLAMD\_DEBUG1 ((\textcolor{stringliteral}{"colamd: Dense and null rows killed: %d\(\backslash\)n"}, n\_row - n\_row2)) ;
00804 
00805   \textcolor{comment}{/* === Compute initial column scores ==================================== */}
00806 
00807   \textcolor{comment}{/* At this point the row degrees are accurate.  They reflect the number */}
00808   \textcolor{comment}{/* of "live" (non-dense) columns in each row.  No empty rows exist. */}
00809   \textcolor{comment}{/* Some "live" columns may contain only dead rows, however.  These are */}
00810   \textcolor{comment}{/* pruned in the code below. */}
00811 
00812   \textcolor{comment}{/* now find the initial matlab score for each column */}
00813   \textcolor{keywordflow}{for} (c = n\_col-1 ; c >= 0 ; c--)
00814   \{
00815     \textcolor{comment}{/* skip dead column */}
00816     \textcolor{keywordflow}{if} (COL\_IS\_DEAD (c))
00817     \{
00818       continue ;
00819     \}
00820     score = 0 ;
00821     cp = &A [Col [c].start] ;
00822     new\_cp = cp ;
00823     cp\_end = cp + Col [c].length ;
00824     \textcolor{keywordflow}{while} (cp < cp\_end)
00825     \{
00826       \textcolor{comment}{/* get a row */}
00827       row = *cp++ ;
00828       \textcolor{comment}{/* skip if dead */}
00829       \textcolor{keywordflow}{if} (ROW\_IS\_DEAD (row))
00830       \{
00831     continue ;
00832       \}
00833       \textcolor{comment}{/* compact the column */}
00834       *new\_cp++ = row ;
00835       \textcolor{comment}{/* add row's external degree */}
00836       score += Row [row].shared1.degree - 1 ;
00837       \textcolor{comment}{/* guard against integer overflow */}
00838       score = numext::mini(score, n\_col) ;
00839     \}
00840     \textcolor{comment}{/* determine pruned column length */}
00841     col\_length = (IndexType) (new\_cp - &A [Col [c].start]) ;
00842     \textcolor{keywordflow}{if} (col\_length == 0)
00843     \{
00844       \textcolor{comment}{/* a newly-made null column (all rows in this col are "dense" */}
00845       \textcolor{comment}{/* and have already been killed) */}
00846       COLAMD\_DEBUG2 ((\textcolor{stringliteral}{"Newly null killed: %d\(\backslash\)n"}, c)) ;
00847       Col [c].shared2.order = --n\_col2 ;
00848       KILL\_PRINCIPAL\_COL (c) ;
00849     \}
00850     \textcolor{keywordflow}{else}
00851     \{
00852       \textcolor{comment}{/* set column length and set score */}
00853       COLAMD\_ASSERT (score >= 0) ;
00854       COLAMD\_ASSERT (score <= n\_col) ;
00855       Col [c].length = col\_length ;
00856       Col [c].shared2.score = score ;
00857     \}
00858   \}
00859   COLAMD\_DEBUG1 ((\textcolor{stringliteral}{"colamd: Dense, null, and newly-null columns killed: %d\(\backslash\)n"},
00860           n\_col-n\_col2)) ;
00861 
00862   \textcolor{comment}{/* At this point, all empty rows and columns are dead.  All live columns */}
00863   \textcolor{comment}{/* are "clean" (containing no dead rows) and simplicial (no supercolumns */}
00864   \textcolor{comment}{/* yet).  Rows may contain dead columns, but all live rows contain at */}
00865   \textcolor{comment}{/* least one live column. */}
00866 
00867   \textcolor{comment}{/* === Initialize degree lists ========================================== */}
00868 
00869 
00870   \textcolor{comment}{/* clear the hash buckets */}
00871   \textcolor{keywordflow}{for} (c = 0 ; c <= n\_col ; c++)
00872   \{
00873     head [c] = COLAMD\_EMPTY ;
00874   \}
00875   min\_score = n\_col ;
00876   \textcolor{comment}{/* place in reverse order, so low column indices are at the front */}
00877   \textcolor{comment}{/* of the lists.  This is to encourage natural tie-breaking */}
00878   \textcolor{keywordflow}{for} (c = n\_col-1 ; c >= 0 ; c--)
00879   \{
00880     \textcolor{comment}{/* only add principal columns to degree lists */}
00881     \textcolor{keywordflow}{if} (COL\_IS\_ALIVE (c))
00882     \{
00883       COLAMD\_DEBUG4 ((\textcolor{stringliteral}{"place %d score %d minscore %d ncol %d\(\backslash\)n"},
00884               c, Col [c].shared2.score, min\_score, n\_col)) ;
00885 
00886       \textcolor{comment}{/* === Add columns score to DList =============================== */}
00887 
00888       score = Col [c].shared2.score ;
00889 
00890       COLAMD\_ASSERT (min\_score >= 0) ;
00891       COLAMD\_ASSERT (min\_score <= n\_col) ;
00892       COLAMD\_ASSERT (score >= 0) ;
00893       COLAMD\_ASSERT (score <= n\_col) ;
00894       COLAMD\_ASSERT (head [score] >= COLAMD\_EMPTY) ;
00895 
00896       \textcolor{comment}{/* now add this column to dList at proper score location */}
00897       next\_col = head [score] ;
00898       Col [c].shared3.prev = COLAMD\_EMPTY ;
00899       Col [c].shared4.degree\_next = next\_col ;
00900 
00901       \textcolor{comment}{/* if there already was a column with the same score, set its */}
00902       \textcolor{comment}{/* previous pointer to this new column */}
00903       \textcolor{keywordflow}{if} (next\_col != COLAMD\_EMPTY)
00904       \{
00905     Col [next\_col].shared3.prev = c ;
00906       \}
00907       head [score] = c ;
00908 
00909       \textcolor{comment}{/* see if this score is less than current min */}
00910       min\_score = numext::mini(min\_score, score) ;
00911 
00912 
00913     \}
00914   \}
00915 
00916 
00917   \textcolor{comment}{/* === Return number of remaining columns, and max row degree =========== */}
00918 
00919   *p\_n\_col2 = n\_col2 ;
00920   *p\_n\_row2 = n\_row2 ;
00921   *p\_max\_deg = max\_deg ;
00922 \}
00923 
00924 
00925 \textcolor{comment}{/* ========================================================================== */}
00926 \textcolor{comment}{/* === find\_ordering ======================================================== */}
00927 \textcolor{comment}{/* ========================================================================== */}
00928 
00929 \textcolor{comment}{/*}
00930 \textcolor{comment}{  Order the principal columns of the supercolumn form of the matrix}
00931 \textcolor{comment}{  (no supercolumns on input).  Uses a minimum approximate column minimum}
00932 \textcolor{comment}{  degree ordering method.  Not user-callable.}
00933 \textcolor{comment}{*/}
00934 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00935 \textcolor{keyword}{static} IndexType find\_ordering \textcolor{comment}{/* return the number of garbage collections */}
00936   (
00937     \textcolor{comment}{/* === Parameters ======================================================= */}
00938 
00939     IndexType n\_row,      \textcolor{comment}{/* number of rows of A */}
00940     IndexType n\_col,      \textcolor{comment}{/* number of columns of A */}
00941     IndexType Alen,     \textcolor{comment}{/* size of A, 2*nnz + n\_col or larger */}
00942     Colamd\_Row<IndexType> Row [],    \textcolor{comment}{/* of size n\_row+1 */}
00943     colamd\_col<IndexType> Col [],    \textcolor{comment}{/* of size n\_col+1 */}
00944     IndexType A [],     \textcolor{comment}{/* column form and row form of A */}
00945     IndexType head [],    \textcolor{comment}{/* of size n\_col+1 */}
00946     IndexType n\_col2,     \textcolor{comment}{/* Remaining columns to order */}
00947     IndexType max\_deg,    \textcolor{comment}{/* Maximum row degree */}
00948     IndexType pfree     \textcolor{comment}{/* index of first free slot (2*nnz on entry) */}
00949     )
00950 \{
00951   \textcolor{comment}{/* === Local variables ================================================== */}
00952 
00953   IndexType k ;     \textcolor{comment}{/* current pivot ordering step */}
00954   IndexType pivot\_col ;   \textcolor{comment}{/* current pivot column */}
00955   IndexType *cp ;     \textcolor{comment}{/* a column pointer */}
00956   IndexType *rp ;     \textcolor{comment}{/* a row pointer */}
00957   IndexType pivot\_row ;   \textcolor{comment}{/* current pivot row */}
00958   IndexType *new\_cp ;   \textcolor{comment}{/* modified column pointer */}
00959   IndexType *new\_rp ;   \textcolor{comment}{/* modified row pointer */}
00960   IndexType pivot\_row\_start ; \textcolor{comment}{/* pointer to start of pivot row */}
00961   IndexType pivot\_row\_degree ;  \textcolor{comment}{/* number of columns in pivot row */}
00962   IndexType pivot\_row\_length ;  \textcolor{comment}{/* number of supercolumns in pivot row */}
00963   IndexType pivot\_col\_score ; \textcolor{comment}{/* score of pivot column */}
00964   IndexType needed\_memory ;   \textcolor{comment}{/* free space needed for pivot row */}
00965   IndexType *cp\_end ;   \textcolor{comment}{/* pointer to the end of a column */}
00966   IndexType *rp\_end ;   \textcolor{comment}{/* pointer to the end of a row */}
00967   IndexType row ;     \textcolor{comment}{/* a row index */}
00968   IndexType col ;     \textcolor{comment}{/* a column index */}
00969   IndexType max\_score ;   \textcolor{comment}{/* maximum possible score */}
00970   IndexType cur\_score ;   \textcolor{comment}{/* score of current column */}
00971   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} hash ;   \textcolor{comment}{/* hash value for supernode detection */}
00972   IndexType head\_column ;   \textcolor{comment}{/* head of hash bucket */}
00973   IndexType first\_col ;   \textcolor{comment}{/* first column in hash bucket */}
00974   IndexType tag\_mark ;    \textcolor{comment}{/* marker value for mark array */}
00975   IndexType row\_mark ;    \textcolor{comment}{/* Row [row].shared2.mark */}
00976   IndexType set\_difference ;  \textcolor{comment}{/* set difference size of row with pivot row */}
00977   IndexType min\_score ;   \textcolor{comment}{/* smallest column score */}
00978   IndexType col\_thickness ;   \textcolor{comment}{/* "thickness" (no. of columns in a supercol) */}
00979   IndexType max\_mark ;    \textcolor{comment}{/* maximum value of tag\_mark */}
00980   IndexType pivot\_col\_thickness ; \textcolor{comment}{/* number of columns represented by pivot col */}
00981   IndexType prev\_col ;    \textcolor{comment}{/* Used by Dlist operations. */}
00982   IndexType next\_col ;    \textcolor{comment}{/* Used by Dlist operations. */}
00983   IndexType ngarbage ;    \textcolor{comment}{/* number of garbage collections performed */}
00984 
00985 
00986   \textcolor{comment}{/* === Initialization and clear mark ==================================== */}
00987 
00988   max\_mark = INT\_MAX - n\_col ;  \textcolor{comment}{/* INT\_MAX defined in <limits.h> */}
00989   tag\_mark = Eigen::internal::clear\_mark (n\_row, Row) ;
00990   min\_score = 0 ;
00991   ngarbage = 0 ;
00992   COLAMD\_DEBUG1 ((\textcolor{stringliteral}{"colamd: Ordering, n\_col2=%d\(\backslash\)n"}, n\_col2)) ;
00993 
00994   \textcolor{comment}{/* === Order the columns ================================================ */}
00995 
00996   \textcolor{keywordflow}{for} (k = 0 ; k < n\_col2 ; \textcolor{comment}{/* 'k' is incremented below */})
00997   \{
00998 
00999     \textcolor{comment}{/* === Select pivot column, and order it ============================ */}
01000 
01001     \textcolor{comment}{/* make sure degree list isn't empty */}
01002     COLAMD\_ASSERT (min\_score >= 0) ;
01003     COLAMD\_ASSERT (min\_score <= n\_col) ;
01004     COLAMD\_ASSERT (head [min\_score] >= COLAMD\_EMPTY) ;
01005 
01006     \textcolor{comment}{/* get pivot column from head of minimum degree list */}
01007     \textcolor{keywordflow}{while} (min\_score < n\_col && head [min\_score] == COLAMD\_EMPTY)
01008     \{
01009       min\_score++ ;
01010     \}
01011     pivot\_col = head [min\_score] ;
01012     COLAMD\_ASSERT (pivot\_col >= 0 && pivot\_col <= n\_col) ;
01013     next\_col = Col [pivot\_col].shared4.degree\_next ;
01014     head [min\_score] = next\_col ;
01015     \textcolor{keywordflow}{if} (next\_col != COLAMD\_EMPTY)
01016     \{
01017       Col [next\_col].shared3.prev = COLAMD\_EMPTY ;
01018     \}
01019 
01020     COLAMD\_ASSERT (COL\_IS\_ALIVE (pivot\_col)) ;
01021     COLAMD\_DEBUG3 ((\textcolor{stringliteral}{"Pivot col: %d\(\backslash\)n"}, pivot\_col)) ;
01022 
01023     \textcolor{comment}{/* remember score for defrag check */}
01024     pivot\_col\_score = Col [pivot\_col].shared2.score ;
01025 
01026     \textcolor{comment}{/* the pivot column is the kth column in the pivot order */}
01027     Col [pivot\_col].shared2.order = k ;
01028 
01029     \textcolor{comment}{/* increment order count by column thickness */}
01030     pivot\_col\_thickness = Col [pivot\_col].shared1.thickness ;
01031     k += pivot\_col\_thickness ;
01032     COLAMD\_ASSERT (pivot\_col\_thickness > 0) ;
01033 
01034     \textcolor{comment}{/* === Garbage\_collection, if necessary ============================= */}
01035 
01036     needed\_memory = numext::mini(pivot\_col\_score, n\_col - k) ;
01037     \textcolor{keywordflow}{if} (pfree + needed\_memory >= Alen)
01038     \{
01039       pfree = Eigen::internal::garbage\_collection (n\_row, n\_col, Row, Col, A, &A [pfree]) ;
01040       ngarbage++ ;
01041       \textcolor{comment}{/* after garbage collection we will have enough */}
01042       COLAMD\_ASSERT (pfree + needed\_memory < Alen) ;
01043       \textcolor{comment}{/* garbage collection has wiped out the Row[].shared2.mark array */}
01044       tag\_mark = Eigen::internal::clear\_mark (n\_row, Row) ;
01045 
01046     \}
01047 
01048     \textcolor{comment}{/* === Compute pivot row pattern ==================================== */}
01049 
01050     \textcolor{comment}{/* get starting location for this new merged row */}
01051     pivot\_row\_start = pfree ;
01052 
01053     \textcolor{comment}{/* initialize new row counts to zero */}
01054     pivot\_row\_degree = 0 ;
01055 
01056     \textcolor{comment}{/* tag pivot column as having been visited so it isn't included */}
01057     \textcolor{comment}{/* in merged pivot row */}
01058     Col [pivot\_col].shared1.thickness = -pivot\_col\_thickness ;
01059 
01060     \textcolor{comment}{/* pivot row is the union of all rows in the pivot column pattern */}
01061     cp = &A [Col [pivot\_col].start] ;
01062     cp\_end = cp + Col [pivot\_col].length ;
01063     \textcolor{keywordflow}{while} (cp < cp\_end)
01064     \{
01065       \textcolor{comment}{/* get a row */}
01066       row = *cp++ ;
01067       COLAMD\_DEBUG4 ((\textcolor{stringliteral}{"Pivot col pattern %d %d\(\backslash\)n"}, ROW\_IS\_ALIVE (row), row)) ;
01068       \textcolor{comment}{/* skip if row is dead */}
01069       \textcolor{keywordflow}{if} (ROW\_IS\_DEAD (row))
01070       \{
01071     continue ;
01072       \}
01073       rp = &A [Row [row].start] ;
01074       rp\_end = rp + Row [row].length ;
01075       \textcolor{keywordflow}{while} (rp < rp\_end)
01076       \{
01077     \textcolor{comment}{/* get a column */}
01078     col = *rp++ ;
01079     \textcolor{comment}{/* add the column, if alive and untagged */}
01080     col\_thickness = Col [col].shared1.thickness ;
01081     \textcolor{keywordflow}{if} (col\_thickness > 0 && COL\_IS\_ALIVE (col))
01082     \{
01083       \textcolor{comment}{/* tag column in pivot row */}
01084       Col [col].shared1.thickness = -col\_thickness ;
01085       COLAMD\_ASSERT (pfree < Alen) ;
01086       \textcolor{comment}{/* place column in pivot row */}
01087       A [pfree++] = col ;
01088       pivot\_row\_degree += col\_thickness ;
01089     \}
01090       \}
01091     \}
01092 
01093     \textcolor{comment}{/* clear tag on pivot column */}
01094     Col [pivot\_col].shared1.thickness = pivot\_col\_thickness ;
01095     max\_deg = numext::maxi(max\_deg, pivot\_row\_degree) ;
01096 
01097 
01098     \textcolor{comment}{/* === Kill all rows used to construct pivot row ==================== */}
01099 
01100     \textcolor{comment}{/* also kill pivot row, temporarily */}
01101     cp = &A [Col [pivot\_col].start] ;
01102     cp\_end = cp + Col [pivot\_col].length ;
01103     \textcolor{keywordflow}{while} (cp < cp\_end)
01104     \{
01105       \textcolor{comment}{/* may be killing an already dead row */}
01106       row = *cp++ ;
01107       COLAMD\_DEBUG3 ((\textcolor{stringliteral}{"Kill row in pivot col: %d\(\backslash\)n"}, row)) ;
01108       KILL\_ROW (row) ;
01109     \}
01110 
01111     \textcolor{comment}{/* === Select a row index to use as the new pivot row =============== */}
01112 
01113     pivot\_row\_length = pfree - pivot\_row\_start ;
01114     \textcolor{keywordflow}{if} (pivot\_row\_length > 0)
01115     \{
01116       \textcolor{comment}{/* pick the "pivot" row arbitrarily (first row in col) */}
01117       pivot\_row = A [Col [pivot\_col].start] ;
01118       COLAMD\_DEBUG3 ((\textcolor{stringliteral}{"Pivotal row is %d\(\backslash\)n"}, pivot\_row)) ;
01119     \}
01120     \textcolor{keywordflow}{else}
01121     \{
01122       \textcolor{comment}{/* there is no pivot row, since it is of zero length */}
01123       pivot\_row = COLAMD\_EMPTY ;
01124       COLAMD\_ASSERT (pivot\_row\_length == 0) ;
01125     \}
01126     COLAMD\_ASSERT (Col [pivot\_col].length > 0 || pivot\_row\_length == 0) ;
01127 
01128     \textcolor{comment}{/* === Approximate degree computation =============================== */}
01129 
01130     \textcolor{comment}{/* Here begins the computation of the approximate degree.  The column */}
01131     \textcolor{comment}{/* score is the sum of the pivot row "length", plus the size of the */}
01132     \textcolor{comment}{/* set differences of each row in the column minus the pattern of the */}
01133     \textcolor{comment}{/* pivot row itself.  The column ("thickness") itself is also */}
01134     \textcolor{comment}{/* excluded from the column score (we thus use an approximate */}
01135     \textcolor{comment}{/* external degree). */}
01136 
01137     \textcolor{comment}{/* The time taken by the following code (compute set differences, and */}
01138     \textcolor{comment}{/* add them up) is proportional to the size of the data structure */}
01139     \textcolor{comment}{/* being scanned - that is, the sum of the sizes of each column in */}
01140     \textcolor{comment}{/* the pivot row.  Thus, the amortized time to compute a column score */}
01141     \textcolor{comment}{/* is proportional to the size of that column (where size, in this */}
01142     \textcolor{comment}{/* context, is the column "length", or the number of row indices */}
01143     \textcolor{comment}{/* in that column).  The number of row indices in a column is */}
01144     \textcolor{comment}{/* monotonically non-decreasing, from the length of the original */}
01145     \textcolor{comment}{/* column on input to colamd. */}
01146 
01147     \textcolor{comment}{/* === Compute set differences ====================================== */}
01148 
01149     COLAMD\_DEBUG3 ((\textcolor{stringliteral}{"** Computing set differences phase. **\(\backslash\)n"})) ;
01150 
01151     \textcolor{comment}{/* pivot row is currently dead - it will be revived later. */}
01152 
01153     COLAMD\_DEBUG3 ((\textcolor{stringliteral}{"Pivot row: "})) ;
01154     \textcolor{comment}{/* for each column in pivot row */}
01155     rp = &A [pivot\_row\_start] ;
01156     rp\_end = rp + pivot\_row\_length ;
01157     \textcolor{keywordflow}{while} (rp < rp\_end)
01158     \{
01159       col = *rp++ ;
01160       COLAMD\_ASSERT (COL\_IS\_ALIVE (col) && col != pivot\_col) ;
01161       COLAMD\_DEBUG3 ((\textcolor{stringliteral}{"Col: %d\(\backslash\)n"}, col)) ;
01162 
01163       \textcolor{comment}{/* clear tags used to construct pivot row pattern */}
01164       col\_thickness = -Col [col].shared1.thickness ;
01165       COLAMD\_ASSERT (col\_thickness > 0) ;
01166       Col [col].shared1.thickness = col\_thickness ;
01167 
01168       \textcolor{comment}{/* === Remove column from degree list =========================== */}
01169 
01170       cur\_score = Col [col].shared2.score ;
01171       prev\_col = Col [col].shared3.prev ;
01172       next\_col = Col [col].shared4.degree\_next ;
01173       COLAMD\_ASSERT (cur\_score >= 0) ;
01174       COLAMD\_ASSERT (cur\_score <= n\_col) ;
01175       COLAMD\_ASSERT (cur\_score >= COLAMD\_EMPTY) ;
01176       \textcolor{keywordflow}{if} (prev\_col == COLAMD\_EMPTY)
01177       \{
01178     head [cur\_score] = next\_col ;
01179       \}
01180       \textcolor{keywordflow}{else}
01181       \{
01182     Col [prev\_col].shared4.degree\_next = next\_col ;
01183       \}
01184       \textcolor{keywordflow}{if} (next\_col != COLAMD\_EMPTY)
01185       \{
01186     Col [next\_col].shared3.prev = prev\_col ;
01187       \}
01188 
01189       \textcolor{comment}{/* === Scan the column ========================================== */}
01190 
01191       cp = &A [Col [col].start] ;
01192       cp\_end = cp + Col [col].length ;
01193       \textcolor{keywordflow}{while} (cp < cp\_end)
01194       \{
01195     \textcolor{comment}{/* get a row */}
01196     row = *cp++ ;
01197     row\_mark = Row [row].shared2.mark ;
01198     \textcolor{comment}{/* skip if dead */}
01199     \textcolor{keywordflow}{if} (ROW\_IS\_MARKED\_DEAD (row\_mark))
01200     \{
01201       continue ;
01202     \}
01203     COLAMD\_ASSERT (row != pivot\_row) ;
01204     set\_difference = row\_mark - tag\_mark ;
01205     \textcolor{comment}{/* check if the row has been seen yet */}
01206     \textcolor{keywordflow}{if} (set\_difference < 0)
01207     \{
01208       COLAMD\_ASSERT (Row [row].shared1.degree <= max\_deg) ;
01209       set\_difference = Row [row].shared1.degree ;
01210     \}
01211     \textcolor{comment}{/* subtract column thickness from this row's set difference */}
01212     set\_difference -= col\_thickness ;
01213     COLAMD\_ASSERT (set\_difference >= 0) ;
01214     \textcolor{comment}{/* absorb this row if the set difference becomes zero */}
01215     \textcolor{keywordflow}{if} (set\_difference == 0)
01216     \{
01217       COLAMD\_DEBUG3 ((\textcolor{stringliteral}{"aggressive absorption. Row: %d\(\backslash\)n"}, row)) ;
01218       KILL\_ROW (row) ;
01219     \}
01220     \textcolor{keywordflow}{else}
01221     \{
01222       \textcolor{comment}{/* save the new mark */}
01223       Row [row].shared2.mark = set\_difference + tag\_mark ;
01224     \}
01225       \}
01226     \}
01227 
01228 
01229     \textcolor{comment}{/* === Add up set differences for each column ======================= */}
01230 
01231     COLAMD\_DEBUG3 ((\textcolor{stringliteral}{"** Adding set differences phase. **\(\backslash\)n"})) ;
01232 
01233     \textcolor{comment}{/* for each column in pivot row */}
01234     rp = &A [pivot\_row\_start] ;
01235     rp\_end = rp + pivot\_row\_length ;
01236     \textcolor{keywordflow}{while} (rp < rp\_end)
01237     \{
01238       \textcolor{comment}{/* get a column */}
01239       col = *rp++ ;
01240       COLAMD\_ASSERT (COL\_IS\_ALIVE (col) && col != pivot\_col) ;
01241       hash = 0 ;
01242       cur\_score = 0 ;
01243       cp = &A [Col [col].start] ;
01244       \textcolor{comment}{/* compact the column */}
01245       new\_cp = cp ;
01246       cp\_end = cp + Col [col].length ;
01247 
01248       COLAMD\_DEBUG4 ((\textcolor{stringliteral}{"Adding set diffs for Col: %d.\(\backslash\)n"}, col)) ;
01249 
01250       \textcolor{keywordflow}{while} (cp < cp\_end)
01251       \{
01252     \textcolor{comment}{/* get a row */}
01253     row = *cp++ ;
01254     COLAMD\_ASSERT(row >= 0 && row < n\_row) ;
01255     row\_mark = Row [row].shared2.mark ;
01256     \textcolor{comment}{/* skip if dead */}
01257     \textcolor{keywordflow}{if} (ROW\_IS\_MARKED\_DEAD (row\_mark))
01258     \{
01259       continue ;
01260     \}
01261     COLAMD\_ASSERT (row\_mark > tag\_mark) ;
01262     \textcolor{comment}{/* compact the column */}
01263     *new\_cp++ = row ;
01264     \textcolor{comment}{/* compute hash function */}
01265     hash += row ;
01266     \textcolor{comment}{/* add set difference */}
01267     cur\_score += row\_mark - tag\_mark ;
01268     \textcolor{comment}{/* integer overflow... */}
01269     cur\_score = numext::mini(cur\_score, n\_col) ;
01270       \}
01271 
01272       \textcolor{comment}{/* recompute the column's length */}
01273       Col [col].length = (IndexType) (new\_cp - &A [Col [col].start]) ;
01274 
01275       \textcolor{comment}{/* === Further mass elimination ================================= */}
01276 
01277       \textcolor{keywordflow}{if} (Col [col].length == 0)
01278       \{
01279     COLAMD\_DEBUG4 ((\textcolor{stringliteral}{"further mass elimination. Col: %d\(\backslash\)n"}, col)) ;
01280     \textcolor{comment}{/* nothing left but the pivot row in this column */}
01281     KILL\_PRINCIPAL\_COL (col) ;
01282     pivot\_row\_degree -= Col [col].shared1.thickness ;
01283     COLAMD\_ASSERT (pivot\_row\_degree >= 0) ;
01284     \textcolor{comment}{/* order it */}
01285     Col [col].shared2.order = k ;
01286     \textcolor{comment}{/* increment order count by column thickness */}
01287     k += Col [col].shared1.thickness ;
01288       \}
01289       \textcolor{keywordflow}{else}
01290       \{
01291     \textcolor{comment}{/* === Prepare for supercolumn detection ==================== */}
01292 
01293     COLAMD\_DEBUG4 ((\textcolor{stringliteral}{"Preparing supercol detection for Col: %d.\(\backslash\)n"}, col)) ;
01294 
01295     \textcolor{comment}{/* save score so far */}
01296     Col [col].shared2.score = cur\_score ;
01297 
01298     \textcolor{comment}{/* add column to hash table, for supercolumn detection */}
01299     hash %= n\_col + 1 ;
01300 
01301     COLAMD\_DEBUG4 ((\textcolor{stringliteral}{" Hash = %d, n\_col = %d.\(\backslash\)n"}, hash, n\_col)) ;
01302     COLAMD\_ASSERT (hash <= n\_col) ;
01303 
01304     head\_column = head [hash] ;
01305     \textcolor{keywordflow}{if} (head\_column > COLAMD\_EMPTY)
01306     \{
01307       \textcolor{comment}{/* degree list "hash" is non-empty, use prev (shared3) of */}
01308       \textcolor{comment}{/* first column in degree list as head of hash bucket */}
01309       first\_col = Col [head\_column].shared3.headhash ;
01310       Col [head\_column].shared3.headhash = col ;
01311     \}
01312     \textcolor{keywordflow}{else}
01313     \{
01314       \textcolor{comment}{/* degree list "hash" is empty, use head as hash bucket */}
01315       first\_col = - (head\_column + 2) ;
01316       head [hash] = - (col + 2) ;
01317     \}
01318     Col [col].shared4.hash\_next = first\_col ;
01319 
01320     \textcolor{comment}{/* save hash function in Col [col].shared3.hash */}
01321     Col [col].shared3.hash = (IndexType) hash ;
01322     COLAMD\_ASSERT (COL\_IS\_ALIVE (col)) ;
01323       \}
01324     \}
01325 
01326     \textcolor{comment}{/* The approximate external column degree is now computed.  */}
01327 
01328     \textcolor{comment}{/* === Supercolumn detection ======================================== */}
01329 
01330     COLAMD\_DEBUG3 ((\textcolor{stringliteral}{"** Supercolumn detection phase. **\(\backslash\)n"})) ;
01331 
01332     Eigen::internal::detect\_super\_cols (Col, A, head, pivot\_row\_start, pivot\_row\_length) ;
01333 
01334     \textcolor{comment}{/* === Kill the pivotal column ====================================== */}
01335 
01336     KILL\_PRINCIPAL\_COL (pivot\_col) ;
01337 
01338     \textcolor{comment}{/* === Clear mark =================================================== */}
01339 
01340     tag\_mark += (max\_deg + 1) ;
01341     \textcolor{keywordflow}{if} (tag\_mark >= max\_mark)
01342     \{
01343       COLAMD\_DEBUG2 ((\textcolor{stringliteral}{"clearing tag\_mark\(\backslash\)n"})) ;
01344       tag\_mark = Eigen::internal::clear\_mark (n\_row, Row) ;
01345     \}
01346 
01347     \textcolor{comment}{/* === Finalize the new pivot row, and column scores ================ */}
01348 
01349     COLAMD\_DEBUG3 ((\textcolor{stringliteral}{"** Finalize scores phase. **\(\backslash\)n"})) ;
01350 
01351     \textcolor{comment}{/* for each column in pivot row */}
01352     rp = &A [pivot\_row\_start] ;
01353     \textcolor{comment}{/* compact the pivot row */}
01354     new\_rp = rp ;
01355     rp\_end = rp + pivot\_row\_length ;
01356     \textcolor{keywordflow}{while} (rp < rp\_end)
01357     \{
01358       col = *rp++ ;
01359       \textcolor{comment}{/* skip dead columns */}
01360       \textcolor{keywordflow}{if} (COL\_IS\_DEAD (col))
01361       \{
01362     continue ;
01363       \}
01364       *new\_rp++ = col ;
01365       \textcolor{comment}{/* add new pivot row to column */}
01366       A [Col [col].start + (Col [col].length++)] = pivot\_row ;
01367 
01368       \textcolor{comment}{/* retrieve score so far and add on pivot row's degree. */}
01369       \textcolor{comment}{/* (we wait until here for this in case the pivot */}
01370       \textcolor{comment}{/* row's degree was reduced due to mass elimination). */}
01371       cur\_score = Col [col].shared2.score + pivot\_row\_degree ;
01372 
01373       \textcolor{comment}{/* calculate the max possible score as the number of */}
01374       \textcolor{comment}{/* external columns minus the 'k' value minus the */}
01375       \textcolor{comment}{/* columns thickness */}
01376       max\_score = n\_col - k - Col [col].shared1.thickness ;
01377 
01378       \textcolor{comment}{/* make the score the external degree of the union-of-rows */}
01379       cur\_score -= Col [col].shared1.thickness ;
01380 
01381       \textcolor{comment}{/* make sure score is less or equal than the max score */}
01382       cur\_score = numext::mini(cur\_score, max\_score) ;
01383       COLAMD\_ASSERT (cur\_score >= 0) ;
01384 
01385       \textcolor{comment}{/* store updated score */}
01386       Col [col].shared2.score = cur\_score ;
01387 
01388       \textcolor{comment}{/* === Place column back in degree list ========================= */}
01389 
01390       COLAMD\_ASSERT (min\_score >= 0) ;
01391       COLAMD\_ASSERT (min\_score <= n\_col) ;
01392       COLAMD\_ASSERT (cur\_score >= 0) ;
01393       COLAMD\_ASSERT (cur\_score <= n\_col) ;
01394       COLAMD\_ASSERT (head [cur\_score] >= COLAMD\_EMPTY) ;
01395       next\_col = head [cur\_score] ;
01396       Col [col].shared4.degree\_next = next\_col ;
01397       Col [col].shared3.prev = COLAMD\_EMPTY ;
01398       \textcolor{keywordflow}{if} (next\_col != COLAMD\_EMPTY)
01399       \{
01400     Col [next\_col].shared3.prev = col ;
01401       \}
01402       head [cur\_score] = col ;
01403 
01404       \textcolor{comment}{/* see if this score is less than current min */}
01405       min\_score = numext::mini(min\_score, cur\_score) ;
01406 
01407     \}
01408 
01409     \textcolor{comment}{/* === Resurrect the new pivot row ================================== */}
01410 
01411     \textcolor{keywordflow}{if} (pivot\_row\_degree > 0)
01412     \{
01413       \textcolor{comment}{/* update pivot row length to reflect any cols that were killed */}
01414       \textcolor{comment}{/* during super-col detection and mass elimination */}
01415       Row [pivot\_row].start  = pivot\_row\_start ;
01416       Row [pivot\_row].length = (IndexType) (new\_rp - &A[pivot\_row\_start]) ;
01417       Row [pivot\_row].shared1.degree = pivot\_row\_degree ;
01418       Row [pivot\_row].shared2.mark = 0 ;
01419       \textcolor{comment}{/* pivot row is no longer dead */}
01420     \}
01421   \}
01422 
01423   \textcolor{comment}{/* === All principal columns have now been ordered ====================== */}
01424 
01425   \textcolor{keywordflow}{return} (ngarbage) ;
01426 \}
01427 
01428 
01429 \textcolor{comment}{/* ========================================================================== */}
01430 \textcolor{comment}{/* === order\_children ======================================================= */}
01431 \textcolor{comment}{/* ========================================================================== */}
01432 
01433 \textcolor{comment}{/*}
01434 \textcolor{comment}{  The find\_ordering routine has ordered all of the principal columns (the}
01435 \textcolor{comment}{  representatives of the supercolumns).  The non-principal columns have not}
01436 \textcolor{comment}{  yet been ordered.  This routine orders those columns by walking up the}
01437 \textcolor{comment}{  parent tree (a column is a child of the column which absorbed it).  The}
01438 \textcolor{comment}{  final permutation vector is then placed in p [0 ... n\_col-1], with p [0]}
01439 \textcolor{comment}{  being the first column, and p [n\_col-1] being the last.  It doesn't look}
01440 \textcolor{comment}{  like it at first glance, but be assured that this routine takes time linear}
01441 \textcolor{comment}{  in the number of columns.  Although not immediately obvious, the time}
01442 \textcolor{comment}{  taken by this routine is O (n\_col), that is, linear in the number of}
01443 \textcolor{comment}{  columns.  Not user-callable.}
01444 \textcolor{comment}{*/}
01445 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
01446 \textcolor{keyword}{static} \textcolor{keyword}{inline}  \textcolor{keywordtype}{void} order\_children
01447 (
01448   \textcolor{comment}{/* === Parameters ======================================================= */}
01449 
01450   IndexType n\_col,      \textcolor{comment}{/* number of columns of A */}
01451   colamd\_col<IndexType> Col [],    \textcolor{comment}{/* of size n\_col+1 */}
01452   IndexType p []      \textcolor{comment}{/* p [0 ... n\_col-1] is the column permutation*/}
01453   )
01454 \{
01455   \textcolor{comment}{/* === Local variables ================================================== */}
01456 
01457   IndexType i ;     \textcolor{comment}{/* loop counter for all columns */}
01458   IndexType c ;     \textcolor{comment}{/* column index */}
01459   IndexType parent ;    \textcolor{comment}{/* index of column's parent */}
01460   IndexType order ;     \textcolor{comment}{/* column's order */}
01461 
01462   \textcolor{comment}{/* === Order each non-principal column ================================== */}
01463 
01464   \textcolor{keywordflow}{for} (i = 0 ; i < n\_col ; i++)
01465   \{
01466     \textcolor{comment}{/* find an un-ordered non-principal column */}
01467     COLAMD\_ASSERT (COL\_IS\_DEAD (i)) ;
01468     \textcolor{keywordflow}{if} (!COL\_IS\_DEAD\_PRINCIPAL (i) && Col [i].shared2.order == COLAMD\_EMPTY)
01469     \{
01470       parent = i ;
01471       \textcolor{comment}{/* once found, find its principal parent */}
01472       \textcolor{keywordflow}{do}
01473       \{
01474     parent = Col [parent].shared1.parent ;
01475       \} \textcolor{keywordflow}{while} (!COL\_IS\_DEAD\_PRINCIPAL (parent)) ;
01476 
01477       \textcolor{comment}{/* now, order all un-ordered non-principal columns along path */}
01478       \textcolor{comment}{/* to this parent.  collapse tree at the same time */}
01479       c = i ;
01480       \textcolor{comment}{/* get order of parent */}
01481       order = Col [parent].shared2.order ;
01482 
01483       \textcolor{keywordflow}{do}
01484       \{
01485     COLAMD\_ASSERT (Col [c].shared2.order == COLAMD\_EMPTY) ;
01486 
01487     \textcolor{comment}{/* order this column */}
01488     Col [c].shared2.order = order++ ;
01489     \textcolor{comment}{/* collaps tree */}
01490     Col [c].shared1.parent = parent ;
01491 
01492     \textcolor{comment}{/* get immediate parent of this column */}
01493     c = Col [c].shared1.parent ;
01494 
01495     \textcolor{comment}{/* continue until we hit an ordered column.  There are */}
01496     \textcolor{comment}{/* guarranteed not to be anymore unordered columns */}
01497     \textcolor{comment}{/* above an ordered column */}
01498       \} \textcolor{keywordflow}{while} (Col [c].shared2.order == COLAMD\_EMPTY) ;
01499 
01500       \textcolor{comment}{/* re-order the super\_col parent to largest order for this group */}
01501       Col [parent].shared2.order = order ;
01502     \}
01503   \}
01504 
01505   \textcolor{comment}{/* === Generate the permutation ========================================= */}
01506 
01507   \textcolor{keywordflow}{for} (c = 0 ; c < n\_col ; c++)
01508   \{
01509     p [Col [c].shared2.order] = c ;
01510   \}
01511 \}
01512 
01513 
01514 \textcolor{comment}{/* ========================================================================== */}
01515 \textcolor{comment}{/* === detect\_super\_cols ==================================================== */}
01516 \textcolor{comment}{/* ========================================================================== */}
01517 
01518 \textcolor{comment}{/*}
01519 \textcolor{comment}{  Detects supercolumns by finding matches between columns in the hash buckets.}
01520 \textcolor{comment}{  Check amongst columns in the set A [row\_start ... row\_start + row\_length-1].}
01521 \textcolor{comment}{  The columns under consideration are currently *not* in the degree lists,}
01522 \textcolor{comment}{  and have already been placed in the hash buckets.}
01523 \textcolor{comment}{}
01524 \textcolor{comment}{  The hash bucket for columns whose hash function is equal to h is stored}
01525 \textcolor{comment}{  as follows:}
01526 \textcolor{comment}{}
01527 \textcolor{comment}{  if head [h] is >= 0, then head [h] contains a degree list, so:}
01528 \textcolor{comment}{}
01529 \textcolor{comment}{  head [h] is the first column in degree bucket h.}
01530 \textcolor{comment}{  Col [head [h]].headhash gives the first column in hash bucket h.}
01531 \textcolor{comment}{}
01532 \textcolor{comment}{  otherwise, the degree list is empty, and:}
01533 \textcolor{comment}{}
01534 \textcolor{comment}{  -(head [h] + 2) is the first column in hash bucket h.}
01535 \textcolor{comment}{}
01536 \textcolor{comment}{  For a column c in a hash bucket, Col [c].shared3.prev is NOT a "previous}
01537 \textcolor{comment}{  column" pointer.  Col [c].shared3.hash is used instead as the hash number}
01538 \textcolor{comment}{  for that column.  The value of Col [c].shared4.hash\_next is the next column}
01539 \textcolor{comment}{  in the same hash bucket.}
01540 \textcolor{comment}{}
01541 \textcolor{comment}{  Assuming no, or "few" hash collisions, the time taken by this routine is}
01542 \textcolor{comment}{  linear in the sum of the sizes (lengths) of each column whose score has}
01543 \textcolor{comment}{  just been computed in the approximate degree computation.}
01544 \textcolor{comment}{  Not user-callable.}
01545 \textcolor{comment}{*/}
01546 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
01547 \textcolor{keyword}{static} \textcolor{keywordtype}{void} detect\_super\_cols
01548 (
01549   \textcolor{comment}{/* === Parameters ======================================================= */}
01550   
01551   colamd\_col<IndexType> Col [],    \textcolor{comment}{/* of size n\_col+1 */}
01552   IndexType A [],     \textcolor{comment}{/* row indices of A */}
01553   IndexType head [],    \textcolor{comment}{/* head of degree lists and hash buckets */}
01554   IndexType row\_start,    \textcolor{comment}{/* pointer to set of columns to check */}
01555   IndexType row\_length    \textcolor{comment}{/* number of columns to check */}
01556 )
01557 \{
01558   \textcolor{comment}{/* === Local variables ================================================== */}
01559 
01560   IndexType hash ;      \textcolor{comment}{/* hash value for a column */}
01561   IndexType *rp ;     \textcolor{comment}{/* pointer to a row */}
01562   IndexType c ;     \textcolor{comment}{/* a column index */}
01563   IndexType super\_c ;   \textcolor{comment}{/* column index of the column to absorb into */}
01564   IndexType *cp1 ;      \textcolor{comment}{/* column pointer for column super\_c */}
01565   IndexType *cp2 ;      \textcolor{comment}{/* column pointer for column c */}
01566   IndexType length ;    \textcolor{comment}{/* length of column super\_c */}
01567   IndexType prev\_c ;    \textcolor{comment}{/* column preceding c in hash bucket */}
01568   IndexType i ;     \textcolor{comment}{/* loop counter */}
01569   IndexType *rp\_end ;   \textcolor{comment}{/* pointer to the end of the row */}
01570   IndexType col ;     \textcolor{comment}{/* a column index in the row to check */}
01571   IndexType head\_column ;   \textcolor{comment}{/* first column in hash bucket or degree list */}
01572   IndexType first\_col ;   \textcolor{comment}{/* first column in hash bucket */}
01573 
01574   \textcolor{comment}{/* === Consider each column in the row ================================== */}
01575 
01576   rp = &A [row\_start] ;
01577   rp\_end = rp + row\_length ;
01578   \textcolor{keywordflow}{while} (rp < rp\_end)
01579   \{
01580     col = *rp++ ;
01581     \textcolor{keywordflow}{if} (COL\_IS\_DEAD (col))
01582     \{
01583       continue ;
01584     \}
01585 
01586     \textcolor{comment}{/* get hash number for this column */}
01587     hash = Col [col].shared3.hash ;
01588     COLAMD\_ASSERT (hash <= n\_col) ;
01589 
01590     \textcolor{comment}{/* === Get the first column in this hash bucket ===================== */}
01591 
01592     head\_column = head [hash] ;
01593     \textcolor{keywordflow}{if} (head\_column > COLAMD\_EMPTY)
01594     \{
01595       first\_col = Col [head\_column].shared3.headhash ;
01596     \}
01597     \textcolor{keywordflow}{else}
01598     \{
01599       first\_col = - (head\_column + 2) ;
01600     \}
01601 
01602     \textcolor{comment}{/* === Consider each column in the hash bucket ====================== */}
01603 
01604     \textcolor{keywordflow}{for} (super\_c = first\_col ; super\_c != COLAMD\_EMPTY ;
01605      super\_c = Col [super\_c].shared4.hash\_next)
01606     \{
01607       COLAMD\_ASSERT (COL\_IS\_ALIVE (super\_c)) ;
01608       COLAMD\_ASSERT (Col [super\_c].shared3.hash == hash) ;
01609       length = Col [super\_c].length ;
01610 
01611       \textcolor{comment}{/* prev\_c is the column preceding column c in the hash bucket */}
01612       prev\_c = super\_c ;
01613 
01614       \textcolor{comment}{/* === Compare super\_c with all columns after it ================ */}
01615 
01616       \textcolor{keywordflow}{for} (c = Col [super\_c].shared4.hash\_next ;
01617        c != COLAMD\_EMPTY ; c = Col [c].shared4.hash\_next)
01618       \{
01619     COLAMD\_ASSERT (c != super\_c) ;
01620     COLAMD\_ASSERT (COL\_IS\_ALIVE (c)) ;
01621     COLAMD\_ASSERT (Col [c].shared3.hash == hash) ;
01622 
01623     \textcolor{comment}{/* not identical if lengths or scores are different */}
01624     \textcolor{keywordflow}{if} (Col [c].length != length ||
01625         Col [c].shared2.score != Col [super\_c].shared2.score)
01626     \{
01627       prev\_c = c ;
01628       continue ;
01629     \}
01630 
01631     \textcolor{comment}{/* compare the two columns */}
01632     cp1 = &A [Col [super\_c].start] ;
01633     cp2 = &A [Col [c].start] ;
01634 
01635     \textcolor{keywordflow}{for} (i = 0 ; i < length ; i++)
01636     \{
01637       \textcolor{comment}{/* the columns are "clean" (no dead rows) */}
01638       COLAMD\_ASSERT (ROW\_IS\_ALIVE (*cp1))  ;
01639       COLAMD\_ASSERT (ROW\_IS\_ALIVE (*cp2))  ;
01640       \textcolor{comment}{/* row indices will same order for both supercols, */}
01641       \textcolor{comment}{/* no gather scatter nessasary */}
01642       \textcolor{keywordflow}{if} (*cp1++ != *cp2++)
01643       \{
01644         break ;
01645       \}
01646     \}
01647 
01648     \textcolor{comment}{/* the two columns are different if the for-loop "broke" */}
01649     \textcolor{keywordflow}{if} (i != length)
01650     \{
01651       prev\_c = c ;
01652       continue ;
01653     \}
01654 
01655     \textcolor{comment}{/* === Got it!  two columns are identical =================== */}
01656 
01657     COLAMD\_ASSERT (Col [c].shared2.score == Col [super\_c].shared2.score) ;
01658 
01659     Col [super\_c].shared1.thickness += Col [c].shared1.thickness ;
01660     Col [c].shared1.parent = super\_c ;
01661     KILL\_NON\_PRINCIPAL\_COL (c) ;
01662     \textcolor{comment}{/* order c later, in order\_children() */}
01663     Col [c].shared2.order = COLAMD\_EMPTY ;
01664     \textcolor{comment}{/* remove c from hash bucket */}
01665     Col [prev\_c].shared4.hash\_next = Col [c].shared4.hash\_next ;
01666       \}
01667     \}
01668 
01669     \textcolor{comment}{/* === Empty this hash bucket ======================================= */}
01670 
01671     \textcolor{keywordflow}{if} (head\_column > COLAMD\_EMPTY)
01672     \{
01673       \textcolor{comment}{/* corresponding degree list "hash" is not empty */}
01674       Col [head\_column].shared3.headhash = COLAMD\_EMPTY ;
01675     \}
01676     \textcolor{keywordflow}{else}
01677     \{
01678       \textcolor{comment}{/* corresponding degree list "hash" is empty */}
01679       head [hash] = COLAMD\_EMPTY ;
01680     \}
01681   \}
01682 \}
01683 
01684 
01685 \textcolor{comment}{/* ========================================================================== */}
01686 \textcolor{comment}{/* === garbage\_collection =================================================== */}
01687 \textcolor{comment}{/* ========================================================================== */}
01688 
01689 \textcolor{comment}{/*}
01690 \textcolor{comment}{  Defragments and compacts columns and rows in the workspace A.  Used when}
01691 \textcolor{comment}{  all avaliable memory has been used while performing row merging.  Returns}
01692 \textcolor{comment}{  the index of the first free position in A, after garbage collection.  The}
01693 \textcolor{comment}{  time taken by this routine is linear is the size of the array A, which is}
01694 \textcolor{comment}{  itself linear in the number of nonzeros in the input matrix.}
01695 \textcolor{comment}{  Not user-callable.}
01696 \textcolor{comment}{*/}
01697 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
01698 \textcolor{keyword}{static} IndexType garbage\_collection  \textcolor{comment}{/* returns the new value of pfree */}
01699   (
01700     \textcolor{comment}{/* === Parameters ======================================================= */}
01701     
01702     IndexType n\_row,      \textcolor{comment}{/* number of rows */}
01703     IndexType n\_col,      \textcolor{comment}{/* number of columns */}
01704     Colamd\_Row<IndexType> Row [],    \textcolor{comment}{/* row info */}
01705     colamd\_col<IndexType> Col [],    \textcolor{comment}{/* column info */}
01706     IndexType A [],     \textcolor{comment}{/* A [0 ... Alen-1] holds the matrix */}
01707     IndexType *pfree      \textcolor{comment}{/* &A [0] ... pfree is in use */}
01708     )
01709 \{
01710   \textcolor{comment}{/* === Local variables ================================================== */}
01711 
01712   IndexType *psrc ;     \textcolor{comment}{/* source pointer */}
01713   IndexType *pdest ;    \textcolor{comment}{/* destination pointer */}
01714   IndexType j ;     \textcolor{comment}{/* counter */}
01715   IndexType r ;     \textcolor{comment}{/* a row index */}
01716   IndexType c ;     \textcolor{comment}{/* a column index */}
01717   IndexType length ;    \textcolor{comment}{/* length of a row or column */}
01718 
01719   \textcolor{comment}{/* === Defragment the columns =========================================== */}
01720 
01721   pdest = &A[0] ;
01722   \textcolor{keywordflow}{for} (c = 0 ; c < n\_col ; c++)
01723   \{
01724     \textcolor{keywordflow}{if} (COL\_IS\_ALIVE (c))
01725     \{
01726       psrc = &A [Col [c].start] ;
01727 
01728       \textcolor{comment}{/* move and compact the column */}
01729       COLAMD\_ASSERT (pdest <= psrc) ;
01730       Col [c].start = (IndexType) (pdest - &A [0]) ;
01731       length = Col [c].length ;
01732       \textcolor{keywordflow}{for} (j = 0 ; j < length ; j++)
01733       \{
01734     r = *psrc++ ;
01735     \textcolor{keywordflow}{if} (ROW\_IS\_ALIVE (r))
01736     \{
01737       *pdest++ = r ;
01738     \}
01739       \}
01740       Col [c].length = (IndexType) (pdest - &A [Col [c].start]) ;
01741     \}
01742   \}
01743 
01744   \textcolor{comment}{/* === Prepare to defragment the rows =================================== */}
01745 
01746   \textcolor{keywordflow}{for} (r = 0 ; r < n\_row ; r++)
01747   \{
01748     \textcolor{keywordflow}{if} (ROW\_IS\_ALIVE (r))
01749     \{
01750       \textcolor{keywordflow}{if} (Row [r].length == 0)
01751       \{
01752     \textcolor{comment}{/* this row is of zero length.  cannot compact it, so kill it */}
01753     COLAMD\_DEBUG3 ((\textcolor{stringliteral}{"Defrag row kill\(\backslash\)n"})) ;
01754     KILL\_ROW (r) ;
01755       \}
01756       \textcolor{keywordflow}{else}
01757       \{
01758     \textcolor{comment}{/* save first column index in Row [r].shared2.first\_column */}
01759     psrc = &A [Row [r].start] ;
01760     Row [r].shared2.first\_column = *psrc ;
01761     COLAMD\_ASSERT (ROW\_IS\_ALIVE (r)) ;
01762     \textcolor{comment}{/* flag the start of the row with the one's complement of row */}
01763     *psrc = ONES\_COMPLEMENT (r) ;
01764 
01765       \}
01766     \}
01767   \}
01768 
01769   \textcolor{comment}{/* === Defragment the rows ============================================== */}
01770 
01771   psrc = pdest ;
01772   \textcolor{keywordflow}{while} (psrc < pfree)
01773   \{
01774     \textcolor{comment}{/* find a negative number ... the start of a row */}
01775     \textcolor{keywordflow}{if} (*psrc++ < 0)
01776     \{
01777       psrc-- ;
01778       \textcolor{comment}{/* get the row index */}
01779       r = ONES\_COMPLEMENT (*psrc) ;
01780       COLAMD\_ASSERT (r >= 0 && r < n\_row) ;
01781       \textcolor{comment}{/* restore first column index */}
01782       *psrc = Row [r].shared2.first\_column ;
01783       COLAMD\_ASSERT (ROW\_IS\_ALIVE (r)) ;
01784 
01785       \textcolor{comment}{/* move and compact the row */}
01786       COLAMD\_ASSERT (pdest <= psrc) ;
01787       Row [r].start = (IndexType) (pdest - &A [0]) ;
01788       length = Row [r].length ;
01789       \textcolor{keywordflow}{for} (j = 0 ; j < length ; j++)
01790       \{
01791     c = *psrc++ ;
01792     \textcolor{keywordflow}{if} (COL\_IS\_ALIVE (c))
01793     \{
01794       *pdest++ = c ;
01795     \}
01796       \}
01797       Row [r].length = (IndexType) (pdest - &A [Row [r].start]) ;
01798 
01799     \}
01800   \}
01801   \textcolor{comment}{/* ensure we found all the rows */}
01802   COLAMD\_ASSERT (debug\_rows == 0) ;
01803 
01804   \textcolor{comment}{/* === Return the new value of pfree ==================================== */}
01805 
01806   \textcolor{keywordflow}{return} ((IndexType) (pdest - &A [0])) ;
01807 \}
01808 
01809 
01810 \textcolor{comment}{/* ========================================================================== */}
01811 \textcolor{comment}{/* === clear\_mark =========================================================== */}
01812 \textcolor{comment}{/* ========================================================================== */}
01813 
01814 \textcolor{comment}{/*}
01815 \textcolor{comment}{  Clears the Row [].shared2.mark array, and returns the new tag\_mark.}
01816 \textcolor{comment}{  Return value is the new tag\_mark.  Not user-callable.}
01817 \textcolor{comment}{*/}
01818 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
01819 \textcolor{keyword}{static} \textcolor{keyword}{inline}  IndexType clear\_mark  \textcolor{comment}{/* return the new value for tag\_mark */}
01820   (
01821       \textcolor{comment}{/* === Parameters ======================================================= */}
01822 
01823     IndexType n\_row,    \textcolor{comment}{/* number of rows in A */}
01824     Colamd\_Row<IndexType> Row [] \textcolor{comment}{/* Row [0 ... n\_row-1].shared2.mark is set to zero */}
01825     )
01826 \{
01827   \textcolor{comment}{/* === Local variables ================================================== */}
01828 
01829   IndexType r ;
01830 
01831   \textcolor{keywordflow}{for} (r = 0 ; r < n\_row ; r++)
01832   \{
01833     \textcolor{keywordflow}{if} (ROW\_IS\_ALIVE (r))
01834     \{
01835       Row [r].shared2.mark = 0 ;
01836     \}
01837   \}
01838   \textcolor{keywordflow}{return} (1) ;
01839 \}
01840 
01841 
01842 \} \textcolor{comment}{// namespace internal }
01843 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
