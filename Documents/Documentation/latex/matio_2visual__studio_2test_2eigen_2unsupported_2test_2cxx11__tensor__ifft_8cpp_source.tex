\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2test_2cxx11__tensor__ifft_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/test/cxx11\+\_\+tensor\+\_\+ifft.cpp}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2test_2cxx11__tensor__ifft_8cpp_source}\index{cxx11\+\_\+tensor\+\_\+ifft.\+cpp@{cxx11\+\_\+tensor\+\_\+ifft.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Jianwei Cui <thucjw@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 \textcolor{preprocessor}{#include <complex>}
00012 \textcolor{preprocessor}{#include <cmath>}
00013 \textcolor{preprocessor}{#include <Eigen/CXX11/Tensor>}
00014 
00015 \textcolor{keyword}{using} \hyperlink{class_eigen_1_1_tensor}{Eigen::Tensor};
00016 
00017 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} DataLayout>
00018 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_1D\_fft\_ifft\_invariant(\textcolor{keywordtype}{int} sequence\_length) \{
00019   \hyperlink{class_eigen_1_1_tensor}{Tensor<double, 1, DataLayout>} tensor(sequence\_length);
00020   tensor.setRandom();
00021 
00022   array<int, 1> fft;
00023   fft[0] = 0;
00024 
00025   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::complex<double>}, 1, DataLayout> tensor\_after\_fft;
00026   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::complex<double>}, 1, DataLayout> tensor\_after\_fft\_ifft;
00027 
00028   tensor\_after\_fft = tensor.template fft<Eigen::BothParts, Eigen::FFT\_FORWARD>(fft);
00029   tensor\_after\_fft\_ifft = tensor\_after\_fft.template fft<Eigen::BothParts, Eigen::FFT\_REVERSE>(fft);
00030 
00031   VERIFY\_IS\_EQUAL(tensor\_after\_fft.dimension(0), sequence\_length);
00032   VERIFY\_IS\_EQUAL(tensor\_after\_fft\_ifft.dimension(0), sequence\_length);
00033 
00034   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < sequence\_length; ++i) \{
00035     VERIFY\_IS\_APPROX(static\_cast<float>(tensor(i)), static\_cast<float>(std::real(tensor\_after\_fft\_ifft(i)))
      );
00036   \}
00037 \}
00038 
00039 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} DataLayout>
00040 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_2D\_fft\_ifft\_invariant(\textcolor{keywordtype}{int} dim0, \textcolor{keywordtype}{int} dim1) \{
00041   \hyperlink{class_eigen_1_1_tensor}{Tensor<double, 2, DataLayout>} tensor(dim0, dim1);
00042   tensor.setRandom();
00043 
00044   array<int, 2> fft;
00045   fft[0] = 0;
00046   fft[1] = 1;
00047 
00048   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::complex<double>}, 2, DataLayout> tensor\_after\_fft;
00049   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::complex<double>}, 2, DataLayout> tensor\_after\_fft\_ifft;
00050 
00051   tensor\_after\_fft = tensor.template fft<Eigen::BothParts, Eigen::FFT\_FORWARD>(fft);
00052   tensor\_after\_fft\_ifft = tensor\_after\_fft.template fft<Eigen::BothParts, Eigen::FFT\_REVERSE>(fft);
00053 
00054   VERIFY\_IS\_EQUAL(tensor\_after\_fft.dimension(0), dim0);
00055   VERIFY\_IS\_EQUAL(tensor\_after\_fft.dimension(1), dim1);
00056   VERIFY\_IS\_EQUAL(tensor\_after\_fft\_ifft.dimension(0), dim0);
00057   VERIFY\_IS\_EQUAL(tensor\_after\_fft\_ifft.dimension(1), dim1);
00058 
00059   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < dim0; ++i) \{
00060     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < dim1; ++j) \{
00061       \textcolor{comment}{//std::cout << "[" << i << "][" << j << "]" <<  "  Original data: " << tensor(i,j) << " Transformed
       data:" << tensor\_after\_fft\_ifft(i,j) << std::endl;}
00062       VERIFY\_IS\_APPROX(static\_cast<float>(tensor(i,j)), static\_cast<float>(std::real(tensor\_after\_fft\_ifft(
      i,j))));
00063     \}
00064   \}
00065 \}
00066 
00067 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} DataLayout>
00068 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_3D\_fft\_ifft\_invariant(\textcolor{keywordtype}{int} dim0, \textcolor{keywordtype}{int} dim1, \textcolor{keywordtype}{int} dim2) \{
00069   \hyperlink{class_eigen_1_1_tensor}{Tensor<double, 3, DataLayout>} tensor(dim0, dim1, dim2);
00070   tensor.setRandom();
00071 
00072   array<int, 3> fft;
00073   fft[0] = 0;
00074   fft[1] = 1;
00075   fft[2] = 2;
00076 
00077   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::complex<double>}, 3, DataLayout> tensor\_after\_fft;
00078   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::complex<double>}, 3, DataLayout> tensor\_after\_fft\_ifft;
00079 
00080   tensor\_after\_fft = tensor.template fft<Eigen::BothParts, Eigen::FFT\_FORWARD>(fft);
00081   tensor\_after\_fft\_ifft = tensor\_after\_fft.template fft<Eigen::BothParts, Eigen::FFT\_REVERSE>(fft);
00082 
00083   VERIFY\_IS\_EQUAL(tensor\_after\_fft.dimension(0), dim0);
00084   VERIFY\_IS\_EQUAL(tensor\_after\_fft.dimension(1), dim1);
00085   VERIFY\_IS\_EQUAL(tensor\_after\_fft.dimension(2), dim2);
00086   VERIFY\_IS\_EQUAL(tensor\_after\_fft\_ifft.dimension(0), dim0);
00087   VERIFY\_IS\_EQUAL(tensor\_after\_fft\_ifft.dimension(1), dim1);
00088   VERIFY\_IS\_EQUAL(tensor\_after\_fft\_ifft.dimension(2), dim2);
00089 
00090   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < dim0; ++i) \{
00091     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < dim1; ++j) \{
00092       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 0; k < dim2; ++k) \{
00093         VERIFY\_IS\_APPROX(static\_cast<float>(tensor(i,j,k)), static\_cast<float>(std::real(
      tensor\_after\_fft\_ifft(i,j,k))));
00094       \}
00095     \}
00096   \}
00097 \}
00098 
00099 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} DataLayout>
00100 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_sub\_fft\_ifft\_invariant(\textcolor{keywordtype}{int} dim0, \textcolor{keywordtype}{int} dim1, \textcolor{keywordtype}{int} dim2, \textcolor{keywordtype}{int} dim3) \{
00101   \hyperlink{class_eigen_1_1_tensor}{Tensor<double, 4, DataLayout>} tensor(dim0, dim1, dim2, dim3);
00102   tensor.setRandom();
00103 
00104   array<int, 2> fft;
00105   fft[0] = 2;
00106   fft[1] = 0;
00107 
00108   \hyperlink{class_eigen_1_1_tensor}{Tensor<std::complex<double>}, 4, DataLayout> tensor\_after\_fft;
00109   \hyperlink{class_eigen_1_1_tensor}{Tensor<double, 4, DataLayout>} tensor\_after\_fft\_ifft;
00110 
00111   tensor\_after\_fft = tensor.template fft<Eigen::BothParts, Eigen::FFT\_FORWARD>(fft);
00112   tensor\_after\_fft\_ifft = tensor\_after\_fft.template fft<Eigen::RealPart, Eigen::FFT\_REVERSE>(fft);
00113 
00114   VERIFY\_IS\_EQUAL(tensor\_after\_fft.dimension(0), dim0);
00115   VERIFY\_IS\_EQUAL(tensor\_after\_fft.dimension(1), dim1);
00116   VERIFY\_IS\_EQUAL(tensor\_after\_fft.dimension(2), dim2);
00117   VERIFY\_IS\_EQUAL(tensor\_after\_fft.dimension(3), dim3);
00118   VERIFY\_IS\_EQUAL(tensor\_after\_fft\_ifft.dimension(0), dim0);
00119   VERIFY\_IS\_EQUAL(tensor\_after\_fft\_ifft.dimension(1), dim1);
00120   VERIFY\_IS\_EQUAL(tensor\_after\_fft\_ifft.dimension(2), dim2);
00121   VERIFY\_IS\_EQUAL(tensor\_after\_fft\_ifft.dimension(3), dim3);
00122 
00123   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < dim0; ++i) \{
00124     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < dim1; ++j) \{
00125       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 0; k < dim2; ++k) \{
00126         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} l = 0; l < dim3; ++l) \{
00127           VERIFY\_IS\_APPROX(static\_cast<float>(tensor(i,j,k,l)), static\_cast<float>(tensor\_after\_fft\_ifft(i,
      j,k,l)));
00128         \}
00129       \}
00130     \}
00131   \}
00132 \}
00133 
00134 \textcolor{keywordtype}{void} test\_cxx11\_tensor\_ifft() \{
00135   CALL\_SUBTEST(test\_1D\_fft\_ifft\_invariant<ColMajor>(4));
00136   CALL\_SUBTEST(test\_1D\_fft\_ifft\_invariant<ColMajor>(16));
00137   CALL\_SUBTEST(test\_1D\_fft\_ifft\_invariant<ColMajor>(32));
00138   CALL\_SUBTEST(test\_1D\_fft\_ifft\_invariant<ColMajor>(1024*1024));
00139 
00140   CALL\_SUBTEST(test\_2D\_fft\_ifft\_invariant<ColMajor>(4,4));
00141   CALL\_SUBTEST(test\_2D\_fft\_ifft\_invariant<ColMajor>(8,16));
00142   CALL\_SUBTEST(test\_2D\_fft\_ifft\_invariant<ColMajor>(16,32));
00143   CALL\_SUBTEST(test\_2D\_fft\_ifft\_invariant<ColMajor>(1024,1024));
00144 
00145   CALL\_SUBTEST(test\_3D\_fft\_ifft\_invariant<ColMajor>(4,4,4));
00146   CALL\_SUBTEST(test\_3D\_fft\_ifft\_invariant<ColMajor>(8,16,32));
00147   CALL\_SUBTEST(test\_3D\_fft\_ifft\_invariant<ColMajor>(16,4,8));
00148   CALL\_SUBTEST(test\_3D\_fft\_ifft\_invariant<ColMajor>(256,256,256));
00149 
00150   CALL\_SUBTEST(test\_sub\_fft\_ifft\_invariant<ColMajor>(4,4,4,4));
00151   CALL\_SUBTEST(test\_sub\_fft\_ifft\_invariant<ColMajor>(8,16,32,64));
00152   CALL\_SUBTEST(test\_sub\_fft\_ifft\_invariant<ColMajor>(16,4,8,12));
00153   CALL\_SUBTEST(test\_sub\_fft\_ifft\_invariant<ColMajor>(64,64,64,64));
00154 \}
\end{DoxyCode}
