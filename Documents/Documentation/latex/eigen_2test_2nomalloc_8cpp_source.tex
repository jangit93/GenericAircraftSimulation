\hypertarget{eigen_2test_2nomalloc_8cpp_source}{}\section{eigen/test/nomalloc.cpp}
\label{eigen_2test_2nomalloc_8cpp_source}\index{nomalloc.\+cpp@{nomalloc.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{comment}{// discard stack allocation as that too bypasses malloc}
00012 \textcolor{preprocessor}{#define EIGEN\_STACK\_ALLOCATION\_LIMIT 0}
00013 \textcolor{comment}{// heap allocation will raise an assert if enabled at runtime}
00014 \textcolor{preprocessor}{#define EIGEN\_RUNTIME\_NO\_MALLOC}
00015 
00016 \textcolor{preprocessor}{#include "main.h"}
00017 \textcolor{preprocessor}{#include <Eigen/Cholesky>}
00018 \textcolor{preprocessor}{#include <Eigen/Eigenvalues>}
00019 \textcolor{preprocessor}{#include <Eigen/LU>}
00020 \textcolor{preprocessor}{#include <Eigen/QR>}
00021 \textcolor{preprocessor}{#include <Eigen/SVD>}
00022 
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} nomalloc(\textcolor{keyword}{const} MatrixType& m)
00024 \{
00025   \textcolor{comment}{/* this test check no dynamic memory allocation are issued with fixed-size matrices}
00026 \textcolor{comment}{  */}
00027   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00029 
00030   Index rows = m.rows();
00031   Index cols = m.cols();
00032 
00033   MatrixType m1 = MatrixType::Random(rows, cols),
00034              m2 = MatrixType::Random(rows, cols),
00035              m3(rows, cols);
00036 
00037   Scalar s1 = internal::random<Scalar>();
00038 
00039   Index r = internal::random<Index>(0, rows-1),
00040         c = internal::random<Index>(0, cols-1);
00041 
00042   VERIFY\_IS\_APPROX((m1+m2)*s1,              s1*m1+s1*m2);
00043   VERIFY\_IS\_APPROX((m1+m2)(r,c), (m1(r,c))+(m2(r,c)));
00044   VERIFY\_IS\_APPROX(m1.cwiseProduct(m1.block(0,0,rows,cols)), (m1.array()*m1.array()).matrix());
00045   VERIFY\_IS\_APPROX((m1*m1.transpose())*m2,  m1*(m1.transpose()*m2));
00046   
00047   m2.col(0).noalias() = m1 * m1.col(0);
00048   m2.col(0).noalias() -= m1.adjoint() * m1.col(0);
00049   m2.col(0).noalias() -= m1 * m1.row(0).adjoint();
00050   m2.col(0).noalias() -= m1.adjoint() * m1.row(0).adjoint();
00051 
00052   m2.row(0).noalias() = m1.row(0) * m1;
00053   m2.row(0).noalias() -= m1.row(0) * m1.adjoint();
00054   m2.row(0).noalias() -= m1.col(0).adjoint() * m1;
00055   m2.row(0).noalias() -= m1.col(0).adjoint() * m1.adjoint();
00056   VERIFY\_IS\_APPROX(m2,m2);
00057   
00058   m2.col(0).noalias() = m1.template triangularView<Upper>() * m1.col(0);
00059   m2.col(0).noalias() -= m1.adjoint().template triangularView<Upper>() * m1.col(0);
00060   m2.col(0).noalias() -= m1.template triangularView<Upper>() * m1.row(0).adjoint();
00061   m2.col(0).noalias() -= m1.adjoint().template triangularView<Upper>() * m1.row(0).adjoint();
00062 
00063   m2.row(0).noalias() = m1.row(0) * m1.template triangularView<Upper>();
00064   m2.row(0).noalias() -= m1.row(0) * m1.adjoint().template triangularView<Upper>();
00065   m2.row(0).noalias() -= m1.col(0).adjoint() * m1.template triangularView<Upper>();
00066   m2.row(0).noalias() -= m1.col(0).adjoint() * m1.adjoint().template triangularView<Upper>();
00067   VERIFY\_IS\_APPROX(m2,m2);
00068   
00069   m2.col(0).noalias() = m1.template selfadjointView<Upper>() * m1.col(0);
00070   m2.col(0).noalias() -= m1.adjoint().template selfadjointView<Upper>() * m1.col(0);
00071   m2.col(0).noalias() -= m1.template selfadjointView<Upper>() * m1.row(0).adjoint();
00072   m2.col(0).noalias() -= m1.adjoint().template selfadjointView<Upper>() * m1.row(0).adjoint();
00073 
00074   m2.row(0).noalias() = m1.row(0) * m1.template selfadjointView<Upper>();
00075   m2.row(0).noalias() -= m1.row(0) * m1.adjoint().template selfadjointView<Upper>();
00076   m2.row(0).noalias() -= m1.col(0).adjoint() * m1.template selfadjointView<Upper>();
00077   m2.row(0).noalias() -= m1.col(0).adjoint() * m1.adjoint().template selfadjointView<Upper>();
00078   VERIFY\_IS\_APPROX(m2,m2);
00079   
00080   m2.template selfadjointView<Lower>().rankUpdate(m1.col(0),-1);
00081   m2.template selfadjointView<Upper>().rankUpdate(m1.row(0),-1);
00082   m2.template selfadjointView<Lower>().rankUpdate(m1.col(0), m1.col(0)); \textcolor{comment}{// rank-2}
00083 
00084   \textcolor{comment}{// The following fancy matrix-matrix products are not safe yet regarding static allocation}
00085   m2.template selfadjointView<Lower>().rankUpdate(m1);
00086   m2 += m2.template triangularView<Upper>() * m1;
00087   m2.template triangularView<Upper>() = m2 * m2;
00088   m1 += m1.template selfadjointView<Lower>() * m2;
00089   VERIFY\_IS\_APPROX(m2,m2);
00090 \}
00091 
00092 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00093 \textcolor{keywordtype}{void} ctms\_decompositions()
00094 \{
00095   \textcolor{keyword}{const} \textcolor{keywordtype}{int} maxSize = 16;
00096   \textcolor{keyword}{const} \textcolor{keywordtype}{int} size    = 12;
00097 
00098   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Eigen::Matrix}<Scalar,
00099                         \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Eigen::Dynamic}, \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Eigen::Dynamic},
00100                         0,
00101                         maxSize, maxSize> \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix};
00102 
00103   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Eigen::Matrix}<Scalar,
00104                         \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Eigen::Dynamic}, 1,
00105                         0,
00106                         maxSize, 1> Vector;
00107 
00108   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Eigen::Matrix<std::complex<Scalar>},
00109                         \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Eigen::Dynamic}, \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Eigen::Dynamic},
00110                         0,
00111                         maxSize, maxSize> ComplexMatrix;
00112 
00113   \textcolor{keyword}{const} Matrix \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}(Matrix::Random(size, size)), \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}(Matrix::Random(size, size));
00114   Matrix X(size,size);
00115   \textcolor{keyword}{const} ComplexMatrix complexA(ComplexMatrix::Random(size, size));
00116   \textcolor{keyword}{const} Matrix saA = \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}.adjoint() * \hyperlink{group___core___module_class_eigen_1_1_matrix}{A};
00117   \textcolor{keyword}{const} Vector b(Vector::Random(size));
00118   Vector x(size);
00119 
00120   \textcolor{comment}{// Cholesky module}
00121   \hyperlink{group___cholesky___module_class_eigen_1_1_l_l_t}{Eigen::LLT<Matrix>}  \hyperlink{group___cholesky___module_class_eigen_1_1_l_l_t}{LLT};  LLT.compute(\hyperlink{group___core___module_class_eigen_1_1_matrix}{A});
00122   X = LLT.\hyperlink{group___cholesky___module_a3738bb3ce6f9b837a2beb432b937499f}{solve}(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B});
00123   x = LLT.\hyperlink{group___cholesky___module_a3738bb3ce6f9b837a2beb432b937499f}{solve}(b);
00124   \hyperlink{group___cholesky___module_class_eigen_1_1_l_d_l_t}{Eigen::LDLT<Matrix>} \hyperlink{group___cholesky___module_class_eigen_1_1_l_d_l_t}{LDLT}; LDLT.compute(\hyperlink{group___core___module_class_eigen_1_1_matrix}{A});
00125   X = LDLT.\hyperlink{group___cholesky___module_aa257dd7a8acf8b347d5a22a13d6ca3e1}{solve}(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B});
00126   x = LDLT.\hyperlink{group___cholesky___module_aa257dd7a8acf8b347d5a22a13d6ca3e1}{solve}(b);
00127 
00128   \textcolor{comment}{// Eigenvalues module}
00129   \hyperlink{group___eigenvalues___module_class_eigen_1_1_hessenberg_decomposition}{Eigen::HessenbergDecomposition<ComplexMatrix>} hessDecomp;   
           hessDecomp.\hyperlink{group___eigenvalues___module_a239a6fd42c57aab3c0b048c47fde3004}{compute}(complexA);
00130   \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_schur}{Eigen::ComplexSchur<ComplexMatrix>}            cSchur(size);      cSchur
      .compute(complexA);
00131   \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_eigen_solver}{Eigen::ComplexEigenSolver<ComplexMatrix>}      cEigSolver;        
      cEigSolver.\hyperlink{group___eigenvalues___module_aeb7e38c6db5369f5c974f3786e94c1f0}{compute}(complexA);
00132   \hyperlink{group___eigenvalues___module_class_eigen_1_1_eigen_solver}{Eigen::EigenSolver<Matrix>}                    eigSolver;         eigSolver.
      \hyperlink{group___eigenvalues___module_a38d032b75b3e75640e3db42e7ab20c24}{compute}(\hyperlink{group___core___module_class_eigen_1_1_matrix}{A});
00133   \hyperlink{group___eigenvalues___module_class_eigen_1_1_self_adjoint_eigen_solver}{Eigen::SelfAdjointEigenSolver<Matrix>}         saEigSolver(size); 
      saEigSolver.compute(saA);
00134   \hyperlink{group___eigenvalues___module_class_eigen_1_1_tridiagonalization}{Eigen::Tridiagonalization<Matrix>}             tridiag;           tridiag
      .\hyperlink{group___eigenvalues___module_acd288abb081d3b40b87e4b98cd8f6ee9}{compute}(saA);
00135 
00136   \textcolor{comment}{// LU module}
00137   \hyperlink{group___l_u___module_class_eigen_1_1_partial_piv_l_u}{Eigen::PartialPivLU<Matrix>} ppLU; ppLU.compute(\hyperlink{group___core___module_class_eigen_1_1_matrix}{A});
00138   X = ppLU.\hyperlink{group___l_u___module_a49247bd2f742a46bca1f9c2bf1b19ad8}{solve}(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B});
00139   x = ppLU.\hyperlink{group___l_u___module_a49247bd2f742a46bca1f9c2bf1b19ad8}{solve}(b);
00140   \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{Eigen::FullPivLU<Matrix>}    fpLU; fpLU.\hyperlink{group___l_u___module_a0a3c3b1bbafa31a03567a4573ebabc79}{compute}(
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{A});
00141   X = fpLU.\hyperlink{group___l_u___module_af563471f6f3283fd10779ef02dd0b748}{solve}(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B});
00142   x = fpLU.\hyperlink{group___l_u___module_af563471f6f3283fd10779ef02dd0b748}{solve}(b);
00143 
00144   \textcolor{comment}{// QR module}
00145   \hyperlink{group___q_r___module_class_eigen_1_1_householder_q_r}{Eigen::HouseholderQR<Matrix>}        hQR;  hQR.compute(
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{A});
00146   X = hQR.\hyperlink{group___q_r___module_a3e8e56769bbaaed0616ad98c4ff99c7b}{solve}(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B});
00147   x = hQR.\hyperlink{group___q_r___module_a3e8e56769bbaaed0616ad98c4ff99c7b}{solve}(b);
00148   \hyperlink{group___q_r___module_class_eigen_1_1_col_piv_householder_q_r}{Eigen::ColPivHouseholderQR<Matrix>}  cpQR; cpQR.compute(
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{A});
00149   X = cpQR.\hyperlink{group___q_r___module_aaa9c4af89930ab3bb7612ed9ae33d3f5}{solve}(\hyperlink{group___core___module_class_eigen_1_1_matrix}{B});
00150   x = cpQR.\hyperlink{group___q_r___module_aaa9c4af89930ab3bb7612ed9ae33d3f5}{solve}(b);
00151   \hyperlink{group___q_r___module_class_eigen_1_1_full_piv_householder_q_r}{Eigen::FullPivHouseholderQR<Matrix>} fpQR; fpQR.compute(
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{A});
00152   \textcolor{comment}{// FIXME X = fpQR.solve(B);}
00153   x = fpQR.\hyperlink{group___q_r___module_a6f1b0a116c78e642e3d2a100a29d1a4a}{solve}(b);
00154 
00155   \textcolor{comment}{// SVD module}
00156   \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{Eigen::JacobiSVD<Matrix>} jSVD; jSVD.\hyperlink{group___s_v_d___module_a5dab376cc86cf0d36674bcdad4af3f5a}{compute}(\hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, 
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a2b4f91ca5859a4159dbfe8090043817f}{ComputeFullU} | \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a52c6f7e80bbf9a42297c88f700245b51}{ComputeFullV});
00157 \}
00158 
00159 \textcolor{keywordtype}{void} test\_zerosized() \{
00160   \textcolor{comment}{// default constructors:}
00161   Eigen::MatrixXd \hyperlink{group___core___module_class_eigen_1_1_matrix}{A};
00162   Eigen::VectorXd v;
00163   \textcolor{comment}{// explicit zero-sized:}
00164   Eigen::ArrayXXd A0(0,0);
00165   Eigen::ArrayXd v0(0);
00166 
00167   \textcolor{comment}{// assigning empty objects to each other:}
00168   A=A0;
00169   v=v0;
00170 \}
00171 
00172 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} test\_reference(\textcolor{keyword}{const} MatrixType& m) \{
00173   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00174   \textcolor{keyword}{enum} \{ Flag          =  MatrixType::IsRowMajor ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{Eigen::RowMajor} : 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{Eigen::ColMajor}\};
00175   \textcolor{keyword}{enum} \{ TransposeFlag = !MatrixType::IsRowMajor ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{Eigen::RowMajor} : 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{Eigen::ColMajor}\};
00176   \textcolor{keyword}{typename} MatrixType::Index rows = m.rows(), cols=m.cols();
00177   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, Flag         >}
       MatrixX;
00178   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, TransposeFlag>}
       MatrixXT;
00179   \textcolor{comment}{// Dynamic reference:}
00180   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Eigen::Ref<const MatrixX  >} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref};
00181   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Eigen::Ref<const MatrixXT >} RefT;
00182 
00183   Ref r1(m);
00184   Ref r2(m.block(rows/3, cols/4, rows/2, cols/2));
00185   RefT r3(m.transpose());
00186   RefT r4(m.topLeftCorner(rows/2, cols/2).transpose());
00187 
00188   VERIFY\_RAISES\_ASSERT(RefT r5(m));
00189   VERIFY\_RAISES\_ASSERT(Ref r6(m.transpose()));
00190   VERIFY\_RAISES\_ASSERT(Ref r7(Scalar(2) * m));
00191 
00192   \textcolor{comment}{// Copy constructors shall also never malloc}
00193   Ref r8 = r1;
00194   RefT r9 = r3;
00195 
00196   \textcolor{comment}{// Initializing from a compatible Ref shall also never malloc}
00197   \hyperlink{group___core___module_class_eigen_1_1_ref}{Eigen::Ref<const MatrixX, Unaligned, Stride<Dynamic, Dynamic>}
       > r10=r8, r11=m;
00198 
00199   \textcolor{comment}{// Initializing from an incompatible Ref will malloc:}
00200   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Eigen::Ref<const MatrixX, Aligned>} RefAligned;
00201   VERIFY\_RAISES\_ASSERT(RefAligned r12=r10);
00202   VERIFY\_RAISES\_ASSERT(Ref r13=r10); \textcolor{comment}{// r10 has more dynamic strides}
00203 
00204 \}
00205 
00206 \textcolor{keywordtype}{void} test\_nomalloc()
00207 \{
00208   \textcolor{comment}{// create some dynamic objects}
00209   Eigen::MatrixXd M1 = MatrixXd::Random(3,3);
00210   \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const MatrixXd>} R1 = 2.0*M1; \textcolor{comment}{// Ref requires temporary}
00211 
00212   \textcolor{comment}{// from here on prohibit malloc:}
00213   Eigen::internal::set\_is\_malloc\_allowed(\textcolor{keyword}{false});
00214 
00215   \textcolor{comment}{// check that our operator new is indeed called:}
00216   VERIFY\_RAISES\_ASSERT(MatrixXd dummy(MatrixXd::Random(3,3)));
00217   CALL\_SUBTEST\_1(nomalloc(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00218   CALL\_SUBTEST\_2(nomalloc(Matrix4d()) );
00219   CALL\_SUBTEST\_3(nomalloc(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,32,32>}()) );
00220   
00221   \textcolor{comment}{// Check decomposition modules with dynamic matrices that have a known compile-time max size (ctms)}
00222   CALL\_SUBTEST\_4(ctms\_decompositions<float>());
00223 
00224   CALL\_SUBTEST\_5(test\_zerosized());
00225 
00226   CALL\_SUBTEST\_6(test\_reference(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,32,32>}()));
00227   CALL\_SUBTEST\_7(test\_reference(R1));
00228   CALL\_SUBTEST\_8(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<MatrixXd>} R2 = M1.topRows<2>(); test\_reference(R2));
00229 \}
\end{DoxyCode}
