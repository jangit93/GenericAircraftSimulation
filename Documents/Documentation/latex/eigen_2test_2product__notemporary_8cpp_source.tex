\hypertarget{eigen_2test_2product__notemporary_8cpp_source}{}\section{eigen/test/product\+\_\+notemporary.cpp}
\label{eigen_2test_2product__notemporary_8cpp_source}\index{product\+\_\+notemporary.\+cpp@{product\+\_\+notemporary.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#define TEST\_ENABLE\_TEMPORARY\_TRACKING}
00011 
00012 \textcolor{preprocessor}{#include "main.h"}
00013 
00014 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} product\_notemporary(\textcolor{keyword}{const} MatrixType& m)
00015 \{
00016   \textcolor{comment}{/* This test checks the number of temporaries created}
00017 \textcolor{comment}{   * during the evaluation of a complex expression */}
00018   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00019   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00020   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00021   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, 1, Dynamic>} RowVectorType;
00022   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>} ColVectorType;
00023   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, Dynamic, ColMajor>} 
      ColMajorMatrixType;
00024   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, Dynamic, RowMajor>} 
      RowMajorMatrixType;
00025 
00026   Index rows = m.rows();
00027   Index cols = m.cols();
00028 
00029   ColMajorMatrixType m1 = MatrixType::Random(rows, cols),
00030                      m2 = MatrixType::Random(rows, cols),
00031                      m3(rows, cols);
00032   RowVectorType rv1 = RowVectorType::Random(rows), rvres(rows);
00033   ColVectorType cv1 = ColVectorType::Random(cols), cvres(cols);
00034   RowMajorMatrixType rm3(rows, cols);
00035 
00036   Scalar s1 = internal::random<Scalar>(),
00037          s2 = internal::random<Scalar>(),
00038          s3 = internal::random<Scalar>();
00039 
00040   Index c0 = internal::random<Index>(4,cols-8),
00041         c1 = internal::random<Index>(8,cols-c0),
00042         r0 = internal::random<Index>(4,cols-8),
00043         r1 = internal::random<Index>(8,rows-r0);
00044 
00045   VERIFY\_EVALUATION\_COUNT( m3 = (m1 * m2.adjoint()), 1);
00046   VERIFY\_EVALUATION\_COUNT( m3 = (m1 * m2.adjoint()).transpose(), 1);
00047   VERIFY\_EVALUATION\_COUNT( m3.noalias() = m1 * m2.adjoint(), 0);
00048 
00049   VERIFY\_EVALUATION\_COUNT( m3 = s1 * (m1 * m2.transpose()), 1);
00050 \textcolor{comment}{//   VERIFY\_EVALUATION\_COUNT( m3 = m3 + s1 * (m1 * m2.transpose()), 1);}
00051   VERIFY\_EVALUATION\_COUNT( m3.noalias() = s1 * (m1 * m2.transpose()), 0);
00052 
00053   VERIFY\_EVALUATION\_COUNT( m3 = m3 + (m1 * m2.adjoint()), 1);
00054   VERIFY\_EVALUATION\_COUNT( m3 = m3 - (m1 * m2.adjoint()), 1);
00055 
00056   VERIFY\_EVALUATION\_COUNT( m3 = m3 + (m1 * m2.adjoint()).transpose(), 1);
00057   VERIFY\_EVALUATION\_COUNT( m3.noalias() = m3 + m1 * m2.transpose(), 0);
00058   VERIFY\_EVALUATION\_COUNT( m3.noalias() += m3 + m1 * m2.transpose(), 0);
00059   VERIFY\_EVALUATION\_COUNT( m3.noalias() -= m3 + m1 * m2.transpose(), 0);
00060   VERIFY\_EVALUATION\_COUNT( m3.noalias() =  m3 - m1 * m2.transpose(), 0);
00061   VERIFY\_EVALUATION\_COUNT( m3.noalias() += m3 - m1 * m2.transpose(), 0);
00062   VERIFY\_EVALUATION\_COUNT( m3.noalias() -= m3 - m1 * m2.transpose(), 0);
00063 
00064   VERIFY\_EVALUATION\_COUNT( m3.noalias() = s1 * m1 * s2 * m2.adjoint(), 0);
00065   VERIFY\_EVALUATION\_COUNT( m3.noalias() = s1 * m1 * s2 * (m1*s3+m2*s2).adjoint(), 1);
00066   VERIFY\_EVALUATION\_COUNT( m3.noalias() = (s1 * m1).adjoint() * s2 * m2, 0);
00067   VERIFY\_EVALUATION\_COUNT( m3.noalias() += s1 * (-m1*s3).adjoint() * (s2 * m2 * s3), 0);
00068   VERIFY\_EVALUATION\_COUNT( m3.noalias() -= s1 * (m1.transpose() * m2), 0);
00069 
00070   VERIFY\_EVALUATION\_COUNT(( m3.block(r0,r0,r1,r1).noalias() += -m1.block(r0,c0,r1,c1) * (s2*m2.block(r0,c0,
      r1,c1)).adjoint() ), 0);
00071   VERIFY\_EVALUATION\_COUNT(( m3.block(r0,r0,r1,r1).noalias() -= s1 * m1.block(r0,c0,r1,c1) * m2.block(c0,r0,
      c1,r1) ), 0);
00072 
00073   \textcolor{comment}{// NOTE this is because the Block expression is not handled yet by our expression analyser}
00074   VERIFY\_EVALUATION\_COUNT(( m3.block(r0,r0,r1,r1).noalias() = s1 * m1.block(r0,c0,r1,c1) * (s1*m2).block(c0
      ,r0,c1,r1) ), 1);
00075 
00076   VERIFY\_EVALUATION\_COUNT( m3.noalias() -= (s1 * m1).\textcolor{keyword}{template} triangularView<Lower>() * m2, 0);
00077   VERIFY\_EVALUATION\_COUNT( rm3.noalias() = (s1 * m1.adjoint()).\textcolor{keyword}{template} triangularView<Upper>() * (m2+m2), 
      1);
00078   VERIFY\_EVALUATION\_COUNT( rm3.noalias() = (s1 * m1.adjoint()).\textcolor{keyword}{template} triangularView<UnitUpper>() * m2.
      adjoint(), 0);
00079 
00080   VERIFY\_EVALUATION\_COUNT( m3.template triangularView<Upper>() = (m1 * m2.adjoint()), 0);
00081   VERIFY\_EVALUATION\_COUNT( m3.template triangularView<Upper>() -= (m1 * m2.adjoint()), 0);
00082 
00083   \textcolor{comment}{// NOTE this is because the blas\_traits require innerstride==1 to avoid a temporary, but that doesn't
       seem to be actually needed for the triangular products}
00084   VERIFY\_EVALUATION\_COUNT( rm3.col(c0).noalias() = (s1 * m1.adjoint()).\textcolor{keyword}{template} triangularView<UnitUpper>()
       * (s2*m2.row(c0)).adjoint(), 1);
00085 
00086   VERIFY\_EVALUATION\_COUNT( m1.template triangularView<Lower>().solveInPlace(m3), 0);
00087   VERIFY\_EVALUATION\_COUNT( m1.adjoint().template triangularView<Lower>().solveInPlace(m3.transpose()), 0);
00088 
00089   VERIFY\_EVALUATION\_COUNT( m3.noalias() -= (s1 * m1).adjoint().template selfadjointView<Lower>() * (-m2*s3)
      .adjoint(), 0);
00090   VERIFY\_EVALUATION\_COUNT( m3.noalias() = s2 * m2.adjoint() * (s1 * m1.adjoint()).\textcolor{keyword}{template} 
      selfadjointView<Upper>(), 0);
00091   VERIFY\_EVALUATION\_COUNT( rm3.noalias() = (s1 * m1.adjoint()).\textcolor{keyword}{template} selfadjointView<Lower>() * m2.
      adjoint(), 0);
00092 
00093   \textcolor{comment}{// NOTE this is because the blas\_traits require innerstride==1 to avoid a temporary, but that doesn't
       seem to be actually needed for the triangular products}
00094   VERIFY\_EVALUATION\_COUNT( m3.col(c0).noalias() = (s1 * m1).adjoint().template selfadjointView<Lower>() * (
      -m2.row(c0)*s3).adjoint(), 1);
00095   VERIFY\_EVALUATION\_COUNT( m3.col(c0).noalias() -= (s1 * m1).adjoint().template selfadjointView<Upper>() * 
      (-m2.row(c0)*s3).adjoint(), 1);
00096 
00097   VERIFY\_EVALUATION\_COUNT( m3.block(r0,c0,r1,c1).noalias() += m1.block(r0,r0,r1,r1).template 
      selfadjointView<Upper>() * (s1*m2.block(r0,c0,r1,c1)), 0);
00098   VERIFY\_EVALUATION\_COUNT( m3.block(r0,c0,r1,c1).noalias() = m1.block(r0,r0,r1,r1).template 
      selfadjointView<Upper>() * m2.block(r0,c0,r1,c1), 0);
00099 
00100   VERIFY\_EVALUATION\_COUNT( m3.template selfadjointView<Lower>().rankUpdate(m2.adjoint()), 0);
00101 
00102   \textcolor{comment}{// Here we will get 1 temporary for each resize operation of the lhs operator; resize(r1,c1) would lead
       to zero temporaries}
00103   m3.resize(1,1);
00104   VERIFY\_EVALUATION\_COUNT( m3.noalias() = m1.block(r0,r0,r1,r1).template selfadjointView<Lower>() * m2.
      block(r0,c0,r1,c1), 1);
00105   m3.resize(1,1);
00106   VERIFY\_EVALUATION\_COUNT( m3.noalias() = m1.block(r0,r0,r1,r1).template triangularView<UnitUpper>()  * m2.
      block(r0,c0,r1,c1), 1);
00107 
00108   \textcolor{comment}{// Zero temporaries for lazy products ...}
00109   VERIFY\_EVALUATION\_COUNT( Scalar tmp = 0; tmp += Scalar(RealScalar(1)) /  (m3.transpose().lazyProduct(m3))
      .diagonal().sum(), 0 );
00110 
00111   \textcolor{comment}{// ... and even no temporary for even deeply (>=2) nested products}
00112   VERIFY\_EVALUATION\_COUNT( Scalar tmp = 0; tmp += Scalar(RealScalar(1)) /  (m3.transpose() * m3).diagonal()
      .sum(), 0 );
00113   VERIFY\_EVALUATION\_COUNT( Scalar tmp = 0; tmp += Scalar(RealScalar(1)) /  (m3.transpose() * m3).diagonal()
      .array().abs().sum(), 0 );
00114 
00115   \textcolor{comment}{// Zero temporaries for ... CoeffBasedProductMode}
00116   VERIFY\_EVALUATION\_COUNT( m3.col(0).template head<5>() * m3.col(0).transpose() + m3.col(0).template 
      head<5>() * m3.col(0).transpose(), 0 );
00117 
00118   \textcolor{comment}{// Check matrix * vectors}
00119   VERIFY\_EVALUATION\_COUNT( cvres.noalias() = m1 * cv1, 0 );
00120   VERIFY\_EVALUATION\_COUNT( cvres.noalias() -= m1 * cv1, 0 );
00121   VERIFY\_EVALUATION\_COUNT( cvres.noalias() -= m1 * m2.col(0), 0 );
00122   VERIFY\_EVALUATION\_COUNT( cvres.noalias() -= m1 * rv1.adjoint(), 0 );
00123   VERIFY\_EVALUATION\_COUNT( cvres.noalias() -= m1 * m2.row(0).transpose(), 0 );
00124 
00125   VERIFY\_EVALUATION\_COUNT( cvres.noalias() = (m1+m1) * cv1, 0 );
00126   VERIFY\_EVALUATION\_COUNT( cvres.noalias() = (rm3+rm3) * cv1, 0 );
00127   VERIFY\_EVALUATION\_COUNT( cvres.noalias() = (m1+m1) * (m1*cv1), 1 );
00128   VERIFY\_EVALUATION\_COUNT( cvres.noalias() = (rm3+rm3) * (m1*cv1), 1 );
00129 
00130   \textcolor{comment}{// Check outer products}
00131   m3 = cv1 * rv1;
00132   VERIFY\_EVALUATION\_COUNT( m3.noalias() = cv1 * rv1, 0 );
00133   VERIFY\_EVALUATION\_COUNT( m3.noalias() = (cv1+cv1) * (rv1+rv1), 1 );
00134   VERIFY\_EVALUATION\_COUNT( m3.noalias() = (m1*cv1) * (rv1), 1 );
00135   VERIFY\_EVALUATION\_COUNT( m3.noalias() += (m1*cv1) * (rv1), 1 );
00136   VERIFY\_EVALUATION\_COUNT( rm3.noalias() = (cv1) * (rv1 * m1), 1 );
00137   VERIFY\_EVALUATION\_COUNT( rm3.noalias() -= (cv1) * (rv1 * m1), 1 );
00138   VERIFY\_EVALUATION\_COUNT( rm3.noalias() = (m1*cv1) * (rv1 * m1), 2 );
00139   VERIFY\_EVALUATION\_COUNT( rm3.noalias() += (m1*cv1) * (rv1 * m1), 2 );
00140 
00141   \textcolor{comment}{// Check nested products}
00142   VERIFY\_EVALUATION\_COUNT( cvres.noalias() = m1.adjoint() * m1 * cv1, 1 );
00143   VERIFY\_EVALUATION\_COUNT( rvres.noalias() = rv1 * (m1 * m2.adjoint()), 1 );
00144 \}
00145 
00146 \textcolor{keywordtype}{void} test\_product\_notemporary()
00147 \{
00148   \textcolor{keywordtype}{int} s;
00149   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00150     s = internal::random<int>(16,EIGEN\_TEST\_MAX\_SIZE);
00151     CALL\_SUBTEST\_1( product\_notemporary(MatrixXf(s, s)) );
00152     CALL\_SUBTEST\_2( product\_notemporary(MatrixXd(s, s)) );
00153     TEST\_SET\_BUT\_UNUSED\_VARIABLE(s)
00154     
00155     s = internal::random<int>(16,EIGEN\_TEST\_MAX\_SIZE/2);
00156     CALL\_SUBTEST\_3( product\_notemporary(MatrixXcf(s,s)) );
00157     CALL\_SUBTEST\_4( product\_notemporary(MatrixXcd(s,s)) );
00158     TEST\_SET\_BUT\_UNUSED\_VARIABLE(s)
00159   \}
00160 \}
\end{DoxyCode}
