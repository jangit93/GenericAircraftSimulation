\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_custom_op_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Custom\+Op.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_custom_op_8h_source}\index{Tensor\+Custom\+Op.\+h@{Tensor\+Custom\+Op.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_CUSTOM\_OP\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_CUSTOM\_OP\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomUnaryFunc, \textcolor{keyword}{typename} XprType>
00024 \textcolor{keyword}{struct }traits<TensorCustomUnaryOp<CustomUnaryFunc, XprType> >
00025 \{
00026   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00027   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::StorageKind StorageKind;
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<Nested>::type \_Nested;
00031   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = traits<XprType>::NumDimensions;
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = traits<XprType>::Layout;
00033 \};
00034 
00035 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomUnaryFunc, \textcolor{keyword}{typename} XprType>
00036 \textcolor{keyword}{struct }eval<TensorCustomUnaryOp<CustomUnaryFunc, XprType>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00037 \{
00038   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorCustomUnaryOp<CustomUnaryFunc, XprType>& type;
00039 \};
00040 
00041 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomUnaryFunc, \textcolor{keyword}{typename} XprType>
00042 \textcolor{keyword}{struct }nested<TensorCustomUnaryOp<CustomUnaryFunc, XprType> >
00043 \{
00044   \textcolor{keyword}{typedef} TensorCustomUnaryOp<CustomUnaryFunc, XprType> type;
00045 \};
00046 
00047 \}  \textcolor{comment}{// end namespace internal}
00048 
00049 
00050 
00051 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomUnaryFunc, \textcolor{keyword}{typename} XprType>
00052 \textcolor{keyword}{class }TensorCustomUnaryOp : \textcolor{keyword}{public} TensorBase<TensorCustomUnaryOp<CustomUnaryFunc, XprType>, ReadOnlyAccess
      ors>
00053 \{
00054   \textcolor{keyword}{public}:
00055   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<TensorCustomUnaryOp>::Scalar Scalar;
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::nested<TensorCustomUnaryOp>::type Nested;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<TensorCustomUnaryOp>::StorageKind StorageKind;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<TensorCustomUnaryOp>::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00061 
00062   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorCustomUnaryOp(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} CustomUnaryFunc& 
      \hyperlink{structfunc}{func})
00063       : m\_expr(expr), m\_func(func) \{\}
00064 
00065   EIGEN\_DEVICE\_FUNC
00066   \textcolor{keyword}{const} CustomUnaryFunc& \hyperlink{structfunc}{func}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_func; \}
00067 
00068   EIGEN\_DEVICE\_FUNC
00069   \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type&
00070   expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_expr; \}
00071 
00072   \textcolor{keyword}{protected}:
00073     \textcolor{keyword}{typename} XprType::Nested m\_expr;
00074     \textcolor{keyword}{const} CustomUnaryFunc m\_func;
00075 \};
00076 
00077 
00078 \textcolor{comment}{// Eval as rvalue}
00079 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomUnaryFunc, \textcolor{keyword}{typename} XprType, \textcolor{keyword}{typename} Device>
00080 \textcolor{keyword}{struct }TensorEvaluator<const TensorCustomUnaryOp<CustomUnaryFunc, XprType>, Device>
00081 \{
00082   \textcolor{keyword}{typedef} TensorCustomUnaryOp<CustomUnaryFunc, XprType> ArgType;
00083   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<ArgType>::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00084   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::traits<ArgType>::NumDimensions;
00085   \textcolor{keyword}{typedef} DSizes<Index, NumDims> Dimensions;
00086   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<typename ArgType::Scalar>::type Scalar;
00087   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<typename XprType::CoeffReturnType>::type CoeffReturnType;
00088   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00089   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = internal::unpacket\_traits<PacketReturnType>::size;
00090 
00091   \textcolor{keyword}{enum} \{
00092     IsAligned = \textcolor{keyword}{false},
00093     PacketAccess = (internal::packet\_traits<Scalar>::size > 1),
00094     BlockAccess = \textcolor{keyword}{false},
00095     Layout = TensorEvaluator<XprType, Device>::Layout,
00096     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00097     RawAccess = \textcolor{keyword}{false}
00098   \};
00099 
00100   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} ArgType& op, \textcolor{keyword}{const} Device& device)
00101       : m\_op(op), m\_device(device), m\_result(NULL)
00102   \{
00103     m\_dimensions = op.func().dimensions(op.expression());
00104   \}
00105 
00106   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00107 
00108   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(CoeffReturnType* data) \{
00109     \textcolor{keywordflow}{if} (data) \{
00110       evalTo(data);
00111       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00112     \} \textcolor{keywordflow}{else} \{
00113       m\_result = \textcolor{keyword}{static\_cast<}CoeffReturnType*\textcolor{keyword}{>}(
00114           m\_device.allocate(dimensions().TotalSize() * \textcolor{keyword}{sizeof}(Scalar)));
00115       evalTo(m\_result);
00116       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00117     \}
00118   \}
00119 
00120   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00121     \textcolor{keywordflow}{if} (m\_result != NULL) \{
00122       m\_device.deallocate(m\_result);
00123       m\_result = NULL;
00124     \}
00125   \}
00126 
00127   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const }\{
00128     \textcolor{keywordflow}{return} m\_result[index];
00129   \}
00130 
00131   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00132   EIGEN\_DEVICE\_FUNC PacketReturnType packet(Index index)\textcolor{keyword}{ const }\{
00133     \textcolor{keywordflow}{return} internal::ploadt<PacketReturnType, LoadMode>(m\_result + index);
00134   \}
00135 
00136   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorOpCost costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00137     \textcolor{comment}{// TODO(rmlarsen): Extend CustomOp API to return its cost estimate.}
00138     \textcolor{keywordflow}{return} TensorOpCost(\textcolor{keyword}{sizeof}(CoeffReturnType), 0, 0, vectorized, PacketSize);
00139   \}
00140 
00141   EIGEN\_DEVICE\_FUNC CoeffReturnType* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_result; \}
00142 
00143  \textcolor{keyword}{protected}:
00144   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} evalTo(Scalar* data) \{
00145     TensorMap<Tensor<CoeffReturnType, NumDims, Layout, Index> > result(
00146         data, m\_dimensions);
00147     m\_op.func().eval(m\_op.expression(), result, m\_device);
00148   \}
00149 
00150   Dimensions m\_dimensions;
00151   \textcolor{keyword}{const} ArgType m\_op;
00152   \textcolor{keyword}{const} Device& m\_device;
00153   CoeffReturnType* m\_result;
00154 \};
00155 
00156 
00157 
00165 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00166 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomBinaryFunc, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
00167 \textcolor{keyword}{struct }traits<TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> >
00168 \{
00169   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::promote\_storage\_type<\textcolor{keyword}{typename} LhsXprType::Scalar,
00170                                                   \textcolor{keyword}{typename} RhsXprType::Scalar>::ret Scalar;
00171   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::promote\_storage\_type<\textcolor{keyword}{typename} LhsXprType::CoeffReturnType,
00172                                                   \textcolor{keyword}{typename} RhsXprType::CoeffReturnType>::ret 
      CoeffReturnType;
00173   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} promote\_storage\_type<typename traits<LhsXprType>::StorageKind,
00174                                         \textcolor{keyword}{typename} traits<RhsXprType>::StorageKind>::ret StorageKind;
00175   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} promote\_index\_type<typename traits<LhsXprType>::Index,
00176                                       \textcolor{keyword}{typename} traits<RhsXprType>::Index>::type 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00177   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsXprType::Nested LhsNested;
00178   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsXprType::Nested RhsNested;
00179   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<LhsNested>::type \_LhsNested;
00180   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<RhsNested>::type \_RhsNested;
00181   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = traits<LhsXprType>::NumDimensions;
00182   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = traits<LhsXprType>::Layout;
00183 \};
00184 
00185 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomBinaryFunc, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
00186 \textcolor{keyword}{struct }eval<TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>, 
      \hyperlink{namespace_eigen}{Eigen}::Dense>
00187 \{
00188   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>& type;
00189 \};
00190 
00191 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomBinaryFunc, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
00192 \textcolor{keyword}{struct }nested<TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> >
00193 \{
00194   \textcolor{keyword}{typedef} TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> type;
00195 \};
00196 
00197 \}  \textcolor{comment}{// end namespace internal}
00198 
00199 
00200 
00201 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomBinaryFunc, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
00202 \textcolor{keyword}{class }TensorCustomBinaryOp : \textcolor{keyword}{public} TensorBase<TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprTyp
      e>, ReadOnlyAccessors>
00203 \{
00204   \textcolor{keyword}{public}:
00205   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<TensorCustomBinaryOp>::Scalar Scalar;
00206   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00207   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<TensorCustomBinaryOp>::CoeffReturnType CoeffReturnType;
00208   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::nested<TensorCustomBinaryOp>::type Nested;
00209   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<TensorCustomBinaryOp>::StorageKind StorageKind;
00210   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<TensorCustomBinaryOp>::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00211 
00212   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorCustomBinaryOp(\textcolor{keyword}{const} LhsXprType& lhs, \textcolor{keyword}{const} RhsXprType& rhs, \textcolor{keyword}{
      const} CustomBinaryFunc& \hyperlink{structfunc}{func})
00213 
00214       : m\_lhs\_xpr(lhs), m\_rhs\_xpr(rhs), m\_func(func) \{\}
00215 
00216   EIGEN\_DEVICE\_FUNC
00217   \textcolor{keyword}{const} CustomBinaryFunc& \hyperlink{structfunc}{func}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_func; \}
00218 
00219   EIGEN\_DEVICE\_FUNC
00220   \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename LhsXprType::Nested>::type&
00221   lhsExpression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhs\_xpr; \}
00222 
00223   EIGEN\_DEVICE\_FUNC
00224   \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename RhsXprType::Nested>::type&
00225   rhsExpression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rhs\_xpr; \}
00226 
00227   \textcolor{keyword}{protected}:
00228     \textcolor{keyword}{typename} LhsXprType::Nested m\_lhs\_xpr;
00229     \textcolor{keyword}{typename} RhsXprType::Nested m\_rhs\_xpr;
00230     \textcolor{keyword}{const} CustomBinaryFunc m\_func;
00231 \};
00232 
00233 
00234 \textcolor{comment}{// Eval as rvalue}
00235 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomBinaryFunc, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType, \textcolor{keyword}{typename} Device>
00236 \textcolor{keyword}{struct }TensorEvaluator<const TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>, Device>
00237 \{
00238   \textcolor{keyword}{typedef} TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> XprType;
00239   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<XprType>::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00240   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::traits<XprType>::NumDimensions;
00241   \textcolor{keyword}{typedef} DSizes<Index, NumDims> Dimensions;
00242   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00243   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<typename XprType::CoeffReturnType>::type CoeffReturnType;
00244   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00245   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = internal::unpacket\_traits<PacketReturnType>::size;
00246 
00247   \textcolor{keyword}{enum} \{
00248     IsAligned = \textcolor{keyword}{false},
00249     PacketAccess = (internal::packet\_traits<Scalar>::size > 1),
00250     BlockAccess = \textcolor{keyword}{false},
00251     Layout = TensorEvaluator<LhsXprType, Device>::Layout,
00252     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00253     RawAccess = \textcolor{keyword}{false}
00254   \};
00255 
00256   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00257       : m\_op(op), m\_device(device), m\_result(NULL)
00258   \{
00259     m\_dimensions = op.func().dimensions(op.lhsExpression(), op.rhsExpression());
00260   \}
00261 
00262   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00263 
00264   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(CoeffReturnType* data) \{
00265     \textcolor{keywordflow}{if} (data) \{
00266       evalTo(data);
00267       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00268     \} \textcolor{keywordflow}{else} \{
00269       m\_result = \textcolor{keyword}{static\_cast<}Scalar *\textcolor{keyword}{>}(m\_device.allocate(dimensions().TotalSize() * \textcolor{keyword}{sizeof}(Scalar)));
00270       evalTo(m\_result);
00271       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00272     \}
00273   \}
00274 
00275   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00276     \textcolor{keywordflow}{if} (m\_result != NULL) \{
00277       m\_device.deallocate(m\_result);
00278       m\_result = NULL;
00279     \}
00280   \}
00281 
00282   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const }\{
00283     \textcolor{keywordflow}{return} m\_result[index];
00284   \}
00285 
00286   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00287   EIGEN\_DEVICE\_FUNC PacketReturnType packet(Index index)\textcolor{keyword}{ const }\{
00288     \textcolor{keywordflow}{return} internal::ploadt<PacketReturnType, LoadMode>(m\_result + index);
00289   \}
00290 
00291   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorOpCost costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00292     \textcolor{comment}{// TODO(rmlarsen): Extend CustomOp API to return its cost estimate.}
00293     \textcolor{keywordflow}{return} TensorOpCost(\textcolor{keyword}{sizeof}(CoeffReturnType), 0, 0, vectorized, PacketSize);
00294   \}
00295 
00296   EIGEN\_DEVICE\_FUNC CoeffReturnType* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_result; \}
00297 
00298  \textcolor{keyword}{protected}:
00299   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} evalTo(Scalar* data) \{
00300     TensorMap<Tensor<Scalar, NumDims, Layout> > result(data, m\_dimensions);
00301     m\_op.func().eval(m\_op.lhsExpression(), m\_op.rhsExpression(), result, m\_device);
00302   \}
00303 
00304   Dimensions m\_dimensions;
00305   \textcolor{keyword}{const} XprType m\_op;
00306   \textcolor{keyword}{const} Device& m\_device;
00307   CoeffReturnType* m\_result;
00308 \};
00309 
00310 
00311 \} \textcolor{comment}{// end namespace Eigen}
00312 
00313 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_CUSTOM\_OP\_H}
\end{DoxyCode}
