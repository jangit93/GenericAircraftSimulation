\hypertarget{eigen_2test_2basicstuff_8cpp_source}{}\section{eigen/test/basicstuff.cpp}
\label{eigen_2test_2basicstuff_8cpp_source}\index{basicstuff.\+cpp@{basicstuff.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#define EIGEN\_NO\_STATIC\_ASSERT}
00011 
00012 \textcolor{preprocessor}{#include "main.h"}
00013 
00014 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} basicStuff(\textcolor{keyword}{const} MatrixType& m)
00015 \{
00016   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00017   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00018   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, 1>} 
      \hyperlink{struct_vector_type}{VectorType};
00019   \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, MatrixType::RowsAtCompileTime>}
       SquareMatrixType;
00020 
00021   Index rows = m.rows();
00022   Index cols = m.cols();
00023 
00024   \textcolor{comment}{// this test relies a lot on Random.h, and there's not much more that we can do}
00025   \textcolor{comment}{// to test it, hence I consider that we will have tested Random.h}
00026   MatrixType m1 = MatrixType::Random(rows, cols),
00027              m2 = MatrixType::Random(rows, cols),
00028              m3(rows, cols),
00029              mzero = MatrixType::Zero(rows, cols),
00030              square = 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, MatrixType::RowsAtCompileTime>::Random}
      (rows, rows);
00031   VectorType v1 = VectorType::Random(rows),
00032              vzero = VectorType::Zero(rows);
00033   SquareMatrixType sm1 = SquareMatrixType::Random(rows,rows), sm2(rows,rows);
00034 
00035   Scalar x = 0;
00036   \textcolor{keywordflow}{while}(x == Scalar(0)) x = internal::random<Scalar>();
00037 
00038   Index r = internal::random<Index>(0, rows-1),
00039         c = internal::random<Index>(0, cols-1);
00040 
00041   m1.coeffRef(r,c) = x;
00042   VERIFY\_IS\_APPROX(x, m1.coeff(r,c));
00043   m1(r,c) = x;
00044   VERIFY\_IS\_APPROX(x, m1(r,c));
00045   v1.coeffRef(r) = x;
00046   VERIFY\_IS\_APPROX(x, v1.coeff(r));
00047   v1(r) = x;
00048   VERIFY\_IS\_APPROX(x, v1(r));
00049   v1[r] = x;
00050   VERIFY\_IS\_APPROX(x, v1[r]);
00051 
00052   VERIFY\_IS\_APPROX(               v1,    v1);
00053   VERIFY\_IS\_NOT\_APPROX(           v1,    2*v1);
00054   VERIFY\_IS\_MUCH\_SMALLER\_THAN(    vzero, v1);
00055   VERIFY\_IS\_MUCH\_SMALLER\_THAN(  vzero, v1.squaredNorm());
00056   VERIFY\_IS\_NOT\_MUCH\_SMALLER\_THAN(v1,    v1);
00057   VERIFY\_IS\_APPROX(               vzero, v1-v1);
00058   VERIFY\_IS\_APPROX(               m1,    m1);
00059   VERIFY\_IS\_NOT\_APPROX(           m1,    2*m1);
00060   VERIFY\_IS\_MUCH\_SMALLER\_THAN(    mzero, m1);
00061   VERIFY\_IS\_NOT\_MUCH\_SMALLER\_THAN(m1,    m1);
00062   VERIFY\_IS\_APPROX(               mzero, m1-m1);
00063 
00064   \textcolor{comment}{// always test operator() on each read-only expression class,}
00065   \textcolor{comment}{// in order to check const-qualifiers.}
00066   \textcolor{comment}{// indeed, if an expression class (here Zero) is meant to be read-only,}
00067   \textcolor{comment}{// hence has no \_write() method, the corresponding MatrixBase method (here zero())}
00068   \textcolor{comment}{// should return a const-qualified object so that it is the const-qualified}
00069   \textcolor{comment}{// operator() that gets called, which in turn calls \_read().}
00070   VERIFY\_IS\_MUCH\_SMALLER\_THAN(MatrixType::Zero(rows,cols)(r,c), static\_cast<Scalar>(1));
00071 
00072   \textcolor{comment}{// now test copying a row-vector into a (column-)vector and conversely.}
00073   square.col(r) = square.row(r).eval();
00074   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, 1, MatrixType::RowsAtCompileTime>} rv(rows)
      ;
00075   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, 1>} cv(rows)
      ;
00076   rv = square.row(r);
00077   cv = square.col(r);
00078   
00079   VERIFY\_IS\_APPROX(rv, cv.transpose());
00080 
00081   \textcolor{keywordflow}{if}(cols!=1 && rows!=1 && MatrixType::SizeAtCompileTime!=Dynamic)
00082   \{
00083     VERIFY\_RAISES\_ASSERT(m1 = (m2.block(0,0, rows-1, cols-1)));
00084   \}
00085 
00086   \textcolor{keywordflow}{if}(cols!=1 && rows!=1)
00087   \{
00088     VERIFY\_RAISES\_ASSERT(m1[0]);
00089     VERIFY\_RAISES\_ASSERT((m1+m1)[0]);
00090   \}
00091 
00092   VERIFY\_IS\_APPROX(m3 = m1,m1);
00093   MatrixType m4;
00094   VERIFY\_IS\_APPROX(m4 = m1,m1);
00095 
00096   m3.real() = m1.real();
00097   VERIFY\_IS\_APPROX(static\_cast<const MatrixType&>(m3).real(), static\_cast<const MatrixType&>(m1).real());
00098   VERIFY\_IS\_APPROX(static\_cast<const MatrixType&>(m3).real(), m1.real());
00099 
00100   \textcolor{comment}{// check == / != operators}
00101   VERIFY(m1==m1);
00102   VERIFY(m1!=m2);
00103   VERIFY(!(m1==m2));
00104   VERIFY(!(m1!=m1));
00105   m1 = m2;
00106   VERIFY(m1==m2);
00107   VERIFY(!(m1!=m2));
00108   
00109   \textcolor{comment}{// check automatic transposition}
00110   sm2.setZero();
00111   \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} MatrixType::Index i=0;i<rows;++i)
00112     sm2.col(i) = sm1.row(i);
00113   VERIFY\_IS\_APPROX(sm2,sm1.transpose());
00114   
00115   sm2.setZero();
00116   \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} MatrixType::Index i=0;i<rows;++i)
00117     sm2.col(i).noalias() = sm1.row(i);
00118   VERIFY\_IS\_APPROX(sm2,sm1.transpose());
00119   
00120   sm2.setZero();
00121   \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} MatrixType::Index i=0;i<rows;++i)
00122     sm2.col(i).noalias() += sm1.row(i);
00123   VERIFY\_IS\_APPROX(sm2,sm1.transpose());
00124   
00125   sm2.setZero();
00126   \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} MatrixType::Index i=0;i<rows;++i)
00127     sm2.col(i).noalias() -= sm1.row(i);
00128   VERIFY\_IS\_APPROX(sm2,-sm1.transpose());
00129   
00130   \textcolor{comment}{// check ternary usage}
00131   \{
00132     \textcolor{keywordtype}{bool} b = internal::random<int>(0,10)>5;
00133     m3 = b ? m1 : m2;
00134     \textcolor{keywordflow}{if}(b) VERIFY\_IS\_APPROX(m3,m1);
00135     \textcolor{keywordflow}{else}  VERIFY\_IS\_APPROX(m3,m2);
00136     m3 = b ? -m1 : m2;
00137     \textcolor{keywordflow}{if}(b) VERIFY\_IS\_APPROX(m3,-m1);
00138     \textcolor{keywordflow}{else}  VERIFY\_IS\_APPROX(m3,m2);
00139     m3 = b ? m1 : -m2;
00140     \textcolor{keywordflow}{if}(b) VERIFY\_IS\_APPROX(m3,m1);
00141     \textcolor{keywordflow}{else}  VERIFY\_IS\_APPROX(m3,-m2);
00142   \}
00143 \}
00144 
00145 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} basicStuffComplex(\textcolor{keyword}{const} MatrixType& m)
00146 \{
00147   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index Index;
00148   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00149   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00150   \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<RealScalar, MatrixType::RowsAtCompileTime, MatrixType::ColsAtCompileTime>}
       RealMatrixType;
00151 
00152   Index rows = m.rows();
00153   Index cols = m.cols();
00154 
00155   Scalar s1 = internal::random<Scalar>(),
00156          s2 = internal::random<Scalar>();
00157 
00158   VERIFY(numext::real(s1)==numext::real\_ref(s1));
00159   VERIFY(numext::imag(s1)==numext::imag\_ref(s1));
00160   numext::real\_ref(s1) = numext::real(s2);
00161   numext::imag\_ref(s1) = numext::imag(s2);
00162   VERIFY(internal::isApprox(s1, s2, \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::epsilon}()));
00163   \textcolor{comment}{// extended precision in Intel FPUs means that s1 == s2 in the line above is not guaranteed.}
00164 
00165   RealMatrixType rm1 = RealMatrixType::Random(rows,cols),
00166                  rm2 = RealMatrixType::Random(rows,cols);
00167   MatrixType cm(rows,cols);
00168   cm.real() = rm1;
00169   cm.imag() = rm2;
00170   VERIFY\_IS\_APPROX(static\_cast<const MatrixType&>(cm).real(), rm1);
00171   VERIFY\_IS\_APPROX(static\_cast<const MatrixType&>(cm).imag(), rm2);
00172   rm1.setZero();
00173   rm2.setZero();
00174   rm1 = cm.real();
00175   rm2 = cm.imag();
00176   VERIFY\_IS\_APPROX(static\_cast<const MatrixType&>(cm).real(), rm1);
00177   VERIFY\_IS\_APPROX(static\_cast<const MatrixType&>(cm).imag(), rm2);
00178   cm.real().setZero();
00179   VERIFY(static\_cast<const MatrixType&>(cm).real().isZero());
00180   VERIFY(!static\_cast<const MatrixType&>(cm).imag().isZero());
00181 \}
00182 
00183 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_2}
00184 \textcolor{keywordtype}{void} casting()
00185 \{
00186   Matrix4f m = Matrix4f::Random(), m2;
00187   Matrix4d n = m.cast<\textcolor{keywordtype}{double}>();
00188   VERIFY(m.isApprox(n.cast<\textcolor{keywordtype}{float}>()));
00189   m2 = m.cast<\textcolor{keywordtype}{float}>(); \textcolor{comment}{// check the specialization when NewType == Type}
00190   VERIFY(m.isApprox(m2));
00191 \}
00192 \textcolor{preprocessor}{#endif}
00193 
00194 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00195 \textcolor{keywordtype}{void} fixedSizeMatrixConstruction()
00196 \{
00197   Scalar raw[4];
00198   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<4; ++k)
00199     raw[k] = internal::random<Scalar>();
00200   
00201   \{
00202     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,4,1>} m(raw);
00203     \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,4,1>} a(raw);
00204     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<4; ++k) VERIFY(m(k) == raw[k]);
00205     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<4; ++k) VERIFY(a(k) == raw[k]);    
00206     VERIFY\_IS\_EQUAL(m,(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,4,1>}(raw[0],raw[1],raw[2],raw[3])));
00207     VERIFY((a==(\hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,4,1>}(raw[0],raw[1],raw[2],raw[3]))).all());
00208   \}
00209   \{
00210     \hyperlink{group___core___module}{Matrix<Scalar,3,1>} m(raw);
00211     \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,3,1>} a(raw);
00212     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<3; ++k) VERIFY(m(k) == raw[k]);
00213     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<3; ++k) VERIFY(a(k) == raw[k]);
00214     VERIFY\_IS\_EQUAL(m,(\hyperlink{group___core___module}{Matrix<Scalar,3,1>}(raw[0],raw[1],raw[2])));
00215     VERIFY((a==\hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,3,1>}(raw[0],raw[1],raw[2])).all());
00216   \}
00217   \{
00218     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,2,1>} m(raw), m2( (DenseIndex(raw[0])), (DenseIndex(raw[1])) );
00219     \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,2,1>} a(raw),  a2( (DenseIndex(raw[0])), (DenseIndex(raw[1])) );
00220     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<2; ++k) VERIFY(m(k) == raw[k]);
00221     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<2; ++k) VERIFY(a(k) == raw[k]);
00222     VERIFY\_IS\_EQUAL(m,(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,2,1>}(raw[0],raw[1])));
00223     VERIFY((a==\hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,2,1>}(raw[0],raw[1])).all());
00224     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<2; ++k) VERIFY(m2(k) == DenseIndex(raw[k]));
00225     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<2; ++k) VERIFY(a2(k) == DenseIndex(raw[k]));
00226   \}
00227   \{
00228     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,1,2>} m(raw),
00229                        m2( (DenseIndex(raw[0])), (DenseIndex(raw[1])) ),
00230                        m3( (\textcolor{keywordtype}{int}(raw[0])), (\textcolor{keywordtype}{int}(raw[1])) ),
00231                        m4( (\textcolor{keywordtype}{float}(raw[0])), (\textcolor{keywordtype}{float}(raw[1])) );
00232     \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,1,2>} a(raw),  a2( (DenseIndex(raw[0])), (DenseIndex(raw[1])) );
00233     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<2; ++k) VERIFY(m(k) == raw[k]);
00234     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<2; ++k) VERIFY(a(k) == raw[k]);
00235     VERIFY\_IS\_EQUAL(m,(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,1,2>}(raw[0],raw[1])));
00236     VERIFY((a==\hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,1,2>}(raw[0],raw[1])).all());
00237     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<2; ++k) VERIFY(m2(k) == DenseIndex(raw[k]));
00238     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<2; ++k) VERIFY(a2(k) == DenseIndex(raw[k]));
00239     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<2; ++k) VERIFY(m3(k) == \textcolor{keywordtype}{int}(raw[k]));
00240     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<2; ++k) VERIFY((m4(k)) == Scalar(\textcolor{keywordtype}{float}(raw[k])));
00241   \}
00242   \{
00243     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,1,1>} m(raw), m1(raw[0]), m2( (DenseIndex(raw[0])) ), m3( (\textcolor{keywordtype}{int}(raw[0])) 
      );
00244     \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,1,1>} a(raw), a1(raw[0]), a2( (DenseIndex(raw[0])) );
00245     VERIFY(m(0) == raw[0]);
00246     VERIFY(a(0) == raw[0]);
00247     VERIFY(m1(0) == raw[0]);
00248     VERIFY(a1(0) == raw[0]);
00249     VERIFY(m2(0) == DenseIndex(raw[0]));
00250     VERIFY(a2(0) == DenseIndex(raw[0]));
00251     VERIFY(m3(0) == \textcolor{keywordtype}{int}(raw[0]));
00252     VERIFY\_IS\_EQUAL(m,(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,1,1>}(raw[0])));
00253     VERIFY((a==\hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,1,1>}(raw[0])).all());
00254   \}
00255 \}
00256 
00257 \textcolor{keywordtype}{void} test\_basicstuff()
00258 \{
00259   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00260     CALL\_SUBTEST\_1( basicStuff(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 1, 1>}()) );
00261     CALL\_SUBTEST\_2( basicStuff(Matrix4d()) );
00262     CALL\_SUBTEST\_3( basicStuff(MatrixXcf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00263     CALL\_SUBTEST\_4( basicStuff(MatrixXi(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), internal::random<int>
      (1,EIGEN\_TEST\_MAX\_SIZE))) );
00264     CALL\_SUBTEST\_5( basicStuff(MatrixXcd(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00265     CALL\_SUBTEST\_6( basicStuff(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 100, 100>}()) );
00266     CALL\_SUBTEST\_7( basicStuff(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<long double,Dynamic,Dynamic>}(
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE),internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00267 
00268     CALL\_SUBTEST\_3( basicStuffComplex(MatrixXcf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00269     CALL\_SUBTEST\_5( basicStuffComplex(MatrixXcd(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00270   \}
00271 
00272   CALL\_SUBTEST\_1(fixedSizeMatrixConstruction<unsigned char>());
00273   CALL\_SUBTEST\_1(fixedSizeMatrixConstruction<float>());
00274   CALL\_SUBTEST\_1(fixedSizeMatrixConstruction<double>());
00275   CALL\_SUBTEST\_1(fixedSizeMatrixConstruction<int>());
00276   CALL\_SUBTEST\_1(fixedSizeMatrixConstruction<long int>());
00277   CALL\_SUBTEST\_1(fixedSizeMatrixConstruction<std::ptrdiff\_t>());
00278 
00279   CALL\_SUBTEST\_2(casting());
00280 \}
\end{DoxyCode}
