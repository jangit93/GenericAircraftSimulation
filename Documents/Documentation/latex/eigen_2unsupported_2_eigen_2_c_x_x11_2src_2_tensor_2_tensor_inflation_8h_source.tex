\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_inflation_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Inflation.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_inflation_8h_source}\index{Tensor\+Inflation.\+h@{Tensor\+Inflation.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Ke Yang <yangke@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_INFLATION\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_INFLATION\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_inflation_8h_source_l00024}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_inflation_op_3_01_strides_00_01_xpr_type_01_4_01_4}{00024} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_inflation_op}{TensorInflationOp}<Strides, XprType> > : \textcolor{keyword}{public} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<XprType>
00025 \{
00026   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00027   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>} \hyperlink{struct_eigen_1_1internal_1_1traits}{XprTraits};
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<Nested>::type} 
      \hyperlink{group___sparse_core___module}{\_Nested};
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00034 \};
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_inflation_8h_source_l00037}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_inflation_op_3_01_strides_00_01_xpr_type_01_4_00_01_eigen_1_1_dense_01_4}{00037} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_inflation_op}{TensorInflationOp}<Strides, XprType>, \hyperlink{namespace_eigen}{Eigen}::
      \hyperlink{struct_eigen_1_1_dense}{Dense}>
00038 \{
00039   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_inflation_op}{TensorInflationOp<Strides, XprType>}& 
      \hyperlink{class_eigen_1_1_tensor_inflation_op}{type};
00040 \};
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_inflation_8h_source_l00043}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_inflation_op_3_01_strides_00_01_xpr_type_01_4_00_eeee4fbc81465d4717490c737a712fae}{00043} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_inflation_op}{TensorInflationOp}<Strides, XprType>, 1, typename 
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_inflation_op}{TensorInflationOp}<Strides, XprType> >::\hyperlink{class_eigen_1_1_tensor_inflation_op}{type}>
00044 \{
00045   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_inflation_op}{TensorInflationOp<Strides, XprType>} 
      \hyperlink{class_eigen_1_1_tensor_inflation_op}{type};
00046 \};
00047 
00048 \}  \textcolor{comment}{// end namespace internal}
00049 
00050 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} XprType>
00051 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_inflation_op}{TensorInflationOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorInflationOp<Strides, XprType>,
       ReadOnlyAccessors>
00052 \{
00053   \textcolor{keyword}{public}:
00054   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorInflationOp>::Scalar}
       Scalar;
00055   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorInflationOp>::type}
       Nested;
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorInflationOp>::StorageKind}
       StorageKind;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorInflationOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00060 
00061   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_inflation_op}{TensorInflationOp}(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} 
      Strides& strides)
00062       : m\_xpr(expr), m\_strides(strides) \{\}
00063 
00064     EIGEN\_DEVICE\_FUNC
00065     \textcolor{keyword}{const} Strides& strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_strides; \}
00066 
00067     EIGEN\_DEVICE\_FUNC
00068     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename XprType::Nested>::type}
      &
00069     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00070 
00071   \textcolor{keyword}{protected}:
00072     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00073     \textcolor{keyword}{const} Strides m\_strides;
00074 \};
00075 
00076 \textcolor{comment}{// Eval as rvalue}
00077 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_inflation_8h_source_l00078}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_inflation_op_3_01_strides_00_01_arg_type_01_4_00_01_device_01_4}{00078} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_inflation_op}{TensorInflationOp}<Strides, ArgType>, Device>
00079 \{
00080   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_inflation_op}{TensorInflationOp<Strides, ArgType>} 
      \hyperlink{class_eigen_1_1_tensor_inflation_op}{XprType};
00081   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00082   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<ArgType, Device>::Dimensions}
      >::value;
00083   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumDims>} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00084   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00085   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00086   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00087   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size};
00088 
00089   \textcolor{keyword}{enum} \{
00090     IsAligned = \textcolor{comment}{/*TensorEvaluator<ArgType, Device>::IsAligned*/} \textcolor{keyword}{false},
00091     PacketAccess = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::PacketAccess}
      ,
00092     BlockAccess = \textcolor{keyword}{false},
00093     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Layout},
00094     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00095     RawAccess = \textcolor{keyword}{false}
00096   \};
00097 
00098   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00099       : m\_impl(op.expression(), device), m\_strides(op.strides())
00100   \{
00101     m\_dimensions = m\_impl.dimensions();
00102     \textcolor{comment}{// Expand each dimension to the inflated dimension.}
00103     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i) \{
00104       m\_dimensions[i] = (m\_dimensions[i] - 1) * op.strides()[i] + 1;
00105     \}
00106 
00107     \textcolor{comment}{// Remember the strides for fast division.}
00108     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i) \{
00109       m\_fastStrides[i] = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_strides[i]);
00110     \}
00111 
00112     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Dimensions}
      & input\_dims = m\_impl.dimensions();
00113     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00114       m\_outputStrides[0] = 1;
00115       m\_inputStrides[0] = 1;
00116       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00117         m\_outputStrides[i] = m\_outputStrides[i-1] * m\_dimensions[i-1];
00118         m\_inputStrides[i] = m\_inputStrides[i-1] * input\_dims[i-1];
00119       \}
00120     \} \textcolor{keywordflow}{else} \{  \textcolor{comment}{// RowMajor}
00121       m\_outputStrides[NumDims-1] = 1;
00122       m\_inputStrides[NumDims-1] = 1;
00123       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00124         m\_outputStrides[i] = m\_outputStrides[i+1] * m\_dimensions[i+1];
00125         m\_inputStrides[i] = m\_inputStrides[i+1] * input\_dims[i+1];
00126       \}
00127     \}
00128   \}
00129 
00130   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00131 
00132   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/}) \{
00133     m\_impl.evalSubExprsIfNeeded(NULL);
00134     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00135   \}
00136   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00137     m\_impl.cleanup();
00138   \}
00139 
00140   \textcolor{comment}{// Computes the input index given the output index. Returns true if the output}
00141   \textcolor{comment}{// index doesn't fall into a hole.}
00142   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} getInputIndex(Index index, Index* inputIndex)\textcolor{keyword}{ const}
00143 \textcolor{keyword}{  }\{
00144     eigen\_assert(index < dimensions().TotalSize());
00145     *inputIndex = 0;
00146     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00147       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00148         \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00149         \textcolor{keywordflow}{if} (idx != idx / m\_fastStrides[i] * m\_strides[i]) \{
00150           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00151         \}
00152         *inputIndex += idx / m\_strides[i] * m\_inputStrides[i];
00153         index -= idx * m\_outputStrides[i];
00154       \}
00155       \textcolor{keywordflow}{if} (index != index / m\_fastStrides[0] * m\_strides[0]) \{
00156         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00157       \}
00158       *inputIndex += index / m\_strides[0];
00159       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00160     \} \textcolor{keywordflow}{else} \{
00161       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00162         \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00163         \textcolor{keywordflow}{if} (idx != idx / m\_fastStrides[i] * m\_strides[i]) \{
00164           \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00165         \}
00166         *inputIndex += idx / m\_strides[i] * m\_inputStrides[i];
00167         index -= idx * m\_outputStrides[i];
00168       \}
00169       \textcolor{keywordflow}{if} (index != index / m\_fastStrides[NumDims-1] * m\_strides[NumDims-1]) \{
00170         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00171       \}
00172       *inputIndex += index / m\_strides[NumDims - 1];
00173     \}
00174     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00175   \}
00176 
00177   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00178 \textcolor{keyword}{  }\{
00179     Index inputIndex = 0;
00180     \textcolor{keywordflow}{if} (getInputIndex(index, &inputIndex)) \{
00181      \textcolor{keywordflow}{return} m\_impl.coeff(inputIndex);
00182     \} \textcolor{keywordflow}{else} \{
00183      \textcolor{keywordflow}{return} Scalar(0);
00184     \}
00185   \}
00186 
00187   \textcolor{comment}{// TODO(yangke): optimize this function so that we can detect and produce}
00188   \textcolor{comment}{// all-zero packets}
00189   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00190   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00191 \textcolor{keyword}{  }\{
00192     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00193     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00194 
00195     EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<CoeffReturnType>::type}
       values[PacketSize];
00196     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00197       values[i] = coeff(index+i);
00198     \}
00199     PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00200     \textcolor{keywordflow}{return} rslt;
00201   \}
00202 
00203   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost} costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00204     \textcolor{keyword}{const} \textcolor{keywordtype}{double} compute\_cost = NumDims * (3 * TensorOpCost::DivCost<Index>() +
00205                                            3 * TensorOpCost::MulCost<Index>() +
00206                                            2 * TensorOpCost::AddCost<Index>());
00207     \textcolor{keyword}{const} \textcolor{keywordtype}{double} input\_size = m\_impl.dimensions().TotalSize();
00208     \textcolor{keyword}{const} \textcolor{keywordtype}{double} output\_size = m\_dimensions.TotalSize();
00209     \textcolor{keywordflow}{if} (output\_size == 0)
00210       \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}();
00211     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) +
00212            \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(\textcolor{keyword}{sizeof}(CoeffReturnType) * input\_size / output\_size, 0,
00213                         compute\_cost, vectorized, PacketSize);
00214   \}
00215 
00216   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00217 
00218  \textcolor{keyword}{protected}:
00219   Dimensions m\_dimensions;
00220   \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} m\_outputStrides;
00221   \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} m\_inputStrides;
00222   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} m\_impl;
00223   \textcolor{keyword}{const} Strides m\_strides;
00224   \hyperlink{class_eigen_1_1array}{array<internal::TensorIntDivisor<Index>}, NumDims> m\_fastStrides;
00225 \};
00226 
00227 \} \textcolor{comment}{// end namespace Eigen}
00228 
00229 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_INFLATION\_H}
\end{DoxyCode}
