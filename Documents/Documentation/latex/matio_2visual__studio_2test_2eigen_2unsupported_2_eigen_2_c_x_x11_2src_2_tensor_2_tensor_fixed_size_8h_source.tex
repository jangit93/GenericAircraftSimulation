\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_fixed_size_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Fixed\+Size.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_fixed_size_8h_source}\index{Tensor\+Fixed\+Size.\+h@{Tensor\+Fixed\+Size.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_FIXED\_SIZE\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_FIXED\_SIZE\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00026 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_, \textcolor{keyword}{typename} Dimensions\_, \textcolor{keywordtype}{int} Options\_, \textcolor{keyword}{typename} IndexType>
00027 \textcolor{keyword}{class }TensorFixedSize : \textcolor{keyword}{public} TensorBase<TensorFixedSize<Scalar\_, Dimensions\_, Options\_, IndexType> >
00028 \{
00029   \textcolor{keyword}{public}:
00030     \textcolor{keyword}{typedef} TensorFixedSize<Scalar\_, Dimensions\_, Options\_, IndexType> Self;
00031     \textcolor{keyword}{typedef} TensorBase<TensorFixedSize<Scalar\_, Dimensions\_, Options\_, IndexType> > Base;
00032     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<Self>::type} Nested;
00033     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<Self>::StorageKind StorageKind;
00034     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<Self>::Index Index;
00035     \textcolor{keyword}{typedef} Scalar\_ Scalar;
00036     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar;
00037     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::CoeffReturnType CoeffReturnType;
00038 
00039     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Options = Options\_;
00040 
00041     \textcolor{keyword}{enum} \{
00042       IsAligned = bool(EIGEN\_MAX\_ALIGN\_BYTES>0),
00043       Layout = Options\_ & \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},
00044       CoordAccess = \textcolor{keyword}{true},
00045       RawAccess = \textcolor{keyword}{true}
00046     \};
00047 
00048   \textcolor{keyword}{typedef} Dimensions\_ Dimensions;
00049   \textcolor{keyword}{static} \textcolor{keyword}{const} std::size\_t NumIndices = Dimensions::count;
00050 
00051   \textcolor{keyword}{protected}:
00052   TensorStorage<Scalar, Dimensions, Options> m\_storage;
00053 
00054   \textcolor{keyword}{public}:
00055     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index                    rank()\textcolor{keyword}{                   const }\{ \textcolor{keywordflow}{return} 
      NumIndices; \}
00056     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index                    dimension(std::size\_t n)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 
      m\_storage.dimensions()[n]; \}
00057     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions&        dimensions()\textcolor{keyword}{             const }\{ \textcolor{keywordflow}{return} 
      m\_storage.dimensions(); \}
00058     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index                    size()\textcolor{keyword}{                   const }\{ \textcolor{keywordflow}{return} 
      m\_storage.size(); \}
00059     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar                   *data()                        \{ \textcolor{keywordflow}{return} 
      m\_storage.data(); \}
00060     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar             *data()\textcolor{keyword}{                  const }\{ \textcolor{keywordflow}{return} 
      m\_storage.data(); \}
00061 
00062     \textcolor{comment}{// This makes EIGEN\_INITIALIZE\_COEFFS\_IF\_THAT\_OPTION\_IS\_ENABLED}
00063     \textcolor{comment}{// work, because that uses base().coeffRef() - and we don't yet}
00064     \textcolor{comment}{// implement a similar class hierarchy}
00065     \textcolor{keyword}{inline} Self& base()             \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}
00066     \textcolor{keyword}{inline} \textcolor{keyword}{const} Self& base()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}
00067 
00068 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00069     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes>
00070     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& coeff(Index firstIndex, IndexTypes... otherIndices)\textcolor{keyword}{
       const}
00071 \textcolor{keyword}{    }\{
00072       \textcolor{comment}{// The number of indices used to access a tensor coefficient must be equal to the rank of the tensor.}
00073       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}...(otherIndices) + 1 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00074       \textcolor{keywordflow}{return} coeff(array<Index, NumIndices>\{\{firstIndex, otherIndices...\}\});
00075     \}
00076 \textcolor{preprocessor}{#endif}
00077 
00078     EIGEN\_DEVICE\_FUNC
00079     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& coeff(\textcolor{keyword}{const} array<Index, NumIndices>& indices)\textcolor{keyword}{ const}
00080 \textcolor{keyword}{    }\{
00081       eigen\_internal\_assert(checkIndexRange(indices));
00082       \textcolor{keywordflow}{return} m\_storage.data()[linearizedIndex(indices)];
00083     \}
00084 
00085     EIGEN\_DEVICE\_FUNC
00086     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& coeff(Index index)\textcolor{keyword}{ const}
00087 \textcolor{keyword}{    }\{
00088       eigen\_internal\_assert(index >= 0 && index < size());
00089       \textcolor{keywordflow}{return} m\_storage.data()[index];
00090     \}
00091 
00092     EIGEN\_DEVICE\_FUNC
00093     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& coeff()\textcolor{keyword}{ const}
00094 \textcolor{keyword}{    }\{
00095       EIGEN\_STATIC\_ASSERT(NumIndices == 0, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00096       \textcolor{keywordflow}{return} m\_storage.data()[0];
00097     \}
00098 
00099 
00100 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00101     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes>
00102     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& coeffRef(Index firstIndex, IndexTypes... otherIndices)
00103     \{
00104       \textcolor{comment}{// The number of indices used to access a tensor coefficient must be equal to the rank of the tensor.}
00105       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}...(otherIndices) + 1 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00106       \textcolor{keywordflow}{return} coeffRef(array<Index, NumIndices>\{\{firstIndex, otherIndices...\}\});
00107     \}
00108 \textcolor{preprocessor}{#endif}
00109 
00110     EIGEN\_DEVICE\_FUNC
00111     EIGEN\_STRONG\_INLINE Scalar& coeffRef(\textcolor{keyword}{const} array<Index, NumIndices>& indices)
00112     \{
00113       eigen\_internal\_assert(checkIndexRange(indices));
00114       \textcolor{keywordflow}{return} m\_storage.data()[linearizedIndex(indices)];
00115     \}
00116 
00117     EIGEN\_DEVICE\_FUNC
00118     EIGEN\_STRONG\_INLINE Scalar& coeffRef(Index index)
00119     \{
00120       eigen\_internal\_assert(index >= 0 && index < size());
00121       \textcolor{keywordflow}{return} m\_storage.data()[index];
00122     \}
00123 
00124     EIGEN\_DEVICE\_FUNC
00125     EIGEN\_STRONG\_INLINE Scalar& coeffRef()
00126     \{
00127       EIGEN\_STATIC\_ASSERT(NumIndices == 0, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00128       \textcolor{keywordflow}{return} m\_storage.data()[0];
00129     \}
00130 
00131 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00132     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes>
00133     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index firstIndex, IndexTypes... 
      otherIndices)\textcolor{keyword}{ const}
00134 \textcolor{keyword}{    }\{
00135       \textcolor{comment}{// The number of indices used to access a tensor coefficient must be equal to the rank of the tensor.}
00136       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}...(otherIndices) + 1 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00137       \textcolor{keywordflow}{return} this->operator()(array<Index, NumIndices>\{\{firstIndex, otherIndices...\}\});
00138     \}
00139 \textcolor{preprocessor}{#else}
00140     EIGEN\_DEVICE\_FUNC
00141     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index i0, Index i1)\textcolor{keyword}{ const}
00142 \textcolor{keyword}{    }\{
00143       \textcolor{keywordflow}{if} (Options&\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) \{
00144         \textcolor{keyword}{const} Index index = i1 + i0 * m\_storage.dimensions()[1];
00145         \textcolor{keywordflow}{return} m\_storage.data()[index];
00146       \} \textcolor{keywordflow}{else} \{
00147         \textcolor{keyword}{const} Index index = i0 + i1 * m\_storage.dimensions()[0];
00148         \textcolor{keywordflow}{return} m\_storage.data()[index];
00149       \}
00150     \}
00151     EIGEN\_DEVICE\_FUNC
00152     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index i0, Index i1, Index i2)\textcolor{keyword}{ const}
00153 \textcolor{keyword}{    }\{
00154       \textcolor{keywordflow}{if} (Options&RowMajor) \{
00155          \textcolor{keyword}{const} Index index = i2 + m\_storage.dimensions()[2] * (i1 + m\_storage.dimensions()[1] * i0);
00156          \textcolor{keywordflow}{return} m\_storage.data()[index];
00157       \} \textcolor{keywordflow}{else} \{
00158          \textcolor{keyword}{const} Index index = i0 + m\_storage.dimensions()[0] * (i1 + m\_storage.dimensions()[1] * i2);
00159         \textcolor{keywordflow}{return} m\_storage.data()[index];
00160       \}
00161     \}
00162     EIGEN\_DEVICE\_FUNC
00163     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index i0, Index i1, Index i2, Index i3)\textcolor{keyword}{ const}
00164 \textcolor{keyword}{    }\{
00165       \textcolor{keywordflow}{if} (Options&RowMajor) \{
00166         \textcolor{keyword}{const} Index index = i3 + m\_storage.dimensions()[3] * (i2 + m\_storage.dimensions()[2] * (i1 + 
      m\_storage.dimensions()[1] * i0));
00167         \textcolor{keywordflow}{return} m\_storage.data()[index];
00168       \} \textcolor{keywordflow}{else} \{
00169         \textcolor{keyword}{const} Index index = i0 + m\_storage.dimensions()[0] * (i1 + m\_storage.dimensions()[1] * (i2 + 
      m\_storage.dimensions()[2] * i3));
00170         \textcolor{keywordflow}{return} m\_storage.data()[index];
00171       \}
00172     \}
00173     EIGEN\_DEVICE\_FUNC
00174     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index i0, Index i1, Index i2, Index i3, Index i4)\textcolor{keyword}{ const}
00175 \textcolor{keyword}{    }\{
00176       \textcolor{keywordflow}{if} (Options&RowMajor) \{
00177         \textcolor{keyword}{const} Index index = i4 + m\_storage.dimensions()[4] * (i3 + m\_storage.dimensions()[3] * (i2 + 
      m\_storage.dimensions()[2] * (i1 + m\_storage.dimensions()[1] * i0)));
00178         \textcolor{keywordflow}{return} m\_storage.data()[index];
00179       \} \textcolor{keywordflow}{else} \{
00180         \textcolor{keyword}{const} Index index = i0 + m\_storage.dimensions()[0] * (i1 + m\_storage.dimensions()[1] * (i2 + 
      m\_storage.dimensions()[2] * (i3 + m\_storage.dimensions()[3] * i4)));
00181         \textcolor{keywordflow}{return} m\_storage.data()[index];
00182       \}
00183     \}
00184 \textcolor{preprocessor}{#endif}
00185 
00186 
00187     EIGEN\_DEVICE\_FUNC
00188     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(\textcolor{keyword}{const} array<Index, NumIndices>& indices)\textcolor{keyword}{ const}
00189 \textcolor{keyword}{    }\{
00190       eigen\_assert(checkIndexRange(indices));
00191       \textcolor{keywordflow}{return} coeff(indices);
00192     \}
00193 
00194     EIGEN\_DEVICE\_FUNC
00195     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index index)\textcolor{keyword}{ const}
00196 \textcolor{keyword}{    }\{
00197       eigen\_internal\_assert(index >= 0 && index < size());
00198       \textcolor{keywordflow}{return} coeff(index);
00199     \}
00200 
00201     EIGEN\_DEVICE\_FUNC
00202     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()()\textcolor{keyword}{ const}
00203 \textcolor{keyword}{    }\{
00204       EIGEN\_STATIC\_ASSERT(NumIndices == 0, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00205       \textcolor{keywordflow}{return} coeff();
00206     \}
00207 
00208     EIGEN\_DEVICE\_FUNC
00209     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator[](Index index)\textcolor{keyword}{ const}
00210 \textcolor{keyword}{    }\{
00211       \textcolor{comment}{// The bracket operator is only for vectors, use the parenthesis operator instead.}
00212       EIGEN\_STATIC\_ASSERT(NumIndices == 1, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00213       \textcolor{keywordflow}{return} coeff(index);
00214     \}
00215 
00216 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00217     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes>
00218     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& operator()(Index firstIndex, IndexTypes... otherIndices)
00219     \{
00220       \textcolor{comment}{// The number of indices used to access a tensor coefficient must be equal to the rank of the tensor.}
00221       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}...(otherIndices) + 1 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00222       \textcolor{keywordflow}{return} operator()(array<Index, NumIndices>\{\{firstIndex, otherIndices...\}\});
00223     \}
00224 \textcolor{preprocessor}{#else}
00225     EIGEN\_DEVICE\_FUNC
00226     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1)
00227     \{
00228        \textcolor{keywordflow}{if} (Options&RowMajor) \{
00229          \textcolor{keyword}{const} Index index = i1 + i0 * m\_storage.dimensions()[1];
00230         \textcolor{keywordflow}{return} m\_storage.data()[index];
00231       \} \textcolor{keywordflow}{else} \{
00232         \textcolor{keyword}{const} Index index = i0 + i1 * m\_storage.dimensions()[0];
00233         \textcolor{keywordflow}{return} m\_storage.data()[index];
00234       \}
00235     \}
00236     EIGEN\_DEVICE\_FUNC
00237     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1, Index i2)
00238     \{
00239        \textcolor{keywordflow}{if} (Options&RowMajor) \{
00240          \textcolor{keyword}{const} Index index = i2 + m\_storage.dimensions()[2] * (i1 + m\_storage.dimensions()[1] * i0);
00241         \textcolor{keywordflow}{return} m\_storage.data()[index];
00242       \} \textcolor{keywordflow}{else} \{
00243          \textcolor{keyword}{const} Index index = i0 + m\_storage.dimensions()[0] * (i1 + m\_storage.dimensions()[1] * i2);
00244         \textcolor{keywordflow}{return} m\_storage.data()[index];
00245       \}
00246     \}
00247     EIGEN\_DEVICE\_FUNC
00248     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3)
00249     \{
00250       \textcolor{keywordflow}{if} (Options&RowMajor) \{
00251         \textcolor{keyword}{const} Index index = i3 + m\_storage.dimensions()[3] * (i2 + m\_storage.dimensions()[2] * (i1 + 
      m\_storage.dimensions()[1] * i0));
00252         \textcolor{keywordflow}{return} m\_storage.data()[index];
00253       \} \textcolor{keywordflow}{else} \{
00254         \textcolor{keyword}{const} Index index = i0 + m\_storage.dimensions()[0] * (i1 + m\_storage.dimensions()[1] * (i2 + 
      m\_storage.dimensions()[2] * i3));
00255         \textcolor{keywordflow}{return} m\_storage.data()[index];
00256       \}
00257     \}
00258     EIGEN\_DEVICE\_FUNC
00259     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3, Index i4)
00260     \{
00261       \textcolor{keywordflow}{if} (Options&RowMajor) \{
00262         \textcolor{keyword}{const} Index index = i4 + m\_storage.dimensions()[4] * (i3 + m\_storage.dimensions()[3] * (i2 + 
      m\_storage.dimensions()[2] * (i1 + m\_storage.dimensions()[1] * i0)));
00263         \textcolor{keywordflow}{return} m\_storage.data()[index];
00264       \} \textcolor{keywordflow}{else} \{
00265         \textcolor{keyword}{const} Index index = i0 + m\_storage.dimensions()[0] * (i1 + m\_storage.dimensions()[1] * (i2 + 
      m\_storage.dimensions()[2] * (i3 + m\_storage.dimensions()[3] * i4)));
00266         \textcolor{keywordflow}{return} m\_storage.data()[index];
00267       \}
00268     \}
00269 \textcolor{preprocessor}{#endif}
00270 
00271     EIGEN\_DEVICE\_FUNC
00272     EIGEN\_STRONG\_INLINE Scalar& operator()(\textcolor{keyword}{const} array<Index, NumIndices>& indices)
00273     \{
00274       eigen\_assert(checkIndexRange(indices));
00275       \textcolor{keywordflow}{return} coeffRef(indices);
00276     \}
00277 
00278     EIGEN\_DEVICE\_FUNC
00279     EIGEN\_STRONG\_INLINE Scalar& operator()(Index index)
00280     \{
00281       eigen\_assert(index >= 0 && index < size());
00282       \textcolor{keywordflow}{return} coeffRef(index);
00283     \}
00284 
00285     EIGEN\_DEVICE\_FUNC
00286     EIGEN\_STRONG\_INLINE Scalar& operator()()
00287     \{
00288       EIGEN\_STATIC\_ASSERT(NumIndices == 0, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00289       \textcolor{keywordflow}{return} coeffRef();
00290     \}
00291 
00292     EIGEN\_DEVICE\_FUNC
00293     EIGEN\_STRONG\_INLINE Scalar& operator[](Index index)
00294     \{
00295       \textcolor{comment}{// The bracket operator is only for vectors, use the parenthesis operator instead}
00296       EIGEN\_STATIC\_ASSERT(NumIndices == 1, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00297       \textcolor{keywordflow}{return} coeffRef(index);
00298     \}
00299 
00300     EIGEN\_DEVICE\_FUNC
00301     EIGEN\_STRONG\_INLINE TensorFixedSize()
00302       : m\_storage()
00303     \{
00304     \}
00305 
00306     EIGEN\_DEVICE\_FUNC
00307     EIGEN\_STRONG\_INLINE TensorFixedSize(\textcolor{keyword}{const} Self& other)
00308       : m\_storage(other.m\_storage)
00309     \{
00310     \}
00311 
00312 \textcolor{preprocessor}{#if EIGEN\_HAS\_RVALUE\_REFERENCES}
00313     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorFixedSize(Self&& other)
00314       : m\_storage(other.m\_storage)
00315     \{
00316     \}
00317 \textcolor{preprocessor}{#endif}
00318 
00319     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00320     EIGEN\_DEVICE\_FUNC
00321     EIGEN\_STRONG\_INLINE TensorFixedSize(\textcolor{keyword}{const} TensorBase<OtherDerived, ReadOnlyAccessors>& other)
00322     \{
00323       \textcolor{keyword}{typedef} TensorAssignOp<TensorFixedSize, const OtherDerived> Assign;
00324       Assign assign(*\textcolor{keyword}{this}, other.derived());
00325       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00326     \}
00327     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00328     EIGEN\_DEVICE\_FUNC
00329     EIGEN\_STRONG\_INLINE TensorFixedSize(\textcolor{keyword}{const} TensorBase<OtherDerived, WriteAccessors>& other)
00330     \{
00331       \textcolor{keyword}{typedef} TensorAssignOp<TensorFixedSize, const OtherDerived> Assign;
00332       Assign assign(*\textcolor{keyword}{this}, other.derived());
00333       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00334     \}
00335 
00336     EIGEN\_DEVICE\_FUNC
00337     EIGEN\_STRONG\_INLINE TensorFixedSize& operator=(\textcolor{keyword}{const} TensorFixedSize& other)
00338     \{
00339       \textcolor{comment}{// FIXME: check that the dimensions of other match the dimensions of *this.}
00340       \textcolor{comment}{// Unfortunately this isn't possible yet when the rhs is an expression.}
00341       \textcolor{keyword}{typedef} TensorAssignOp<Self, const TensorFixedSize> Assign;
00342       Assign assign(*\textcolor{keyword}{this}, other);
00343       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00344       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00345     \}
00346     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00347     EIGEN\_DEVICE\_FUNC
00348     EIGEN\_STRONG\_INLINE TensorFixedSize& operator=(\textcolor{keyword}{const} OtherDerived& other)
00349     \{
00350       \textcolor{comment}{// FIXME: check that the dimensions of other match the dimensions of *this.}
00351       \textcolor{comment}{// Unfortunately this isn't possible yet when the rhs is an expression.}
00352       \textcolor{keyword}{typedef} TensorAssignOp<Self, const OtherDerived> Assign;
00353       Assign assign(*\textcolor{keyword}{this}, other);
00354       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00355       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00356     \}
00357 
00358   \textcolor{keyword}{protected}:
00359     EIGEN\_DEVICE\_FUNC
00360     EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} checkIndexRange(\textcolor{keyword}{const} array<Index, NumIndices>& \textcolor{comment}{/*indices*/})\textcolor{keyword}{ const}
00361 \textcolor{keyword}{    }\{
00362       \textcolor{keyword}{using} internal::array\_apply\_and\_reduce;
00363       \textcolor{keyword}{using} internal::array\_zip\_and\_reduce;
00364       \textcolor{keyword}{using} internal::greater\_equal\_zero\_op;
00365       \textcolor{keyword}{using} internal::logical\_and\_op;
00366       \textcolor{keyword}{using} internal::lesser\_op;
00367 
00368       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00369         \textcolor{comment}{// check whether the indices are all >= 0}
00370           \textcolor{comment}{/*       array\_apply\_and\_reduce<logical\_and\_op, greater\_equal\_zero\_op>(indices) &&}
00371 \textcolor{comment}{        // check whether the indices fit in the dimensions}
00372 \textcolor{comment}{        array\_zip\_and\_reduce<logical\_and\_op, lesser\_op>(indices, m\_storage.dimensions());*/}
00373     \}
00374 
00375     EIGEN\_DEVICE\_FUNC
00376     EIGEN\_STRONG\_INLINE Index linearizedIndex(\textcolor{keyword}{const} array<Index, NumIndices>& indices)\textcolor{keyword}{ const}
00377 \textcolor{keyword}{    }\{
00378       \textcolor{keywordflow}{if} (Options&RowMajor) \{
00379         \textcolor{keywordflow}{return} m\_storage.dimensions().IndexOfRowMajor(indices);
00380       \} \textcolor{keywordflow}{else} \{
00381         \textcolor{keywordflow}{return} m\_storage.dimensions().IndexOfColMajor(indices);
00382       \}
00383     \}
00384 \};
00385 
00386 
00387 \} \textcolor{comment}{// end namespace Eigen}
00388 
00389 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_FIXED\_SIZE\_H}
\end{DoxyCode}
