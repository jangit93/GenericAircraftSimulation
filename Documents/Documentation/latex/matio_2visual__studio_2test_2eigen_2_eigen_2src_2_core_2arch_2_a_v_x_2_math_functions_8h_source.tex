\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_a_v_x_2_math_functions_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/arch/\+A\+V\+X/\+Math\+Functions.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_a_v_x_2_math_functions_8h_source}\index{Math\+Functions.\+h@{Math\+Functions.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Pedro Gonnet (pedro.gonnet@gmail.com)}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_MATH\_FUNCTIONS\_AVX\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_MATH\_FUNCTIONS\_AVX\_H}
00012 
00013 \textcolor{comment}{/* The sin, cos, exp, and log functions of this file are loosely derived from}
00014 \textcolor{comment}{ * Julien Pommier's sse math library: http://gruntthepeon.free.fr/ssemath/}
00015 \textcolor{comment}{ */}
00016 
00017 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00018 
00019 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00020 
00021 \textcolor{keyword}{inline} Packet8i pshiftleft(Packet8i v, \textcolor{keywordtype}{int} n)
00022 \{
00023 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_AVX2}
00024   \textcolor{keywordflow}{return} \_mm256\_slli\_epi32(v, n);
00025 \textcolor{preprocessor}{#else}
00026   \_\_m128i lo = \_mm\_slli\_epi32(\_mm256\_extractf128\_si256(v, 0), n);
00027   \_\_m128i hi = \_mm\_slli\_epi32(\_mm256\_extractf128\_si256(v, 1), n);
00028   \textcolor{keywordflow}{return} \_mm256\_insertf128\_si256(\_mm256\_castsi128\_si256(lo), (hi), 1);
00029 \textcolor{preprocessor}{#endif}
00030 \}
00031 
00032 \textcolor{keyword}{inline} Packet8f pshiftright(Packet8f v, \textcolor{keywordtype}{int} n)
00033 \{
00034 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_AVX2}
00035   \textcolor{keywordflow}{return} \_mm256\_cvtepi32\_ps(\_mm256\_srli\_epi32(\_mm256\_castps\_si256(v), n));
00036 \textcolor{preprocessor}{#else}
00037   \_\_m128i lo = \_mm\_srli\_epi32(\_mm256\_extractf128\_si256(\_mm256\_castps\_si256(v), 0), n);
00038   \_\_m128i hi = \_mm\_srli\_epi32(\_mm256\_extractf128\_si256(\_mm256\_castps\_si256(v), 1), n);
00039   \textcolor{keywordflow}{return} \_mm256\_cvtepi32\_ps(\_mm256\_insertf128\_si256(\_mm256\_castsi128\_si256(lo), (hi), 1));
00040 \textcolor{preprocessor}{#endif}
00041 \}
00042 
00043 \textcolor{comment}{// Sine function}
00044 \textcolor{comment}{// Computes sin(x) by wrapping x to the interval [-Pi/4,3*Pi/4] and}
00045 \textcolor{comment}{// evaluating interpolants in [-Pi/4,Pi/4] or [Pi/4,3*Pi/4]. The interpolants}
00046 \textcolor{comment}{// are (anti-)symmetric and thus have only odd/even coefficients}
00047 \textcolor{keyword}{template} <>
00048 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet8f
00049 psin<Packet8f>(\textcolor{keyword}{const} Packet8f& \_x) \{
00050   Packet8f x = \_x;
00051 
00052   \textcolor{comment}{// Some useful values.}
00053   \_EIGEN\_DECLARE\_CONST\_Packet8i(one, 1);
00054   \_EIGEN\_DECLARE\_CONST\_Packet8f(one, 1.0f);
00055   \_EIGEN\_DECLARE\_CONST\_Packet8f(two, 2.0f);
00056   \_EIGEN\_DECLARE\_CONST\_Packet8f(one\_over\_four, 0.25f);
00057   \_EIGEN\_DECLARE\_CONST\_Packet8f(one\_over\_pi, 3.183098861837907e-01f);
00058   \_EIGEN\_DECLARE\_CONST\_Packet8f(neg\_pi\_first, -3.140625000000000e+00f);
00059   \_EIGEN\_DECLARE\_CONST\_Packet8f(neg\_pi\_second, -9.670257568359375e-04f);
00060   \_EIGEN\_DECLARE\_CONST\_Packet8f(neg\_pi\_third, -6.278329571784980e-07f);
00061   \_EIGEN\_DECLARE\_CONST\_Packet8f(four\_over\_pi, 1.273239544735163e+00f);
00062 
00063   \textcolor{comment}{// Map x from [-Pi/4,3*Pi/4] to z in [-1,3] and subtract the shifted period.}
00064   Packet8f z = pmul(x, p8f\_one\_over\_pi);
00065   Packet8f shift = \_mm256\_floor\_ps(padd(z, p8f\_one\_over\_four));
00066   x = pmadd(shift, p8f\_neg\_pi\_first, x);
00067   x = pmadd(shift, p8f\_neg\_pi\_second, x);
00068   x = pmadd(shift, p8f\_neg\_pi\_third, x);
00069   z = pmul(x, p8f\_four\_over\_pi);
00070 
00071   \textcolor{comment}{// Make a mask for the entries that need flipping, i.e. wherever the shift}
00072   \textcolor{comment}{// is odd.}
00073   Packet8i shift\_ints = \_mm256\_cvtps\_epi32(shift);
00074   Packet8i shift\_isodd = \_mm256\_castps\_si256(\_mm256\_and\_ps(\_mm256\_castsi256\_ps(shift\_ints), 
      \_mm256\_castsi256\_ps(p8i\_one)));
00075   Packet8i sign\_flip\_mask = pshiftleft(shift\_isodd, 31);
00076 
00077   \textcolor{comment}{// Create a mask for which interpolant to use, i.e. if z > 1, then the mask}
00078   \textcolor{comment}{// is set to ones for that entry.}
00079   Packet8f ival\_mask = \_mm256\_cmp\_ps(z, p8f\_one, \_CMP\_GT\_OQ);
00080 
00081   \textcolor{comment}{// Evaluate the polynomial for the interval [1,3] in z.}
00082   \_EIGEN\_DECLARE\_CONST\_Packet8f(coeff\_right\_0, 9.999999724233232e-01f);
00083   \_EIGEN\_DECLARE\_CONST\_Packet8f(coeff\_right\_2, -3.084242535619928e-01f);
00084   \_EIGEN\_DECLARE\_CONST\_Packet8f(coeff\_right\_4, 1.584991525700324e-02f);
00085   \_EIGEN\_DECLARE\_CONST\_Packet8f(coeff\_right\_6, -3.188805084631342e-04f);
00086   Packet8f z\_minus\_two = psub(z, p8f\_two);
00087   Packet8f z\_minus\_two2 = pmul(z\_minus\_two, z\_minus\_two);
00088   Packet8f right = pmadd(p8f\_coeff\_right\_6, z\_minus\_two2, p8f\_coeff\_right\_4);
00089   right = pmadd(right, z\_minus\_two2, p8f\_coeff\_right\_2);
00090   right = pmadd(right, z\_minus\_two2, p8f\_coeff\_right\_0);
00091 
00092   \textcolor{comment}{// Evaluate the polynomial for the interval [-1,1] in z.}
00093   \_EIGEN\_DECLARE\_CONST\_Packet8f(coeff\_left\_1, 7.853981525427295e-01f);
00094   \_EIGEN\_DECLARE\_CONST\_Packet8f(coeff\_left\_3, -8.074536727092352e-02f);
00095   \_EIGEN\_DECLARE\_CONST\_Packet8f(coeff\_left\_5, 2.489871967827018e-03f);
00096   \_EIGEN\_DECLARE\_CONST\_Packet8f(coeff\_left\_7, -3.587725841214251e-05f);
00097   Packet8f z2 = pmul(z, z);
00098   Packet8f left = pmadd(p8f\_coeff\_left\_7, z2, p8f\_coeff\_left\_5);
00099   left = pmadd(left, z2, p8f\_coeff\_left\_3);
00100   left = pmadd(left, z2, p8f\_coeff\_left\_1);
00101   left = pmul(left, z);
00102 
00103   \textcolor{comment}{// Assemble the results, i.e. select the left and right polynomials.}
00104   left = \_mm256\_andnot\_ps(ival\_mask, left);
00105   right = \_mm256\_and\_ps(ival\_mask, right);
00106   Packet8f res = \_mm256\_or\_ps(left, right);
00107 
00108   \textcolor{comment}{// Flip the sign on the odd intervals and return the result.}
00109   res = \_mm256\_xor\_ps(res, \_mm256\_castsi256\_ps(sign\_flip\_mask));
00110   \textcolor{keywordflow}{return} res;
00111 \}
00112 
00113 \textcolor{comment}{// Natural logarithm}
00114 \textcolor{comment}{// Computes log(x) as log(2^e * m) = C*e + log(m), where the constant C =log(2)}
00115 \textcolor{comment}{// and m is in the range [sqrt(1/2),sqrt(2)). In this range, the logarithm can}
00116 \textcolor{comment}{// be easily approximated by a polynomial centered on m=1 for stability.}
00117 \textcolor{comment}{// TODO(gonnet): Further reduce the interval allowing for lower-degree}
00118 \textcolor{comment}{//               polynomial interpolants -> ... -> profit!}
00119 \textcolor{keyword}{template} <>
00120 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet8f
00121 plog<Packet8f>(\textcolor{keyword}{const} Packet8f& \_x) \{
00122   Packet8f x = \_x;
00123   \_EIGEN\_DECLARE\_CONST\_Packet8f(1, 1.0f);
00124   \_EIGEN\_DECLARE\_CONST\_Packet8f(half, 0.5f);
00125   \_EIGEN\_DECLARE\_CONST\_Packet8f(126f, 126.0f);
00126 
00127   \_EIGEN\_DECLARE\_CONST\_Packet8f\_FROM\_INT(inv\_mant\_mask, ~0x7f800000);
00128 
00129   \textcolor{comment}{// The smallest non denormalized float number.}
00130   \_EIGEN\_DECLARE\_CONST\_Packet8f\_FROM\_INT(min\_norm\_pos, 0x00800000);
00131   \_EIGEN\_DECLARE\_CONST\_Packet8f\_FROM\_INT(minus\_inf, 0xff800000);
00132 
00133   \textcolor{comment}{// Polynomial coefficients.}
00134   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_SQRTHF, 0.707106781186547524f);
00135   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_log\_p0, 7.0376836292E-2f);
00136   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_log\_p1, -1.1514610310E-1f);
00137   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_log\_p2, 1.1676998740E-1f);
00138   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_log\_p3, -1.2420140846E-1f);
00139   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_log\_p4, +1.4249322787E-1f);
00140   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_log\_p5, -1.6668057665E-1f);
00141   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_log\_p6, +2.0000714765E-1f);
00142   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_log\_p7, -2.4999993993E-1f);
00143   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_log\_p8, +3.3333331174E-1f);
00144   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_log\_q1, -2.12194440e-4f);
00145   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_log\_q2, 0.693359375f);
00146 
00147   Packet8f invalid\_mask = \_mm256\_cmp\_ps(x, \_mm256\_setzero\_ps(), \_CMP\_NGE\_UQ); \textcolor{comment}{// not greater equal is true
       if x is NaN}
00148   Packet8f iszero\_mask = \_mm256\_cmp\_ps(x, \_mm256\_setzero\_ps(), \_CMP\_EQ\_OQ);
00149 
00150   \textcolor{comment}{// Truncate input values to the minimum positive normal.}
00151   x = pmax(x, p8f\_min\_norm\_pos);
00152 
00153   Packet8f emm0 = pshiftright(x,23);
00154   Packet8f e = \_mm256\_sub\_ps(emm0, p8f\_126f);
00155 
00156   \textcolor{comment}{// Set the exponents to -1, i.e. x are in the range [0.5,1).}
00157   x = \_mm256\_and\_ps(x, p8f\_inv\_mant\_mask);
00158   x = \_mm256\_or\_ps(x, p8f\_half);
00159 
00160   \textcolor{comment}{// part2: Shift the inputs from the range [0.5,1) to [sqrt(1/2),sqrt(2))}
00161   \textcolor{comment}{// and shift by -1. The values are then centered around 0, which improves}
00162   \textcolor{comment}{// the stability of the polynomial evaluation.}
00163   \textcolor{comment}{//   if( x < SQRTHF ) \{}
00164   \textcolor{comment}{//     e -= 1;}
00165   \textcolor{comment}{//     x = x + x - 1.0;}
00166   \textcolor{comment}{//   \} else \{ x = x - 1.0; \}}
00167   Packet8f mask = \_mm256\_cmp\_ps(x, p8f\_cephes\_SQRTHF, \_CMP\_LT\_OQ);
00168   Packet8f tmp = \_mm256\_and\_ps(x, mask);
00169   x = psub(x, p8f\_1);
00170   e = psub(e, \_mm256\_and\_ps(p8f\_1, mask));
00171   x = padd(x, tmp);
00172 
00173   Packet8f x2 = pmul(x, x);
00174   Packet8f x3 = pmul(x2, x);
00175 
00176   \textcolor{comment}{// Evaluate the polynomial approximant of degree 8 in three parts, probably}
00177   \textcolor{comment}{// to improve instruction-level parallelism.}
00178   Packet8f y, y1, y2;
00179   y = pmadd(p8f\_cephes\_log\_p0, x, p8f\_cephes\_log\_p1);
00180   y1 = pmadd(p8f\_cephes\_log\_p3, x, p8f\_cephes\_log\_p4);
00181   y2 = pmadd(p8f\_cephes\_log\_p6, x, p8f\_cephes\_log\_p7);
00182   y = pmadd(y, x, p8f\_cephes\_log\_p2);
00183   y1 = pmadd(y1, x, p8f\_cephes\_log\_p5);
00184   y2 = pmadd(y2, x, p8f\_cephes\_log\_p8);
00185   y = pmadd(y, x3, y1);
00186   y = pmadd(y, x3, y2);
00187   y = pmul(y, x3);
00188 
00189   \textcolor{comment}{// Add the logarithm of the exponent back to the result of the interpolation.}
00190   y1 = pmul(e, p8f\_cephes\_log\_q1);
00191   tmp = pmul(x2, p8f\_half);
00192   y = padd(y, y1);
00193   x = psub(x, tmp);
00194   y2 = pmul(e, p8f\_cephes\_log\_q2);
00195   x = padd(x, y);
00196   x = padd(x, y2);
00197 
00198   \textcolor{comment}{// Filter out invalid inputs, i.e. negative arg will be NAN, 0 will be -INF.}
00199   \textcolor{keywordflow}{return} \_mm256\_or\_ps(
00200       \_mm256\_andnot\_ps(iszero\_mask, \_mm256\_or\_ps(x, invalid\_mask)),
00201       \_mm256\_and\_ps(iszero\_mask, p8f\_minus\_inf));
00202 \}
00203 
00204 \textcolor{comment}{// Exponential function. Works by writing "x = m*log(2) + r" where}
00205 \textcolor{comment}{// "m = floor(x/log(2)+1/2)" and "r" is the remainder. The result is then}
00206 \textcolor{comment}{// "exp(x) = 2^m*exp(r)" where exp(r) is in the range [-1,1).}
00207 \textcolor{keyword}{template} <>
00208 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet8f
00209 pexp<Packet8f>(\textcolor{keyword}{const} Packet8f& \_x) \{
00210   \_EIGEN\_DECLARE\_CONST\_Packet8f(1, 1.0f);
00211   \_EIGEN\_DECLARE\_CONST\_Packet8f(half, 0.5f);
00212   \_EIGEN\_DECLARE\_CONST\_Packet8f(127, 127.0f);
00213 
00214   \_EIGEN\_DECLARE\_CONST\_Packet8f(exp\_hi, 88.3762626647950f);
00215   \_EIGEN\_DECLARE\_CONST\_Packet8f(exp\_lo, -88.3762626647949f);
00216 
00217   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_LOG2EF, 1.44269504088896341f);
00218 
00219   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_exp\_p0, 1.9875691500E-4f);
00220   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_exp\_p1, 1.3981999507E-3f);
00221   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_exp\_p2, 8.3334519073E-3f);
00222   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_exp\_p3, 4.1665795894E-2f);
00223   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_exp\_p4, 1.6666665459E-1f);
00224   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_exp\_p5, 5.0000001201E-1f);
00225 
00226   \textcolor{comment}{// Clamp x.}
00227   Packet8f x = pmax(pmin(\_x, p8f\_exp\_hi), p8f\_exp\_lo);
00228 
00229   \textcolor{comment}{// Express exp(x) as exp(m*ln(2) + r), start by extracting}
00230   \textcolor{comment}{// m = floor(x/ln(2) + 0.5).}
00231   Packet8f m = \_mm256\_floor\_ps(pmadd(x, p8f\_cephes\_LOG2EF, p8f\_half));
00232 
00233 \textcolor{comment}{// Get r = x - m*ln(2). If no FMA instructions are available, m*ln(2) is}
00234 \textcolor{comment}{// subtracted out in two parts, m*C1+m*C2 = m*ln(2), to avoid accumulating}
00235 \textcolor{comment}{// truncation errors. Note that we don't use the "pmadd" function here to}
00236 \textcolor{comment}{// ensure that a precision-preserving FMA instruction is used.}
00237 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_FMA}
00238   \_EIGEN\_DECLARE\_CONST\_Packet8f(nln2, -0.6931471805599453f);
00239   Packet8f r = \_mm256\_fmadd\_ps(m, p8f\_nln2, x);
00240 \textcolor{preprocessor}{#else}
00241   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_exp\_C1, 0.693359375f);
00242   \_EIGEN\_DECLARE\_CONST\_Packet8f(cephes\_exp\_C2, -2.12194440e-4f);
00243   Packet8f r = psub(x, pmul(m, p8f\_cephes\_exp\_C1));
00244   r = psub(r, pmul(m, p8f\_cephes\_exp\_C2));
00245 \textcolor{preprocessor}{#endif}
00246 
00247   Packet8f r2 = pmul(r, r);
00248 
00249   \textcolor{comment}{// TODO(gonnet): Split into odd/even polynomials and try to exploit}
00250   \textcolor{comment}{//               instruction-level parallelism.}
00251   Packet8f y = p8f\_cephes\_exp\_p0;
00252   y = pmadd(y, r, p8f\_cephes\_exp\_p1);
00253   y = pmadd(y, r, p8f\_cephes\_exp\_p2);
00254   y = pmadd(y, r, p8f\_cephes\_exp\_p3);
00255   y = pmadd(y, r, p8f\_cephes\_exp\_p4);
00256   y = pmadd(y, r, p8f\_cephes\_exp\_p5);
00257   y = pmadd(y, r2, r);
00258   y = padd(y, p8f\_1);
00259 
00260   \textcolor{comment}{// Build emm0 = 2^m.}
00261   Packet8i emm0 = \_mm256\_cvttps\_epi32(padd(m, p8f\_127));
00262   emm0 = pshiftleft(emm0, 23);
00263 
00264   \textcolor{comment}{// Return 2^m * exp(r).}
00265   \textcolor{keywordflow}{return} pmax(pmul(y, \_mm256\_castsi256\_ps(emm0)), \_x);
00266 \}
00267 
00268 \textcolor{comment}{// Hyperbolic Tangent function.}
00269 \textcolor{keyword}{template} <>
00270 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet8f
00271 ptanh<Packet8f>(\textcolor{keyword}{const} Packet8f& x) \{
00272   \textcolor{keywordflow}{return} internal::generic\_fast\_tanh\_float(x);
00273 \}
00274 
00275 \textcolor{keyword}{template} <>
00276 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet4d
00277 pexp<Packet4d>(\textcolor{keyword}{const} Packet4d& \_x) \{
00278   Packet4d x = \_x;
00279 
00280   \_EIGEN\_DECLARE\_CONST\_Packet4d(1, 1.0);
00281   \_EIGEN\_DECLARE\_CONST\_Packet4d(2, 2.0);
00282   \_EIGEN\_DECLARE\_CONST\_Packet4d(half, 0.5);
00283 
00284   \_EIGEN\_DECLARE\_CONST\_Packet4d(exp\_hi, 709.437);
00285   \_EIGEN\_DECLARE\_CONST\_Packet4d(exp\_lo, -709.436139303);
00286 
00287   \_EIGEN\_DECLARE\_CONST\_Packet4d(cephes\_LOG2EF, 1.4426950408889634073599);
00288 
00289   \_EIGEN\_DECLARE\_CONST\_Packet4d(cephes\_exp\_p0, 1.26177193074810590878e-4);
00290   \_EIGEN\_DECLARE\_CONST\_Packet4d(cephes\_exp\_p1, 3.02994407707441961300e-2);
00291   \_EIGEN\_DECLARE\_CONST\_Packet4d(cephes\_exp\_p2, 9.99999999999999999910e-1);
00292 
00293   \_EIGEN\_DECLARE\_CONST\_Packet4d(cephes\_exp\_q0, 3.00198505138664455042e-6);
00294   \_EIGEN\_DECLARE\_CONST\_Packet4d(cephes\_exp\_q1, 2.52448340349684104192e-3);
00295   \_EIGEN\_DECLARE\_CONST\_Packet4d(cephes\_exp\_q2, 2.27265548208155028766e-1);
00296   \_EIGEN\_DECLARE\_CONST\_Packet4d(cephes\_exp\_q3, 2.00000000000000000009e0);
00297 
00298   \_EIGEN\_DECLARE\_CONST\_Packet4d(cephes\_exp\_C1, 0.693145751953125);
00299   \_EIGEN\_DECLARE\_CONST\_Packet4d(cephes\_exp\_C2, 1.42860682030941723212e-6);
00300   \_EIGEN\_DECLARE\_CONST\_Packet4i(1023, 1023);
00301 
00302   Packet4d tmp, fx;
00303 
00304   \textcolor{comment}{// clamp x}
00305   x = pmax(pmin(x, p4d\_exp\_hi), p4d\_exp\_lo);
00306   \textcolor{comment}{// Express exp(x) as exp(g + n*log(2)).}
00307   fx = pmadd(p4d\_cephes\_LOG2EF, x, p4d\_half);
00308 
00309   \textcolor{comment}{// Get the integer modulus of log(2), i.e. the "n" described above.}
00310   fx = \_mm256\_floor\_pd(fx);
00311 
00312   \textcolor{comment}{// Get the remainder modulo log(2), i.e. the "g" described above. Subtract}
00313   \textcolor{comment}{// n*log(2) out in two steps, i.e. n*C1 + n*C2, C1+C2=log2 to get the last}
00314   \textcolor{comment}{// digits right.}
00315   tmp = pmul(fx, p4d\_cephes\_exp\_C1);
00316   Packet4d z = pmul(fx, p4d\_cephes\_exp\_C2);
00317   x = psub(x, tmp);
00318   x = psub(x, z);
00319 
00320   Packet4d x2 = pmul(x, x);
00321 
00322   \textcolor{comment}{// Evaluate the numerator polynomial of the rational interpolant.}
00323   Packet4d px = p4d\_cephes\_exp\_p0;
00324   px = pmadd(px, x2, p4d\_cephes\_exp\_p1);
00325   px = pmadd(px, x2, p4d\_cephes\_exp\_p2);
00326   px = pmul(px, x);
00327 
00328   \textcolor{comment}{// Evaluate the denominator polynomial of the rational interpolant.}
00329   Packet4d qx = p4d\_cephes\_exp\_q0;
00330   qx = pmadd(qx, x2, p4d\_cephes\_exp\_q1);
00331   qx = pmadd(qx, x2, p4d\_cephes\_exp\_q2);
00332   qx = pmadd(qx, x2, p4d\_cephes\_exp\_q3);
00333 
00334   \textcolor{comment}{// I don't really get this bit, copied from the SSE2 routines, so...}
00335   \textcolor{comment}{// TODO(gonnet): Figure out what is going on here, perhaps find a better}
00336   \textcolor{comment}{// rational interpolant?}
00337   x = \_mm256\_div\_pd(px, psub(qx, px));
00338   x = pmadd(p4d\_2, x, p4d\_1);
00339 
00340   \textcolor{comment}{// Build e=2^n by constructing the exponents in a 128-bit vector and}
00341   \textcolor{comment}{// shifting them to where they belong in double-precision values.}
00342   \_\_m128i emm0 = \_mm256\_cvtpd\_epi32(fx);
00343   emm0 = \_mm\_add\_epi32(emm0, p4i\_1023);
00344   emm0 = \_mm\_shuffle\_epi32(emm0, \_MM\_SHUFFLE(3, 1, 2, 0));
00345   \_\_m128i lo = \_mm\_slli\_epi64(emm0, 52);
00346   \_\_m128i hi = \_mm\_slli\_epi64(\_mm\_srli\_epi64(emm0, 32), 52);
00347   \_\_m256i e = \_mm256\_insertf128\_si256(\_mm256\_setzero\_si256(), lo, 0);
00348   e = \_mm256\_insertf128\_si256(e, hi, 1);
00349 
00350   \textcolor{comment}{// Construct the result 2^n * exp(g) = e * x. The max is used to catch}
00351   \textcolor{comment}{// non-finite values in the input.}
00352   \textcolor{keywordflow}{return} pmax(pmul(x, \_mm256\_castsi256\_pd(e)), \_x);
00353 \}
00354 
00355 \textcolor{comment}{// Functions for sqrt.}
00356 \textcolor{comment}{// The EIGEN\_FAST\_MATH version uses the \_mm\_rsqrt\_ps approximation and one step}
00357 \textcolor{comment}{// of Newton's method, at a cost of 1-2 bits of precision as opposed to the}
00358 \textcolor{comment}{// exact solution. It does not handle +inf, or denormalized numbers correctly.}
00359 \textcolor{comment}{// The main advantage of this approach is not just speed, but also the fact that}
00360 \textcolor{comment}{// it can be inlined and pipelined with other computations, further reducing its}
00361 \textcolor{comment}{// effective latency. This is similar to Quake3's fast inverse square root.}
00362 \textcolor{comment}{// For detail see here: http://www.beyond3d.com/content/articles/8/}
00363 \textcolor{preprocessor}{#if EIGEN\_FAST\_MATH}
00364 \textcolor{keyword}{template} <>
00365 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet8f
00366 psqrt<Packet8f>(\textcolor{keyword}{const} Packet8f& \_x) \{
00367   Packet8f half = pmul(\_x, pset1<Packet8f>(.5f));
00368   Packet8f denormal\_mask = \_mm256\_and\_ps(
00369       \_mm256\_cmp\_ps(\_x, pset1<Packet8f>((std::numeric\_limits<float>::min)()),
00370                     \_CMP\_LT\_OQ),
00371       \_mm256\_cmp\_ps(\_x, \_mm256\_setzero\_ps(), \_CMP\_GE\_OQ));
00372 
00373   \textcolor{comment}{// Compute approximate reciprocal sqrt.}
00374   Packet8f x = \_mm256\_rsqrt\_ps(\_x);
00375   \textcolor{comment}{// Do a single step of Newton's iteration.}
00376   x = pmul(x, psub(pset1<Packet8f>(1.5f), pmul(half, pmul(x,x))));
00377   \textcolor{comment}{// Flush results for denormals to zero.}
00378   \textcolor{keywordflow}{return} \_mm256\_andnot\_ps(denormal\_mask, pmul(\_x,x));
00379 \}
00380 \textcolor{preprocessor}{#else}
00381 \textcolor{keyword}{template} <> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00382 Packet8f psqrt<Packet8f>(\textcolor{keyword}{const} Packet8f& x) \{
00383   \textcolor{keywordflow}{return} \_mm256\_sqrt\_ps(x);
00384 \}
00385 \textcolor{preprocessor}{#endif}
00386 \textcolor{keyword}{template} <> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00387 Packet4d psqrt<Packet4d>(\textcolor{keyword}{const} Packet4d& x) \{
00388   \textcolor{keywordflow}{return} \_mm256\_sqrt\_pd(x);
00389 \}
00390 \textcolor{preprocessor}{#if EIGEN\_FAST\_MATH}
00391 
00392 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00393 Packet8f prsqrt<Packet8f>(\textcolor{keyword}{const} Packet8f& \_x) \{
00394   \_EIGEN\_DECLARE\_CONST\_Packet8f\_FROM\_INT(inf, 0x7f800000);
00395   \_EIGEN\_DECLARE\_CONST\_Packet8f\_FROM\_INT(nan, 0x7fc00000);
00396   \_EIGEN\_DECLARE\_CONST\_Packet8f(one\_point\_five, 1.5f);
00397   \_EIGEN\_DECLARE\_CONST\_Packet8f(minus\_half, -0.5f);
00398   \_EIGEN\_DECLARE\_CONST\_Packet8f\_FROM\_INT(flt\_min, 0x00800000);
00399 
00400   Packet8f neg\_half = pmul(\_x, p8f\_minus\_half);
00401 
00402   \textcolor{comment}{// select only the inverse sqrt of positive normal inputs (denormals are}
00403   \textcolor{comment}{// flushed to zero and cause infs as well).}
00404   Packet8f le\_zero\_mask = \_mm256\_cmp\_ps(\_x, p8f\_flt\_min, \_CMP\_LT\_OQ);
00405   Packet8f x = \_mm256\_andnot\_ps(le\_zero\_mask, \_mm256\_rsqrt\_ps(\_x));
00406 
00407   \textcolor{comment}{// Fill in NaNs and Infs for the negative/zero entries.}
00408   Packet8f neg\_mask = \_mm256\_cmp\_ps(\_x, \_mm256\_setzero\_ps(), \_CMP\_LT\_OQ);
00409   Packet8f zero\_mask = \_mm256\_andnot\_ps(neg\_mask, le\_zero\_mask);
00410   Packet8f infs\_and\_nans = \_mm256\_or\_ps(\_mm256\_and\_ps(neg\_mask, p8f\_nan),
00411                                         \_mm256\_and\_ps(zero\_mask, p8f\_inf));
00412 
00413   \textcolor{comment}{// Do a single step of Newton's iteration.}
00414   x = pmul(x, pmadd(neg\_half, pmul(x, x), p8f\_one\_point\_five));
00415 
00416   \textcolor{comment}{// Insert NaNs and Infs in all the right places.}
00417   \textcolor{keywordflow}{return} \_mm256\_or\_ps(x, infs\_and\_nans);
00418 \}
00419 
00420 \textcolor{preprocessor}{#else}
00421 \textcolor{keyword}{template} <> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00422 Packet8f prsqrt<Packet8f>(\textcolor{keyword}{const} Packet8f& x) \{
00423   \_EIGEN\_DECLARE\_CONST\_Packet8f(one, 1.0f);
00424   \textcolor{keywordflow}{return} \_mm256\_div\_ps(p8f\_one, \_mm256\_sqrt\_ps(x));
00425 \}
00426 \textcolor{preprocessor}{#endif}
00427 
00428 \textcolor{keyword}{template} <> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00429 Packet4d prsqrt<Packet4d>(\textcolor{keyword}{const} Packet4d& x) \{
00430   \_EIGEN\_DECLARE\_CONST\_Packet4d(one, 1.0);
00431   \textcolor{keywordflow}{return} \_mm256\_div\_pd(p4d\_one, \_mm256\_sqrt\_pd(x));
00432 \}
00433 
00434 
00435 \}  \textcolor{comment}{// end namespace internal}
00436 
00437 \}  \textcolor{comment}{// end namespace Eigen}
00438 
00439 \textcolor{preprocessor}{#endif  // EIGEN\_MATH\_FUNCTIONS\_AVX\_H}
\end{DoxyCode}
