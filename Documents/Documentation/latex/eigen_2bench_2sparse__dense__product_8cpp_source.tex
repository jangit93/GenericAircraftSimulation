\hypertarget{eigen_2bench_2sparse__dense__product_8cpp_source}{}\section{eigen/bench/sparse\+\_\+dense\+\_\+product.cpp}
\label{eigen_2bench_2sparse__dense__product_8cpp_source}\index{sparse\+\_\+dense\+\_\+product.\+cpp@{sparse\+\_\+dense\+\_\+product.\+cpp}}

\begin{DoxyCode}
00001 
00002 \textcolor{comment}{//g++ -O3 -g0 -DNDEBUG  sparse\_product.cpp -I.. -I/home/gael/Coding/LinearAlgebra/mtl4/ -DDENSITY=0.005
       -DSIZE=10000 && ./a.out}
00003 \textcolor{comment}{//g++ -O3 -g0 -DNDEBUG  sparse\_product.cpp -I.. -I/home/gael/Coding/LinearAlgebra/mtl4/ -DDENSITY=0.05
       -DSIZE=2000 && ./a.out}
00004 \textcolor{comment}{// -DNOGMM -DNOMTL -DCSPARSE}
00005 \textcolor{comment}{// -I /home/gael/Coding/LinearAlgebra/CSparse/Include/
       /home/gael/Coding/LinearAlgebra/CSparse/Lib/libcsparse.a}
00006 \textcolor{preprocessor}{#ifndef SIZE}
00007 \textcolor{preprocessor}{#define SIZE 650000}
00008 \textcolor{preprocessor}{#endif}
00009 
00010 \textcolor{preprocessor}{#ifndef DENSITY}
00011 \textcolor{preprocessor}{#define DENSITY 0.01}
00012 \textcolor{preprocessor}{#endif}
00013 
00014 \textcolor{preprocessor}{#ifndef REPEAT}
00015 \textcolor{preprocessor}{#define REPEAT 1}
00016 \textcolor{preprocessor}{#endif}
00017 
00018 \textcolor{preprocessor}{#include "BenchSparseUtil.h"}
00019 
00020 \textcolor{preprocessor}{#ifndef MINDENSITY}
00021 \textcolor{preprocessor}{#define MINDENSITY 0.0004}
00022 \textcolor{preprocessor}{#endif}
00023 
00024 \textcolor{preprocessor}{#ifndef NBTRIES}
00025 \textcolor{preprocessor}{#define NBTRIES 10}
00026 \textcolor{preprocessor}{#endif}
00027 
00028 \textcolor{preprocessor}{#define BENCH(X) \(\backslash\)}
00029 \textcolor{preprocessor}{  timer.reset(); \(\backslash\)}
00030 \textcolor{preprocessor}{  for (int \_j=0; \_j<NBTRIES; ++\_j) \{ \(\backslash\)}
00031 \textcolor{preprocessor}{    timer.start(); \(\backslash\)}
00032 \textcolor{preprocessor}{    for (int \_k=0; \_k<REPEAT; ++\_k) \{ \(\backslash\)}
00033 \textcolor{preprocessor}{        X  \(\backslash\)}
00034 \textcolor{preprocessor}{  \} timer.stop(); \}}
00035 
00036 
00037 \textcolor{preprocessor}{#ifdef CSPARSE}
00038 cs* cs\_sorted\_multiply(\textcolor{keyword}{const} cs* a, \textcolor{keyword}{const} cs* b)
00039 \{
00040   cs* \hyperlink{group___core___module_class_eigen_1_1_matrix}{A} = cs\_transpose (a, 1) ;
00041   cs* \hyperlink{group___core___module_class_eigen_1_1_matrix}{B} = cs\_transpose (b, 1) ;
00042   cs* D = cs\_multiply (B,A) ;   \textcolor{comment}{/* D = B'*A' */}
00043   cs\_spfree (A) ;
00044   cs\_spfree (B) ;
00045   cs\_dropzeros (D) ;      \textcolor{comment}{/* drop zeros from D */}
00046   cs* \hyperlink{group___core___module}{C} = cs\_transpose (D, 1) ;   \textcolor{comment}{/* C = D', so that C is sorted */}
00047   cs\_spfree (D) ;
00048   \textcolor{keywordflow}{return} C;
00049 \}
00050 \textcolor{preprocessor}{#endif}
00051 
00052 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[])
00053 \{
00054   \textcolor{keywordtype}{int} rows = SIZE;
00055   \textcolor{keywordtype}{int} cols = SIZE;
00056   \textcolor{keywordtype}{float} density = DENSITY;
00057 
00058   \hyperlink{group___sparse_core___module}{EigenSparseMatrix} sm1(rows,cols);
00059   \hyperlink{group___core___module}{DenseVector} v1(cols), v2(cols);
00060   v1.setRandom();
00061 
00062   \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} timer;
00063   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} density = DENSITY; density>=MINDENSITY; density*=0.5)
00064   \{
00065     \textcolor{comment}{//fillMatrix(density, rows, cols, sm1);}
00066     fillMatrix2(7, rows, cols, sm1);
00067 
00068     \textcolor{comment}{// dense matrices}
00069 \textcolor{preprocessor}{    #ifdef DENSEMATRIX}
00070     \{
00071       std::cout << \textcolor{stringliteral}{"Eigen Dense\(\backslash\)t"} << density*100 << \textcolor{stringliteral}{"%\(\backslash\)n"};
00072       \hyperlink{group___core___module}{DenseMatrix} m1(rows,cols);
00073       eiToDense(sm1, m1);
00074 
00075       timer.reset();
00076       timer.start();
00077       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<REPEAT; ++k)
00078         v2 = m1 * v1;
00079       timer.stop();
00080       std::cout << \textcolor{stringliteral}{"   a * v:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}() << \textcolor{stringliteral}{"  "} << double(REPEAT)/timer.
      \hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}() << \textcolor{stringliteral}{" * / sec "} << endl;
00081 
00082       timer.reset();
00083       timer.start();
00084       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<REPEAT; ++k)
00085         v2 = m1.transpose() * v1;
00086       timer.stop();
00087       std::cout << \textcolor{stringliteral}{"   a' * v:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}() << endl;
00088     \}
00089 \textcolor{preprocessor}{    #endif}
00090 
00091     \textcolor{comment}{// eigen sparse matrices}
00092     \{
00093       std::cout << \textcolor{stringliteral}{"Eigen sparse\(\backslash\)t"} << sm1.nonZeros()/float(sm1.rows()*sm1.cols())*100 << \textcolor{stringliteral}{"%\(\backslash\)n"};
00094 
00095       BENCH(\textcolor{keyword}{asm}(\textcolor{stringliteral}{"#myc"}); v2 = sm1 * v1; \textcolor{keyword}{asm}(\textcolor{stringliteral}{"#myd"});)
00096       std::cout << \textcolor{stringliteral}{"   a * v:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}()/REPEAT << \textcolor{stringliteral}{"  "} << double(REPEAT)/timer.
      \hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}(REAL\_TIMER) << \textcolor{stringliteral}{" * / sec "} << endl;
00097 
00098 
00099       BENCH( \{ \textcolor{keyword}{asm}(\textcolor{stringliteral}{"#mya"}); v2 = sm1.transpose() * v1; \textcolor{keyword}{asm}(\textcolor{stringliteral}{"#myb"}); \})
00100 
00101       std::cout << \textcolor{stringliteral}{"   a' * v:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}()/REPEAT << endl;
00102     \}
00103 
00104 \textcolor{comment}{//     \{}
00105 \textcolor{comment}{//       DynamicSparseMatrix<Scalar> m1(sm1);}
00106 \textcolor{comment}{//       std::cout << "Eigen dyn-sparse\(\backslash\)t" << m1.nonZeros()/float(m1.rows()*m1.cols())*100 << "%\(\backslash\)n";}
00107 \textcolor{comment}{//}
00108 \textcolor{comment}{//       BENCH(for (int k=0; k<REPEAT; ++k) v2 = m1 * v1;)}
00109 \textcolor{comment}{//       std::cout << "   a * v:\(\backslash\)t" << timer.value() << endl;}
00110 \textcolor{comment}{//}
00111 \textcolor{comment}{//       BENCH(for (int k=0; k<REPEAT; ++k) v2 = m1.transpose() * v1;)}
00112 \textcolor{comment}{//       std::cout << "   a' * v:\(\backslash\)t" << timer.value() << endl;}
00113 \textcolor{comment}{//     \}}
00114 
00115     \textcolor{comment}{// GMM++}
00116 \textcolor{preprocessor}{    #ifndef NOGMM}
00117     \{
00118       std::cout << \textcolor{stringliteral}{"GMM++ sparse\(\backslash\)t"} << density*100 << \textcolor{stringliteral}{"%\(\backslash\)n"};
00119       \textcolor{comment}{//GmmDynSparse  gmmT3(rows,cols);}
00120       GmmSparse m1(rows,cols);
00121       eiToGmm(sm1, m1);
00122 
00123       std::vector<Scalar> gmmV1(cols), gmmV2(cols);
00124       \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<Scalar,Dynamic,1>} >(&gmmV1[0], cols) = v1;
00125       \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<Scalar,Dynamic,1>} >(&gmmV2[0], cols) = v2;
00126 
00127       BENCH( \textcolor{keyword}{asm}(\textcolor{stringliteral}{"#myx"}); gmm::mult(m1, gmmV1, gmmV2); \textcolor{keyword}{asm}(\textcolor{stringliteral}{"#myy"}); )
00128       std::cout << \textcolor{stringliteral}{"   a * v:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00129 
00130       BENCH( gmm::mult(gmm::transposed(m1), gmmV1, gmmV2); )
00131       std::cout << \textcolor{stringliteral}{"   a' * v:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00132     \}
00133 \textcolor{preprocessor}{    #endif}
00134     
00135 \textcolor{preprocessor}{    #ifndef NOUBLAS}
00136     \{
00137       std::cout << \textcolor{stringliteral}{"ublas sparse\(\backslash\)t"} << density*100 << \textcolor{stringliteral}{"%\(\backslash\)n"};
00138       UBlasSparse m1(rows,cols);
00139       eiToUblas(sm1, m1);
00140       
00141       boost::numeric::ublas::vector<Scalar> uv1, uv2;
00142       eiToUblasVec(v1,uv1);
00143       eiToUblasVec(v2,uv2);
00144 
00145 \textcolor{comment}{//       std::vector<Scalar> gmmV1(cols), gmmV2(cols);}
00146 \textcolor{comment}{//       Map<Matrix<Scalar,Dynamic,1> >(&gmmV1[0], cols) = v1;}
00147 \textcolor{comment}{//       Map<Matrix<Scalar,Dynamic,1> >(&gmmV2[0], cols) = v2;}
00148 
00149       BENCH( uv2 = boost::numeric::ublas::prod(m1, uv1); )
00150       std::cout << \textcolor{stringliteral}{"   a * v:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00151 
00152 \textcolor{comment}{//       BENCH( boost::ublas::prod(gmm::transposed(m1), gmmV1, gmmV2); )}
00153 \textcolor{comment}{//       std::cout << "   a' * v:\(\backslash\)t" << timer.value() << endl;}
00154     \}
00155 \textcolor{preprocessor}{    #endif}
00156 
00157     \textcolor{comment}{// MTL4}
00158 \textcolor{preprocessor}{    #ifndef NOMTL}
00159     \{
00160       std::cout << \textcolor{stringliteral}{"MTL4\(\backslash\)t"} << density*100 << \textcolor{stringliteral}{"%\(\backslash\)n"};
00161       MtlSparse m1(rows,cols);
00162       eiToMtl(sm1, m1);
00163       mtl::dense\_vector<Scalar> mtlV1(cols, 1.0);
00164       mtl::dense\_vector<Scalar> mtlV2(cols, 1.0);
00165 
00166       timer.reset();
00167       timer.start();
00168       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<REPEAT; ++k)
00169         mtlV2 = m1 * mtlV1;
00170       timer.stop();
00171       std::cout << \textcolor{stringliteral}{"   a * v:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00172 
00173       timer.reset();
00174       timer.start();
00175       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<REPEAT; ++k)
00176         mtlV2 = trans(m1) * mtlV1;
00177       timer.stop();
00178       std::cout << \textcolor{stringliteral}{"   a' * v:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00179     \}
00180 \textcolor{preprocessor}{    #endif}
00181 
00182     std::cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
00183   \}
00184 
00185   \textcolor{keywordflow}{return} 0;
00186 \}
00187 
\end{DoxyCode}
