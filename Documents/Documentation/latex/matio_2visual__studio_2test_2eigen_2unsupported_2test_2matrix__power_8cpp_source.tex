\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2test_2matrix__power_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/test/matrix\+\_\+power.cpp}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2test_2matrix__power_8cpp_source}\index{matrix\+\_\+power.\+cpp@{matrix\+\_\+power.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012, 2013 Chen-Pang He <jdh8@ms63.hinet.net>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "matrix\_functions.h"}
00011 
00012 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00013 \textcolor{keywordtype}{void} test2dRotation(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& tol)
00014 \{
00015   Matrix<T,2,2> A, B, C;
00016   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} angle, c, s;
00017 
00018   A << 0, 1, -1, 0;
00019   MatrixPower<Matrix<T,2,2> > Apow(A);
00020 
00021   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<=20; ++i) \{
00022     angle = std::pow(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}(10), (i-10) / \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}(5.));
00023     c = std::cos(angle);
00024     s = std::sin(angle);
00025     B << c, s, -s, c;
00026 
00027     C = Apow(std::ldexp(angle,1) / \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}(EIGEN\_PI));
00028     std::cout << \textcolor{stringliteral}{"test2dRotation: i = "} << i << \textcolor{stringliteral}{"   error powerm = "} << relerr(C,B) << \textcolor{charliteral}{'\(\backslash\)n'};
00029     VERIFY(C.isApprox(B, tol));
00030   \}
00031 \}
00032 
00033 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00034 \textcolor{keywordtype}{void} test2dHyperbolicRotation(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& tol)
00035 \{
00036   Matrix<std::complex<T>,2,2> A, B, C;
00037   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} angle, ch = std::cosh((\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})1);
00038   std::complex<T> ish(0, std::sinh((\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})1));
00039 
00040   A << ch, ish, -ish, ch;
00041   MatrixPower<Matrix<std::complex<T>,2,2> > Apow(A);
00042 
00043   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<=20; ++i) \{
00044     angle = std::ldexp(static\_cast<T>(i-10), -1);
00045     ch = std::cosh(angle);
00046     ish = std::complex<T>(0, std::sinh(angle));
00047     B << ch, ish, -ish, ch;
00048 
00049     C = Apow(angle);
00050     std::cout << \textcolor{stringliteral}{"test2dHyperbolicRotation: i = "} << i << \textcolor{stringliteral}{"   error powerm = "} << relerr(C,B) << \textcolor{charliteral}{'\(\backslash\)n'};
00051     VERIFY(C.isApprox(B, tol));
00052   \}
00053 \}
00054 
00055 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00056 \textcolor{keywordtype}{void} test3dRotation(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& tol)
00057 \{
00058   Matrix<T,3,1> v;
00059   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} angle;
00060 
00061   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<=20; ++i) \{
00062     v = Matrix<T,3,1>::Random();
00063     v.normalize();
00064     angle = std::pow(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}(10), (i-10) / \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}(5.));
00065     VERIFY(AngleAxis<T>(angle, v).matrix().isApprox(AngleAxis<T>(1,v).matrix().
      \hyperlink{group___core___module_ab6dc101d82e8228a19a8840e3a29c1c9}{pow}(angle), tol));
00066   \}
00067 \}
00068 
00069 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00070 \textcolor{keywordtype}{void} testGeneral(\textcolor{keyword}{const} MatrixType& m, \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::RealScalar& tol)
00071 \{
00072   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00073   MatrixType m1, m2, m3, m4, m5;
00074   RealScalar x, y;
00075 
00076   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < g\_repeat; ++i) \{
00077     \hyperlink{structgenerate_test_matrix}{generateTestMatrix<MatrixType>::run}(m1, m.rows());
00078     MatrixPower<MatrixType> mpow(m1);
00079 
00080     x = internal::random<RealScalar>();
00081     y = internal::random<RealScalar>();
00082     m2 = mpow(x);
00083     m3 = mpow(y);
00084 
00085     m4 = mpow(x+y);
00086     m5.noalias() = m2 * m3;
00087     VERIFY(m4.isApprox(m5, tol));
00088 
00089     m4 = mpow(x*y);
00090     m5 = m2.pow(y);
00091     VERIFY(m4.isApprox(m5, tol));
00092 
00093     m4 = (std::abs(x) * m1).\hyperlink{group___core___module_ab6dc101d82e8228a19a8840e3a29c1c9}{pow}(y);
00094     m5 = std::pow(std::abs(x), y) * m3;
00095     VERIFY(m4.isApprox(m5, tol));
00096   \}
00097 \}
00098 
00099 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00100 \textcolor{keywordtype}{void} testSingular(\textcolor{keyword}{const} MatrixType& m\_const, \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::RealScalar& tol)
00101 \{
00102   \textcolor{comment}{// we need to pass by reference in order to prevent errors with}
00103   \textcolor{comment}{// MSVC for aligned data types ...}
00104   MatrixType& m = \textcolor{keyword}{const\_cast<}MatrixType&\textcolor{keyword}{>}(m\_const);
00105 
00106   \textcolor{keyword}{const} \textcolor{keywordtype}{int} IsComplex = NumTraits<typename internal::traits<MatrixType>::Scalar>::IsComplex;
00107   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::conditional<IsComplex, TriangularView<MatrixType,Upper>, \textcolor{keyword}{const} MatrixType&>
      ::type TriangularType;
00108   \textcolor{keyword}{typename} internal::conditional< IsComplex, ComplexSchur<MatrixType>, RealSchur<MatrixType> >::type schur;
00109   MatrixType \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T};
00110 
00111   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < g\_repeat; ++i) \{
00112     m.setRandom();
00113     m.\hyperlink{group___sparse_core___module_a3531e3e2098507a069a368d72d46471e}{col}(0).fill(0);
00114 
00115     schur.compute(m);
00116     T = schur.matrixT();
00117     \textcolor{keyword}{const} MatrixType& U = schur.matrixU();
00118     \hyperlink{structprocess_triangular_matrix}{processTriangularMatrix<MatrixType>::run}(m, T, U);
00119     MatrixPower<MatrixType> mpow(m);
00120 
00121     T = T.sqrt();
00122     VERIFY(mpow(0.5L).isApprox(U * (TriangularType(T) * U.adjoint()), tol));
00123 
00124     T = T.sqrt();
00125     VERIFY(mpow(0.25L).isApprox(U * (TriangularType(T) * U.adjoint()), tol));
00126 
00127     T = T.sqrt();
00128     VERIFY(mpow(0.125L).isApprox(U * (TriangularType(T) * U.adjoint()), tol));
00129   \}
00130 \}
00131 
00132 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00133 \textcolor{keywordtype}{void} testLogThenExp(\textcolor{keyword}{const} MatrixType& m\_const, \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::RealScalar& tol)
00134 \{
00135   \textcolor{comment}{// we need to pass by reference in order to prevent errors with}
00136   \textcolor{comment}{// MSVC for aligned data types ...}
00137   MatrixType& m = \textcolor{keyword}{const\_cast<}MatrixType&\textcolor{keyword}{>}(m\_const);
00138 
00139   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00140   Scalar x;
00141 
00142   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < g\_repeat; ++i) \{
00143     \hyperlink{structgenerate_test_matrix}{generateTestMatrix<MatrixType>::run}(m, m.rows());
00144     x = internal::random<Scalar>();
00145     VERIFY(m.pow(x).isApprox((x * m.log()).exp(), tol));
00146   \}
00147 \}
00148 
00149 \textcolor{keyword}{typedef} Matrix<double,3,3,RowMajor>         Matrix3dRowMajor;
00150 \textcolor{keyword}{typedef} Matrix<long double,3,3>             Matrix3e;
00151 \textcolor{keyword}{typedef} Matrix<long double,Dynamic,Dynamic> MatrixXe;
00152  
00153 \textcolor{keywordtype}{void} test\_matrix\_power()
00154 \{
00155   CALL\_SUBTEST\_2(test2dRotation<double>(1e-13));
00156   CALL\_SUBTEST\_1(test2dRotation<float>(2e-5));  \textcolor{comment}{// was 1e-5, relaxed for clang 2.8 / linux / x86-64}
00157   CALL\_SUBTEST\_9(test2dRotation<long double>(1e-13L));
00158   CALL\_SUBTEST\_2(test2dHyperbolicRotation<double>(1e-14));
00159   CALL\_SUBTEST\_1(test2dHyperbolicRotation<float>(1e-5));
00160   CALL\_SUBTEST\_9(test2dHyperbolicRotation<long double>(1e-14L));
00161 
00162   CALL\_SUBTEST\_10(test3dRotation<double>(1e-13));
00163   CALL\_SUBTEST\_11(test3dRotation<float>(1e-5));
00164   CALL\_SUBTEST\_12(test3dRotation<long double>(1e-13L));
00165 
00166   CALL\_SUBTEST\_2(testGeneral(Matrix2d(),         1e-13));
00167   CALL\_SUBTEST\_7(testGeneral(Matrix3dRowMajor(), 1e-13));
00168   CALL\_SUBTEST\_3(testGeneral(Matrix4cd(),        1e-13));
00169   CALL\_SUBTEST\_4(testGeneral(MatrixXd(8,8),      2e-12));
00170   CALL\_SUBTEST\_1(testGeneral(Matrix2f(),         1e-4));
00171   CALL\_SUBTEST\_5(testGeneral(Matrix3cf(),        1e-4));
00172   CALL\_SUBTEST\_8(testGeneral(Matrix4f(),         1e-4));
00173   CALL\_SUBTEST\_6(testGeneral(MatrixXf(2,2),      1e-3)); \textcolor{comment}{// see bug 614}
00174   CALL\_SUBTEST\_9(testGeneral(MatrixXe(7,7),      1e-13L));
00175   CALL\_SUBTEST\_10(testGeneral(Matrix3d(),        1e-13));
00176   CALL\_SUBTEST\_11(testGeneral(Matrix3f(),        1e-4));
00177   CALL\_SUBTEST\_12(testGeneral(Matrix3e(),        1e-13L));
00178 
00179   CALL\_SUBTEST\_2(testSingular(Matrix2d(),         1e-13));
00180   CALL\_SUBTEST\_7(testSingular(Matrix3dRowMajor(), 1e-13));
00181   CALL\_SUBTEST\_3(testSingular(Matrix4cd(),        1e-13));
00182   CALL\_SUBTEST\_4(testSingular(MatrixXd(8,8),      2e-12));
00183   CALL\_SUBTEST\_1(testSingular(Matrix2f(),         1e-4));
00184   CALL\_SUBTEST\_5(testSingular(Matrix3cf(),        1e-4));
00185   CALL\_SUBTEST\_8(testSingular(Matrix4f(),         1e-4));
00186   CALL\_SUBTEST\_6(testSingular(MatrixXf(2,2),      1e-3));
00187   CALL\_SUBTEST\_9(testSingular(MatrixXe(7,7),      1e-13L));
00188   CALL\_SUBTEST\_10(testSingular(Matrix3d(),        1e-13));
00189   CALL\_SUBTEST\_11(testSingular(Matrix3f(),        1e-4));
00190   CALL\_SUBTEST\_12(testSingular(Matrix3e(),        1e-13L));
00191 
00192   CALL\_SUBTEST\_2(testLogThenExp(Matrix2d(),         1e-13));
00193   CALL\_SUBTEST\_7(testLogThenExp(Matrix3dRowMajor(), 1e-13));
00194   CALL\_SUBTEST\_3(testLogThenExp(Matrix4cd(),        1e-13));
00195   CALL\_SUBTEST\_4(testLogThenExp(MatrixXd(8,8),      2e-12));
00196   CALL\_SUBTEST\_1(testLogThenExp(Matrix2f(),         1e-4));
00197   CALL\_SUBTEST\_5(testLogThenExp(Matrix3cf(),        1e-4));
00198   CALL\_SUBTEST\_8(testLogThenExp(Matrix4f(),         1e-4));
00199   CALL\_SUBTEST\_6(testLogThenExp(MatrixXf(2,2),      1e-3));
00200   CALL\_SUBTEST\_9(testLogThenExp(MatrixXe(7,7),      1e-13L));
00201   CALL\_SUBTEST\_10(testLogThenExp(Matrix3d(),        1e-13));
00202   CALL\_SUBTEST\_11(testLogThenExp(Matrix3f(),        1e-4));
00203   CALL\_SUBTEST\_12(testLogThenExp(Matrix3e(),        1e-13L));
00204 \}
\end{DoxyCode}
