\hypertarget{matio_2visual__studio_2test_2eigen_2test_2mixingtypes_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/mixingtypes.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2mixingtypes_8cpp_source}\index{mixingtypes.\+cpp@{mixingtypes.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{comment}{// work around "uninitialized" warnings and give that option some testing}
00012 \textcolor{preprocessor}{#define EIGEN\_INITIALIZE\_MATRICES\_BY\_ZERO}
00013 
00014 \textcolor{preprocessor}{#ifndef EIGEN\_NO\_STATIC\_ASSERT}
00015 \textcolor{preprocessor}{#define EIGEN\_NO\_STATIC\_ASSERT // turn static asserts into runtime asserts in order to check them}
00016 \textcolor{preprocessor}{#endif}
00017 
00018 \textcolor{preprocessor}{#if defined(EIGEN\_TEST\_PART\_1) || defined(EIGEN\_TEST\_PART\_2) || defined(EIGEN\_TEST\_PART\_3)}
00019 
00020 \textcolor{preprocessor}{#ifndef EIGEN\_DONT\_VECTORIZE}
00021 \textcolor{preprocessor}{#define EIGEN\_DONT\_VECTORIZE}
00022 \textcolor{preprocessor}{#endif}
00023 
00024 \textcolor{preprocessor}{#endif}
00025 
00026 \textcolor{keyword}{static} \textcolor{keywordtype}{bool} g\_called;
00027 \textcolor{preprocessor}{#define EIGEN\_SCALAR\_BINARY\_OP\_PLUGIN \{ g\_called |= (!internal::is\_same<LhsScalar,RhsScalar>::value); \}}
00028 
00029 \textcolor{preprocessor}{#include "main.h"}
00030 
00031 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00032 
00033 \textcolor{preprocessor}{#define VERIFY\_MIX\_SCALAR(XPR,REF) \(\backslash\)}
00034 \textcolor{preprocessor}{  g\_called = false; \(\backslash\)}
00035 \textcolor{preprocessor}{  VERIFY\_IS\_APPROX(XPR,REF); \(\backslash\)}
00036 \textcolor{preprocessor}{  VERIFY( g\_called && #XPR" not properly optimized");}
00037 
00038 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SizeAtCompileType> \textcolor{keywordtype}{void} mixingtypes(\textcolor{keywordtype}{int} size = SizeAtCompileType)
00039 \{
00040   \textcolor{keyword}{typedef} std::complex<float>   CF;
00041   \textcolor{keyword}{typedef} std::complex<double>  CD;
00042   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, SizeAtCompileType, SizeAtCompileType>}
       Mat\_f;
00043   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double, SizeAtCompileType, SizeAtCompileType>}
       Mat\_d;
00044   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<std::complex<float>}, SizeAtCompileType, SizeAtCompileType> 
      Mat\_cf;
00045   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<std::complex<double>}, SizeAtCompileType, SizeAtCompileType> 
      Mat\_cd;
00046   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, SizeAtCompileType, 1>} Vec\_f;
00047   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double, SizeAtCompileType, 1>} Vec\_d;
00048   \textcolor{keyword}{typedef} Matrix<std::complex<float>, SizeAtCompileType, 1> Vec\_cf;
00049   \textcolor{keyword}{typedef} Matrix<std::complex<double>, SizeAtCompileType, 1> Vec\_cd;
00050 
00051   Mat\_f mf    = Mat\_f::Random(size,size);
00052   Mat\_d md    = mf.template cast<double>();
00053   \textcolor{comment}{//Mat\_d rd    = md;}
00054   Mat\_cf mcf  = Mat\_cf::Random(size,size);
00055   Mat\_cd mcd  = mcf.template cast<complex<double> >();
00056   Mat\_cd rcd = mcd;
00057   Vec\_f vf    = Vec\_f::Random(size,1);
00058   Vec\_d vd    = vf.template cast<double>();
00059   Vec\_cf vcf  = Vec\_cf::Random(size,1);
00060   Vec\_cd vcd  = vcf.template cast<complex<double> >();
00061   \textcolor{keywordtype}{float}           sf  = internal::random<float>();
00062   \textcolor{keywordtype}{double}          sd  = internal::random<double>();
00063   \hyperlink{structcomplex}{complex<float>}  scf = internal::random<complex<float> >();
00064   \hyperlink{structcomplex}{complex<double>} scd = internal::random<complex<double> >();
00065 
00066   mf+mf;
00067 
00068   \textcolor{keywordtype}{float}  epsf = std::sqrt(std::numeric\_limits<float> ::min EIGEN\_EMPTY ());
00069   \textcolor{keywordtype}{double} epsd = std::sqrt(std::numeric\_limits<double>::min EIGEN\_EMPTY ());
00070 
00071   \textcolor{keywordflow}{while}(std::abs(sf )<epsf) sf  = internal::random<float>();
00072   \textcolor{keywordflow}{while}(std::abs(sd )<epsd) sf  = internal::random<double>();
00073   \textcolor{keywordflow}{while}(std::abs(scf)<epsf) scf = internal::random<CF>();
00074   \textcolor{keywordflow}{while}(std::abs(scd)<epsd) scd = internal::random<CD>();
00075 
00076 \textcolor{comment}{//   VERIFY\_RAISES\_ASSERT(mf+md); // does not even compile}
00077 
00078 \textcolor{preprocessor}{#ifdef EIGEN\_DONT\_VECTORIZE}
00079   VERIFY\_RAISES\_ASSERT(vf=vd);
00080   VERIFY\_RAISES\_ASSERT(vf+=vd);
00081 \textcolor{preprocessor}{#endif}
00082   
00083   \textcolor{comment}{// check scalar products}
00084   VERIFY\_MIX\_SCALAR(vcf * sf , vcf * \hyperlink{structcomplex}{complex<float>}(sf));
00085   VERIFY\_MIX\_SCALAR(sd * vcd , \hyperlink{structcomplex}{complex<double>}(sd) * vcd);
00086   VERIFY\_MIX\_SCALAR(vf * scf , vf.template cast<\hyperlink{structcomplex}{complex<float>} >() * scf);
00087   VERIFY\_MIX\_SCALAR(scd * vd , scd * vd.template cast<\hyperlink{structcomplex}{complex<double>} >());
00088 
00089   VERIFY\_MIX\_SCALAR(vcf * 2 , vcf * \hyperlink{structcomplex}{complex<float>}(2));
00090   VERIFY\_MIX\_SCALAR(vcf * 2.1 , vcf * \hyperlink{structcomplex}{complex<float>}(2.1));
00091   VERIFY\_MIX\_SCALAR(2 * vcf, vcf * \hyperlink{structcomplex}{complex<float>}(2));
00092   VERIFY\_MIX\_SCALAR(2.1 * vcf , vcf * \hyperlink{structcomplex}{complex<float>}(2.1));
00093 
00094   \textcolor{comment}{// check scalar quotients}
00095   VERIFY\_MIX\_SCALAR(vcf / sf , vcf / \hyperlink{structcomplex}{complex<float>}(sf));
00096   VERIFY\_MIX\_SCALAR(vf / scf , vf.template cast<\hyperlink{structcomplex}{complex<float>} >() / scf);
00097   VERIFY\_MIX\_SCALAR(vf.array()  / scf, vf.template cast<complex<float> >().\hyperlink{class_eigen_1_1array}{array}() / scf);
00098   VERIFY\_MIX\_SCALAR(scd / vd.array() , scd / vd.template cast<complex<double> >().
      \hyperlink{class_eigen_1_1array}{array}());
00099 
00100   \textcolor{comment}{// check scalar increment}
00101   VERIFY\_MIX\_SCALAR(vcf.array() + sf , vcf.array() + \hyperlink{structcomplex}{complex<float>}(sf));
00102   VERIFY\_MIX\_SCALAR(sd  + vcd.array(), \hyperlink{structcomplex}{complex<double>}(sd) + vcd.array());
00103   VERIFY\_MIX\_SCALAR(vf.array()  + scf, vf.template cast<complex<float> >().\hyperlink{class_eigen_1_1array}{array}() + scf);
00104   VERIFY\_MIX\_SCALAR(scd + vd.array() , scd + vd.template cast<complex<double> >().
      \hyperlink{class_eigen_1_1array}{array}());
00105 
00106   \textcolor{comment}{// check scalar subtractions}
00107   VERIFY\_MIX\_SCALAR(vcf.array() - sf , vcf.array() - \hyperlink{structcomplex}{complex<float>}(sf));
00108   VERIFY\_MIX\_SCALAR(sd  - vcd.array(), \hyperlink{structcomplex}{complex<double>}(sd) - vcd.array());
00109   VERIFY\_MIX\_SCALAR(vf.array()  - scf, vf.template cast<complex<float> >().\hyperlink{class_eigen_1_1array}{array}() - scf);
00110   VERIFY\_MIX\_SCALAR(scd - vd.array() , scd - vd.template cast<complex<double> >().
      \hyperlink{class_eigen_1_1array}{array}());
00111 
00112   \textcolor{comment}{// check scalar powers}
00113   VERIFY\_MIX\_SCALAR( pow(vcf.array(), sf),        Eigen::pow(vcf.array(), 
      \hyperlink{structcomplex}{complex<float>}(sf)) );
00114   VERIFY\_MIX\_SCALAR( vcf.array().pow(sf) ,        Eigen::pow(vcf.array(), 
      \hyperlink{structcomplex}{complex<float>}(sf)) );
00115   VERIFY\_MIX\_SCALAR( pow(sd, vcd.array()),        Eigen::pow(\hyperlink{structcomplex}{complex<double>}(sd), vcd.array(
      )) );
00116   VERIFY\_MIX\_SCALAR( Eigen::pow(vf.array(), scf), Eigen::pow(vf.template cast<
      \hyperlink{structcomplex}{complex<float>} >().array(), scf) );
00117   VERIFY\_MIX\_SCALAR( vf.array().pow(scf) ,        Eigen::pow(vf.template cast<
      \hyperlink{structcomplex}{complex<float>} >().array(), scf) );
00118   VERIFY\_MIX\_SCALAR( Eigen::pow(scd, vd.array()), Eigen::pow(scd, vd.template cast<
      \hyperlink{structcomplex}{complex<double>} >().array()) );
00119 
00120   \textcolor{comment}{// check dot product}
00121   vf.dot(vf);
00122 \textcolor{preprocessor}{#if 0 // we get other compilation errors here than just static asserts}
00123   VERIFY\_RAISES\_ASSERT(vd.dot(vf));
00124 \textcolor{preprocessor}{#endif}
00125   VERIFY\_IS\_APPROX(vcf.dot(vf), vcf.dot(vf.template cast<\hyperlink{structcomplex}{complex<float>} >()));
00126 
00127   \textcolor{comment}{// check diagonal product}
00128   VERIFY\_IS\_APPROX(vf.asDiagonal() * mcf, vf.template cast<complex<float> >().asDiagonal() * mcf);
00129   VERIFY\_IS\_APPROX(vcd.asDiagonal() * md, vcd.asDiagonal() * md.template cast<complex<double> >());
00130   VERIFY\_IS\_APPROX(mcf * vf.asDiagonal(), mcf * vf.template cast<complex<float> >().asDiagonal());
00131   VERIFY\_IS\_APPROX(md * vcd.asDiagonal(), md.template cast<complex<double> >() * vcd.asDiagonal());
00132 
00133 \textcolor{comment}{//   vd.asDiagonal() * mf;    // does not even compile}
00134 \textcolor{comment}{//   vcd.asDiagonal() * mf;   // does not even compile}
00135 
00136   \textcolor{comment}{// check inner product}
00137   VERIFY\_IS\_APPROX((vf.transpose() * vcf).value(), (vf.template cast<complex<float> >().transpose() * vcf).
      value());
00138 
00139   \textcolor{comment}{// check outer product}
00140   VERIFY\_IS\_APPROX((vf * vcf.transpose()).eval(), (vf.template cast<complex<float> >() * vcf.transpose()).
      eval());
00141 
00142   \textcolor{comment}{// coeff wise product}
00143 
00144   VERIFY\_IS\_APPROX((vf * vcf.transpose()).eval(), (vf.template cast<complex<float> >() * vcf.transpose()).
      eval());
00145 
00146   Mat\_cd mcd2 = mcd;
00147   VERIFY\_IS\_APPROX(mcd.array() *= md.array(), mcd2.array() *= md.array().template cast<std::complex<double>
       >());
00148   
00149   \textcolor{comment}{// check matrix-matrix products}
00150   VERIFY\_IS\_APPROX(sd*md*mcd, (sd*md).\textcolor{keyword}{template} cast<CD>().eval()*mcd);
00151   VERIFY\_IS\_APPROX(sd*mcd*md, sd*mcd*md.template cast<CD>());
00152   VERIFY\_IS\_APPROX(scd*md*mcd, scd*md.template cast<CD>().eval()*mcd);
00153   VERIFY\_IS\_APPROX(scd*mcd*md, scd*mcd*md.template cast<CD>());
00154 
00155   VERIFY\_IS\_APPROX(sf*mf*mcf, sf*mf.template cast<CF>()*mcf);
00156   VERIFY\_IS\_APPROX(sf*mcf*mf, sf*mcf*mf.template cast<CF>());
00157   VERIFY\_IS\_APPROX(scf*mf*mcf, scf*mf.template cast<CF>()*mcf);
00158   VERIFY\_IS\_APPROX(scf*mcf*mf, scf*mcf*mf.template cast<CF>());
00159 
00160   VERIFY\_IS\_APPROX(sd*md.adjoint()*mcd, (sd*md).\textcolor{keyword}{template} cast<CD>().eval().adjoint()*mcd);
00161   VERIFY\_IS\_APPROX(sd*mcd.adjoint()*md, sd*mcd.adjoint()*md.template cast<CD>());
00162   VERIFY\_IS\_APPROX(sd*md.adjoint()*mcd.adjoint(), (sd*md).\textcolor{keyword}{template} cast<CD>().eval().adjoint()*mcd.adjoint(
      ));
00163   VERIFY\_IS\_APPROX(sd*mcd.adjoint()*md.adjoint(), sd*mcd.adjoint()*md.template cast<CD>().adjoint());
00164   VERIFY\_IS\_APPROX(sd*md*mcd.adjoint(), (sd*md).\textcolor{keyword}{template} cast<CD>().eval()*mcd.adjoint());
00165   VERIFY\_IS\_APPROX(sd*mcd*md.adjoint(), sd*mcd*md.template cast<CD>().adjoint());
00166 
00167   VERIFY\_IS\_APPROX(sf*mf.adjoint()*mcf, (sf*mf).\textcolor{keyword}{template} cast<CF>().eval().adjoint()*mcf);
00168   VERIFY\_IS\_APPROX(sf*mcf.adjoint()*mf, sf*mcf.adjoint()*mf.template cast<CF>());
00169   VERIFY\_IS\_APPROX(sf*mf.adjoint()*mcf.adjoint(), (sf*mf).\textcolor{keyword}{template} cast<CF>().eval().adjoint()*mcf.adjoint(
      ));
00170   VERIFY\_IS\_APPROX(sf*mcf.adjoint()*mf.adjoint(), sf*mcf.adjoint()*mf.template cast<CF>().adjoint());
00171   VERIFY\_IS\_APPROX(sf*mf*mcf.adjoint(), (sf*mf).\textcolor{keyword}{template} cast<CF>().eval()*mcf.adjoint());
00172   VERIFY\_IS\_APPROX(sf*mcf*mf.adjoint(), sf*mcf*mf.template cast<CF>().adjoint());
00173 
00174   VERIFY\_IS\_APPROX(sf*mf*vcf, (sf*mf).\textcolor{keyword}{template} cast<CF>().eval()*vcf);
00175   VERIFY\_IS\_APPROX(scf*mf*vcf,(scf*mf.template cast<CF>()).eval()*vcf);
00176   VERIFY\_IS\_APPROX(sf*mcf*vf, sf*mcf*vf.template cast<CF>());
00177   VERIFY\_IS\_APPROX(scf*mcf*vf,scf*mcf*vf.template cast<CF>());
00178 
00179   VERIFY\_IS\_APPROX(sf*vcf.adjoint()*mf,  sf*vcf.adjoint()*mf.template cast<CF>().eval());
00180   VERIFY\_IS\_APPROX(scf*vcf.adjoint()*mf, scf*vcf.adjoint()*mf.template cast<CF>().eval());
00181   VERIFY\_IS\_APPROX(sf*vf.adjoint()*mcf,  sf*vf.adjoint().template cast<CF>().eval()*mcf);
00182   VERIFY\_IS\_APPROX(scf*vf.adjoint()*mcf, scf*vf.adjoint().template cast<CF>().eval()*mcf);
00183 
00184   VERIFY\_IS\_APPROX(sd*md*vcd, (sd*md).\textcolor{keyword}{template} cast<CD>().eval()*vcd);
00185   VERIFY\_IS\_APPROX(scd*md*vcd,(scd*md.template cast<CD>()).eval()*vcd);
00186   VERIFY\_IS\_APPROX(sd*mcd*vd, sd*mcd*vd.template cast<CD>().eval());
00187   VERIFY\_IS\_APPROX(scd*mcd*vd,scd*mcd*vd.template cast<CD>().eval());
00188 
00189   VERIFY\_IS\_APPROX(sd*vcd.adjoint()*md,  sd*vcd.adjoint()*md.template cast<CD>().eval());
00190   VERIFY\_IS\_APPROX(scd*vcd.adjoint()*md, scd*vcd.adjoint()*md.template cast<CD>().eval());
00191   VERIFY\_IS\_APPROX(sd*vd.adjoint()*mcd,  sd*vd.adjoint().template cast<CD>().eval()*mcd);
00192   VERIFY\_IS\_APPROX(scd*vd.adjoint()*mcd, scd*vd.adjoint().template cast<CD>().eval()*mcd);
00193 
00194   VERIFY\_IS\_APPROX( sd*vcd.adjoint()*md.template triangularView<Upper>(),  sd*vcd.adjoint()*md.template 
      cast<CD>().eval().template triangularView<Upper>());
00195   VERIFY\_IS\_APPROX(scd*vcd.adjoint()*md.template triangularView<Lower>(), scd*vcd.adjoint()*md.template 
      cast<CD>().eval().template triangularView<Lower>());
00196   VERIFY\_IS\_APPROX( sd*vcd.adjoint()*md.transpose().template triangularView<Upper>(),  sd*vcd.adjoint()*md.
      transpose().template cast<CD>().eval().template triangularView<Upper>());
00197   VERIFY\_IS\_APPROX(scd*vcd.adjoint()*md.transpose().template triangularView<Lower>(), scd*vcd.adjoint()*md.
      transpose().template cast<CD>().eval().template triangularView<Lower>());
00198   VERIFY\_IS\_APPROX( sd*vd.adjoint()*mcd.template triangularView<Lower>(),  sd*vd.adjoint().template 
      cast<CD>().eval()*mcd.template triangularView<Lower>());
00199   VERIFY\_IS\_APPROX(scd*vd.adjoint()*mcd.template triangularView<Upper>(), scd*vd.adjoint().template 
      cast<CD>().eval()*mcd.template triangularView<Upper>());
00200   VERIFY\_IS\_APPROX( sd*vd.adjoint()*mcd.transpose().template triangularView<Lower>(),  sd*vd.adjoint().
      template cast<CD>().eval()*mcd.transpose().template triangularView<Lower>());
00201   VERIFY\_IS\_APPROX(scd*vd.adjoint()*mcd.transpose().template triangularView<Upper>(), scd*vd.adjoint().
      template cast<CD>().eval()*mcd.transpose().template triangularView<Upper>());
00202 
00203   \textcolor{comment}{// Not supported yet: trmm}
00204 \textcolor{comment}{//   VERIFY\_IS\_APPROX(sd*mcd*md.template triangularView<Lower>(),  sd*mcd*md.template
       cast<CD>().eval().template triangularView<Lower>());}
00205 \textcolor{comment}{//   VERIFY\_IS\_APPROX(scd*mcd*md.template triangularView<Upper>(), scd*mcd*md.template
       cast<CD>().eval().template triangularView<Upper>());}
00206 \textcolor{comment}{//   VERIFY\_IS\_APPROX(sd*md*mcd.template triangularView<Lower>(),  sd*md.template
       cast<CD>().eval()*mcd.template triangularView<Lower>());}
00207 \textcolor{comment}{//   VERIFY\_IS\_APPROX(scd*md*mcd.template triangularView<Upper>(), scd*md.template
       cast<CD>().eval()*mcd.template triangularView<Upper>());}
00208 
00209   \textcolor{comment}{// Not supported yet: symv}
00210 \textcolor{comment}{//   VERIFY\_IS\_APPROX(sd*vcd.adjoint()*md.template selfadjointView<Upper>(),  sd*vcd.adjoint()*md.template
       cast<CD>().eval().template selfadjointView<Upper>());}
00211 \textcolor{comment}{//   VERIFY\_IS\_APPROX(scd*vcd.adjoint()*md.template selfadjointView<Lower>(), scd*vcd.adjoint()*md.template
       cast<CD>().eval().template selfadjointView<Lower>());}
00212 \textcolor{comment}{//   VERIFY\_IS\_APPROX(sd*vd.adjoint()*mcd.template selfadjointView<Lower>(),  sd*vd.adjoint().template
       cast<CD>().eval()*mcd.template selfadjointView<Lower>());}
00213 \textcolor{comment}{//   VERIFY\_IS\_APPROX(scd*vd.adjoint()*mcd.template selfadjointView<Upper>(), scd*vd.adjoint().template
       cast<CD>().eval()*mcd.template selfadjointView<Upper>());}
00214 
00215   \textcolor{comment}{// Not supported yet: symm}
00216 \textcolor{comment}{//   VERIFY\_IS\_APPROX(sd*vcd.adjoint()*md.template selfadjointView<Upper>(),  sd*vcd.adjoint()*md.template
       cast<CD>().eval().template selfadjointView<Upper>());}
00217 \textcolor{comment}{//   VERIFY\_IS\_APPROX(scd*vcd.adjoint()*md.template selfadjointView<Upper>(), scd*vcd.adjoint()*md.template
       cast<CD>().eval().template selfadjointView<Upper>());}
00218 \textcolor{comment}{//   VERIFY\_IS\_APPROX(sd*vd.adjoint()*mcd.template selfadjointView<Upper>(),  sd*vd.adjoint().template
       cast<CD>().eval()*mcd.template selfadjointView<Upper>());}
00219 \textcolor{comment}{//   VERIFY\_IS\_APPROX(scd*vd.adjoint()*mcd.template selfadjointView<Upper>(), scd*vd.adjoint().template
       cast<CD>().eval()*mcd.template selfadjointView<Upper>());}
00220 
00221   rcd.setZero();
00222   VERIFY\_IS\_APPROX(Mat\_cd(rcd.template triangularView<Upper>() = sd * mcd * md),
00223                    Mat\_cd((sd * mcd * md.template cast<CD>().eval()).\textcolor{keyword}{template} triangularView<Upper>()));
00224   VERIFY\_IS\_APPROX(Mat\_cd(rcd.template triangularView<Upper>() = sd * md * mcd),
00225                    Mat\_cd((sd * md.template cast<CD>().eval() * mcd).\textcolor{keyword}{template} triangularView<Upper>()));
00226   VERIFY\_IS\_APPROX(Mat\_cd(rcd.template triangularView<Upper>() = scd * mcd * md),
00227                    Mat\_cd((scd * mcd * md.template cast<CD>().eval()).\textcolor{keyword}{template} triangularView<Upper>()));
00228   VERIFY\_IS\_APPROX(Mat\_cd(rcd.template triangularView<Upper>() = scd * md * mcd),
00229                    Mat\_cd((scd * md.template cast<CD>().eval() * mcd).\textcolor{keyword}{template} triangularView<Upper>()));
00230 
00231 
00232   VERIFY\_IS\_APPROX( md.array()  * mcd.array(), md.template cast<CD>().eval().array() * mcd.array() );
00233   VERIFY\_IS\_APPROX( mcd.array() * md.array(),  mcd.array() * md.template cast<CD>().eval().array() );
00234 
00235   VERIFY\_IS\_APPROX( md.array()  + mcd.array(), md.template cast<CD>().eval().array() + mcd.array() );
00236   VERIFY\_IS\_APPROX( mcd.array() + md.array(),  mcd.array() + md.template cast<CD>().eval().array() );
00237 
00238   VERIFY\_IS\_APPROX( md.array()  - mcd.array(), md.template cast<CD>().eval().array() - mcd.array() );
00239   VERIFY\_IS\_APPROX( mcd.array() - md.array(),  mcd.array() - md.template cast<CD>().eval().array() );
00240 
00241   \textcolor{keywordflow}{if}(mcd.array().abs().minCoeff()>epsd)
00242   \{
00243     VERIFY\_IS\_APPROX( md.array() / mcd.array(), md.template cast<CD>().eval().array() / mcd.array() );
00244   \}
00245   \textcolor{keywordflow}{if}(md.array().abs().minCoeff()>epsd)
00246   \{
00247     VERIFY\_IS\_APPROX( mcd.array() / md.array(), mcd.array() / md.template cast<CD>().eval().array() );
00248   \}
00249 
00250   \textcolor{keywordflow}{if}(md.array().abs().minCoeff()>epsd || mcd.array().abs().minCoeff()>epsd)
00251   \{
00252     VERIFY\_IS\_APPROX( md.array().pow(mcd.array()), md.template cast<CD>().eval().array().pow(mcd.array()) )
      ;
00253     VERIFY\_IS\_APPROX( mcd.array().pow(md.array()),  mcd.array().pow(md.template cast<CD>().eval().array()) 
      );
00254 
00255     VERIFY\_IS\_APPROX( pow(md.array(),mcd.array()), md.template cast<CD>().eval().array().pow(mcd.array()) )
      ;
00256     VERIFY\_IS\_APPROX( pow(mcd.array(),md.array()),  mcd.array().pow(md.template cast<CD>().eval().array()) 
      );
00257   \}
00258 
00259   rcd = mcd;
00260   VERIFY\_IS\_APPROX( rcd = md, md.template cast<CD>().eval() );
00261   rcd = mcd;
00262   VERIFY\_IS\_APPROX( rcd += md, mcd + md.template cast<CD>().eval() );
00263   rcd = mcd;
00264   VERIFY\_IS\_APPROX( rcd -= md, mcd - md.template cast<CD>().eval() );
00265   rcd = mcd;
00266   VERIFY\_IS\_APPROX( rcd.array() *= md.array(), mcd.array() * md.template cast<CD>().eval().array() );
00267   rcd = mcd;
00268   \textcolor{keywordflow}{if}(md.array().abs().minCoeff()>epsd)
00269   \{
00270     VERIFY\_IS\_APPROX( rcd.array() /= md.array(), mcd.array() / md.template cast<CD>().eval().array() );
00271   \}
00272 
00273   rcd = mcd;
00274   VERIFY\_IS\_APPROX( rcd.noalias() += md + mcd*md, mcd + (md.template cast<CD>().eval()) + mcd*(md.template 
      cast<CD>().eval()));
00275 
00276   VERIFY\_IS\_APPROX( rcd.noalias()  = md*md,       ((md*md).eval().template cast<CD>()) );
00277   rcd = mcd;
00278   VERIFY\_IS\_APPROX( rcd.noalias() += md*md, mcd + ((md*md).eval().template cast<CD>()) );
00279   rcd = mcd;
00280   VERIFY\_IS\_APPROX( rcd.noalias() -= md*md, mcd - ((md*md).eval().template cast<CD>()) );
00281 
00282   VERIFY\_IS\_APPROX( rcd.noalias()  = mcd + md*md,       mcd + ((md*md).eval().template cast<CD>()) );
00283   rcd = mcd;
00284   VERIFY\_IS\_APPROX( rcd.noalias() += mcd + md*md, mcd + mcd + ((md*md).eval().template cast<CD>()) );
00285   rcd = mcd;
00286   VERIFY\_IS\_APPROX( rcd.noalias() -= mcd + md*md,           - ((md*md).eval().template cast<CD>()) );
00287 \}
00288 
00289 \textcolor{keywordtype}{void} test\_mixingtypes()
00290 \{
00291   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00292     CALL\_SUBTEST\_1(mixingtypes<3>());
00293     CALL\_SUBTEST\_2(mixingtypes<4>());
00294     CALL\_SUBTEST\_3(mixingtypes<Dynamic>(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE)));
00295 
00296     CALL\_SUBTEST\_4(mixingtypes<3>());
00297     CALL\_SUBTEST\_5(mixingtypes<4>());
00298     CALL\_SUBTEST\_6(mixingtypes<Dynamic>(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE)));
00299   \}
00300 \}
\end{DoxyCode}
