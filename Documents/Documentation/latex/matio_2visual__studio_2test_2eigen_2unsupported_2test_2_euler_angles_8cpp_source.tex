\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2test_2_euler_angles_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/test/\+Euler\+Angles.cpp}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2test_2_euler_angles_8cpp_source}\index{Euler\+Angles.\+cpp@{Euler\+Angles.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Tal Hadad <tal\_hd@hotmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{preprocessor}{#include <unsupported/Eigen/EulerAngles>}
00013 
00014 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00015 
00016 \textcolor{keyword}{template}<\textcolor{keyword}{typename} EulerSystem, \textcolor{keyword}{typename} Scalar>
00017 \textcolor{keywordtype}{void} verify\_euler\_ranged(\textcolor{keyword}{const} \hyperlink{group___core___module}{Matrix<Scalar,3,1>}& ea,
00018   \textcolor{keywordtype}{bool} positiveRangeAlpha, \textcolor{keywordtype}{bool} positiveRangeBeta, \textcolor{keywordtype}{bool} positiveRangeGamma)
00019 \{
00020   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_euler_angles}{EulerAngles<Scalar, EulerSystem>} EulerAnglesType;
00021   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,3,3>} Matrix3;
00022   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,3,1>} Vector3;
00023   \textcolor{keyword}{typedef} \hyperlink{group___geometry___module_class_eigen_1_1_quaternion}{Quaternion<Scalar>} QuaternionType;
00024   \textcolor{keyword}{typedef} \hyperlink{group___geometry___module_class_eigen_1_1_angle_axis}{AngleAxis<Scalar>} AngleAxisType;
00025   \textcolor{keyword}{using} std::abs;
00026   
00027   Scalar alphaRangeStart, alphaRangeEnd;
00028   Scalar betaRangeStart, betaRangeEnd;
00029   Scalar gammaRangeStart, gammaRangeEnd;
00030   
00031   \textcolor{keywordflow}{if} (positiveRangeAlpha)
00032   \{
00033     alphaRangeStart = Scalar(0);
00034     alphaRangeEnd = Scalar(2 * EIGEN\_PI);
00035   \}
00036   \textcolor{keywordflow}{else}
00037   \{
00038     alphaRangeStart = -Scalar(EIGEN\_PI);
00039     alphaRangeEnd = Scalar(EIGEN\_PI);
00040   \}
00041   
00042   \textcolor{keywordflow}{if} (positiveRangeBeta)
00043   \{
00044     betaRangeStart = Scalar(0);
00045     betaRangeEnd = Scalar(2 * EIGEN\_PI);
00046   \}
00047   \textcolor{keywordflow}{else}
00048   \{
00049     betaRangeStart = -Scalar(EIGEN\_PI);
00050     betaRangeEnd = Scalar(EIGEN\_PI);
00051   \}
00052   
00053   \textcolor{keywordflow}{if} (positiveRangeGamma)
00054   \{
00055     gammaRangeStart = Scalar(0);
00056     gammaRangeEnd = Scalar(2 * EIGEN\_PI);
00057   \}
00058   \textcolor{keywordflow}{else}
00059   \{
00060     gammaRangeStart = -Scalar(EIGEN\_PI);
00061     gammaRangeEnd = Scalar(EIGEN\_PI);
00062   \}
00063   
00064   \textcolor{keyword}{const} \textcolor{keywordtype}{int} i = \hyperlink{class_eigen_1_1_euler_system_ab1604e0e8eb9b72fa937236fdb9fd68da54814e9f1958769932e1f1a2047701b8}{EulerSystem::AlphaAxisAbs} - 1;
00065   \textcolor{keyword}{const} \textcolor{keywordtype}{int} j = \hyperlink{class_eigen_1_1_euler_system_ab1604e0e8eb9b72fa937236fdb9fd68daaea3c35e3fd2cab857f0b37feaa80c05}{EulerSystem::BetaAxisAbs} - 1;
00066   \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = \hyperlink{class_eigen_1_1_euler_system_ab1604e0e8eb9b72fa937236fdb9fd68daef2019be264b8fb5dbd4a5ca4f118b29}{EulerSystem::GammaAxisAbs} - 1;
00067   
00068   \textcolor{keyword}{const} \textcolor{keywordtype}{int} iFactor = \hyperlink{class_eigen_1_1_euler_system_ab1604e0e8eb9b72fa937236fdb9fd68daac88718d0bd48e25e3e715af12342de7}{EulerSystem::IsAlphaOpposite} ? -1 : 1;
00069   \textcolor{keyword}{const} \textcolor{keywordtype}{int} jFactor = \hyperlink{class_eigen_1_1_euler_system_ab1604e0e8eb9b72fa937236fdb9fd68da659596aeadc17ade7dff5b8740c04ca8}{EulerSystem::IsBetaOpposite} ? -1 : 1;
00070   \textcolor{keyword}{const} \textcolor{keywordtype}{int} kFactor = \hyperlink{class_eigen_1_1_euler_system_ab1604e0e8eb9b72fa937236fdb9fd68da6779029ac21bd5102818c8ea8cf6c031}{EulerSystem::IsGammaOpposite} ? -1 : 1;
00071   
00072   \textcolor{keyword}{const} Vector3 I = EulerAnglesType::AlphaAxisVector();
00073   \textcolor{keyword}{const} Vector3 J = EulerAnglesType::BetaAxisVector();
00074   \textcolor{keyword}{const} Vector3 K = EulerAnglesType::GammaAxisVector();
00075   
00076   EulerAnglesType e(ea[0], ea[1], ea[2]);
00077   
00078   Matrix3 m(e);
00079   Vector3 eabis = EulerAnglesType(m, positiveRangeAlpha, positiveRangeBeta, positiveRangeGamma).angles();
00080   
00081   \textcolor{comment}{// Check that eabis in range}
00082   VERIFY(alphaRangeStart <= eabis[0] && eabis[0] <= alphaRangeEnd);
00083   VERIFY(betaRangeStart <= eabis[1] && eabis[1] <= betaRangeEnd);
00084   VERIFY(gammaRangeStart <= eabis[2] && eabis[2] <= gammaRangeEnd);
00085   
00086   Vector3 eabis2 = m.eulerAngles(i, j, k);
00087   
00088   \textcolor{comment}{// Invert the relevant axes}
00089   eabis2[0] *= iFactor;
00090   eabis2[1] *= jFactor;
00091   eabis2[2] *= kFactor;
00092   
00093   \textcolor{comment}{// Saturate the angles to the correct range}
00094   \textcolor{keywordflow}{if} (positiveRangeAlpha && (eabis2[0] < 0))
00095     eabis2[0] += Scalar(2 * EIGEN\_PI);
00096   \textcolor{keywordflow}{if} (positiveRangeBeta && (eabis2[1] < 0))
00097     eabis2[1] += Scalar(2 * EIGEN\_PI);
00098   \textcolor{keywordflow}{if} (positiveRangeGamma && (eabis2[2] < 0))
00099     eabis2[2] += Scalar(2 * EIGEN\_PI);
00100   
00101   VERIFY\_IS\_APPROX(eabis, eabis2);\textcolor{comment}{// Verify that our estimation is the same as m.eulerAngles() is}
00102   
00103   Matrix3 mbis(AngleAxisType(eabis[0], I) * AngleAxisType(eabis[1], J) * AngleAxisType(eabis[2], K));
00104   VERIFY\_IS\_APPROX(m,  mbis);
00105   
00106   \textcolor{comment}{// Tests that are only relevant for no possitive range}
00107   \textcolor{keywordflow}{if} (!(positiveRangeAlpha || positiveRangeBeta || positiveRangeGamma))
00108   \{
00109     \textcolor{comment}{/* If I==K, and ea[1]==0, then there no unique solution. */} 
00110     \textcolor{comment}{/* The remark apply in the case where I!=K, and |ea[1]| is close to pi/2. */} 
00111     \textcolor{keywordflow}{if}( (i!=k || ea[1]!=0) && (i==k || !internal::isApprox(abs(ea[1]),Scalar(EIGEN\_PI/2),
      test\_precision<Scalar>())) ) 
00112       VERIFY((ea-eabis).norm() <= test\_precision<Scalar>());
00113     
00114     \textcolor{comment}{// approx\_or\_less\_than does not work for 0}
00115     VERIFY(0 < eabis[0] || test\_isMuchSmallerThan(eabis[0], Scalar(1)));
00116   \}
00117   
00118   \textcolor{comment}{// Quaternions}
00119   QuaternionType q(e);
00120   eabis = EulerAnglesType(q, positiveRangeAlpha, positiveRangeBeta, positiveRangeGamma).angles();
00121   VERIFY\_IS\_APPROX(eabis, eabis2);\textcolor{comment}{// Verify that the euler angles are still the same}
00122 \}
00123 
00124 \textcolor{keyword}{template}<\textcolor{keyword}{typename} EulerSystem, \textcolor{keyword}{typename} Scalar>
00125 \textcolor{keywordtype}{void} verify\_euler(\textcolor{keyword}{const} \hyperlink{group___core___module}{Matrix<Scalar,3,1>}& ea)
00126 \{
00127   verify\_euler\_ranged<EulerSystem>(ea, \textcolor{keyword}{false}, \textcolor{keyword}{false}, \textcolor{keyword}{false});
00128   verify\_euler\_ranged<EulerSystem>(ea, \textcolor{keyword}{false}, \textcolor{keyword}{false}, \textcolor{keyword}{true});
00129   verify\_euler\_ranged<EulerSystem>(ea, \textcolor{keyword}{false}, \textcolor{keyword}{true}, \textcolor{keyword}{false});
00130   verify\_euler\_ranged<EulerSystem>(ea, \textcolor{keyword}{false}, \textcolor{keyword}{true}, \textcolor{keyword}{true});
00131   verify\_euler\_ranged<EulerSystem>(ea, \textcolor{keyword}{true}, \textcolor{keyword}{false}, \textcolor{keyword}{false});
00132   verify\_euler\_ranged<EulerSystem>(ea, \textcolor{keyword}{true}, \textcolor{keyword}{false}, \textcolor{keyword}{true});
00133   verify\_euler\_ranged<EulerSystem>(ea, \textcolor{keyword}{true}, \textcolor{keyword}{true}, \textcolor{keyword}{false});
00134   verify\_euler\_ranged<EulerSystem>(ea, \textcolor{keyword}{true}, \textcolor{keyword}{true}, \textcolor{keyword}{true});
00135 \}
00136 
00137 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} check\_all\_var(\textcolor{keyword}{const} \hyperlink{group___core___module}{Matrix<Scalar,3,1>}& ea)
00138 \{
00139   verify\_euler<EulerSystemXYZ>(ea);
00140   verify\_euler<EulerSystemXYX>(ea);
00141   verify\_euler<EulerSystemXZY>(ea);
00142   verify\_euler<EulerSystemXZX>(ea);
00143   
00144   verify\_euler<EulerSystemYZX>(ea);
00145   verify\_euler<EulerSystemYZY>(ea);
00146   verify\_euler<EulerSystemYXZ>(ea);
00147   verify\_euler<EulerSystemYXY>(ea);
00148   
00149   verify\_euler<EulerSystemZXY>(ea);
00150   verify\_euler<EulerSystemZXZ>(ea);
00151   verify\_euler<EulerSystemZYX>(ea);
00152   verify\_euler<EulerSystemZYZ>(ea);
00153 \}
00154 
00155 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} eulerangles()
00156 \{
00157   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,3,3>} Matrix3;
00158   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,3,1>} Vector3;
00159   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,3,1>} Array3;
00160   \textcolor{keyword}{typedef} \hyperlink{group___geometry___module_class_eigen_1_1_quaternion}{Quaternion<Scalar>} Quaternionx;
00161   \textcolor{keyword}{typedef} \hyperlink{group___geometry___module_class_eigen_1_1_angle_axis}{AngleAxis<Scalar>} AngleAxisType;
00162 
00163   Scalar a = internal::random<Scalar>(-Scalar(EIGEN\_PI), Scalar(EIGEN\_PI));
00164   Quaternionx q1;
00165   q1 = AngleAxisType(a, Vector3::Random().normalized());
00166   Matrix3 m;
00167   m = q1;
00168   
00169   Vector3 ea = m.eulerAngles(0,1,2);
00170   check\_all\_var(ea);
00171   ea = m.eulerAngles(0,1,0);
00172   check\_all\_var(ea);
00173   
00174   \textcolor{comment}{// Check with purely random Quaternion:}
00175   q1.coeffs() = Quaternionx::Coefficients::Random().normalized();
00176   m = q1;
00177   ea = m.eulerAngles(0,1,2);
00178   check\_all\_var(ea);
00179   ea = m.eulerAngles(0,1,0);
00180   check\_all\_var(ea);
00181   
00182   \textcolor{comment}{// Check with random angles in range [0:pi]x[-pi:pi]x[-pi:pi].}
00183   ea = (Array3::Random() + Array3(1,0,0))*Scalar(EIGEN\_PI)*Array3(0.5,1,1);
00184   check\_all\_var(ea);
00185   
00186   ea[2] = ea[0] = internal::random<Scalar>(0,Scalar(EIGEN\_PI));
00187   check\_all\_var(ea);
00188   
00189   ea[0] = ea[1] = internal::random<Scalar>(0,Scalar(EIGEN\_PI));
00190   check\_all\_var(ea);
00191   
00192   ea[1] = 0;
00193   check\_all\_var(ea);
00194   
00195   ea.head(2).setZero();
00196   check\_all\_var(ea);
00197   
00198   ea.setZero();
00199   check\_all\_var(ea);
00200 \}
00201 
00202 \textcolor{keywordtype}{void} test\_EulerAngles()
00203 \{
00204   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00205     CALL\_SUBTEST\_1( eulerangles<float>() );
00206     CALL\_SUBTEST\_2( eulerangles<double>() );
00207   \}
00208 \}
\end{DoxyCode}
