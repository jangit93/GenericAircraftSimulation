\hypertarget{eigen_2bench_2benchmark-blocking-sizes_8cpp_source}{}\section{eigen/bench/benchmark-\/blocking-\/sizes.cpp}
\label{eigen_2bench_2benchmark-blocking-sizes_8cpp_source}\index{benchmark-\/blocking-\/sizes.\+cpp@{benchmark-\/blocking-\/sizes.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Benoit Jacob <benoitjacob@google.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include <iostream>}
00011 \textcolor{preprocessor}{#include <cstdint>}
00012 \textcolor{preprocessor}{#include <cstdlib>}
00013 \textcolor{preprocessor}{#include <vector>}
00014 \textcolor{preprocessor}{#include <fstream>}
00015 \textcolor{preprocessor}{#include <memory>}
00016 \textcolor{preprocessor}{#include <cstdio>}
00017 
00018 \textcolor{keywordtype}{bool} eigen\_use\_specific\_block\_size;
00019 \textcolor{keywordtype}{int} eigen\_block\_size\_k, eigen\_block\_size\_m, eigen\_block\_size\_n;
00020 \textcolor{preprocessor}{#define EIGEN\_TEST\_SPECIFIC\_BLOCKING\_SIZES eigen\_use\_specific\_block\_size}
00021 \textcolor{preprocessor}{#define EIGEN\_TEST\_SPECIFIC\_BLOCKING\_SIZE\_K eigen\_block\_size\_k}
00022 \textcolor{preprocessor}{#define EIGEN\_TEST\_SPECIFIC\_BLOCKING\_SIZE\_M eigen\_block\_size\_m}
00023 \textcolor{preprocessor}{#define EIGEN\_TEST\_SPECIFIC\_BLOCKING\_SIZE\_N eigen\_block\_size\_n}
00024 \textcolor{preprocessor}{#include <Eigen/Core>}
00025 
00026 \textcolor{preprocessor}{#include <bench/BenchTimer.h>}
00027 
00028 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00029 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00030 
00031 \textcolor{keyword}{static} \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} timer;
00032 
00033 \textcolor{comment}{// how many times we repeat each measurement.}
00034 \textcolor{comment}{// measurements are randomly shuffled - we're not doing}
00035 \textcolor{comment}{// all N identical measurements in a row.}
00036 \textcolor{keyword}{const} \textcolor{keywordtype}{int} measurement\_repetitions = 3;
00037 
00038 \textcolor{comment}{// Timings below this value are too short to be accurate,}
00039 \textcolor{comment}{// we'll repeat measurements with more iterations until}
00040 \textcolor{comment}{// we get a timing above that threshold.}
00041 \textcolor{keyword}{const} \textcolor{keywordtype}{float} min\_accurate\_time = 1e-2f;
00042 
00043 \textcolor{comment}{// See --min-working-set-size command line parameter.}
00044 \textcolor{keywordtype}{size\_t} min\_working\_set\_size = 0;
00045 
00046 \textcolor{keywordtype}{float} max\_clock\_speed = 0.0f;
00047 
00048 \textcolor{comment}{// range of sizes that we will benchmark (in all 3 K,M,N dimensions)}
00049 \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} maxsize = 2048;
00050 \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} minsize = 16;
00051 
00052 \textcolor{keyword}{typedef} MatrixXf MatrixType;
00053 \textcolor{keyword}{typedef} MatrixType::Scalar Scalar;
00054 \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{internal::packet\_traits<Scalar>::type} 
      \hyperlink{group___sparse_core___module}{Packet};
00055 
00056 static\_assert((maxsize & (maxsize - 1)) == 0, \textcolor{stringliteral}{"maxsize must be a power of two"});
00057 static\_assert((minsize & (minsize - 1)) == 0, \textcolor{stringliteral}{"minsize must be a power of two"});
00058 static\_assert(maxsize > minsize, \textcolor{stringliteral}{"maxsize must be larger than minsize"});
00059 static\_assert(maxsize < (minsize << 16), \textcolor{stringliteral}{"maxsize must be less than (minsize<<16)"});
00060 
00061 \textcolor{comment}{// just a helper to store a triple of K,M,N sizes for matrix product}
00062 \textcolor{keyword}{struct }\hyperlink{structsize__triple__t}{size\_triple\_t}
00063 \{
00064   \textcolor{keywordtype}{size\_t} k, m, n;
00065   \hyperlink{structsize__triple__t}{size\_triple\_t}() : k(0), m(0), n(0) \{\}
00066   \hyperlink{structsize__triple__t}{size\_triple\_t}(\textcolor{keywordtype}{size\_t} \_k, \textcolor{keywordtype}{size\_t} \_m, \textcolor{keywordtype}{size\_t} \_n) : k(\_k), m(\_m), n(\_n) \{\}
00067   \hyperlink{structsize__triple__t}{size\_triple\_t}(\textcolor{keyword}{const} \hyperlink{structsize__triple__t}{size\_triple\_t}& o) : k(o.k), m(o.m), n(o.n) \{\}
00068   \hyperlink{structsize__triple__t}{size\_triple\_t}(uint16\_t compact)
00069   \{
00070     k = 1 << ((compact & 0xf00) >> 8);
00071     m = 1 << ((compact & 0x0f0) >> 4);
00072     n = 1 << ((compact & 0x00f) >> 0);
00073   \}
00074 \};
00075 
00076 uint8\_t log2\_pot(\textcolor{keywordtype}{size\_t} x) \{
00077   \textcolor{keywordtype}{size\_t} l = 0;
00078   \textcolor{keywordflow}{while} (x >>= 1) l++;
00079   \textcolor{keywordflow}{return} l;
00080 \}
00081 
00082 \textcolor{comment}{// Convert between size tripes and a compact form fitting in 12 bits}
00083 \textcolor{comment}{// where each size, which must be a POT, is encoded as its log2, on 4 bits}
00084 \textcolor{comment}{// so the largest representable size is 2^15 == 32k  ... big enough.}
00085 uint16\_t compact\_size\_triple(\textcolor{keywordtype}{size\_t} k, \textcolor{keywordtype}{size\_t} m, \textcolor{keywordtype}{size\_t} n)
00086 \{
00087   \textcolor{keywordflow}{return} (log2\_pot(k) << 8) | (log2\_pot(m) << 4) | log2\_pot(n);
00088 \}
00089 
00090 uint16\_t compact\_size\_triple(\textcolor{keyword}{const} \hyperlink{structsize__triple__t}{size\_triple\_t}& t)
00091 \{
00092   \textcolor{keywordflow}{return} compact\_size\_triple(t.k, t.m, t.n);
00093 \}
00094 
00095 \textcolor{comment}{// A single benchmark. Initially only contains benchmark params.}
00096 \textcolor{comment}{// Then call run(), which stores the result in the gflops field.}
\Hypertarget{eigen_2bench_2benchmark-blocking-sizes_8cpp_source_l00097}\hyperlink{structbenchmark__t}{00097} \textcolor{keyword}{struct }\hyperlink{structbenchmark__t}{benchmark\_t}
00098 \{
00099   uint16\_t compact\_product\_size;
00100   uint16\_t compact\_block\_size;
00101   \textcolor{keywordtype}{bool} use\_default\_block\_size;
00102   \textcolor{keywordtype}{float} gflops;
00103   \hyperlink{structbenchmark__t}{benchmark\_t}()
00104     : compact\_product\_size(0)
00105     , compact\_block\_size(0)
00106     , use\_default\_block\_size(\textcolor{keyword}{false})
00107     , gflops(0)
00108   \{
00109   \}
00110   \hyperlink{structbenchmark__t}{benchmark\_t}(\textcolor{keywordtype}{size\_t} pk, \textcolor{keywordtype}{size\_t} pm, \textcolor{keywordtype}{size\_t} pn,
00111               \textcolor{keywordtype}{size\_t} bk, \textcolor{keywordtype}{size\_t} bm, \textcolor{keywordtype}{size\_t} bn)
00112     : compact\_product\_size(compact\_size\_triple(pk, pm, pn))
00113     , compact\_block\_size(compact\_size\_triple(bk, bm, bn))
00114     , use\_default\_block\_size(\textcolor{keyword}{false})
00115     , gflops(0)
00116   \{\}
00117   \hyperlink{structbenchmark__t}{benchmark\_t}(\textcolor{keywordtype}{size\_t} pk, \textcolor{keywordtype}{size\_t} pm, \textcolor{keywordtype}{size\_t} pn)
00118     : compact\_product\_size(compact\_size\_triple(pk, pm, pn))
00119     , compact\_block\_size(0)
00120     , use\_default\_block\_size(\textcolor{keyword}{true})
00121     , gflops(0)
00122   \{\}
00123 
00124   \textcolor{keywordtype}{void} run();
00125 \};
00126 
00127 ostream& operator<<(ostream& s, \textcolor{keyword}{const} \hyperlink{structbenchmark__t}{benchmark\_t}& b)
00128 \{
00129   s << hex << b.compact\_product\_size << dec;
00130   \textcolor{keywordflow}{if} (b.use\_default\_block\_size) \{
00131     \hyperlink{structsize__triple__t}{size\_triple\_t} t(b.compact\_product\_size);
00132     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = t.k, m = t.m, n = t.n;
00133     internal::computeProductBlockingSizes<Scalar, Scalar>(k, m, n);
00134     s << \textcolor{stringliteral}{" default("} << k << \textcolor{stringliteral}{", "} << m << \textcolor{stringliteral}{", "} << n << \textcolor{stringliteral}{")"};
00135   \} \textcolor{keywordflow}{else} \{
00136     s << \textcolor{stringliteral}{" "} << hex << b.compact\_block\_size << dec;
00137   \}
00138   s << \textcolor{stringliteral}{" "} << b.gflops;
00139   \textcolor{keywordflow}{return} s;
00140 \}
00141 
00142 \textcolor{comment}{// We sort first by increasing benchmark parameters,}
00143 \textcolor{comment}{// then by decreasing performance.}
00144 \textcolor{keywordtype}{bool} operator<(\textcolor{keyword}{const} \hyperlink{structbenchmark__t}{benchmark\_t}& b1, \textcolor{keyword}{const} \hyperlink{structbenchmark__t}{benchmark\_t}& b2)
00145 \{ 
00146   \textcolor{keywordflow}{return} b1.compact\_product\_size < b2.compact\_product\_size ||
00147            (b1.compact\_product\_size == b2.compact\_product\_size && (
00148              (b1.compact\_block\_size < b2.compact\_block\_size || (
00149                b1.compact\_block\_size == b2.compact\_block\_size &&
00150                  b1.gflops > b2.gflops))));
00151 \}
00152 
00153 \textcolor{keywordtype}{void} benchmark\_t::run()
00154 \{
00155   \hyperlink{structsize__triple__t}{size\_triple\_t} productsizes(compact\_product\_size);
00156 
00157   \textcolor{keywordflow}{if} (use\_default\_block\_size) \{
00158     eigen\_use\_specific\_block\_size = \textcolor{keyword}{false};
00159   \} \textcolor{keywordflow}{else} \{
00160     \textcolor{comment}{// feed eigen with our custom blocking params}
00161     eigen\_use\_specific\_block\_size = \textcolor{keyword}{true};
00162     \hyperlink{structsize__triple__t}{size\_triple\_t} blocksizes(compact\_block\_size);
00163     eigen\_block\_size\_k = blocksizes.k;
00164     eigen\_block\_size\_m = blocksizes.m;
00165     eigen\_block\_size\_n = blocksizes.n;
00166   \}
00167 
00168   \textcolor{comment}{// set up the matrix pool}
00169 
00170   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} combined\_three\_matrices\_sizes =
00171     \textcolor{keyword}{sizeof}(Scalar) *
00172       (productsizes.k * productsizes.m +
00173        productsizes.k * productsizes.n +
00174        productsizes.m * productsizes.n);
00175 
00176   \textcolor{comment}{// 64 M is large enough that nobody has a cache bigger than that,}
00177   \textcolor{comment}{// while still being small enough that everybody has this much RAM,}
00178   \textcolor{comment}{// so conveniently we don't need to special-case platforms here.}
00179   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} unlikely\_large\_cache\_size = 64 << 20;
00180 
00181   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} working\_set\_size =
00182     min\_working\_set\_size ? min\_working\_set\_size : unlikely\_large\_cache\_size;
00183 
00184   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} matrix\_pool\_size =
00185     1 + working\_set\_size / combined\_three\_matrices\_sizes;
00186 
00187   MatrixType *lhs = \textcolor{keyword}{new} MatrixType[matrix\_pool\_size];
00188   MatrixType *rhs = \textcolor{keyword}{new} MatrixType[matrix\_pool\_size];
00189   MatrixType *dst = \textcolor{keyword}{new} MatrixType[matrix\_pool\_size];
00190   
00191   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < matrix\_pool\_size; i++) \{
00192     lhs[i] = MatrixType::Zero(productsizes.m, productsizes.k);
00193     rhs[i] = MatrixType::Zero(productsizes.k, productsizes.n);
00194     dst[i] = MatrixType::Zero(productsizes.m, productsizes.n);
00195   \}
00196 
00197   \textcolor{comment}{// main benchmark loop}
00198 
00199   \textcolor{keywordtype}{int} iters\_at\_a\_time = 1;
00200   \textcolor{keywordtype}{float} time\_per\_iter = 0.0f;
00201   \textcolor{keywordtype}{size\_t} matrix\_index = 0;
00202   \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
00203 
00204     \textcolor{keywordtype}{double} starttime = timer.getCpuTime();
00205     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < iters\_at\_a\_time; i++) \{
00206       dst[matrix\_index].noalias() = lhs[matrix\_index] * rhs[matrix\_index];
00207       matrix\_index++;
00208       \textcolor{keywordflow}{if} (matrix\_index == matrix\_pool\_size) \{
00209         matrix\_index = 0;
00210       \}
00211     \}
00212     \textcolor{keywordtype}{double} endtime = timer.getCpuTime();
00213 
00214     \textcolor{keyword}{const} \textcolor{keywordtype}{float} timing = float(endtime - starttime);
00215 
00216     \textcolor{keywordflow}{if} (timing >= min\_accurate\_time) \{
00217       time\_per\_iter = timing / iters\_at\_a\_time;
00218       \textcolor{keywordflow}{break};
00219     \}
00220 
00221     iters\_at\_a\_time *= 2;
00222   \}
00223 
00224   \textcolor{keyword}{delete}[] lhs;
00225   \textcolor{keyword}{delete}[] rhs;
00226   \textcolor{keyword}{delete}[] dst;
00227 
00228   gflops = 2e-9 * productsizes.k * productsizes.m * productsizes.n / time\_per\_iter;
00229 \}
00230 
00231 \textcolor{keywordtype}{void} print\_cpuinfo()
00232 \{
00233 \textcolor{preprocessor}{#ifdef \_\_linux\_\_}
00234   cout << \textcolor{stringliteral}{"contents of /proc/cpuinfo:"} << endl;
00235   \textcolor{keywordtype}{string} line;
00236   ifstream cpuinfo(\textcolor{stringliteral}{"/proc/cpuinfo"});
00237   \textcolor{keywordflow}{if} (cpuinfo.is\_open()) \{
00238     \textcolor{keywordflow}{while} (getline(cpuinfo, line)) \{
00239       cout << line << endl;
00240     \}
00241     cpuinfo.close();
00242   \}
00243   cout << endl;
00244 \textcolor{preprocessor}{#elif defined \_\_APPLE\_\_}
00245   cout << \textcolor{stringliteral}{"output of sysctl hw:"} << endl;
00246   system(\textcolor{stringliteral}{"sysctl hw"});
00247   cout << endl;
00248 \textcolor{preprocessor}{#endif}
00249 \}
00250 
00251 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00252 \textcolor{keywordtype}{string} type\_name()
00253 \{
00254   \textcolor{keywordflow}{return} \textcolor{stringliteral}{"unknown"};
00255 \}
00256 
00257 \textcolor{keyword}{template}<>
00258 \textcolor{keywordtype}{string} type\_name<float>()
00259 \{
00260   \textcolor{keywordflow}{return} \textcolor{stringliteral}{"float"};
00261 \}
00262 
00263 \textcolor{keyword}{template}<>
00264 \textcolor{keywordtype}{string} type\_name<double>()
00265 \{
00266   \textcolor{keywordflow}{return} \textcolor{stringliteral}{"double"};
00267 \}
00268 
00269 \textcolor{keyword}{struct }\hyperlink{structaction__t}{action\_t}
00270 \{
00271   \textcolor{keyword}{virtual} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* invokation\_name()\textcolor{keyword}{ const }\{ abort(); \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr}; \}
00272   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} run()\textcolor{keyword}{ const }\{ abort(); \}
00273   \textcolor{keyword}{virtual} ~\hyperlink{structaction__t}{action\_t}() \{\}
00274 \};
00275 
00276 \textcolor{keywordtype}{void} show\_usage\_and\_exit(\textcolor{keywordtype}{int} \textcolor{comment}{/*argc*/}, \textcolor{keywordtype}{char}* argv[],
00277                          \textcolor{keyword}{const} vector<unique\_ptr<action\_t>>& available\_actions)
00278 \{
00279   cerr << \textcolor{stringliteral}{"usage: "} << argv[0] << \textcolor{stringliteral}{" <action> [options...]"} << endl << endl;
00280   cerr << \textcolor{stringliteral}{"available actions:"} << endl << endl;
00281   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = available\_actions.begin(); it != available\_actions.end(); ++it) \{
00282     cerr << \textcolor{stringliteral}{"  "} << (*it)->invokation\_name() << endl;
00283   \}
00284   cerr << endl;
00285   cerr << \textcolor{stringliteral}{"options:"} << endl << endl;
00286   cerr << \textcolor{stringliteral}{"  --min-working-set-size=N:"} << endl;
00287   cerr << \textcolor{stringliteral}{"       Set the minimum working set size to N bytes."} << endl;
00288   cerr << \textcolor{stringliteral}{"       This is rounded up as needed to a multiple of matrix size."} << endl;
00289   cerr << \textcolor{stringliteral}{"       A larger working set lowers the chance of a warm cache."} << endl;
00290   cerr << \textcolor{stringliteral}{"       The default value 0 means use a large enough working"} << endl;
00291   cerr << \textcolor{stringliteral}{"       set to likely outsize caches."} << endl;
00292   cerr << \textcolor{stringliteral}{"       A value of 1 (that is, 1 byte) would mean don't do anything to"} << endl;
00293   cerr << \textcolor{stringliteral}{"       avoid warm caches."} << endl;
00294   exit(1);
00295 \}
00296      
00297 \textcolor{keywordtype}{float} measure\_clock\_speed()
00298 \{
00299   cerr << \textcolor{stringliteral}{"Measuring clock speed...                              \(\backslash\)r"} << flush;
00300           
00301   vector<float> all\_gflops;
00302   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 8; i++) \{
00303     \hyperlink{structbenchmark__t}{benchmark\_t} b(1024, 1024, 1024);
00304     b.run();
00305     all\_gflops.push\_back(b.gflops);
00306   \}
00307 
00308   sort(all\_gflops.begin(), all\_gflops.end());
00309   \textcolor{keywordtype}{float} stable\_estimate = all\_gflops[2] + all\_gflops[3] + all\_gflops[4] + all\_gflops[5];
00310 
00311   \textcolor{comment}{// multiply by an arbitrary constant to discourage trying doing anything with the}
00312   \textcolor{comment}{// returned values besides just comparing them with each other.}
00313   \textcolor{keywordtype}{float} result = stable\_estimate * 123.456f;
00314 
00315   \textcolor{keywordflow}{return} result;
00316 \}
00317 
\Hypertarget{eigen_2bench_2benchmark-blocking-sizes_8cpp_source_l00318}\hyperlink{structhuman__duration__t}{00318} \textcolor{keyword}{struct }\hyperlink{structhuman__duration__t}{human\_duration\_t}
00319 \{
00320   \textcolor{keywordtype}{int} seconds;
00321   \hyperlink{structhuman__duration__t}{human\_duration\_t}(\textcolor{keywordtype}{int} s) : seconds(s) \{\}
00322 \};
00323 
00324 ostream& operator<<(ostream& s, \textcolor{keyword}{const} \hyperlink{structhuman__duration__t}{human\_duration\_t}& d)
00325 \{
00326   \textcolor{keywordtype}{int} remainder = d.seconds;
00327   \textcolor{keywordflow}{if} (remainder > 3600) \{
00328     \textcolor{keywordtype}{int} hours = remainder / 3600;
00329     s << hours << \textcolor{stringliteral}{" h "};
00330     remainder -= hours * 3600;
00331   \}
00332   \textcolor{keywordflow}{if} (remainder > 60) \{
00333     \textcolor{keywordtype}{int} minutes = remainder / 60;
00334     s << minutes << \textcolor{stringliteral}{" min "};
00335     remainder -= minutes * 60;
00336   \}
00337   \textcolor{keywordflow}{if} (d.seconds < 600) \{
00338     s << remainder << \textcolor{stringliteral}{" s"};
00339   \}
00340   \textcolor{keywordflow}{return} s;
00341 \}
00342 
00343 \textcolor{keyword}{const} \textcolor{keywordtype}{char} session\_filename[] = \textcolor{stringliteral}{"/data/local/tmp/benchmark-blocking-sizes-session.data"};
00344 
00345 \textcolor{keywordtype}{void} serialize\_benchmarks(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} vector<benchmark\_t>& benchmarks, \textcolor{keywordtype}{size\_t} 
      first\_benchmark\_to\_run)
00346 \{
00347   FILE* \hyperlink{structfile}{file} = fopen(filename, \textcolor{stringliteral}{"w"});
00348   \textcolor{keywordflow}{if} (!file) \{
00349     cerr << \textcolor{stringliteral}{"Could not open file "} << filename << \textcolor{stringliteral}{" for writing."} << endl;
00350     cerr << \textcolor{stringliteral}{"Do you have write permissions on the current working directory?"} << endl;
00351     exit(1);
00352   \}
00353   \textcolor{keywordtype}{size\_t} benchmarks\_vector\_size = benchmarks.size();
00354   fwrite(&max\_clock\_speed, \textcolor{keyword}{sizeof}(max\_clock\_speed), 1, file);
00355   fwrite(&benchmarks\_vector\_size, \textcolor{keyword}{sizeof}(benchmarks\_vector\_size), 1, file);
00356   fwrite(&first\_benchmark\_to\_run, \textcolor{keyword}{sizeof}(first\_benchmark\_to\_run), 1, file);
00357   fwrite(benchmarks.data(), \textcolor{keyword}{sizeof}(\hyperlink{structbenchmark__t}{benchmark\_t}), benchmarks.size(), file);
00358   fclose(file);
00359 \}
00360 
00361 \textcolor{keywordtype}{bool} deserialize\_benchmarks(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, vector<benchmark\_t>& benchmarks, \textcolor{keywordtype}{size\_t}& 
      first\_benchmark\_to\_run)
00362 \{
00363   FILE* \hyperlink{structfile}{file} = fopen(filename, \textcolor{stringliteral}{"r"});
00364   \textcolor{keywordflow}{if} (!file) \{
00365     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00366   \}
00367   \textcolor{keywordflow}{if} (1 != fread(&max\_clock\_speed, \textcolor{keyword}{sizeof}(max\_clock\_speed), 1, file)) \{
00368     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00369   \}
00370   \textcolor{keywordtype}{size\_t} benchmarks\_vector\_size = 0;
00371   \textcolor{keywordflow}{if} (1 != fread(&benchmarks\_vector\_size, \textcolor{keyword}{sizeof}(benchmarks\_vector\_size), 1, file)) \{
00372     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00373   \}
00374   \textcolor{keywordflow}{if} (1 != fread(&first\_benchmark\_to\_run, \textcolor{keyword}{sizeof}(first\_benchmark\_to\_run), 1, file)) \{
00375     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00376   \}
00377   benchmarks.resize(benchmarks\_vector\_size);
00378   \textcolor{keywordflow}{if} (benchmarks.size() != fread(benchmarks.data(), \textcolor{keyword}{sizeof}(\hyperlink{structbenchmark__t}{benchmark\_t}), benchmarks.size(), file
      )) \{
00379     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00380   \}
00381   unlink(filename);
00382   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00383 \}
00384 
00385 \textcolor{keywordtype}{void} try\_run\_some\_benchmarks(
00386   vector<benchmark\_t>& benchmarks,
00387   \textcolor{keywordtype}{double} time\_start,
00388   \textcolor{keywordtype}{size\_t}& first\_benchmark\_to\_run)
00389 \{
00390   \textcolor{keywordflow}{if} (first\_benchmark\_to\_run == benchmarks.size()) \{
00391     \textcolor{keywordflow}{return};
00392   \}
00393 
00394   \textcolor{keywordtype}{double} time\_last\_progress\_update = 0;
00395   \textcolor{keywordtype}{double} time\_last\_clock\_speed\_measurement = 0;
00396   \textcolor{keywordtype}{double} time\_now = 0;
00397 
00398   \textcolor{keywordtype}{size\_t} benchmark\_index = first\_benchmark\_to\_run;
00399 
00400   \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
00401     \textcolor{keywordtype}{float} ratio\_done = float(benchmark\_index) / benchmarks.size();
00402     time\_now = timer.getRealTime();
00403 
00404     \textcolor{comment}{// We check clock speed every minute and at the end.}
00405     \textcolor{keywordflow}{if} (benchmark\_index == benchmarks.size() ||
00406         time\_now > time\_last\_clock\_speed\_measurement + 60.0f)
00407     \{
00408       time\_last\_clock\_speed\_measurement = time\_now;
00409 
00410       \textcolor{comment}{// Ensure that clock speed is as expected}
00411       \textcolor{keywordtype}{float} current\_clock\_speed = measure\_clock\_speed();
00412 
00413       \textcolor{comment}{// The tolerance needs to be smaller than the relative difference between}
00414       \textcolor{comment}{// clock speeds that a device could operate under.}
00415       \textcolor{comment}{// It seems unlikely that a device would be throttling clock speeds by}
00416       \textcolor{comment}{// amounts smaller than 2%.}
00417       \textcolor{comment}{// With a value of 1%, I was getting within noise on a Sandy Bridge.}
00418       \textcolor{keyword}{const} \textcolor{keywordtype}{float} clock\_speed\_tolerance = 0.02f;
00419 
00420       \textcolor{keywordflow}{if} (current\_clock\_speed > (1 + clock\_speed\_tolerance) * max\_clock\_speed) \{
00421         \textcolor{comment}{// Clock speed is now higher than we previously measured.}
00422         \textcolor{comment}{// Either our initial measurement was inaccurate, which won't happen}
00423         \textcolor{comment}{// too many times as we are keeping the best clock speed value and}
00424         \textcolor{comment}{// and allowing some tolerance; or something really weird happened,}
00425         \textcolor{comment}{// which invalidates all benchmark results collected so far.}
00426         \textcolor{comment}{// Either way, we better restart all over again now.}
00427         \textcolor{keywordflow}{if} (benchmark\_index) \{
00428           cerr << \textcolor{stringliteral}{"Restarting at "} << 100.0f * ratio\_done
00429                << \textcolor{stringliteral}{" % because clock speed increased.          "} << endl;
00430         \}
00431         max\_clock\_speed = current\_clock\_speed;
00432         first\_benchmark\_to\_run = 0;
00433         \textcolor{keywordflow}{return};
00434       \}
00435 
00436       \textcolor{keywordtype}{bool} rerun\_last\_tests = \textcolor{keyword}{false};
00437 
00438       \textcolor{keywordflow}{if} (current\_clock\_speed < (1 - clock\_speed\_tolerance) * max\_clock\_speed) \{
00439         cerr << \textcolor{stringliteral}{"Measurements completed so far: "}
00440              << 100.0f * ratio\_done
00441              << \textcolor{stringliteral}{" %                             "} << endl;
00442         cerr << \textcolor{stringliteral}{"Clock speed seems to be only "}
00443              << current\_clock\_speed/max\_clock\_speed
00444              << \textcolor{stringliteral}{" times what it used to be."} << endl;
00445 
00446         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} seconds\_to\_sleep\_if\_lower\_clock\_speed = 1;
00447 
00448         \textcolor{keywordflow}{while} (current\_clock\_speed < (1 - clock\_speed\_tolerance) * max\_clock\_speed) \{
00449           \textcolor{keywordflow}{if} (seconds\_to\_sleep\_if\_lower\_clock\_speed > 32) \{
00450             cerr << \textcolor{stringliteral}{"Sleeping longer probably won't make a difference."} << endl;
00451             cerr << \textcolor{stringliteral}{"Serializing benchmarks to "} << session\_filename << endl;
00452             serialize\_benchmarks(session\_filename, benchmarks, first\_benchmark\_to\_run);
00453             cerr << \textcolor{stringliteral}{"Now restart this benchmark, and it should pick up where we left."} << endl;
00454             exit(2);
00455           \}
00456           rerun\_last\_tests = \textcolor{keyword}{true};
00457           cerr << \textcolor{stringliteral}{"Sleeping "}
00458                << seconds\_to\_sleep\_if\_lower\_clock\_speed
00459                << \textcolor{stringliteral}{" s...                                   \(\backslash\)r"} << endl;
00460           sleep(seconds\_to\_sleep\_if\_lower\_clock\_speed);
00461           current\_clock\_speed = measure\_clock\_speed();
00462           seconds\_to\_sleep\_if\_lower\_clock\_speed *= 2;
00463         \}
00464       \}
00465 
00466       \textcolor{keywordflow}{if} (rerun\_last\_tests) \{
00467         cerr << \textcolor{stringliteral}{"Redoing the last "}
00468              << 100.0f * float(benchmark\_index - first\_benchmark\_to\_run) / benchmarks.size()
00469              << \textcolor{stringliteral}{" % because clock speed had been low.   "} << endl;
00470         \textcolor{keywordflow}{return};
00471       \}
00472 
00473       \textcolor{comment}{// nothing wrong with the clock speed so far, so there won't be a need to rerun}
00474       \textcolor{comment}{// benchmarks run so far in case we later encounter a lower clock speed.}
00475       first\_benchmark\_to\_run = benchmark\_index;
00476     \}
00477 
00478     \textcolor{keywordflow}{if} (benchmark\_index == benchmarks.size()) \{
00479       \textcolor{comment}{// We're done!}
00480       first\_benchmark\_to\_run = benchmarks.size();
00481       \textcolor{comment}{// Erase progress info}
00482       cerr << \textcolor{stringliteral}{"                                                            "} << endl;
00483       \textcolor{keywordflow}{return};
00484     \}
00485 
00486     \textcolor{comment}{// Display progress info on stderr}
00487     \textcolor{keywordflow}{if} (time\_now > time\_last\_progress\_update + 1.0f) \{
00488       time\_last\_progress\_update = time\_now;
00489       cerr << \textcolor{stringliteral}{"Measurements... "} << 100.0f * ratio\_done
00490            << \textcolor{stringliteral}{" %, ETA "}
00491            << \hyperlink{structhuman__duration__t}{human\_duration\_t}(\textcolor{keywordtype}{float}(time\_now - time\_start) * (1.0f - ratio\_done) / 
      ratio\_done)
00492            << \textcolor{stringliteral}{"                          \(\backslash\)r"} << flush;
00493     \}
00494 
00495     \textcolor{comment}{// This is where we actually run a benchmark!}
00496     benchmarks[benchmark\_index].run();
00497     benchmark\_index++;
00498   \}
00499 \}
00500 
00501 \textcolor{keywordtype}{void} run\_benchmarks(vector<benchmark\_t>& benchmarks)
00502 \{
00503   \textcolor{keywordtype}{size\_t} first\_benchmark\_to\_run;
00504   vector<benchmark\_t> deserialized\_benchmarks;
00505   \textcolor{keywordtype}{bool} use\_deserialized\_benchmarks = \textcolor{keyword}{false};
00506   \textcolor{keywordflow}{if} (deserialize\_benchmarks(session\_filename, deserialized\_benchmarks, first\_benchmark\_to\_run)) \{
00507     cerr << \textcolor{stringliteral}{"Found serialized session with "}
00508          << 100.0f * first\_benchmark\_to\_run / deserialized\_benchmarks.size()
00509          << \textcolor{stringliteral}{" % already done"} << endl;
00510     \textcolor{keywordflow}{if} (deserialized\_benchmarks.size() == benchmarks.size() &&
00511         first\_benchmark\_to\_run > 0 &&
00512         first\_benchmark\_to\_run < benchmarks.size())
00513     \{
00514       use\_deserialized\_benchmarks = \textcolor{keyword}{true};
00515     \}
00516   \}
00517 
00518   \textcolor{keywordflow}{if} (use\_deserialized\_benchmarks) \{
00519     benchmarks = deserialized\_benchmarks;
00520   \} \textcolor{keywordflow}{else} \{
00521     \textcolor{comment}{// not using deserialized benchmarks, starting from scratch}
00522     first\_benchmark\_to\_run = 0;
00523 
00524     \textcolor{comment}{// Randomly shuffling benchmarks allows us to get accurate enough progress info,}
00525     \textcolor{comment}{// as now the cheap/expensive benchmarks are randomly mixed so they average out.}
00526     \textcolor{comment}{// It also means that if data is corrupted for some time span, the odds are that}
00527     \textcolor{comment}{// not all repetitions of a given benchmark will be corrupted.}
00528     random\_shuffle(benchmarks.begin(), benchmarks.end());
00529   \}
00530 
00531   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; i++) \{
00532     max\_clock\_speed = max(max\_clock\_speed, measure\_clock\_speed());
00533   \}
00534   
00535   \textcolor{keywordtype}{double} time\_start = 0.0;
00536   \textcolor{keywordflow}{while} (first\_benchmark\_to\_run < benchmarks.size()) \{
00537     \textcolor{keywordflow}{if} (first\_benchmark\_to\_run == 0) \{
00538       time\_start = timer.getRealTime();
00539     \}
00540     try\_run\_some\_benchmarks(benchmarks,
00541                             time\_start,
00542                             first\_benchmark\_to\_run);
00543   \}
00544 
00545   \textcolor{comment}{// Sort timings by increasing benchmark parameters, and decreasing gflops.}
00546   \textcolor{comment}{// The latter is very important. It means that we can ignore all but the first}
00547   \textcolor{comment}{// benchmark with given parameters.}
00548   sort(benchmarks.begin(), benchmarks.end());
00549 
00550   \textcolor{comment}{// Collect best (i.e. now first) results for each parameter values.}
00551   vector<benchmark\_t> best\_benchmarks;
00552   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = benchmarks.begin(); it != benchmarks.end(); ++it) \{
00553     \textcolor{keywordflow}{if} (best\_benchmarks.empty() ||
00554         best\_benchmarks.back().compact\_product\_size != it->compact\_product\_size ||
00555         best\_benchmarks.back().compact\_block\_size != it->compact\_block\_size)
00556     \{
00557       best\_benchmarks.push\_back(*it);
00558     \}
00559   \}
00560 
00561   \textcolor{comment}{// keep and return only the best benchmarks}
00562   benchmarks = best\_benchmarks;
00563 \}
00564 
\Hypertarget{eigen_2bench_2benchmark-blocking-sizes_8cpp_source_l00565}\hyperlink{structmeasure__all__pot__sizes__action__t}{00565} \textcolor{keyword}{struct }\hyperlink{structmeasure__all__pot__sizes__action__t}{measure\_all\_pot\_sizes\_action\_t} : \hyperlink{structaction__t}{action\_t}
00566 \{
00567   \textcolor{keyword}{virtual} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* invokation\_name()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"all-pot-sizes"}; \}
00568   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} run()\textcolor{keyword}{ const}
00569 \textcolor{keyword}{  }\{
00570     vector<benchmark\_t> benchmarks;
00571     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} repetition = 0; repetition < measurement\_repetitions; repetition++) \{
00572       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} ksize = minsize; ksize <= maxsize; ksize *= 2) \{
00573         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} msize = minsize; msize <= maxsize; msize *= 2) \{
00574           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} nsize = minsize; nsize <= maxsize; nsize *= 2) \{
00575             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} kblock = minsize; kblock <= ksize; kblock *= 2) \{
00576               \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} mblock = minsize; mblock <= msize; mblock *= 2) \{
00577                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} nblock = minsize; nblock <= nsize; nblock *= 2) \{
00578                   benchmarks.emplace\_back(ksize, msize, nsize, kblock, mblock, nblock);
00579                 \}
00580               \}
00581             \}
00582           \}
00583         \}
00584       \}
00585     \}
00586 
00587     run\_benchmarks(benchmarks);
00588 
00589     cout << \textcolor{stringliteral}{"BEGIN MEASUREMENTS ALL POT SIZES"} << endl;
00590     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = benchmarks.begin(); it != benchmarks.end(); ++it) \{
00591       cout << *it << endl;
00592     \}
00593   \}
00594 \};
00595 
\Hypertarget{eigen_2bench_2benchmark-blocking-sizes_8cpp_source_l00596}\hyperlink{structmeasure__default__sizes__action__t}{00596} \textcolor{keyword}{struct }\hyperlink{structmeasure__default__sizes__action__t}{measure\_default\_sizes\_action\_t} : \hyperlink{structaction__t}{action\_t}
00597 \{
00598   \textcolor{keyword}{virtual} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* invokation\_name()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"default-sizes"}; \}
00599   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} run()\textcolor{keyword}{ const}
00600 \textcolor{keyword}{  }\{
00601     vector<benchmark\_t> benchmarks;
00602     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} repetition = 0; repetition < measurement\_repetitions; repetition++) \{
00603       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} ksize = minsize; ksize <= maxsize; ksize *= 2) \{
00604         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} msize = minsize; msize <= maxsize; msize *= 2) \{
00605           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} nsize = minsize; nsize <= maxsize; nsize *= 2) \{
00606             benchmarks.emplace\_back(ksize, msize, nsize);
00607           \}
00608         \}
00609       \}
00610     \}
00611 
00612     run\_benchmarks(benchmarks);
00613 
00614     cout << \textcolor{stringliteral}{"BEGIN MEASUREMENTS DEFAULT SIZES"} << endl;
00615     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = benchmarks.begin(); it != benchmarks.end(); ++it) \{
00616       cout << *it << endl;
00617     \}
00618   \}
00619 \};
00620 
00621 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
00622 \{
00623   \textcolor{keywordtype}{double} time\_start = timer.getRealTime();
00624   cout.precision(4);
00625   cerr.precision(4);
00626 
00627   vector<unique\_ptr<action\_t>> available\_actions;
00628   available\_actions.emplace\_back(\textcolor{keyword}{new} \hyperlink{structmeasure__all__pot__sizes__action__t}{measure\_all\_pot\_sizes\_action\_t});
00629   available\_actions.emplace\_back(\textcolor{keyword}{new} \hyperlink{structmeasure__default__sizes__action__t}{measure\_default\_sizes\_action\_t});
00630 
00631   \textcolor{keyword}{auto} action = available\_actions.end();
00632 
00633   \textcolor{keywordflow}{if} (argc <= 1) \{
00634     show\_usage\_and\_exit(argc, argv, available\_actions);
00635   \}
00636   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = available\_actions.begin(); it != available\_actions.end(); ++it) \{
00637     \textcolor{keywordflow}{if} (!strcmp(argv[1], (*it)->invokation\_name())) \{
00638       action = it;
00639       \textcolor{keywordflow}{break};
00640     \}
00641   \}
00642 
00643   \textcolor{keywordflow}{if} (action == available\_actions.end()) \{
00644     show\_usage\_and\_exit(argc, argv, available\_actions);
00645   \}
00646 
00647   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 2; i < argc; i++) \{
00648     \textcolor{keywordflow}{if} (argv[i] == strstr(argv[i], \textcolor{stringliteral}{"--min-working-set-size="})) \{
00649       \textcolor{keyword}{const} \textcolor{keywordtype}{char}* equals\_sign = strchr(argv[i], \textcolor{charliteral}{'='});
00650       min\_working\_set\_size = strtoul(equals\_sign+1, \textcolor{keyword}{nullptr}, 10);
00651     \} \textcolor{keywordflow}{else} \{
00652       cerr << \textcolor{stringliteral}{"unrecognized option: "} << argv[i] << endl << endl;
00653       show\_usage\_and\_exit(argc, argv, available\_actions);
00654     \}
00655   \}
00656 
00657   print\_cpuinfo();
00658 
00659   cout << \textcolor{stringliteral}{"benchmark parameters:"} << endl;
00660   cout << \textcolor{stringliteral}{"pointer size: "} << 8*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*) << \textcolor{stringliteral}{" bits"} << endl;
00661   cout << \textcolor{stringliteral}{"scalar type: "} << type\_name<Scalar>() << endl;
00662   cout << \textcolor{stringliteral}{"packet size: "} << internal::packet\_traits<MatrixType::Scalar>::size << endl;
00663   cout << \textcolor{stringliteral}{"minsize = "} << minsize << endl;
00664   cout << \textcolor{stringliteral}{"maxsize = "} << maxsize << endl;
00665   cout << \textcolor{stringliteral}{"measurement\_repetitions = "} << measurement\_repetitions << endl;
00666   cout << \textcolor{stringliteral}{"min\_accurate\_time = "} << min\_accurate\_time << endl;
00667   cout << \textcolor{stringliteral}{"min\_working\_set\_size = "} << min\_working\_set\_size;
00668   \textcolor{keywordflow}{if} (min\_working\_set\_size == 0) \{
00669     cout << \textcolor{stringliteral}{" (try to outsize caches)"};
00670   \}
00671   cout << endl << endl;
00672 
00673   (*action)->run();
00674 
00675   \textcolor{keywordtype}{double} time\_end = timer.getRealTime();
00676   cerr << \textcolor{stringliteral}{"Finished in "} << \hyperlink{structhuman__duration__t}{human\_duration\_t}(time\_end - time\_start) << endl;
00677 \}
\end{DoxyCode}
