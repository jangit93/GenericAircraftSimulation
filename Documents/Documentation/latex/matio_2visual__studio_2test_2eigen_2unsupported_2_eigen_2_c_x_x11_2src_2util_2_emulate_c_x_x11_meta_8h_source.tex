\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_emulate_c_x_x11_meta_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/util/\+Emulate\+C\+X\+X11\+Meta.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_emulate_c_x_x11_meta_8h_source}\index{Emulate\+C\+X\+X11\+Meta.\+h@{Emulate\+C\+X\+X11\+Meta.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_EMULATE\_CXX11\_META\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_EMULATE\_CXX11\_META\_H}
00012 
00013 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00016 
00017 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00018 
00025 \textcolor{keyword}{struct }empty\_list \{ \textcolor{keyword}{static} \textcolor{keyword}{const} std::size\_t count = 0; \};
00026 
00027 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Tail=empty\_list> \textcolor{keyword}{struct }type\_list \{
00028   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} HeadType;
00029   \textcolor{keyword}{typedef} Tail TailType;
00030   \textcolor{keyword}{static} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} head;
00031   \textcolor{keyword}{static} \textcolor{keyword}{const} Tail tail;
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} std::size\_t count = 1 + Tail::count;
00033 \};
00034 
00035 \textcolor{keyword}{struct }null\_type \{ \};
00036 
00037 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1 = null\_type, \textcolor{keyword}{typename} T2 = null\_type, \textcolor{keyword}{typename} T3 = null\_type,
00038          \textcolor{keyword}{typename} T4 = null\_type, \textcolor{keyword}{typename} T5 = null\_type, \textcolor{keyword}{typename} T6 = null\_type,
00039          \textcolor{keyword}{typename} T7 = null\_type, \textcolor{keyword}{typename} T8 = null\_type>
00040 \textcolor{keyword}{struct }make\_type\_list \{
00041   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} make\_type\_list<T2, T3, T4, T5, T6, T7, T8>::type tailresult;
00042 
00043   \textcolor{keyword}{typedef} type\_list<T1, tailresult> type;
00044 \};
00045 
00046 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }make\_type\_list<> \{
00047   \textcolor{keyword}{typedef} empty\_list type;
00048 \};
00049 
00050 
00051 \textcolor{keyword}{template} <std::\textcolor{keywordtype}{size\_t} index, \textcolor{keyword}{class} TList> \textcolor{keyword}{struct }get\_type;
00052 
00053 \textcolor{keyword}{template} <\textcolor{keyword}{class} Head, \textcolor{keyword}{class} Tail>
00054 \textcolor{keyword}{struct }get\_type<0, type\_list<Head, Tail> >
00055 \{
00056   \textcolor{keyword}{typedef} Head type;
00057 \};
00058 
00059 \textcolor{keyword}{template} <std::\textcolor{keywordtype}{size\_t} i, \textcolor{keyword}{class} Head, \textcolor{keyword}{class} Tail>
00060 \textcolor{keyword}{struct }get\_type<i, type\_list<Head, Tail> >
00061 \{
00062   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} get\_type<i-1, Tail>::type type;
00063 \};
00064 
00065 
00066 \textcolor{comment}{/* numeric list */}
00067 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, T n>
00068 \textcolor{keyword}{struct }type2val \{
00069   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type;
00070   \textcolor{keyword}{static} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} value = n;
00071 \};
00072 
00073 
00074 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} n, T V> \textcolor{keyword}{struct }gen\_numeric\_list\_repeated;
00075 
00076 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, T V> \textcolor{keyword}{struct }gen\_numeric\_list\_repeated<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, 1, V> \{
00077   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} make\_type\_list<type2val<T, V> >::type type;
00078 \};
00079 
00080 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, T V> \textcolor{keyword}{struct }gen\_numeric\_list\_repeated<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, 2, V> \{
00081   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} make\_type\_list<type2val<T, V>, type2val<T, V> >::type type;
00082 \};
00083 
00084 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, T V> \textcolor{keyword}{struct }gen\_numeric\_list\_repeated<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, 3, V> \{
00085   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} make\_type\_list<type2val<T, V>, type2val<T, V>, type2val<T, V> >::type type;
00086 \};
00087 
00088 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, T V> \textcolor{keyword}{struct }gen\_numeric\_list\_repeated<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, 4, V> \{
00089   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} make\_type\_list<type2val<T, V>, type2val<T, V>, type2val<T, V>, type2val<T, V> >::type 
      type;
00090 \};
00091 
00092 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, T V> \textcolor{keyword}{struct }gen\_numeric\_list\_repeated<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, 5, V> \{
00093   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} make\_type\_list<type2val<T, V>, type2val<T, V>, type2val<T, V>, type2val<T, V>, 
      type2val<T, V> >::type type;
00094 \};
00095 
00096 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, T V> \textcolor{keyword}{struct }gen\_numeric\_list\_repeated<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, 6, V> \{
00097   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} make\_type\_list<type2val<T, V>, type2val<T, V>, type2val<T, V>,
00098                                   type2val<T, V>, type2val<T, V>, type2val<T, V> >::type type;
00099 \};
00100 
00101 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, T V> \textcolor{keyword}{struct }gen\_numeric\_list\_repeated<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, 7, V> \{
00102   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} make\_type\_list<type2val<T, V>, type2val<T, V>, type2val<T, V>,
00103                                   type2val<T, V>, type2val<T, V>, type2val<T, V>,
00104                                   type2val<T, V> >::type type;
00105 \};
00106 
00107 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, T V> \textcolor{keyword}{struct }gen\_numeric\_list\_repeated<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, 8, V> \{
00108   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} make\_type\_list<type2val<T, V>, type2val<T, V>, type2val<T, V>,
00109                                   type2val<T, V>, type2val<T, V>, type2val<T, V>,
00110                                   type2val<T, V>, type2val<T, V> >::type type;
00111 \};
00112 
00113 
00114 \textcolor{keyword}{template} <std::\textcolor{keywordtype}{size\_t} index, \textcolor{keyword}{class} NList> \textcolor{keyword}{struct }get;
00115 
00116 \textcolor{keyword}{template} <std::\textcolor{keywordtype}{size\_t} i>
00117 \textcolor{keyword}{struct }get<i, empty\_list>
00118 \{
00119   \textcolor{keyword}{get}() \{ eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"index overflow"}); \}
00120   \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} type;
00121   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} value = \textcolor{charliteral}{'\(\backslash\)0'};
00122 \};
00123 
00124 \textcolor{keyword}{template} <std::\textcolor{keywordtype}{size\_t} i, \textcolor{keyword}{class} Head>
00125 \textcolor{keyword}{struct }get<i, type\_list<Head, empty\_list> >
00126 \{
00127   \textcolor{keyword}{get}() \{ eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"index overflow"}); \}
00128   \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} type;
00129   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} value = \textcolor{charliteral}{'\(\backslash\)0'};
00130 \};
00131 
00132 \textcolor{keyword}{template} <\textcolor{keyword}{class} Head>
00133 \textcolor{keyword}{struct }get<0, type\_list<Head, empty\_list> >
00134 \{
00135   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Head::type type;
00136   \textcolor{keyword}{static} \textcolor{keyword}{const} type value = Head::value;
00137 \};
00138 
00139 \textcolor{keyword}{template} <\textcolor{keyword}{class} Head, \textcolor{keyword}{class} Tail>
00140 \textcolor{keyword}{struct }get<0, type\_list<Head, Tail> >
00141 \{
00142   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Head::type type;
00143   \textcolor{keyword}{static} \textcolor{keyword}{const} type value = Head::value;
00144 \};
00145 
00146 \textcolor{keyword}{template} <std::\textcolor{keywordtype}{size\_t} i, \textcolor{keyword}{class} Head, \textcolor{keyword}{class} Tail>
00147 \textcolor{keyword}{struct }get<i, type\_list<Head, Tail> >
00148 \{
00149   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Tail::HeadType::type type;
00150   \textcolor{keyword}{static} \textcolor{keyword}{const} type value = \textcolor{keyword}{get}<i-1, Tail>::value;
00151 \};
00152 
00153 
00154 \textcolor{keyword}{template} <\textcolor{keyword}{class} NList> \textcolor{keyword}{struct }arg\_prod \{
00155   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{typename} NList::HeadType::type value = get<0, NList>::value * arg\_prod<typename
       NList::TailType>::value;
00156 \};
00157 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }arg\_prod<empty\_list> \{
00158   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} value = 1;
00159 \};
00160 
00161 
00162 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} n, \textcolor{keyword}{typename} t>
00163 array<t, n> repeat(t v) \{
00164   array<t, n> array;
00165   array.fill(v);
00166   \textcolor{keywordflow}{return} array;
00167 \}
00168 
00169 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} I, \textcolor{keyword}{class} Head, \textcolor{keyword}{class} Tail>
00170 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} Head::type array\_get(type\_list<Head, Tail>&) \{
00171   \textcolor{keywordflow}{return} get<I, type\_list<Head, Tail> >::value;
00172 \}
00173 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} I, \textcolor{keyword}{class} Head, \textcolor{keyword}{class} Tail>
00174 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} Head::type array\_get(\textcolor{keyword}{const} type\_list<Head, Tail>&) \{
00175   \textcolor{keywordflow}{return} get<I, type\_list<Head, Tail> >::value;
00176 \}
00177 
00178 \textcolor{keyword}{template} <\textcolor{keyword}{class} NList>
00179 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} NList::HeadType::type array\_prod(\textcolor{keyword}{const} NList&) \{
00180   \textcolor{keywordflow}{return} arg\_prod<NList>::value;
00181 \}
00182 
00183 \textcolor{keyword}{template}<\textcolor{keyword}{typename} t, std::\textcolor{keywordtype}{size\_t} n>
00184 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE t array\_prod(\textcolor{keyword}{const} array<t, n>& a) \{
00185   t prod = 1;
00186   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < n; ++i) \{ prod *= a[i]; \}
00187   \textcolor{keywordflow}{return} prod;
00188 \}
00189 \textcolor{keyword}{template}<\textcolor{keyword}{typename} t>
00190 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE t array\_prod(\textcolor{keyword}{const} array<t, 0>& \textcolor{comment}{/*a*/}) \{
00191   \textcolor{keywordflow}{return} 0;
00192 \}
00193 
00194 \textcolor{keyword}{template}<\textcolor{keyword}{typename} t>
00195 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE t array\_prod(\textcolor{keyword}{const} std::vector<t>& a) \{
00196   eigen\_assert(a.size() > 0);
00197   t prod = 1;
00198   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < a.size(); ++i) \{ prod *= a[i]; \}
00199   \textcolor{keywordflow}{return} prod;
00200 \}
00201 
00202 
00203 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} I, \textcolor{keyword}{class} T>
00204 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& array\_get(std::vector<T>& a) \{
00205   \textcolor{keywordflow}{return} a[I];
00206 \}
00207 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} I, \textcolor{keyword}{class} T>
00208 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& array\_get(\textcolor{keyword}{const} std::vector<T>& a) \{
00209   \textcolor{keywordflow}{return} a[I];
00210 \}
00211 
00212 \textcolor{keyword}{struct }sum\_op \{
00213   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a, B b) \{ \textcolor{keywordflow}{return} a + b; \}
00214 \};
00215 \textcolor{keyword}{struct }product\_op \{
00216   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a, B b) \{ \textcolor{keywordflow}{return} a * b; \}
00217 \};
00218 
00219 \textcolor{keyword}{struct }logical\_and\_op \{
00220   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a, B b) \{ \textcolor{keywordflow}{return} a && b; \}
00221 \};
00222 \textcolor{keyword}{struct }logical\_or\_op \{
00223   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a, B b) \{ \textcolor{keywordflow}{return} a || b; \}
00224 \};
00225 
00226 \textcolor{keyword}{struct }equal\_op \{
00227   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a, B b) \{ \textcolor{keywordflow}{return} a == b; \}
00228 \};
00229 \textcolor{keyword}{struct }not\_equal\_op \{
00230   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a, B b) \{ \textcolor{keywordflow}{return} a != b; \}
00231 \};
00232 \textcolor{keyword}{struct }lesser\_op \{
00233   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a, B b) \{ \textcolor{keywordflow}{return} a < b; \}
00234 \};
00235 \textcolor{keyword}{struct }lesser\_equal\_op \{
00236   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a, B b) \{ \textcolor{keywordflow}{return} a <= b; \}
00237 \};
00238 
00239 \textcolor{keyword}{struct }greater\_op \{
00240   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a, B b) \{ \textcolor{keywordflow}{return} a > b; \}
00241 \};
00242 \textcolor{keyword}{struct }greater\_equal\_op \{
00243   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a, B b) \{ \textcolor{keywordflow}{return} a >= b; \}
00244 \};
00245 
00246 \textcolor{keyword}{struct }not\_op \{
00247   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a) \{ \textcolor{keywordflow}{return} !a; \}
00248 \};
00249 \textcolor{keyword}{struct }negation\_op \{
00250   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a) \{ \textcolor{keywordflow}{return} -a; \}
00251 \};
00252 \textcolor{keyword}{struct }greater\_equal\_zero\_op \{
00253   \textcolor{keyword}{template}<\textcolor{keyword}{typename} A> \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(A a) \{ \textcolor{keywordflow}{return} a >= 0; \}
00254 \};
00255 
00256 
00257 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, std::\textcolor{keywordtype}{size\_t} N>
00258 \textcolor{keyword}{struct }ArrayApplyAndReduce \{
00259   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(\textcolor{keyword}{const} array<A, N>& a) \{
00260     EIGEN\_STATIC\_ASSERT(N >= 2, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00261     \textcolor{keywordtype}{bool} result = Reducer::run(Op::run(a[0]), Op::run(a[1]));
00262     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 2; i < N; ++i) \{
00263       result = Reducer::run(result, Op::run(a[i]));
00264     \}
00265     \textcolor{keywordflow}{return} result;
00266   \}
00267 \};
00268 
00269 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A>
00270 \textcolor{keyword}{struct }ArrayApplyAndReduce<Reducer, Op, A, 1>  \{
00271   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(\textcolor{keyword}{const} array<A, 1>& a) \{
00272     \textcolor{keywordflow}{return} Op::run(a[0]);
00273   \}
00274 \};
00275 
00276 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, std::\textcolor{keywordtype}{size\_t} N>
00277 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} array\_apply\_and\_reduce(\textcolor{keyword}{const} array<A, N>& a) \{
00278   \textcolor{keywordflow}{return} ArrayApplyAndReduce<Reducer, Op, A, N>::run(a);
00279 \}
00280 
00281 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B, std::\textcolor{keywordtype}{size\_t} N>
00282 \textcolor{keyword}{struct }ArrayZipAndReduce \{
00283   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(\textcolor{keyword}{const} array<A, N>& a, \textcolor{keyword}{const} array<B, N>& b) \{
00284     EIGEN\_STATIC\_ASSERT(N >= 2, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00285     \textcolor{keywordtype}{bool} result = Reducer::run(Op::run(a[0], b[0]), Op::run(a[1], b[1]));
00286     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 2; i < N; ++i) \{
00287       result = Reducer::run(result, Op::run(a[i], b[i]));
00288     \}
00289     \textcolor{keywordflow}{return} result;
00290   \}
00291 \};
00292 
00293 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>
00294 \textcolor{keyword}{struct }ArrayZipAndReduce<Reducer, Op, A, B, 1> \{
00295   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} run(\textcolor{keyword}{const} array<A, 1>& a, \textcolor{keyword}{const} array<B, 1>& b) \{
00296     \textcolor{keywordflow}{return} Op::run(a[0], b[0]);
00297   \}
00298 \};
00299 
00300 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B, std::\textcolor{keywordtype}{size\_t} N>
00301 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} array\_zip\_and\_reduce(\textcolor{keyword}{const} array<A, N>& a, \textcolor{keyword}{const} array<B, N>& b) \{
00302   \textcolor{keywordflow}{return} ArrayZipAndReduce<Reducer, Op, A, B, N>::run(a, b);
00303 \}
00304 
00305 \}  \textcolor{comment}{// end namespace internal}
00306 
00307 \}  \textcolor{comment}{// end namespace Eigen}
00308 
00309 
00310 
00311 \textcolor{preprocessor}{#endif  // EIGEN\_EMULATE\_CXX11\_META\_H}
\end{DoxyCode}
