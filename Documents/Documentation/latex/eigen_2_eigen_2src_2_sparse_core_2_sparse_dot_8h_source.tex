\hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_dot_8h_source}{}\section{eigen/\+Eigen/src/\+Sparse\+Core/\+Sparse\+Dot.h}
\label{eigen_2_eigen_2src_2_sparse_core_2_sparse_dot_8h_source}\index{Sparse\+Dot.\+h@{Sparse\+Dot.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSE\_DOT\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SPARSE\_DOT\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00016 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00017 \textcolor{keyword}{typename} internal::traits<Derived>::Scalar
00018 SparseMatrixBase<Derived>::dot(\textcolor{keyword}{const} MatrixBase<OtherDerived>& other)\textcolor{keyword}{ const}
00019 \textcolor{keyword}{}\{
00020   EIGEN\_STATIC\_ASSERT\_VECTOR\_ONLY(Derived)
00021   EIGEN\_STATIC\_ASSERT\_VECTOR\_ONLY(OtherDerived)
00022   EIGEN\_STATIC\_ASSERT\_SAME\_VECTOR\_SIZE(Derived,OtherDerived)
00023   EIGEN\_STATIC\_ASSERT((internal::is\_same<Scalar, typename OtherDerived::Scalar>::value),
00024     
      YOU\_MIXED\_DIFFERENT\_NUMERIC\_TYPES\_\_YOU\_NEED\_TO\_USE\_THE\_CAST\_METHOD\_OF\_MATRIXBASE\_TO\_CAST\_NUMERIC\_TYPES\_EXPLICITLY)
00025 
00026   eigen\_assert(size() == other.size());
00027   eigen\_assert(other.size()>0 && \textcolor{stringliteral}{"you are using a non initialized vector"});
00028 
00029   internal::evaluator<Derived> thisEval(derived());
00030   \textcolor{keyword}{typename} internal::evaluator<Derived>::InnerIterator i(thisEval, 0);
00031   Scalar res(0);
00032   \textcolor{keywordflow}{while} (i)
00033   \{
00034     res += numext::conj(i.value()) * other.coeff(i.index());
00035     ++i;
00036   \}
00037   \textcolor{keywordflow}{return} res;
00038 \}
00039 
00040 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00041 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00042 \textcolor{keyword}{typename} internal::traits<Derived>::Scalar
00043 SparseMatrixBase<Derived>::dot(\textcolor{keyword}{const} SparseMatrixBase<OtherDerived>& other)\textcolor{keyword}{ const}
00044 \textcolor{keyword}{}\{
00045   EIGEN\_STATIC\_ASSERT\_VECTOR\_ONLY(Derived)
00046   EIGEN\_STATIC\_ASSERT\_VECTOR\_ONLY(OtherDerived)
00047   EIGEN\_STATIC\_ASSERT\_SAME\_VECTOR\_SIZE(Derived,OtherDerived)
00048   EIGEN\_STATIC\_ASSERT((internal::is\_same<Scalar, typename OtherDerived::Scalar>::value),
00049     
      YOU\_MIXED\_DIFFERENT\_NUMERIC\_TYPES\_\_YOU\_NEED\_TO\_USE\_THE\_CAST\_METHOD\_OF\_MATRIXBASE\_TO\_CAST\_NUMERIC\_TYPES\_EXPLICITLY)
00050 
00051   eigen\_assert(size() == other.size());
00052 
00053   internal::evaluator<Derived> thisEval(derived());
00054   \textcolor{keyword}{typename} internal::evaluator<Derived>::InnerIterator i(thisEval, 0);
00055   
00056   internal::evaluator<OtherDerived>  otherEval(other.derived());
00057   \textcolor{keyword}{typename} internal::evaluator<OtherDerived>::InnerIterator j(otherEval, 0);
00058 
00059   Scalar res(0);
00060   \textcolor{keywordflow}{while} (i && j)
00061   \{
00062     \textcolor{keywordflow}{if} (i.index()==j.index())
00063     \{
00064       res += numext::conj(i.value()) * j.value();
00065       ++i; ++j;
00066     \}
00067     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (i.index()<j.index())
00068       ++i;
00069     \textcolor{keywordflow}{else}
00070       ++j;
00071   \}
00072   \textcolor{keywordflow}{return} res;
00073 \}
00074 
00075 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00076 \textcolor{keyword}{inline} \textcolor{keyword}{typename} NumTraits<typename internal::traits<Derived>::Scalar>::Real
00077 SparseMatrixBase<Derived>::squaredNorm()\textcolor{keyword}{ const}
00078 \textcolor{keyword}{}\{
00079   \textcolor{keywordflow}{return} numext::real((*this).cwiseAbs2().sum());
00080 \}
00081 
00082 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00083 \textcolor{keyword}{inline} \textcolor{keyword}{typename} NumTraits<typename internal::traits<Derived>::Scalar>::Real
00084 SparseMatrixBase<Derived>::norm()\textcolor{keyword}{ const}
00085 \textcolor{keyword}{}\{
00086   \textcolor{keyword}{using} std::sqrt;
00087   \textcolor{keywordflow}{return} sqrt(squaredNorm());
00088 \}
00089 
00090 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00091 \textcolor{keyword}{inline} \textcolor{keyword}{typename} NumTraits<typename internal::traits<Derived>::Scalar>::Real
00092 SparseMatrixBase<Derived>::blueNorm()\textcolor{keyword}{ const}
00093 \textcolor{keyword}{}\{
00094   \textcolor{keywordflow}{return} internal::blueNorm\_impl(*\textcolor{keyword}{this});
00095 \}
00096 \} \textcolor{comment}{// end namespace Eigen}
00097 
00098 \textcolor{preprocessor}{#endif // EIGEN\_SPARSE\_DOT\_H}
\end{DoxyCode}
