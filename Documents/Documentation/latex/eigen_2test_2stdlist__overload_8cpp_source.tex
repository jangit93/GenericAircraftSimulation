\hypertarget{eigen_2test_2stdlist__overload_8cpp_source}{}\section{eigen/test/stdlist\+\_\+overload.cpp}
\label{eigen_2test_2stdlist__overload_8cpp_source}\index{stdlist\+\_\+overload.\+cpp@{stdlist\+\_\+overload.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2010 Hauke Heibel <hauke.heibel@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#include "main.h"}
00012 
00013 \textcolor{preprocessor}{#include <Eigen/StdList>}
00014 \textcolor{preprocessor}{#include <Eigen/Geometry>}
00015 
00016 EIGEN\_DEFINE\_STL\_LIST\_SPECIALIZATION(Vector4f)
00017 
00018 EIGEN\_DEFINE\_STL\_LIST\_SPECIALIZATION(Matrix2f)
00019 EIGEN\_DEFINE\_STL\_LIST\_SPECIALIZATION(Matrix4f)
00020 EIGEN\_DEFINE\_STL\_LIST\_SPECIALIZATION(Matrix4d)
00021 
00022 EIGEN\_DEFINE\_STL\_LIST\_SPECIALIZATION(\hyperlink{group___geometry___module_class_eigen_1_1_transform}{Affine3f})
00023 EIGEN\_DEFINE\_STL\_LIST\_SPECIALIZATION(\hyperlink{group___geometry___module_class_eigen_1_1_transform}{Affine3d})
00024 
00025 EIGEN\_DEFINE\_STL\_LIST\_SPECIALIZATION(\hyperlink{group___geometry___module_class_eigen_1_1_quaternion}{Quaternionf})
00026 EIGEN\_DEFINE\_STL\_LIST\_SPECIALIZATION(\hyperlink{group___geometry___module_class_eigen_1_1_quaternion}{Quaterniond})
00027 
00028 \textcolor{keyword}{template} <\textcolor{keyword}{class} Container, \textcolor{keyword}{class} Position>
00029 \textcolor{keyword}{typename} Container::iterator \textcolor{keyword}{get}(Container & c, Position position)
00030 \{
00031   \textcolor{keyword}{typename} Container::iterator it = c.begin();
00032   std::advance(it, position);
00033   \textcolor{keywordflow}{return} it;
00034 \}
00035 
00036 \textcolor{keyword}{template} <\textcolor{keyword}{class} Container, \textcolor{keyword}{class} Position, \textcolor{keyword}{class} Value>
00037 \textcolor{keywordtype}{void} \textcolor{keyword}{set}(Container & c, Position position, \textcolor{keyword}{const} Value & value)
00038 \{
00039   \textcolor{keyword}{typename} Container::iterator it = c.begin();
00040   std::advance(it, position);
00041   *it = value;
00042 \}
00043 
00044 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00045 \textcolor{keywordtype}{void} check\_stdlist\_matrix(\textcolor{keyword}{const} MatrixType& m)
00046 \{
00047   \textcolor{keyword}{typename} MatrixType::Index rows = m.rows();
00048   \textcolor{keyword}{typename} MatrixType::Index cols = m.cols();
00049   MatrixType x = MatrixType::Random(rows,cols), y = MatrixType::Random(rows,cols);
00050   std::list<MatrixType> v(10, MatrixType(rows,cols)), w(20, y);
00051   \textcolor{keyword}{typename} std::list<MatrixType>::iterator itv = \textcolor{keyword}{get}(v, 5);
00052   \textcolor{keyword}{typename} std::list<MatrixType>::iterator itw = \textcolor{keyword}{get}(w, 6);
00053   *itv = x;
00054   *itw = *itv;
00055   VERIFY\_IS\_APPROX(*itw, *itv);
00056   v = w;
00057   itv = v.begin();
00058   itw = w.begin();
00059   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00060   \{
00061     VERIFY\_IS\_APPROX(*itw, *itv);
00062     ++itv;
00063     ++itw;
00064   \}
00065 
00066   v.resize(21);
00067   \textcolor{keyword}{set}(v, 20, x);
00068   VERIFY\_IS\_APPROX(*\textcolor{keyword}{get}(v, 20), x);
00069   v.resize(22,y);
00070   VERIFY\_IS\_APPROX(*\textcolor{keyword}{get}(v, 21), y);
00071   v.push\_back(x);
00072   VERIFY\_IS\_APPROX(*\textcolor{keyword}{get}(v, 22), x);
00073 
00074   \textcolor{comment}{// do a lot of push\_back such that the list gets internally resized}
00075   \textcolor{comment}{// (with memory reallocation)}
00076   MatrixType* ref = &(*\textcolor{keyword}{get}(w, 0));
00077   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<30 || ((ref==&(*\textcolor{keyword}{get}(w, 0))) && i<300); ++i)
00078     v.push\_back(*\textcolor{keyword}{get}(w, i%w.size()));
00079   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=23; i<v.size(); ++i)
00080   \{
00081     VERIFY((*\textcolor{keyword}{get}(v, i))==(*\textcolor{keyword}{get}(w, (i-23)%w.size())));
00082   \}
00083 \}
00084 
00085 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TransformType>
00086 \textcolor{keywordtype}{void} check\_stdlist\_transform(\textcolor{keyword}{const} TransformType&)
00087 \{
00088   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} TransformType::MatrixType MatrixType;
00089   TransformType x(MatrixType::Random()), y(MatrixType::Random());
00090   std::list<TransformType> v(10), w(20, y);
00091   \textcolor{keyword}{typename} std::list<TransformType>::iterator itv = \textcolor{keyword}{get}(v, 5);
00092   \textcolor{keyword}{typename} std::list<TransformType>::iterator itw = \textcolor{keyword}{get}(w, 6);
00093   *itv = x;
00094   *itw = *itv;
00095   VERIFY\_IS\_APPROX(*itw, *itv);
00096   v = w;
00097   itv = v.begin();
00098   itw = w.begin();
00099   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00100   \{
00101     VERIFY\_IS\_APPROX(*itw, *itv);
00102     ++itv;
00103     ++itw;
00104   \}
00105 
00106   v.resize(21);
00107   \textcolor{keyword}{set}(v, 20, x);
00108   VERIFY\_IS\_APPROX(*\textcolor{keyword}{get}(v, 20), x);
00109   v.resize(22,y);
00110   VERIFY\_IS\_APPROX(*\textcolor{keyword}{get}(v, 21), y);
00111   v.push\_back(x);
00112   VERIFY\_IS\_APPROX(*\textcolor{keyword}{get}(v, 22), x);
00113 
00114   \textcolor{comment}{// do a lot of push\_back such that the list gets internally resized}
00115   \textcolor{comment}{// (with memory reallocation)}
00116   TransformType* ref = &(*\textcolor{keyword}{get}(w, 0));
00117   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<30 || ((ref==&(*\textcolor{keyword}{get}(w, 0))) && i<300); ++i)
00118     v.push\_back(*\textcolor{keyword}{get}(w, i%w.size()));
00119   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=23; i<v.size(); ++i)
00120   \{
00121     VERIFY(\textcolor{keyword}{get}(v, i)->matrix()==\textcolor{keyword}{get}(w, (i-23)%w.size())->matrix());
00122   \}
00123 \}
00124 
00125 \textcolor{keyword}{template}<\textcolor{keyword}{typename} QuaternionType>
00126 \textcolor{keywordtype}{void} check\_stdlist\_quaternion(\textcolor{keyword}{const} QuaternionType&)
00127 \{
00128   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} QuaternionType::Coefficients Coefficients;
00129   QuaternionType x(Coefficients::Random()), y(Coefficients::Random());
00130   std::list<QuaternionType> v(10), w(20, y);
00131   \textcolor{keyword}{typename} std::list<QuaternionType>::iterator itv = \textcolor{keyword}{get}(v, 5);
00132   \textcolor{keyword}{typename} std::list<QuaternionType>::iterator itw = \textcolor{keyword}{get}(w, 6);
00133   *itv = x;
00134   *itw = *itv;
00135   VERIFY\_IS\_APPROX(*itw, *itv);
00136   v = w;
00137   itv = v.begin();
00138   itw = w.begin();
00139   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00140   \{
00141     VERIFY\_IS\_APPROX(*itw, *itv);
00142     ++itv;
00143     ++itw;
00144   \}
00145 
00146   v.resize(21);
00147   \textcolor{keyword}{set}(v, 20, x);
00148   VERIFY\_IS\_APPROX(*\textcolor{keyword}{get}(v, 20), x);
00149   v.resize(22,y);
00150   VERIFY\_IS\_APPROX(*\textcolor{keyword}{get}(v, 21), y);
00151   v.push\_back(x);
00152   VERIFY\_IS\_APPROX(*\textcolor{keyword}{get}(v, 22), x);
00153 
00154   \textcolor{comment}{// do a lot of push\_back such that the list gets internally resized}
00155   \textcolor{comment}{// (with memory reallocation)}
00156   QuaternionType* ref = &(*\textcolor{keyword}{get}(w, 0));
00157   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<30 || ((ref==&(*\textcolor{keyword}{get}(w, 0))) && i<300); ++i)
00158     v.push\_back(*\textcolor{keyword}{get}(w, i%w.size()));
00159   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=23; i<v.size(); ++i)
00160   \{
00161     VERIFY(\textcolor{keyword}{get}(v, i)->coeffs()==\textcolor{keyword}{get}(w, (i-23)%w.size())->coeffs());
00162   \}
00163 \}
00164 
00165 \textcolor{keywordtype}{void} test\_stdlist\_overload()
00166 \{
00167   \textcolor{comment}{// some non vectorizable fixed sizes}
00168   CALL\_SUBTEST\_1(check\_stdlist\_matrix(Vector2f()));
00169   CALL\_SUBTEST\_1(check\_stdlist\_matrix(Matrix3f()));
00170   CALL\_SUBTEST\_2(check\_stdlist\_matrix(Matrix3d()));
00171 
00172   \textcolor{comment}{// some vectorizable fixed sizes}
00173   CALL\_SUBTEST\_1(check\_stdlist\_matrix(Matrix2f()));
00174   CALL\_SUBTEST\_1(check\_stdlist\_matrix(Vector4f()));
00175   CALL\_SUBTEST\_1(check\_stdlist\_matrix(Matrix4f()));
00176   CALL\_SUBTEST\_2(check\_stdlist\_matrix(Matrix4d()));
00177 
00178   \textcolor{comment}{// some dynamic sizes}
00179   CALL\_SUBTEST\_3(check\_stdlist\_matrix(MatrixXd(1,1)));
00180   CALL\_SUBTEST\_3(check\_stdlist\_matrix(VectorXd(20)));
00181   CALL\_SUBTEST\_3(check\_stdlist\_matrix(RowVectorXf(20)));
00182   CALL\_SUBTEST\_3(check\_stdlist\_matrix(MatrixXcf(10,10)));
00183 
00184   \textcolor{comment}{// some Transform}
00185   CALL\_SUBTEST\_4(check\_stdlist\_transform(\hyperlink{group___geometry___module_ga2c1ea05a21899654ee3a2e3f91fa30e0}{Affine2f}())); \textcolor{comment}{// does not need the specialization (2+1)^2
       = 9}
00186   CALL\_SUBTEST\_4(check\_stdlist\_transform(\hyperlink{group___geometry___module_ga17e901de8ff882aea7845c5457db6a4f}{Affine3f}()));
00187   CALL\_SUBTEST\_4(check\_stdlist\_transform(\hyperlink{group___geometry___module_gaaffa69d3143826efeb84e5d6c56a4c78}{Affine3d}()));
00188 
00189   \textcolor{comment}{// some Quaternion}
00190   CALL\_SUBTEST\_5(check\_stdlist\_quaternion(\hyperlink{group___geometry___module_ga785b13a5a87f9bf55d4eba51ead2dcf0}{Quaternionf}()));
00191   CALL\_SUBTEST\_5(check\_stdlist\_quaternion(\hyperlink{group___geometry___module_ga6e77eb8b6aae0e04be2db88107dbc642}{Quaterniond}()));
00192 \}
\end{DoxyCode}
