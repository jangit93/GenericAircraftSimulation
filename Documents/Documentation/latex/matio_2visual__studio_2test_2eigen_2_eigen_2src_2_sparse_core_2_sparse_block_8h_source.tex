\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_block_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+Core/\+Sparse\+Block.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_block_8h_source}\index{Sparse\+Block.\+h@{Sparse\+Block.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSE\_BLOCK\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SPARSE\_BLOCK\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{comment}{// Subset of columns or rows}
00016 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols>
00017 \textcolor{keyword}{class }BlockImpl<XprType,BlockRows,BlockCols,true,Sparse>
00018   : \textcolor{keyword}{public} SparseMatrixBase<Block<XprType,BlockRows,BlockCols,true> >
00019 \{
00020     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type \_MatrixTypeNested;
00021     \textcolor{keyword}{typedef} Block<XprType, BlockRows, BlockCols, true> BlockType;
00022 \textcolor{keyword}{public}:
00023     \textcolor{keyword}{enum} \{ IsRowMajor = internal::traits<BlockType>::IsRowMajor \};
00024 \textcolor{keyword}{protected}:
00025     \textcolor{keyword}{enum} \{ OuterSize = IsRowMajor ? BlockRows : BlockCols \};
00026     \textcolor{keyword}{typedef} SparseMatrixBase<BlockType> Base;
00027     \textcolor{keyword}{using} Base::convert\_index;
00028 \textcolor{keyword}{public}:
00029     EIGEN\_SPARSE\_PUBLIC\_INTERFACE(BlockType)
00030 
00031     \textcolor{keyword}{inline} BlockImpl(XprType& xpr, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i)
00032       : m\_matrix(xpr), m\_outerStart(convert\_index(i)), m\_outerSize(OuterSize)
00033     \{\}
00034 
00035     \textcolor{keyword}{inline} BlockImpl(XprType& xpr, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startRow, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startCol, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockRows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockCols)
00036       : m\_matrix(xpr), m\_outerStart(convert\_index(IsRowMajor ? startRow : startCol)), m\_outerSize(
      convert\_index(IsRowMajor ? blockRows : blockCols))
00037     \{\}
00038 
00039     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_outerSize.value() : m\_matrix.rows()
      ; \}
00040     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_matrix.cols() : m\_outerSize.value()
      ; \}
00041 
00042     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nonZeros()\textcolor{keyword}{ const}
00043 \textcolor{keyword}{    }\{
00044       \textcolor{keyword}{typedef} internal::evaluator<XprType> EvaluatorType;
00045       EvaluatorType matEval(m\_matrix);
00046       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nnz = 0;
00047       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} end = m\_outerStart + m\_outerSize.value();
00048       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=m\_outerStart; j<end; ++j)
00049         \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} EvaluatorType::InnerIterator it(matEval, j); it; ++it)
00050           ++nnz;
00051       \textcolor{keywordflow}{return} nnz;
00052     \}
00053 
00054     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00055 \textcolor{keyword}{    }\{
00056       \textcolor{keywordflow}{return} m\_matrix.coeff(row + (IsRowMajor ? m\_outerStart : 0), col + (IsRowMajor ? 0 :  m\_outerStart));
00057     \}
00058 
00059     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00060 \textcolor{keyword}{    }\{
00061       \textcolor{keywordflow}{return} m\_matrix.coeff(IsRowMajor ? m\_outerStart : index, IsRowMajor ? index :  m\_outerStart);
00062     \}
00063 
00064     \textcolor{keyword}{inline} \textcolor{keyword}{const} XprType& nestedExpression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix; \}
00065     \textcolor{keyword}{inline} XprType& nestedExpression() \{ \textcolor{keywordflow}{return} m\_matrix; \}
00066     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startRow()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_outerStart : 0; \}
00067     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startCol()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? 0 : m\_outerStart; \}
00068     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockRows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_outerSize.value() : m\_matrix.rows(); \}
00069     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockCols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_matrix.cols() : m\_outerSize.value(); \}
00070 
00071   \textcolor{keyword}{protected}:
00072 
00073     \textcolor{keyword}{typename} internal::ref\_selector<XprType>::non\_const\_type m\_matrix;
00074     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_outerStart;
00075     \textcolor{keyword}{const} internal::variable\_if\_dynamic<Index, OuterSize> m\_outerSize;
00076 
00077   \textcolor{keyword}{protected}:
00078     \textcolor{comment}{// Disable assignment with clear error message.}
00079     \textcolor{comment}{// Note that simply removing operator= yields compilation errors with ICC+MSVC}
00080     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00081     BlockImpl& operator=(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&)
00082     \{
00083       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})==0, THIS\_SPARSE\_BLOCK\_SUBEXPRESSION\_IS\_READ\_ONLY);
00084       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00085     \}
00086 \};
00087 
00088 
00089 \textcolor{comment}{/***************************************************************************}
00090 \textcolor{comment}{* specialization for SparseMatrix}
00091 \textcolor{comment}{***************************************************************************/}
00092 
00093 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00094 
00095 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseMatrixType, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols>
00096 \textcolor{keyword}{class }sparse\_matrix\_block\_impl
00097   : \textcolor{keyword}{public} SparseCompressedBase<Block<SparseMatrixType,BlockRows,BlockCols,true> >
00098 \{
00099     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<typename SparseMatrixType::Nested>::type \_MatrixTypeNested;
00100     \textcolor{keyword}{typedef} Block<SparseMatrixType, BlockRows, BlockCols, true> BlockType;
00101     \textcolor{keyword}{typedef} SparseCompressedBase<Block<SparseMatrixType,BlockRows,BlockCols,true> > Base;
00102     \textcolor{keyword}{using} Base::convert\_index;
00103 \textcolor{keyword}{public}:
00104     \textcolor{keyword}{enum} \{ IsRowMajor = internal::traits<BlockType>::IsRowMajor \};
00105     EIGEN\_SPARSE\_PUBLIC\_INTERFACE(BlockType)
00106 \textcolor{keyword}{protected}:
00107     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::IndexVector IndexVector;
00108     \textcolor{keyword}{enum} \{ OuterSize = IsRowMajor ? BlockRows : BlockCols \};
00109 \textcolor{keyword}{public}:
00110 
00111     \textcolor{keyword}{inline} sparse\_matrix\_block\_impl(SparseMatrixType& xpr, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i)
00112       : m\_matrix(xpr), m\_outerStart(convert\_index(i)), m\_outerSize(OuterSize)
00113     \{\}
00114 
00115     \textcolor{keyword}{inline} sparse\_matrix\_block\_impl(SparseMatrixType& xpr, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startRow, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startCol, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockRows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockCols)
00116       : m\_matrix(xpr), m\_outerStart(convert\_index(IsRowMajor ? startRow : startCol)), m\_outerSize(
      convert\_index(IsRowMajor ? blockRows : blockCols))
00117     \{\}
00118 
00119     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00120     \textcolor{keyword}{inline} BlockType& operator=(\textcolor{keyword}{const} SparseMatrixBase<OtherDerived>& other)
00121     \{
00122       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<typename SparseMatrixType::Nested>::type \_NestedMatrixType;
00123       \_NestedMatrixType& matrix = m\_matrix;
00124       \textcolor{comment}{// This assignment is slow if this vector set is not empty}
00125       \textcolor{comment}{// and/or it is not at the end of the nonzeros of the underlying matrix.}
00126 
00127       \textcolor{comment}{// 1 - eval to a temporary to avoid transposition and/or aliasing issues}
00128       Ref<const SparseMatrix<Scalar, IsRowMajor ? RowMajor : ColMajor, StorageIndex> > tmp(other.derived())
      ;
00129       eigen\_internal\_assert(tmp.outerSize()==m\_outerSize.value());
00130 
00131       \textcolor{comment}{// 2 - let's check whether there is enough allocated memory}
00132       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nnz           = tmp.nonZeros();
00133       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} start         = m\_outerStart==0 ? 0 : m\_matrix.outerIndexPtr()[m\_outerStart]; \textcolor{comment}{// starting
       position of the current block}
00134       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} end           = m\_matrix.outerIndexPtr()[m\_outerStart+m\_outerSize.value()]; \textcolor{comment}{// ending
       position of the current block}
00135       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} block\_size    = end - start;                                                \textcolor{comment}{// available
       room in the current block}
00136       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} tail\_size     = m\_matrix.outerIndexPtr()[m\_matrix.outerSize()] - end;
00137 
00138       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} free\_size     = m\_matrix.isCompressed()
00139                           ? \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(matrix.data().allocatedSize()) + block\_size
00140                           : block\_size;
00141 
00142       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} tmp\_start = tmp.outerIndexPtr()[0];
00143 
00144       \textcolor{keywordtype}{bool} update\_trailing\_pointers = \textcolor{keyword}{false};
00145       \textcolor{keywordflow}{if}(nnz>free\_size)
00146       \{
00147         \textcolor{comment}{// realloc manually to reduce copies}
00148         \textcolor{keyword}{typename} SparseMatrixType::Storage newdata(m\_matrix.data().allocatedSize() - block\_size + nnz);
00149 
00150         internal::smart\_copy(m\_matrix.valuePtr(),       m\_matrix.valuePtr() + start,      newdata.valuePtr(
      ));
00151         internal::smart\_copy(m\_matrix.innerIndexPtr(),  m\_matrix.innerIndexPtr() + start, newdata.indexPtr(
      ));
00152 
00153         internal::smart\_copy(tmp.valuePtr() + tmp\_start,      tmp.valuePtr() + tmp\_start + nnz,       
      newdata.valuePtr() + start);
00154         internal::smart\_copy(tmp.innerIndexPtr() + tmp\_start, tmp.innerIndexPtr() + tmp\_start + nnz,  
      newdata.indexPtr() + start);
00155 
00156         internal::smart\_copy(matrix.valuePtr()+end,       matrix.valuePtr()+end + tail\_size,      newdata.
      valuePtr()+start+nnz);
00157         internal::smart\_copy(matrix.innerIndexPtr()+end,  matrix.innerIndexPtr()+end + tail\_size, newdata.
      indexPtr()+start+nnz);
00158 
00159         newdata.resize(m\_matrix.outerIndexPtr()[m\_matrix.outerSize()] - block\_size + nnz);
00160 
00161         matrix.data().swap(newdata);
00162 
00163         update\_trailing\_pointers = \textcolor{keyword}{true};
00164       \}
00165       \textcolor{keywordflow}{else}
00166       \{
00167         \textcolor{keywordflow}{if}(m\_matrix.isCompressed())
00168         \{
00169           \textcolor{comment}{// no need to realloc, simply copy the tail at its respective position and insert tmp}
00170           matrix.data().resize(start + nnz + tail\_size);
00171 
00172           internal::smart\_memmove(matrix.valuePtr()+end,      matrix.valuePtr() + end+tail\_size,      
      matrix.valuePtr() + start+nnz);
00173           internal::smart\_memmove(matrix.innerIndexPtr()+end, matrix.innerIndexPtr() + end+tail\_size, 
      matrix.innerIndexPtr() + start+nnz);
00174 
00175           update\_trailing\_pointers = \textcolor{keyword}{true};
00176         \}
00177 
00178         internal::smart\_copy(tmp.valuePtr() + tmp\_start,      tmp.valuePtr() + tmp\_start + nnz,       
      matrix.valuePtr() + start);
00179         internal::smart\_copy(tmp.innerIndexPtr() + tmp\_start, tmp.innerIndexPtr() + tmp\_start + nnz,  
      matrix.innerIndexPtr() + start);
00180       \}
00181 
00182       \textcolor{comment}{// update outer index pointers and innerNonZeros}
00183       \textcolor{keywordflow}{if}(IsVectorAtCompileTime)
00184       \{
00185         \textcolor{keywordflow}{if}(!m\_matrix.isCompressed())
00186           matrix.innerNonZeroPtr()[m\_outerStart] = StorageIndex(nnz);
00187         matrix.outerIndexPtr()[m\_outerStart] = StorageIndex(start);
00188       \}
00189       \textcolor{keywordflow}{else}
00190       \{
00191         StorageIndex p = StorageIndex(start);
00192         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<m\_outerSize.value(); ++k)
00193         \{
00194           StorageIndex nnz\_k = internal::convert\_index<StorageIndex>(tmp.innerVector(k).nonZeros());
00195           \textcolor{keywordflow}{if}(!m\_matrix.isCompressed())
00196             matrix.innerNonZeroPtr()[m\_outerStart+k] = nnz\_k;
00197           matrix.outerIndexPtr()[m\_outerStart+k] = p;
00198           p += nnz\_k;
00199         \}
00200       \}
00201 
00202       \textcolor{keywordflow}{if}(update\_trailing\_pointers)
00203       \{
00204         StorageIndex offset = internal::convert\_index<StorageIndex>(nnz - block\_size);
00205         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = m\_outerStart + m\_outerSize.value(); k<=matrix.outerSize(); ++k)
00206         \{
00207           matrix.outerIndexPtr()[k] += offset;
00208         \}
00209       \}
00210 
00211       \textcolor{keywordflow}{return} derived();
00212     \}
00213 
00214     \textcolor{keyword}{inline} BlockType& operator=(\textcolor{keyword}{const} BlockType& other)
00215     \{
00216       \textcolor{keywordflow}{return} \textcolor{keyword}{operator}=<BlockType>(other);
00217     \}
00218 
00219     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar* valuePtr()\textcolor{keyword}{ const}
00220 \textcolor{keyword}{    }\{ \textcolor{keywordflow}{return} m\_matrix.valuePtr(); \}
00221     \textcolor{keyword}{inline} Scalar* valuePtr()
00222     \{ \textcolor{keywordflow}{return} m\_matrix.valuePtr(); \}
00223 
00224     \textcolor{keyword}{inline} \textcolor{keyword}{const} StorageIndex* innerIndexPtr()\textcolor{keyword}{ const}
00225 \textcolor{keyword}{    }\{ \textcolor{keywordflow}{return} m\_matrix.innerIndexPtr(); \}
00226     \textcolor{keyword}{inline} StorageIndex* innerIndexPtr()
00227     \{ \textcolor{keywordflow}{return} m\_matrix.innerIndexPtr(); \}
00228 
00229     \textcolor{keyword}{inline} \textcolor{keyword}{const} StorageIndex* outerIndexPtr()\textcolor{keyword}{ const}
00230 \textcolor{keyword}{    }\{ \textcolor{keywordflow}{return} m\_matrix.outerIndexPtr() + m\_outerStart; \}
00231     \textcolor{keyword}{inline} StorageIndex* outerIndexPtr()
00232     \{ \textcolor{keywordflow}{return} m\_matrix.outerIndexPtr() + m\_outerStart; \}
00233 
00234     \textcolor{keyword}{inline} \textcolor{keyword}{const} StorageIndex* innerNonZeroPtr()\textcolor{keyword}{ const}
00235 \textcolor{keyword}{    }\{ \textcolor{keywordflow}{return} isCompressed() ? 0 : (m\_matrix.innerNonZeroPtr()+m\_outerStart); \}
00236     \textcolor{keyword}{inline} StorageIndex* innerNonZeroPtr()
00237     \{ \textcolor{keywordflow}{return} isCompressed() ? 0 : (m\_matrix.innerNonZeroPtr()+m\_outerStart); \}
00238 
00239     \textcolor{keywordtype}{bool} isCompressed()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix.innerNonZeroPtr()==0; \}
00240 
00241     \textcolor{keyword}{inline} Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
00242     \{
00243       \textcolor{keywordflow}{return} m\_matrix.coeffRef(row + (IsRowMajor ? m\_outerStart : 0), col + (IsRowMajor ? 0 :  m\_outerStart
      ));
00244     \}
00245 
00246     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00247 \textcolor{keyword}{    }\{
00248       \textcolor{keywordflow}{return} m\_matrix.coeff(row + (IsRowMajor ? m\_outerStart : 0), col + (IsRowMajor ? 0 :  m\_outerStart));
00249     \}
00250 
00251     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00252 \textcolor{keyword}{    }\{
00253       \textcolor{keywordflow}{return} m\_matrix.coeff(IsRowMajor ? m\_outerStart : index, IsRowMajor ? index :  m\_outerStart);
00254     \}
00255 
00256     \textcolor{keyword}{const} Scalar& lastCoeff()\textcolor{keyword}{ const}
00257 \textcolor{keyword}{    }\{
00258       EIGEN\_STATIC\_ASSERT\_VECTOR\_ONLY(sparse\_matrix\_block\_impl);
00259       eigen\_assert(Base::nonZeros()>0);
00260       \textcolor{keywordflow}{if}(m\_matrix.isCompressed())
00261         \textcolor{keywordflow}{return} m\_matrix.valuePtr()[m\_matrix.outerIndexPtr()[m\_outerStart+1]-1];
00262       \textcolor{keywordflow}{else}
00263         \textcolor{keywordflow}{return} m\_matrix.valuePtr()[m\_matrix.outerIndexPtr()[m\_outerStart]+m\_matrix.innerNonZeroPtr()[
      m\_outerStart]-1];
00264     \}
00265 
00266     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_outerSize.value() : m\_matrix.rows()
      ; \}
00267     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_matrix.cols() : m\_outerSize.value()
      ; \}
00268 
00269     \textcolor{keyword}{inline} \textcolor{keyword}{const} SparseMatrixType& nestedExpression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix; \}
00270     \textcolor{keyword}{inline} SparseMatrixType& nestedExpression() \{ \textcolor{keywordflow}{return} m\_matrix; \}
00271     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startRow()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_outerStart : 0; \}
00272     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startCol()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? 0 : m\_outerStart; \}
00273     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockRows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_outerSize.value() : m\_matrix.rows(); \}
00274     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockCols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_matrix.cols() : m\_outerSize.value(); \}
00275 
00276   \textcolor{keyword}{protected}:
00277 
00278     \textcolor{keyword}{typename} internal::ref\_selector<SparseMatrixType>::non\_const\_type m\_matrix;
00279     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_outerStart;
00280     \textcolor{keyword}{const} internal::variable\_if\_dynamic<Index, OuterSize> m\_outerSize;
00281 
00282 \};
00283 
00284 \} \textcolor{comment}{// namespace internal}
00285 
00286 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols>
00287 \textcolor{keyword}{class }BlockImpl<SparseMatrix<\_Scalar, \_Options, \_StorageIndex>,BlockRows,BlockCols,true,Sparse>
00288   : \textcolor{keyword}{public} internal::sparse\_matrix\_block\_impl<SparseMatrix<\_Scalar, \_Options, \_StorageIndex>,BlockRows,Bloc
      kCols>
00289 \{
00290 \textcolor{keyword}{public}:
00291   \textcolor{keyword}{typedef} \_StorageIndex StorageIndex;
00292   \textcolor{keyword}{typedef} SparseMatrix<\_Scalar, \_Options, \_StorageIndex> SparseMatrixType;
00293   \textcolor{keyword}{typedef} internal::sparse\_matrix\_block\_impl<SparseMatrixType,BlockRows,BlockCols> Base;
00294   \textcolor{keyword}{inline} BlockImpl(SparseMatrixType& xpr, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i)
00295     : Base(xpr, i)
00296   \{\}
00297 
00298   \textcolor{keyword}{inline} BlockImpl(SparseMatrixType& xpr, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startRow, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startCol, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockRows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockCols)
00299     : Base(xpr, startRow, startCol, blockRows, blockCols)
00300   \{\}
00301 
00302   \textcolor{keyword}{using} Base::operator=;
00303 \};
00304 
00305 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols>
00306 \textcolor{keyword}{class }BlockImpl<const SparseMatrix<\_Scalar, \_Options, \_StorageIndex>,BlockRows,BlockCols,true,Sparse>
00307   : \textcolor{keyword}{public} internal::sparse\_matrix\_block\_impl<const SparseMatrix<\_Scalar, \_Options, \_StorageIndex>,BlockRow
      s,BlockCols>
00308 \{
00309 \textcolor{keyword}{public}:
00310   \textcolor{keyword}{typedef} \_StorageIndex StorageIndex;
00311   \textcolor{keyword}{typedef} \textcolor{keyword}{const} SparseMatrix<\_Scalar, \_Options, \_StorageIndex> SparseMatrixType;
00312   \textcolor{keyword}{typedef} internal::sparse\_matrix\_block\_impl<SparseMatrixType,BlockRows,BlockCols> Base;
00313   \textcolor{keyword}{inline} BlockImpl(SparseMatrixType& xpr, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i)
00314     : Base(xpr, i)
00315   \{\}
00316 
00317   \textcolor{keyword}{inline} BlockImpl(SparseMatrixType& xpr, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startRow, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startCol, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockRows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockCols)
00318     : Base(xpr, startRow, startCol, blockRows, blockCols)
00319   \{\}
00320 
00321   \textcolor{keyword}{using} Base::operator=;
00322 \textcolor{keyword}{private}:
00323   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> BlockImpl(\textcolor{keyword}{const} SparseMatrixBase<Derived>& xpr, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i);
00324   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> BlockImpl(\textcolor{keyword}{const} SparseMatrixBase<Derived>& xpr);
00325 \};
00326 
00327 \textcolor{comment}{//----------}
00328 
00332 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00333 \textcolor{keyword}{typename} SparseMatrixBase<Derived>::InnerVectorReturnType 
      \hyperlink{group___sparse_core___module_a65aaf3b50d205011e2bfa0de24756cce}{SparseMatrixBase<Derived>::innerVector}(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer)
00334 \{ \textcolor{keywordflow}{return} InnerVectorReturnType(derived(), outer); \}
00335 
00339 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00340 \textcolor{keyword}{const} \textcolor{keyword}{typename} SparseMatrixBase<Derived>::ConstInnerVectorReturnType 
      \hyperlink{group___sparse_core___module_a65aaf3b50d205011e2bfa0de24756cce}{SparseMatrixBase<Derived>::innerVector}(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer)\textcolor{keyword}{ const}
00341 \textcolor{keyword}{}\{ \textcolor{keywordflow}{return} ConstInnerVectorReturnType(derived(), outer); \}
00342 
00346 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00347 \textcolor{keyword}{typename} SparseMatrixBase<Derived>::InnerVectorsReturnType
00348 \hyperlink{group___sparse_core___module_a3c51bf5a7eb18eab9a85949d03aed14a}{SparseMatrixBase<Derived>::innerVectors}(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerStart, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerSize)
00349 \{
00350   \textcolor{keywordflow}{return} Block<Derived,Dynamic,Dynamic,true>(derived(),
00351                                              IsRowMajor ? outerStart : 0, IsRowMajor ? 0 : outerStart,
00352                                              IsRowMajor ? outerSize : rows(), IsRowMajor ? cols() : 
      outerSize);
00353 
00354 \}
00355 
00359 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00360 \textcolor{keyword}{const} \textcolor{keyword}{typename} SparseMatrixBase<Derived>::ConstInnerVectorsReturnType
00361 \hyperlink{group___sparse_core___module_a3c51bf5a7eb18eab9a85949d03aed14a}{SparseMatrixBase<Derived>::innerVectors}(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerStart, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerSize)\textcolor{keyword}{ const}
00362 \textcolor{keyword}{}\{
00363   \textcolor{keywordflow}{return} Block<const Derived,Dynamic,Dynamic,true>(derived(),
00364                                                   IsRowMajor ? outerStart : 0, IsRowMajor ? 0 : outerStart,
00365                                                   IsRowMajor ? outerSize : rows(), IsRowMajor ? cols() : 
      outerSize);
00366 
00367 \}
00368 
00372 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols, \textcolor{keywordtype}{bool} InnerPanel>
00373 \textcolor{keyword}{class }BlockImpl<XprType,BlockRows,BlockCols,InnerPanel,Sparse>
00374   : \textcolor{keyword}{public} SparseMatrixBase<Block<XprType,BlockRows,BlockCols,InnerPanel> >, 
      internal::no\_assignment\_operator
00375 \{
00376     \textcolor{keyword}{typedef} Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;
00377     \textcolor{keyword}{typedef} SparseMatrixBase<BlockType> Base;
00378     \textcolor{keyword}{using} Base::convert\_index;
00379 \textcolor{keyword}{public}:
00380     \textcolor{keyword}{enum} \{ IsRowMajor = internal::traits<BlockType>::IsRowMajor \};
00381     EIGEN\_SPARSE\_PUBLIC\_INTERFACE(BlockType)
00382 
00383     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type \_MatrixTypeNested;
00384 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_block_8h_source_l00387}\hyperlink{class_eigen_1_1_block_impl_3_01_xpr_type_00_01_block_rows_00_01_block_cols_00_01_inner_panel_00_01_sparse_01_4_aa724feeda73e4d5d2330c6dced2d18f9}{00387}     \textcolor{keyword}{inline} \hyperlink{class_eigen_1_1_block_impl_3_01_xpr_type_00_01_block_rows_00_01_block_cols_00_01_inner_panel_00_01_sparse_01_4_aa724feeda73e4d5d2330c6dced2d18f9}{BlockImpl}(XprType& xpr, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i)
00388       : m\_matrix(xpr),
00389         m\_startRow( (BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) ? convert\_index(i) : 0),
00390         m\_startCol( (BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) ? convert\_index(i) : 0),
00391         m\_blockRows(BlockRows==1 ? 1 : xpr.rows()),
00392         m\_blockCols(BlockCols==1 ? 1 : xpr.cols())
00393     \{\}
00394 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_block_8h_source_l00397}\hyperlink{class_eigen_1_1_block_impl_3_01_xpr_type_00_01_block_rows_00_01_block_cols_00_01_inner_panel_00_01_sparse_01_4_a2fe461bd49f27e586b7d0e652e370644}{00397}     \textcolor{keyword}{inline} \hyperlink{class_eigen_1_1_block_impl_3_01_xpr_type_00_01_block_rows_00_01_block_cols_00_01_inner_panel_00_01_sparse_01_4_a2fe461bd49f27e586b7d0e652e370644}{BlockImpl}(XprType& xpr, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} startRow, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} startCol, 
      \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} blockRows, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} blockCols)
00398       : m\_matrix(xpr), m\_startRow(convert\_index(startRow)), m\_startCol(convert\_index(startCol)), 
      m\_blockRows(convert\_index(blockRows)), m\_blockCols(convert\_index(blockCols))
00399     \{\}
00400 
00401     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_blockRows.value(); \}
00402     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_blockCols.value(); \}
00403 
00404     \textcolor{keyword}{inline} Scalar& coeffRef(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col)
00405     \{
00406       \textcolor{keywordflow}{return} m\_matrix.coeffRef(row + m\_startRow.value(), col + m\_startCol.value());
00407     \}
00408 
00409     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar coeff(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col)\textcolor{keyword}{ const}
00410 \textcolor{keyword}{    }\{
00411       \textcolor{keywordflow}{return} m\_matrix.coeff(row + m\_startRow.value(), col + m\_startCol.value());
00412     \}
00413 
00414     \textcolor{keyword}{inline} Scalar& coeffRef(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} index)
00415     \{
00416       \textcolor{keywordflow}{return} m\_matrix.coeffRef(m\_startRow.value() + (RowsAtCompileTime == 1 ? 0 : index),
00417                                m\_startCol.value() + (RowsAtCompileTime == 1 ? index : 0));
00418     \}
00419 
00420     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar coeff(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} index)\textcolor{keyword}{ const}
00421 \textcolor{keyword}{    }\{
00422       \textcolor{keywordflow}{return} m\_matrix.coeff(m\_startRow.value() + (RowsAtCompileTime == 1 ? 0 : index),
00423                             m\_startCol.value() + (RowsAtCompileTime == 1 ? index : 0));
00424     \}
00425 
00426     \textcolor{keyword}{inline} \textcolor{keyword}{const} XprType& nestedExpression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix; \}
00427     \textcolor{keyword}{inline} XprType& nestedExpression() \{ \textcolor{keywordflow}{return} m\_matrix; \}
00428     \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} startRow()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_startRow.value(); \}
00429     \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} startCol()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_startCol.value(); \}
00430     \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} blockRows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_blockRows.value(); \}
00431     \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} blockCols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_blockCols.value(); \}
00432 
00433   \textcolor{keyword}{protected}:
00434 \textcolor{comment}{//     friend class internal::GenericSparseBlockInnerIteratorImpl<XprType,BlockRows,BlockCols,InnerPanel>;}
00435     \textcolor{keyword}{friend} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1unary__evaluator}{internal::unary\_evaluator}<Block<XprType,BlockRows,BlockCols,
      InnerPanel>, internal::IteratorBased, Scalar >;
00436 
00437     \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} nonZeros() const \{ \textcolor{keywordflow}{return} \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}; \}
00438 
00439     \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::ref\_selector<XprType>::non\_const\_type}
       m\_matrix;
00440     \textcolor{keyword}{const} 
      \hyperlink{class_eigen_1_1internal_1_1variable__if__dynamic}{internal::variable\_if\_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic>}
       m\_startRow;
00441     \textcolor{keyword}{const} 
      \hyperlink{class_eigen_1_1internal_1_1variable__if__dynamic}{internal::variable\_if\_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic>}
       m\_startCol;
00442     \textcolor{keyword}{const} \hyperlink{class_eigen_1_1internal_1_1variable__if__dynamic}{internal::variable\_if\_dynamic<Index, RowsAtCompileTime>}
       m\_blockRows;
00443     \textcolor{keyword}{const} \hyperlink{class_eigen_1_1internal_1_1variable__if__dynamic}{internal::variable\_if\_dynamic<Index, ColsAtCompileTime>}
       m\_blockCols;
00444 
00445   \textcolor{keyword}{protected}:
00446     \textcolor{comment}{// Disable assignment with clear error message.}
00447     \textcolor{comment}{// Note that simply removing operator= yields compilation errors with ICC+MSVC}
00448     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00449     \hyperlink{class_eigen_1_1_block_impl}{BlockImpl}& operator=(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}&)
00450     \{
00451       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module}{T})==0, THIS\_SPARSE\_BLOCK\_SUBEXPRESSION\_IS\_READ\_ONLY);
00452       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00453     \}
00454 
00455 \};
00456 
00457 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00458 
00459 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols, \textcolor{keywordtype}{bool} InnerPanel>
00460 \textcolor{keyword}{struct }unary\_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>, IteratorBased >
00461  : \textcolor{keyword}{public} evaluator\_base<Block<ArgType,BlockRows,BlockCols,InnerPanel> >
00462 \{
00463     \textcolor{keyword}{class }InnerVectorInnerIterator;
00464     \textcolor{keyword}{class }OuterVectorInnerIterator;
00465   \textcolor{keyword}{public}:
00466     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_block}{Block<ArgType,BlockRows,BlockCols,InnerPanel>} 
      XprType;
00467     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::StorageIndex \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex};
00468     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00469 
00470     \textcolor{keyword}{enum} \{
00471       IsRowMajor = XprType::IsRowMajor,
00472 
00473       OuterVector =  (BlockCols==1 && ArgType::IsRowMajor)
00474                     | \textcolor{comment}{// FIXME | instead of || to please GCC 4.4.0 stupid warning "suggest parentheses
       around &&".}
00475                       \textcolor{comment}{// revert to || as soon as not needed anymore.}
00476                      (BlockRows==1 && !ArgType::IsRowMajor),
00477 
00478       CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
00479       Flags = XprType::Flags
00480     \};
00481 
00482     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::conditional<OuterVector,OuterVectorInnerIterator,InnerVectorInnerIterator>::type}
       \hyperlink{class_eigen_1_1_inner_iterator}{InnerIterator};
00483 
00484     \textcolor{keyword}{explicit} unary\_evaluator(\textcolor{keyword}{const} XprType& op)
00485       : m\_argImpl(op.nestedExpression()), m\_block(op)
00486     \{\}
00487 
00488     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} nonZerosEstimate()\textcolor{keyword}{ const }\{
00489       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} nnz = m\_block.nonZeros();
00490       \textcolor{keywordflow}{if}(nnz<0)
00491         \textcolor{keywordflow}{return} m\_argImpl.nonZerosEstimate() * m\_block.size() / m\_block.nestedExpression().size();
00492       \textcolor{keywordflow}{return} nnz;
00493     \}
00494 
00495   \textcolor{keyword}{protected}:
00496     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<ArgType>::InnerIterator EvalIterator;
00497 
00498     evaluator<ArgType> m\_argImpl;
00499     \textcolor{keyword}{const} XprType &m\_block;
00500 \};
00501 
00502 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols, \textcolor{keywordtype}{bool} InnerPanel>
00503 \textcolor{keyword}{class }unary\_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>, IteratorBased>::
      InnerVectorInnerIterator
00504  : \textcolor{keyword}{public} EvalIterator
00505 \{
00506   \textcolor{keyword}{enum} \{ IsRowMajor = unary\_evaluator::IsRowMajor \};
00507   \textcolor{keyword}{const} XprType& m\_block;
00508   \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} m\_end;
00509 \textcolor{keyword}{public}:
00510 
00511   EIGEN\_STRONG\_INLINE InnerVectorInnerIterator(\textcolor{keyword}{const} unary\_evaluator& aEval, 
      \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer)
00512     : EvalIterator(aEval.m\_argImpl, outer + (IsRowMajor ? aEval.m\_block.startRow() : aEval.m\_block.startCol
      ())),
00513       m\_block(aEval.m\_block),
00514       m\_end(IsRowMajor ? aEval.m\_block.startCol()+aEval.m\_block.blockCols() : aEval.m\_block.startRow()+
      aEval.m\_block.blockRows())
00515   \{
00516     \textcolor{keywordflow}{while}( (EvalIterator::operator \textcolor{keywordtype}{bool}()) && (EvalIterator::index() < (IsRowMajor ? m\_block.startCol() : 
      m\_block.startRow())) )
00517       EvalIterator::operator++();
00518   \}
00519 
00520   \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} index()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} EvalIterator::index() - 
      convert\_index<StorageIndex>(IsRowMajor ? m\_block.startCol() : m\_block.startRow()); \}
00521   \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer()\textcolor{keyword}{  const }\{ \textcolor{keywordflow}{return} EvalIterator::outer() - (IsRowMajor ? m\_block.startRow() : 
      m\_block.startCol()); \}
00522   \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row()\textcolor{keyword}{    const }\{ \textcolor{keywordflow}{return} EvalIterator::row()   - m\_block.startRow(); \}
00523   \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col()\textcolor{keyword}{    const }\{ \textcolor{keywordflow}{return} EvalIterator::col()   - m\_block.startCol(); \}
00524 
00525   \textcolor{keyword}{inline} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} EvalIterator::operator bool() && EvalIterator::index() < m\_end; \}
00526 \};
00527 
00528 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols, \textcolor{keywordtype}{bool} InnerPanel>
00529 \textcolor{keyword}{class }unary\_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>, IteratorBased>::
      OuterVectorInnerIterator
00530 \{
00531   \textcolor{keyword}{enum} \{ IsRowMajor = unary\_evaluator::IsRowMajor \};
00532   \textcolor{keyword}{const} unary\_evaluator& m\_eval;
00533   \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} m\_outerPos;
00534   \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} m\_innerIndex;
00535   \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} m\_end;
00536   EvalIterator m\_it;
00537 \textcolor{keyword}{public}:
00538 
00539   EIGEN\_STRONG\_INLINE OuterVectorInnerIterator(\textcolor{keyword}{const} unary\_evaluator& aEval, 
      \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer)
00540     : m\_eval(aEval),
00541       m\_outerPos( (IsRowMajor ? aEval.m\_block.startCol() : aEval.m\_block.startRow()) ),
00542       m\_innerIndex(IsRowMajor ? aEval.m\_block.startRow() : aEval.m\_block.startCol()),
00543       m\_end(IsRowMajor ? aEval.m\_block.startCol()+aEval.m\_block.blockCols() : aEval.m\_block.startRow()+
      aEval.m\_block.blockRows()),
00544       m\_it(m\_eval.m\_argImpl, m\_outerPos)
00545   \{
00546     EIGEN\_UNUSED\_VARIABLE(outer);
00547     eigen\_assert(outer==0);
00548 
00549     \textcolor{keywordflow}{while}(m\_it && m\_it.index() < m\_innerIndex) ++m\_it;
00550     \textcolor{keywordflow}{if}((!m\_it) || (m\_it.index()!=m\_innerIndex))
00551       ++(*this);
00552   \}
00553 
00554   \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} index()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} convert\_index<StorageIndex>(m\_outerPos - (
      IsRowMajor ? m\_eval.m\_block.startCol() : m\_eval.m\_block.startRow())); \}
00555   \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer()\textcolor{keyword}{  const }\{ \textcolor{keywordflow}{return} 0; \}
00556   \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row()\textcolor{keyword}{    const }\{ \textcolor{keywordflow}{return} IsRowMajor ? 0 : index(); \}
00557   \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col()\textcolor{keyword}{    const }\{ \textcolor{keywordflow}{return} IsRowMajor ? index() : 0; \}
00558 
00559   \textcolor{keyword}{inline} Scalar value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_it.value(); \}
00560   \textcolor{keyword}{inline} Scalar& valueRef() \{ \textcolor{keywordflow}{return} m\_it.valueRef(); \}
00561 
00562   \textcolor{keyword}{inline} OuterVectorInnerIterator& operator++()
00563   \{
00564     \textcolor{comment}{// search next non-zero entry}
00565     \textcolor{keywordflow}{while}(++m\_outerPos<m\_end)
00566     \{
00567       \textcolor{comment}{// Restart iterator at the next inner-vector:}
00568       m\_it.~EvalIterator();
00569       ::new (&m\_it) EvalIterator(m\_eval.m\_argImpl, m\_outerPos);
00570       \textcolor{comment}{// search for the key m\_innerIndex in the current outer-vector}
00571       \textcolor{keywordflow}{while}(m\_it && m\_it.index() < m\_innerIndex) ++m\_it;
00572       \textcolor{keywordflow}{if}(m\_it && m\_it.index()==m\_innerIndex) \textcolor{keywordflow}{break};
00573     \}
00574     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00575   \}
00576 
00577   \textcolor{keyword}{inline} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_outerPos < m\_end; \}
00578 \};
00579 
00580 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols>
00581 \textcolor{keyword}{struct }unary\_evaluator<Block<SparseMatrix<\_Scalar, \_Options, \_StorageIndex>,BlockRows,BlockCols,true>, 
      IteratorBased>
00582   : evaluator<SparseCompressedBase<Block<SparseMatrix<\_Scalar, \_Options, \_StorageIndex>,BlockRows,BlockCols
      ,true> > >
00583 \{
00584   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_block}{Block<SparseMatrix<\_Scalar, \_Options, \_StorageIndex>}
      ,BlockRows,BlockCols,\textcolor{keyword}{true}> XprType;
00585   \textcolor{keyword}{typedef} evaluator<SparseCompressedBase<XprType> > Base;
00586   \textcolor{keyword}{explicit} unary\_evaluator(\textcolor{keyword}{const} XprType &xpr) : Base(xpr) \{\}
00587 \};
00588 
00589 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols>
00590 \textcolor{keyword}{struct }unary\_evaluator<Block<const SparseMatrix<\_Scalar, \_Options, \_StorageIndex>,BlockRows,BlockCols,true>
      , IteratorBased>
00591   : evaluator<SparseCompressedBase<Block<const SparseMatrix<\_Scalar, \_Options, \_StorageIndex>,BlockRows,Blo
      ckCols,true> > >
00592 \{
00593   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_block}{Block<const SparseMatrix<\_Scalar, \_Options, \_StorageIndex>}
      ,BlockRows,BlockCols,\textcolor{keyword}{true}> XprType;
00594   \textcolor{keyword}{typedef} evaluator<SparseCompressedBase<XprType> > Base;
00595   \textcolor{keyword}{explicit} unary\_evaluator(\textcolor{keyword}{const} XprType &xpr) : Base(xpr) \{\}
00596 \};
00597 
00598 \} \textcolor{comment}{// end namespace internal}
00599 
00600 
00601 \} \textcolor{comment}{// end namespace Eigen}
00602 
00603 \textcolor{preprocessor}{#endif // EIGEN\_SPARSE\_BLOCK\_H}
\end{DoxyCode}
