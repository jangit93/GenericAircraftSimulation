\hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source}{}\section{eigen/unsupported/test/levenberg\+\_\+marquardt.cpp}
\label{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source}\index{levenberg\+\_\+marquardt.\+cpp@{levenberg\+\_\+marquardt.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Thomas Capricelli <orzel@freehackers.org>}
00005 \textcolor{comment}{// Copyright (C) 2012 desire Nuentsa <desire.nuentsa\_wakam@inria.fr}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 
00012 \textcolor{comment}{// FIXME: These tests all check for hard-coded values. Ideally, parameters and start estimates should be
       randomized.}
00013 
00014 
00015 \textcolor{preprocessor}{#include <stdio.h>}
00016 
00017 \textcolor{preprocessor}{#include "main.h"}
00018 \textcolor{preprocessor}{#include <unsupported/Eigen/LevenbergMarquardt>}
00019 
00020 \textcolor{comment}{// This disables some useless Warnings on MSVC.}
00021 \textcolor{comment}{// It is intended to be done for this test only.}
00022 \textcolor{preprocessor}{#include <Eigen/src/Core/util/DisableStupidWarnings.h>}
00023 
00024 \textcolor{keyword}{using} std::sqrt;
00025 
00026 \textcolor{comment}{// tolerance for chekcing number of iterations}
00027 \textcolor{preprocessor}{#define LM\_EVAL\_COUNT\_TOL 4/3}
00028 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l00029}\hyperlink{structlmder__functor}{00029} \textcolor{keyword}{struct }\hyperlink{structlmder__functor}{lmder\_functor} : DenseFunctor<double>
00030 \{
00031     \hyperlink{structlmder__functor}{lmder\_functor}(\textcolor{keywordtype}{void}): DenseFunctor<double>(3,15) \{\}
00032     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &x, VectorXd &fvec)\textcolor{keyword}{ const}
00033 \textcolor{keyword}{    }\{
00034         \textcolor{keywordtype}{double} tmp1, tmp2, tmp3;
00035         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} y[15] = \{1.4e-1, 1.8e-1, 2.2e-1, 2.5e-1, 2.9e-1, 3.2e-1, 3.5e-1,
00036             3.9e-1, 3.7e-1, 5.8e-1, 7.3e-1, 9.6e-1, 1.34, 2.1, 4.39\};
00037 
00038         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < values(); i++)
00039         \{
00040             tmp1 = i+1;
00041             tmp2 = 16 - i - 1;
00042             tmp3 = (i>=8)? tmp2 : tmp1;
00043             fvec[i] = y[i] - (x[0] + tmp1/(x[1]*tmp2 + x[2]*tmp3));
00044         \}
00045         \textcolor{keywordflow}{return} 0;
00046     \}
00047 
00048     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &x, MatrixXd &fjac)\textcolor{keyword}{ const}
00049 \textcolor{keyword}{    }\{
00050         \textcolor{keywordtype}{double} tmp1, tmp2, tmp3, tmp4;
00051         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < values(); i++)
00052         \{
00053             tmp1 = i+1;
00054             tmp2 = 16 - i - 1;
00055             tmp3 = (i>=8)? tmp2 : tmp1;
00056             tmp4 = (x[1]*tmp2 + x[2]*tmp3); tmp4 = tmp4*tmp4;
00057             fjac(i,0) = -1;
00058             fjac(i,1) = tmp1*tmp2/tmp4;
00059             fjac(i,2) = tmp1*tmp3/tmp4;
00060         \}
00061         \textcolor{keywordflow}{return} 0;
00062     \}
00063 \};
00064 
00065 \textcolor{keywordtype}{void} testLmder1()
00066 \{
00067   \textcolor{keywordtype}{int} n=3, info;
00068 
00069   VectorXd x;
00070 
00071   \textcolor{comment}{/* the following starting values provide a rough fit. */}
00072   x.setConstant(n, 1.);
00073 
00074   \textcolor{comment}{// do the computation}
00075   \hyperlink{structlmder__functor}{lmder\_functor} functor;
00076   LevenbergMarquardt<lmder\_functor> lm(functor);
00077   info = lm.lmder1(x);
00078 
00079   \textcolor{comment}{// check return value}
00080   VERIFY\_IS\_EQUAL(info, 1);
00081   VERIFY\_IS\_EQUAL(lm.nfev(), 6);
00082   VERIFY\_IS\_EQUAL(lm.njev(), 5);
00083 
00084   \textcolor{comment}{// check norm}
00085   VERIFY\_IS\_APPROX(lm.fvec().blueNorm(), 0.09063596);
00086 
00087   \textcolor{comment}{// check x}
00088   VectorXd x\_ref(n);
00089   x\_ref << 0.08241058, 1.133037, 2.343695;
00090   VERIFY\_IS\_APPROX(x, x\_ref);
00091 \}
00092 
00093 \textcolor{keywordtype}{void} testLmder()
00094 \{
00095   \textcolor{keyword}{const} \textcolor{keywordtype}{int} m=15, n=3;
00096   \textcolor{keywordtype}{int} info;
00097   \textcolor{keywordtype}{double} fnorm, covfac;
00098   VectorXd x;
00099 
00100   \textcolor{comment}{/* the following starting values provide a rough fit. */}
00101   x.setConstant(n, 1.);
00102 
00103   \textcolor{comment}{// do the computation}
00104   \hyperlink{structlmder__functor}{lmder\_functor} functor;
00105   LevenbergMarquardt<lmder\_functor> lm(functor);
00106   info = lm.minimize(x);
00107 
00108   \textcolor{comment}{// check return values}
00109   VERIFY\_IS\_EQUAL(info, 1);
00110   VERIFY\_IS\_EQUAL(lm.nfev(), 6);
00111   VERIFY\_IS\_EQUAL(lm.njev(), 5);
00112 
00113   \textcolor{comment}{// check norm}
00114   fnorm = lm.fvec().blueNorm();
00115   VERIFY\_IS\_APPROX(fnorm, 0.09063596);
00116 
00117   \textcolor{comment}{// check x}
00118   VectorXd x\_ref(n);
00119   x\_ref << 0.08241058, 1.133037, 2.343695;
00120   VERIFY\_IS\_APPROX(x, x\_ref);
00121 
00122   \textcolor{comment}{// check covariance}
00123   covfac = fnorm*fnorm/(m-n);
00124   internal::covar(lm.matrixR(), lm.permutation().indices()); \textcolor{comment}{// TODO : move this as a function of lm}
00125 
00126   MatrixXd cov\_ref(n,n);
00127   cov\_ref <<
00128       0.0001531202,   0.002869941,  -0.002656662,
00129       0.002869941,    0.09480935,   -0.09098995,
00130       -0.002656662,   -0.09098995,    0.08778727;
00131 
00132 \textcolor{comment}{//  std::cout << fjac*covfac << std::endl;}
00133 
00134   MatrixXd cov;
00135   cov =  covfac*lm.matrixR().topLeftCorner<n,n>();
00136   VERIFY\_IS\_APPROX( cov, cov\_ref);
00137   \textcolor{comment}{// TODO: why isn't this allowed ? :}
00138   \textcolor{comment}{// VERIFY\_IS\_APPROX( covfac*fjac.topLeftCorner<n,n>() , cov\_ref);}
00139 \}
00140 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l00141}\hyperlink{structlmdif__functor}{00141} \textcolor{keyword}{struct }\hyperlink{structlmdif__functor}{lmdif\_functor} : DenseFunctor<double>
00142 \{
00143     \hyperlink{structlmdif__functor}{lmdif\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(3,15) \{\}
00144     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &x, VectorXd &fvec)\textcolor{keyword}{ const}
00145 \textcolor{keyword}{    }\{
00146         \textcolor{keywordtype}{int} i;
00147         \textcolor{keywordtype}{double} tmp1,tmp2,tmp3;
00148         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} y[15]=\{1.4e-1,1.8e-1,2.2e-1,2.5e-1,2.9e-1,3.2e-1,3.5e-1,3.9e-1,
00149             3.7e-1,5.8e-1,7.3e-1,9.6e-1,1.34e0,2.1e0,4.39e0\};
00150 
00151         assert(x.size()==3);
00152         assert(fvec.size()==15);
00153         \textcolor{keywordflow}{for} (i=0; i<15; i++)
00154         \{
00155             tmp1 = i+1;
00156             tmp2 = 15 - i;
00157             tmp3 = tmp1;
00158 
00159             \textcolor{keywordflow}{if} (i >= 8) tmp3 = tmp2;
00160             fvec[i] = y[i] - (x[0] + tmp1/(x[1]*tmp2 + x[2]*tmp3));
00161         \}
00162         \textcolor{keywordflow}{return} 0;
00163     \}
00164 \};
00165 
00166 \textcolor{keywordtype}{void} testLmdif1()
00167 \{
00168   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=3;
00169   \textcolor{keywordtype}{int} info;
00170 
00171   VectorXd x(n), fvec(15);
00172 
00173   \textcolor{comment}{/* the following starting values provide a rough fit. */}
00174   x.setConstant(n, 1.);
00175 
00176   \textcolor{comment}{// do the computation}
00177   \hyperlink{structlmdif__functor}{lmdif\_functor} functor;
00178   DenseIndex nfev;
00179   info = LevenbergMarquardt<lmdif\_functor>::lmdif1(functor, x, &nfev);
00180 
00181   \textcolor{comment}{// check return value}
00182   VERIFY\_IS\_EQUAL(info, 1);
00183 \textcolor{comment}{//   VERIFY\_IS\_EQUAL(nfev, 26);}
00184 
00185   \textcolor{comment}{// check norm}
00186   functor(x, fvec);
00187   VERIFY\_IS\_APPROX(fvec.blueNorm(), 0.09063596);
00188 
00189   \textcolor{comment}{// check x}
00190   VectorXd x\_ref(n);
00191   x\_ref << 0.0824106, 1.1330366, 2.3436947;
00192   VERIFY\_IS\_APPROX(x, x\_ref);
00193 
00194 \}
00195 
00196 \textcolor{keywordtype}{void} testLmdif()
00197 \{
00198   \textcolor{keyword}{const} \textcolor{keywordtype}{int} m=15, n=3;
00199   \textcolor{keywordtype}{int} info;
00200   \textcolor{keywordtype}{double} fnorm, covfac;
00201   VectorXd x(n);
00202 
00203   \textcolor{comment}{/* the following starting values provide a rough fit. */}
00204   x.setConstant(n, 1.);
00205 
00206   \textcolor{comment}{// do the computation}
00207   \hyperlink{structlmdif__functor}{lmdif\_functor} functor;
00208   NumericalDiff<lmdif\_functor> numDiff(functor);
00209   LevenbergMarquardt<NumericalDiff<lmdif\_functor> > lm(numDiff);
00210   info = lm.minimize(x);
00211 
00212   \textcolor{comment}{// check return values}
00213   VERIFY\_IS\_EQUAL(info, 1);
00214 \textcolor{comment}{//   VERIFY\_IS\_EQUAL(lm.nfev(), 26);}
00215 
00216   \textcolor{comment}{// check norm}
00217   fnorm = lm.fvec().blueNorm();
00218   VERIFY\_IS\_APPROX(fnorm, 0.09063596);
00219 
00220   \textcolor{comment}{// check x}
00221   VectorXd x\_ref(n);
00222   x\_ref << 0.08241058, 1.133037, 2.343695;
00223   VERIFY\_IS\_APPROX(x, x\_ref);
00224 
00225   \textcolor{comment}{// check covariance}
00226   covfac = fnorm*fnorm/(m-n);
00227   internal::covar(lm.matrixR(), lm.permutation().indices()); \textcolor{comment}{// TODO : move this as a function of lm}
00228 
00229   MatrixXd cov\_ref(n,n);
00230   cov\_ref <<
00231       0.0001531202,   0.002869942,  -0.002656662,
00232       0.002869942,    0.09480937,   -0.09098997,
00233       -0.002656662,   -0.09098997,    0.08778729;
00234 
00235 \textcolor{comment}{//  std::cout << fjac*covfac << std::endl;}
00236 
00237   MatrixXd cov;
00238   cov =  covfac*lm.matrixR().topLeftCorner<n,n>();
00239   VERIFY\_IS\_APPROX( cov, cov\_ref);
00240   \textcolor{comment}{// TODO: why isn't this allowed ? :}
00241   \textcolor{comment}{// VERIFY\_IS\_APPROX( covfac*fjac.topLeftCorner<n,n>() , cov\_ref);}
00242 \}
00243 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l00244}\hyperlink{structchwirut2__functor}{00244} \textcolor{keyword}{struct }\hyperlink{structchwirut2__functor}{chwirut2\_functor} : DenseFunctor<double>
00245 \{
00246     \hyperlink{structchwirut2__functor}{chwirut2\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(3,54) \{\}
00247     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} m\_x[54];
00248     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} m\_y[54];
00249     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
00250     \{
00251         \textcolor{keywordtype}{int} i;
00252 
00253         assert(b.size()==3);
00254         assert(fvec.size()==54);
00255         \textcolor{keywordflow}{for}(i=0; i<54; i++) \{
00256             \textcolor{keywordtype}{double} x = m\_x[i];
00257             fvec[i] = exp(-b[0]*x)/(b[1]+b[2]*x) - m\_y[i];
00258         \}
00259         \textcolor{keywordflow}{return} 0;
00260     \}
00261     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
00262     \{
00263         assert(b.size()==3);
00264         assert(fjac.rows()==54);
00265         assert(fjac.cols()==3);
00266         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<54; i++) \{
00267             \textcolor{keywordtype}{double} x = m\_x[i];
00268             \textcolor{keywordtype}{double} factor = 1./(b[1]+b[2]*x);
00269             \textcolor{keywordtype}{double} e = exp(-b[0]*x);
00270             fjac(i,0) = -x*e*factor;
00271             fjac(i,1) = -e*factor*factor;
00272             fjac(i,2) = -x*e*factor*factor;
00273         \}
00274         \textcolor{keywordflow}{return} 0;
00275     \}
00276 \};
00277 \textcolor{keyword}{const} \textcolor{keywordtype}{double} chwirut2\_functor::m\_x[54] = \{ 0.500E0, 1.000E0, 1.750E0, 3.750E0, 5.750E0, 0.875E0, 2.250E0, 3
      .250E0, 5.250E0, 0.750E0, 1.750E0, 2.750E0, 4.750E0, 0.625E0, 1.250E0, 2.250E0, 4.250E0, .500E0, 3.000E0, .7
      50E0, 3.000E0, 1.500E0, 6.000E0, 3.000E0, 6.000E0, 1.500E0, 3.000E0, .500E0, 2.000E0, 4.000E0, .750E0, 2.000
      E0, 5.000E0, .750E0, 2.250E0, 3.750E0, 5.750E0, 3.000E0, .750E0, 2.500E0, 4.000E0, .750E0, 2.500E0, 4.000E0,
       .750E0, 2.500E0, 4.000E0, .500E0, 6.000E0, 3.000E0, .500E0, 2.750E0, .500E0, 1.750E0\};
00278 \textcolor{keyword}{const} \textcolor{keywordtype}{double} chwirut2\_functor::m\_y[54] = \{ 92.9000E0 ,57.1000E0 ,31.0500E0 ,11.5875E0 ,8.0250E0 ,63.6000E0 
      ,21.4000E0 ,14.2500E0 ,8.4750E0 ,63.8000E0 ,26.8000E0 ,16.4625E0 ,7.1250E0 ,67.3000E0 ,41.0000E0 ,21.1500E0 
      ,8.1750E0 ,81.5000E0 ,13.1200E0 ,59.9000E0 ,14.6200E0 ,32.9000E0 ,5.4400E0 ,12.5600E0 ,5.4400E0 ,32.0000E0 ,
      13.9500E0 ,75.8000E0 ,20.0000E0 ,10.4200E0 ,59.5000E0 ,21.6700E0 ,8.5500E0 ,62.0000E0 ,20.2000E0 ,7.7600E0 ,
      3.7500E0 ,11.8100E0 ,54.7000E0 ,23.7000E0 ,11.5500E0 ,61.3000E0 ,17.7000E0 ,8.7400E0 ,59.2000E0 ,16.3000E0 ,
      8.6200E0 ,81.0000E0 ,4.8700E0 ,14.6200E0 ,81.7000E0 ,17.1700E0 ,81.3000E0 ,28.9000E0  \};
00279 
00280 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/chwirut2.shtml}
00281 \textcolor{keywordtype}{void} testNistChwirut2(\textcolor{keywordtype}{void})
00282 \{
00283   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=3;
00284   LevenbergMarquardtSpace::Status info;
00285 
00286   VectorXd x(n);
00287 
00288   \textcolor{comment}{/*}
00289 \textcolor{comment}{   * First try}
00290 \textcolor{comment}{   */}
00291   x<< 0.1, 0.01, 0.02;
00292   \textcolor{comment}{// do the computation}
00293   \hyperlink{structchwirut2__functor}{chwirut2\_functor} functor;
00294   LevenbergMarquardt<chwirut2\_functor> lm(functor);
00295   info = lm.minimize(x);
00296 
00297   \textcolor{comment}{// check return value}
00298   VERIFY\_IS\_EQUAL(info, 1);
00299 \textcolor{comment}{//   VERIFY\_IS\_EQUAL(lm.nfev(), 10);}
00300   VERIFY\_IS\_EQUAL(lm.njev(), 8);
00301   \textcolor{comment}{// check norm^2}
00302   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 5.1304802941E+02);
00303   \textcolor{comment}{// check x}
00304   VERIFY\_IS\_APPROX(x[0], 1.6657666537E-01);
00305   VERIFY\_IS\_APPROX(x[1], 5.1653291286E-03);
00306   VERIFY\_IS\_APPROX(x[2], 1.2150007096E-02);
00307 
00308   \textcolor{comment}{/*}
00309 \textcolor{comment}{   * Second try}
00310 \textcolor{comment}{   */}
00311   x<< 0.15, 0.008, 0.010;
00312   \textcolor{comment}{// do the computation}
00313   lm.resetParameters();
00314   lm.setFtol(1.E6*NumTraits<double>::epsilon());
00315   lm.setXtol(1.E6*NumTraits<double>::epsilon());
00316   info = lm.minimize(x);
00317 
00318   \textcolor{comment}{// check return value}
00319   VERIFY\_IS\_EQUAL(info, 1);
00320 \textcolor{comment}{//   VERIFY\_IS\_EQUAL(lm.nfev(), 7);}
00321   VERIFY\_IS\_EQUAL(lm.njev(), 6);
00322   \textcolor{comment}{// check norm^2}
00323   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 5.1304802941E+02);
00324   \textcolor{comment}{// check x}
00325   VERIFY\_IS\_APPROX(x[0], 1.6657666537E-01);
00326   VERIFY\_IS\_APPROX(x[1], 5.1653291286E-03);
00327   VERIFY\_IS\_APPROX(x[2], 1.2150007096E-02);
00328 \}
00329 
00330 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l00331}\hyperlink{structmisra1a__functor}{00331} \textcolor{keyword}{struct }\hyperlink{structmisra1a__functor}{misra1a\_functor} : DenseFunctor<double>
00332 \{
00333     \hyperlink{structmisra1a__functor}{misra1a\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(2,14) \{\}
00334     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} m\_x[14];
00335     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} m\_y[14];
00336     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
00337     \{
00338         assert(b.size()==2);
00339         assert(fvec.size()==14);
00340         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<14; i++) \{
00341             fvec[i] = b[0]*(1.-exp(-b[1]*m\_x[i])) - m\_y[i] ;
00342         \}
00343         \textcolor{keywordflow}{return} 0;
00344     \}
00345     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
00346     \{
00347         assert(b.size()==2);
00348         assert(fjac.rows()==14);
00349         assert(fjac.cols()==2);
00350         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<14; i++) \{
00351             fjac(i,0) = (1.-exp(-b[1]*m\_x[i]));
00352             fjac(i,1) = (b[0]*m\_x[i]*exp(-b[1]*m\_x[i]));
00353         \}
00354         \textcolor{keywordflow}{return} 0;
00355     \}
00356 \};
00357 \textcolor{keyword}{const} \textcolor{keywordtype}{double} misra1a\_functor::m\_x[14] = \{ 77.6E0, 114.9E0, 141.1E0, 190.8E0, 239.9E0, 289.0E0, 332.8E0, 378
      .4E0, 434.8E0, 477.3E0, 536.8E0, 593.1E0, 689.1E0, 760.0E0\};
00358 \textcolor{keyword}{const} \textcolor{keywordtype}{double} misra1a\_functor::m\_y[14] = \{ 10.07E0, 14.73E0, 17.94E0, 23.93E0, 29.61E0, 35.18E0, 40.02E0, 44
      .82E0, 50.76E0, 55.05E0, 61.01E0, 66.40E0, 75.47E0, 81.78E0\};
00359 
00360 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/misra1a.shtml}
00361 \textcolor{keywordtype}{void} testNistMisra1a(\textcolor{keywordtype}{void})
00362 \{
00363   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=2;
00364   \textcolor{keywordtype}{int} info;
00365 
00366   VectorXd x(n);
00367 
00368   \textcolor{comment}{/*}
00369 \textcolor{comment}{   * First try}
00370 \textcolor{comment}{   */}
00371   x<< 500., 0.0001;
00372   \textcolor{comment}{// do the computation}
00373   \hyperlink{structmisra1a__functor}{misra1a\_functor} functor;
00374   LevenbergMarquardt<misra1a\_functor> lm(functor);
00375   info = lm.minimize(x);
00376 
00377   \textcolor{comment}{// check return value}
00378   VERIFY\_IS\_EQUAL(info, 1);
00379   VERIFY\_IS\_EQUAL(lm.nfev(), 19);
00380   VERIFY\_IS\_EQUAL(lm.njev(), 15);
00381   \textcolor{comment}{// check norm^2}
00382   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 1.2455138894E-01);
00383   \textcolor{comment}{// check x}
00384   VERIFY\_IS\_APPROX(x[0], 2.3894212918E+02);
00385   VERIFY\_IS\_APPROX(x[1], 5.5015643181E-04);
00386 
00387   \textcolor{comment}{/*}
00388 \textcolor{comment}{   * Second try}
00389 \textcolor{comment}{   */}
00390   x<< 250., 0.0005;
00391   \textcolor{comment}{// do the computation}
00392   info = lm.minimize(x);
00393 
00394   \textcolor{comment}{// check return value}
00395   VERIFY\_IS\_EQUAL(info, 1);
00396   VERIFY\_IS\_EQUAL(lm.nfev(), 5);
00397   VERIFY\_IS\_EQUAL(lm.njev(), 4);
00398   \textcolor{comment}{// check norm^2}
00399   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 1.2455138894E-01);
00400   \textcolor{comment}{// check x}
00401   VERIFY\_IS\_APPROX(x[0], 2.3894212918E+02);
00402   VERIFY\_IS\_APPROX(x[1], 5.5015643181E-04);
00403 \}
00404 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l00405}\hyperlink{structhahn1__functor}{00405} \textcolor{keyword}{struct }\hyperlink{structhahn1__functor}{hahn1\_functor} : DenseFunctor<double>
00406 \{
00407     \hyperlink{structhahn1__functor}{hahn1\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(7,236) \{\}
00408     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} m\_x[236];
00409     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
00410     \{
00411         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} m\_y[236] = \{ .591E0 , 1.547E0 , 2.902E0 , 2.894E0 , 4.703E0 , 6.307E0 , 7.03E0 
       , 7.898E0 , 9.470E0 , 9.484E0 , 10.072E0 , 10.163E0 , 11.615E0 , 12.005E0 , 12.478E0 , 12.982E0 , 12.970E0 
      , 13.926E0 , 14.452E0 , 14.404E0 , 15.190E0 , 15.550E0 , 15.528E0 , 15.499E0 , 16.131E0 , 16.438E0 , 16.387
      E0 , 16.549E0 , 16.872E0 , 16.830E0 , 16.926E0 , 16.907E0 , 16.966E0 , 17.060E0 , 17.122E0 , 17.311E0 , 17.35
      5E0 , 17.668E0 , 17.767E0 , 17.803E0 , 17.765E0 , 17.768E0 , 17.736E0 , 17.858E0 , 17.877E0 , 17.912E0 , 18.
      046E0 , 18.085E0 , 18.291E0 , 18.357E0 , 18.426E0 , 18.584E0 , 18.610E0 , 18.870E0 , 18.795E0 , 19.111E0 , .
      367E0 , .796E0 , 0.892E0 , 1.903E0 , 2.150E0 , 3.697E0 , 5.870E0 , 6.421E0 , 7.422E0 , 9.944E0 , 11.023E0 , 
      11.87E0  , 12.786E0 , 14.067E0 , 13.974E0 , 14.462E0 , 14.464E0 , 15.381E0 , 15.483E0 , 15.59E0  , 16.075E0 
      , 16.347E0 , 16.181E0 , 16.915E0 , 17.003E0 , 16.978E0 , 17.756E0 , 17.808E0 , 17.868E0 , 18.481E0 , 18.486
      E0 , 19.090E0 , 16.062E0 , 16.337E0 , 16.345E0 ,
00412         16.388E0 , 17.159E0 , 17.116E0 , 17.164E0 , 17.123E0 , 17.979E0 , 17.974E0 , 18.007E0 , 17.993E0 , 
      18.523E0 , 18.669E0 , 18.617E0 , 19.371E0 , 19.330E0 , 0.080E0 , 0.248E0 , 1.089E0 , 1.418E0 , 2.278E0 , 3.6
      24E0 , 4.574E0 , 5.556E0 , 7.267E0 , 7.695E0 , 9.136E0 , 9.959E0 , 9.957E0 , 11.600E0 , 13.138E0 , 13.564E0 
      , 13.871E0 , 13.994E0 , 14.947E0 , 15.473E0 , 15.379E0 , 15.455E0 , 15.908E0 , 16.114E0 , 17.071E0 , 17.135
      E0 , 17.282E0 , 17.368E0 , 17.483E0 , 17.764E0 , 18.185E0 , 18.271E0 , 18.236E0 , 18.237E0 , 18.523E0 , 18.62
      7E0 , 18.665E0 , 19.086E0 , 0.214E0 , 0.943E0 , 1.429E0 , 2.241E0 , 2.951E0 , 3.782E0 , 4.757E0 , 5.602E0 , 
      7.169E0 , 8.920E0 , 10.055E0 , 12.035E0 , 12.861E0 , 13.436E0 , 14.167E0 , 14.755E0 , 15.168E0 , 15.651E0 , 
      15.746E0 , 16.216E0 , 16.445E0 , 16.965E0 , 17.121E0 , 17.206E0 , 17.250E0 , 17.339E0 , 17.793E0 , 18.123E0 
      , 18.49E0  , 18.566E0 , 18.645E0 , 18.706E0 , 18.924E0 , 19.1E0   , 0.375E0 , 0.471E0 , 1.504E0 , 2.204E0 , 
      2.813E0 , 4.765E0 , 9.835E0 , 10.040E0 , 11.946E0 , 
00413 12.596E0 , 
00414 13.303E0 , 13.922E0 , 14.440E0 , 14.951E0 , 15.627E0 , 15.639E0 , 15.814E0 , 16.315E0 , 16.334E0 , 16.430E0
       , 16.423E0 , 17.024E0 , 17.009E0 , 17.165E0 , 17.134E0 , 17.349E0 , 17.576E0 , 17.848E0 , 18.090E0 , 18.276
      E0 , 18.404E0 , 18.519E0 , 19.133E0 , 19.074E0 , 19.239E0 , 19.280E0 , 19.101E0 , 19.398E0 , 19.252E0 , 19.8
      9E0  , 20.007E0 , 19.929E0 , 19.268E0 , 19.324E0 , 20.049E0 , 20.107E0 , 20.062E0 , 20.065E0 , 19.286E0 , 19
      .972E0 , 20.088E0 , 20.743E0 , 20.83E0  , 20.935E0 , 21.035E0 , 20.93E0  , 21.074E0 , 21.085E0 , 20.935E0 \};
00415 
00416         \textcolor{comment}{//        int called=0; printf("call hahn1\_functor with  iflag=%d, called=%d\(\backslash\)n", iflag, called); if
       (iflag==1) called++;}
00417 
00418         assert(b.size()==7);
00419         assert(fvec.size()==236);
00420         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<236; i++) \{
00421             \textcolor{keywordtype}{double} x=m\_x[i], xx=x*x, xxx=xx*x;
00422             fvec[i] = (b[0]+b[1]*x+b[2]*xx+b[3]*xxx) / (1.+b[4]*x+b[5]*xx+b[6]*xxx) - m\_y[i];
00423         \}
00424         \textcolor{keywordflow}{return} 0;
00425     \}
00426 
00427     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
00428     \{
00429         assert(b.size()==7);
00430         assert(fjac.rows()==236);
00431         assert(fjac.cols()==7);
00432         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<236; i++) \{
00433             \textcolor{keywordtype}{double} x=m\_x[i], xx=x*x, xxx=xx*x;
00434             \textcolor{keywordtype}{double} fact = 1./(1.+b[4]*x+b[5]*xx+b[6]*xxx);
00435             fjac(i,0) = 1.*fact;
00436             fjac(i,1) = x*fact;
00437             fjac(i,2) = xx*fact;
00438             fjac(i,3) = xxx*fact;
00439             fact = - (b[0]+b[1]*x+b[2]*xx+b[3]*xxx) * fact * fact;
00440             fjac(i,4) = x*fact;
00441             fjac(i,5) = xx*fact;
00442             fjac(i,6) = xxx*fact;
00443         \}
00444         \textcolor{keywordflow}{return} 0;
00445     \}
00446 \};
00447 \textcolor{keyword}{const} \textcolor{keywordtype}{double} hahn1\_functor::m\_x[236] = \{ 24.41E0 , 34.82E0 , 44.09E0 , 45.07E0 , 54.98E0 , 65.51E0 , 70.53
      E0 , 75.70E0 , 89.57E0 , 91.14E0 , 96.40E0 , 97.19E0 , 114.26E0 , 120.25E0 , 127.08E0 , 133.55E0 , 133.61E0 ,
       158.67E0 , 172.74E0 , 171.31E0 , 202.14E0 , 220.55E0 , 221.05E0 , 221.39E0 , 250.99E0 , 268.99E0 , 271.80E0
       , 271.97E0 , 321.31E0 , 321.69E0 , 330.14E0 , 333.03E0 , 333.47E0 , 340.77E0 , 345.65E0 , 373.11E0 , 373.79
      E0 , 411.82E0 , 419.51E0 , 421.59E0 , 422.02E0 , 422.47E0 , 422.61E0 , 441.75E0 , 447.41E0 , 448.7E0  , 472.
      89E0 , 476.69E0 , 522.47E0 , 522.62E0 , 524.43E0 , 546.75E0 , 549.53E0 , 575.29E0 , 576.00E0 , 625.55E0 , 20
      .15E0 , 28.78E0 , 29.57E0 , 37.41E0 , 39.12E0 , 50.24E0 , 61.38E0 , 66.25E0 , 73.42E0 , 95.52E0 , 107.32E0 ,
       122.04E0 , 134.03E0 , 163.19E0 , 163.48E0 , 175.70E0 , 179.86E0 , 211.27E0 , 217.78E0 , 219.14E0 , 262.52E0
       , 268.01E0 , 268.62E0 , 336.25E0 , 337.23E0 , 339.33E0 , 427.38E0 , 428.58E0 , 432.68E0 , 528.99E0 , 531.08
      E0 , 628.34E0 , 253.24E0 , 273.13E0 , 273.66E0 ,
00448 282.10E0 , 346.62E0 , 347.19E0 , 348.78E0 , 351.18E0 , 450.10E0 , 450.35E0 , 451.92E0 , 455.56E0 , 552.22E0
       , 553.56E0 , 555.74E0 , 652.59E0 , 656.20E0 , 14.13E0 , 20.41E0 , 31.30E0 , 33.84E0 , 39.70E0 , 48.83E0 , 
      54.50E0 , 60.41E0 , 72.77E0 , 75.25E0 , 86.84E0 , 94.88E0 , 96.40E0 , 117.37E0 , 139.08E0 , 147.73E0 , 158.63
      E0 , 161.84E0 , 192.11E0 , 206.76E0 , 209.07E0 , 213.32E0 , 226.44E0 , 237.12E0 , 330.90E0 , 358.72E0 , 370.
      77E0 , 372.72E0 , 396.24E0 , 416.59E0 , 484.02E0 , 495.47E0 , 514.78E0 , 515.65E0 , 519.47E0 , 544.47E0 , 
      560.11E0 , 620.77E0 , 18.97E0 , 28.93E0 , 33.91E0 , 40.03E0 , 44.66E0 , 49.87E0 , 55.16E0 , 60.90E0 , 72.08E0 
      , 85.15E0 , 97.06E0 , 119.63E0 , 133.27E0 , 143.84E0 , 161.91E0 , 180.67E0 , 198.44E0 , 226.86E0 , 229.65E0 
      , 258.27E0 , 273.77E0 , 339.15E0 , 350.13E0 , 362.75E0 , 371.03E0 , 393.32E0 , 448.53E0 , 473.78E0 , 511.12
      E0 , 524.70E0 , 548.75E0 , 551.64E0 , 574.02E0 , 623.86E0 , 21.46E0 , 24.33E0 , 33.43E0 , 39.22E0 , 44.18E0 ,
       55.02E0 , 94.33E0 , 96.44E0 , 118.82E0 , 128.48E0 ,
00449 141.94E0 , 156.92E0 , 171.65E0 , 190.00E0 , 223.26E0 , 223.88E0 , 231.50E0 , 265.05E0 , 269.44E0 , 271.78E0
       , 273.46E0 , 334.61E0 , 339.79E0 , 349.52E0 , 358.18E0 , 377.98E0 , 394.77E0 , 429.66E0 , 468.22E0 , 487.27
      E0 , 519.54E0 , 523.03E0 , 612.99E0 , 638.59E0 , 641.36E0 , 622.05E0 , 631.50E0 , 663.97E0 , 646.9E0  , 748.
      29E0 , 749.21E0 , 750.14E0 , 647.04E0 , 646.89E0 , 746.9E0  , 748.43E0 , 747.35E0 , 749.27E0 , 647.61E0 , 
      747.78E0 , 750.51E0 , 851.37E0 , 845.97E0 , 847.54E0 , 849.93E0 , 851.61E0 , 849.75E0 , 850.98E0 , 848.23E0\};
00450 
00451 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/hahn1.shtml}
00452 \textcolor{keywordtype}{void} testNistHahn1(\textcolor{keywordtype}{void})
00453 \{
00454   \textcolor{keyword}{const} \textcolor{keywordtype}{int}  n=7;
00455   \textcolor{keywordtype}{int} info;
00456 
00457   VectorXd x(n);
00458 
00459   \textcolor{comment}{/*}
00460 \textcolor{comment}{   * First try}
00461 \textcolor{comment}{   */}
00462   x<< 10., -1., .05, -.00001, -.05, .001, -.000001;
00463   \textcolor{comment}{// do the computation}
00464   \hyperlink{structhahn1__functor}{hahn1\_functor} functor;
00465   LevenbergMarquardt<hahn1\_functor> lm(functor);
00466   info = lm.minimize(x);
00467 
00468   \textcolor{comment}{// check return value}
00469   VERIFY\_IS\_EQUAL(info, 1);
00470   VERIFY\_IS\_EQUAL(lm.nfev(), 11);
00471   VERIFY\_IS\_EQUAL(lm.njev(), 10);
00472   \textcolor{comment}{// check norm^2}
00473   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 1.5324382854E+00);
00474   \textcolor{comment}{// check x}
00475   VERIFY\_IS\_APPROX(x[0], 1.0776351733E+00);
00476   VERIFY\_IS\_APPROX(x[1],-1.2269296921E-01);
00477   VERIFY\_IS\_APPROX(x[2], 4.0863750610E-03);
00478   VERIFY\_IS\_APPROX(x[3],-1.426264e-06); \textcolor{comment}{// shoulde be : -1.4262662514E-06}
00479   VERIFY\_IS\_APPROX(x[4],-5.7609940901E-03);
00480   VERIFY\_IS\_APPROX(x[5], 2.4053735503E-04);
00481   VERIFY\_IS\_APPROX(x[6],-1.2314450199E-07);
00482 
00483   \textcolor{comment}{/*}
00484 \textcolor{comment}{   * Second try}
00485 \textcolor{comment}{   */}
00486   x<< .1, -.1, .005, -.000001, -.005, .0001, -.0000001;
00487   \textcolor{comment}{// do the computation}
00488   info = lm.minimize(x);
00489 
00490   \textcolor{comment}{// check return value}
00491   VERIFY\_IS\_EQUAL(info, 1);
00492 \textcolor{comment}{//   VERIFY\_IS\_EQUAL(lm.nfev(), 11);}
00493   VERIFY\_IS\_EQUAL(lm.njev(), 10);
00494   \textcolor{comment}{// check norm^2}
00495   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 1.5324382854E+00);
00496   \textcolor{comment}{// check x}
00497   VERIFY\_IS\_APPROX(x[0], 1.077640); \textcolor{comment}{// should be :  1.0776351733E+00}
00498   VERIFY\_IS\_APPROX(x[1], -0.1226933); \textcolor{comment}{// should be : -1.2269296921E-01}
00499   VERIFY\_IS\_APPROX(x[2], 0.004086383); \textcolor{comment}{// should be : 4.0863750610E-03}
00500   VERIFY\_IS\_APPROX(x[3], -1.426277e-06); \textcolor{comment}{// shoulde be : -1.4262662514E-06}
00501   VERIFY\_IS\_APPROX(x[4],-5.7609940901E-03);
00502   VERIFY\_IS\_APPROX(x[5], 0.00024053772); \textcolor{comment}{// should be : 2.4053735503E-04}
00503   VERIFY\_IS\_APPROX(x[6], -1.231450e-07); \textcolor{comment}{// should be : -1.2314450199E-07}
00504 
00505 \}
00506 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l00507}\hyperlink{structmisra1d__functor}{00507} \textcolor{keyword}{struct }\hyperlink{structmisra1d__functor}{misra1d\_functor} : DenseFunctor<double>
00508 \{
00509     \hyperlink{structmisra1d__functor}{misra1d\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(2,14) \{\}
00510     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} x[14];
00511     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} y[14];
00512     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
00513     \{
00514         assert(b.size()==2);
00515         assert(fvec.size()==14);
00516         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<14; i++) \{
00517             fvec[i] = b[0]*b[1]*x[i]/(1.+b[1]*x[i]) - y[i];
00518         \}
00519         \textcolor{keywordflow}{return} 0;
00520     \}
00521     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
00522     \{
00523         assert(b.size()==2);
00524         assert(fjac.rows()==14);
00525         assert(fjac.cols()==2);
00526         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<14; i++) \{
00527             \textcolor{keywordtype}{double} den = 1.+b[1]*x[i];
00528             fjac(i,0) = b[1]*x[i] / den;
00529             fjac(i,1) = b[0]*x[i]*(den-b[1]*x[i])/den/den;
00530         \}
00531         \textcolor{keywordflow}{return} 0;
00532     \}
00533 \};
00534 \textcolor{keyword}{const} \textcolor{keywordtype}{double} misra1d\_functor::x[14] = \{ 77.6E0, 114.9E0, 141.1E0, 190.8E0, 239.9E0, 289.0E0, 332.8E0, 378.4
      E0, 434.8E0, 477.3E0, 536.8E0, 593.1E0, 689.1E0, 760.0E0\};
00535 \textcolor{keyword}{const} \textcolor{keywordtype}{double} misra1d\_functor::y[14] = \{ 10.07E0, 14.73E0, 17.94E0, 23.93E0, 29.61E0, 35.18E0, 40.02E0, 44.8
      2E0, 50.76E0, 55.05E0, 61.01E0, 66.40E0, 75.47E0, 81.78E0\};
00536 
00537 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/misra1d.shtml}
00538 \textcolor{keywordtype}{void} testNistMisra1d(\textcolor{keywordtype}{void})
00539 \{
00540   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=2;
00541   \textcolor{keywordtype}{int} info;
00542 
00543   VectorXd x(n);
00544 
00545   \textcolor{comment}{/*}
00546 \textcolor{comment}{   * First try}
00547 \textcolor{comment}{   */}
00548   x<< 500., 0.0001;
00549   \textcolor{comment}{// do the computation}
00550   \hyperlink{structmisra1d__functor}{misra1d\_functor} functor;
00551   LevenbergMarquardt<misra1d\_functor> lm(functor);
00552   info = lm.minimize(x);
00553 
00554   \textcolor{comment}{// check return value}
00555   VERIFY\_IS\_EQUAL(info, 1);
00556   VERIFY\_IS\_EQUAL(lm.nfev(), 9);
00557   VERIFY\_IS\_EQUAL(lm.njev(), 7);
00558   \textcolor{comment}{// check norm^2}
00559   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 5.6419295283E-02);
00560   \textcolor{comment}{// check x}
00561   VERIFY\_IS\_APPROX(x[0], 4.3736970754E+02);
00562   VERIFY\_IS\_APPROX(x[1], 3.0227324449E-04);
00563 
00564   \textcolor{comment}{/*}
00565 \textcolor{comment}{   * Second try}
00566 \textcolor{comment}{   */}
00567   x<< 450., 0.0003;
00568   \textcolor{comment}{// do the computation}
00569   info = lm.minimize(x);
00570 
00571   \textcolor{comment}{// check return value}
00572   VERIFY\_IS\_EQUAL(info, 1);
00573   VERIFY\_IS\_EQUAL(lm.nfev(), 4);
00574   VERIFY\_IS\_EQUAL(lm.njev(), 3);
00575   \textcolor{comment}{// check norm^2}
00576   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 5.6419295283E-02);
00577   \textcolor{comment}{// check x}
00578   VERIFY\_IS\_APPROX(x[0], 4.3736970754E+02);
00579   VERIFY\_IS\_APPROX(x[1], 3.0227324449E-04);
00580 \}
00581 
00582 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l00583}\hyperlink{structlanczos1__functor}{00583} \textcolor{keyword}{struct }\hyperlink{structlanczos1__functor}{lanczos1\_functor} : DenseFunctor<double>
00584 \{
00585     \hyperlink{structlanczos1__functor}{lanczos1\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(6,24) \{\}
00586     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} x[24];
00587     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} y[24];
00588     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
00589     \{
00590         assert(b.size()==6);
00591         assert(fvec.size()==24);
00592         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<24; i++)
00593             fvec[i] = b[0]*exp(-b[1]*x[i]) + b[2]*exp(-b[3]*x[i]) + b[4]*exp(-b[5]*x[i])  - y[i];
00594         \textcolor{keywordflow}{return} 0;
00595     \}
00596     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
00597     \{
00598         assert(b.size()==6);
00599         assert(fjac.rows()==24);
00600         assert(fjac.cols()==6);
00601         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<24; i++) \{
00602             fjac(i,0) = exp(-b[1]*x[i]);
00603             fjac(i,1) = -b[0]*x[i]*exp(-b[1]*x[i]);
00604             fjac(i,2) = exp(-b[3]*x[i]);
00605             fjac(i,3) = -b[2]*x[i]*exp(-b[3]*x[i]);
00606             fjac(i,4) = exp(-b[5]*x[i]);
00607             fjac(i,5) = -b[4]*x[i]*exp(-b[5]*x[i]);
00608         \}
00609         \textcolor{keywordflow}{return} 0;
00610     \}
00611 \};
00612 \textcolor{keyword}{const} \textcolor{keywordtype}{double} lanczos1\_functor::x[24] = \{ 0.000000000000E+00, 5.000000000000E-02, 1.000000000000E-01, 1.5000
      00000000E-01, 2.000000000000E-01, 2.500000000000E-01, 3.000000000000E-01, 3.500000000000E-01, 4.000000000000
      E-01, 4.500000000000E-01, 5.000000000000E-01, 5.500000000000E-01, 6.000000000000E-01, 6.500000000000E-01, 7.
      000000000000E-01, 7.500000000000E-01, 8.000000000000E-01, 8.500000000000E-01, 9.000000000000E-01, 9.50000000
      0000E-01, 1.000000000000E+00, 1.050000000000E+00, 1.100000000000E+00, 1.150000000000E+00 \};
00613 \textcolor{keyword}{const} \textcolor{keywordtype}{double} lanczos1\_functor::y[24] = \{ 2.513400000000E+00 ,2.044333373291E+00 ,1.668404436564E+00 ,1.3664
      18021208E+00 ,1.123232487372E+00 ,9.268897180037E-01 ,7.679338563728E-01 ,6.388775523106E-01 ,5.337835317402
      E-01 ,4.479363617347E-01 ,3.775847884350E-01 ,3.197393199326E-01 ,2.720130773746E-01 ,2.324965529032E-01 ,1.
      996589546065E-01 ,1.722704126914E-01 ,1.493405660168E-01 ,1.300700206922E-01 ,1.138119324644E-01 ,1.00041558
      7559E-01 ,8.833209084540E-02 ,7.833544019350E-02 ,6.976693743449E-02 ,6.239312536719E-02 \};
00614 
00615 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/lanczos1.shtml}
00616 \textcolor{keywordtype}{void} testNistLanczos1(\textcolor{keywordtype}{void})
00617 \{
00618   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=6;
00619   LevenbergMarquardtSpace::Status info;
00620 
00621   VectorXd x(n);
00622 
00623   \textcolor{comment}{/*}
00624 \textcolor{comment}{   * First try}
00625 \textcolor{comment}{   */}
00626   x<< 1.2, 0.3, 5.6, 5.5, 6.5, 7.6;
00627   \textcolor{comment}{// do the computation}
00628   \hyperlink{structlanczos1__functor}{lanczos1\_functor} functor;
00629   LevenbergMarquardt<lanczos1\_functor> lm(functor);
00630   info = lm.minimize(x);
00631 
00632   \textcolor{comment}{// check return value}
00633   VERIFY\_IS\_EQUAL(info, LevenbergMarquardtSpace::RelativeErrorTooSmall);
00634   VERIFY\_IS\_EQUAL(lm.nfev(), 79);
00635   VERIFY\_IS\_EQUAL(lm.njev(), 72);
00636   \textcolor{comment}{// check norm^2}
00637   VERIFY(lm.fvec().squaredNorm() <= 1.4307867721E-25);
00638   \textcolor{comment}{// check x}
00639   VERIFY\_IS\_APPROX(x[0], 9.5100000027E-02);
00640   VERIFY\_IS\_APPROX(x[1], 1.0000000001E+00);
00641   VERIFY\_IS\_APPROX(x[2], 8.6070000013E-01);
00642   VERIFY\_IS\_APPROX(x[3], 3.0000000002E+00);
00643   VERIFY\_IS\_APPROX(x[4], 1.5575999998E+00);
00644   VERIFY\_IS\_APPROX(x[5], 5.0000000001E+00);
00645 
00646   \textcolor{comment}{/*}
00647 \textcolor{comment}{   * Second try}
00648 \textcolor{comment}{   */}
00649   x<< 0.5, 0.7, 3.6, 4.2, 4., 6.3;
00650   \textcolor{comment}{// do the computation}
00651   info = lm.minimize(x);
00652 
00653   \textcolor{comment}{// check return value}
00654   VERIFY\_IS\_EQUAL(info, LevenbergMarquardtSpace::RelativeErrorTooSmall);
00655   VERIFY\_IS\_EQUAL(lm.nfev(), 9);
00656   VERIFY\_IS\_EQUAL(lm.njev(), 8);
00657   \textcolor{comment}{// check norm^2}
00658   VERIFY(lm.fvec().squaredNorm() <= 1.4307867721E-25);
00659   \textcolor{comment}{// check x}
00660   VERIFY\_IS\_APPROX(x[0], 9.5100000027E-02);
00661   VERIFY\_IS\_APPROX(x[1], 1.0000000001E+00);
00662   VERIFY\_IS\_APPROX(x[2], 8.6070000013E-01);
00663   VERIFY\_IS\_APPROX(x[3], 3.0000000002E+00);
00664   VERIFY\_IS\_APPROX(x[4], 1.5575999998E+00);
00665   VERIFY\_IS\_APPROX(x[5], 5.0000000001E+00);
00666 
00667 \}
00668 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l00669}\hyperlink{structrat42__functor}{00669} \textcolor{keyword}{struct }\hyperlink{structrat42__functor}{rat42\_functor} : DenseFunctor<double>
00670 \{
00671     \hyperlink{structrat42__functor}{rat42\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(3,9) \{\}
00672     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} x[9];
00673     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} y[9];
00674     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
00675     \{
00676         assert(b.size()==3);
00677         assert(fvec.size()==9);
00678         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<9; i++) \{
00679             fvec[i] = b[0] / (1.+exp(b[1]-b[2]*x[i])) - y[i];
00680         \}
00681         \textcolor{keywordflow}{return} 0;
00682     \}
00683 
00684     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
00685     \{
00686         assert(b.size()==3);
00687         assert(fjac.rows()==9);
00688         assert(fjac.cols()==3);
00689         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<9; i++) \{
00690             \textcolor{keywordtype}{double} e = exp(b[1]-b[2]*x[i]);
00691             fjac(i,0) = 1./(1.+e);
00692             fjac(i,1) = -b[0]*e/(1.+e)/(1.+e);
00693             fjac(i,2) = +b[0]*e*x[i]/(1.+e)/(1.+e);
00694         \}
00695         \textcolor{keywordflow}{return} 0;
00696     \}
00697 \};
00698 \textcolor{keyword}{const} \textcolor{keywordtype}{double} rat42\_functor::x[9] = \{ 9.000E0, 14.000E0, 21.000E0, 28.000E0, 42.000E0, 57.000E0, 63.000E0, 
      70.000E0, 79.000E0 \};
00699 \textcolor{keyword}{const} \textcolor{keywordtype}{double} rat42\_functor::y[9] = \{ 8.930E0 ,10.800E0 ,18.590E0 ,22.330E0 ,39.350E0 ,56.110E0 ,61.730E0 ,
      64.620E0 ,67.080E0 \};
00700 
00701 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/ratkowsky2.shtml}
00702 \textcolor{keywordtype}{void} testNistRat42(\textcolor{keywordtype}{void})
00703 \{
00704   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=3;
00705   LevenbergMarquardtSpace::Status info;
00706 
00707   VectorXd x(n);
00708 
00709   \textcolor{comment}{/*}
00710 \textcolor{comment}{   * First try}
00711 \textcolor{comment}{   */}
00712   x<< 100., 1., 0.1;
00713   \textcolor{comment}{// do the computation}
00714   \hyperlink{structrat42__functor}{rat42\_functor} functor;
00715   LevenbergMarquardt<rat42\_functor> lm(functor);
00716   info = lm.minimize(x);
00717 
00718   \textcolor{comment}{// check return value}
00719   VERIFY\_IS\_EQUAL(info, LevenbergMarquardtSpace::RelativeReductionTooSmall);
00720   VERIFY\_IS\_EQUAL(lm.nfev(), 10);
00721   VERIFY\_IS\_EQUAL(lm.njev(), 8);
00722   \textcolor{comment}{// check norm^2}
00723   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 8.0565229338E+00);
00724   \textcolor{comment}{// check x}
00725   VERIFY\_IS\_APPROX(x[0], 7.2462237576E+01);
00726   VERIFY\_IS\_APPROX(x[1], 2.6180768402E+00);
00727   VERIFY\_IS\_APPROX(x[2], 6.7359200066E-02);
00728 
00729   \textcolor{comment}{/*}
00730 \textcolor{comment}{   * Second try}
00731 \textcolor{comment}{   */}
00732   x<< 75., 2.5, 0.07;
00733   \textcolor{comment}{// do the computation}
00734   info = lm.minimize(x);
00735 
00736   \textcolor{comment}{// check return value}
00737   VERIFY\_IS\_EQUAL(info, LevenbergMarquardtSpace::RelativeReductionTooSmall);
00738   VERIFY\_IS\_EQUAL(lm.nfev(), 6);
00739   VERIFY\_IS\_EQUAL(lm.njev(), 5);
00740   \textcolor{comment}{// check norm^2}
00741   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 8.0565229338E+00);
00742   \textcolor{comment}{// check x}
00743   VERIFY\_IS\_APPROX(x[0], 7.2462237576E+01);
00744   VERIFY\_IS\_APPROX(x[1], 2.6180768402E+00);
00745   VERIFY\_IS\_APPROX(x[2], 6.7359200066E-02);
00746 \}
00747 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l00748}\hyperlink{struct_m_g_h10__functor}{00748} \textcolor{keyword}{struct }\hyperlink{struct_m_g_h10__functor}{MGH10\_functor} : DenseFunctor<double>
00749 \{
00750     \hyperlink{struct_m_g_h10__functor}{MGH10\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(3,16) \{\}
00751     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} x[16];
00752     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} y[16];
00753     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
00754     \{
00755         assert(b.size()==3);
00756         assert(fvec.size()==16);
00757         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<16; i++)
00758             fvec[i] =  b[0] * exp(b[1]/(x[i]+b[2])) - y[i];
00759         \textcolor{keywordflow}{return} 0;
00760     \}
00761     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
00762     \{
00763         assert(b.size()==3);
00764         assert(fjac.rows()==16);
00765         assert(fjac.cols()==3);
00766         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<16; i++) \{
00767             \textcolor{keywordtype}{double} factor = 1./(x[i]+b[2]);
00768             \textcolor{keywordtype}{double} e = exp(b[1]*factor);
00769             fjac(i,0) = e;
00770             fjac(i,1) = b[0]*factor*e;
00771             fjac(i,2) = -b[1]*b[0]*factor*factor*e;
00772         \}
00773         \textcolor{keywordflow}{return} 0;
00774     \}
00775 \};
00776 \textcolor{keyword}{const} \textcolor{keywordtype}{double} MGH10\_functor::x[16] = \{ 5.000000E+01, 5.500000E+01, 6.000000E+01, 6.500000E+01, 7.000000E+01,
       7.500000E+01, 8.000000E+01, 8.500000E+01, 9.000000E+01, 9.500000E+01, 1.000000E+02, 1.050000E+02, 1.100000E
      +02, 1.150000E+02, 1.200000E+02, 1.250000E+02 \};
00777 \textcolor{keyword}{const} \textcolor{keywordtype}{double} MGH10\_functor::y[16] = \{ 3.478000E+04, 2.861000E+04, 2.365000E+04, 1.963000E+04, 1.637000E+04,
       1.372000E+04, 1.154000E+04, 9.744000E+03, 8.261000E+03, 7.030000E+03, 6.005000E+03, 5.147000E+03, 4.427000E
      +03, 3.820000E+03, 3.307000E+03, 2.872000E+03 \};
00778 
00779 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/mgh10.shtml}
00780 \textcolor{keywordtype}{void} testNistMGH10(\textcolor{keywordtype}{void})
00781 \{
00782   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=3;
00783   LevenbergMarquardtSpace::Status info;
00784 
00785   VectorXd x(n);
00786 
00787   \textcolor{comment}{/*}
00788 \textcolor{comment}{   * First try}
00789 \textcolor{comment}{   */}
00790   x<< 2., 400000., 25000.;
00791   \textcolor{comment}{// do the computation}
00792   \hyperlink{struct_m_g_h10__functor}{MGH10\_functor} functor;
00793   LevenbergMarquardt<MGH10\_functor> lm(functor);
00794   info = lm.minimize(x);
00795   ++g\_test\_level;
00796   VERIFY\_IS\_EQUAL(info, LevenbergMarquardtSpace::RelativeReductionTooSmall);
00797   --g\_test\_level;
00798   \textcolor{comment}{// was: VERIFY\_IS\_EQUAL(info, 1);}
00799 
00800   \textcolor{comment}{// check norm^2}
00801   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 8.7945855171E+01);
00802   \textcolor{comment}{// check x}
00803   VERIFY\_IS\_APPROX(x[0], 5.6096364710E-03);
00804   VERIFY\_IS\_APPROX(x[1], 6.1813463463E+03);
00805   VERIFY\_IS\_APPROX(x[2], 3.4522363462E+02);
00806   
00807   \textcolor{comment}{// check return value}
00808 
00809   ++g\_test\_level;
00810   VERIFY\_IS\_EQUAL(lm.nfev(), 284 );
00811   VERIFY\_IS\_EQUAL(lm.njev(), 249 );
00812   --g\_test\_level;
00813   VERIFY(lm.nfev() < 284 * LM\_EVAL\_COUNT\_TOL);
00814   VERIFY(lm.njev() < 249 * LM\_EVAL\_COUNT\_TOL);
00815 
00816   \textcolor{comment}{/*}
00817 \textcolor{comment}{   * Second try}
00818 \textcolor{comment}{   */}
00819   x<< 0.02, 4000., 250.;
00820   \textcolor{comment}{// do the computation}
00821   info = lm.minimize(x);
00822   ++g\_test\_level;
00823   VERIFY\_IS\_EQUAL(info, LevenbergMarquardtSpace::RelativeReductionTooSmall);
00824   \textcolor{comment}{// was: VERIFY\_IS\_EQUAL(info, 1);}
00825   --g\_test\_level;
00826 
00827   \textcolor{comment}{// check norm^2}
00828   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 8.7945855171E+01);
00829   \textcolor{comment}{// check x}
00830   VERIFY\_IS\_APPROX(x[0], 5.6096364710E-03);
00831   VERIFY\_IS\_APPROX(x[1], 6.1813463463E+03);
00832   VERIFY\_IS\_APPROX(x[2], 3.4522363462E+02);
00833   
00834   \textcolor{comment}{// check return value}
00835   ++g\_test\_level;
00836   VERIFY\_IS\_EQUAL(lm.nfev(), 126);
00837   VERIFY\_IS\_EQUAL(lm.njev(), 116);
00838   --g\_test\_level;
00839   VERIFY(lm.nfev() < 126 * LM\_EVAL\_COUNT\_TOL);
00840   VERIFY(lm.njev() < 116 * LM\_EVAL\_COUNT\_TOL);
00841 \}
00842 
00843 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l00844}\hyperlink{struct_box_b_o_d__functor}{00844} \textcolor{keyword}{struct }\hyperlink{struct_box_b_o_d__functor}{BoxBOD\_functor} : DenseFunctor<double>
00845 \{
00846     \hyperlink{struct_box_b_o_d__functor}{BoxBOD\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(2,6) \{\}
00847     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} x[6];
00848     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
00849     \{
00850         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} y[6] = \{ 109., 149., 149., 191., 213., 224. \};
00851         assert(b.size()==2);
00852         assert(fvec.size()==6);
00853         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<6; i++)
00854             fvec[i] =  b[0]*(1.-exp(-b[1]*x[i])) - y[i];
00855         \textcolor{keywordflow}{return} 0;
00856     \}
00857     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
00858     \{
00859         assert(b.size()==2);
00860         assert(fjac.rows()==6);
00861         assert(fjac.cols()==2);
00862         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<6; i++) \{
00863             \textcolor{keywordtype}{double} e = exp(-b[1]*x[i]);
00864             fjac(i,0) = 1.-e;
00865             fjac(i,1) = b[0]*x[i]*e;
00866         \}
00867         \textcolor{keywordflow}{return} 0;
00868     \}
00869 \};
00870 \textcolor{keyword}{const} \textcolor{keywordtype}{double} BoxBOD\_functor::x[6] = \{ 1., 2., 3., 5., 7., 10. \};
00871 
00872 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/boxbod.shtml}
00873 \textcolor{keywordtype}{void} testNistBoxBOD(\textcolor{keywordtype}{void})
00874 \{
00875   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=2;
00876   \textcolor{keywordtype}{int} info;
00877 
00878   VectorXd x(n);
00879 
00880   \textcolor{comment}{/*}
00881 \textcolor{comment}{   * First try}
00882 \textcolor{comment}{   */}
00883   x<< 1., 1.;
00884   \textcolor{comment}{// do the computation}
00885   \hyperlink{struct_box_b_o_d__functor}{BoxBOD\_functor} functor;
00886   LevenbergMarquardt<BoxBOD\_functor> lm(functor);
00887   lm.setFtol(1.E6*NumTraits<double>::epsilon());
00888   lm.setXtol(1.E6*NumTraits<double>::epsilon());
00889   lm.setFactor(10);
00890   info = lm.minimize(x);
00891 
00892   \textcolor{comment}{// check norm^2}
00893   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 1.1680088766E+03);
00894   \textcolor{comment}{// check x}
00895   VERIFY\_IS\_APPROX(x[0], 2.1380940889E+02);
00896   VERIFY\_IS\_APPROX(x[1], 5.4723748542E-01);
00897   
00898   \textcolor{comment}{// check return value}
00899   VERIFY\_IS\_EQUAL(info, 1);
00900   VERIFY(lm.nfev() < 31); \textcolor{comment}{// 31}
00901   VERIFY(lm.njev() < 25); \textcolor{comment}{// 25}
00902 
00903   \textcolor{comment}{/*}
00904 \textcolor{comment}{   * Second try}
00905 \textcolor{comment}{   */}
00906   x<< 100., 0.75;
00907   \textcolor{comment}{// do the computation}
00908   lm.resetParameters();
00909   lm.setFtol(NumTraits<double>::epsilon());
00910   lm.setXtol( NumTraits<double>::epsilon());
00911   info = lm.minimize(x);
00912 
00913   \textcolor{comment}{// check return value}
00914   VERIFY\_IS\_EQUAL(info, 1); 
00915   ++g\_test\_level;
00916   VERIFY\_IS\_EQUAL(lm.nfev(), 16 );
00917   VERIFY\_IS\_EQUAL(lm.njev(), 15 );
00918   --g\_test\_level;
00919   VERIFY(lm.nfev() < 16 * LM\_EVAL\_COUNT\_TOL);
00920   VERIFY(lm.njev() < 15 * LM\_EVAL\_COUNT\_TOL);
00921   \textcolor{comment}{// check norm^2}
00922   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 1.1680088766E+03);
00923   \textcolor{comment}{// check x}
00924   VERIFY\_IS\_APPROX(x[0], 2.1380940889E+02);
00925   VERIFY\_IS\_APPROX(x[1], 5.4723748542E-01);
00926 \}
00927 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l00928}\hyperlink{struct_m_g_h17__functor}{00928} \textcolor{keyword}{struct }\hyperlink{struct_m_g_h17__functor}{MGH17\_functor} : DenseFunctor<double>
00929 \{
00930     \hyperlink{struct_m_g_h17__functor}{MGH17\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(5,33) \{\}
00931     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} x[33];
00932     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} y[33];
00933     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
00934     \{
00935         assert(b.size()==5);
00936         assert(fvec.size()==33);
00937         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<33; i++)
00938             fvec[i] =  b[0] + b[1]*exp(-b[3]*x[i]) +  b[2]*exp(-b[4]*x[i]) - y[i];
00939         \textcolor{keywordflow}{return} 0;
00940     \}
00941     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
00942     \{
00943         assert(b.size()==5);
00944         assert(fjac.rows()==33);
00945         assert(fjac.cols()==5);
00946         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<33; i++) \{
00947             fjac(i,0) = 1.;
00948             fjac(i,1) = exp(-b[3]*x[i]);
00949             fjac(i,2) = exp(-b[4]*x[i]);
00950             fjac(i,3) = -x[i]*b[1]*exp(-b[3]*x[i]);
00951             fjac(i,4) = -x[i]*b[2]*exp(-b[4]*x[i]);
00952         \}
00953         \textcolor{keywordflow}{return} 0;
00954     \}
00955 \};
00956 \textcolor{keyword}{const} \textcolor{keywordtype}{double} MGH17\_functor::x[33] = \{ 0.000000E+00, 1.000000E+01, 2.000000E+01, 3.000000E+01, 4.000000E+01,
       5.000000E+01, 6.000000E+01, 7.000000E+01, 8.000000E+01, 9.000000E+01, 1.000000E+02, 1.100000E+02, 1.200000E
      +02, 1.300000E+02, 1.400000E+02, 1.500000E+02, 1.600000E+02, 1.700000E+02, 1.800000E+02, 1.900000E+02, 2.000
      000E+02, 2.100000E+02, 2.200000E+02, 2.300000E+02, 2.400000E+02, 2.500000E+02, 2.600000E+02, 2.700000E+02, 2
      .800000E+02, 2.900000E+02, 3.000000E+02, 3.100000E+02, 3.200000E+02 \};
00957 \textcolor{keyword}{const} \textcolor{keywordtype}{double} MGH17\_functor::y[33] = \{ 8.440000E-01, 9.080000E-01, 9.320000E-01, 9.360000E-01, 9.250000E-01,
       9.080000E-01, 8.810000E-01, 8.500000E-01, 8.180000E-01, 7.840000E-01, 7.510000E-01, 7.180000E-01, 6.850000E
      -01, 6.580000E-01, 6.280000E-01, 6.030000E-01, 5.800000E-01, 5.580000E-01, 5.380000E-01, 5.220000E-01, 5.060
      000E-01, 4.900000E-01, 4.780000E-01, 4.670000E-01, 4.570000E-01, 4.480000E-01, 4.380000E-01, 4.310000E-01, 4
      .240000E-01, 4.200000E-01, 4.140000E-01, 4.110000E-01, 4.060000E-01 \};
00958 
00959 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/mgh17.shtml}
00960 \textcolor{keywordtype}{void} testNistMGH17(\textcolor{keywordtype}{void})
00961 \{
00962   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=5;
00963   \textcolor{keywordtype}{int} info;
00964 
00965   VectorXd x(n);
00966 
00967   \textcolor{comment}{/*}
00968 \textcolor{comment}{   * First try}
00969 \textcolor{comment}{   */}
00970   x<< 50., 150., -100., 1., 2.;
00971   \textcolor{comment}{// do the computation}
00972   \hyperlink{struct_m_g_h17__functor}{MGH17\_functor} functor;
00973   LevenbergMarquardt<MGH17\_functor> lm(functor);
00974   lm.setFtol(NumTraits<double>::epsilon());
00975   lm.setXtol(NumTraits<double>::epsilon());
00976   lm.setMaxfev(1000);
00977   info = lm.minimize(x);
00978 
00979   \textcolor{comment}{// check norm^2}
00980   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 5.4648946975E-05);
00981   \textcolor{comment}{// check x}
00982   VERIFY\_IS\_APPROX(x[0], 3.7541005211E-01);
00983   VERIFY\_IS\_APPROX(x[1], 1.9358469127E+00);
00984   VERIFY\_IS\_APPROX(x[2], -1.4646871366E+00);
00985   VERIFY\_IS\_APPROX(x[3], 1.2867534640E-02);
00986   VERIFY\_IS\_APPROX(x[4], 2.2122699662E-02);
00987   
00988     \textcolor{comment}{// check return value}
00989 \textcolor{comment}{//   VERIFY\_IS\_EQUAL(info, 2);  //FIXME Use (lm.info() == Success)}
00990   VERIFY(lm.nfev() < 700 ); \textcolor{comment}{// 602}
00991   VERIFY(lm.njev() < 600 ); \textcolor{comment}{// 545}
00992 
00993   \textcolor{comment}{/*}
00994 \textcolor{comment}{   * Second try}
00995 \textcolor{comment}{   */}
00996   x<< 0.5  ,1.5  ,-1   ,0.01 ,0.02;
00997   \textcolor{comment}{// do the computation}
00998   lm.resetParameters();
00999   info = lm.minimize(x);
01000 
01001   \textcolor{comment}{// check return value}
01002   VERIFY\_IS\_EQUAL(info, 1);
01003   VERIFY\_IS\_EQUAL(lm.nfev(), 18);
01004   VERIFY\_IS\_EQUAL(lm.njev(), 15);
01005   \textcolor{comment}{// check norm^2}
01006   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 5.4648946975E-05);
01007   \textcolor{comment}{// check x}
01008   VERIFY\_IS\_APPROX(x[0], 3.7541005211E-01);
01009   VERIFY\_IS\_APPROX(x[1], 1.9358469127E+00);
01010   VERIFY\_IS\_APPROX(x[2], -1.4646871366E+00);
01011   VERIFY\_IS\_APPROX(x[3], 1.2867534640E-02);
01012   VERIFY\_IS\_APPROX(x[4], 2.2122699662E-02);
01013 \}
01014 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l01015}\hyperlink{struct_m_g_h09__functor}{01015} \textcolor{keyword}{struct }\hyperlink{struct_m_g_h09__functor}{MGH09\_functor} : DenseFunctor<double>
01016 \{
01017     \hyperlink{struct_m_g_h09__functor}{MGH09\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(4,11) \{\}
01018     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} \_x[11];
01019     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} y[11];
01020     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
01021     \{
01022         assert(b.size()==4);
01023         assert(fvec.size()==11);
01024         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<11; i++) \{
01025             \textcolor{keywordtype}{double} x = \_x[i], xx=x*x;
01026             fvec[i] = b[0]*(xx+x*b[1])/(xx+x*b[2]+b[3]) - y[i];
01027         \}
01028         \textcolor{keywordflow}{return} 0;
01029     \}
01030     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
01031     \{
01032         assert(b.size()==4);
01033         assert(fjac.rows()==11);
01034         assert(fjac.cols()==4);
01035         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<11; i++) \{
01036             \textcolor{keywordtype}{double} x = \_x[i], xx=x*x;
01037             \textcolor{keywordtype}{double} factor = 1./(xx+x*b[2]+b[3]);
01038             fjac(i,0) = (xx+x*b[1]) * factor;
01039             fjac(i,1) = b[0]*x* factor;
01040             fjac(i,2) = - b[0]*(xx+x*b[1]) * x * factor * factor;
01041             fjac(i,3) = - b[0]*(xx+x*b[1]) * factor * factor;
01042         \}
01043         \textcolor{keywordflow}{return} 0;
01044     \}
01045 \};
01046 \textcolor{keyword}{const} \textcolor{keywordtype}{double} MGH09\_functor::\_x[11] = \{ 4., 2., 1., 5.E-1 , 2.5E-01, 1.670000E-01, 1.250000E-01,  1.E-01, 8.
      330000E-02, 7.140000E-02, 6.250000E-02 \};
01047 \textcolor{keyword}{const} \textcolor{keywordtype}{double} MGH09\_functor::y[11] = \{ 1.957000E-01, 1.947000E-01, 1.735000E-01, 1.600000E-01, 8.440000E-02,
       6.270000E-02, 4.560000E-02, 3.420000E-02, 3.230000E-02, 2.350000E-02, 2.460000E-02 \};
01048 
01049 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/mgh09.shtml}
01050 \textcolor{keywordtype}{void} testNistMGH09(\textcolor{keywordtype}{void})
01051 \{
01052   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=4;
01053   \textcolor{keywordtype}{int} info;
01054 
01055   VectorXd x(n);
01056 
01057   \textcolor{comment}{/*}
01058 \textcolor{comment}{   * First try}
01059 \textcolor{comment}{   */}
01060   x<< 25., 39, 41.5, 39.;
01061   \textcolor{comment}{// do the computation}
01062   \hyperlink{struct_m_g_h09__functor}{MGH09\_functor} functor;
01063   LevenbergMarquardt<MGH09\_functor> lm(functor);
01064   lm.setMaxfev(1000);
01065   info = lm.minimize(x);
01066 
01067   \textcolor{comment}{// check norm^2}
01068   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 3.0750560385E-04);
01069   \textcolor{comment}{// check x}
01070   VERIFY\_IS\_APPROX(x[0], 0.1928077089); \textcolor{comment}{// should be 1.9280693458E-01}
01071   VERIFY\_IS\_APPROX(x[1], 0.19126423573); \textcolor{comment}{// should be 1.9128232873E-01}
01072   VERIFY\_IS\_APPROX(x[2], 0.12305309914); \textcolor{comment}{// should be 1.2305650693E-01}
01073   VERIFY\_IS\_APPROX(x[3], 0.13605395375); \textcolor{comment}{// should be 1.3606233068E-01}
01074   \textcolor{comment}{// check return value}
01075   VERIFY\_IS\_EQUAL(info, 1); 
01076   VERIFY(lm.nfev() < 510 ); \textcolor{comment}{// 490}
01077   VERIFY(lm.njev() < 400 ); \textcolor{comment}{// 376}
01078 
01079   \textcolor{comment}{/*}
01080 \textcolor{comment}{   * Second try}
01081 \textcolor{comment}{   */}
01082   x<< 0.25, 0.39, 0.415, 0.39;
01083   \textcolor{comment}{// do the computation}
01084   lm.resetParameters();
01085   info = lm.minimize(x);
01086 
01087   \textcolor{comment}{// check return value}
01088   VERIFY\_IS\_EQUAL(info, 1);
01089   VERIFY\_IS\_EQUAL(lm.nfev(), 18);
01090   VERIFY\_IS\_EQUAL(lm.njev(), 16);
01091   \textcolor{comment}{// check norm^2}
01092   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 3.0750560385E-04);
01093   \textcolor{comment}{// check x}
01094   VERIFY\_IS\_APPROX(x[0], 0.19280781); \textcolor{comment}{// should be 1.9280693458E-01}
01095   VERIFY\_IS\_APPROX(x[1], 0.19126265); \textcolor{comment}{// should be 1.9128232873E-01}
01096   VERIFY\_IS\_APPROX(x[2], 0.12305280); \textcolor{comment}{// should be 1.2305650693E-01}
01097   VERIFY\_IS\_APPROX(x[3], 0.13605322); \textcolor{comment}{// should be 1.3606233068E-01}
01098 \}
01099 
01100 
01101 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l01102}\hyperlink{struct_bennett5__functor}{01102} \textcolor{keyword}{struct }\hyperlink{struct_bennett5__functor}{Bennett5\_functor} : DenseFunctor<double>
01103 \{
01104     \hyperlink{struct_bennett5__functor}{Bennett5\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(3,154) \{\}
01105     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} x[154];
01106     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} y[154];
01107     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
01108     \{
01109         assert(b.size()==3);
01110         assert(fvec.size()==154);
01111         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<154; i++)
01112             fvec[i] = b[0]* pow(b[1]+x[i],-1./b[2]) - y[i];
01113         \textcolor{keywordflow}{return} 0;
01114     \}
01115     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
01116     \{
01117         assert(b.size()==3);
01118         assert(fjac.rows()==154);
01119         assert(fjac.cols()==3);
01120         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<154; i++) \{
01121             \textcolor{keywordtype}{double} e = pow(b[1]+x[i],-1./b[2]);
01122             fjac(i,0) = e;
01123             fjac(i,1) = - b[0]*e/b[2]/(b[1]+x[i]);
01124             fjac(i,2) = b[0]*e*\hyperlink{structlog}{log}(b[1]+x[i])/b[2]/b[2];
01125         \}
01126         \textcolor{keywordflow}{return} 0;
01127     \}
01128 \};
01129 \textcolor{keyword}{const} \textcolor{keywordtype}{double} Bennett5\_functor::x[154] = \{ 7.447168E0, 8.102586E0, 8.452547E0, 8.711278E0, 8.916774E0, 9.087
      155E0, 9.232590E0, 9.359535E0, 9.472166E0, 9.573384E0, 9.665293E0, 9.749461E0, 9.827092E0, 9.899128E0, 9.966
      321E0, 10.029280E0, 10.088510E0, 10.144430E0, 10.197380E0, 10.247670E0, 10.295560E0, 10.341250E0, 10.384950
      E0, 10.426820E0, 10.467000E0, 10.505640E0, 10.542830E0, 10.578690E0, 10.613310E0, 10.646780E0, 10.679150E0, 
      10.710520E0, 10.740920E0, 10.770440E0, 10.799100E0, 10.826970E0, 10.854080E0, 10.880470E0, 10.906190E0, 10.93
      1260E0, 10.955720E0, 10.979590E0, 11.002910E0, 11.025700E0, 11.047980E0, 11.069770E0, 11.091100E0, 11.111980
      E0, 11.132440E0, 11.152480E0, 11.172130E0, 11.191410E0, 11.210310E0, 11.228870E0, 11.247090E0, 11.264980E0, 
      11.282560E0, 11.299840E0, 11.316820E0, 11.333520E0, 11.349940E0, 11.366100E0, 11.382000E0, 11.397660E0, 11.4
      13070E0, 11.428240E0, 11.443200E0, 11.457930E0, 11.472440E0, 11.486750E0, 11.500860E0, 11.514770E0, 11.52849
      0E0, 11.542020E0, 11.555380E0, 11.568550E0,
01130 11.581560E0, 11.594420E0, 11.607121E0, 11.619640E0, 11.632000E0, 11.644210E0, 11.656280E0, 11.668200E0, 11.
      679980E0, 11.691620E0, 11.703130E0, 11.714510E0, 11.725760E0, 11.736880E0, 11.747890E0, 11.758780E0, 11.7695
      50E0, 11.780200E0, 11.790730E0, 11.801160E0, 11.811480E0, 11.821700E0, 11.831810E0, 11.841820E0, 11.851730E0
      , 11.861550E0, 11.871270E0, 11.880890E0, 11.890420E0, 11.899870E0, 11.909220E0, 11.918490E0, 11.927680E0, 11
      .936780E0, 11.945790E0, 11.954730E0, 11.963590E0, 11.972370E0, 11.981070E0, 11.989700E0, 11.998260E0, 12.006
      740E0, 12.015150E0, 12.023490E0, 12.031760E0, 12.039970E0, 12.048100E0, 12.056170E0, 12.064180E0, 12.072120
      E0, 12.080010E0, 12.087820E0, 12.095580E0, 12.103280E0, 12.110920E0, 12.118500E0, 12.126030E0, 12.133500E0, 
      12.140910E0, 12.148270E0, 12.155570E0, 12.162830E0, 12.170030E0, 12.177170E0, 12.184270E0, 12.191320E0, 12.19
      8320E0, 12.205270E0, 12.212170E0, 12.219030E0, 12.225840E0, 12.232600E0, 12.239320E0, 12.245990E0, 12.252620
      E0, 12.259200E0, 12.265750E0, 12.272240E0 \};
01131 \textcolor{keyword}{const} \textcolor{keywordtype}{double} Bennett5\_functor::y[154] = \{ -34.834702E0 ,-34.393200E0 ,-34.152901E0 ,-33.979099E0 ,-33.84590
      1E0 ,-33.732899E0 ,-33.640301E0 ,-33.559200E0 ,-33.486801E0 ,-33.423100E0 ,-33.365101E0 ,-33.313000E0 ,-33.2
      60899E0 ,-33.217400E0 ,-33.176899E0 ,-33.139198E0 ,-33.101601E0 ,-33.066799E0 ,-33.035000E0 ,-33.003101E0 ,-
      32.971298E0 ,-32.942299E0 ,-32.916302E0 ,-32.890202E0 ,-32.864101E0 ,-32.841000E0 ,-32.817799E0 ,-32.797501
      E0 ,-32.774300E0 ,-32.757000E0 ,-32.733799E0 ,-32.716400E0 ,-32.699100E0 ,-32.678799E0 ,-32.661400E0 ,-32.644
      001E0 ,-32.626701E0 ,-32.612202E0 ,-32.597698E0 ,-32.583199E0 ,-32.568699E0 ,-32.554298E0 ,-32.539799E0 ,-32
      .525299E0 ,-32.510799E0 ,-32.499199E0 ,-32.487598E0 ,-32.473202E0 ,-32.461601E0 ,-32.435501E0 ,-32.435501E0 
      ,-32.426800E0 ,-32.412300E0 ,-32.400799E0 ,-32.392101E0 ,-32.380501E0 ,-32.366001E0 ,-32.357300E0 ,-32.34859
      8E0 ,-32.339901E0 ,-32.328400E0 ,-32.319698E0 ,-32.311001E0 ,-32.299400E0 ,-32.290699E0 ,-32.282001E0 ,-32.2
      73300E0 ,-32.264599E0 ,-32.256001E0 ,-32.247299E0
01132 ,-32.238602E0 ,-32.229900E0 ,-32.224098E0 ,-32.215401E0 ,-32.203800E0 ,-32.198002E0 ,-32.189400E0 ,-32.1836
      01E0 ,-32.174900E0 ,-32.169102E0 ,-32.163300E0 ,-32.154598E0 ,-32.145901E0 ,-32.140099E0 ,-32.131401E0 ,-32.
      125599E0 ,-32.119801E0 ,-32.111198E0 ,-32.105400E0 ,-32.096699E0 ,-32.090900E0 ,-32.088001E0 ,-32.079300E0 ,
      -32.073502E0 ,-32.067699E0 ,-32.061901E0 ,-32.056099E0 ,-32.050301E0 ,-32.044498E0 ,-32.038799E0 ,-32.033001
      E0 ,-32.027199E0 ,-32.024300E0 ,-32.018501E0 ,-32.012699E0 ,-32.004002E0 ,-32.001099E0 ,-31.995300E0 ,-31.98
      9500E0 ,-31.983700E0 ,-31.977900E0 ,-31.972099E0 ,-31.969299E0 ,-31.963501E0 ,-31.957701E0 ,-31.951900E0 ,-
      31.946100E0 ,-31.940300E0 ,-31.937401E0 ,-31.931601E0 ,-31.925800E0 ,-31.922899E0 ,-31.917101E0 ,-31.911301E0
       ,-31.908400E0 ,-31.902599E0 ,-31.896900E0 ,-31.893999E0 ,-31.888201E0 ,-31.885300E0 ,-31.882401E0 ,-31.8766
      00E0 ,-31.873699E0 ,-31.867901E0 ,-31.862101E0 ,-31.859200E0 ,-31.856300E0 ,-31.850500E0 ,-31.844700E0 ,-31.
      841801E0 ,-31.838900E0 ,-31.833099E0 ,-31.830200E0 ,
01133 -31.827299E0 ,-31.821600E0 ,-31.818701E0 ,-31.812901E0 ,-31.809999E0 ,-31.807100E0 ,-31.801300E0 ,-31.79840
      1E0 ,-31.795500E0 ,-31.789700E0 ,-31.786800E0 \};
01134 
01135 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/bennett5.shtml}
01136 \textcolor{keywordtype}{void} testNistBennett5(\textcolor{keywordtype}{void})
01137 \{
01138   \textcolor{keyword}{const} \textcolor{keywordtype}{int}  n=3;
01139   \textcolor{keywordtype}{int} info;
01140 
01141   VectorXd x(n);
01142 
01143   \textcolor{comment}{/*}
01144 \textcolor{comment}{   * First try}
01145 \textcolor{comment}{   */}
01146   x<< -2000., 50., 0.8;
01147   \textcolor{comment}{// do the computation}
01148   \hyperlink{struct_bennett5__functor}{Bennett5\_functor} functor;
01149   LevenbergMarquardt<Bennett5\_functor> lm(functor);
01150   lm.setMaxfev(1000);
01151   info = lm.minimize(x);
01152 
01153   \textcolor{comment}{// check return value}
01154   VERIFY\_IS\_EQUAL(info, 1);
01155   VERIFY\_IS\_EQUAL(lm.nfev(), 758);
01156   VERIFY\_IS\_EQUAL(lm.njev(), 744);
01157   \textcolor{comment}{// check norm^2}
01158   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 5.2404744073E-04);
01159   \textcolor{comment}{// check x}
01160   VERIFY\_IS\_APPROX(x[0], -2.5235058043E+03);
01161   VERIFY\_IS\_APPROX(x[1], 4.6736564644E+01);
01162   VERIFY\_IS\_APPROX(x[2], 9.3218483193E-01);
01163   \textcolor{comment}{/*}
01164 \textcolor{comment}{   * Second try}
01165 \textcolor{comment}{   */}
01166   x<< -1500., 45., 0.85;
01167   \textcolor{comment}{// do the computation}
01168   lm.resetParameters();
01169   info = lm.minimize(x);
01170 
01171   \textcolor{comment}{// check return value}
01172   VERIFY\_IS\_EQUAL(info, 1);
01173   VERIFY\_IS\_EQUAL(lm.nfev(), 203);
01174   VERIFY\_IS\_EQUAL(lm.njev(), 192);
01175   \textcolor{comment}{// check norm^2}
01176   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 5.2404744073E-04);
01177   \textcolor{comment}{// check x}
01178   VERIFY\_IS\_APPROX(x[0], -2523.3007865); \textcolor{comment}{// should be -2.5235058043E+03}
01179   VERIFY\_IS\_APPROX(x[1], 46.735705771); \textcolor{comment}{// should be 4.6736564644E+01);}
01180   VERIFY\_IS\_APPROX(x[2], 0.93219881891); \textcolor{comment}{// should be 9.3218483193E-01);}
01181 \}
01182 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l01183}\hyperlink{structthurber__functor}{01183} \textcolor{keyword}{struct }\hyperlink{structthurber__functor}{thurber\_functor} : DenseFunctor<double>
01184 \{
01185     \hyperlink{structthurber__functor}{thurber\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(7,37) \{\}
01186     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} \_x[37];
01187     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} \_y[37];
01188     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
01189     \{
01190         \textcolor{comment}{//        int called=0; printf("call hahn1\_functor with  iflag=%d, called=%d\(\backslash\)n", iflag, called); if
       (iflag==1) called++;}
01191         assert(b.size()==7);
01192         assert(fvec.size()==37);
01193         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<37; i++) \{
01194             \textcolor{keywordtype}{double} x=\_x[i], xx=x*x, xxx=xx*x;
01195             fvec[i] = (b[0]+b[1]*x+b[2]*xx+b[3]*xxx) / (1.+b[4]*x+b[5]*xx+b[6]*xxx) - \_y[i];
01196         \}
01197         \textcolor{keywordflow}{return} 0;
01198     \}
01199     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
01200     \{
01201         assert(b.size()==7);
01202         assert(fjac.rows()==37);
01203         assert(fjac.cols()==7);
01204         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<37; i++) \{
01205             \textcolor{keywordtype}{double} x=\_x[i], xx=x*x, xxx=xx*x;
01206             \textcolor{keywordtype}{double} fact = 1./(1.+b[4]*x+b[5]*xx+b[6]*xxx);
01207             fjac(i,0) = 1.*fact;
01208             fjac(i,1) = x*fact;
01209             fjac(i,2) = xx*fact;
01210             fjac(i,3) = xxx*fact;
01211             fact = - (b[0]+b[1]*x+b[2]*xx+b[3]*xxx) * fact * fact;
01212             fjac(i,4) = x*fact;
01213             fjac(i,5) = xx*fact;
01214             fjac(i,6) = xxx*fact;
01215         \}
01216         \textcolor{keywordflow}{return} 0;
01217     \}
01218 \};
01219 \textcolor{keyword}{const} \textcolor{keywordtype}{double} thurber\_functor::\_x[37] = \{ -3.067E0, -2.981E0, -2.921E0, -2.912E0, -2.840E0, -2.797E0, -2.702
      E0, -2.699E0, -2.633E0, -2.481E0, -2.363E0, -2.322E0, -1.501E0, -1.460E0, -1.274E0, -1.212E0, -1.100E0, -1.0
      46E0, -0.915E0, -0.714E0, -0.566E0, -0.545E0, -0.400E0, -0.309E0, -0.109E0, -0.103E0, 0.010E0, 0.119E0, 0.37
      7E0, 0.790E0, 0.963E0, 1.006E0, 1.115E0, 1.572E0, 1.841E0, 2.047E0, 2.200E0 \};
01220 \textcolor{keyword}{const} \textcolor{keywordtype}{double} thurber\_functor::\_y[37] = \{ 80.574E0, 84.248E0, 87.264E0, 87.195E0, 89.076E0, 89.608E0, 89.868
      E0, 90.101E0, 92.405E0, 95.854E0, 100.696E0, 101.060E0, 401.672E0, 390.724E0, 567.534E0, 635.316E0, 733.054
      E0, 759.087E0, 894.206E0, 990.785E0, 1090.109E0, 1080.914E0, 1122.643E0, 1178.351E0, 1260.531E0, 1273.514E0, 
      1288.339E0, 1327.543E0, 1353.863E0, 1414.509E0, 1425.208E0, 1421.384E0, 1442.962E0, 1464.350E0, 1468.705E0, 
      1447.894E0, 1457.628E0\};
01221 
01222 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/thurber.shtml}
01223 \textcolor{keywordtype}{void} testNistThurber(\textcolor{keywordtype}{void})
01224 \{
01225   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=7;
01226   \textcolor{keywordtype}{int} info;
01227 
01228   VectorXd x(n);
01229 
01230   \textcolor{comment}{/*}
01231 \textcolor{comment}{   * First try}
01232 \textcolor{comment}{   */}
01233   x<< 1000 ,1000 ,400 ,40 ,0.7,0.3,0.0 ;
01234   \textcolor{comment}{// do the computation}
01235   \hyperlink{structthurber__functor}{thurber\_functor} functor;
01236   LevenbergMarquardt<thurber\_functor> lm(functor);
01237   lm.setFtol(1.E4*NumTraits<double>::epsilon());
01238   lm.setXtol(1.E4*NumTraits<double>::epsilon());
01239   info = lm.minimize(x);
01240 
01241   \textcolor{comment}{// check return value}
01242   VERIFY\_IS\_EQUAL(info, 1);
01243   VERIFY\_IS\_EQUAL(lm.nfev(), 39);
01244   VERIFY\_IS\_EQUAL(lm.njev(), 36);
01245   \textcolor{comment}{// check norm^2}
01246   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 5.6427082397E+03);
01247   \textcolor{comment}{// check x}
01248   VERIFY\_IS\_APPROX(x[0], 1.2881396800E+03);
01249   VERIFY\_IS\_APPROX(x[1], 1.4910792535E+03);
01250   VERIFY\_IS\_APPROX(x[2], 5.8323836877E+02);
01251   VERIFY\_IS\_APPROX(x[3], 7.5416644291E+01);
01252   VERIFY\_IS\_APPROX(x[4], 9.6629502864E-01);
01253   VERIFY\_IS\_APPROX(x[5], 3.9797285797E-01);
01254   VERIFY\_IS\_APPROX(x[6], 4.9727297349E-02);
01255 
01256   \textcolor{comment}{/*}
01257 \textcolor{comment}{   * Second try}
01258 \textcolor{comment}{   */}
01259   x<< 1300 ,1500 ,500  ,75   ,1    ,0.4  ,0.05  ;
01260   \textcolor{comment}{// do the computation}
01261   lm.resetParameters();
01262   lm.setFtol(1.E4*NumTraits<double>::epsilon());
01263   lm.setXtol(1.E4*NumTraits<double>::epsilon());
01264   info = lm.minimize(x);
01265 
01266   \textcolor{comment}{// check return value}
01267   VERIFY\_IS\_EQUAL(info, 1);
01268   VERIFY\_IS\_EQUAL(lm.nfev(), 29);
01269   VERIFY\_IS\_EQUAL(lm.njev(), 28);
01270   \textcolor{comment}{// check norm^2}
01271   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 5.6427082397E+03);
01272   \textcolor{comment}{// check x}
01273   VERIFY\_IS\_APPROX(x[0], 1.2881396800E+03);
01274   VERIFY\_IS\_APPROX(x[1], 1.4910792535E+03);
01275   VERIFY\_IS\_APPROX(x[2], 5.8323836877E+02);
01276   VERIFY\_IS\_APPROX(x[3], 7.5416644291E+01);
01277   VERIFY\_IS\_APPROX(x[4], 9.6629502864E-01);
01278   VERIFY\_IS\_APPROX(x[5], 3.9797285797E-01);
01279   VERIFY\_IS\_APPROX(x[6], 4.9727297349E-02);
01280 \}
01281 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l01282}\hyperlink{structrat43__functor}{01282} \textcolor{keyword}{struct }\hyperlink{structrat43__functor}{rat43\_functor} : DenseFunctor<double>
01283 \{
01284     \hyperlink{structrat43__functor}{rat43\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(4,15) \{\}
01285     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} x[15];
01286     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} y[15];
01287     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
01288     \{
01289         assert(b.size()==4);
01290         assert(fvec.size()==15);
01291         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<15; i++)
01292             fvec[i] = b[0] * pow(1.+exp(b[1]-b[2]*x[i]),-1./b[3]) - y[i];
01293         \textcolor{keywordflow}{return} 0;
01294     \}
01295     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
01296     \{
01297         assert(b.size()==4);
01298         assert(fjac.rows()==15);
01299         assert(fjac.cols()==4);
01300         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<15; i++) \{
01301             \textcolor{keywordtype}{double} e = exp(b[1]-b[2]*x[i]);
01302             \textcolor{keywordtype}{double} power = -1./b[3];
01303             fjac(i,0) = pow(1.+e, power);
01304             fjac(i,1) = power*b[0]*e*pow(1.+e, power-1.);
01305             fjac(i,2) = -power*b[0]*e*x[i]*pow(1.+e, power-1.);
01306             fjac(i,3) = b[0]*power*power*\hyperlink{structlog}{log}(1.+e)*pow(1.+e, power);
01307         \}
01308         \textcolor{keywordflow}{return} 0;
01309     \}
01310 \};
01311 \textcolor{keyword}{const} \textcolor{keywordtype}{double} rat43\_functor::x[15] = \{ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15. \};
01312 \textcolor{keyword}{const} \textcolor{keywordtype}{double} rat43\_functor::y[15] = \{ 16.08, 33.83, 65.80, 97.20, 191.55, 326.20, 386.87, 520.53, 590.03, 
      651.92, 724.93, 699.56, 689.96, 637.56, 717.41 \};
01313 
01314 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/ratkowsky3.shtml}
01315 \textcolor{keywordtype}{void} testNistRat43(\textcolor{keywordtype}{void})
01316 \{
01317   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=4;
01318   \textcolor{keywordtype}{int} info;
01319 
01320   VectorXd x(n);
01321 
01322   \textcolor{comment}{/*}
01323 \textcolor{comment}{   * First try}
01324 \textcolor{comment}{   */}
01325   x<< 100., 10., 1., 1.;
01326   \textcolor{comment}{// do the computation}
01327   \hyperlink{structrat43__functor}{rat43\_functor} functor;
01328   LevenbergMarquardt<rat43\_functor> lm(functor);
01329   lm.setFtol(1.E6*NumTraits<double>::epsilon());
01330   lm.setXtol(1.E6*NumTraits<double>::epsilon());
01331   info = lm.minimize(x);
01332 
01333   \textcolor{comment}{// check return value}
01334   VERIFY\_IS\_EQUAL(info, 1);
01335   VERIFY\_IS\_EQUAL(lm.nfev(), 27);
01336   VERIFY\_IS\_EQUAL(lm.njev(), 20);
01337   \textcolor{comment}{// check norm^2}
01338   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 8.7864049080E+03);
01339   \textcolor{comment}{// check x}
01340   VERIFY\_IS\_APPROX(x[0], 6.9964151270E+02);
01341   VERIFY\_IS\_APPROX(x[1], 5.2771253025E+00);
01342   VERIFY\_IS\_APPROX(x[2], 7.5962938329E-01);
01343   VERIFY\_IS\_APPROX(x[3], 1.2792483859E+00);
01344 
01345   \textcolor{comment}{/*}
01346 \textcolor{comment}{   * Second try}
01347 \textcolor{comment}{   */}
01348   x<< 700., 5., 0.75, 1.3;
01349   \textcolor{comment}{// do the computation}
01350   lm.resetParameters();
01351   lm.setFtol(1.E5*NumTraits<double>::epsilon());
01352   lm.setXtol(1.E5*NumTraits<double>::epsilon());
01353   info = lm.minimize(x);
01354 
01355   \textcolor{comment}{// check return value}
01356   VERIFY\_IS\_EQUAL(info, 1);
01357   VERIFY\_IS\_EQUAL(lm.nfev(), 9);
01358   VERIFY\_IS\_EQUAL(lm.njev(), 8);
01359   \textcolor{comment}{// check norm^2}
01360   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 8.7864049080E+03);
01361   \textcolor{comment}{// check x}
01362   VERIFY\_IS\_APPROX(x[0], 6.9964151270E+02);
01363   VERIFY\_IS\_APPROX(x[1], 5.2771253025E+00);
01364   VERIFY\_IS\_APPROX(x[2], 7.5962938329E-01);
01365   VERIFY\_IS\_APPROX(x[3], 1.2792483859E+00);
01366 \}
01367 
01368 
01369 
\Hypertarget{eigen_2unsupported_2test_2levenberg__marquardt_8cpp_source_l01370}\hyperlink{structeckerle4__functor}{01370} \textcolor{keyword}{struct }\hyperlink{structeckerle4__functor}{eckerle4\_functor} : DenseFunctor<double>
01371 \{
01372     \hyperlink{structeckerle4__functor}{eckerle4\_functor}(\textcolor{keywordtype}{void}) : DenseFunctor<double>(3,35) \{\}
01373     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} x[35];
01374     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} y[35];
01375     \textcolor{keywordtype}{int} operator()(\textcolor{keyword}{const} VectorXd &b, VectorXd &fvec)
01376     \{
01377         assert(b.size()==3);
01378         assert(fvec.size()==35);
01379         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<35; i++)
01380             fvec[i] = b[0]/b[1] * exp(-0.5*(x[i]-b[2])*(x[i]-b[2])/(b[1]*b[1])) - y[i];
01381         \textcolor{keywordflow}{return} 0;
01382     \}
01383     \textcolor{keywordtype}{int} df(\textcolor{keyword}{const} VectorXd &b, MatrixXd &fjac)
01384     \{
01385         assert(b.size()==3);
01386         assert(fjac.rows()==35);
01387         assert(fjac.cols()==3);
01388         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<35; i++) \{
01389             \textcolor{keywordtype}{double} b12 = b[1]*b[1];
01390             \textcolor{keywordtype}{double} e = exp(-0.5*(x[i]-b[2])*(x[i]-b[2])/b12);
01391             fjac(i,0) = e / b[1];
01392             fjac(i,1) = ((x[i]-b[2])*(x[i]-b[2])/b12-1.) * b[0]*e/b12;
01393             fjac(i,2) = (x[i]-b[2])*e*b[0]/b[1]/b12;
01394         \}
01395         \textcolor{keywordflow}{return} 0;
01396     \}
01397 \};
01398 \textcolor{keyword}{const} \textcolor{keywordtype}{double} eckerle4\_functor::x[35] = \{ 400.0, 405.0, 410.0, 415.0, 420.0, 425.0, 430.0, 435.0, 436.5, 438
      .0, 439.5, 441.0, 442.5, 444.0, 445.5, 447.0, 448.5, 450.0, 451.5, 453.0, 454.5, 456.0, 457.5, 459.0, 460.5,
       462.0, 463.5, 465.0, 470.0, 475.0, 480.0, 485.0, 490.0, 495.0, 500.0\};
01399 \textcolor{keyword}{const} \textcolor{keywordtype}{double} eckerle4\_functor::y[35] = \{ 0.0001575, 0.0001699, 0.0002350, 0.0003102, 0.0004917, 0.0008710, 
      0.0017418, 0.0046400, 0.0065895, 0.0097302, 0.0149002, 0.0237310, 0.0401683, 0.0712559, 0.1264458, 0.2073413
      , 0.2902366, 0.3445623, 0.3698049, 0.3668534, 0.3106727, 0.2078154, 0.1164354, 0.0616764, 0.0337200, 0.01940
      23, 0.0117831, 0.0074357, 0.0022732, 0.0008800, 0.0004579, 0.0002345, 0.0001586, 0.0001143, 0.0000710 \};
01400 
01401 \textcolor{comment}{// http://www.itl.nist.gov/div898/strd/nls/data/eckerle4.shtml}
01402 \textcolor{keywordtype}{void} testNistEckerle4(\textcolor{keywordtype}{void})
01403 \{
01404   \textcolor{keyword}{const} \textcolor{keywordtype}{int} n=3;
01405   \textcolor{keywordtype}{int} info;
01406 
01407   VectorXd x(n);
01408 
01409   \textcolor{comment}{/*}
01410 \textcolor{comment}{   * First try}
01411 \textcolor{comment}{   */}
01412   x<< 1., 10., 500.;
01413   \textcolor{comment}{// do the computation}
01414   \hyperlink{structeckerle4__functor}{eckerle4\_functor} functor;
01415   LevenbergMarquardt<eckerle4\_functor> lm(functor);
01416   info = lm.minimize(x);
01417 
01418   \textcolor{comment}{// check return value}
01419   VERIFY\_IS\_EQUAL(info, 1);
01420   VERIFY\_IS\_EQUAL(lm.nfev(), 18);
01421   VERIFY\_IS\_EQUAL(lm.njev(), 15);
01422   \textcolor{comment}{// check norm^2}
01423   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 1.4635887487E-03);
01424   \textcolor{comment}{// check x}
01425   VERIFY\_IS\_APPROX(x[0], 1.5543827178);
01426   VERIFY\_IS\_APPROX(x[1], 4.0888321754);
01427   VERIFY\_IS\_APPROX(x[2], 4.5154121844E+02);
01428 
01429   \textcolor{comment}{/*}
01430 \textcolor{comment}{   * Second try}
01431 \textcolor{comment}{   */}
01432   x<< 1.5, 5., 450.;
01433   \textcolor{comment}{// do the computation}
01434   info = lm.minimize(x);
01435 
01436   \textcolor{comment}{// check return value}
01437   VERIFY\_IS\_EQUAL(info, 1);
01438   VERIFY\_IS\_EQUAL(lm.nfev(), 7);
01439   VERIFY\_IS\_EQUAL(lm.njev(), 6);
01440   \textcolor{comment}{// check norm^2}
01441   VERIFY\_IS\_APPROX(lm.fvec().squaredNorm(), 1.4635887487E-03);
01442   \textcolor{comment}{// check x}
01443   VERIFY\_IS\_APPROX(x[0], 1.5543827178);
01444   VERIFY\_IS\_APPROX(x[1], 4.0888321754);
01445   VERIFY\_IS\_APPROX(x[2], 4.5154121844E+02);
01446 \}
01447 
01448 \textcolor{keywordtype}{void} test\_levenberg\_marquardt()
01449 \{
01450     \textcolor{comment}{// Tests using the examples provided by (c)minpack}
01451     CALL\_SUBTEST(testLmder1());
01452     CALL\_SUBTEST(testLmder());
01453     CALL\_SUBTEST(testLmdif1());
01454 \textcolor{comment}{//     CALL\_SUBTEST(testLmstr1());}
01455 \textcolor{comment}{//     CALL\_SUBTEST(testLmstr());}
01456     CALL\_SUBTEST(testLmdif());
01457 
01458     \textcolor{comment}{// NIST tests, level of difficulty = "Lower"}
01459     CALL\_SUBTEST(testNistMisra1a());
01460     CALL\_SUBTEST(testNistChwirut2());
01461 
01462     \textcolor{comment}{// NIST tests, level of difficulty = "Average"}
01463     CALL\_SUBTEST(testNistHahn1());
01464     CALL\_SUBTEST(testNistMisra1d());
01465     CALL\_SUBTEST(testNistMGH17());
01466     CALL\_SUBTEST(testNistLanczos1());
01467 
01468 \textcolor{comment}{//     // NIST tests, level of difficulty = "Higher"}
01469     CALL\_SUBTEST(testNistRat42());
01470     CALL\_SUBTEST(testNistMGH10());
01471     CALL\_SUBTEST(testNistBoxBOD());
01472 \textcolor{comment}{//     CALL\_SUBTEST(testNistMGH09());}
01473     CALL\_SUBTEST(testNistBennett5());
01474     CALL\_SUBTEST(testNistThurber());
01475     CALL\_SUBTEST(testNistRat43());
01476     CALL\_SUBTEST(testNistEckerle4());
01477 \}
\end{DoxyCode}
