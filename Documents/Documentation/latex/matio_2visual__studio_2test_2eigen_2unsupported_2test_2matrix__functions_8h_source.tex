\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2test_2matrix__functions_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/test/matrix\+\_\+functions.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2test_2matrix__functions_8h_source}\index{matrix\+\_\+functions.\+h@{matrix\+\_\+functions.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2011 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 \textcolor{preprocessor}{#include <unsupported/Eigen/MatrixFunctions>}
00012 
00013 \textcolor{comment}{// For complex matrices, any matrix is fine.}
00014 template<typename MatrixType, int IsComplex = NumTraits<typename internal::traits<MatrixType>::Scalar>
      ::IsComplex>
00015 \textcolor{keyword}{struct }\hyperlink{structprocess_triangular_matrix}{processTriangularMatrix}
00016 \{
00017   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType&, MatrixType&, \textcolor{keyword}{const} MatrixType&)
00018   \{ \}
00019 \};
00020 
00021 \textcolor{comment}{// For real matrices, make sure none of the eigenvalues are negative.}
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00023 \textcolor{keyword}{struct }\hyperlink{structprocess_triangular_matrix}{processTriangularMatrix}<MatrixType,0>
00024 \{
00025   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType& m, MatrixType& \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \textcolor{keyword}{const} MatrixType& U)
00026   \{
00027     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = m.cols();
00028 
00029     \textcolor{keywordflow}{for} (Index i=0; i < size; ++i) \{
00030       \textcolor{keywordflow}{if} (i == size - 1 || T.coeff(i+1,i) == 0)
00031         T.coeffRef(i,i) = std::abs(T.coeff(i,i));
00032       \textcolor{keywordflow}{else}
00033         ++i;
00034     \}
00035     m = U * T * U.transpose();
00036   \}
00037 \};
00038 
00039 template <typename MatrixType, int IsComplex = NumTraits<typename internal::traits<MatrixType>::Scalar>
      ::IsComplex>
00040 \textcolor{keyword}{struct }\hyperlink{structgenerate_test_matrix}{generateTestMatrix};
00041 
00042 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00043 \textcolor{keyword}{struct }\hyperlink{structgenerate_test_matrix}{generateTestMatrix}<MatrixType,0>
00044 \{
00045   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType& result, \textcolor{keyword}{typename} MatrixType::Index size)
00046   \{
00047     result = MatrixType::Random(size, size);
00048     RealSchur<MatrixType> schur(result);
00049     MatrixType T = schur.matrixT();
00050     \hyperlink{structprocess_triangular_matrix}{processTriangularMatrix<MatrixType>::run}(result, T, schur.
      matrixU());
00051   \}
00052 \};
00053 
00054 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00055 \textcolor{keyword}{struct }\hyperlink{structgenerate_test_matrix}{generateTestMatrix}<MatrixType,1>
00056 \{
00057   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType& result, \textcolor{keyword}{typename} MatrixType::Index size)
00058   \{
00059     result = MatrixType::Random(size, size);
00060   \}
00061 \};
00062 
00063 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>
00064 \textcolor{keyword}{typename} Derived::RealScalar relerr(\textcolor{keyword}{const} MatrixBase<Derived>& A, \textcolor{keyword}{const} MatrixBase<OtherDerived>& B)
00065 \{
00066   \textcolor{keywordflow}{return} std::sqrt((A - B).cwiseAbs2().sum() / (std::min)(A.cwiseAbs2().sum(), B.cwiseAbs2().sum()));
00067 \}
\end{DoxyCode}
