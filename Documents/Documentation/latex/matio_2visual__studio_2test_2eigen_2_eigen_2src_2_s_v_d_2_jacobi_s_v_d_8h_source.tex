\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_jacobi_s_v_d_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+S\+V\+D/\+Jacobi\+S\+VD.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_jacobi_s_v_d_8h_source}\index{Jacobi\+S\+V\+D.\+h@{Jacobi\+S\+V\+D.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2010 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2013-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_JACOBISVD\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_JACOBISVD\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00017 \textcolor{comment}{// forward declaration (needed by ICC)}
00018 \textcolor{comment}{// the empty body is required by MSVC}
00019 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} QRPreconditioner,
00020          \textcolor{keywordtype}{bool} IsComplex = NumTraits<typename MatrixType::Scalar>::IsComplex>
00021 \textcolor{keyword}{struct }svd\_precondition\_2x2\_block\_to\_be\_real \{\};
00022 
00023 \textcolor{comment}{/*** QR preconditioners (R-SVD)}
00024 \textcolor{comment}{ ***}
00025 \textcolor{comment}{ *** Their role is to reduce the problem of computing the SVD to the case of a square matrix.}
00026 \textcolor{comment}{ *** This approach, known as R-SVD, is an optimization for rectangular-enough matrices, and is a
       requirement for}
00027 \textcolor{comment}{ *** JacobiSVD which by itself is only able to work on square matrices.}
00028 \textcolor{comment}{ ***/}
00029 
00030 \textcolor{keyword}{enum} \{ PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols \};
00031 
00032 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} QRPreconditioner, \textcolor{keywordtype}{int} Case>
00033 \textcolor{keyword}{struct }qr\_preconditioner\_should\_do\_anything
00034 \{
00035   \textcolor{keyword}{enum} \{ a = MatrixType::RowsAtCompileTime != \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} &&
00036              MatrixType::ColsAtCompileTime != \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} &&
00037              MatrixType::ColsAtCompileTime <= MatrixType::RowsAtCompileTime,
00038          b = MatrixType::RowsAtCompileTime != \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} &&
00039              MatrixType::ColsAtCompileTime != \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} &&
00040              MatrixType::RowsAtCompileTime <= MatrixType::ColsAtCompileTime,
00041          ret = !( (QRPreconditioner == \hyperlink{group__enums_gga46eba0d5c621f590b8cf1b53af31d56ea4d4b44de7ac7f4e623309be035d287d0}{NoQRPreconditioner}) ||
00042                   (Case == PreconditionIfMoreColsThanRows && \textcolor{keywordtype}{bool}(a)) ||
00043                   (Case == PreconditionIfMoreRowsThanCols && \textcolor{keywordtype}{bool}(b)) )
00044   \};
00045 \};
00046 
00047 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} QRPreconditioner, \textcolor{keywordtype}{int} Case,
00048          \textcolor{keywordtype}{bool} DoAnything = qr\_preconditioner\_should\_do\_anything<MatrixType, QRPreconditioner, Case>::ret
00049 > \textcolor{keyword}{struct }qr\_preconditioner\_impl \{\};
00050 
00051 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} QRPreconditioner, \textcolor{keywordtype}{int} Case>
00052 \textcolor{keyword}{class }qr\_preconditioner\_impl<MatrixType, QRPreconditioner, Case, false>
00053 \{
00054 \textcolor{keyword}{public}:
00055   \textcolor{keywordtype}{void} allocate(\textcolor{keyword}{const} JacobiSVD<MatrixType, QRPreconditioner>&) \{\}
00056   \textcolor{keywordtype}{bool} run(JacobiSVD<MatrixType, QRPreconditioner>&, \textcolor{keyword}{const} MatrixType&)
00057   \{
00058     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00059   \}
00060 \};
00061 
00062 \textcolor{comment}{/*** preconditioner using FullPivHouseholderQR ***/}
00063 
00064 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00065 \textcolor{keyword}{class }qr\_preconditioner\_impl<MatrixType, \hyperlink{group__enums_gga46eba0d5c621f590b8cf1b53af31d56ea566c44ba828dea7f5d2fb174d799d5d2}{FullPivHouseholderQRPreconditioner}
      , PreconditionIfMoreRowsThanCols, true>
00066 \{
00067 \textcolor{keyword}{public}:
00068   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00069   \textcolor{keyword}{enum}
00070   \{
00071     RowsAtCompileTime = MatrixType::RowsAtCompileTime,
00072     MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime
00073   \};
00074   \textcolor{keyword}{typedef} Matrix<Scalar, 1, RowsAtCompileTime, RowMajor, 1, MaxRowsAtCompileTime> WorkspaceType;
00075 
00076   \textcolor{keywordtype}{void} allocate(\textcolor{keyword}{const} JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)
00077   \{
00078     \textcolor{keywordflow}{if} (svd.rows() != m\_qr.rows() || svd.cols() != m\_qr.cols())
00079     \{
00080       m\_qr.~QRType();
00081       ::new (&m\_qr) QRType(svd.rows(), svd.cols());
00082     \}
00083     \textcolor{keywordflow}{if} (svd.m\_computeFullU) m\_workspace.resize(svd.rows());
00084   \}
00085 
00086   \textcolor{keywordtype}{bool} run(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, \textcolor{keyword}{const} MatrixType& matrix)
00087   \{
00088     \textcolor{keywordflow}{if}(matrix.rows() > matrix.cols())
00089     \{
00090       m\_qr.compute(matrix);
00091       svd.m\_workMatrix = m\_qr.matrixQR().block(0,0,matrix.cols(),matrix.cols()).\textcolor{keyword}{template} 
      triangularView<Upper>();
00092       \textcolor{keywordflow}{if}(svd.m\_computeFullU) m\_qr.matrixQ().evalTo(svd.m\_matrixU, m\_workspace);
00093       \textcolor{keywordflow}{if}(svd.computeV()) svd.m\_matrixV = m\_qr.colsPermutation();
00094       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00095     \}
00096     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00097   \}
00098 \textcolor{keyword}{private}:
00099   \textcolor{keyword}{typedef} FullPivHouseholderQR<MatrixType> QRType;
00100   QRType m\_qr;
00101   WorkspaceType m\_workspace;
00102 \};
00103 
00104 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00105 \textcolor{keyword}{class }qr\_preconditioner\_impl<MatrixType, \hyperlink{group__enums_gga46eba0d5c621f590b8cf1b53af31d56ea566c44ba828dea7f5d2fb174d799d5d2}{FullPivHouseholderQRPreconditioner}
      , PreconditionIfMoreColsThanRows, true>
00106 \{
00107 \textcolor{keyword}{public}:
00108   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00109   \textcolor{keyword}{enum}
00110   \{
00111     RowsAtCompileTime = MatrixType::RowsAtCompileTime,
00112     ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00113     MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
00114     MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
00115     TrOptions = RowsAtCompileTime==1 ? (MatrixType::Options & ~(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}))
00116               : ColsAtCompileTime==1 ? (MatrixType::Options |   \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor})
00117               : MatrixType::Options
00118   \};
00119   \textcolor{keyword}{typedef} Matrix<Scalar, ColsAtCompileTime, RowsAtCompileTime, TrOptions, MaxColsAtCompileTime,
       MaxRowsAtCompileTime>
00120           TransposeTypeWithSameStorageOrder;
00121 
00122   \textcolor{keywordtype}{void} allocate(\textcolor{keyword}{const} JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)
00123   \{
00124     \textcolor{keywordflow}{if} (svd.cols() != m\_qr.rows() || svd.rows() != m\_qr.cols())
00125     \{
00126       m\_qr.~QRType();
00127       ::new (&m\_qr) QRType(svd.cols(), svd.rows());
00128     \}
00129     m\_adjoint.resize(svd.cols(), svd.rows());
00130     \textcolor{keywordflow}{if} (svd.m\_computeFullV) m\_workspace.resize(svd.cols());
00131   \}
00132 
00133   \textcolor{keywordtype}{bool} run(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, \textcolor{keyword}{const} MatrixType& matrix)
00134   \{
00135     \textcolor{keywordflow}{if}(matrix.cols() > matrix.rows())
00136     \{
00137       m\_adjoint = matrix.adjoint();
00138       m\_qr.compute(m\_adjoint);
00139       svd.m\_workMatrix = m\_qr.matrixQR().block(0,0,matrix.rows(),matrix.rows()).\textcolor{keyword}{template} 
      triangularView<Upper>().adjoint();
00140       \textcolor{keywordflow}{if}(svd.m\_computeFullV) m\_qr.matrixQ().evalTo(svd.m\_matrixV, m\_workspace);
00141       \textcolor{keywordflow}{if}(svd.computeU()) svd.m\_matrixU = m\_qr.colsPermutation();
00142       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00143     \}
00144     \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00145   \}
00146 \textcolor{keyword}{private}:
00147   \textcolor{keyword}{typedef} FullPivHouseholderQR<TransposeTypeWithSameStorageOrder> QRType;
00148   QRType m\_qr;
00149   TransposeTypeWithSameStorageOrder m\_adjoint;
00150   \textcolor{keyword}{typename} internal::plain\_row\_type<MatrixType>::type m\_workspace;
00151 \};
00152 
00153 \textcolor{comment}{/*** preconditioner using ColPivHouseholderQR ***/}
00154 
00155 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00156 \textcolor{keyword}{class }qr\_preconditioner\_impl<MatrixType, \hyperlink{group__enums_gga46eba0d5c621f590b8cf1b53af31d56eaebc52a2365eec1df700ea97bd7af2d9a}{ColPivHouseholderQRPreconditioner}
      , PreconditionIfMoreRowsThanCols, true>
00157 \{
00158 \textcolor{keyword}{public}:
00159   \textcolor{keywordtype}{void} allocate(\textcolor{keyword}{const} JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)
00160   \{
00161     \textcolor{keywordflow}{if} (svd.rows() != m\_qr.rows() || svd.cols() != m\_qr.cols())
00162     \{
00163       m\_qr.~QRType();
00164       ::new (&m\_qr) QRType(svd.rows(), svd.cols());
00165     \}
00166     \textcolor{keywordflow}{if} (svd.m\_computeFullU) m\_workspace.resize(svd.rows());
00167     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (svd.m\_computeThinU) m\_workspace.resize(svd.cols());
00168   \}
00169 
00170   \textcolor{keywordtype}{bool} run(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, \textcolor{keyword}{const} MatrixType& matrix)
00171   \{
00172     \textcolor{keywordflow}{if}(matrix.rows() > matrix.cols())
00173     \{
00174       m\_qr.compute(matrix);
00175       svd.m\_workMatrix = m\_qr.matrixQR().block(0,0,matrix.cols(),matrix.cols()).\textcolor{keyword}{template} 
      triangularView<Upper>();
00176       \textcolor{keywordflow}{if}(svd.m\_computeFullU) m\_qr.householderQ().evalTo(svd.m\_matrixU, m\_workspace);
00177       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(svd.m\_computeThinU)
00178       \{
00179         svd.m\_matrixU.setIdentity(matrix.rows(), matrix.cols());
00180         m\_qr.householderQ().applyThisOnTheLeft(svd.m\_matrixU, m\_workspace);
00181       \}
00182       \textcolor{keywordflow}{if}(svd.computeV()) svd.m\_matrixV = m\_qr.colsPermutation();
00183       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00184     \}
00185     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00186   \}
00187 
00188 \textcolor{keyword}{private}:
00189   \textcolor{keyword}{typedef} ColPivHouseholderQR<MatrixType> QRType;
00190   QRType m\_qr;
00191   \textcolor{keyword}{typename} internal::plain\_col\_type<MatrixType>::type m\_workspace;
00192 \};
00193 
00194 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00195 \textcolor{keyword}{class }qr\_preconditioner\_impl<MatrixType, \hyperlink{group__enums_gga46eba0d5c621f590b8cf1b53af31d56eaebc52a2365eec1df700ea97bd7af2d9a}{ColPivHouseholderQRPreconditioner}
      , PreconditionIfMoreColsThanRows, true>
00196 \{
00197 \textcolor{keyword}{public}:
00198   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00199   \textcolor{keyword}{enum}
00200   \{
00201     RowsAtCompileTime = MatrixType::RowsAtCompileTime,
00202     ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00203     MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
00204     MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
00205     TrOptions = RowsAtCompileTime==1 ? (MatrixType::Options & ~(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}))
00206               : ColsAtCompileTime==1 ? (MatrixType::Options |   \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor})
00207               : MatrixType::Options
00208   \};
00209 
00210   \textcolor{keyword}{typedef} Matrix<Scalar, ColsAtCompileTime, RowsAtCompileTime, TrOptions, MaxColsAtCompileTime,
       MaxRowsAtCompileTime>
00211           TransposeTypeWithSameStorageOrder;
00212 
00213   \textcolor{keywordtype}{void} allocate(\textcolor{keyword}{const} JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)
00214   \{
00215     \textcolor{keywordflow}{if} (svd.cols() != m\_qr.rows() || svd.rows() != m\_qr.cols())
00216     \{
00217       m\_qr.~QRType();
00218       ::new (&m\_qr) QRType(svd.cols(), svd.rows());
00219     \}
00220     \textcolor{keywordflow}{if} (svd.m\_computeFullV) m\_workspace.resize(svd.cols());
00221     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (svd.m\_computeThinV) m\_workspace.resize(svd.rows());
00222     m\_adjoint.resize(svd.cols(), svd.rows());
00223   \}
00224 
00225   \textcolor{keywordtype}{bool} run(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, \textcolor{keyword}{const} MatrixType& matrix)
00226   \{
00227     \textcolor{keywordflow}{if}(matrix.cols() > matrix.rows())
00228     \{
00229       m\_adjoint = matrix.adjoint();
00230       m\_qr.compute(m\_adjoint);
00231 
00232       svd.m\_workMatrix = m\_qr.matrixQR().block(0,0,matrix.rows(),matrix.rows()).\textcolor{keyword}{template} 
      triangularView<Upper>().adjoint();
00233       \textcolor{keywordflow}{if}(svd.m\_computeFullV) m\_qr.householderQ().evalTo(svd.m\_matrixV, m\_workspace);
00234       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(svd.m\_computeThinV)
00235       \{
00236         svd.m\_matrixV.setIdentity(matrix.cols(), matrix.rows());
00237         m\_qr.householderQ().applyThisOnTheLeft(svd.m\_matrixV, m\_workspace);
00238       \}
00239       \textcolor{keywordflow}{if}(svd.computeU()) svd.m\_matrixU = m\_qr.colsPermutation();
00240       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00241     \}
00242     \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00243   \}
00244 
00245 \textcolor{keyword}{private}:
00246   \textcolor{keyword}{typedef} ColPivHouseholderQR<TransposeTypeWithSameStorageOrder> QRType;
00247   QRType m\_qr;
00248   TransposeTypeWithSameStorageOrder m\_adjoint;
00249   \textcolor{keyword}{typename} internal::plain\_row\_type<MatrixType>::type m\_workspace;
00250 \};
00251 
00252 \textcolor{comment}{/*** preconditioner using HouseholderQR ***/}
00253 
00254 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00255 \textcolor{keyword}{class }qr\_preconditioner\_impl<MatrixType, \hyperlink{group__enums_gga46eba0d5c621f590b8cf1b53af31d56ea25d36655046e5910c850f62f84f34e25}{HouseholderQRPreconditioner}, 
      PreconditionIfMoreRowsThanCols, true>
00256 \{
00257 \textcolor{keyword}{public}:
00258   \textcolor{keywordtype}{void} allocate(\textcolor{keyword}{const} JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)
00259   \{
00260     \textcolor{keywordflow}{if} (svd.rows() != m\_qr.rows() || svd.cols() != m\_qr.cols())
00261     \{
00262       m\_qr.~QRType();
00263       ::new (&m\_qr) QRType(svd.rows(), svd.cols());
00264     \}
00265     \textcolor{keywordflow}{if} (svd.m\_computeFullU) m\_workspace.resize(svd.rows());
00266     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (svd.m\_computeThinU) m\_workspace.resize(svd.cols());
00267   \}
00268 
00269   \textcolor{keywordtype}{bool} run(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, \textcolor{keyword}{const} MatrixType& matrix)
00270   \{
00271     \textcolor{keywordflow}{if}(matrix.rows() > matrix.cols())
00272     \{
00273       m\_qr.compute(matrix);
00274       svd.m\_workMatrix = m\_qr.matrixQR().block(0,0,matrix.cols(),matrix.cols()).\textcolor{keyword}{template} 
      triangularView<Upper>();
00275       \textcolor{keywordflow}{if}(svd.m\_computeFullU) m\_qr.householderQ().evalTo(svd.m\_matrixU, m\_workspace);
00276       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(svd.m\_computeThinU)
00277       \{
00278         svd.m\_matrixU.setIdentity(matrix.rows(), matrix.cols());
00279         m\_qr.householderQ().applyThisOnTheLeft(svd.m\_matrixU, m\_workspace);
00280       \}
00281       \textcolor{keywordflow}{if}(svd.computeV()) svd.m\_matrixV.setIdentity(matrix.cols(), matrix.cols());
00282       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00283     \}
00284     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00285   \}
00286 \textcolor{keyword}{private}:
00287   \textcolor{keyword}{typedef} HouseholderQR<MatrixType> QRType;
00288   QRType m\_qr;
00289   \textcolor{keyword}{typename} internal::plain\_col\_type<MatrixType>::type m\_workspace;
00290 \};
00291 
00292 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00293 \textcolor{keyword}{class }qr\_preconditioner\_impl<MatrixType, \hyperlink{group__enums_gga46eba0d5c621f590b8cf1b53af31d56ea25d36655046e5910c850f62f84f34e25}{HouseholderQRPreconditioner}, 
      PreconditionIfMoreColsThanRows, true>
00294 \{
00295 \textcolor{keyword}{public}:
00296   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00297   \textcolor{keyword}{enum}
00298   \{
00299     RowsAtCompileTime = MatrixType::RowsAtCompileTime,
00300     ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00301     MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
00302     MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
00303     Options = MatrixType::Options
00304   \};
00305 
00306   \textcolor{keyword}{typedef} Matrix<Scalar, ColsAtCompileTime, RowsAtCompileTime, Options, MaxColsAtCompileTime,
       MaxRowsAtCompileTime>
00307           TransposeTypeWithSameStorageOrder;
00308 
00309   \textcolor{keywordtype}{void} allocate(\textcolor{keyword}{const} JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)
00310   \{
00311     \textcolor{keywordflow}{if} (svd.cols() != m\_qr.rows() || svd.rows() != m\_qr.cols())
00312     \{
00313       m\_qr.~QRType();
00314       ::new (&m\_qr) QRType(svd.cols(), svd.rows());
00315     \}
00316     \textcolor{keywordflow}{if} (svd.m\_computeFullV) m\_workspace.resize(svd.cols());
00317     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (svd.m\_computeThinV) m\_workspace.resize(svd.rows());
00318     m\_adjoint.resize(svd.cols(), svd.rows());
00319   \}
00320 
00321   \textcolor{keywordtype}{bool} run(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, \textcolor{keyword}{const} MatrixType& matrix)
00322   \{
00323     \textcolor{keywordflow}{if}(matrix.cols() > matrix.rows())
00324     \{
00325       m\_adjoint = matrix.adjoint();
00326       m\_qr.compute(m\_adjoint);
00327 
00328       svd.m\_workMatrix = m\_qr.matrixQR().block(0,0,matrix.rows(),matrix.rows()).\textcolor{keyword}{template} 
      triangularView<Upper>().adjoint();
00329       \textcolor{keywordflow}{if}(svd.m\_computeFullV) m\_qr.householderQ().evalTo(svd.m\_matrixV, m\_workspace);
00330       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(svd.m\_computeThinV)
00331       \{
00332         svd.m\_matrixV.setIdentity(matrix.cols(), matrix.rows());
00333         m\_qr.householderQ().applyThisOnTheLeft(svd.m\_matrixV, m\_workspace);
00334       \}
00335       \textcolor{keywordflow}{if}(svd.computeU()) svd.m\_matrixU.setIdentity(matrix.rows(), matrix.rows());
00336       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00337     \}
00338     \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00339   \}
00340 
00341 \textcolor{keyword}{private}:
00342   \textcolor{keyword}{typedef} HouseholderQR<TransposeTypeWithSameStorageOrder> QRType;
00343   QRType m\_qr;
00344   TransposeTypeWithSameStorageOrder m\_adjoint;
00345   \textcolor{keyword}{typename} internal::plain\_row\_type<MatrixType>::type m\_workspace;
00346 \};
00347 
00348 \textcolor{comment}{/*** 2x2 SVD implementation}
00349 \textcolor{comment}{ ***}
00350 \textcolor{comment}{ *** JacobiSVD consists in performing a series of 2x2 SVD subproblems}
00351 \textcolor{comment}{ ***/}
00352 
00353 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} QRPreconditioner>
00354 \textcolor{keyword}{struct }svd\_precondition\_2x2\_block\_to\_be\_real<MatrixType, QRPreconditioner, false>
00355 \{
00356   \textcolor{keyword}{typedef} JacobiSVD<MatrixType, QRPreconditioner> SVD;
00357   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00358   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} run(\textcolor{keyword}{typename} SVD::WorkMatrixType&, SVD&, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, RealScalar&) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; 
      \}
00359 \};
00360 
00361 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} QRPreconditioner>
00362 \textcolor{keyword}{struct }svd\_precondition\_2x2\_block\_to\_be\_real<MatrixType, QRPreconditioner, true>
00363 \{
00364   \textcolor{keyword}{typedef} JacobiSVD<MatrixType, QRPreconditioner> SVD;
00365   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00366   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00367   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} run(\textcolor{keyword}{typename} SVD::WorkMatrixType& work\_matrix, SVD& svd, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} q, RealScalar& maxDiagEntry)
00368   \{
00369     \textcolor{keyword}{using} std::sqrt;
00370     \textcolor{keyword}{using} std::abs;
00371     Scalar z;
00372     JacobiRotation<Scalar> rot;
00373     RealScalar n = sqrt(numext::abs2(work\_matrix.coeff(p,p)) + numext::abs2(work\_matrix.coeff(q,p)));
00374 
00375     \textcolor{keyword}{const} RealScalar considerAsZero = (std::numeric\_limits<RealScalar>::min)();
00376     \textcolor{keyword}{const} RealScalar precision = NumTraits<Scalar>::epsilon();
00377 
00378     \textcolor{keywordflow}{if}(n==0)
00379     \{
00380       \textcolor{comment}{// make sure first column is zero}
00381       work\_matrix.coeffRef(p,p) = work\_matrix.coeffRef(q,p) = Scalar(0);
00382 
00383       \textcolor{keywordflow}{if}(abs(numext::imag(work\_matrix.coeff(p,q)))>considerAsZero)
00384       \{
00385         \textcolor{comment}{// work\_matrix.coeff(p,q) can be zero if work\_matrix.coeff(q,p) is not zero but small enough to
       underflow when computing n}
00386         z = abs(work\_matrix.coeff(p,q)) / work\_matrix.coeff(p,q);
00387         work\_matrix.row(p) *= z;
00388         \textcolor{keywordflow}{if}(svd.computeU()) svd.m\_matrixU.col(p) *= conj(z);
00389       \}
00390       \textcolor{keywordflow}{if}(abs(numext::imag(work\_matrix.coeff(q,q)))>considerAsZero)
00391       \{
00392         z = abs(work\_matrix.coeff(q,q)) / work\_matrix.coeff(q,q);
00393         work\_matrix.row(q) *= z;
00394         \textcolor{keywordflow}{if}(svd.computeU()) svd.m\_matrixU.col(q) *= conj(z);
00395       \}
00396       \textcolor{comment}{// otherwise the second row is already zero, so we have nothing to do.}
00397     \}
00398     \textcolor{keywordflow}{else}
00399     \{
00400       rot.c() = conj(work\_matrix.coeff(p,p)) / n;
00401       rot.s() = work\_matrix.coeff(q,p) / n;
00402       work\_matrix.applyOnTheLeft(p,q,rot);
00403       \textcolor{keywordflow}{if}(svd.computeU()) svd.m\_matrixU.applyOnTheRight(p,q,rot.adjoint());
00404       \textcolor{keywordflow}{if}(abs(numext::imag(work\_matrix.coeff(p,q)))>considerAsZero)
00405       \{
00406         z = abs(work\_matrix.coeff(p,q)) / work\_matrix.coeff(p,q);
00407         work\_matrix.col(q) *= z;
00408         \textcolor{keywordflow}{if}(svd.computeV()) svd.m\_matrixV.col(q) *= z;
00409       \}
00410       \textcolor{keywordflow}{if}(abs(numext::imag(work\_matrix.coeff(q,q)))>considerAsZero)
00411       \{
00412         z = abs(work\_matrix.coeff(q,q)) / work\_matrix.coeff(q,q);
00413         work\_matrix.row(q) *= z;
00414         \textcolor{keywordflow}{if}(svd.computeU()) svd.m\_matrixU.col(q) *= conj(z);
00415       \}
00416     \}
00417 
00418     \textcolor{comment}{// update largest diagonal entry}
00419     maxDiagEntry = numext::maxi<RealScalar>(maxDiagEntry,numext::maxi<RealScalar>(abs(work\_matrix.coeff(p,p
      )), abs(work\_matrix.coeff(q,q))));
00420     \textcolor{comment}{// and check whether the 2x2 block is already diagonal}
00421     RealScalar threshold = numext::maxi<RealScalar>(considerAsZero, precision * maxDiagEntry);
00422     \textcolor{keywordflow}{return} abs(work\_matrix.coeff(p,q))>threshold || abs(work\_matrix.coeff(q,p)) > threshold;
00423   \}
00424 \};
00425 
00426 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} QRPreconditioner> 
00427 \textcolor{keyword}{struct }traits<JacobiSVD<\_MatrixType,QRPreconditioner> >
00428 \{
00429   \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00430 \};
00431 
00432 \} \textcolor{comment}{// end namespace internal}
00433 
00487 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keywordtype}{int} QRPreconditioner> \textcolor{keyword}{class }JacobiSVD
00488  : \textcolor{keyword}{public} SVDBase<JacobiSVD<\_MatrixType,QRPreconditioner> >
00489 \{
00490     \textcolor{keyword}{typedef} SVDBase<JacobiSVD> Base;
00491   \textcolor{keyword}{public}:
00492 
00493     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00494     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00495     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<typename MatrixType::Scalar>::Real RealScalar;
00496     \textcolor{keyword}{enum} \{
00497       RowsAtCompileTime = MatrixType::RowsAtCompileTime,
00498       ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00499       DiagSizeAtCompileTime = EIGEN\_SIZE\_MIN\_PREFER\_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime),
00500       MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
00501       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
00502       MaxDiagSizeAtCompileTime = EIGEN\_SIZE\_MIN\_PREFER\_FIXED(MaxRowsAtCompileTime,MaxColsAtCompileTime),
00503       MatrixOptions = MatrixType::Options
00504     \};
00505 
00506     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::MatrixUType MatrixUType;
00507     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::MatrixVType MatrixVType;
00508     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::SingularValuesType SingularValuesType;
00509     
00510     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_row\_type<MatrixType>::type RowType;
00511     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_col\_type<MatrixType>::type ColType;
00512     \textcolor{keyword}{typedef} Matrix<Scalar, DiagSizeAtCompileTime, DiagSizeAtCompileTime,
00513                    MatrixOptions, MaxDiagSizeAtCompileTime, MaxDiagSizeAtCompileTime>
00514             WorkMatrixType;
00515 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_jacobi_s_v_d_8h_source_l00521}\hyperlink{group___s_v_d___module_a55315ab9cd060019a5ad07be798ff3b9}{00521}     \hyperlink{group___s_v_d___module_a55315ab9cd060019a5ad07be798ff3b9}{JacobiSVD}()
00522     \{\}
00523 
00524 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_jacobi_s_v_d_8h_source_l00531}\hyperlink{group___s_v_d___module_a5d9ea7c8f361337727260efd77ee03ac}{00531}     \hyperlink{group___s_v_d___module_a5d9ea7c8f361337727260efd77ee03ac}{JacobiSVD}(\hyperlink{group___s_v_d___module_a6229a37997eca1072b52cca5ee7a2bec}{Index} rows, \hyperlink{group___s_v_d___module_a6229a37997eca1072b52cca5ee7a2bec}{Index} cols, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions = 0)
00532     \{
00533       allocate(rows, cols, computationOptions);
00534     \}
00535 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_jacobi_s_v_d_8h_source_l00546}\hyperlink{group___s_v_d___module_abfd1dd454a6e3edec7feecd97c818a78}{00546}     \textcolor{keyword}{explicit} \hyperlink{group___s_v_d___module_abfd1dd454a6e3edec7feecd97c818a78}{JacobiSVD}(\textcolor{keyword}{const} MatrixType& matrix, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions = 0)
00547     \{
00548       compute(matrix, computationOptions);
00549     \}
00550 
00561     \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD}& compute(\textcolor{keyword}{const} MatrixType& matrix, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions);
00562 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_jacobi_s_v_d_8h_source_l00569}\hyperlink{group___s_v_d___module_acc7b9a4068cf7b69ae3227d217ed7efd}{00569}     \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD}& \hyperlink{group___s_v_d___module_acc7b9a4068cf7b69ae3227d217ed7efd}{compute}(\textcolor{keyword}{const} MatrixType& matrix)
00570     \{
00571       \textcolor{keywordflow}{return} compute(matrix, m\_computationOptions);
00572     \}
00573 
00574     \textcolor{keyword}{using} Base::computeU;
00575     \textcolor{keyword}{using} Base::computeV;
00576     \textcolor{keyword}{using} Base::rows;
00577     \textcolor{keyword}{using} Base::cols;
00578     \textcolor{keyword}{using} Base::rank;
00579 
00580   \textcolor{keyword}{private}:
00581     \textcolor{keywordtype}{void} allocate(\hyperlink{group___s_v_d___module_a6229a37997eca1072b52cca5ee7a2bec}{Index} rows, \hyperlink{group___s_v_d___module_a6229a37997eca1072b52cca5ee7a2bec}{Index} cols, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions);
00582 
00583   \textcolor{keyword}{protected}:
00584     \textcolor{keyword}{using} Base::m\_matrixU;
00585     \textcolor{keyword}{using} Base::m\_matrixV;
00586     \textcolor{keyword}{using} Base::m\_singularValues;
00587     \textcolor{keyword}{using} Base::m\_isInitialized;
00588     \textcolor{keyword}{using} Base::m\_isAllocated;
00589     \textcolor{keyword}{using} Base::m\_usePrescribedThreshold;
00590     \textcolor{keyword}{using} Base::m\_computeFullU;
00591     \textcolor{keyword}{using} Base::m\_computeThinU;
00592     \textcolor{keyword}{using} Base::m\_computeFullV;
00593     \textcolor{keyword}{using} Base::m\_computeThinV;
00594     \textcolor{keyword}{using} Base::m\_computationOptions;
00595     \textcolor{keyword}{using} Base::m\_nonzeroSingularValues;
00596     \textcolor{keyword}{using} Base::m\_rows;
00597     \textcolor{keyword}{using} Base::m\_cols;
00598     \textcolor{keyword}{using} Base::m\_diagSize;
00599     \textcolor{keyword}{using} Base::m\_prescribedThreshold;
00600     WorkMatrixType m\_workMatrix;
00601 
00602     \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_\_MatrixType, \textcolor{keywordtype}{int} \_QRPreconditioner, \textcolor{keywordtype}{bool} \_IsComplex>
00603     \textcolor{keyword}{friend} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1svd__precondition__2x2__block__to__be__real}{internal::svd\_precondition\_2x2\_block\_to\_be\_real}
      ;
00604     \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_\_MatrixType, \textcolor{keywordtype}{int} \_QRPreconditioner, \textcolor{keywordtype}{int} \_Case, \textcolor{keywordtype}{bool} \_DoAnything>
00605     \textcolor{keyword}{friend} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1qr__preconditioner__impl}{internal::qr\_preconditioner\_impl};
00606 
00607     
      \hyperlink{struct_eigen_1_1internal_1_1qr__preconditioner__impl}{internal::qr\_preconditioner\_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows>}
       m\_qr\_precond\_morecols;
00608     
      \hyperlink{struct_eigen_1_1internal_1_1qr__preconditioner__impl}{internal::qr\_preconditioner\_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols>}
       m\_qr\_precond\_morerows;
00609     MatrixType m\_scaledMatrix;
00610 \};
00611 
00612 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} QRPreconditioner>
00613 \textcolor{keywordtype}{void} \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD<MatrixType, QRPreconditioner>::allocate}(
      \hyperlink{group___s_v_d___module_a6229a37997eca1072b52cca5ee7a2bec}{Index} rows, \hyperlink{group___s_v_d___module_a6229a37997eca1072b52cca5ee7a2bec}{Index} cols, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions)
00614 \{
00615   eigen\_assert(rows >= 0 && cols >= 0);
00616 
00617   \textcolor{keywordflow}{if} (m\_isAllocated &&
00618       rows == m\_rows &&
00619       cols == m\_cols &&
00620       computationOptions == m\_computationOptions)
00621   \{
00622     \textcolor{keywordflow}{return};
00623   \}
00624 
00625   m\_rows = rows;
00626   m\_cols = cols;
00627   m\_isInitialized = \textcolor{keyword}{false};
00628   m\_isAllocated = \textcolor{keyword}{true};
00629   m\_computationOptions = computationOptions;
00630   m\_computeFullU = (computationOptions & \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a2b4f91ca5859a4159dbfe8090043817f}{ComputeFullU}) != 0;
00631   m\_computeThinU = (computationOptions & \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9af8c742a1aa87773e165eae406c9ccaf8}{ComputeThinU}) != 0;
00632   m\_computeFullV = (computationOptions & \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a52c6f7e80bbf9a42297c88f700245b51}{ComputeFullV}) != 0;
00633   m\_computeThinV = (computationOptions & \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a1055e53fa95c8ae04a07ebb72cfafd95}{ComputeThinV}) != 0;
00634   eigen\_assert(!(m\_computeFullU && m\_computeThinU) && \textcolor{stringliteral}{"JacobiSVD: you can't ask for both full and thin U"});
00635   eigen\_assert(!(m\_computeFullV && m\_computeThinV) && \textcolor{stringliteral}{"JacobiSVD: you can't ask for both full and thin V"});
00636   eigen\_assert(EIGEN\_IMPLIES(m\_computeThinU || m\_computeThinV, MatrixType::ColsAtCompileTime==
      \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}) &&
00637               \textcolor{stringliteral}{"JacobiSVD: thin U and V are only available when your matrix has a dynamic number of columns.
      "});
00638   \textcolor{keywordflow}{if} (QRPreconditioner == \hyperlink{group__enums_gga46eba0d5c621f590b8cf1b53af31d56ea566c44ba828dea7f5d2fb174d799d5d2}{FullPivHouseholderQRPreconditioner})
00639   \{
00640       eigen\_assert(!(m\_computeThinU || m\_computeThinV) &&
00641               \textcolor{stringliteral}{"JacobiSVD: can't compute thin U or thin V with the FullPivHouseholderQR preconditioner. "}
00642               \textcolor{stringliteral}{"Use the ColPivHouseholderQR preconditioner instead."});
00643   \}
00644   m\_diagSize = (std::min)(m\_rows, m\_cols);
00645   m\_singularValues.resize(m\_diagSize);
00646   \textcolor{keywordflow}{if}(RowsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic})
00647     m\_matrixU.resize(m\_rows, m\_computeFullU ? m\_rows
00648                             : m\_computeThinU ? m\_diagSize
00649                             : 0);
00650   \textcolor{keywordflow}{if}(ColsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic})
00651     m\_matrixV.resize(m\_cols, m\_computeFullV ? m\_cols
00652                             : m\_computeThinV ? m\_diagSize
00653                             : 0);
00654   m\_workMatrix.resize(m\_diagSize, m\_diagSize);
00655   
00656   \textcolor{keywordflow}{if}(m\_cols>m\_rows)   m\_qr\_precond\_morecols.allocate(*\textcolor{keyword}{this});
00657   \textcolor{keywordflow}{if}(m\_rows>m\_cols)   m\_qr\_precond\_morerows.allocate(*\textcolor{keyword}{this});
00658   \textcolor{keywordflow}{if}(m\_rows!=m\_cols)  m\_scaledMatrix.resize(rows,cols);
00659 \}
00660 
00661 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} QRPreconditioner>
00662 \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD<MatrixType, QRPreconditioner>}&
00663 \hyperlink{group___s_v_d___module_a5dab376cc86cf0d36674bcdad4af3f5a}{JacobiSVD<MatrixType, QRPreconditioner>::compute}(\textcolor{keyword}{const} 
      MatrixType& matrix, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions)
00664 \{
00665   \textcolor{keyword}{using} std::abs;
00666   allocate(matrix.rows(), matrix.cols(), computationOptions);
00667 
00668   \textcolor{comment}{// currently we stop when we reach precision 2*epsilon as the last bit of precision can require an
       unreasonable number of iterations,}
00669   \textcolor{comment}{// only worsening the precision of U and V as we accumulate more rotations}
00670   \textcolor{keyword}{const} RealScalar precision = RealScalar(2) * \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}();
00671 
00672   \textcolor{comment}{// limit for denormal numbers to be considered zero in order to avoid infinite loops (see bug 286)}
00673   \textcolor{keyword}{const} RealScalar considerAsZero = (std::numeric\_limits<RealScalar>::min)();
00674 
00675   \textcolor{comment}{// Scaling factor to reduce over/under-flows}
00676   RealScalar scale = matrix.cwiseAbs().maxCoeff();
00677   \textcolor{keywordflow}{if}(scale==RealScalar(0)) scale = RealScalar(1);
00678   
00679   \textcolor{comment}{/*** step 1. The R-SVD step: we use a QR decomposition to reduce to the case of a square matrix */}
00680 
00681   \textcolor{keywordflow}{if}(m\_rows!=m\_cols)
00682   \{
00683     m\_scaledMatrix = matrix / scale;
00684     m\_qr\_precond\_morecols.run(*\textcolor{keyword}{this}, m\_scaledMatrix);
00685     m\_qr\_precond\_morerows.run(*\textcolor{keyword}{this}, m\_scaledMatrix);
00686   \}
00687   \textcolor{keywordflow}{else}
00688   \{
00689     m\_workMatrix = matrix.block(0,0,m\_diagSize,m\_diagSize) / scale;
00690     \textcolor{keywordflow}{if}(m\_computeFullU) m\_matrixU.setIdentity(m\_rows,m\_rows);
00691     \textcolor{keywordflow}{if}(m\_computeThinU) m\_matrixU.setIdentity(m\_rows,m\_diagSize);
00692     \textcolor{keywordflow}{if}(m\_computeFullV) m\_matrixV.setIdentity(m\_cols,m\_cols);
00693     \textcolor{keywordflow}{if}(m\_computeThinV) m\_matrixV.setIdentity(m\_cols, m\_diagSize);
00694   \}
00695 
00696   \textcolor{comment}{/*** step 2. The main Jacobi SVD iteration. ***/}
00697   RealScalar maxDiagEntry = m\_workMatrix.cwiseAbs().diagonal().maxCoeff();
00698 
00699   \textcolor{keywordtype}{bool} finished = \textcolor{keyword}{false};
00700   \textcolor{keywordflow}{while}(!finished)
00701   \{
00702     finished = \textcolor{keyword}{true};
00703 
00704     \textcolor{comment}{// do a sweep: for all index pairs (p,q), perform SVD of the corresponding 2x2 sub-matrix}
00705 
00706     \textcolor{keywordflow}{for}(\hyperlink{group___s_v_d___module_a6229a37997eca1072b52cca5ee7a2bec}{Index} p = 1; p < m\_diagSize; ++p)
00707     \{
00708       \textcolor{keywordflow}{for}(\hyperlink{group___s_v_d___module_a6229a37997eca1072b52cca5ee7a2bec}{Index} q = 0; q < p; ++q)
00709       \{
00710         \textcolor{comment}{// if this 2x2 sub-matrix is not diagonal already...}
00711         \textcolor{comment}{// notice that this comparison will evaluate to false if any NaN is involved, ensuring that NaN's
       don't}
00712         \textcolor{comment}{// keep us iterating forever. Similarly, small denormal numbers are considered zero.}
00713         RealScalar threshold = numext::maxi<RealScalar>(considerAsZero, precision * maxDiagEntry);
00714         \textcolor{keywordflow}{if}(abs(m\_workMatrix.coeff(p,q))>threshold || abs(m\_workMatrix.coeff(q,p)) > threshold)
00715         \{
00716           finished = \textcolor{keyword}{false};
00717           \textcolor{comment}{// perform SVD decomposition of 2x2 sub-matrix corresponding to indices p,q to make it diagonal}
00718           \textcolor{comment}{// the complex to real operation returns true if the updated 2x2 block is not already diagonal}
00719           \textcolor{keywordflow}{if}(
      \hyperlink{struct_eigen_1_1internal_1_1svd__precondition__2x2__block__to__be__real}{internal::svd\_precondition\_2x2\_block\_to\_be\_real<MatrixType, QRPreconditioner>::run}
      (m\_workMatrix, *\textcolor{keyword}{this}, p, q, maxDiagEntry))
00720           \{
00721             \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<RealScalar>} j\_left, j\_right;
00722             internal::real\_2x2\_jacobi\_svd(m\_workMatrix, p, q, &j\_left, &j\_right);
00723 
00724             \textcolor{comment}{// accumulate resulting Jacobi rotations}
00725             m\_workMatrix.applyOnTheLeft(p,q,j\_left);
00726             \textcolor{keywordflow}{if}(computeU()) m\_matrixU.applyOnTheRight(p,q,j\_left.\hyperlink{group___jacobi___module_ab40e9cdc4582593511e57ee896e055a2}{transpose}());
00727 
00728             m\_workMatrix.applyOnTheRight(p,q,j\_right);
00729             \textcolor{keywordflow}{if}(computeV()) m\_matrixV.applyOnTheRight(p,q,j\_right);
00730 
00731             \textcolor{comment}{// keep track of the largest diagonal coefficient}
00732             maxDiagEntry = numext::maxi<RealScalar>(maxDiagEntry,numext::maxi<RealScalar>(abs(m\_workMatrix.
      coeff(p,p)), abs(m\_workMatrix.coeff(q,q))));
00733           \}
00734         \}
00735       \}
00736     \}
00737   \}
00738 
00739   \textcolor{comment}{/*** step 3. The work matrix is now diagonal, so ensure it's positive so its diagonal entries are the
       singular values ***/}
00740 
00741   \textcolor{keywordflow}{for}(\hyperlink{group___s_v_d___module_a6229a37997eca1072b52cca5ee7a2bec}{Index} i = 0; i < m\_diagSize; ++i)
00742   \{
00743     \textcolor{comment}{// For a complex matrix, some diagonal coefficients might note have been}
00744     \textcolor{comment}{// treated by svd\_precondition\_2x2\_block\_to\_be\_real, and the imaginary part}
00745     \textcolor{comment}{// of some diagonal entry might not be null.}
00746     \textcolor{keywordflow}{if}(\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsComplex} && abs(numext::imag(m\_workMatrix.coeff(i,i)
      ))>considerAsZero)
00747     \{
00748       RealScalar a = abs(m\_workMatrix.coeff(i,i));
00749       m\_singularValues.coeffRef(i) = abs(a);
00750       \textcolor{keywordflow}{if}(computeU()) m\_matrixU.col(i) *= m\_workMatrix.coeff(i,i)/a;
00751     \}
00752     \textcolor{keywordflow}{else}
00753     \{
00754       \textcolor{comment}{// m\_workMatrix.coeff(i,i) is already real, no difficulty:}
00755       RealScalar a = numext::real(m\_workMatrix.coeff(i,i));
00756       m\_singularValues.coeffRef(i) = abs(a);
00757       \textcolor{keywordflow}{if}(computeU() && (a<RealScalar(0))) m\_matrixU.col(i) = -m\_matrixU.col(i);
00758     \}
00759   \}
00760   
00761   m\_singularValues *= scale;
00762 
00763   \textcolor{comment}{/*** step 4. Sort singular values in descending order and compute the number of nonzero singular values *
      **/}
00764 
00765   m\_nonzeroSingularValues = m\_diagSize;
00766   \textcolor{keywordflow}{for}(\hyperlink{group___s_v_d___module_a6229a37997eca1072b52cca5ee7a2bec}{Index} i = 0; i < m\_diagSize; i++)
00767   \{
00768     \hyperlink{group___s_v_d___module_a6229a37997eca1072b52cca5ee7a2bec}{Index} pos;
00769     RealScalar maxRemainingSingularValue = m\_singularValues.tail(m\_diagSize-i).maxCoeff(&pos);
00770     \textcolor{keywordflow}{if}(maxRemainingSingularValue == RealScalar(0))
00771     \{
00772       m\_nonzeroSingularValues = i;
00773       \textcolor{keywordflow}{break};
00774     \}
00775     \textcolor{keywordflow}{if}(pos)
00776     \{
00777       pos += i;
00778       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_singularValues.coeffRef(i), m\_singularValues.coeffRef(pos));
00779       \textcolor{keywordflow}{if}(computeU()) m\_matrixU.col(pos).swap(m\_matrixU.col(i));
00780       \textcolor{keywordflow}{if}(computeV()) m\_matrixV.col(pos).swap(m\_matrixV.col(i));
00781     \}
00782   \}
00783 
00784   m\_isInitialized = \textcolor{keyword}{true};
00785   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00786 \}
00787 
00795 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00796 \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD<typename MatrixBase<Derived>::PlainObject}>
00797 \hyperlink{group___core___module_a5745dca9c54390633b434e54a1d1eedd}{MatrixBase<Derived>::jacobiSvd}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions)\textcolor{keyword}{ const}
00798 \textcolor{keyword}{}\{
00799   \textcolor{keywordflow}{return} \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD<PlainObject>}(*\textcolor{keyword}{this}, computationOptions);
00800 \}
00801 
00802 \} \textcolor{comment}{// end namespace Eigen}
00803 
00804 \textcolor{preprocessor}{#endif // EIGEN\_JACOBISVD\_H}
\end{DoxyCode}
