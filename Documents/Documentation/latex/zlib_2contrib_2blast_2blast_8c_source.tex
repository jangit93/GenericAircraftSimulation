\hypertarget{zlib_2contrib_2blast_2blast_8c_source}{}\section{zlib/contrib/blast/blast.c}
\label{zlib_2contrib_2blast_2blast_8c_source}\index{blast.\+c@{blast.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* blast.c}
00002 \textcolor{comment}{ * Copyright (C) 2003, 2012, 2013 Mark Adler}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in blast.h}
00004 \textcolor{comment}{ * version 1.3, 24 Aug 2013}
00005 \textcolor{comment}{ *}
00006 \textcolor{comment}{ * blast.c decompresses data compressed by the PKWare Compression Library.}
00007 \textcolor{comment}{ * This function provides functionality similar to the explode() function of}
00008 \textcolor{comment}{ * the PKWare library, hence the name "blast".}
00009 \textcolor{comment}{ *}
00010 \textcolor{comment}{ * This decompressor is based on the excellent format description provided by}
00011 \textcolor{comment}{ * Ben Rudiak-Gould in comp.compression on August 13, 2001.  Interestingly, the}
00012 \textcolor{comment}{ * example Ben provided in the post is incorrect.  The distance 110001 should}
00013 \textcolor{comment}{ * instead be 111000.  When corrected, the example byte stream becomes:}
00014 \textcolor{comment}{ *}
00015 \textcolor{comment}{ *    00 04 82 24 25 8f 80 7f}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * which decompresses to "AIAIAIAIAIAIA" (without the quotes).}
00018 \textcolor{comment}{ */}
00019 
00020 \textcolor{comment}{/*}
00021 \textcolor{comment}{ * Change history:}
00022 \textcolor{comment}{ *}
00023 \textcolor{comment}{ * 1.0  12 Feb 2003     - First version}
00024 \textcolor{comment}{ * 1.1  16 Feb 2003     - Fixed distance check for > 4 GB uncompressed data}
00025 \textcolor{comment}{ * 1.2  24 Oct 2012     - Add note about using binary mode in stdio}
00026 \textcolor{comment}{ *                      - Fix comparisons of differently signed integers}
00027 \textcolor{comment}{ * 1.3  24 Aug 2013     - Return unused input from blast()}
00028 \textcolor{comment}{ *                      - Fix test code to correctly report unused input}
00029 \textcolor{comment}{ *                      - Enable the provision of initial input to blast()}
00030 \textcolor{comment}{ */}
00031 
00032 \textcolor{preprocessor}{#include <stddef.h>}             \textcolor{comment}{/* for NULL */}
00033 \textcolor{preprocessor}{#include <setjmp.h>}             \textcolor{comment}{/* for setjmp(), longjmp(), and jmp\_buf */}
00034 \textcolor{preprocessor}{#include "blast.h"}              \textcolor{comment}{/* prototype for blast() */}
00035 
00036 \textcolor{preprocessor}{#define local static            }\textcolor{comment}{/* for local function definitions */}\textcolor{preprocessor}{}
00037 \textcolor{preprocessor}{#define MAXBITS 13              }\textcolor{comment}{/* maximum code length */}\textcolor{preprocessor}{}
00038 \textcolor{preprocessor}{#define MAXWIN 4096             }\textcolor{comment}{/* maximum window size */}\textcolor{preprocessor}{}
00039 
00040 \textcolor{comment}{/* input and output state */}
00041 \textcolor{keyword}{struct }\hyperlink{structstate}{state} \{
00042     \textcolor{comment}{/* input state */}
00043     blast\_in infun;             \textcolor{comment}{/* input function provided by user */}
00044     \textcolor{keywordtype}{void} *inhow;                \textcolor{comment}{/* opaque information passed to infun() */}
00045     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *in;          \textcolor{comment}{/* next input location */}
00046     \textcolor{keywordtype}{unsigned} left;              \textcolor{comment}{/* available input at in */}
00047     \textcolor{keywordtype}{int} bitbuf;                 \textcolor{comment}{/* bit buffer */}
00048     \textcolor{keywordtype}{int} bitcnt;                 \textcolor{comment}{/* number of bits in bit buffer */}
00049 
00050     \textcolor{comment}{/* input limit error return state for bits() and decode() */}
00051     jmp\_buf env;
00052 
00053     \textcolor{comment}{/* output state */}
00054     blast\_out outfun;           \textcolor{comment}{/* output function provided by user */}
00055     \textcolor{keywordtype}{void} *outhow;               \textcolor{comment}{/* opaque information passed to outfun() */}
00056     \textcolor{keywordtype}{unsigned} next;              \textcolor{comment}{/* index of next write location in out[] */}
00057     \textcolor{keywordtype}{int} first;                  \textcolor{comment}{/* true to check distances (for first 4K) */}
00058     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} out[MAXWIN];  \textcolor{comment}{/* output buffer and sliding window */}
00059 \};
00060 
00061 \textcolor{comment}{/*}
00062 \textcolor{comment}{ * Return need bits from the input stream.  This always leaves less than}
00063 \textcolor{comment}{ * eight bits in the buffer.  bits() works properly for need == 0.}
00064 \textcolor{comment}{ *}
00065 \textcolor{comment}{ * Format notes:}
00066 \textcolor{comment}{ *}
00067 \textcolor{comment}{ * - Bits are stored in bytes from the least significant bit to the most}
00068 \textcolor{comment}{ *   significant bit.  Therefore bits are dropped from the bottom of the bit}
00069 \textcolor{comment}{ *   buffer, using shift right, and new bytes are appended to the top of the}
00070 \textcolor{comment}{ *   bit buffer, using shift left.}
00071 \textcolor{comment}{ */}
00072 local \textcolor{keywordtype}{int} bits(\textcolor{keyword}{struct} \hyperlink{structstate}{state} *s, \textcolor{keywordtype}{int} need)
00073 \{
00074     \textcolor{keywordtype}{int} val;            \textcolor{comment}{/* bit accumulator */}
00075 
00076     \textcolor{comment}{/* load at least need bits into val */}
00077     val = s->bitbuf;
00078     \textcolor{keywordflow}{while} (s->bitcnt < need) \{
00079         \textcolor{keywordflow}{if} (s->left == 0) \{
00080             s->left = s->infun(s->inhow, &(s->in));
00081             \textcolor{keywordflow}{if} (s->left == 0) longjmp(s->env, 1);       \textcolor{comment}{/* out of input */}
00082         \}
00083         val |= (int)(*(s->in)++) << s->bitcnt;          \textcolor{comment}{/* load eight bits */}
00084         s->left--;
00085         s->bitcnt += 8;
00086     \}
00087 
00088     \textcolor{comment}{/* drop need bits and update buffer, always zero to seven bits left */}
00089     s->bitbuf = val >> need;
00090     s->bitcnt -= need;
00091 
00092     \textcolor{comment}{/* return need bits, zeroing the bits above that */}
00093     \textcolor{keywordflow}{return} val & ((1 << need) - 1);
00094 \}
00095 
00096 \textcolor{comment}{/*}
00097 \textcolor{comment}{ * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of}
00098 \textcolor{comment}{ * each length, which for a canonical code are stepped through in order.}
00099 \textcolor{comment}{ * symbol[] are the symbol values in canonical order, where the number of}
00100 \textcolor{comment}{ * entries is the sum of the counts in count[].  The decoding process can be}
00101 \textcolor{comment}{ * seen in the function decode() below.}
00102 \textcolor{comment}{ */}
00103 \textcolor{keyword}{struct }\hyperlink{structhuffman}{huffman} \{
00104     \textcolor{keywordtype}{short} *count;       \textcolor{comment}{/* number of symbols of each length */}
00105     \textcolor{keywordtype}{short} *symbol;      \textcolor{comment}{/* canonically ordered symbols */}
00106 \};
00107 
00108 \textcolor{comment}{/*}
00109 \textcolor{comment}{ * Decode a code from the stream s using huffman table h.  Return the symbol or}
00110 \textcolor{comment}{ * a negative value if there is an error.  If all of the lengths are zero, i.e.}
00111 \textcolor{comment}{ * an empty code, or if the code is incomplete and an invalid code is received,}
00112 \textcolor{comment}{ * then -9 is returned after reading MAXBITS bits.}
00113 \textcolor{comment}{ *}
00114 \textcolor{comment}{ * Format notes:}
00115 \textcolor{comment}{ *}
00116 \textcolor{comment}{ * - The codes as stored in the compressed data are bit-reversed relative to}
00117 \textcolor{comment}{ *   a simple integer ordering of codes of the same lengths.  Hence below the}
00118 \textcolor{comment}{ *   bits are pulled from the compressed data one at a time and used to}
00119 \textcolor{comment}{ *   build the code value reversed from what is in the stream in order to}
00120 \textcolor{comment}{ *   permit simple integer comparisons for decoding.}
00121 \textcolor{comment}{ *}
00122 \textcolor{comment}{ * - The first code for the shortest length is all ones.  Subsequent codes of}
00123 \textcolor{comment}{ *   the same length are simply integer decrements of the previous code.  When}
00124 \textcolor{comment}{ *   moving up a length, a one bit is appended to the code.  For a complete}
00125 \textcolor{comment}{ *   code, the last code of the longest length will be all zeros.  To support}
00126 \textcolor{comment}{ *   this ordering, the bits pulled during decoding are inverted to apply the}
00127 \textcolor{comment}{ *   more "natural" ordering starting with all zeros and incrementing.}
00128 \textcolor{comment}{ */}
00129 local \textcolor{keywordtype}{int} decode(\textcolor{keyword}{struct} \hyperlink{structstate}{state} *s, \textcolor{keyword}{struct} \hyperlink{structhuffman}{huffman} *h)
00130 \{
00131     \textcolor{keywordtype}{int} len;            \textcolor{comment}{/* current number of bits in code */}
00132     \textcolor{keywordtype}{int} \hyperlink{structcode}{code};           \textcolor{comment}{/* len bits being decoded */}
00133     \textcolor{keywordtype}{int} first;          \textcolor{comment}{/* first code of length len */}
00134     \textcolor{keywordtype}{int} count;          \textcolor{comment}{/* number of codes of length len */}
00135     \textcolor{keywordtype}{int} index;          \textcolor{comment}{/* index of first code of length len in symbol table */}
00136     \textcolor{keywordtype}{int} bitbuf;         \textcolor{comment}{/* bits from stream */}
00137     \textcolor{keywordtype}{int} left;           \textcolor{comment}{/* bits left in next or left to process */}
00138     \textcolor{keywordtype}{short} *next;        \textcolor{comment}{/* next number of codes */}
00139 
00140     bitbuf = s->bitbuf;
00141     left = s->bitcnt;
00142     code = first = index = 0;
00143     len = 1;
00144     next = h->count + 1;
00145     \textcolor{keywordflow}{while} (1) \{
00146         \textcolor{keywordflow}{while} (left--) \{
00147             code |= (bitbuf & 1) ^ 1;   \textcolor{comment}{/* invert code */}
00148             bitbuf >>= 1;
00149             count = *next++;
00150             \textcolor{keywordflow}{if} (code < first + count) \{ \textcolor{comment}{/* if length len, return symbol */}
00151                 s->bitbuf = bitbuf;
00152                 s->bitcnt = (s->bitcnt - len) & 7;
00153                 \textcolor{keywordflow}{return} h->symbol[index + (code - first)];
00154             \}
00155             index += count;             \textcolor{comment}{/* else update for next length */}
00156             first += count;
00157             first <<= 1;
00158             code <<= 1;
00159             len++;
00160         \}
00161         left = (MAXBITS+1) - len;
00162         \textcolor{keywordflow}{if} (left == 0) \textcolor{keywordflow}{break};
00163         \textcolor{keywordflow}{if} (s->left == 0) \{
00164             s->left = s->infun(s->inhow, &(s->in));
00165             \textcolor{keywordflow}{if} (s->left == 0) longjmp(s->env, 1);       \textcolor{comment}{/* out of input */}
00166         \}
00167         bitbuf = *(s->in)++;
00168         s->left--;
00169         \textcolor{keywordflow}{if} (left > 8) left = 8;
00170     \}
00171     \textcolor{keywordflow}{return} -9;                          \textcolor{comment}{/* ran out of codes */}
00172 \}
00173 
00174 \textcolor{comment}{/*}
00175 \textcolor{comment}{ * Given a list of repeated code lengths rep[0..n-1], where each byte is a}
00176 \textcolor{comment}{ * count (high four bits + 1) and a code length (low four bits), generate the}
00177 \textcolor{comment}{ * list of code lengths.  This compaction reduces the size of the object code.}
00178 \textcolor{comment}{ * Then given the list of code lengths length[0..n-1] representing a canonical}
00179 \textcolor{comment}{ * Huffman code for n symbols, construct the tables required to decode those}
00180 \textcolor{comment}{ * codes.  Those tables are the number of codes of each length, and the symbols}
00181 \textcolor{comment}{ * sorted by length, retaining their original order within each length.  The}
00182 \textcolor{comment}{ * return value is zero for a complete code set, negative for an over-}
00183 \textcolor{comment}{ * subscribed code set, and positive for an incomplete code set.  The tables}
00184 \textcolor{comment}{ * can be used if the return value is zero or positive, but they cannot be used}
00185 \textcolor{comment}{ * if the return value is negative.  If the return value is zero, it is not}
00186 \textcolor{comment}{ * possible for decode() using that table to return an error--any stream of}
00187 \textcolor{comment}{ * enough bits will resolve to a symbol.  If the return value is positive, then}
00188 \textcolor{comment}{ * it is possible for decode() using that table to return an error for received}
00189 \textcolor{comment}{ * codes past the end of the incomplete lengths.}
00190 \textcolor{comment}{ */}
00191 local \textcolor{keywordtype}{int} construct(\textcolor{keyword}{struct} \hyperlink{structhuffman}{huffman} *h, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *rep, \textcolor{keywordtype}{int} n)
00192 \{
00193     \textcolor{keywordtype}{int} symbol;         \textcolor{comment}{/* current symbol when stepping through length[] */}
00194     \textcolor{keywordtype}{int} len;            \textcolor{comment}{/* current length when stepping through h->count[] */}
00195     \textcolor{keywordtype}{int} left;           \textcolor{comment}{/* number of possible codes left of current length */}
00196     \textcolor{keywordtype}{short} offs[MAXBITS+1];      \textcolor{comment}{/* offsets in symbol table for each length */}
00197     \textcolor{keywordtype}{short} length[256];  \textcolor{comment}{/* code lengths */}
00198 
00199     \textcolor{comment}{/* convert compact repeat counts into symbol bit length list */}
00200     symbol = 0;
00201     \textcolor{keywordflow}{do} \{
00202         len = *rep++;
00203         left = (len >> 4) + 1;
00204         len &= 15;
00205         \textcolor{keywordflow}{do} \{
00206             length[symbol++] = len;
00207         \} \textcolor{keywordflow}{while} (--left);
00208     \} \textcolor{keywordflow}{while} (--n);
00209     n = symbol;
00210 
00211     \textcolor{comment}{/* count number of codes of each length */}
00212     \textcolor{keywordflow}{for} (len = 0; len <= MAXBITS; len++)
00213         h->count[len] = 0;
00214     for (symbol = 0; symbol < n; symbol++)
00215         (h->count[length[symbol]])++;   \textcolor{comment}{/* assumes lengths are within bounds */}
00216     \textcolor{keywordflow}{if} (h->count[0] == n)               \textcolor{comment}{/* no codes! */}
00217         \textcolor{keywordflow}{return} 0;                       \textcolor{comment}{/* complete, but decode() will fail */}
00218 
00219     \textcolor{comment}{/* check for an over-subscribed or incomplete set of lengths */}
00220     left = 1;                           \textcolor{comment}{/* one possible code of zero length */}
00221     \textcolor{keywordflow}{for} (len = 1; len <= MAXBITS; len++) \{
00222         left <<= 1;                     \textcolor{comment}{/* one more bit, double codes left */}
00223         left -= h->count[len];          \textcolor{comment}{/* deduct count from possible codes */}
00224         \textcolor{keywordflow}{if} (left < 0) \textcolor{keywordflow}{return} left;      \textcolor{comment}{/* over-subscribed--return negative */}
00225     \}                                   \textcolor{comment}{/* left > 0 means incomplete */}
00226 
00227     \textcolor{comment}{/* generate offsets into symbol table for each length for sorting */}
00228     offs[1] = 0;
00229     \textcolor{keywordflow}{for} (len = 1; len < MAXBITS; len++)
00230         offs[len + 1] = offs[len] + h->count[len];
00231 
00232     \textcolor{comment}{/*}
00233 \textcolor{comment}{     * put symbols in table sorted by length, by symbol order within each}
00234 \textcolor{comment}{     * length}
00235 \textcolor{comment}{     */}
00236     for (symbol = 0; symbol < n; symbol++)
00237         \textcolor{keywordflow}{if} (length[symbol] != 0)
00238             h->symbol[offs[length[symbol]]++] = symbol;
00239 
00240     \textcolor{comment}{/* return zero for complete set, positive for incomplete set */}
00241     \textcolor{keywordflow}{return} left;
00242 \}
00243 
00244 \textcolor{comment}{/*}
00245 \textcolor{comment}{ * Decode PKWare Compression Library stream.}
00246 \textcolor{comment}{ *}
00247 \textcolor{comment}{ * Format notes:}
00248 \textcolor{comment}{ *}
00249 \textcolor{comment}{ * - First byte is 0 if literals are uncoded or 1 if they are coded.  Second}
00250 \textcolor{comment}{ *   byte is 4, 5, or 6 for the number of extra bits in the distance code.}
00251 \textcolor{comment}{ *   This is the base-2 logarithm of the dictionary size minus six.}
00252 \textcolor{comment}{ *}
00253 \textcolor{comment}{ * - Compressed data is a combination of literals and length/distance pairs}
00254 \textcolor{comment}{ *   terminated by an end code.  Literals are either Huffman coded or}
00255 \textcolor{comment}{ *   uncoded bytes.  A length/distance pair is a coded length followed by a}
00256 \textcolor{comment}{ *   coded distance to represent a string that occurs earlier in the}
00257 \textcolor{comment}{ *   uncompressed data that occurs again at the current location.}
00258 \textcolor{comment}{ *}
00259 \textcolor{comment}{ * - A bit preceding a literal or length/distance pair indicates which comes}
00260 \textcolor{comment}{ *   next, 0 for literals, 1 for length/distance.}
00261 \textcolor{comment}{ *}
00262 \textcolor{comment}{ * - If literals are uncoded, then the next eight bits are the literal, in the}
00263 \textcolor{comment}{ *   normal bit order in the stream, i.e. no bit-reversal is needed. Similarly,}
00264 \textcolor{comment}{ *   no bit reversal is needed for either the length extra bits or the distance}
00265 \textcolor{comment}{ *   extra bits.}
00266 \textcolor{comment}{ *}
00267 \textcolor{comment}{ * - Literal bytes are simply written to the output.  A length/distance pair is}
00268 \textcolor{comment}{ *   an instruction to copy previously uncompressed bytes to the output.  The}
00269 \textcolor{comment}{ *   copy is from distance bytes back in the output stream, copying for length}
00270 \textcolor{comment}{ *   bytes.}
00271 \textcolor{comment}{ *}
00272 \textcolor{comment}{ * - Distances pointing before the beginning of the output data are not}
00273 \textcolor{comment}{ *   permitted.}
00274 \textcolor{comment}{ *}
00275 \textcolor{comment}{ * - Overlapped copies, where the length is greater than the distance, are}
00276 \textcolor{comment}{ *   allowed and common.  For example, a distance of one and a length of 518}
00277 \textcolor{comment}{ *   simply copies the last byte 518 times.  A distance of four and a length of}
00278 \textcolor{comment}{ *   twelve copies the last four bytes three times.  A simple forward copy}
00279 \textcolor{comment}{ *   ignoring whether the length is greater than the distance or not implements}
00280 \textcolor{comment}{ *   this correctly.}
00281 \textcolor{comment}{ */}
00282 local \textcolor{keywordtype}{int} decomp(\textcolor{keyword}{struct} \hyperlink{structstate}{state} *s)
00283 \{
00284     \textcolor{keywordtype}{int} lit;            \textcolor{comment}{/* true if literals are coded */}
00285     \textcolor{keywordtype}{int} dict;           \textcolor{comment}{/* log2(dictionary size) - 6 */}
00286     \textcolor{keywordtype}{int} symbol;         \textcolor{comment}{/* decoded symbol, extra bits for distance */}
00287     \textcolor{keywordtype}{int} len;            \textcolor{comment}{/* length for copy */}
00288     \textcolor{keywordtype}{unsigned} dist;      \textcolor{comment}{/* distance for copy */}
00289     \textcolor{keywordtype}{int} copy;           \textcolor{comment}{/* copy counter */}
00290     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *from, *to;   \textcolor{comment}{/* copy pointers */}
00291     \textcolor{keyword}{static} \textcolor{keywordtype}{int} virgin = 1;                              \textcolor{comment}{/* build tables once */}
00292     \textcolor{keyword}{static} \textcolor{keywordtype}{short} litcnt[MAXBITS+1], litsym[256];        \textcolor{comment}{/* litcode memory */}
00293     \textcolor{keyword}{static} \textcolor{keywordtype}{short} lencnt[MAXBITS+1], lensym[16];         \textcolor{comment}{/* lencode memory */}
00294     \textcolor{keyword}{static} \textcolor{keywordtype}{short} distcnt[MAXBITS+1], distsym[64];       \textcolor{comment}{/* distcode memory */}
00295     \textcolor{keyword}{static} \textcolor{keyword}{struct }\hyperlink{structhuffman}{huffman} litcode = \{litcnt, litsym\};   \textcolor{comment}{/* length code */}
00296     \textcolor{keyword}{static} \textcolor{keyword}{struct }\hyperlink{structhuffman}{huffman} lencode = \{lencnt, lensym\};   \textcolor{comment}{/* length code */}
00297     \textcolor{keyword}{static} \textcolor{keyword}{struct }\hyperlink{structhuffman}{huffman} distcode = \{distcnt, distsym\};\textcolor{comment}{/* distance code */}
00298         \textcolor{comment}{/* bit lengths of literal codes */}
00299     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} litlen[] = \{
00300         11, 124, 8, 7, 28, 7, 188, 13, 76, 4, 10, 8, 12, 10, 12, 10, 8, 23, 8,
00301         9, 7, 6, 7, 8, 7, 6, 55, 8, 23, 24, 12, 11, 7, 9, 11, 12, 6, 7, 22, 5,
00302         7, 24, 6, 11, 9, 6, 7, 22, 7, 11, 38, 7, 9, 8, 25, 11, 8, 11, 9, 12,
00303         8, 12, 5, 38, 5, 38, 5, 11, 7, 5, 6, 21, 6, 10, 53, 8, 7, 24, 10, 27,
00304         44, 253, 253, 253, 252, 252, 252, 13, 12, 45, 12, 45, 12, 61, 12, 45,
00305         44, 173\};
00306         \textcolor{comment}{/* bit lengths of length codes 0..15 */}
00307     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} lenlen[] = \{2, 35, 36, 53, 38, 23\};
00308         \textcolor{comment}{/* bit lengths of distance codes 0..63 */}
00309     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} distlen[] = \{2, 20, 53, 230, 247, 151, 248\};
00310     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{short} base[16] = \{     \textcolor{comment}{/* base for length codes */}
00311         3, 2, 4, 5, 6, 7, 8, 9, 10, 12, 16, 24, 40, 72, 136, 264\};
00312     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} extra[16] = \{     \textcolor{comment}{/* extra bits for length codes */}
00313         0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8\};
00314 
00315     \textcolor{comment}{/* set up decoding tables (once--might not be thread-safe) */}
00316     \textcolor{keywordflow}{if} (virgin) \{
00317         construct(&litcode, litlen, \textcolor{keyword}{sizeof}(litlen));
00318         construct(&lencode, lenlen, \textcolor{keyword}{sizeof}(lenlen));
00319         construct(&distcode, distlen, \textcolor{keyword}{sizeof}(distlen));
00320         virgin = 0;
00321     \}
00322 
00323     \textcolor{comment}{/* read header */}
00324     lit = bits(s, 8);
00325     \textcolor{keywordflow}{if} (lit > 1) \textcolor{keywordflow}{return} -1;
00326     dict = bits(s, 8);
00327     \textcolor{keywordflow}{if} (dict < 4 || dict > 6) \textcolor{keywordflow}{return} -2;
00328 
00329     \textcolor{comment}{/* decode literals and length/distance pairs */}
00330     \textcolor{keywordflow}{do} \{
00331         \textcolor{keywordflow}{if} (bits(s, 1)) \{
00332             \textcolor{comment}{/* get length */}
00333             symbol = decode(s, &lencode);
00334             len = base[symbol] + bits(s, extra[symbol]);
00335             \textcolor{keywordflow}{if} (len == 519) \textcolor{keywordflow}{break};              \textcolor{comment}{/* end code */}
00336 
00337             \textcolor{comment}{/* get distance */}
00338             symbol = len == 2 ? 2 : dict;
00339             dist = decode(s, &distcode) << symbol;
00340             dist += bits(s, symbol);
00341             dist++;
00342             \textcolor{keywordflow}{if} (s->first && dist > s->next)
00343                 \textcolor{keywordflow}{return} -3;              \textcolor{comment}{/* distance too far back */}
00344 
00345             \textcolor{comment}{/* copy length bytes from distance bytes back */}
00346             \textcolor{keywordflow}{do} \{
00347                 to = s->out + s->next;
00348                 from = to - dist;
00349                 copy = MAXWIN;
00350                 \textcolor{keywordflow}{if} (s->next < dist) \{
00351                     from += copy;
00352                     copy = dist;
00353                 \}
00354                 copy -= s->next;
00355                 \textcolor{keywordflow}{if} (copy > len) copy = len;
00356                 len -= copy;
00357                 s->next += copy;
00358                 \textcolor{keywordflow}{do} \{
00359                     *to++ = *from++;
00360                 \} \textcolor{keywordflow}{while} (--copy);
00361                 \textcolor{keywordflow}{if} (s->next == MAXWIN) \{
00362                     \textcolor{keywordflow}{if} (s->outfun(s->outhow, s->out, s->next)) \textcolor{keywordflow}{return} 1;
00363                     s->next = 0;
00364                     s->first = 0;
00365                 \}
00366             \} \textcolor{keywordflow}{while} (len != 0);
00367         \}
00368         \textcolor{keywordflow}{else} \{
00369             \textcolor{comment}{/* get literal and write it */}
00370             symbol = lit ? decode(s, &litcode) : bits(s, 8);
00371             s->out[s->next++] = symbol;
00372             \textcolor{keywordflow}{if} (s->next == MAXWIN) \{
00373                 \textcolor{keywordflow}{if} (s->outfun(s->outhow, s->out, s->next)) \textcolor{keywordflow}{return} 1;
00374                 s->next = 0;
00375                 s->first = 0;
00376             \}
00377         \}
00378     \} \textcolor{keywordflow}{while} (1);
00379     \textcolor{keywordflow}{return} 0;
00380 \}
00381 
00382 \textcolor{comment}{/* See comments in blast.h */}
00383 \textcolor{keywordtype}{int} blast(blast\_in infun, \textcolor{keywordtype}{void} *inhow, blast\_out outfun, \textcolor{keywordtype}{void} *outhow,
00384           \textcolor{keywordtype}{unsigned} *left, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **in)
00385 \{
00386     \textcolor{keyword}{struct }\hyperlink{structstate}{state} s;             \textcolor{comment}{/* input/output state */}
00387     \textcolor{keywordtype}{int} err;                    \textcolor{comment}{/* return value */}
00388 
00389     \textcolor{comment}{/* initialize input state */}
00390     s.infun = infun;
00391     s.inhow = inhow;
00392     \textcolor{keywordflow}{if} (left != NULL && *left) \{
00393         s.left = *left;
00394         s.in = *in;
00395     \}
00396     \textcolor{keywordflow}{else}
00397         s.left = 0;
00398     s.bitbuf = 0;
00399     s.bitcnt = 0;
00400 
00401     \textcolor{comment}{/* initialize output state */}
00402     s.outfun = outfun;
00403     s.outhow = outhow;
00404     s.next = 0;
00405     s.first = 1;
00406 
00407     \textcolor{comment}{/* return if bits() or decode() tries to read past available input */}
00408     \textcolor{keywordflow}{if} (setjmp(s.env) != 0)             \textcolor{comment}{/* if came back here via longjmp(), */}
00409         err = 2;                        \textcolor{comment}{/*  then skip decomp(), return error */}
00410     \textcolor{keywordflow}{else}
00411         err = decomp(&s);               \textcolor{comment}{/* decompress */}
00412 
00413     \textcolor{comment}{/* return unused input */}
00414     \textcolor{keywordflow}{if} (left != NULL)
00415         *left = s.left;
00416     \textcolor{keywordflow}{if} (in != NULL)
00417         *in = s.left ? s.in : NULL;
00418 
00419     \textcolor{comment}{/* write any leftover output and update the error code if needed */}
00420     \textcolor{keywordflow}{if} (err != 1 && s.next && s.outfun(s.outhow, s.out, s.next) && err == 0)
00421         err = 1;
00422     \textcolor{keywordflow}{return} err;
00423 \}
00424 
00425 \textcolor{preprocessor}{#ifdef TEST}
00426 \textcolor{comment}{/* Example of how to use blast() */}
00427 \textcolor{preprocessor}{#include <stdio.h>}
00428 \textcolor{preprocessor}{#include <stdlib.h>}
00429 
00430 \textcolor{preprocessor}{#define CHUNK 16384}
00431 
00432 local \textcolor{keywordtype}{unsigned} inf(\textcolor{keywordtype}{void} *how, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **buf)
00433 \{
00434     \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} hold[CHUNK];
00435 
00436     *buf = hold;
00437     \textcolor{keywordflow}{return} fread(hold, 1, CHUNK, (FILE *)how);
00438 \}
00439 
00440 local \textcolor{keywordtype}{int} outf(\textcolor{keywordtype}{void} *how, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf, \textcolor{keywordtype}{unsigned} len)
00441 \{
00442     \textcolor{keywordflow}{return} fwrite(buf, 1, len, (FILE *)how) != len;
00443 \}
00444 
00445 \textcolor{comment}{/* Decompress a PKWare Compression Library stream from stdin to stdout */}
00446 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{void})
00447 \{
00448     \textcolor{keywordtype}{int} ret;
00449     \textcolor{keywordtype}{unsigned} left;
00450 
00451     \textcolor{comment}{/* decompress to stdout */}
00452     left = 0;
00453     ret = blast(inf, stdin, outf, stdout, &left, NULL);
00454     \textcolor{keywordflow}{if} (ret != 0)
00455         fprintf(stderr, \textcolor{stringliteral}{"blast error: %d\(\backslash\)n"}, ret);
00456 
00457     \textcolor{comment}{/* count any leftover bytes */}
00458     \textcolor{keywordflow}{while} (getchar() != EOF)
00459         left++;
00460     \textcolor{keywordflow}{if} (left)
00461         fprintf(stderr, \textcolor{stringliteral}{"blast warning: %u unused bytes of input\(\backslash\)n"}, left);
00462 
00463     \textcolor{comment}{/* return blast() error code */}
00464     \textcolor{keywordflow}{return} ret;
00465 \}
00466 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
