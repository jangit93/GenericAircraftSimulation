\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_core_evaluators_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/\+Core\+Evaluators.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_core_evaluators_8h_source}\index{Core\+Evaluators.\+h@{Core\+Evaluators.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2011 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2011-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{// Copyright (C) 2011-2012 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00007 \textcolor{comment}{//}
00008 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00009 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00010 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00011 
00012 
00013 \textcolor{preprocessor}{#ifndef EIGEN\_COREEVALUATORS\_H}
00014 \textcolor{preprocessor}{#define EIGEN\_COREEVALUATORS\_H}
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00017   
00018 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00019 
00020 \textcolor{comment}{// This class returns the evaluator kind from the expression storage kind.}
00021 \textcolor{comment}{// Default assumes index based accessors}
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StorageKind>
00023 \textcolor{keyword}{struct }storage\_kind\_to\_evaluator\_kind \{
00024   \textcolor{keyword}{typedef} IndexBased Kind;
00025 \};
00026 
00027 \textcolor{comment}{// This class returns the evaluator shape from the expression storage kind.}
00028 \textcolor{comment}{// It can be Dense, Sparse, Triangular, Diagonal, SelfAdjoint, Band, etc.}
00029 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StorageKind> \textcolor{keyword}{struct }storage\_kind\_to\_shape;
00030 
00031 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }storage\_kind\_to\_shape<Dense>                  \{ \textcolor{keyword}{typedef} DenseShape Shape;           \};
00032 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }storage\_kind\_to\_shape<SolverStorage>          \{ \textcolor{keyword}{typedef} SolverShape Shape;           \};
00033 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }storage\_kind\_to\_shape<PermutationStorage>     \{ \textcolor{keyword}{typedef} PermutationShape Shape;     \};
00034 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }storage\_kind\_to\_shape<TranspositionsStorage>  \{ \textcolor{keyword}{typedef} TranspositionsShape Shape;  \};
00035 
00036 \textcolor{comment}{// Evaluators have to be specialized with respect to various criteria such as:}
00037 \textcolor{comment}{//  - storage/structure/shape}
00038 \textcolor{comment}{//  - scalar type}
00039 \textcolor{comment}{//  - etc.}
00040 \textcolor{comment}{// Therefore, we need specialization of evaluator providing additional template arguments for each kind of
       evaluators.}
00041 \textcolor{comment}{// We currently distinguish the following kind of evaluators:}
00042 \textcolor{comment}{// - unary\_evaluator    for expressions taking only one arguments (CwiseUnaryOp, CwiseUnaryView, Transpose,
       MatrixWrapper, ArrayWrapper, Reverse, Replicate)}
00043 \textcolor{comment}{// - binary\_evaluator   for expression taking two arguments (CwiseBinaryOp)}
00044 \textcolor{comment}{// - ternary\_evaluator   for expression taking three arguments (CwiseTernaryOp)}
00045 \textcolor{comment}{// - product\_evaluator  for linear algebra products (Product); special case of binary\_evaluator because it
       requires additional tags for dispatching.}
00046 \textcolor{comment}{// - mapbase\_evaluator  for Map, Block, Ref}
00047 \textcolor{comment}{// - block\_evaluator    for Block (special dispatching to a mapbase\_evaluator or unary\_evaluator)}
00048 
00049 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T},
00050           \textcolor{keyword}{typename} Arg1Kind   = \textcolor{keyword}{typename} evaluator\_traits<typename T::Arg1>::Kind,
00051           \textcolor{keyword}{typename} Arg2Kind   = \textcolor{keyword}{typename} evaluator\_traits<typename T::Arg2>::Kind,
00052           \textcolor{keyword}{typename} Arg3Kind   = \textcolor{keyword}{typename} evaluator\_traits<typename T::Arg3>::Kind,
00053           \textcolor{keyword}{typename} Arg1Scalar = \textcolor{keyword}{typename} traits<typename T::Arg1>::Scalar,
00054           \textcolor{keyword}{typename} Arg2Scalar = \textcolor{keyword}{typename} traits<typename T::Arg2>::Scalar,
00055           \textcolor{keyword}{typename} Arg3Scalar = \textcolor{keyword}{typename} traits<typename T::Arg3>::Scalar> \textcolor{keyword}{struct }ternary\_evaluator;
00056 
00057 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T},
00058           \textcolor{keyword}{typename} LhsKind   = \textcolor{keyword}{typename} evaluator\_traits<typename T::Lhs>::Kind,
00059           \textcolor{keyword}{typename} RhsKind   = \textcolor{keyword}{typename} evaluator\_traits<typename T::Rhs>::Kind,
00060           \textcolor{keyword}{typename} LhsScalar = \textcolor{keyword}{typename} traits<typename T::Lhs>::Scalar,
00061           \textcolor{keyword}{typename} RhsScalar = \textcolor{keyword}{typename} traits<typename T::Rhs>::Scalar> \textcolor{keyword}{struct }binary\_evaluator;
00062 
00063 \textcolor{keyword}{template}< \textcolor{keyword}{typename} T,
00064           \textcolor{keyword}{typename} Kind   = \textcolor{keyword}{typename} evaluator\_traits<typename T::NestedExpression>::Kind,
00065           \textcolor{keyword}{typename} Scalar = \textcolor{keyword}{typename} T::Scalar> \textcolor{keyword}{struct }unary\_evaluator;
00066           
00067 \textcolor{comment}{// evaluator\_traits<T> contains traits for evaluator<T> }
00068 
00069 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00070 \textcolor{keyword}{struct }evaluator\_traits\_base
00071 \{
00072   \textcolor{comment}{// by default, get evaluator kind and shape from storage}
00073   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} storage\_kind\_to\_evaluator\_kind<typename traits<T>::StorageKind>::Kind Kind;
00074   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} storage\_kind\_to\_shape<typename traits<T>::StorageKind>::Shape Shape;
00075 \};
00076 
00077 \textcolor{comment}{// Default evaluator traits}
00078 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00079 \textcolor{keyword}{struct }evaluator\_traits : \textcolor{keyword}{public} evaluator\_traits\_base<T>
00080 \{
00081 \};
00082 
00083 template<typename T, typename Shape = typename evaluator\_traits<T>::Shape >
00084 \textcolor{keyword}{struct }evaluator\_assume\_aliasing \{
00085   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false};
00086 \};
00087 
00088 \textcolor{comment}{// By default, we assume a unary expression:}
00089 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00090 \textcolor{keyword}{struct }evaluator : \textcolor{keyword}{public} unary\_evaluator<T>
00091 \{
00092   \textcolor{keyword}{typedef} unary\_evaluator<T> Base;
00093   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} T& xpr) : Base(xpr) \{\}
00094 \};
00095 
00096 
00097 \textcolor{comment}{// TODO: Think about const-correctness}
00098 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00099 \textcolor{keyword}{struct }evaluator<const T>
00100   : evaluator<T>
00101 \{
00102   EIGEN\_DEVICE\_FUNC
00103   \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} T& xpr) : evaluator<T>(xpr) \{\}
00104 \};
00105 
00106 \textcolor{comment}{// ---------- base class for all evaluators ----------}
00107 
00108 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType>
00109 \textcolor{keyword}{struct }evaluator\_base : \textcolor{keyword}{public} noncopyable
00110 \{
00111   \textcolor{comment}{// TODO that's not very nice to have to propagate all these traits. They are currently only needed to
       handle outer,inner indices.}
00112   \textcolor{keyword}{typedef} traits<ExpressionType> ExpressionTraits;
00113   
00114   \textcolor{keyword}{enum} \{
00115     Alignment = 0
00116   \};
00117 \};
00118 
00119 \textcolor{comment}{// -------------------- Matrix and Array --------------------}
00120 \textcolor{comment}{//}
00121 \textcolor{comment}{// evaluator<PlainObjectBase> is a common base class for the}
00122 \textcolor{comment}{// Matrix and Array evaluators.}
00123 \textcolor{comment}{// Here we directly specialize evaluator. This is not really a unary expression, and it is, by definition,
       dense,}
00124 \textcolor{comment}{// so no need for more sophisticated dispatching.}
00125 
00126 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00127 \textcolor{keyword}{struct }evaluator<PlainObjectBase<Derived> >
00128   : evaluator\_base<Derived>
00129 \{
00130   \textcolor{keyword}{typedef} PlainObjectBase<Derived> PlainObjectType;
00131   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PlainObjectType::Scalar Scalar;
00132   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PlainObjectType::CoeffReturnType CoeffReturnType;
00133 
00134   \textcolor{keyword}{enum} \{
00135     IsRowMajor = PlainObjectType::IsRowMajor,
00136     IsVectorAtCompileTime = PlainObjectType::IsVectorAtCompileTime,
00137     RowsAtCompileTime = PlainObjectType::RowsAtCompileTime,
00138     ColsAtCompileTime = PlainObjectType::ColsAtCompileTime,
00139     
00140     CoeffReadCost = NumTraits<Scalar>::ReadCost,
00141     Flags = traits<Derived>::EvaluatorFlags,
00142     Alignment = traits<Derived>::Alignment
00143   \};
00144   
00145   EIGEN\_DEVICE\_FUNC evaluator()
00146     : m\_data(0),
00147       m\_outerStride(IsVectorAtCompileTime  ? 0 
00148                                            : int(IsRowMajor) ? ColsAtCompileTime 
00149                                            : RowsAtCompileTime)
00150   \{
00151     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00152   \}
00153   
00154   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} PlainObjectType& m)
00155     : m\_data(m.data()), m\_outerStride(IsVectorAtCompileTime ? 0 : m.outerStride()) 
00156   \{
00157     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00158   \}
00159 
00160   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00161   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00162 \textcolor{keyword}{  }\{
00163     \textcolor{keywordflow}{if} (IsRowMajor)
00164       \textcolor{keywordflow}{return} m\_data[row * m\_outerStride.value() + col];
00165     \textcolor{keywordflow}{else}
00166       \textcolor{keywordflow}{return} m\_data[row + col * m\_outerStride.value()];
00167   \}
00168 
00169   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00170   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00171 \textcolor{keyword}{  }\{
00172     \textcolor{keywordflow}{return} m\_data[index];
00173   \}
00174 
00175   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00176   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
00177   \{
00178     \textcolor{keywordflow}{if} (IsRowMajor)
00179       \textcolor{keywordflow}{return} \textcolor{keyword}{const\_cast<}Scalar*\textcolor{keyword}{>}(m\_data)[row * m\_outerStride.value() + col];
00180     \textcolor{keywordflow}{else}
00181       \textcolor{keywordflow}{return} \textcolor{keyword}{const\_cast<}Scalar*\textcolor{keyword}{>}(m\_data)[row + col * m\_outerStride.value()];
00182   \}
00183 
00184   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00185   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)
00186   \{
00187     \textcolor{keywordflow}{return} \textcolor{keyword}{const\_cast<}Scalar*\textcolor{keyword}{>}(m\_data)[index];
00188   \}
00189 
00190   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00191   EIGEN\_STRONG\_INLINE
00192   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00193 \textcolor{keyword}{  }\{
00194     \textcolor{keywordflow}{if} (IsRowMajor)
00195       \textcolor{keywordflow}{return} ploadt<PacketType, LoadMode>(m\_data + row * m\_outerStride.value() + col);
00196     \textcolor{keywordflow}{else}
00197       \textcolor{keywordflow}{return} ploadt<PacketType, LoadMode>(m\_data + row + col * m\_outerStride.value());
00198   \}
00199 
00200   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00201   EIGEN\_STRONG\_INLINE
00202   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00203 \textcolor{keyword}{  }\{
00204     \textcolor{keywordflow}{return} ploadt<PacketType, LoadMode>(m\_data + index);
00205   \}
00206 
00207   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode,\textcolor{keyword}{typename} PacketType>
00208   EIGEN\_STRONG\_INLINE
00209   \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col, \textcolor{keyword}{const} PacketType& x)
00210   \{
00211     \textcolor{keywordflow}{if} (IsRowMajor)
00212       \textcolor{keywordflow}{return} pstoret<Scalar, PacketType, StoreMode>
00213                 (\textcolor{keyword}{const\_cast<}Scalar*\textcolor{keyword}{>}(m\_data) + row * m\_outerStride.value() + col, x);
00214     \textcolor{keywordflow}{else}
00215       \textcolor{keywordflow}{return} pstoret<Scalar, PacketType, StoreMode>
00216                     (\textcolor{keyword}{const\_cast<}Scalar*\textcolor{keyword}{>}(m\_data) + row + col * m\_outerStride.value(), x);
00217   \}
00218 
00219   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode, \textcolor{keyword}{typename} PacketType>
00220   EIGEN\_STRONG\_INLINE
00221   \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index, \textcolor{keyword}{const} PacketType& x)
00222   \{
00223     \textcolor{keywordflow}{return} pstoret<Scalar, PacketType, StoreMode>(\textcolor{keyword}{const\_cast<}Scalar*\textcolor{keyword}{>}(m\_data) + index, x);
00224   \}
00225 
00226 \textcolor{keyword}{protected}:
00227   \textcolor{keyword}{const} Scalar *m\_data;
00228 
00229   \textcolor{comment}{// We do not need to know the outer stride for vectors}
00230   variable\_if\_dynamic<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, IsVectorAtCompileTime  ? 0 
00231                                                     : int(IsRowMajor) ? ColsAtCompileTime 
00232                                                     : RowsAtCompileTime> m\_outerStride;
00233 \};
00234 
00235 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Rows, \textcolor{keywordtype}{int} Cols, \textcolor{keywordtype}{int} Options, \textcolor{keywordtype}{int} MaxRows, \textcolor{keywordtype}{int} MaxCols>
00236 \textcolor{keyword}{struct }evaluator<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >
00237   : evaluator<PlainObjectBase<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> > >
00238 \{
00239   \textcolor{keyword}{typedef} Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;
00240   
00241   EIGEN\_DEVICE\_FUNC evaluator() \{\}
00242 
00243   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} XprType& m)
00244     : evaluator<PlainObjectBase<XprType> >(m) 
00245   \{ \}
00246 \};
00247 
00248 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Rows, \textcolor{keywordtype}{int} Cols, \textcolor{keywordtype}{int} Options, \textcolor{keywordtype}{int} MaxRows, \textcolor{keywordtype}{int} MaxCols>
00249 \textcolor{keyword}{struct }evaluator<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >
00250   : evaluator<PlainObjectBase<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> > >
00251 \{
00252   \textcolor{keyword}{typedef} Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;
00253 
00254   EIGEN\_DEVICE\_FUNC evaluator() \{\}
00255   
00256   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} XprType& m)
00257     : evaluator<PlainObjectBase<XprType> >(m) 
00258   \{ \}
00259 \};
00260 
00261 \textcolor{comment}{// -------------------- Transpose --------------------}
00262 
00263 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType>
00264 \textcolor{keyword}{struct }unary\_evaluator<Transpose<ArgType>, IndexBased>
00265   : evaluator\_base<Transpose<ArgType> >
00266 \{
00267   \textcolor{keyword}{typedef} Transpose<ArgType> XprType;
00268   
00269   \textcolor{keyword}{enum} \{
00270     CoeffReadCost = evaluator<ArgType>::CoeffReadCost,    
00271     Flags = evaluator<ArgType>::Flags ^ \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit},
00272     Alignment = evaluator<ArgType>::Alignment
00273   \};
00274 
00275   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} unary\_evaluator(\textcolor{keyword}{const} XprType& t) : m\_argImpl(t.nestedExpression()) \{\}
00276 
00277   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00278   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00279 
00280   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00281   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00282 \textcolor{keyword}{  }\{
00283     \textcolor{keywordflow}{return} m\_argImpl.coeff(col, row);
00284   \}
00285 
00286   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00287   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00288 \textcolor{keyword}{  }\{
00289     \textcolor{keywordflow}{return} m\_argImpl.coeff(index);
00290   \}
00291 
00292   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00293   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
00294   \{
00295     \textcolor{keywordflow}{return} m\_argImpl.coeffRef(col, row);
00296   \}
00297 
00298   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00299   \textcolor{keyword}{typename} XprType::Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)
00300   \{
00301     \textcolor{keywordflow}{return} m\_argImpl.coeffRef(index);
00302   \}
00303 
00304   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00305   EIGEN\_STRONG\_INLINE
00306   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00307 \textcolor{keyword}{  }\{
00308     \textcolor{keywordflow}{return} m\_argImpl.template packet<LoadMode,PacketType>(col, row);
00309   \}
00310 
00311   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00312   EIGEN\_STRONG\_INLINE
00313   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00314 \textcolor{keyword}{  }\{
00315     \textcolor{keywordflow}{return} m\_argImpl.template packet<LoadMode,PacketType>(index);
00316   \}
00317 
00318   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode, \textcolor{keyword}{typename} PacketType>
00319   EIGEN\_STRONG\_INLINE
00320   \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col, \textcolor{keyword}{const} PacketType& x)
00321   \{
00322     m\_argImpl.template writePacket<StoreMode,PacketType>(col, row, x);
00323   \}
00324 
00325   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode, \textcolor{keyword}{typename} PacketType>
00326   EIGEN\_STRONG\_INLINE
00327   \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index, \textcolor{keyword}{const} PacketType& x)
00328   \{
00329     m\_argImpl.template writePacket<StoreMode,PacketType>(index, x);
00330   \}
00331 
00332 \textcolor{keyword}{protected}:
00333   evaluator<ArgType> m\_argImpl;
00334 \};
00335 
00336 \textcolor{comment}{// -------------------- CwiseNullaryOp --------------------}
00337 \textcolor{comment}{// Like Matrix and Array, this is not really a unary expression, so we directly specialize evaluator.}
00338 \textcolor{comment}{// Likewise, there is not need to more sophisticated dispatching here.}
00339 
00340 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} NullaryOp,
00341          \textcolor{keywordtype}{bool} has\_nullary = has\_nullary\_operator<NullaryOp>::value,
00342          \textcolor{keywordtype}{bool} has\_unary   = has\_unary\_operator<NullaryOp>::value,
00343          \textcolor{keywordtype}{bool} has\_binary  = has\_binary\_operator<NullaryOp>::value>
00344 \textcolor{keyword}{struct }nullary\_wrapper
00345 \{
00346   \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00347   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar operator()(\textcolor{keyword}{const} NullaryOp& op, IndexType i, IndexType j)\textcolor{keyword}{
       const }\{ \textcolor{keywordflow}{return} op(i,j); \}
00348   \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00349   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar operator()(\textcolor{keyword}{const} NullaryOp& op, IndexType i)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 
      op(i); \}
00350 
00351   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} IndexType> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE T packetOp(\textcolor{keyword}{const} 
      NullaryOp& op, IndexType i, IndexType j)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} op.template packetOp<T>(i,j); \}
00352   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} IndexType> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE T packetOp(\textcolor{keyword}{const} 
      NullaryOp& op, IndexType i)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} op.template packetOp<T>(i); \}
00353 \};
00354 
00355 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} NullaryOp>
00356 \textcolor{keyword}{struct }nullary\_wrapper<Scalar,NullaryOp,true,false,false>
00357 \{
00358   \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00359   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar operator()(\textcolor{keyword}{const} NullaryOp& op, IndexType=0, IndexType=0)\textcolor{keyword}{
       const }\{ \textcolor{keywordflow}{return} op(); \}
00360   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} IndexType> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE T packetOp(\textcolor{keyword}{const} 
      NullaryOp& op, IndexType=0, IndexType=0)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} op.template packetOp<T>(); \}
00361 \};
00362 
00363 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} NullaryOp>
00364 \textcolor{keyword}{struct }nullary\_wrapper<Scalar,NullaryOp,false,false,true>
00365 \{
00366   \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00367   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar operator()(\textcolor{keyword}{const} NullaryOp& op, IndexType i, IndexType j=0)\textcolor{keyword}{
       const }\{ \textcolor{keywordflow}{return} op(i,j); \}
00368   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} IndexType> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE T packetOp(\textcolor{keyword}{const} 
      NullaryOp& op, IndexType i, IndexType j=0)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} op.template packetOp<T>(i,j); \}
00369 \};
00370 
00371 \textcolor{comment}{// We need the following specialization for vector-only functors assigned to a runtime vector,}
00372 \textcolor{comment}{// for instance, using linspace and assigning a RowVectorXd to a MatrixXd or even a row of a MatrixXd.}
00373 \textcolor{comment}{// In this case, i==0 and j is used for the actual iteration.}
00374 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} NullaryOp>
00375 \textcolor{keyword}{struct }nullary\_wrapper<Scalar,NullaryOp,false,true,false>
00376 \{
00377   \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00378   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar operator()(\textcolor{keyword}{const} NullaryOp& op, IndexType i, IndexType j)\textcolor{keyword}{
       const }\{
00379     eigen\_assert(i==0 || j==0);
00380     \textcolor{keywordflow}{return} op(i+j);
00381   \}
00382   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} IndexType> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE T packetOp(\textcolor{keyword}{const} 
      NullaryOp& op, IndexType i, IndexType j)\textcolor{keyword}{ const }\{
00383     eigen\_assert(i==0 || j==0);
00384     \textcolor{keywordflow}{return} op.template packetOp<T>(i+j);
00385   \}
00386 
00387   \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00388   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar operator()(\textcolor{keyword}{const} NullaryOp& op, IndexType i)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 
      op(i); \}
00389   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} IndexType>
00390   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE T packetOp(\textcolor{keyword}{const} NullaryOp& op, IndexType i)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} op.
      template packetOp<T>(i); \}
00391 \};
00392 
00393 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} NullaryOp>
00394 \textcolor{keyword}{struct }nullary\_wrapper<Scalar,NullaryOp,false,false,false> \{\};
00395 
00396 \textcolor{preprocessor}{#if 0 && EIGEN\_COMP\_MSVC>0}
00397 \textcolor{comment}{// Disable this ugly workaround. This is now handled in traits<Ref>::match,}
00398 \textcolor{comment}{// but this piece of code might still become handly if some other weird compilation}
00399 \textcolor{comment}{// erros pop up again.}
00400 
00401 \textcolor{comment}{// MSVC exhibits a weird compilation error when}
00402 \textcolor{comment}{// compiling:}
00403 \textcolor{comment}{//    Eigen::MatrixXf A = MatrixXf::Random(3,3);}
00404 \textcolor{comment}{//    Ref<const MatrixXf> R = 2.f*A;}
00405 \textcolor{comment}{// and that has\_*ary\_operator<scalar\_constant\_op<float>> have not been instantiated yet.}
00406 \textcolor{comment}{// The "problem" is that evaluator<2.f*A> is instantiated by traits<Ref>::match<2.f*A>}
00407 \textcolor{comment}{// and at that time has\_*ary\_operator<T> returns true regardless of T.}
00408 \textcolor{comment}{// Then nullary\_wrapper is badly instantiated as nullary\_wrapper<.,.,true,true,true>.}
00409 \textcolor{comment}{// The trick is thus to defer the proper instantiation of nullary\_wrapper when coeff(),}
00410 \textcolor{comment}{// and packet() are really instantiated as implemented below:}
00411 
00412 \textcolor{comment}{// This is a simple wrapper around Index to enforce the re-instantiation of}
00413 \textcolor{comment}{// has\_*ary\_operator when needed.}
00414 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }nullary\_wrapper\_workaround\_msvc \{
00415   nullary\_wrapper\_workaround\_msvc(\textcolor{keyword}{const} T&);
00416   \textcolor{keyword}{operator} T()\textcolor{keyword}{const};
00417 \};
00418 
00419 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} NullaryOp>
00420 \textcolor{keyword}{struct }nullary\_wrapper<Scalar,NullaryOp,true,true,true>
00421 \{
00422   \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00423   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar operator()(\textcolor{keyword}{const} NullaryOp& op, IndexType i, IndexType j)\textcolor{keyword}{
       const }\{
00424     \textcolor{keywordflow}{return} nullary\_wrapper<Scalar,NullaryOp,
00425     has\_nullary\_operator<NullaryOp,nullary\_wrapper\_workaround\_msvc<IndexType> >::value,
00426     has\_unary\_operator<NullaryOp,nullary\_wrapper\_workaround\_msvc<IndexType> >::value,
00427     has\_binary\_operator<NullaryOp,nullary\_wrapper\_workaround\_msvc<IndexType> >::value>().\textcolor{keyword}{operator}()(op,i,j)
      ;
00428   \}
00429   \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00430   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar operator()(\textcolor{keyword}{const} NullaryOp& op, IndexType i)\textcolor{keyword}{ const }\{
00431     \textcolor{keywordflow}{return} nullary\_wrapper<Scalar,NullaryOp,
00432     has\_nullary\_operator<NullaryOp,nullary\_wrapper\_workaround\_msvc<IndexType> >::value,
00433     has\_unary\_operator<NullaryOp,nullary\_wrapper\_workaround\_msvc<IndexType> >::value,
00434     has\_binary\_operator<NullaryOp,nullary\_wrapper\_workaround\_msvc<IndexType> >::value>().\textcolor{keyword}{operator}()(op,i);
00435   \}
00436 
00437   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} IndexType>
00438   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE T packetOp(\textcolor{keyword}{const} NullaryOp& op, IndexType i, IndexType j)\textcolor{keyword}{ const }\{
00439     \textcolor{keywordflow}{return} nullary\_wrapper<Scalar,NullaryOp,
00440     has\_nullary\_operator<NullaryOp,nullary\_wrapper\_workaround\_msvc<IndexType> >::value,
00441     has\_unary\_operator<NullaryOp,nullary\_wrapper\_workaround\_msvc<IndexType> >::value,
00442     has\_binary\_operator<NullaryOp,nullary\_wrapper\_workaround\_msvc<IndexType> >::value>().\textcolor{keyword}{template} 
      packetOp<T>(op,i,j);
00443   \}
00444   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} IndexType>
00445   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE T packetOp(\textcolor{keyword}{const} NullaryOp& op, IndexType i)\textcolor{keyword}{ const }\{
00446     \textcolor{keywordflow}{return} nullary\_wrapper<Scalar,NullaryOp,
00447     has\_nullary\_operator<NullaryOp,nullary\_wrapper\_workaround\_msvc<IndexType> >::value,
00448     has\_unary\_operator<NullaryOp,nullary\_wrapper\_workaround\_msvc<IndexType> >::value,
00449     has\_binary\_operator<NullaryOp,nullary\_wrapper\_workaround\_msvc<IndexType> >::value>().\textcolor{keyword}{template} 
      packetOp<T>(op,i);
00450   \}
00451 \};
00452 \textcolor{preprocessor}{#endif // MSVC workaround}
00453 
00454 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NullaryOp, \textcolor{keyword}{typename} PlainObjectType>
00455 \textcolor{keyword}{struct }evaluator<CwiseNullaryOp<NullaryOp,PlainObjectType> >
00456   : evaluator\_base<CwiseNullaryOp<NullaryOp,PlainObjectType> >
00457 \{
00458   \textcolor{keyword}{typedef} CwiseNullaryOp<NullaryOp,PlainObjectType> XprType;
00459   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<PlainObjectType>::type PlainObjectTypeCleaned;
00460   
00461   \textcolor{keyword}{enum} \{
00462     CoeffReadCost = internal::functor\_traits<NullaryOp>::Cost,
00463     
00464     Flags = (evaluator<PlainObjectTypeCleaned>::Flags
00465           &  (  HereditaryBits
00466               | (functor\_has\_linear\_access<NullaryOp>::ret  ? \hyperlink{group__flags_ga4b983a15d57cd55806df618ac544d09e}{LinearAccessBit} : 0)
00467               | (functor\_traits<NullaryOp>::PacketAccess    ? \hyperlink{group__flags_ga1a306a438e1ab074e8be59512e887b9f}{PacketAccessBit} : 0)))
00468           | (functor\_traits<NullaryOp>::IsRepeatable ? 0 : \hyperlink{group__flags_gaa34e83bae46a8eeae4e69ebe3aaecbed}{EvalBeforeNestingBit}),
00469     Alignment = AlignedMax
00470   \};
00471 
00472   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} XprType& n)
00473     : m\_functor(n.functor()), m\_wrapper()
00474   \{
00475     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00476   \}
00477 
00478   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00479 
00480   \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00481   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00482   CoeffReturnType coeff(IndexType row, IndexType col)\textcolor{keyword}{ const}
00483 \textcolor{keyword}{  }\{
00484     \textcolor{keywordflow}{return} m\_wrapper(m\_functor, row, col);
00485   \}
00486 
00487   \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexType>
00488   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00489   CoeffReturnType coeff(IndexType index)\textcolor{keyword}{ const}
00490 \textcolor{keyword}{  }\{
00491     \textcolor{keywordflow}{return} m\_wrapper(m\_functor,index);
00492   \}
00493 
00494   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType, \textcolor{keyword}{typename} IndexType>
00495   EIGEN\_STRONG\_INLINE
00496   PacketType packet(IndexType row, IndexType col)\textcolor{keyword}{ const}
00497 \textcolor{keyword}{  }\{
00498     \textcolor{keywordflow}{return} m\_wrapper.template packetOp<PacketType>(m\_functor, row, col);
00499   \}
00500 
00501   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType, \textcolor{keyword}{typename} IndexType>
00502   EIGEN\_STRONG\_INLINE
00503   PacketType packet(IndexType index)\textcolor{keyword}{ const}
00504 \textcolor{keyword}{  }\{
00505     \textcolor{keywordflow}{return} m\_wrapper.template packetOp<PacketType>(m\_functor, index);
00506   \}
00507 
00508 \textcolor{keyword}{protected}:
00509   \textcolor{keyword}{const} NullaryOp m\_functor;
00510   \textcolor{keyword}{const} internal::nullary\_wrapper<CoeffReturnType,NullaryOp> m\_wrapper;
00511 \};
00512 
00513 \textcolor{comment}{// -------------------- CwiseUnaryOp --------------------}
00514 
00515 \textcolor{keyword}{template}<\textcolor{keyword}{typename} UnaryOp, \textcolor{keyword}{typename} ArgType>
00516 \textcolor{keyword}{struct }unary\_evaluator<CwiseUnaryOp<UnaryOp, ArgType>, IndexBased >
00517   : evaluator\_base<CwiseUnaryOp<UnaryOp, ArgType> >
00518 \{
00519   \textcolor{keyword}{typedef} CwiseUnaryOp<UnaryOp, ArgType> XprType;
00520   
00521   \textcolor{keyword}{enum} \{
00522     CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor\_traits<UnaryOp>::Cost,
00523     
00524     Flags = evaluator<ArgType>::Flags
00525           & (HereditaryBits | \hyperlink{group__flags_ga4b983a15d57cd55806df618ac544d09e}{LinearAccessBit} | (functor\_traits<UnaryOp>::PacketAccess ? 
      \hyperlink{group__flags_ga1a306a438e1ab074e8be59512e887b9f}{PacketAccessBit} : 0)),
00526     Alignment = evaluator<ArgType>::Alignment
00527   \};
00528 
00529   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00530   \textcolor{keyword}{explicit} unary\_evaluator(\textcolor{keyword}{const} XprType& op)
00531     : m\_functor(op.functor()), 
00532       m\_argImpl(op.nestedExpression()) 
00533   \{
00534     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(functor\_traits<UnaryOp>::Cost);
00535     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00536   \}
00537 
00538   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00539 
00540   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00541   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00542 \textcolor{keyword}{  }\{
00543     \textcolor{keywordflow}{return} m\_functor(m\_argImpl.coeff(row, col));
00544   \}
00545 
00546   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00547   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00548 \textcolor{keyword}{  }\{
00549     \textcolor{keywordflow}{return} m\_functor(m\_argImpl.coeff(index));
00550   \}
00551 
00552   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00553   EIGEN\_STRONG\_INLINE
00554   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00555 \textcolor{keyword}{  }\{
00556     \textcolor{keywordflow}{return} m\_functor.packetOp(m\_argImpl.template packet<LoadMode, PacketType>(row, col));
00557   \}
00558 
00559   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00560   EIGEN\_STRONG\_INLINE
00561   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00562 \textcolor{keyword}{  }\{
00563     \textcolor{keywordflow}{return} m\_functor.packetOp(m\_argImpl.template packet<LoadMode, PacketType>(index));
00564   \}
00565 
00566 \textcolor{keyword}{protected}:
00567   \textcolor{keyword}{const} UnaryOp m\_functor;
00568   evaluator<ArgType> m\_argImpl;
00569 \};
00570 
00571 \textcolor{comment}{// -------------------- CwiseTernaryOp --------------------}
00572 
00573 \textcolor{comment}{// this is a ternary expression}
00574 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TernaryOp, \textcolor{keyword}{typename} Arg1, \textcolor{keyword}{typename} Arg2, \textcolor{keyword}{typename} Arg3>
00575 \textcolor{keyword}{struct }evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> >
00576   : \textcolor{keyword}{public} ternary\_evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> >
00577 \{
00578   \textcolor{keyword}{typedef} CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> XprType;
00579   \textcolor{keyword}{typedef} ternary\_evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> > Base;
00580   
00581   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} XprType& xpr) : Base(xpr) \{\}
00582 \};
00583 
00584 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TernaryOp, \textcolor{keyword}{typename} Arg1, \textcolor{keyword}{typename} Arg2, \textcolor{keyword}{typename} Arg3>
00585 \textcolor{keyword}{struct }ternary\_evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3>, IndexBased, IndexBased>
00586   : evaluator\_base<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> >
00587 \{
00588   \textcolor{keyword}{typedef} CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> XprType;
00589   
00590   \textcolor{keyword}{enum} \{
00591     CoeffReadCost = evaluator<Arg1>::CoeffReadCost + evaluator<Arg2>::CoeffReadCost + 
      evaluator<Arg3>::CoeffReadCost + functor\_traits<TernaryOp>::Cost,
00592     
00593     Arg1Flags = evaluator<Arg1>::Flags,
00594     Arg2Flags = evaluator<Arg2>::Flags,
00595     Arg3Flags = evaluator<Arg3>::Flags,
00596     SameType = is\_same<typename Arg1::Scalar,typename Arg2::Scalar>::value && is\_same<typename
       Arg1::Scalar,typename Arg3::Scalar>::value,
00597     StorageOrdersAgree = (int(Arg1Flags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==(\textcolor{keywordtype}{int}(Arg2Flags)&
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) && (\textcolor{keywordtype}{int}(Arg1Flags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==(\textcolor{keywordtype}{int}(Arg3Flags)&
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}),
00598     Flags0 = (\textcolor{keywordtype}{int}(Arg1Flags) | int(Arg2Flags) | int(Arg3Flags)) & (
00599         HereditaryBits
00600         | (\textcolor{keywordtype}{int}(Arg1Flags) & \textcolor{keywordtype}{int}(Arg2Flags) & \textcolor{keywordtype}{int}(Arg3Flags) &
00601            ( (StorageOrdersAgree ? \hyperlink{group__flags_ga4b983a15d57cd55806df618ac544d09e}{LinearAccessBit} : 0)
00602            | (functor\_traits<TernaryOp>::PacketAccess && StorageOrdersAgree && SameType ? 
      \hyperlink{group__flags_ga1a306a438e1ab074e8be59512e887b9f}{PacketAccessBit} : 0)
00603            )
00604         )
00605      ),
00606     Flags = (Flags0 & ~\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) | (Arg1Flags & \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}),
00607     Alignment = EIGEN\_PLAIN\_ENUM\_MIN(
00608         EIGEN\_PLAIN\_ENUM\_MIN(evaluator<Arg1>::Alignment, evaluator<Arg2>::Alignment),
00609         evaluator<Arg3>::Alignment)
00610   \};
00611 
00612   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} ternary\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00613     : m\_functor(xpr.functor()),
00614       m\_arg1Impl(xpr.arg1()), 
00615       m\_arg2Impl(xpr.arg2()), 
00616       m\_arg3Impl(xpr.arg3())  
00617   \{
00618     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(functor\_traits<TernaryOp>::Cost);
00619     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00620   \}
00621 
00622   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00623 
00624   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00625   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00626 \textcolor{keyword}{  }\{
00627     \textcolor{keywordflow}{return} m\_functor(m\_arg1Impl.coeff(row, col), m\_arg2Impl.coeff(row, col), m\_arg3Impl.coeff(row, col));
00628   \}
00629 
00630   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00631   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00632 \textcolor{keyword}{  }\{
00633     \textcolor{keywordflow}{return} m\_functor(m\_arg1Impl.coeff(index), m\_arg2Impl.coeff(index), m\_arg3Impl.coeff(index));
00634   \}
00635 
00636   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00637   EIGEN\_STRONG\_INLINE
00638   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00639 \textcolor{keyword}{  }\{
00640     \textcolor{keywordflow}{return} m\_functor.packetOp(m\_arg1Impl.template packet<LoadMode,PacketType>(row, col),
00641                               m\_arg2Impl.template packet<LoadMode,PacketType>(row, col),
00642                               m\_arg3Impl.template packet<LoadMode,PacketType>(row, col));
00643   \}
00644 
00645   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00646   EIGEN\_STRONG\_INLINE
00647   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00648 \textcolor{keyword}{  }\{
00649     \textcolor{keywordflow}{return} m\_functor.packetOp(m\_arg1Impl.template packet<LoadMode,PacketType>(index),
00650                               m\_arg2Impl.template packet<LoadMode,PacketType>(index),
00651                               m\_arg3Impl.template packet<LoadMode,PacketType>(index));
00652   \}
00653 
00654 \textcolor{keyword}{protected}:
00655   \textcolor{keyword}{const} TernaryOp m\_functor;
00656   evaluator<Arg1> m\_arg1Impl;
00657   evaluator<Arg2> m\_arg2Impl;
00658   evaluator<Arg3> m\_arg3Impl;
00659 \};
00660 
00661 \textcolor{comment}{// -------------------- CwiseBinaryOp --------------------}
00662 
00663 \textcolor{comment}{// this is a binary expression}
00664 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00665 \textcolor{keyword}{struct }evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
00666   : \textcolor{keyword}{public} binary\_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
00667 \{
00668   \textcolor{keyword}{typedef} CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;
00669   \textcolor{keyword}{typedef} binary\_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> > Base;
00670   
00671   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} XprType& xpr) : Base(xpr) \{\}
00672 \};
00673 
00674 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00675 \textcolor{keyword}{struct }binary\_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IndexBased, IndexBased>
00676   : evaluator\_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
00677 \{
00678   \textcolor{keyword}{typedef} CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;
00679   
00680   \textcolor{keyword}{enum} \{
00681     CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + 
      functor\_traits<BinaryOp>::Cost,
00682     
00683     LhsFlags = evaluator<Lhs>::Flags,
00684     RhsFlags = evaluator<Rhs>::Flags,
00685     SameType = is\_same<typename Lhs::Scalar,typename Rhs::Scalar>::value,
00686     StorageOrdersAgree = (int(LhsFlags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==(\textcolor{keywordtype}{int}(RhsFlags)&
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}),
00687     Flags0 = (\textcolor{keywordtype}{int}(LhsFlags) | int(RhsFlags)) & (
00688         HereditaryBits
00689       | (\textcolor{keywordtype}{int}(LhsFlags) & \textcolor{keywordtype}{int}(RhsFlags) &
00690            ( (StorageOrdersAgree ? LinearAccessBit : 0)
00691            | (functor\_traits<BinaryOp>::PacketAccess && StorageOrdersAgree && SameType ? PacketAccessBit : 
      0)
00692            )
00693         )
00694      ),
00695     Flags = (Flags0 & ~\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) | (LhsFlags & \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}),
00696     Alignment = EIGEN\_PLAIN\_ENUM\_MIN(evaluator<Lhs>::Alignment,evaluator<Rhs>::Alignment)
00697   \};
00698 
00699   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} binary\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00700     : m\_functor(xpr.functor()),
00701       m\_lhsImpl(xpr.lhs()), 
00702       m\_rhsImpl(xpr.rhs())  
00703   \{
00704     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(functor\_traits<BinaryOp>::Cost);
00705     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00706   \}
00707 
00708   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00709 
00710   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00711   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00712 \textcolor{keyword}{  }\{
00713     \textcolor{keywordflow}{return} m\_functor(m\_lhsImpl.coeff(row, col), m\_rhsImpl.coeff(row, col));
00714   \}
00715 
00716   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00717   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00718 \textcolor{keyword}{  }\{
00719     \textcolor{keywordflow}{return} m\_functor(m\_lhsImpl.coeff(index), m\_rhsImpl.coeff(index));
00720   \}
00721 
00722   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00723   EIGEN\_STRONG\_INLINE
00724   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00725 \textcolor{keyword}{  }\{
00726     \textcolor{keywordflow}{return} m\_functor.packetOp(m\_lhsImpl.template packet<LoadMode,PacketType>(row, col),
00727                               m\_rhsImpl.template packet<LoadMode,PacketType>(row, col));
00728   \}
00729 
00730   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00731   EIGEN\_STRONG\_INLINE
00732   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00733 \textcolor{keyword}{  }\{
00734     \textcolor{keywordflow}{return} m\_functor.packetOp(m\_lhsImpl.template packet<LoadMode,PacketType>(index),
00735                               m\_rhsImpl.template packet<LoadMode,PacketType>(index));
00736   \}
00737 
00738 \textcolor{keyword}{protected}:
00739   \textcolor{keyword}{const} BinaryOp m\_functor;
00740   evaluator<Lhs> m\_lhsImpl;
00741   evaluator<Rhs> m\_rhsImpl;
00742 \};
00743 
00744 \textcolor{comment}{// -------------------- CwiseUnaryView --------------------}
00745 
00746 \textcolor{keyword}{template}<\textcolor{keyword}{typename} UnaryOp, \textcolor{keyword}{typename} ArgType>
00747 \textcolor{keyword}{struct }unary\_evaluator<CwiseUnaryView<UnaryOp, ArgType>, IndexBased>
00748   : evaluator\_base<CwiseUnaryView<UnaryOp, ArgType> >
00749 \{
00750   \textcolor{keyword}{typedef} CwiseUnaryView<UnaryOp, ArgType> XprType;
00751   
00752   \textcolor{keyword}{enum} \{
00753     CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor\_traits<UnaryOp>::Cost,
00754     
00755     Flags = (evaluator<ArgType>::Flags & (HereditaryBits | LinearAccessBit | 
      \hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit})),
00756     
00757     Alignment = 0 \textcolor{comment}{// FIXME it is not very clear why alignment is necessarily lost...}
00758   \};
00759 
00760   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} unary\_evaluator(\textcolor{keyword}{const} XprType& op)
00761     : m\_unaryOp(op.functor()), 
00762       m\_argImpl(op.nestedExpression()) 
00763   \{
00764     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(functor\_traits<UnaryOp>::Cost);
00765     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00766   \}
00767 
00768   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00769   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00770 
00771   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00772   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00773 \textcolor{keyword}{  }\{
00774     \textcolor{keywordflow}{return} m\_unaryOp(m\_argImpl.coeff(row, col));
00775   \}
00776 
00777   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00778   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00779 \textcolor{keyword}{  }\{
00780     \textcolor{keywordflow}{return} m\_unaryOp(m\_argImpl.coeff(index));
00781   \}
00782 
00783   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00784   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
00785   \{
00786     \textcolor{keywordflow}{return} m\_unaryOp(m\_argImpl.coeffRef(row, col));
00787   \}
00788 
00789   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00790   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)
00791   \{
00792     \textcolor{keywordflow}{return} m\_unaryOp(m\_argImpl.coeffRef(index));
00793   \}
00794 
00795 \textcolor{keyword}{protected}:
00796   \textcolor{keyword}{const} UnaryOp m\_unaryOp;
00797   evaluator<ArgType> m\_argImpl;
00798 \};
00799 
00800 \textcolor{comment}{// -------------------- Map --------------------}
00801 
00802 \textcolor{comment}{// FIXME perhaps the PlainObjectType could be provided by Derived::PlainObject ?}
00803 \textcolor{comment}{// but that might complicate template specialization}
00804 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} PlainObjectType>
00805 \textcolor{keyword}{struct }mapbase\_evaluator;
00806 
00807 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} PlainObjectType>
00808 \textcolor{keyword}{struct }mapbase\_evaluator : evaluator\_base<Derived>
00809 \{
00810   \textcolor{keyword}{typedef} Derived  XprType;
00811   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::PointerType PointerType;
00812   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00813   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00814   
00815   \textcolor{keyword}{enum} \{
00816     IsRowMajor = XprType::RowsAtCompileTime,
00817     ColsAtCompileTime = XprType::ColsAtCompileTime,
00818     CoeffReadCost = NumTraits<Scalar>::ReadCost
00819   \};
00820 
00821   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} mapbase\_evaluator(\textcolor{keyword}{const} XprType& map)
00822     : m\_data(const\_cast<PointerType>(map.data())),
00823       m\_innerStride(map.innerStride()),
00824       m\_outerStride(map.outerStride())
00825   \{
00826     EIGEN\_STATIC\_ASSERT(EIGEN\_IMPLIES(evaluator<Derived>::Flags&PacketAccessBit, 
      internal::inner\_stride\_at\_compile\_time<Derived>::ret==1),
00827                         PACKET\_ACCESS\_REQUIRES\_TO\_HAVE\_INNER\_STRIDE\_FIXED\_TO\_1);
00828     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00829   \}
00830 
00831   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00832   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00833 \textcolor{keyword}{  }\{
00834     \textcolor{keywordflow}{return} m\_data[col * colStride() + row * rowStride()];
00835   \}
00836 
00837   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00838   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00839 \textcolor{keyword}{  }\{
00840     \textcolor{keywordflow}{return} m\_data[index * m\_innerStride.value()];
00841   \}
00842 
00843   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00844   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
00845   \{
00846     \textcolor{keywordflow}{return} m\_data[col * colStride() + row * rowStride()];
00847   \}
00848 
00849   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00850   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)
00851   \{
00852     \textcolor{keywordflow}{return} m\_data[index * m\_innerStride.value()];
00853   \}
00854 
00855   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00856   EIGEN\_STRONG\_INLINE
00857   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
00858 \textcolor{keyword}{  }\{
00859     PointerType ptr = m\_data + row * rowStride() + col * colStride();
00860     \textcolor{keywordflow}{return} internal::ploadt<PacketType, LoadMode>(ptr);
00861   \}
00862 
00863   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
00864   EIGEN\_STRONG\_INLINE
00865   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00866 \textcolor{keyword}{  }\{
00867     \textcolor{keywordflow}{return} internal::ploadt<PacketType, LoadMode>(m\_data + index * m\_innerStride.value());
00868   \}
00869 
00870   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode, \textcolor{keyword}{typename} PacketType>
00871   EIGEN\_STRONG\_INLINE
00872   \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col, \textcolor{keyword}{const} PacketType& x)
00873   \{
00874     PointerType ptr = m\_data + row * rowStride() + col * colStride();
00875     \textcolor{keywordflow}{return} internal::pstoret<Scalar, PacketType, StoreMode>(ptr, x);
00876   \}
00877 
00878   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode, \textcolor{keyword}{typename} PacketType>
00879   EIGEN\_STRONG\_INLINE
00880   \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index, \textcolor{keyword}{const} PacketType& x)
00881   \{
00882     internal::pstoret<Scalar, PacketType, StoreMode>(m\_data + index * m\_innerStride.value(), x);
00883   \}
00884 \textcolor{keyword}{protected}:
00885   EIGEN\_DEVICE\_FUNC
00886   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rowStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} XprType::IsRowMajor ? m\_outerStride.value() : m\_innerStride.
      value(); \}
00887   EIGEN\_DEVICE\_FUNC
00888   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} colStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} XprType::IsRowMajor ? m\_innerStride.value() : m\_outerStride.
      value(); \}
00889 
00890   PointerType m\_data;
00891   \textcolor{keyword}{const} internal::variable\_if\_dynamic<Index, XprType::InnerStrideAtCompileTime> m\_innerStride;
00892   \textcolor{keyword}{const} internal::variable\_if\_dynamic<Index, XprType::OuterStrideAtCompileTime> m\_outerStride;
00893 \};
00894 
00895 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType, \textcolor{keywordtype}{int} MapOptions, \textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}eType> 
00896 \textcolor{keyword}{struct }evaluator<Map<PlainObjectType, MapOptions, StrideType> >
00897   : \textcolor{keyword}{public} mapbase\_evaluator<Map<PlainObjectType, MapOptions, StrideType>, PlainObjectType>
00898 \{
00899   \textcolor{keyword}{typedef} Map<PlainObjectType, MapOptions, StrideType> XprType;
00900   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00901   \textcolor{comment}{// TODO: should check for smaller packet types once we can handle multi-sized packet types}
00902   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::type PacketScalar;
00903   
00904   \textcolor{keyword}{enum} \{
00905     InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0
00906                              ? int(PlainObjectType::InnerStrideAtCompileTime)
00907                              : int(StrideType::InnerStrideAtCompileTime),
00908     OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0
00909                              ? int(PlainObjectType::OuterStrideAtCompileTime)
00910                              : int(StrideType::OuterStrideAtCompileTime),
00911     HasNoInnerStride = InnerStrideAtCompileTime == 1,
00912     HasNoOuterStride = StrideType::OuterStrideAtCompileTime == 0,
00913     HasNoStride = HasNoInnerStride && HasNoOuterStride,
00914     IsDynamicSize = PlainObjectType::SizeAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00915     
00916     PacketAccessMask = bool(HasNoInnerStride) ? ~int(0) : ~int(PacketAccessBit),
00917     LinearAccessMask = bool(HasNoStride) || bool(PlainObjectType::IsVectorAtCompileTime) ? ~int(0) : ~int(
      LinearAccessBit),
00918     Flags = int( evaluator<PlainObjectType>::Flags) & (LinearAccessMask&PacketAccessMask),
00919     
00920     Alignment = int(MapOptions)&int(AlignedMask)
00921   \};
00922 
00923   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} XprType& map)
00924     : mapbase\_evaluator<XprType, PlainObjectType>(map) 
00925   \{ \}
00926 \};
00927 
00928 \textcolor{comment}{// -------------------- Ref --------------------}
00929 
00930 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType, \textcolor{keywordtype}{int} RefOptions, \textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}eType> 
00931 \textcolor{keyword}{struct }evaluator<Ref<PlainObjectType, RefOptions, StrideType> >
00932   : \textcolor{keyword}{public} mapbase\_evaluator<Ref<PlainObjectType, RefOptions, StrideType>, PlainObjectType>
00933 \{
00934   \textcolor{keyword}{typedef} Ref<PlainObjectType, RefOptions, StrideType> XprType;
00935   
00936   \textcolor{keyword}{enum} \{
00937     Flags = evaluator<Map<PlainObjectType, RefOptions, StrideType> >::Flags,
00938     Alignment = evaluator<Map<PlainObjectType, RefOptions, StrideType> >::Alignment
00939   \};
00940 
00941   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} XprType& ref)
00942     : mapbase\_evaluator<XprType, PlainObjectType>(ref) 
00943   \{ \}
00944 \};
00945 
00946 \textcolor{comment}{// -------------------- Block --------------------}
00947 
00948 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols, \textcolor{keywordtype}{bool} InnerPanel,
00949          \textcolor{keywordtype}{bool} HasDirectAccess = internal::has\_direct\_access<ArgType>::ret> \textcolor{keyword}{struct }block\_evaluator;
00950          
00951 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols, \textcolor{keywordtype}{bool} InnerPanel> 
00952 \textcolor{keyword}{struct }evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel> >
00953   : block\_evaluator<ArgType, BlockRows, BlockCols, InnerPanel>
00954 \{
00955   \textcolor{keyword}{typedef} Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
00956   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00957   \textcolor{comment}{// TODO: should check for smaller packet types once we can handle multi-sized packet types}
00958   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::type PacketScalar;
00959   
00960   \textcolor{keyword}{enum} \{
00961     CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
00962     
00963     RowsAtCompileTime = traits<XprType>::RowsAtCompileTime,
00964     ColsAtCompileTime = traits<XprType>::ColsAtCompileTime,
00965     MaxRowsAtCompileTime = traits<XprType>::MaxRowsAtCompileTime,
00966     MaxColsAtCompileTime = traits<XprType>::MaxColsAtCompileTime,
00967     
00968     ArgTypeIsRowMajor = (int(evaluator<ArgType>::Flags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) != 0,
00969     IsRowMajor = (MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1) ? 1
00970                : (MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1) ? 0
00971                : ArgTypeIsRowMajor,
00972     HasSameStorageOrderAsArgType = (IsRowMajor == ArgTypeIsRowMajor),
00973     InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),
00974     InnerStrideAtCompileTime = HasSameStorageOrderAsArgType
00975                              ? int(inner\_stride\_at\_compile\_time<ArgType>::ret)
00976                              : int(outer\_stride\_at\_compile\_time<ArgType>::ret),
00977     OuterStrideAtCompileTime = HasSameStorageOrderAsArgType
00978                              ? int(outer\_stride\_at\_compile\_time<ArgType>::ret)
00979                              : int(inner\_stride\_at\_compile\_time<ArgType>::ret),
00980     MaskPacketAccessBit = (InnerStrideAtCompileTime == 1) ? PacketAccessBit : 0,
00981     
00982     FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1 || (InnerPanel && (evaluator<
      ArgType>::Flags&LinearAccessBit))) ? LinearAccessBit : 0,    
00983     FlagsRowMajorBit = XprType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit},
00984     Flags0 = evaluator<ArgType>::Flags & ( (HereditaryBits & ~\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) |
00985                                            \hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit} |
00986                                            MaskPacketAccessBit),
00987     Flags = Flags0 | FlagsLinearAccessBit | FlagsRowMajorBit,
00988     
00989     PacketAlignment = unpacket\_traits<PacketScalar>::alignment,
00990     Alignment0 = (InnerPanel && (OuterStrideAtCompileTime!=\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}) && (((OuterStrideAtCompileTime *
       int(sizeof(Scalar))) % int(PacketAlignment)) == 0)) ? int(PacketAlignment) : 0,
00991     Alignment = EIGEN\_PLAIN\_ENUM\_MIN(evaluator<ArgType>::Alignment, Alignment0)
00992   \};
00993   \textcolor{keyword}{typedef} block\_evaluator<ArgType, BlockRows, BlockCols, InnerPanel> block\_evaluator\_type;
00994   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} XprType& block) : block\_evaluator\_type(block)
00995   \{
00996     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00997   \}
00998 \};
00999 
01000 \textcolor{comment}{// no direct-access => dispatch to a unary evaluator}
01001 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols, \textcolor{keywordtype}{bool} InnerPanel>
01002 \textcolor{keyword}{struct }block\_evaluator<ArgType, BlockRows, BlockCols, InnerPanel, \textcolor{comment}{/*HasDirectAccess*/} false>
01003   : unary\_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel> >
01004 \{
01005   \textcolor{keyword}{typedef} Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
01006 
01007   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} block\_evaluator(\textcolor{keyword}{const} XprType& block)
01008     : unary\_evaluator<XprType>(block) 
01009   \{\}
01010 \};
01011 
01012 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols, \textcolor{keywordtype}{bool} InnerPanel>
01013 \textcolor{keyword}{struct }unary\_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel>, IndexBased>
01014   : evaluator\_base<Block<ArgType, BlockRows, BlockCols, InnerPanel> >
01015 \{
01016   \textcolor{keyword}{typedef} Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
01017 
01018   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} unary\_evaluator(\textcolor{keyword}{const} XprType& block)
01019     : m\_argImpl(block.nestedExpression()), 
01020       m\_startRow(block.startRow()), 
01021       m\_startCol(block.startCol()) 
01022   \{ \}
01023  
01024   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
01025   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
01026 
01027   \textcolor{keyword}{enum} \{
01028     RowsAtCompileTime = XprType::RowsAtCompileTime
01029   \};
01030  
01031   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01032   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
01033 \textcolor{keyword}{  }\{ 
01034     \textcolor{keywordflow}{return} m\_argImpl.coeff(m\_startRow.value() + row, m\_startCol.value() + col); 
01035   \}
01036   
01037   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01038   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
01039 \textcolor{keyword}{  }\{ 
01040     \textcolor{keywordflow}{return} coeff(RowsAtCompileTime == 1 ? 0 : index, RowsAtCompileTime == 1 ? index : 0);
01041   \}
01042 
01043   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01044   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
01045   \{ 
01046     \textcolor{keywordflow}{return} m\_argImpl.coeffRef(m\_startRow.value() + row, m\_startCol.value() + col); 
01047   \}
01048   
01049   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01050   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)
01051   \{ 
01052     \textcolor{keywordflow}{return} coeffRef(RowsAtCompileTime == 1 ? 0 : index, RowsAtCompileTime == 1 ? index : 0);
01053   \}
01054  
01055   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
01056   EIGEN\_STRONG\_INLINE
01057   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const }
01058 \textcolor{keyword}{  }\{ 
01059     \textcolor{keywordflow}{return} m\_argImpl.template packet<LoadMode,PacketType>(m\_startRow.value() + row, m\_startCol.value() + 
      col); 
01060   \}
01061 
01062   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
01063   EIGEN\_STRONG\_INLINE
01064   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const }
01065 \textcolor{keyword}{  }\{ 
01066     \textcolor{keywordflow}{return} packet<LoadMode,PacketType>(RowsAtCompileTime == 1 ? 0 : index,
01067                                        RowsAtCompileTime == 1 ? index : 0);
01068   \}
01069   
01070   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode, \textcolor{keyword}{typename} PacketType>
01071   EIGEN\_STRONG\_INLINE
01072   \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col, \textcolor{keyword}{const} PacketType& x) 
01073   \{
01074     \textcolor{keywordflow}{return} m\_argImpl.template writePacket<StoreMode,PacketType>(m\_startRow.value() + row, m\_startCol.value(
      ) + col, x); 
01075   \}
01076   
01077   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode, \textcolor{keyword}{typename} PacketType>
01078   EIGEN\_STRONG\_INLINE
01079   \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index, \textcolor{keyword}{const} PacketType& x) 
01080   \{
01081     \textcolor{keywordflow}{return} writePacket<StoreMode,PacketType>(RowsAtCompileTime == 1 ? 0 : index,
01082                                              RowsAtCompileTime == 1 ? index : 0,
01083                                              x);
01084   \}
01085  
01086 \textcolor{keyword}{protected}:
01087   evaluator<ArgType> m\_argImpl;
01088   \textcolor{keyword}{const} variable\_if\_dynamic<Index, (ArgType::RowsAtCompileTime == 1 && BlockRows==1) ? 0 : Dynamic> 
      m\_startRow;
01089   \textcolor{keyword}{const} variable\_if\_dynamic<Index, (ArgType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> 
      m\_startCol;
01090 \};
01091 
01092 \textcolor{comment}{// TODO: This evaluator does not actually use the child evaluator; }
01093 \textcolor{comment}{// all action is via the data() as returned by the Block expression.}
01094 
01095 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keywordtype}{int} BlockRows, \textcolor{keywordtype}{int} BlockCols, \textcolor{keywordtype}{bool} InnerPanel> 
01096 \textcolor{keyword}{struct }block\_evaluator<ArgType, BlockRows, BlockCols, InnerPanel, \textcolor{comment}{/* HasDirectAccess */} true>
01097   : mapbase\_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel>,
01098                       typename Block<ArgType, BlockRows, BlockCols, InnerPanel>::PlainObject>
01099 \{
01100   \textcolor{keyword}{typedef} Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
01101   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
01102 
01103   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} block\_evaluator(\textcolor{keyword}{const} XprType& block)
01104     : mapbase\_evaluator<XprType, typename XprType::PlainObject>(block) 
01105   \{
01106     \textcolor{comment}{// TODO: for the 3.3 release, this should be turned to an internal assertion, but let's keep it as is
       for the beta lifetime}
01107     eigen\_assert(((internal::UIntPtr(block.data()) % EIGEN\_PLAIN\_ENUM\_MAX(1,evaluator<XprType>::Alignment))
       == 0) && \textcolor{stringliteral}{"data is not aligned"});
01108   \}
01109 \};
01110 
01111 
01112 \textcolor{comment}{// -------------------- Select --------------------}
01113 \textcolor{comment}{// NOTE shall we introduce a ternary\_evaluator?}
01114 
01115 \textcolor{comment}{// TODO enable vectorization for Select}
01116 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ConditionMatrixType, \textcolor{keyword}{typename} ThenMatrixType, \textcolor{keyword}{typename} ElseMatrixType>
01117 \textcolor{keyword}{struct }evaluator<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >
01118   : evaluator\_base<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >
01119 \{
01120   \textcolor{keyword}{typedef} Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> XprType;
01121   \textcolor{keyword}{enum} \{
01122     CoeffReadCost = evaluator<ConditionMatrixType>::CoeffReadCost
01123                   + EIGEN\_PLAIN\_ENUM\_MAX(evaluator<ThenMatrixType>::CoeffReadCost,
01124                                          evaluator<ElseMatrixType>::CoeffReadCost),
01125 
01126     Flags = (\textcolor{keywordtype}{unsigned} int)evaluator<ThenMatrixType>::Flags & evaluator<ElseMatrixType>::Flags & 
      HereditaryBits,
01127     
01128     Alignment = EIGEN\_PLAIN\_ENUM\_MIN(evaluator<ThenMatrixType>::Alignment, 
      evaluator<ElseMatrixType>::Alignment)
01129   \};
01130 
01131   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} XprType& select)
01132     : m\_conditionImpl(select.conditionMatrix()),
01133       m\_thenImpl(select.thenMatrix()),
01134       m\_elseImpl(select.elseMatrix())
01135   \{
01136     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
01137   \}
01138  
01139   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
01140 
01141   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01142   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
01143 \textcolor{keyword}{  }\{
01144     \textcolor{keywordflow}{if} (m\_conditionImpl.coeff(row, col))
01145       \textcolor{keywordflow}{return} m\_thenImpl.coeff(row, col);
01146     \textcolor{keywordflow}{else}
01147       \textcolor{keywordflow}{return} m\_elseImpl.coeff(row, col);
01148   \}
01149 
01150   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01151   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
01152 \textcolor{keyword}{  }\{
01153     \textcolor{keywordflow}{if} (m\_conditionImpl.coeff(index))
01154       \textcolor{keywordflow}{return} m\_thenImpl.coeff(index);
01155     \textcolor{keywordflow}{else}
01156       \textcolor{keywordflow}{return} m\_elseImpl.coeff(index);
01157   \}
01158  
01159 \textcolor{keyword}{protected}:
01160   evaluator<ConditionMatrixType> m\_conditionImpl;
01161   evaluator<ThenMatrixType> m\_thenImpl;
01162   evaluator<ElseMatrixType> m\_elseImpl;
01163 \};
01164 
01165 
01166 \textcolor{comment}{// -------------------- Replicate --------------------}
01167 
01168 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keywordtype}{int} RowFactor, \textcolor{keywordtype}{int} ColFactor> 
01169 \textcolor{keyword}{struct }unary\_evaluator<Replicate<ArgType, RowFactor, ColFactor> >
01170   : evaluator\_base<Replicate<ArgType, RowFactor, ColFactor> >
01171 \{
01172   \textcolor{keyword}{typedef} Replicate<ArgType, RowFactor, ColFactor> XprType;
01173   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
01174   \textcolor{keyword}{enum} \{
01175     Factor = (RowFactor==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} || ColFactor==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}) ? \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} : RowFactor*
      ColFactor
01176   \};
01177   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::nested\_eval<ArgType,Factor>::type ArgTypeNested;
01178   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ArgTypeNested>::type ArgTypeNestedCleaned;
01179   
01180   \textcolor{keyword}{enum} \{
01181     CoeffReadCost = evaluator<ArgTypeNestedCleaned>::CoeffReadCost,
01182     LinearAccessMask = XprType::IsVectorAtCompileTime ? \hyperlink{group__flags_ga4b983a15d57cd55806df618ac544d09e}{LinearAccessBit} : 0,
01183     Flags = (evaluator<ArgTypeNestedCleaned>::Flags & (HereditaryBits|LinearAccessMask) & ~
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) | (traits<XprType>::Flags & \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}),
01184     
01185     Alignment = evaluator<ArgTypeNestedCleaned>::Alignment
01186   \};
01187 
01188   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} unary\_evaluator(\textcolor{keyword}{const} XprType& replicate)
01189     : m\_arg(replicate.nestedExpression()),
01190       m\_argImpl(m\_arg),
01191       m\_rows(replicate.nestedExpression().rows()),
01192       m\_cols(replicate.nestedExpression().cols())
01193   \{\}
01194  
01195   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01196   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
01197 \textcolor{keyword}{  }\{
01198     \textcolor{comment}{// try to avoid using modulo; this is a pure optimization strategy}
01199     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_row = internal::traits<XprType>::RowsAtCompileTime==1 ? 0
01200                            : RowFactor==1 ? row
01201                            : row % m\_rows.value();
01202     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_col = internal::traits<XprType>::ColsAtCompileTime==1 ? 0
01203                            : ColFactor==1 ? col
01204                            : col % m\_cols.value();
01205     
01206     \textcolor{keywordflow}{return} m\_argImpl.coeff(actual\_row, actual\_col);
01207   \}
01208   
01209   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01210   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
01211 \textcolor{keyword}{  }\{
01212     \textcolor{comment}{// try to avoid using modulo; this is a pure optimization strategy}
01213     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_index = internal::traits<XprType>::RowsAtCompileTime==1
01214                                   ? (ColFactor==1 ?  index : index%m\_cols.value())
01215                                   : (RowFactor==1 ?  index : index%m\_rows.value());
01216     
01217     \textcolor{keywordflow}{return} m\_argImpl.coeff(actual\_index);
01218   \}
01219 
01220   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
01221   EIGEN\_STRONG\_INLINE
01222   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
01223 \textcolor{keyword}{  }\{
01224     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_row = internal::traits<XprType>::RowsAtCompileTime==1 ? 0
01225                            : RowFactor==1 ? row
01226                            : row % m\_rows.value();
01227     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_col = internal::traits<XprType>::ColsAtCompileTime==1 ? 0
01228                            : ColFactor==1 ? col
01229                            : col % m\_cols.value();
01230 
01231     \textcolor{keywordflow}{return} m\_argImpl.template packet<LoadMode,PacketType>(actual\_row, actual\_col);
01232   \}
01233   
01234   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
01235   EIGEN\_STRONG\_INLINE
01236   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
01237 \textcolor{keyword}{  }\{
01238     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_index = internal::traits<XprType>::RowsAtCompileTime==1
01239                                   ? (ColFactor==1 ?  index : index%m\_cols.value())
01240                                   : (RowFactor==1 ?  index : index%m\_rows.value());
01241 
01242     \textcolor{keywordflow}{return} m\_argImpl.template packet<LoadMode,PacketType>(actual\_index);
01243   \}
01244  
01245 \textcolor{keyword}{protected}:
01246   \textcolor{keyword}{const} ArgTypeNested m\_arg;
01247   evaluator<ArgTypeNestedCleaned> m\_argImpl;
01248   \textcolor{keyword}{const} variable\_if\_dynamic<Index, ArgType::RowsAtCompileTime> m\_rows;
01249   \textcolor{keyword}{const} variable\_if\_dynamic<Index, ArgType::ColsAtCompileTime> m\_cols;
01250 \};
01251 
01252 
01253 \textcolor{comment}{// -------------------- PartialReduxExpr --------------------}
01254 
01255 \textcolor{keyword}{template}< \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} MemberOp, \textcolor{keywordtype}{int} Direction>
01256 \textcolor{keyword}{struct }evaluator<PartialReduxExpr<ArgType, MemberOp, Direction> >
01257   : evaluator\_base<PartialReduxExpr<ArgType, MemberOp, Direction> >
01258 \{
01259   \textcolor{keyword}{typedef} PartialReduxExpr<ArgType, MemberOp, Direction> XprType;
01260   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::nested\_eval<ArgType,1>::type ArgTypeNested;
01261   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ArgTypeNested>::type ArgTypeNestedCleaned;
01262   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ArgType::Scalar InputScalar;
01263   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
01264   \textcolor{keyword}{enum} \{
01265     TraversalSize = Direction==int(\hyperlink{group__enums_ggad49a7b3738e273eb00932271b36127f7addca718e0564723df21d61b94b1198be}{Vertical}) ? int(ArgType::RowsAtCompileTime) :  int(ArgType::
      ColsAtCompileTime)
01266   \};
01267   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MemberOp::template Cost<InputScalar,int(TraversalSize)> CostOpType;
01268   \textcolor{keyword}{enum} \{
01269     CoeffReadCost = TraversalSize==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} ? \hyperlink{namespace_eigen_a3163430a1c13173faffde69016b48aaf}{HugeCost}
01270                   : TraversalSize * evaluator<ArgType>::CoeffReadCost + int(CostOpType::value),
01271     
01272     Flags = (traits<XprType>::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) | (evaluator<ArgType>::Flags&(HereditaryBits&(~
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}))) | LinearAccessBit,
01273     
01274     Alignment = 0 \textcolor{comment}{// FIXME this will need to be improved once PartialReduxExpr is vectorized}
01275   \};
01276 
01277   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} XprType xpr)
01278     : m\_arg(xpr.nestedExpression()), m\_functor(xpr.functor())
01279   \{
01280     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(TraversalSize==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} ? \hyperlink{namespace_eigen_a3163430a1c13173faffde69016b48aaf}{HugeCost} : \textcolor{keywordtype}{int}(
      CostOpType::value));
01281     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
01282   \}
01283 
01284   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
01285 
01286   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01287   \textcolor{keyword}{const} Scalar coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j)\textcolor{keyword}{ const}
01288 \textcolor{keyword}{  }\{
01289     \textcolor{keywordflow}{if} (Direction==\hyperlink{group__enums_ggad49a7b3738e273eb00932271b36127f7addca718e0564723df21d61b94b1198be}{Vertical})
01290       \textcolor{keywordflow}{return} m\_functor(m\_arg.col(j));
01291     \textcolor{keywordflow}{else}
01292       \textcolor{keywordflow}{return} m\_functor(m\_arg.row(i));
01293   \}
01294 
01295   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01296   \textcolor{keyword}{const} Scalar coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
01297 \textcolor{keyword}{  }\{
01298     \textcolor{keywordflow}{if} (Direction==\hyperlink{group__enums_ggad49a7b3738e273eb00932271b36127f7addca718e0564723df21d61b94b1198be}{Vertical})
01299       \textcolor{keywordflow}{return} m\_functor(m\_arg.col(index));
01300     \textcolor{keywordflow}{else}
01301       \textcolor{keywordflow}{return} m\_functor(m\_arg.row(index));
01302   \}
01303 
01304 \textcolor{keyword}{protected}:
01305   \textcolor{keyword}{typename} internal::add\_const\_on\_value\_type<ArgTypeNested>::type m\_arg;
01306   \textcolor{keyword}{const} MemberOp m\_functor;
01307 \};
01308 
01309 
01310 \textcolor{comment}{// -------------------- MatrixWrapper and ArrayWrapper --------------------}
01311 \textcolor{comment}{//}
01312 \textcolor{comment}{// evaluator\_wrapper\_base<T> is a common base class for the}
01313 \textcolor{comment}{// MatrixWrapper and ArrayWrapper evaluators.}
01314 
01315 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
01316 \textcolor{keyword}{struct }evaluator\_wrapper\_base
01317   : evaluator\_base<XprType>
01318 \{
01319   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<typename XprType::NestedExpressionType>::type ArgType;
01320   \textcolor{keyword}{enum} \{
01321     CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
01322     Flags = evaluator<ArgType>::Flags,
01323     Alignment = evaluator<ArgType>::Alignment
01324   \};
01325 
01326   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator\_wrapper\_base(\textcolor{keyword}{const} ArgType& arg) : m\_argImpl(arg) \{\}
01327 
01328   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ArgType::Scalar Scalar;
01329   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ArgType::CoeffReturnType CoeffReturnType;
01330 
01331   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01332   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
01333 \textcolor{keyword}{  }\{
01334     \textcolor{keywordflow}{return} m\_argImpl.coeff(row, col);
01335   \}
01336 
01337   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01338   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
01339 \textcolor{keyword}{  }\{
01340     \textcolor{keywordflow}{return} m\_argImpl.coeff(index);
01341   \}
01342 
01343   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01344   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
01345   \{
01346     \textcolor{keywordflow}{return} m\_argImpl.coeffRef(row, col);
01347   \}
01348 
01349   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01350   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)
01351   \{
01352     \textcolor{keywordflow}{return} m\_argImpl.coeffRef(index);
01353   \}
01354 
01355   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
01356   EIGEN\_STRONG\_INLINE
01357   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
01358 \textcolor{keyword}{  }\{
01359     \textcolor{keywordflow}{return} m\_argImpl.template packet<LoadMode,PacketType>(row, col);
01360   \}
01361 
01362   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
01363   EIGEN\_STRONG\_INLINE
01364   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
01365 \textcolor{keyword}{  }\{
01366     \textcolor{keywordflow}{return} m\_argImpl.template packet<LoadMode,PacketType>(index);
01367   \}
01368 
01369   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode, \textcolor{keyword}{typename} PacketType>
01370   EIGEN\_STRONG\_INLINE
01371   \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col, \textcolor{keyword}{const} PacketType& x)
01372   \{
01373     m\_argImpl.template writePacket<StoreMode>(row, col, x);
01374   \}
01375 
01376   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode, \textcolor{keyword}{typename} PacketType>
01377   EIGEN\_STRONG\_INLINE
01378   \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index, \textcolor{keyword}{const} PacketType& x)
01379   \{
01380     m\_argImpl.template writePacket<StoreMode>(index, x);
01381   \}
01382 
01383 \textcolor{keyword}{protected}:
01384   evaluator<ArgType> m\_argImpl;
01385 \};
01386 
01387 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TArgType>
01388 \textcolor{keyword}{struct }unary\_evaluator<MatrixWrapper<TArgType> >
01389   : evaluator\_wrapper\_base<MatrixWrapper<TArgType> >
01390 \{
01391   \textcolor{keyword}{typedef} MatrixWrapper<TArgType> XprType;
01392 
01393   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} unary\_evaluator(\textcolor{keyword}{const} XprType& wrapper)
01394     : evaluator\_wrapper\_base<MatrixWrapper<TArgType> >(wrapper.nestedExpression())
01395   \{ \}
01396 \};
01397 
01398 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TArgType>
01399 \textcolor{keyword}{struct }unary\_evaluator<ArrayWrapper<TArgType> >
01400   : evaluator\_wrapper\_base<ArrayWrapper<TArgType> >
01401 \{
01402   \textcolor{keyword}{typedef} ArrayWrapper<TArgType> XprType;
01403 
01404   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} unary\_evaluator(\textcolor{keyword}{const} XprType& wrapper)
01405     : evaluator\_wrapper\_base<ArrayWrapper<TArgType> >(wrapper.nestedExpression())
01406   \{ \}
01407 \};
01408 
01409 
01410 \textcolor{comment}{// -------------------- Reverse --------------------}
01411 
01412 \textcolor{comment}{// defined in Reverse.h:}
01413 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PacketType, \textcolor{keywordtype}{bool} ReversePacket> \textcolor{keyword}{struct }reverse\_packet\_cond;
01414 
01415 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keywordtype}{int} Direction>
01416 \textcolor{keyword}{struct }unary\_evaluator<Reverse<ArgType, Direction> >
01417   : evaluator\_base<Reverse<ArgType, Direction> >
01418 \{
01419   \textcolor{keyword}{typedef} Reverse<ArgType, Direction> XprType;
01420   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
01421   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
01422 
01423   \textcolor{keyword}{enum} \{
01424     IsRowMajor = XprType::IsRowMajor,
01425     IsColMajor = !IsRowMajor,
01426     ReverseRow = (Direction == \hyperlink{group__enums_ggad49a7b3738e273eb00932271b36127f7addca718e0564723df21d61b94b1198be}{Vertical})   || (Direction == 
      \hyperlink{group__enums_ggad49a7b3738e273eb00932271b36127f7aa01e40fce022901560ce6d9fdee2fde3}{BothDirections}),
01427     ReverseCol = (Direction == \hyperlink{group__enums_ggad49a7b3738e273eb00932271b36127f7aae8a16b3b9272683c1162915f6d892be}{Horizontal}) || (Direction == 
      \hyperlink{group__enums_ggad49a7b3738e273eb00932271b36127f7aa01e40fce022901560ce6d9fdee2fde3}{BothDirections}),
01428     ReversePacket = (Direction == \hyperlink{group__enums_ggad49a7b3738e273eb00932271b36127f7aa01e40fce022901560ce6d9fdee2fde3}{BothDirections})
01429                     || ((Direction == \hyperlink{group__enums_ggad49a7b3738e273eb00932271b36127f7addca718e0564723df21d61b94b1198be}{Vertical})   && IsColMajor)
01430                     || ((Direction == \hyperlink{group__enums_ggad49a7b3738e273eb00932271b36127f7aae8a16b3b9272683c1162915f6d892be}{Horizontal}) && IsRowMajor),
01431                     
01432     CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
01433     
01434     \textcolor{comment}{// let's enable LinearAccess only with vectorization because of the product overhead}
01435     \textcolor{comment}{// FIXME enable DirectAccess with negative strides?}
01436     Flags0 = evaluator<ArgType>::Flags,
01437     LinearAccess = ( (Direction==\hyperlink{group__enums_ggad49a7b3738e273eb00932271b36127f7aa01e40fce022901560ce6d9fdee2fde3}{BothDirections}) && (int(Flags0)&
      \hyperlink{group__flags_ga1a306a438e1ab074e8be59512e887b9f}{PacketAccessBit}) )
01438                   || ((ReverseRow && XprType::ColsAtCompileTime==1) || (ReverseCol && 
      XprType::RowsAtCompileTime==1))
01439                  ? LinearAccessBit : 0,
01440 
01441     Flags = \textcolor{keywordtype}{int}(Flags0) & (HereditaryBits | PacketAccessBit | LinearAccess),
01442     
01443     Alignment = 0 \textcolor{comment}{// FIXME in some rare cases, Alignment could be preserved, like a Vector4f.}
01444   \};
01445 
01446   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} unary\_evaluator(\textcolor{keyword}{const} XprType& reverse)
01447     : m\_argImpl(reverse.nestedExpression()),
01448       m\_rows(ReverseRow ? reverse.nestedExpression().rows() : 1),
01449       m\_cols(ReverseCol ? reverse.nestedExpression().cols() : 1)
01450   \{ \}
01451  
01452   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01453   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
01454 \textcolor{keyword}{  }\{
01455     \textcolor{keywordflow}{return} m\_argImpl.coeff(ReverseRow ? m\_rows.value() - row - 1 : row,
01456                            ReverseCol ? m\_cols.value() - col - 1 : col);
01457   \}
01458 
01459   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01460   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
01461 \textcolor{keyword}{  }\{
01462     \textcolor{keywordflow}{return} m\_argImpl.coeff(m\_rows.value() * m\_cols.value() - index - 1);
01463   \}
01464 
01465   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01466   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
01467   \{
01468     \textcolor{keywordflow}{return} m\_argImpl.coeffRef(ReverseRow ? m\_rows.value() - row - 1 : row,
01469                               ReverseCol ? m\_cols.value() - col - 1 : col);
01470   \}
01471 
01472   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01473   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)
01474   \{
01475     \textcolor{keywordflow}{return} m\_argImpl.coeffRef(m\_rows.value() * m\_cols.value() - index - 1);
01476   \}
01477 
01478   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
01479   EIGEN\_STRONG\_INLINE
01480   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)\textcolor{keyword}{ const}
01481 \textcolor{keyword}{  }\{
01482     \textcolor{keyword}{enum} \{
01483       PacketSize = unpacket\_traits<PacketType>::size,
01484       OffsetRow  = ReverseRow && IsColMajor ? PacketSize : 1,
01485       OffsetCol  = ReverseCol && IsRowMajor ? PacketSize : 1
01486     \};
01487     \textcolor{keyword}{typedef} internal::reverse\_packet\_cond<PacketType,ReversePacket> reverse\_packet;
01488     \textcolor{keywordflow}{return} reverse\_packet::run(m\_argImpl.template packet<LoadMode,PacketType>(
01489                                   ReverseRow ? m\_rows.value() - row - OffsetRow : row,
01490                                   ReverseCol ? m\_cols.value() - col - OffsetCol : col));
01491   \}
01492 
01493   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
01494   EIGEN\_STRONG\_INLINE
01495   PacketType packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
01496 \textcolor{keyword}{  }\{
01497     \textcolor{keyword}{enum} \{ PacketSize = unpacket\_traits<PacketType>::size \};
01498     \textcolor{keywordflow}{return} preverse(m\_argImpl.template packet<LoadMode,PacketType>(m\_rows.value() * m\_cols.value() - index 
      - PacketSize));
01499   \}
01500 
01501   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
01502   EIGEN\_STRONG\_INLINE
01503   \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col, \textcolor{keyword}{const} PacketType& x)
01504   \{
01505     \textcolor{comment}{// FIXME we could factorize some code with packet(i,j)}
01506     \textcolor{keyword}{enum} \{
01507       PacketSize = unpacket\_traits<PacketType>::size,
01508       OffsetRow  = ReverseRow && IsColMajor ? PacketSize : 1,
01509       OffsetCol  = ReverseCol && IsRowMajor ? PacketSize : 1
01510     \};
01511     \textcolor{keyword}{typedef} internal::reverse\_packet\_cond<PacketType,ReversePacket> reverse\_packet;
01512     m\_argImpl.template writePacket<LoadMode>(
01513                                   ReverseRow ? m\_rows.value() - row - OffsetRow : row,
01514                                   ReverseCol ? m\_cols.value() - col - OffsetCol : col,
01515                                   reverse\_packet::run(x));
01516   \}
01517 
01518   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} PacketType>
01519   EIGEN\_STRONG\_INLINE
01520   \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index, \textcolor{keyword}{const} PacketType& x)
01521   \{
01522     \textcolor{keyword}{enum} \{ PacketSize = unpacket\_traits<PacketType>::size \};
01523     m\_argImpl.template writePacket<LoadMode>
01524       (m\_rows.value() * m\_cols.value() - index - PacketSize, preverse(x));
01525   \}
01526  
01527 \textcolor{keyword}{protected}:
01528   evaluator<ArgType> m\_argImpl;
01529 
01530   \textcolor{comment}{// If we do not reverse rows, then we do not need to know the number of rows; same for columns}
01531   \textcolor{comment}{// Nonetheless, in this case it is important to set to 1 such that the coeff(index) method works fine for
       vectors.}
01532   \textcolor{keyword}{const} variable\_if\_dynamic<Index, ReverseRow ? ArgType::RowsAtCompileTime : 1> m\_rows;
01533   \textcolor{keyword}{const} variable\_if\_dynamic<Index, ReverseCol ? ArgType::ColsAtCompileTime : 1> m\_cols;
01534 \};
01535 
01536 
01537 \textcolor{comment}{// -------------------- Diagonal --------------------}
01538 
01539 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keywordtype}{int} DiagIndex>
01540 \textcolor{keyword}{struct }evaluator<Diagonal<ArgType, DiagIndex> >
01541   : evaluator\_base<Diagonal<ArgType, DiagIndex> >
01542 \{
01543   \textcolor{keyword}{typedef} Diagonal<ArgType, DiagIndex> XprType;
01544   
01545   \textcolor{keyword}{enum} \{
01546     CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
01547     
01548     Flags = (\textcolor{keywordtype}{unsigned} int)(evaluator<ArgType>::Flags & (HereditaryBits | 
      \hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit}) & ~\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) | LinearAccessBit,
01549     
01550     Alignment = 0
01551   \};
01552 
01553   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} XprType& diagonal)
01554     : m\_argImpl(diagonal.nestedExpression()),
01555       m\_index(diagonal.index())
01556   \{ \}
01557  
01558   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
01559   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
01560 
01561   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01562   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index})\textcolor{keyword}{ const}
01563 \textcolor{keyword}{  }\{
01564     \textcolor{keywordflow}{return} m\_argImpl.coeff(row + rowOffset(), row + colOffset());
01565   \}
01566 
01567   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01568   CoeffReturnType coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
01569 \textcolor{keyword}{  }\{
01570     \textcolor{keywordflow}{return} m\_argImpl.coeff(index + rowOffset(), index + colOffset());
01571   \}
01572 
01573   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01574   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index})
01575   \{
01576     \textcolor{keywordflow}{return} m\_argImpl.coeffRef(row + rowOffset(), row + colOffset());
01577   \}
01578 
01579   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
01580   Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)
01581   \{
01582     \textcolor{keywordflow}{return} m\_argImpl.coeffRef(index + rowOffset(), index + colOffset());
01583   \}
01584 
01585 \textcolor{keyword}{protected}:
01586   evaluator<ArgType> m\_argImpl;
01587   \textcolor{keyword}{const} internal::variable\_if\_dynamicindex<Index, XprType::DiagIndex> m\_index;
01588 
01589 \textcolor{keyword}{private}:
01590   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rowOffset()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_index.value() > 0 ? 0 : -
      m\_index.value(); \}
01591   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} colOffset()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_index.value() > 0 ? m\_index
      .value() : 0; \}
01592 \};
01593 
01594 
01595 \textcolor{comment}{//----------------------------------------------------------------------}
01596 \textcolor{comment}{// deprecated code}
01597 \textcolor{comment}{//----------------------------------------------------------------------}
01598 
01599 \textcolor{comment}{// -------------------- EvalToTemp --------------------}
01600 
01601 \textcolor{comment}{// expression class for evaluating nested expression to a temporary}
01602 
01603 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType> \textcolor{keyword}{class }EvalToTemp;
01604 
01605 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType>
01606 \textcolor{keyword}{struct }traits<EvalToTemp<ArgType> >
01607   : \textcolor{keyword}{public} traits<ArgType>
01608 \{ \};
01609 
01610 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType>
01611 \textcolor{keyword}{class }EvalToTemp
01612   : \textcolor{keyword}{public} dense\_xpr\_base<EvalToTemp<ArgType> >::type
01613 \{
01614  \textcolor{keyword}{public}:
01615  
01616   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} dense\_xpr\_base<EvalToTemp>::type Base;
01617   EIGEN\_GENERIC\_PUBLIC\_INTERFACE(EvalToTemp)
01618  
01619   \textcolor{keyword}{explicit} EvalToTemp(\textcolor{keyword}{const} ArgType& arg)
01620     : m\_arg(arg)
01621   \{ \}
01622  
01623   \textcolor{keyword}{const} ArgType& arg()\textcolor{keyword}{ const}
01624 \textcolor{keyword}{  }\{
01625     \textcolor{keywordflow}{return} m\_arg;
01626   \}
01627 
01628   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }
01629 \textcolor{keyword}{  }\{
01630     \textcolor{keywordflow}{return} m\_arg.rows();
01631   \}
01632 
01633   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }
01634 \textcolor{keyword}{  }\{
01635     \textcolor{keywordflow}{return} m\_arg.cols();
01636   \}
01637 
01638  \textcolor{keyword}{private}:
01639   \textcolor{keyword}{const} ArgType& m\_arg;
01640 \};
01641  
01642 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType>
01643 \textcolor{keyword}{struct }evaluator<EvalToTemp<ArgType> >
01644   : \textcolor{keyword}{public} evaluator<typename ArgType::PlainObject>
01645 \{
01646   \textcolor{keyword}{typedef} EvalToTemp<ArgType>                   XprType;
01647   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ArgType::PlainObject         PlainObject;
01648   \textcolor{keyword}{typedef} evaluator<PlainObject> Base;
01649   
01650   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} XprType& xpr)
01651     : m\_result(xpr.arg())
01652   \{
01653     ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(m\_result);
01654   \}
01655 
01656   \textcolor{comment}{// This constructor is used when nesting an EvalTo evaluator in another evaluator}
01657   EIGEN\_DEVICE\_FUNC evaluator(const ArgType& arg)
01658     : m\_result(arg)
01659   \{
01660     ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(m\_result);
01661   \}
01662 
01663 protected:
01664   PlainObject m\_result;
01665 \};
01666 
01667 \} \textcolor{comment}{// namespace internal}
01668 
01669 \} \textcolor{comment}{// end namespace Eigen}
01670 
01671 \textcolor{preprocessor}{#endif // EIGEN\_COREEVALUATORS\_H}
\end{DoxyCode}
