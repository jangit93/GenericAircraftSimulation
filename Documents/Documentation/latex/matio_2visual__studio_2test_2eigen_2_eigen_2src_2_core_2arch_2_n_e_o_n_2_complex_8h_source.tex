\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_n_e_o_n_2_complex_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/arch/\+N\+E\+O\+N/\+Complex.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_n_e_o_n_2_complex_8h_source}\index{Complex.\+h@{Complex.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2010 Konstantinos Margaritis <markos@freevec.org>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_COMPLEX\_NEON\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_COMPLEX\_NEON\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00017 
00018 \textcolor{keyword}{inline} uint32x4\_t p4ui\_CONJ\_XOR() \{
00019 \textcolor{comment}{// See bug 1325, clang fails to call vld1q\_u64.}
00020 \textcolor{preprocessor}{#if EIGEN\_COMP\_CLANG}
00021   uint32x4\_t ret = \{ 0x00000000, 0x80000000, 0x00000000, 0x80000000 \};
00022   \textcolor{keywordflow}{return} ret;
00023 \textcolor{preprocessor}{#else}
00024   \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t conj\_XOR\_DATA[] = \{ 0x00000000, 0x80000000, 0x00000000, 0x80000000 \};
00025   \textcolor{keywordflow}{return} vld1q\_u32( conj\_XOR\_DATA );
00026 \textcolor{preprocessor}{#endif}
00027 \}
00028 
00029 \textcolor{keyword}{inline} uint32x2\_t p2ui\_CONJ\_XOR() \{
00030   \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t conj\_XOR\_DATA[] = \{ 0x00000000, 0x80000000 \};
00031   \textcolor{keywordflow}{return} vld1\_u32( conj\_XOR\_DATA );
00032 \}
00033 
00034 \textcolor{comment}{//---------- float ----------}
00035 \textcolor{keyword}{struct }Packet2cf
00036 \{
00037   EIGEN\_STRONG\_INLINE Packet2cf() \{\}
00038   EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} Packet2cf(\textcolor{keyword}{const} Packet4f& a) : v(a) \{\}
00039   Packet4f  v;
00040 \};
00041 
00042 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<float> >  : default\_packet\_traits
00043 \{
00044   \textcolor{keyword}{typedef} Packet2cf type;
00045   \textcolor{keyword}{typedef} Packet2cf half;
00046   \textcolor{keyword}{enum} \{
00047     Vectorizable = 1,
00048     AlignedOnScalar = 1,
00049     size = 2,
00050     HasHalfPacket = 0,
00051 
00052     HasAdd    = 1,
00053     HasSub    = 1,
00054     HasMul    = 1,
00055     HasDiv    = 1,
00056     HasNegate = 1,
00057     HasAbs    = 0,
00058     HasAbs2   = 0,
00059     HasMin    = 0,
00060     HasMax    = 0,
00061     HasSetLinear = 0
00062   \};
00063 \};
00064 
00065 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet2cf> \{ \textcolor{keyword}{typedef} std::complex<float> type; \textcolor{keyword}{enum} \{size=2, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet2cf half; \};
00066 
00067 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pset1<Packet2cf>(\textcolor{keyword}{const} std::complex<float>&  from)
00068 \{
00069   float32x2\_t r64;
00070   r64 = vld1\_f32((\textcolor{keywordtype}{float} *)&from);
00071 
00072   \textcolor{keywordflow}{return} Packet2cf(vcombine\_f32(r64, r64));
00073 \}
00074 
00075 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf padd<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{return} 
      Packet2cf(padd<Packet4f>(a.v,b.v)); \}
00076 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf psub<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{return} 
      Packet2cf(psub<Packet4f>(a.v,b.v)); \}
00077 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pnegate(\textcolor{keyword}{const} Packet2cf& a) \{ \textcolor{keywordflow}{return} Packet2cf(pnegate<Packet4f>(a
      .v)); \}
00078 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pconj(\textcolor{keyword}{const} Packet2cf& a)
00079 \{
00080   Packet4ui b = vreinterpretq\_u32\_f32(a.v);
00081   \textcolor{keywordflow}{return} Packet2cf(vreinterpretq\_f32\_u32(veorq\_u32(b, p4ui\_CONJ\_XOR())));
00082 \}
00083 
00084 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pmul<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)
00085 \{
00086   Packet4f v1, v2;
00087 
00088   \textcolor{comment}{// Get the real values of a | a1\_re | a1\_re | a2\_re | a2\_re |}
00089   v1 = vcombine\_f32(vdup\_lane\_f32(vget\_low\_f32(a.v), 0), vdup\_lane\_f32(vget\_high\_f32(a.v), 0));
00090   \textcolor{comment}{// Get the imag values of a | a1\_im | a1\_im | a2\_im | a2\_im |}
00091   v2 = vcombine\_f32(vdup\_lane\_f32(vget\_low\_f32(a.v), 1), vdup\_lane\_f32(vget\_high\_f32(a.v), 1));
00092   \textcolor{comment}{// Multiply the real a with b}
00093   v1 = vmulq\_f32(v1, b.v);
00094   \textcolor{comment}{// Multiply the imag a with b}
00095   v2 = vmulq\_f32(v2, b.v);
00096   \textcolor{comment}{// Conjugate v2 }
00097   v2 = vreinterpretq\_f32\_u32(veorq\_u32(vreinterpretq\_u32\_f32(v2), p4ui\_CONJ\_XOR()));
00098   \textcolor{comment}{// Swap real/imag elements in v2.}
00099   v2 = vrev64q\_f32(v2);
00100   \textcolor{comment}{// Add and return the result}
00101   \textcolor{keywordflow}{return} Packet2cf(vaddq\_f32(v1, v2));
00102 \}
00103 
00104 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pand   <Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)
00105 \{
00106   \textcolor{keywordflow}{return} Packet2cf(vreinterpretq\_f32\_u32(vandq\_u32(vreinterpretq\_u32\_f32(a.v),vreinterpretq\_u32\_f32(b.v))))
      ;
00107 \}
00108 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf por    <Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)
00109 \{
00110   \textcolor{keywordflow}{return} Packet2cf(vreinterpretq\_f32\_u32(vorrq\_u32(vreinterpretq\_u32\_f32(a.v),vreinterpretq\_u32\_f32(b.v))))
      ;
00111 \}
00112 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pxor   <Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)
00113 \{
00114   \textcolor{keywordflow}{return} Packet2cf(vreinterpretq\_f32\_u32(veorq\_u32(vreinterpretq\_u32\_f32(a.v),vreinterpretq\_u32\_f32(b.v))))
      ;
00115 \}
00116 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pandnot<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)
00117 \{
00118   \textcolor{keywordflow}{return} Packet2cf(vreinterpretq\_f32\_u32(vbicq\_u32(vreinterpretq\_u32\_f32(a.v),vreinterpretq\_u32\_f32(b.v))))
      ;
00119 \}
00120 
00121 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pload<Packet2cf>(\textcolor{keyword}{const} std::complex<float>* from) \{ 
      EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{return} Packet2cf(pload<Packet4f>((\textcolor{keyword}{const} \textcolor{keywordtype}{float}*)from)); \}
00122 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf ploadu<Packet2cf>(\textcolor{keyword}{const} std::complex<float>* from) \{ 
      EIGEN\_DEBUG\_UNALIGNED\_LOAD \textcolor{keywordflow}{return} Packet2cf(ploadu<Packet4f>((\textcolor{keyword}{const} \textcolor{keywordtype}{float}*)from)); \}
00123 
00124 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf ploaddup<Packet2cf>(\textcolor{keyword}{const} std::complex<float>* from) \{ \textcolor{keywordflow}{return} 
      pset1<Packet2cf>(*from); \}
00125 
00126 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore <std::complex<float> >(std::complex<float> *   to, \textcolor{keyword}{const} 
      Packet2cf& from) \{ EIGEN\_DEBUG\_ALIGNED\_STORE pstore((\textcolor{keywordtype}{float}*)to, from.v); \}
00127 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<std::complex<float> >(std::complex<float> *   to, \textcolor{keyword}{const} 
      Packet2cf& from) \{ EIGEN\_DEBUG\_UNALIGNED\_STORE pstoreu((\textcolor{keywordtype}{float}*)to, from.v); \}
00128 
00129 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet2cf pgather<std::complex<float>, Packet2cf>(\textcolor{keyword}{const} 
      std::complex<float>* from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00130 \{
00131   Packet4f res = pset1<Packet4f>(0.f);
00132   res = vsetq\_lane\_f32(std::real(from[0*stride]), res, 0);
00133   res = vsetq\_lane\_f32(std::imag(from[0*stride]), res, 1);
00134   res = vsetq\_lane\_f32(std::real(from[1*stride]), res, 2);
00135   res = vsetq\_lane\_f32(std::imag(from[1*stride]), res, 3);
00136   \textcolor{keywordflow}{return} Packet2cf(res);
00137 \}
00138 
00139 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, \textcolor{keyword}{
      const} Packet2cf& from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00140 \{
00141   to[stride*0] = std::complex<float>(vgetq\_lane\_f32(from.v, 0), vgetq\_lane\_f32(from.v, 1));
00142   to[stride*1] = std::complex<float>(vgetq\_lane\_f32(from.v, 2), vgetq\_lane\_f32(from.v, 3));
00143 \}
00144 
00145 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<std::complex<float> >(\textcolor{keyword}{const} std::complex<float> *   addr) \{ 
      EIGEN\_ARM\_PREFETCH((\textcolor{keywordtype}{float} *)addr); \}
00146 
00147 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float>  pfirst<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00148 \{
00149   std::complex<float> EIGEN\_ALIGN16 x[2];
00150   vst1q\_f32((\textcolor{keywordtype}{float} *)x, a.v);
00151   \textcolor{keywordflow}{return} x[0];
00152 \}
00153 
00154 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf preverse(\textcolor{keyword}{const} Packet2cf& a)
00155 \{
00156   float32x2\_t a\_lo, a\_hi;
00157   Packet4f a\_r128;
00158 
00159   a\_lo = vget\_low\_f32(a.v);
00160   a\_hi = vget\_high\_f32(a.v);
00161   a\_r128 = vcombine\_f32(a\_hi, a\_lo);
00162 
00163   \textcolor{keywordflow}{return} Packet2cf(a\_r128);
00164 \}
00165 
00166 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pcplxflip<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00167 \{
00168   \textcolor{keywordflow}{return} Packet2cf(vrev64q\_f32(a.v));
00169 \}
00170 
00171 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> predux<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00172 \{
00173   float32x2\_t a1, a2;
00174   std::complex<float> s;
00175 
00176   a1 = vget\_low\_f32(a.v);
00177   a2 = vget\_high\_f32(a.v);
00178   a2 = vadd\_f32(a1, a2);
00179   vst1\_f32((\textcolor{keywordtype}{float} *)&s, a2);
00180 
00181   \textcolor{keywordflow}{return} s;
00182 \}
00183 
00184 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf preduxp<Packet2cf>(\textcolor{keyword}{const} Packet2cf* vecs)
00185 \{
00186   Packet4f sum1, sum2, sum;
00187 
00188   \textcolor{comment}{// Add the first two 64-bit float32x2\_t of vecs[0]}
00189   sum1 = vcombine\_f32(vget\_low\_f32(vecs[0].v), vget\_low\_f32(vecs[1].v));
00190   sum2 = vcombine\_f32(vget\_high\_f32(vecs[0].v), vget\_high\_f32(vecs[1].v));
00191   sum = vaddq\_f32(sum1, sum2);
00192 
00193   \textcolor{keywordflow}{return} Packet2cf(sum);
00194 \}
00195 
00196 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> predux\_mul<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00197 \{
00198   float32x2\_t a1, a2, v1, v2, prod;
00199   std::complex<float> s;
00200 
00201   a1 = vget\_low\_f32(a.v);
00202   a2 = vget\_high\_f32(a.v);
00203    \textcolor{comment}{// Get the real values of a | a1\_re | a1\_re | a2\_re | a2\_re |}
00204   v1 = vdup\_lane\_f32(a1, 0);
00205   \textcolor{comment}{// Get the real values of a | a1\_im | a1\_im | a2\_im | a2\_im |}
00206   v2 = vdup\_lane\_f32(a1, 1);
00207   \textcolor{comment}{// Multiply the real a with b}
00208   v1 = vmul\_f32(v1, a2);
00209   \textcolor{comment}{// Multiply the imag a with b}
00210   v2 = vmul\_f32(v2, a2);
00211   \textcolor{comment}{// Conjugate v2 }
00212   v2 = vreinterpret\_f32\_u32(veor\_u32(vreinterpret\_u32\_f32(v2), p2ui\_CONJ\_XOR()));
00213   \textcolor{comment}{// Swap real/imag elements in v2.}
00214   v2 = vrev64\_f32(v2);
00215   \textcolor{comment}{// Add v1, v2}
00216   prod = vadd\_f32(v1, v2);
00217 
00218   vst1\_f32((\textcolor{keywordtype}{float} *)&s, prod);
00219 
00220   \textcolor{keywordflow}{return} s;
00221 \}
00222 
00223 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00224 \textcolor{keyword}{struct }palign\_impl<Offset,Packet2cf>
00225 \{
00226   EIGEN\_STRONG\_INLINE \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(Packet2cf& first, \textcolor{keyword}{const} Packet2cf& second)
00227   \{
00228     \textcolor{keywordflow}{if} (Offset==1)
00229     \{
00230       first.v = vextq\_f32(first.v, second.v, 2);
00231     \}
00232   \}
00233 \};
00234 
00235 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet2cf, false,true>
00236 \{
00237   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00238 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00239 
00240   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)\textcolor{keyword}{ const}
00241 \textcolor{keyword}{  }\{
00242     \textcolor{keywordflow}{return} internal::pmul(a, pconj(b));
00243   \}
00244 \};
00245 
00246 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet2cf, true,false>
00247 \{
00248   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00249 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00250 
00251   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)\textcolor{keyword}{ const}
00252 \textcolor{keyword}{  }\{
00253     \textcolor{keywordflow}{return} internal::pmul(pconj(a), b);
00254   \}
00255 \};
00256 
00257 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet2cf, true,true>
00258 \{
00259   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00260 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00261 
00262   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)\textcolor{keyword}{ const}
00263 \textcolor{keyword}{  }\{
00264     \textcolor{keywordflow}{return} pconj(internal::pmul(a, b));
00265   \}
00266 \};
00267 
00268 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pdiv<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)
00269 \{
00270   \textcolor{comment}{// TODO optimize it for NEON}
00271   Packet2cf res = conj\_helper<Packet2cf,Packet2cf,false,true>().pmul(a,b);
00272   Packet4f s, rev\_s;
00273 
00274   \textcolor{comment}{// this computes the norm}
00275   s = vmulq\_f32(b.v, b.v);
00276   rev\_s = vrev64q\_f32(s);
00277 
00278   \textcolor{keywordflow}{return} Packet2cf(pdiv(res.v, vaddq\_f32(s,rev\_s)));
00279 \}
00280 
00281 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00282 ptranspose(PacketBlock<Packet2cf,2>& kernel) \{
00283   Packet4f tmp = vcombine\_f32(vget\_high\_f32(kernel.packet[0].v), vget\_high\_f32(kernel.packet[1].v));
00284   kernel.packet[0].v = vcombine\_f32(vget\_low\_f32(kernel.packet[0].v), vget\_low\_f32(kernel.packet[1].v));
00285   kernel.packet[1].v = tmp;
00286 \}
00287 
00288 \textcolor{comment}{//---------- double ----------}
00289 \textcolor{preprocessor}{#if EIGEN\_ARCH\_ARM64 && !EIGEN\_APPLE\_DOUBLE\_NEON\_BUG}
00290 
00291 \textcolor{comment}{// See bug 1325, clang fails to call vld1q\_u64.}
00292 \textcolor{preprocessor}{#if EIGEN\_COMP\_CLANG}
00293   \textcolor{keyword}{static} uint64x2\_t p2ul\_CONJ\_XOR = \{0x0, 0x8000000000000000\};
00294 \textcolor{preprocessor}{#else}
00295   \textcolor{keyword}{const} uint64\_t  p2ul\_conj\_XOR\_DATA[] = \{ 0x0, 0x8000000000000000 \};
00296   \textcolor{keyword}{static} uint64x2\_t p2ul\_CONJ\_XOR = vld1q\_u64( p2ul\_conj\_XOR\_DATA );
00297 \textcolor{preprocessor}{#endif}
00298 
00299 \textcolor{keyword}{struct }Packet1cd
00300 \{
00301   EIGEN\_STRONG\_INLINE Packet1cd() \{\}
00302   EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} Packet1cd(\textcolor{keyword}{const} Packet2d& a) : v(a) \{\}
00303   Packet2d v;
00304 \};
00305 
00306 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<double> >  : default\_packet\_traits
00307 \{
00308   \textcolor{keyword}{typedef} Packet1cd type;
00309   \textcolor{keyword}{typedef} Packet1cd half;
00310   \textcolor{keyword}{enum} \{
00311     Vectorizable = 1,
00312     AlignedOnScalar = 0,
00313     size = 1,
00314     HasHalfPacket = 0,
00315 
00316     HasAdd    = 1,
00317     HasSub    = 1,
00318     HasMul    = 1,
00319     HasDiv    = 1,
00320     HasNegate = 1,
00321     HasAbs    = 0,
00322     HasAbs2   = 0,
00323     HasMin    = 0,
00324     HasMax    = 0,
00325     HasSetLinear = 0
00326   \};
00327 \};
00328 
00329 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet1cd> \{ \textcolor{keyword}{typedef} std::complex<double> type; \textcolor{keyword}{enum} \{size=1, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet1cd half; \};
00330 
00331 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pload<Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from) \{ 
      EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{return} Packet1cd(pload<Packet2d>((\textcolor{keyword}{const} \textcolor{keywordtype}{double}*)from)); \}
00332 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd ploadu<Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from) \{ 
      EIGEN\_DEBUG\_UNALIGNED\_LOAD \textcolor{keywordflow}{return} Packet1cd(ploadu<Packet2d>((\textcolor{keyword}{const} \textcolor{keywordtype}{double}*)from)); \}
00333 
00334 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pset1<Packet1cd>(\textcolor{keyword}{const} std::complex<double>&  from)
00335 \{ \textcolor{comment}{/* here we really have to use unaligned loads :( */} \textcolor{keywordflow}{return} ploadu<Packet1cd>(&from); \}
00336 
00337 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd padd<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{return} 
      Packet1cd(padd<Packet2d>(a.v,b.v)); \}
00338 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd psub<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{return} 
      Packet1cd(psub<Packet2d>(a.v,b.v)); \}
00339 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pnegate(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} Packet1cd(pnegate<Packet2d>(a
      .v)); \}
00340 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pconj(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} Packet1cd(vreinterpretq\_f64\_u64
      (veorq\_u64(vreinterpretq\_u64\_f64(a.v), p2ul\_CONJ\_XOR))); \}
00341 
00342 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pmul<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)
00343 \{
00344   Packet2d v1, v2;
00345 
00346   \textcolor{comment}{// Get the real values of a }
00347   v1 = vdupq\_lane\_f64(vget\_low\_f64(a.v), 0);
00348   \textcolor{comment}{// Get the imag values of a}
00349   v2 = vdupq\_lane\_f64(vget\_high\_f64(a.v), 0);
00350   \textcolor{comment}{// Multiply the real a with b}
00351   v1 = vmulq\_f64(v1, b.v);
00352   \textcolor{comment}{// Multiply the imag a with b}
00353   v2 = vmulq\_f64(v2, b.v);
00354   \textcolor{comment}{// Conjugate v2 }
00355   v2 = vreinterpretq\_f64\_u64(veorq\_u64(vreinterpretq\_u64\_f64(v2), p2ul\_CONJ\_XOR));
00356   \textcolor{comment}{// Swap real/imag elements in v2.}
00357   v2 = preverse<Packet2d>(v2);
00358   \textcolor{comment}{// Add and return the result}
00359   \textcolor{keywordflow}{return} Packet1cd(vaddq\_f64(v1, v2));
00360 \}
00361 
00362 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pand   <Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)
00363 \{
00364   \textcolor{keywordflow}{return} Packet1cd(vreinterpretq\_f64\_u64(vandq\_u64(vreinterpretq\_u64\_f64(a.v),vreinterpretq\_u64\_f64(b.v))))
      ;
00365 \}
00366 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd por    <Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)
00367 \{
00368   \textcolor{keywordflow}{return} Packet1cd(vreinterpretq\_f64\_u64(vorrq\_u64(vreinterpretq\_u64\_f64(a.v),vreinterpretq\_u64\_f64(b.v))))
      ;
00369 \}
00370 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pxor   <Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)
00371 \{
00372   \textcolor{keywordflow}{return} Packet1cd(vreinterpretq\_f64\_u64(veorq\_u64(vreinterpretq\_u64\_f64(a.v),vreinterpretq\_u64\_f64(b.v))))
      ;
00373 \}
00374 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pandnot<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)
00375 \{
00376   \textcolor{keywordflow}{return} Packet1cd(vreinterpretq\_f64\_u64(vbicq\_u64(vreinterpretq\_u64\_f64(a.v),vreinterpretq\_u64\_f64(b.v))))
      ;
00377 \}
00378 
00379 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd ploaddup<Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from) \{ \textcolor{keywordflow}{return} 
      pset1<Packet1cd>(*from); \}
00380 
00381 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore <std::complex<double> >(std::complex<double> *   to, \textcolor{keyword}{const} 
      Packet1cd& from) \{ EIGEN\_DEBUG\_ALIGNED\_STORE pstore((\textcolor{keywordtype}{double}*)to, from.v); \}
00382 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<std::complex<double> >(std::complex<double> *   to, \textcolor{keyword}{const} 
      Packet1cd& from) \{ EIGEN\_DEBUG\_UNALIGNED\_STORE pstoreu((\textcolor{keywordtype}{double}*)to, from.v); \}
00383 
00384 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<std::complex<double> >(\textcolor{keyword}{const} std::complex<double> *   addr) \{ 
      EIGEN\_ARM\_PREFETCH((\textcolor{keywordtype}{double} *)addr); \}
00385 
00386 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet1cd pgather<std::complex<double>, Packet1cd>(\textcolor{keyword}{const} 
      std::complex<double>* from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00387 \{
00388   Packet2d res = pset1<Packet2d>(0.0);
00389   res = vsetq\_lane\_f64(std::real(from[0*stride]), res, 0);
00390   res = vsetq\_lane\_f64(std::imag(from[0*stride]), res, 1);
00391   \textcolor{keywordflow}{return} Packet1cd(res);
00392 \}
00393 
00394 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to
      , \textcolor{keyword}{const} Packet1cd& from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00395 \{
00396   to[stride*0] = std::complex<double>(vgetq\_lane\_f64(from.v, 0), vgetq\_lane\_f64(from.v, 1));
00397 \}
00398 
00399 
00400 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double>  pfirst<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a)
00401 \{
00402   std::complex<double> EIGEN\_ALIGN16 res;
00403   pstore<std::complex<double> >(&res, a);
00404 
00405   \textcolor{keywordflow}{return} res;
00406 \}
00407 
00408 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd preverse(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} a; \}
00409 
00410 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double> predux<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} pfirst(a
      ); \}
00411 
00412 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd preduxp<Packet1cd>(\textcolor{keyword}{const} Packet1cd* vecs) \{ \textcolor{keywordflow}{return} vecs[0]; \}
00413 
00414 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double> predux\_mul<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} 
      pfirst(a); \}
00415 
00416 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00417 \textcolor{keyword}{struct }palign\_impl<Offset,Packet1cd>
00418 \{
00419   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet1cd& \textcolor{comment}{/*first*/}, \textcolor{keyword}{const} Packet1cd& \textcolor{comment}{/*second*/})
00420   \{
00421     \textcolor{comment}{// FIXME is it sure we never have to align a Packet1cd?}
00422     \textcolor{comment}{// Even though a std::complex<double> has 16 bytes, it is not necessarily aligned on a 16 bytes
       boundary...}
00423   \}
00424 \};
00425 
00426 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet1cd, Packet1cd, false,true>
00427 \{
00428   EIGEN\_STRONG\_INLINE Packet1cd pmadd(\textcolor{keyword}{const} Packet1cd& x, \textcolor{keyword}{const} Packet1cd& y, \textcolor{keyword}{const} Packet1cd& c)\textcolor{keyword}{ const}
00429 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00430 
00431   EIGEN\_STRONG\_INLINE Packet1cd pmul(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)\textcolor{keyword}{ const}
00432 \textcolor{keyword}{  }\{
00433     \textcolor{keywordflow}{return} internal::pmul(a, pconj(b));
00434   \}
00435 \};
00436 
00437 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet1cd, Packet1cd, true,false>
00438 \{
00439   EIGEN\_STRONG\_INLINE Packet1cd pmadd(\textcolor{keyword}{const} Packet1cd& x, \textcolor{keyword}{const} Packet1cd& y, \textcolor{keyword}{const} Packet1cd& c)\textcolor{keyword}{ const}
00440 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00441 
00442   EIGEN\_STRONG\_INLINE Packet1cd pmul(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)\textcolor{keyword}{ const}
00443 \textcolor{keyword}{  }\{
00444     \textcolor{keywordflow}{return} internal::pmul(pconj(a), b);
00445   \}
00446 \};
00447 
00448 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet1cd, Packet1cd, true,true>
00449 \{
00450   EIGEN\_STRONG\_INLINE Packet1cd pmadd(\textcolor{keyword}{const} Packet1cd& x, \textcolor{keyword}{const} Packet1cd& y, \textcolor{keyword}{const} Packet1cd& c)\textcolor{keyword}{ const}
00451 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00452 
00453   EIGEN\_STRONG\_INLINE Packet1cd pmul(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)\textcolor{keyword}{ const}
00454 \textcolor{keyword}{  }\{
00455     \textcolor{keywordflow}{return} pconj(internal::pmul(a, b));
00456   \}
00457 \};
00458 
00459 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pdiv<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)
00460 \{
00461   \textcolor{comment}{// TODO optimize it for NEON}
00462   Packet1cd res = conj\_helper<Packet1cd,Packet1cd,false,true>().pmul(a,b);
00463   Packet2d s = pmul<Packet2d>(b.v, b.v);
00464   Packet2d rev\_s = preverse<Packet2d>(s);
00465 
00466   \textcolor{keywordflow}{return} Packet1cd(pdiv(res.v, padd<Packet2d>(s,rev\_s)));
00467 \}
00468 
00469 EIGEN\_STRONG\_INLINE Packet1cd pcplxflip\textcolor{comment}{/*<Packet1cd>*/}(\textcolor{keyword}{const} Packet1cd& x)
00470 \{
00471   \textcolor{keywordflow}{return} Packet1cd(preverse(Packet2d(x.v)));
00472 \}
00473 
00474 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} ptranspose(PacketBlock<Packet1cd,2>& kernel)
00475 \{
00476   Packet2d tmp = vcombine\_f64(vget\_high\_f64(kernel.packet[0].v), vget\_high\_f64(kernel.packet[1].v));
00477   kernel.packet[0].v = vcombine\_f64(vget\_low\_f64(kernel.packet[0].v), vget\_low\_f64(kernel.packet[1].v));
00478   kernel.packet[1].v = tmp;
00479 \}
00480 \textcolor{preprocessor}{#endif // EIGEN\_ARCH\_ARM64}
00481 
00482 \} \textcolor{comment}{// end namespace internal}
00483 
00484 \} \textcolor{comment}{// end namespace Eigen}
00485 
00486 \textcolor{preprocessor}{#endif // EIGEN\_COMPLEX\_NEON\_H}
\end{DoxyCode}
