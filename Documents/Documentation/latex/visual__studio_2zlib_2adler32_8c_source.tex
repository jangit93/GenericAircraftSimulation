\hypertarget{visual__studio_2zlib_2adler32_8c_source}{}\section{visual\+\_\+studio/zlib/adler32.c}
\label{visual__studio_2zlib_2adler32_8c_source}\index{adler32.\+c@{adler32.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* adler32.c -- compute the Adler-32 checksum of a data stream}
00002 \textcolor{comment}{ * Copyright (C) 1995-2011, 2016 Mark Adler}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ */}
00005 
00006 \textcolor{comment}{/* @(#) $Id$ */}
00007 
00008 \textcolor{preprocessor}{#include "zutil.h"}
00009 
00010 local uLong adler32\_combine\_ OF((uLong adler1, uLong adler2, z\_off64\_t len2));
00011 
00012 \textcolor{preprocessor}{#define BASE 65521U     }\textcolor{comment}{/* largest prime smaller than 65536 */}\textcolor{preprocessor}{}
00013 \textcolor{preprocessor}{#define NMAX 5552}
00014 \textcolor{comment}{/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */}
00015 
00016 \textcolor{preprocessor}{#define DO1(buf,i)  \{adler += (buf)[i]; sum2 += adler;\}}
00017 \textcolor{preprocessor}{#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);}
00018 \textcolor{preprocessor}{#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);}
00019 \textcolor{preprocessor}{#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);}
00020 \textcolor{preprocessor}{#define DO16(buf)   DO8(buf,0); DO8(buf,8);}
00021 
00022 \textcolor{comment}{/* use NO\_DIVIDE if your processor does not do division in hardware --}
00023 \textcolor{comment}{   try it both ways to see which is faster */}
00024 \textcolor{preprocessor}{#ifdef NO\_DIVIDE}
00025 \textcolor{comment}{/* note that this assumes BASE is 65521, where 65536 % 65521 == 15}
00026 \textcolor{comment}{   (thank you to John Reiser for pointing this out) */}
00027 \textcolor{preprocessor}{#  define CHOP(a) \(\backslash\)}
00028 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00029 \textcolor{preprocessor}{        unsigned long tmp = a >> 16; \(\backslash\)}
00030 \textcolor{preprocessor}{        a &= 0xffffUL; \(\backslash\)}
00031 \textcolor{preprocessor}{        a += (tmp << 4) - tmp; \(\backslash\)}
00032 \textcolor{preprocessor}{    \} while (0)}
00033 \textcolor{preprocessor}{#  define MOD28(a) \(\backslash\)}
00034 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00035 \textcolor{preprocessor}{        CHOP(a); \(\backslash\)}
00036 \textcolor{preprocessor}{        if (a >= BASE) a -= BASE; \(\backslash\)}
00037 \textcolor{preprocessor}{    \} while (0)}
00038 \textcolor{preprocessor}{#  define MOD(a) \(\backslash\)}
00039 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00040 \textcolor{preprocessor}{        CHOP(a); \(\backslash\)}
00041 \textcolor{preprocessor}{        MOD28(a); \(\backslash\)}
00042 \textcolor{preprocessor}{    \} while (0)}
00043 \textcolor{preprocessor}{#  define MOD63(a) \(\backslash\)}
00044 \textcolor{preprocessor}{    do \{ }\textcolor{comment}{/* this assumes a is not negative */}\textcolor{preprocessor}{ \(\backslash\)}
00045 \textcolor{preprocessor}{        z\_off64\_t tmp = a >> 32; \(\backslash\)}
00046 \textcolor{preprocessor}{        a &= 0xffffffffL; \(\backslash\)}
00047 \textcolor{preprocessor}{        a += (tmp << 8) - (tmp << 5) + tmp; \(\backslash\)}
00048 \textcolor{preprocessor}{        tmp = a >> 16; \(\backslash\)}
00049 \textcolor{preprocessor}{        a &= 0xffffL; \(\backslash\)}
00050 \textcolor{preprocessor}{        a += (tmp << 4) - tmp; \(\backslash\)}
00051 \textcolor{preprocessor}{        tmp = a >> 16; \(\backslash\)}
00052 \textcolor{preprocessor}{        a &= 0xffffL; \(\backslash\)}
00053 \textcolor{preprocessor}{        a += (tmp << 4) - tmp; \(\backslash\)}
00054 \textcolor{preprocessor}{        if (a >= BASE) a -= BASE; \(\backslash\)}
00055 \textcolor{preprocessor}{    \} while (0)}
00056 \textcolor{preprocessor}{#else}
00057 \textcolor{preprocessor}{#  define MOD(a) a %= BASE}
00058 \textcolor{preprocessor}{#  define MOD28(a) a %= BASE}
00059 \textcolor{preprocessor}{#  define MOD63(a) a %= BASE}
00060 \textcolor{preprocessor}{#endif}
00061 
00062 \textcolor{comment}{/* ========================================================================= */}
00063 uLong ZEXPORT adler32\_z(adler, buf, len)
00064     uLong adler;
00065     \textcolor{keyword}{const} Bytef *buf;
00066     z\_size\_t len;
00067 \{
00068     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} sum2;
00069     \textcolor{keywordtype}{unsigned} n;
00070 
00071     \textcolor{comment}{/* split Adler-32 into component sums */}
00072     sum2 = (adler >> 16) & 0xffff;
00073     adler &= 0xffff;
00074 
00075     \textcolor{comment}{/* in case user likes doing a byte at a time, keep it fast */}
00076     \textcolor{keywordflow}{if} (len == 1) \{
00077         adler += buf[0];
00078         \textcolor{keywordflow}{if} (adler >= BASE)
00079             adler -= BASE;
00080         sum2 += adler;
00081         \textcolor{keywordflow}{if} (sum2 >= BASE)
00082             sum2 -= BASE;
00083         \textcolor{keywordflow}{return} adler | (sum2 << 16);
00084     \}
00085 
00086     \textcolor{comment}{/* initial Adler-32 value (deferred check for len == 1 speed) */}
00087     \textcolor{keywordflow}{if} (buf == Z\_NULL)
00088         \textcolor{keywordflow}{return} 1L;
00089 
00090     \textcolor{comment}{/* in case short lengths are provided, keep it somewhat fast */}
00091     \textcolor{keywordflow}{if} (len < 16) \{
00092         \textcolor{keywordflow}{while} (len--) \{
00093             adler += *buf++;
00094             sum2 += adler;
00095         \}
00096         \textcolor{keywordflow}{if} (adler >= BASE)
00097             adler -= BASE;
00098         MOD28(sum2);            \textcolor{comment}{/* only added so many BASE's */}
00099         \textcolor{keywordflow}{return} adler | (sum2 << 16);
00100     \}
00101 
00102     \textcolor{comment}{/* do length NMAX blocks -- requires just one modulo operation */}
00103     \textcolor{keywordflow}{while} (len >= NMAX) \{
00104         len -= NMAX;
00105         n = NMAX / 16;          \textcolor{comment}{/* NMAX is divisible by 16 */}
00106         \textcolor{keywordflow}{do} \{
00107             DO16(buf);          \textcolor{comment}{/* 16 sums unrolled */}
00108             buf += 16;
00109         \} \textcolor{keywordflow}{while} (--n);
00110         MOD(adler);
00111         MOD(sum2);
00112     \}
00113 
00114     \textcolor{comment}{/* do remaining bytes (less than NMAX, still just one modulo) */}
00115     \textcolor{keywordflow}{if} (len) \{                  \textcolor{comment}{/* avoid modulos if none remaining */}
00116         \textcolor{keywordflow}{while} (len >= 16) \{
00117             len -= 16;
00118             DO16(buf);
00119             buf += 16;
00120         \}
00121         \textcolor{keywordflow}{while} (len--) \{
00122             adler += *buf++;
00123             sum2 += adler;
00124         \}
00125         MOD(adler);
00126         MOD(sum2);
00127     \}
00128 
00129     \textcolor{comment}{/* return recombined sums */}
00130     \textcolor{keywordflow}{return} adler | (sum2 << 16);
00131 \}
00132 
00133 \textcolor{comment}{/* ========================================================================= */}
00134 uLong ZEXPORT adler32(adler, buf, len)
00135     uLong adler;
00136     \textcolor{keyword}{const} Bytef *buf;
00137     uInt len;
00138 \{
00139     \textcolor{keywordflow}{return} adler32\_z(adler, buf, len);
00140 \}
00141 
00142 \textcolor{comment}{/* ========================================================================= */}
00143 local uLong adler32\_combine\_(adler1, adler2, len2)
00144     uLong adler1;
00145     uLong adler2;
00146     z\_off64\_t len2;
00147 \{
00148     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} sum1;
00149     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} sum2;
00150     \textcolor{keywordtype}{unsigned} rem;
00151 
00152     \textcolor{comment}{/* for negative len, return invalid adler32 as a clue for debugging */}
00153     \textcolor{keywordflow}{if} (len2 < 0)
00154         \textcolor{keywordflow}{return} 0xffffffffUL;
00155 
00156     \textcolor{comment}{/* the derivation of this formula is left as an exercise for the reader */}
00157     MOD63(len2);                \textcolor{comment}{/* assumes len2 >= 0 */}
00158     rem = (unsigned)len2;
00159     sum1 = adler1 & 0xffff;
00160     sum2 = rem * sum1;
00161     MOD(sum2);
00162     sum1 += (adler2 & 0xffff) + BASE - 1;
00163     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
00164     \textcolor{keywordflow}{if} (sum1 >= BASE) sum1 -= BASE;
00165     \textcolor{keywordflow}{if} (sum1 >= BASE) sum1 -= BASE;
00166     \textcolor{keywordflow}{if} (sum2 >= ((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})BASE << 1)) sum2 -= ((\textcolor{keywordtype}{unsigned} long)BASE << 1);
00167     \textcolor{keywordflow}{if} (sum2 >= BASE) sum2 -= BASE;
00168     \textcolor{keywordflow}{return} sum1 | (sum2 << 16);
00169 \}
00170 
00171 \textcolor{comment}{/* ========================================================================= */}
00172 uLong ZEXPORT adler32\_combine(adler1, adler2, len2)
00173     uLong adler1;
00174     uLong adler2;
00175     z\_off\_t len2;
00176 \{
00177     \textcolor{keywordflow}{return} adler32\_combine\_(adler1, adler2, len2);
00178 \}
00179 
00180 uLong ZEXPORT adler32\_combine64(adler1, adler2, len2)
00181     uLong adler1;
00182     uLong adler2;
00183     z\_off64\_t len2;
00184 \{
00185     \textcolor{keywordflow}{return} adler32\_combine\_(adler1, adler2, len2);
00186 \}
\end{DoxyCode}
