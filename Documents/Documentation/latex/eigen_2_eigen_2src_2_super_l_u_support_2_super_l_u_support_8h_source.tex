\hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source}{}\section{eigen/\+Eigen/src/\+Super\+L\+U\+Support/\+Super\+L\+U\+Support.h}
\label{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source}\index{Super\+L\+U\+Support.\+h@{Super\+L\+U\+Support.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SUPERLUSUPPORT\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SUPERLUSUPPORT\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{preprocessor}{#if defined(SUPERLU\_MAJOR\_VERSION) && (SUPERLU\_MAJOR\_VERSION >= 5)}
00016 \textcolor{preprocessor}{#define DECL\_GSSVX(PREFIX,FLOATTYPE,KEYTYPE)        \(\backslash\)}
00017 \textcolor{preprocessor}{    extern "C" \{                                                                                          \(\backslash\)}
00018 \textcolor{preprocessor}{      extern void PREFIX##gssvx(superlu\_options\_t *, SuperMatrix *, int *, int *, int *,                  \(\backslash\)}
00019 \textcolor{preprocessor}{                                char *, FLOATTYPE *, FLOATTYPE *, SuperMatrix *, SuperMatrix *,           \(\backslash\)}
00020 \textcolor{preprocessor}{                                void *, int, SuperMatrix *, SuperMatrix *,                                \(\backslash\)}
00021 \textcolor{preprocessor}{                                FLOATTYPE *, FLOATTYPE *, FLOATTYPE *, FLOATTYPE *,                       \(\backslash\)}
00022 \textcolor{preprocessor}{                                GlobalLU\_t *, mem\_usage\_t *, SuperLUStat\_t *, int *);                     \(\backslash\)}
00023 \textcolor{preprocessor}{    \}                                                                                                     \(\backslash\)}
00024 \textcolor{preprocessor}{    inline float SuperLU\_gssvx(superlu\_options\_t *options, SuperMatrix *A,                                \(\backslash\)}
00025 \textcolor{preprocessor}{         int *perm\_c, int *perm\_r, int *etree, char *equed,                                               \(\backslash\)}
00026 \textcolor{preprocessor}{         FLOATTYPE *R, FLOATTYPE *C, SuperMatrix *L,                                                      \(\backslash\)}
00027 \textcolor{preprocessor}{         SuperMatrix *U, void *work, int lwork,                                                           \(\backslash\)}
00028 \textcolor{preprocessor}{         SuperMatrix *B, SuperMatrix *X,                                                                  \(\backslash\)}
00029 \textcolor{preprocessor}{         FLOATTYPE *recip\_pivot\_growth,                                                                   \(\backslash\)}
00030 \textcolor{preprocessor}{         FLOATTYPE *rcond, FLOATTYPE *ferr, FLOATTYPE *berr,                                              \(\backslash\)}
00031 \textcolor{preprocessor}{         SuperLUStat\_t *stats, int *info, KEYTYPE) \{                                                      \(\backslash\)}
00032 \textcolor{preprocessor}{    mem\_usage\_t mem\_usage;                                                                                \(\backslash\)}
00033 \textcolor{preprocessor}{    GlobalLU\_t gLU;                                                                                       \(\backslash\)}
00034 \textcolor{preprocessor}{    PREFIX##gssvx(options, A, perm\_c, perm\_r, etree, equed, R, C, L,                                      \(\backslash\)}
00035 \textcolor{preprocessor}{         U, work, lwork, B, X, recip\_pivot\_growth, rcond,                                                 \(\backslash\)}
00036 \textcolor{preprocessor}{         ferr, berr, &gLU, &mem\_usage, stats, info);                                                      \(\backslash\)}
00037 \textcolor{preprocessor}{    return mem\_usage.for\_lu; }\textcolor{comment}{/* bytes used by the factor storage */}\textcolor{preprocessor}{                                       \(\backslash\)}
00038 \textcolor{preprocessor}{  \}}
00039 \textcolor{preprocessor}{#else // version < 5.0}
00040 \textcolor{preprocessor}{#define DECL\_GSSVX(PREFIX,FLOATTYPE,KEYTYPE)        \(\backslash\)}
00041 \textcolor{preprocessor}{    extern "C" \{                                                                                          \(\backslash\)}
00042 \textcolor{preprocessor}{      extern void PREFIX##gssvx(superlu\_options\_t *, SuperMatrix *, int *, int *, int *,                  \(\backslash\)}
00043 \textcolor{preprocessor}{                                char *, FLOATTYPE *, FLOATTYPE *, SuperMatrix *, SuperMatrix *,           \(\backslash\)}
00044 \textcolor{preprocessor}{                                void *, int, SuperMatrix *, SuperMatrix *,                                \(\backslash\)}
00045 \textcolor{preprocessor}{                                FLOATTYPE *, FLOATTYPE *, FLOATTYPE *, FLOATTYPE *,                       \(\backslash\)}
00046 \textcolor{preprocessor}{                                mem\_usage\_t *, SuperLUStat\_t *, int *);                                   \(\backslash\)}
00047 \textcolor{preprocessor}{    \}                                                                                                     \(\backslash\)}
00048 \textcolor{preprocessor}{    inline float SuperLU\_gssvx(superlu\_options\_t *options, SuperMatrix *A,                                \(\backslash\)}
00049 \textcolor{preprocessor}{         int *perm\_c, int *perm\_r, int *etree, char *equed,                                               \(\backslash\)}
00050 \textcolor{preprocessor}{         FLOATTYPE *R, FLOATTYPE *C, SuperMatrix *L,                                                      \(\backslash\)}
00051 \textcolor{preprocessor}{         SuperMatrix *U, void *work, int lwork,                                                           \(\backslash\)}
00052 \textcolor{preprocessor}{         SuperMatrix *B, SuperMatrix *X,                                                                  \(\backslash\)}
00053 \textcolor{preprocessor}{         FLOATTYPE *recip\_pivot\_growth,                                                                   \(\backslash\)}
00054 \textcolor{preprocessor}{         FLOATTYPE *rcond, FLOATTYPE *ferr, FLOATTYPE *berr,                                              \(\backslash\)}
00055 \textcolor{preprocessor}{         SuperLUStat\_t *stats, int *info, KEYTYPE) \{                                                      \(\backslash\)}
00056 \textcolor{preprocessor}{    mem\_usage\_t mem\_usage;                                                                                \(\backslash\)}
00057 \textcolor{preprocessor}{    PREFIX##gssvx(options, A, perm\_c, perm\_r, etree, equed, R, C, L,                                      \(\backslash\)}
00058 \textcolor{preprocessor}{         U, work, lwork, B, X, recip\_pivot\_growth, rcond,                                                 \(\backslash\)}
00059 \textcolor{preprocessor}{         ferr, berr, &mem\_usage, stats, info);                                                            \(\backslash\)}
00060 \textcolor{preprocessor}{    return mem\_usage.for\_lu; }\textcolor{comment}{/* bytes used by the factor storage */}\textcolor{preprocessor}{                                       \(\backslash\)}
00061 \textcolor{preprocessor}{  \}}
00062 \textcolor{preprocessor}{#endif}
00063 
00064 DECL\_GSSVX(s,\textcolor{keywordtype}{float},\textcolor{keywordtype}{float})
00065 DECL\_GSSVX(c,\textcolor{keywordtype}{float},std::complex<float>)
00066 DECL\_GSSVX(d,\textcolor{keywordtype}{double},\textcolor{keywordtype}{double})
00067 DECL\_GSSVX(z,\textcolor{keywordtype}{double},std::complex<double>)
00068 
00069 \textcolor{preprocessor}{#ifdef MILU\_ALPHA}
00070 \textcolor{preprocessor}{#define EIGEN\_SUPERLU\_HAS\_ILU}
00071 \textcolor{preprocessor}{#endif}
00072 
00073 \textcolor{preprocessor}{#ifdef EIGEN\_SUPERLU\_HAS\_ILU}
00074 
00075 \textcolor{comment}{// similarly for the incomplete factorization using gsisx}
00076 \textcolor{preprocessor}{#define DECL\_GSISX(PREFIX,FLOATTYPE,KEYTYPE)                                                    \(\backslash\)}
00077 \textcolor{preprocessor}{    extern "C" \{                                                                                \(\backslash\)}
00078 \textcolor{preprocessor}{      extern void PREFIX##gsisx(superlu\_options\_t *, SuperMatrix *, int *, int *, int *,        \(\backslash\)}
00079 \textcolor{preprocessor}{                         char *, FLOATTYPE *, FLOATTYPE *, SuperMatrix *, SuperMatrix *,        \(\backslash\)}
00080 \textcolor{preprocessor}{                         void *, int, SuperMatrix *, SuperMatrix *, FLOATTYPE *, FLOATTYPE *,   \(\backslash\)}
00081 \textcolor{preprocessor}{                         mem\_usage\_t *, SuperLUStat\_t *, int *);                        \(\backslash\)}
00082 \textcolor{preprocessor}{    \}                                                                                           \(\backslash\)}
00083 \textcolor{preprocessor}{    inline float SuperLU\_gsisx(superlu\_options\_t *options, SuperMatrix *A,                      \(\backslash\)}
00084 \textcolor{preprocessor}{         int *perm\_c, int *perm\_r, int *etree, char *equed,                                     \(\backslash\)}
00085 \textcolor{preprocessor}{         FLOATTYPE *R, FLOATTYPE *C, SuperMatrix *L,                                            \(\backslash\)}
00086 \textcolor{preprocessor}{         SuperMatrix *U, void *work, int lwork,                                                 \(\backslash\)}
00087 \textcolor{preprocessor}{         SuperMatrix *B, SuperMatrix *X,                                                        \(\backslash\)}
00088 \textcolor{preprocessor}{         FLOATTYPE *recip\_pivot\_growth,                                                         \(\backslash\)}
00089 \textcolor{preprocessor}{         FLOATTYPE *rcond,                                                                      \(\backslash\)}
00090 \textcolor{preprocessor}{         SuperLUStat\_t *stats, int *info, KEYTYPE) \{                                            \(\backslash\)}
00091 \textcolor{preprocessor}{    mem\_usage\_t mem\_usage;                                                              \(\backslash\)}
00092 \textcolor{preprocessor}{    PREFIX##gsisx(options, A, perm\_c, perm\_r, etree, equed, R, C, L,                            \(\backslash\)}
00093 \textcolor{preprocessor}{         U, work, lwork, B, X, recip\_pivot\_growth, rcond,                                       \(\backslash\)}
00094 \textcolor{preprocessor}{         &mem\_usage, stats, info);                                                              \(\backslash\)}
00095 \textcolor{preprocessor}{    return mem\_usage.for\_lu; }\textcolor{comment}{/* bytes used by the factor storage */}\textcolor{preprocessor}{                             \(\backslash\)}
00096 \textcolor{preprocessor}{  \}}
00097 
00098 DECL\_GSISX(s,\textcolor{keywordtype}{float},\textcolor{keywordtype}{float})
00099 DECL\_GSISX(c,\textcolor{keywordtype}{float},std::complex<float>)
00100 DECL\_GSISX(d,\textcolor{keywordtype}{double},\textcolor{keywordtype}{double})
00101 DECL\_GSISX(z,\textcolor{keywordtype}{double},std::complex<double>)
00102 
00103 \textcolor{preprocessor}{#endif}
00104 
00105 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00106}\hyperlink{struct_eigen_1_1_slu_matrix_map_helper}{00106} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_slu_matrix_map_helper}{SluMatrixMapHelper};
00107 
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00115}\hyperlink{struct_eigen_1_1_slu_matrix}{00115} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix} : SuperMatrix
00116 \{
00117   \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix}()
00118   \{
00119     Store = &storage;
00120   \}
00121 
00122   \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix}(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix}& other)
00123     : SuperMatrix(other)
00124   \{
00125     Store = &storage;
00126     storage = other.storage;
00127   \}
00128 
00129   \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix}& operator=(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix}& other)
00130   \{
00131     SuperMatrix::operator=(static\_cast<const SuperMatrix&>(other));
00132     Store = &storage;
00133     storage = other.storage;
00134     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00135   \}
00136 
00137   \textcolor{keyword}{struct}
00138   \{
00139     \textcolor{keyword}{union }\{\textcolor{keywordtype}{int} nnz;\textcolor{keywordtype}{int} lda;\};
00140     \textcolor{keywordtype}{void} *values;
00141     \textcolor{keywordtype}{int} *innerInd;
00142     \textcolor{keywordtype}{int} *outerInd;
00143   \} storage;
00144 
00145   \textcolor{keywordtype}{void} setStorageType(Stype\_t t)
00146   \{
00147     Stype = t;
00148     \textcolor{keywordflow}{if} (t==SLU\_NC || t==SLU\_NR || t==SLU\_DN)
00149       Store = &storage;
00150     \textcolor{keywordflow}{else}
00151     \{
00152       eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"storage type not supported"});
00153       Store = 0;
00154     \}
00155   \}
00156 
00157   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00158   \textcolor{keywordtype}{void} setScalarType()
00159   \{
00160     \textcolor{keywordflow}{if} (\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar,float>::value})
00161       Dtype = SLU\_S;
00162     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar,double>::value})
00163       Dtype = SLU\_D;
00164     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same}<Scalar,std::complex<float> >::value)
00165       Dtype = SLU\_C;
00166     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same}<Scalar,std::complex<double> >::value)
00167       Dtype = SLU\_Z;
00168     \textcolor{keywordflow}{else}
00169     \{
00170       eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Scalar type not supported by SuperLU"});
00171     \}
00172   \}
00173 
00174   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00175   \textcolor{keyword}{static} \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix} \hyperlink{group___core___module_class_eigen_1_1_map}{Map}(\hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<MatrixType>}& \_mat)
00176   \{
00177     MatrixType& mat(\_mat.derived());
00178     eigen\_assert( ((MatrixType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})!=RowMajorBit) && \textcolor{stringliteral}{"row-major dense matrices
       are not supported by SuperLU"});
00179     \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix} res;
00180     res.setStorageType(SLU\_DN);
00181     res.setScalarType<\textcolor{keyword}{typename} MatrixType::Scalar>();
00182     res.Mtype     = SLU\_GE;
00183 
00184     res.nrow      = internal::convert\_index<int>(mat.rows());
00185     res.ncol      = internal::convert\_index<int>(mat.cols());
00186 
00187     res.storage.lda       = internal::convert\_index<int>(MatrixType::IsVectorAtCompileTime ? mat.size() : 
      mat.outerStride());
00188     res.storage.values    = (\textcolor{keywordtype}{void}*)(mat.data());
00189     \textcolor{keywordflow}{return} res;
00190   \}
00191 
00192   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00193   \textcolor{keyword}{static} \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix} \hyperlink{group___core___module_class_eigen_1_1_map}{Map}(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<MatrixType>}& a\_mat)
00194   \{
00195     MatrixType &mat(a\_mat.derived());
00196     \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix} res;
00197     \textcolor{keywordflow}{if} ((MatrixType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})
00198     \{
00199       res.setStorageType(SLU\_NR);
00200       res.nrow      = internal::convert\_index<int>(mat.cols());
00201       res.ncol      = internal::convert\_index<int>(mat.rows());
00202     \}
00203     \textcolor{keywordflow}{else}
00204     \{
00205       res.setStorageType(SLU\_NC);
00206       res.nrow      = internal::convert\_index<int>(mat.rows());
00207       res.ncol      = internal::convert\_index<int>(mat.cols());
00208     \}
00209 
00210     res.Mtype       = SLU\_GE;
00211 
00212     res.storage.nnz       = internal::convert\_index<int>(mat.nonZeros());
00213     res.storage.values    = mat.valuePtr();
00214     res.storage.innerInd  = mat.innerIndexPtr();
00215     res.storage.outerInd  = mat.outerIndexPtr();
00216 
00217     res.setScalarType<\textcolor{keyword}{typename} MatrixType::Scalar>();
00218 
00219     \textcolor{comment}{// FIXME the following is not very accurate}
00220     \textcolor{keywordflow}{if} (MatrixType::Flags & \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper})
00221       res.Mtype = SLU\_TRU;
00222     \textcolor{keywordflow}{if} (MatrixType::Flags & \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower})
00223       res.Mtype = SLU\_TRL;
00224 
00225     eigen\_assert(((MatrixType::Flags & \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda2491fc6765056421f504eb7e16083e8f}{SelfAdjoint})==0) && \textcolor{stringliteral}{"SelfAdjoint matrix shape not
       supported by SuperLU"});
00226 
00227     \textcolor{keywordflow}{return} res;
00228   \}
00229 \};
00230 
00231 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Rows, \textcolor{keywordtype}{int} Cols, \textcolor{keywordtype}{int} Options, \textcolor{keywordtype}{int} MRows, \textcolor{keywordtype}{int} MCols>
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00232}\hyperlink{struct_eigen_1_1_slu_matrix_map_helper_3_01_matrix_3_01_scalar_00_01_rows_00_01_cols_00_01_optioce31c400c0dc6b34c9e9bbf922bc7aae}{00232} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_slu_matrix_map_helper}{SluMatrixMapHelper}<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<Scalar,Rows,Cols,Options,MRows,MCols> >
00233 \{
00234   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Rows,Cols,Options,MRows,MCols>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{MatrixType};
00235   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType& mat, \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix}& res)
00236   \{
00237     eigen\_assert( ((Options&\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor})!=RowMajor) && \textcolor{stringliteral}{"row-major dense matrices is not supported by
       SuperLU"});
00238     res.setStorageType(SLU\_DN);
00239     res.setScalarType<Scalar>();
00240     res.Mtype     = SLU\_GE;
00241 
00242     res.nrow      = mat.rows();
00243     res.ncol      = mat.cols();
00244 
00245     res.storage.lda       = mat.outerStride();
00246     res.storage.values    = mat.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}();
00247   \}
00248 \};
00249 
00250 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00251}\hyperlink{struct_eigen_1_1_slu_matrix_map_helper_3_01_sparse_matrix_base_3_01_derived_01_4_01_4}{00251} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_slu_matrix_map_helper}{SluMatrixMapHelper}<\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase}<Derived> >
00252 \{
00253   \textcolor{keyword}{typedef} Derived MatrixType;
00254   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType& mat, \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix}& res)
00255   \{
00256     \textcolor{keywordflow}{if} ((MatrixType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==RowMajorBit)
00257     \{
00258       res.setStorageType(SLU\_NR);
00259       res.nrow      = mat.cols();
00260       res.ncol      = mat.rows();
00261     \}
00262     \textcolor{keywordflow}{else}
00263     \{
00264       res.setStorageType(SLU\_NC);
00265       res.nrow      = mat.rows();
00266       res.ncol      = mat.cols();
00267     \}
00268 
00269     res.Mtype       = SLU\_GE;
00270 
00271     res.storage.nnz       = mat.nonZeros();
00272     res.storage.values    = mat.valuePtr();
00273     res.storage.innerInd  = mat.innerIndexPtr();
00274     res.storage.outerInd  = mat.outerIndexPtr();
00275 
00276     res.setScalarType<\textcolor{keyword}{typename} MatrixType::Scalar>();
00277 
00278     \textcolor{comment}{// FIXME the following is not very accurate}
00279     \textcolor{keywordflow}{if} (MatrixType::Flags & \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper})
00280       res.Mtype = SLU\_TRU;
00281     \textcolor{keywordflow}{if} (MatrixType::Flags & \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower})
00282       res.Mtype = SLU\_TRL;
00283 
00284     eigen\_assert(((MatrixType::Flags & \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda2491fc6765056421f504eb7e16083e8f}{SelfAdjoint})==0) && \textcolor{stringliteral}{"SelfAdjoint matrix shape not
       supported by SuperLU"});
00285   \}
00286 \};
00287 
00288 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00289 
00290 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00291 \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix} asSluMatrix(MatrixType& mat)
00292 \{
00293   \textcolor{keywordflow}{return} SluMatrix::Map(mat);
00294 \}
00295 
00297 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Flags, \textcolor{keyword}{typename} Index>
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00298}\hyperlink{namespace_eigen_1_1internal_a3623dd66c579fac70fa26a40aae5061b}{00298} \hyperlink{class_eigen_1_1_mapped_sparse_matrix}{MappedSparseMatrix<Scalar,Flags,Index>} 
      \hyperlink{namespace_eigen_1_1internal_a3623dd66c579fac70fa26a40aae5061b}{map\_superlu}(\hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix}& sluMat)
00299 \{
00300   eigen\_assert((Flags&\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor})==RowMajor && sluMat.Stype == SLU\_NR
00301          || (Flags&\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})==ColMajor && sluMat.Stype == SLU\_NC);
00302 
00303   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerSize = (Flags&\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor})==RowMajor ? sluMat.ncol : sluMat.nrow;
00304 
00305   \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_mapped_sparse_matrix}{MappedSparseMatrix<Scalar,Flags,Index>}(
00306     sluMat.nrow, sluMat.ncol, sluMat.storage.outerInd[outerSize],
00307     sluMat.storage.outerInd, sluMat.storage.innerInd, reinterpret\_cast<Scalar*>(sluMat.storage.values) );
00308 \}
00309 
00310 \} \textcolor{comment}{// end namespace internal}
00311 
00316 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00317}\hyperlink{class_eigen_1_1_super_l_u_base}{00317} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_super_l_u_base}{SuperLUBase} : \textcolor{keyword}{public} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase}<Derived>
00318 \{
00319   \textcolor{keyword}{protected}:
00320     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase<Derived>} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{Base};
00321     \textcolor{keyword}{using} Base::derived;
00322     \textcolor{keyword}{using} Base::m\_isInitialized;
00323   \textcolor{keyword}{public}:
00324     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00325     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00326     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00327     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00328     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} \hyperlink{group___core___module}{Vector};
00329     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<int, 1, MatrixType::ColsAtCompileTime>} 
      \hyperlink{group___core___module}{IntRowVectorType};
00330     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<int, MatrixType::RowsAtCompileTime, 1>} 
      \hyperlink{group___core___module}{IntColVectorType};    
00331     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<PermutationMatrix<Dynamic,Dynamic,int>} > 
      \hyperlink{group___core___module_class_eigen_1_1_map}{PermutationMap};
00332     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar>} \hyperlink{group___sparse_core___module}{LUMatrixType};
00333     \textcolor{keyword}{enum} \{
00334       ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00335       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
00336     \};
00337 
00338   \textcolor{keyword}{public}:
00339 
00340     \hyperlink{class_eigen_1_1_super_l_u_base}{SuperLUBase}() \{\}
00341 
00342     ~\hyperlink{class_eigen_1_1_super_l_u_base}{SuperLUBase}()
00343     \{
00344       clearFactors();
00345     \}
00346     
00347     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix.rows(); \}
00348     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix.cols(); \}
00349     
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00351}\hyperlink{class_eigen_1_1_super_l_u_base_a42d9d79073379f1e75b0f2c49879ed5b}{00351}     \textcolor{keyword}{inline} superlu\_options\_t& \hyperlink{class_eigen_1_1_super_l_u_base_a42d9d79073379f1e75b0f2c49879ed5b}{options}() \{ \textcolor{keywordflow}{return} m\_sluOptions; \}
00352     
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00358}\hyperlink{class_eigen_1_1_super_l_u_base_aa67da5c8c24110931c949c5896c5ec03}{00358}     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} \hyperlink{class_eigen_1_1_super_l_u_base_aa67da5c8c24110931c949c5896c5ec03}{info}()\textcolor{keyword}{ const}
00359 \textcolor{keyword}{    }\{
00360       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"Decomposition is not initialized."});
00361       \textcolor{keywordflow}{return} m\_info;
00362     \}
00363 
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00365}\hyperlink{class_eigen_1_1_super_l_u_base_a28cb3ef7914ecb6fdae1935b53f6be40}{00365}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_super_l_u_base_a28cb3ef7914ecb6fdae1935b53f6be40}{compute}(\textcolor{keyword}{const} MatrixType& matrix)
00366     \{
00367       derived().analyzePattern(matrix);
00368       derived().factorize(matrix);
00369     \}
00370 
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00377}\hyperlink{class_eigen_1_1_super_l_u_base_a2d3f48425328d9b3cbdca369889007f3}{00377}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_super_l_u_base_a2d3f48425328d9b3cbdca369889007f3}{analyzePattern}(\textcolor{keyword}{const} MatrixType& \textcolor{comment}{/*matrix*/})
00378     \{
00379       m\_isInitialized = \textcolor{keyword}{true};
00380       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00381       m\_analysisIsOk = \textcolor{keyword}{true};
00382       m\_factorizationIsOk = \textcolor{keyword}{false};
00383     \}
00384     
00385     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Stream>
00386     \textcolor{keywordtype}{void} dumpMemory(Stream& \textcolor{comment}{/*s*/})
00387     \{\}
00388     
00389   \textcolor{keyword}{protected}:
00390     
00391     \textcolor{keywordtype}{void} initFactorization(\textcolor{keyword}{const} MatrixType& a)
00392     \{
00393       set\_default\_options(&this->m\_sluOptions);
00394       
00395       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = a.rows();
00396       m\_matrix = a;
00397 
00398       m\_sluA = internal::asSluMatrix(m\_matrix);
00399       clearFactors();
00400 
00401       m\_p.resize(size);
00402       m\_q.resize(size);
00403       m\_sluRscale.resize(size);
00404       m\_sluCscale.resize(size);
00405       m\_sluEtree.resize(size);
00406 
00407       \textcolor{comment}{// set empty B and X}
00408       m\_sluB.setStorageType(SLU\_DN);
00409       m\_sluB.setScalarType<Scalar>();
00410       m\_sluB.Mtype          = SLU\_GE;
00411       m\_sluB.storage.values = 0;
00412       m\_sluB.nrow           = 0;
00413       m\_sluB.ncol           = 0;
00414       m\_sluB.storage.lda    = internal::convert\_index<int>(size);
00415       m\_sluX                = m\_sluB;
00416       
00417       m\_extractedDataAreDirty = \textcolor{keyword}{true};
00418     \}
00419     
00420     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}()
00421     \{
00422       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434}{InvalidInput};
00423       m\_isInitialized = \textcolor{keyword}{false};
00424       m\_sluL.Store = 0;
00425       m\_sluU.Store = 0;
00426     \}
00427     
00428     \textcolor{keywordtype}{void} extractData() \textcolor{keyword}{const};
00429 
00430     \textcolor{keywordtype}{void} clearFactors()
00431     \{
00432       \textcolor{keywordflow}{if}(m\_sluL.Store)
00433         Destroy\_SuperNode\_Matrix(&m\_sluL);
00434       \textcolor{keywordflow}{if}(m\_sluU.Store)
00435         Destroy\_CompCol\_Matrix(&m\_sluU);
00436 
00437       m\_sluL.Store = 0;
00438       m\_sluU.Store = 0;
00439 
00440       memset(&m\_sluL,0,\textcolor{keyword}{sizeof} m\_sluL);
00441       memset(&m\_sluU,0,\textcolor{keyword}{sizeof} m\_sluU);
00442     \}
00443 
00444     \textcolor{comment}{// cached data to reduce reallocation, etc.}
00445     \textcolor{keyword}{mutable} LUMatrixType m\_l;
00446     \textcolor{keyword}{mutable} LUMatrixType m\_u;
00447     \textcolor{keyword}{mutable} IntColVectorType m\_p;
00448     \textcolor{keyword}{mutable} IntRowVectorType m\_q;
00449 
00450     \textcolor{keyword}{mutable} LUMatrixType m\_matrix;  \textcolor{comment}{// copy of the factorized matrix}
00451     \textcolor{keyword}{mutable} \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix} m\_sluA;
00452     \textcolor{keyword}{mutable} SuperMatrix m\_sluL, m\_sluU;
00453     \textcolor{keyword}{mutable} \hyperlink{struct_eigen_1_1_slu_matrix}{SluMatrix} m\_sluB, m\_sluX;
00454     \textcolor{keyword}{mutable} SuperLUStat\_t m\_sluStat;
00455     \textcolor{keyword}{mutable} superlu\_options\_t m\_sluOptions;
00456     \textcolor{keyword}{mutable} std::vector<int> m\_sluEtree;
00457     \textcolor{keyword}{mutable} \hyperlink{group___core___module}{Matrix<RealScalar,Dynamic,1>} m\_sluRscale, m\_sluCscale;
00458     \textcolor{keyword}{mutable} \hyperlink{group___core___module}{Matrix<RealScalar,Dynamic,1>} m\_sluFerr, m\_sluBerr;
00459     \textcolor{keyword}{mutable} \textcolor{keywordtype}{char} m\_sluEqued;
00460 
00461     \textcolor{keyword}{mutable} \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} m\_info;
00462     \textcolor{keywordtype}{int} m\_factorizationIsOk;
00463     \textcolor{keywordtype}{int} m\_analysisIsOk;
00464     \textcolor{keyword}{mutable} \textcolor{keywordtype}{bool} m\_extractedDataAreDirty;
00465     
00466   \textcolor{keyword}{private}:
00467     \hyperlink{class_eigen_1_1_super_l_u_base}{SuperLUBase}(\hyperlink{class_eigen_1_1_super_l_u_base}{SuperLUBase}& ) \{ \}
00468 \};
00469 
00470 
00487 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00488}\hyperlink{class_eigen_1_1_super_l_u}{00488} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_super_l_u}{SuperLU} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_super_l_u_base}{SuperLUBase}<\_MatrixType,SuperLU<\_MatrixType> >
00489 \{
00490   \textcolor{keyword}{public}:
00491     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_super_l_u_base}{SuperLUBase<\_MatrixType,SuperLU>} 
      \hyperlink{class_eigen_1_1_super_l_u_base}{Base};
00492     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00493     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::Scalar Scalar;
00494     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::RealScalar RealScalar;
00495     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::StorageIndex StorageIndex;
00496     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module}{Base::IntRowVectorType} 
      \hyperlink{group___core___module}{IntRowVectorType};
00497     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module}{Base::IntColVectorType} 
      \hyperlink{group___core___module}{IntColVectorType};   
00498     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_class_eigen_1_1_map}{Base::PermutationMap} \hyperlink{group___core___module_class_eigen_1_1_map}{PermutationMap};
00499     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Base::LUMatrixType} \hyperlink{group___sparse_core___module}{LUMatrixType};
00500     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_triangular_view}{TriangularView<LUMatrixType, Lower|UnitDiag>}  
      \hyperlink{group___core___module_class_eigen_1_1_triangular_view}{LMatrixType};
00501     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_triangular_view}{TriangularView<LUMatrixType,  Upper>}          
      \hyperlink{group___core___module_class_eigen_1_1_triangular_view}{UMatrixType};
00502 
00503   \textcolor{keyword}{public}:
00504     \textcolor{keyword}{using} Base::\_solve\_impl;
00505 
00506     \hyperlink{class_eigen_1_1_super_l_u}{SuperLU}() : Base() \{ \hyperlink{structinit}{init}(); \}
00507 
00508     \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1_super_l_u}{SuperLU}(\textcolor{keyword}{const} MatrixType& matrix) : Base()
00509     \{
00510       \hyperlink{structinit}{init}();
00511       Base::compute(matrix);
00512     \}
00513 
00514     ~\hyperlink{class_eigen_1_1_super_l_u}{SuperLU}()
00515     \{
00516     \}
00517     
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00524}\hyperlink{class_eigen_1_1_super_l_u_a493cdfada27415a6037b004ff974eace}{00524}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_super_l_u_a493cdfada27415a6037b004ff974eace}{analyzePattern}(\textcolor{keyword}{const} MatrixType& matrix)
00525     \{
00526       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434}{InvalidInput};
00527       m\_isInitialized = \textcolor{keyword}{false};
00528       Base::analyzePattern(matrix);
00529     \}
00530     
00537     \textcolor{keywordtype}{void} factorize(\textcolor{keyword}{const} MatrixType& matrix);
00538     
00540     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs,\textcolor{keyword}{typename} Dest>
00541     \textcolor{keywordtype}{void} \_solve\_impl(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>} &b, \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>} &dest) \textcolor{keyword}{const}
      ;
00542     
00543     \textcolor{keyword}{inline} \textcolor{keyword}{const} LMatrixType& matrixL()\textcolor{keyword}{ const}
00544 \textcolor{keyword}{    }\{
00545       \textcolor{keywordflow}{if} (m\_extractedDataAreDirty) this->extractData();
00546       \textcolor{keywordflow}{return} m\_l;
00547     \}
00548 
00549     \textcolor{keyword}{inline} \textcolor{keyword}{const} UMatrixType& matrixU()\textcolor{keyword}{ const}
00550 \textcolor{keyword}{    }\{
00551       \textcolor{keywordflow}{if} (m\_extractedDataAreDirty) this->extractData();
00552       \textcolor{keywordflow}{return} m\_u;
00553     \}
00554 
00555     \textcolor{keyword}{inline} \textcolor{keyword}{const} IntColVectorType& permutationP()\textcolor{keyword}{ const}
00556 \textcolor{keyword}{    }\{
00557       \textcolor{keywordflow}{if} (m\_extractedDataAreDirty) this->extractData();
00558       \textcolor{keywordflow}{return} m\_p;
00559     \}
00560 
00561     \textcolor{keyword}{inline} \textcolor{keyword}{const} IntRowVectorType& permutationQ()\textcolor{keyword}{ const}
00562 \textcolor{keyword}{    }\{
00563       \textcolor{keywordflow}{if} (m\_extractedDataAreDirty) this->extractData();
00564       \textcolor{keywordflow}{return} m\_q;
00565     \}
00566     
00567     Scalar determinant() \textcolor{keyword}{const};
00568     
00569   \textcolor{keyword}{protected}:
00570     
00571     \textcolor{keyword}{using} Base::m\_matrix;
00572     \textcolor{keyword}{using} Base::m\_sluOptions;
00573     \textcolor{keyword}{using} Base::m\_sluA;
00574     \textcolor{keyword}{using} Base::m\_sluB;
00575     \textcolor{keyword}{using} Base::m\_sluX;
00576     \textcolor{keyword}{using} Base::m\_p;
00577     \textcolor{keyword}{using} Base::m\_q;
00578     \textcolor{keyword}{using} Base::m\_sluEtree;
00579     \textcolor{keyword}{using} Base::m\_sluEqued;
00580     \textcolor{keyword}{using} Base::m\_sluRscale;
00581     \textcolor{keyword}{using} Base::m\_sluCscale;
00582     \textcolor{keyword}{using} Base::m\_sluL;
00583     \textcolor{keyword}{using} Base::m\_sluU;
00584     \textcolor{keyword}{using} Base::m\_sluStat;
00585     \textcolor{keyword}{using} Base::m\_sluFerr;
00586     \textcolor{keyword}{using} Base::m\_sluBerr;
00587     \textcolor{keyword}{using} Base::m\_l;
00588     \textcolor{keyword}{using} Base::m\_u;
00589     
00590     \textcolor{keyword}{using} Base::m\_analysisIsOk;
00591     \textcolor{keyword}{using} Base::m\_factorizationIsOk;
00592     \textcolor{keyword}{using} Base::m\_extractedDataAreDirty;
00593     \textcolor{keyword}{using} Base::m\_isInitialized;
00594     \textcolor{keyword}{using} Base::m\_info;
00595     
00596     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}()
00597     \{
00598       Base::init();
00599       
00600       set\_default\_options(&this->m\_sluOptions);
00601       m\_sluOptions.PrintStat        = NO;
00602       m\_sluOptions.ConditionNumber  = NO;
00603       m\_sluOptions.Trans            = NOTRANS;
00604       m\_sluOptions.ColPerm          = COLAMD;
00605     \}
00606     
00607     
00608   \textcolor{keyword}{private}:
00609     \hyperlink{class_eigen_1_1_super_l_u}{SuperLU}(\hyperlink{class_eigen_1_1_super_l_u}{SuperLU}& ) \{ \}
00610 \};
00611 
00612 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2_eigen_2src_2_super_l_u_support_2_super_l_u_support_8h_source_l00613}\hyperlink{class_eigen_1_1_super_l_u_a0b5a5fbda1a1f368003c7c01021a4636}{00613} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_super_l_u_a0b5a5fbda1a1f368003c7c01021a4636}{SuperLU<MatrixType>::factorize}(\textcolor{keyword}{const} MatrixType& a)
00614 \{
00615   eigen\_assert(m\_analysisIsOk && \textcolor{stringliteral}{"You must first call analyzePattern()"});
00616   \textcolor{keywordflow}{if}(!m\_analysisIsOk)
00617   \{
00618     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434}{InvalidInput};
00619     \textcolor{keywordflow}{return};
00620   \}
00621   
00622   this->initFactorization(a);
00623   
00624   m\_sluOptions.ColPerm = COLAMD;
00625   \textcolor{keywordtype}{int} info = 0;
00626   RealScalar recip\_pivot\_growth, rcond;
00627   RealScalar ferr, berr;
00628 
00629   StatInit(&m\_sluStat);
00630   SuperLU\_gssvx(&m\_sluOptions, &m\_sluA, m\_q.data(), m\_p.data(), &m\_sluEtree[0],
00631                 &m\_sluEqued, &m\_sluRscale[0], &m\_sluCscale[0],
00632                 &m\_sluL, &m\_sluU,
00633                 NULL, 0,
00634                 &m\_sluB, &m\_sluX,
00635                 &recip\_pivot\_growth, &rcond,
00636                 &ferr, &berr,
00637                 &m\_sluStat, &info, Scalar());
00638   StatFree(&m\_sluStat);
00639 
00640   m\_extractedDataAreDirty = \textcolor{keyword}{true};
00641 
00642   \textcolor{comment}{// FIXME how to better check for errors ???}
00643   m\_info = info == 0 ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} : \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00644   m\_factorizationIsOk = \textcolor{keyword}{true};
00645 \}
00646 
00647 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00648 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs,\textcolor{keyword}{typename} Dest>
00649 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_super_l_u}{SuperLU<MatrixType>::\_solve\_impl}(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>} &b, \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>}& x)\textcolor{keyword}{ const}
00650 \textcolor{keyword}{}\{
00651   eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"The decomposition is not in a valid state for solving, you must
       first call either compute() or analyzePattern()/factorize()"});
00652 
00653   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = m\_matrix.rows();
00654   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rhsCols = b.cols();
00655   eigen\_assert(size==b.rows());
00656 
00657   m\_sluOptions.Trans = NOTRANS;
00658   m\_sluOptions.Fact = FACTORED;
00659   m\_sluOptions.IterRefine = NOREFINE;
00660   
00661 
00662   m\_sluFerr.resize(rhsCols);
00663   m\_sluBerr.resize(rhsCols);
00664   
00665   \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const Matrix<typename Rhs::Scalar,Dynamic,Dynamic,ColMajor>}
       > b\_ref(b);
00666   \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const Matrix<typename Dest::Scalar,Dynamic,Dynamic,ColMajor>}
       > x\_ref(x);
00667   
00668   m\_sluB = SluMatrix::Map(b\_ref.const\_cast\_derived());
00669   m\_sluX = SluMatrix::Map(x\_ref.const\_cast\_derived());
00670   
00671   \textcolor{keyword}{typename} Rhs::PlainObject b\_cpy;
00672   \textcolor{keywordflow}{if}(m\_sluEqued!=\textcolor{charliteral}{'N'})
00673   \{
00674     b\_cpy = b;
00675     m\_sluB = SluMatrix::Map(b\_cpy.const\_cast\_derived());  
00676   \}
00677 
00678   StatInit(&m\_sluStat);
00679   \textcolor{keywordtype}{int} info = 0;
00680   RealScalar recip\_pivot\_growth, rcond;
00681   SuperLU\_gssvx(&m\_sluOptions, &m\_sluA,
00682                 m\_q.data(), m\_p.data(),
00683                 &m\_sluEtree[0], &m\_sluEqued,
00684                 &m\_sluRscale[0], &m\_sluCscale[0],
00685                 &m\_sluL, &m\_sluU,
00686                 NULL, 0,
00687                 &m\_sluB, &m\_sluX,
00688                 &recip\_pivot\_growth, &rcond,
00689                 &m\_sluFerr[0], &m\_sluBerr[0],
00690                 &m\_sluStat, &info, Scalar());
00691   StatFree(&m\_sluStat);
00692   
00693   \textcolor{keywordflow}{if}(x.derived().data() != x\_ref.data())
00694     x = x\_ref;
00695   
00696   m\_info = info==0 ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} : \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00697 \}
00698 
00699 \textcolor{comment}{// the code of this extractData() function has been adapted from the SuperLU's Matlab support code,}
00700 \textcolor{comment}{//}
00701 \textcolor{comment}{//  Copyright (c) 1994 by Xerox Corporation.  All rights reserved.}
00702 \textcolor{comment}{//}
00703 \textcolor{comment}{//  THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY}
00704 \textcolor{comment}{//  EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.}
00705 \textcolor{comment}{//}
00706 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} Derived>
00707 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_super_l_u_base}{SuperLUBase<MatrixType,Derived>::extractData}()\textcolor{keyword}{ const}
00708 \textcolor{keyword}{}\{
00709   eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"The decomposition is not in a valid state for extracting factors,
       you must first call either compute() or analyzePattern()/factorize()"});
00710   \textcolor{keywordflow}{if} (m\_extractedDataAreDirty)
00711   \{
00712     \textcolor{keywordtype}{int}         upper;
00713     \textcolor{keywordtype}{int}         fsupc, istart, nsupr;
00714     \textcolor{keywordtype}{int}         lastl = 0, lastu = 0;
00715     SCformat    *Lstore = \textcolor{keyword}{static\_cast<}SCformat*\textcolor{keyword}{>}(m\_sluL.Store);
00716     NCformat    *Ustore = \textcolor{keyword}{static\_cast<}NCformat*\textcolor{keyword}{>}(m\_sluU.Store);
00717     Scalar      *SNptr;
00718 
00719     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = m\_matrix.rows();
00720     m\_l.resize(size,size);
00721     m\_l.resizeNonZeros(Lstore->nnz);
00722     m\_u.resize(size,size);
00723     m\_u.resizeNonZeros(Ustore->nnz);
00724 
00725     \textcolor{keywordtype}{int}* Lcol = m\_l.outerIndexPtr();
00726     \textcolor{keywordtype}{int}* Lrow = m\_l.innerIndexPtr();
00727     Scalar* Lval = m\_l.valuePtr();
00728 
00729     \textcolor{keywordtype}{int}* Ucol = m\_u.outerIndexPtr();
00730     \textcolor{keywordtype}{int}* Urow = m\_u.innerIndexPtr();
00731     Scalar* Uval = m\_u.valuePtr();
00732 
00733     Ucol[0] = 0;
00734     Ucol[0] = 0;
00735 
00736     \textcolor{comment}{/* for each supernode */}
00737     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 0; k <= Lstore->nsuper; ++k)
00738     \{
00739       fsupc   = L\_FST\_SUPC(k);
00740       istart  = L\_SUB\_START(fsupc);
00741       nsupr   = L\_SUB\_START(fsupc+1) - istart;
00742       upper   = 1;
00743 
00744       \textcolor{comment}{/* for each column in the supernode */}
00745       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = fsupc; j < L\_FST\_SUPC(k+1); ++j)
00746       \{
00747         SNptr = &((Scalar*)Lstore->nzval)[L\_NZ\_START(j)];
00748 
00749         \textcolor{comment}{/* Extract U */}
00750         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = U\_NZ\_START(j); i < U\_NZ\_START(j+1); ++i)
00751         \{
00752           Uval[lastu] = ((Scalar*)Ustore->nzval)[i];
00753           \textcolor{comment}{/* Matlab doesn't like explicit zero. */}
00754           \textcolor{keywordflow}{if} (Uval[lastu] != 0.0)
00755             Urow[lastu++] = U\_SUB(i);
00756         \}
00757         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < upper; ++i)
00758         \{
00759           \textcolor{comment}{/* upper triangle in the supernode */}
00760           Uval[lastu] = SNptr[i];
00761           \textcolor{comment}{/* Matlab doesn't like explicit zero. */}
00762           \textcolor{keywordflow}{if} (Uval[lastu] != 0.0)
00763             Urow[lastu++] = L\_SUB(istart+i);
00764         \}
00765         Ucol[j+1] = lastu;
00766 
00767         \textcolor{comment}{/* Extract L */}
00768         Lval[lastl] = 1.0; \textcolor{comment}{/* unit diagonal */}
00769         Lrow[lastl++] = L\_SUB(istart + upper - 1);
00770         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = upper; i < nsupr; ++i)
00771         \{
00772           Lval[lastl] = SNptr[i];
00773           \textcolor{comment}{/* Matlab doesn't like explicit zero. */}
00774           \textcolor{keywordflow}{if} (Lval[lastl] != 0.0)
00775             Lrow[lastl++] = L\_SUB(istart+i);
00776         \}
00777         Lcol[j+1] = lastl;
00778 
00779         ++upper;
00780       \} \textcolor{comment}{/* for j ... */}
00781 
00782     \} \textcolor{comment}{/* for k ... */}
00783 
00784     \textcolor{comment}{// squeeze the matrices :}
00785     m\_l.resizeNonZeros(lastl);
00786     m\_u.resizeNonZeros(lastu);
00787 
00788     m\_extractedDataAreDirty = \textcolor{keyword}{false};
00789   \}
00790 \}
00791 
00792 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00793 \textcolor{keyword}{typename} SuperLU<MatrixType>::Scalar \hyperlink{class_eigen_1_1_super_l_u}{SuperLU<MatrixType>::determinant}()\textcolor{keyword}{
       const}
00794 \textcolor{keyword}{}\{
00795   eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"The decomposition is not in a valid state for computing the
       determinant, you must first call either compute() or analyzePattern()/factorize()"});
00796   
00797   \textcolor{keywordflow}{if} (m\_extractedDataAreDirty)
00798     this->extractData();
00799 
00800   Scalar det = Scalar(1);
00801   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<m\_u.cols(); ++j)
00802   \{
00803     \textcolor{keywordflow}{if} (m\_u.outerIndexPtr()[j+1]-m\_u.outerIndexPtr()[j] > 0)
00804     \{
00805       \textcolor{keywordtype}{int} lastId = m\_u.outerIndexPtr()[j+1]-1;
00806       eigen\_assert(m\_u.innerIndexPtr()[lastId]<=j);
00807       \textcolor{keywordflow}{if} (m\_u.innerIndexPtr()[lastId]==j)
00808         det *= m\_u.valuePtr()[lastId];
00809     \}
00810   \}
00811   \textcolor{keywordflow}{if}(\hyperlink{group___core___module_class_eigen_1_1_map}{PermutationMap}(m\_p.data(),m\_p.size()).determinant()*
      \hyperlink{group___core___module_class_eigen_1_1_map}{PermutationMap}(m\_q.data(),m\_q.size()).determinant()<0)
00812     det = -det;
00813   \textcolor{keywordflow}{if}(m\_sluEqued!=\textcolor{charliteral}{'N'})
00814     \textcolor{keywordflow}{return} det/m\_sluRscale.prod()/m\_sluCscale.prod();
00815   \textcolor{keywordflow}{else}
00816     \textcolor{keywordflow}{return} det;
00817 \}
00818 
00819 \textcolor{preprocessor}{#ifdef EIGEN\_PARSED\_BY\_DOXYGEN}
00820 \textcolor{preprocessor}{#define EIGEN\_SUPERLU\_HAS\_ILU}
00821 \textcolor{preprocessor}{#endif}
00822 
00823 \textcolor{preprocessor}{#ifdef EIGEN\_SUPERLU\_HAS\_ILU}
00824 
00841 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
00842 \textcolor{keyword}{class }SuperILU : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_super_l_u_base}{SuperLUBase}<\_MatrixType,SuperILU<\_MatrixType> >
00843 \{
00844   \textcolor{keyword}{public}:
00845     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_super_l_u_base}{SuperLUBase<\_MatrixType,SuperILU>} 
      \hyperlink{class_eigen_1_1_super_l_u_base}{Base};
00846     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00847     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::Scalar Scalar;
00848     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::RealScalar RealScalar;
00849 
00850   \textcolor{keyword}{public}:
00851     \textcolor{keyword}{using} Base::\_solve\_impl;
00852 
00853     SuperILU() : Base() \{ \hyperlink{structinit}{init}(); \}
00854 
00855     SuperILU(\textcolor{keyword}{const} MatrixType& matrix) : Base()
00856     \{
00857       \hyperlink{structinit}{init}();
00858       Base::compute(matrix);
00859     \}
00860 
00861     ~SuperILU()
00862     \{
00863     \}
00864     
00871     \textcolor{keywordtype}{void} analyzePattern(\textcolor{keyword}{const} MatrixType& matrix)
00872     \{
00873       Base::analyzePattern(matrix);
00874     \}
00875     
00882     \textcolor{keywordtype}{void} factorize(\textcolor{keyword}{const} MatrixType& matrix);
00883     
00884 \textcolor{preprocessor}{    #ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00885 
00886     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs,\textcolor{keyword}{typename} Dest>
00887     \textcolor{keywordtype}{void} \_solve\_impl(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>} &b, \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>} &dest) \textcolor{keyword}{const}
      ;
00888 \textcolor{preprocessor}{    #endif // EIGEN\_PARSED\_BY\_DOXYGEN}
00889     
00890   \textcolor{keyword}{protected}:
00891     
00892     \textcolor{keyword}{using} Base::m\_matrix;
00893     \textcolor{keyword}{using} Base::m\_sluOptions;
00894     \textcolor{keyword}{using} Base::m\_sluA;
00895     \textcolor{keyword}{using} Base::m\_sluB;
00896     \textcolor{keyword}{using} Base::m\_sluX;
00897     \textcolor{keyword}{using} Base::m\_p;
00898     \textcolor{keyword}{using} Base::m\_q;
00899     \textcolor{keyword}{using} Base::m\_sluEtree;
00900     \textcolor{keyword}{using} Base::m\_sluEqued;
00901     \textcolor{keyword}{using} Base::m\_sluRscale;
00902     \textcolor{keyword}{using} Base::m\_sluCscale;
00903     \textcolor{keyword}{using} Base::m\_sluL;
00904     \textcolor{keyword}{using} Base::m\_sluU;
00905     \textcolor{keyword}{using} Base::m\_sluStat;
00906     \textcolor{keyword}{using} Base::m\_sluFerr;
00907     \textcolor{keyword}{using} Base::m\_sluBerr;
00908     \textcolor{keyword}{using} Base::m\_l;
00909     \textcolor{keyword}{using} Base::m\_u;
00910     
00911     \textcolor{keyword}{using} Base::m\_analysisIsOk;
00912     \textcolor{keyword}{using} Base::m\_factorizationIsOk;
00913     \textcolor{keyword}{using} Base::m\_extractedDataAreDirty;
00914     \textcolor{keyword}{using} Base::m\_isInitialized;
00915     \textcolor{keyword}{using} Base::m\_info;
00916 
00917     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}()
00918     \{
00919       Base::init();
00920       
00921       ilu\_set\_default\_options(&m\_sluOptions);
00922       m\_sluOptions.PrintStat        = NO;
00923       m\_sluOptions.ConditionNumber  = NO;
00924       m\_sluOptions.Trans            = NOTRANS;
00925       m\_sluOptions.ColPerm          = MMD\_AT\_PLUS\_A;
00926       
00927       \textcolor{comment}{// no attempt to preserve column sum}
00928       m\_sluOptions.ILU\_MILU = SILU;
00929       \textcolor{comment}{// only basic ILU(k) support -- no direct control over memory consumption}
00930       \textcolor{comment}{// better to use ILU\_DropRule = DROP\_BASIC | DROP\_AREA}
00931       \textcolor{comment}{// and set ILU\_FillFactor to max memory growth}
00932       m\_sluOptions.ILU\_DropRule = DROP\_BASIC;
00933       m\_sluOptions.ILU\_DropTol = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::dummy\_precision}()*10;
00934     \}
00935     
00936   \textcolor{keyword}{private}:
00937     SuperILU(SuperILU& ) \{ \}
00938 \};
00939 
00940 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00941 \textcolor{keywordtype}{void} SuperILU<MatrixType>::factorize(\textcolor{keyword}{const} MatrixType& a)
00942 \{
00943   eigen\_assert(m\_analysisIsOk && \textcolor{stringliteral}{"You must first call analyzePattern()"});
00944   \textcolor{keywordflow}{if}(!m\_analysisIsOk)
00945   \{
00946     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434}{InvalidInput};
00947     \textcolor{keywordflow}{return};
00948   \}
00949   
00950   this->initFactorization(a);
00951 
00952   \textcolor{keywordtype}{int} info = 0;
00953   RealScalar recip\_pivot\_growth, rcond;
00954 
00955   StatInit(&m\_sluStat);
00956   SuperLU\_gsisx(&m\_sluOptions, &m\_sluA, m\_q.data(), m\_p.data(), &m\_sluEtree[0],
00957                 &m\_sluEqued, &m\_sluRscale[0], &m\_sluCscale[0],
00958                 &m\_sluL, &m\_sluU,
00959                 NULL, 0,
00960                 &m\_sluB, &m\_sluX,
00961                 &recip\_pivot\_growth, &rcond,
00962                 &m\_sluStat, &info, Scalar());
00963   StatFree(&m\_sluStat);
00964 
00965   \textcolor{comment}{// FIXME how to better check for errors ???}
00966   m\_info = info == 0 ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} : \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00967   m\_factorizationIsOk = \textcolor{keyword}{true};
00968 \}
00969 
00970 \textcolor{preprocessor}{#ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00971 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00972 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs,\textcolor{keyword}{typename} Dest>
00973 \textcolor{keywordtype}{void} SuperILU<MatrixType>::\_solve\_impl(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>} &b, 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>}& x)\textcolor{keyword}{ const}
00974 \textcolor{keyword}{}\{
00975   eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"The decomposition is not in a valid state for solving, you must
       first call either compute() or analyzePattern()/factorize()"});
00976 
00977   \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = m\_matrix.rows();
00978   \textcolor{keyword}{const} \textcolor{keywordtype}{int} rhsCols = b.cols();
00979   eigen\_assert(size==b.rows());
00980 
00981   m\_sluOptions.Trans = NOTRANS;
00982   m\_sluOptions.Fact = FACTORED;
00983   m\_sluOptions.IterRefine = NOREFINE;
00984 
00985   m\_sluFerr.resize(rhsCols);
00986   m\_sluBerr.resize(rhsCols);
00987   
00988   \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const Matrix<typename Rhs::Scalar,Dynamic,Dynamic,ColMajor>}
       > b\_ref(b);
00989   \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const Matrix<typename Dest::Scalar,Dynamic,Dynamic,ColMajor>}
       > x\_ref(x);
00990   
00991   m\_sluB = SluMatrix::Map(b\_ref.const\_cast\_derived());
00992   m\_sluX = SluMatrix::Map(x\_ref.const\_cast\_derived());
00993 
00994   \textcolor{keyword}{typename} Rhs::PlainObject b\_cpy;
00995   \textcolor{keywordflow}{if}(m\_sluEqued!=\textcolor{charliteral}{'N'})
00996   \{
00997     b\_cpy = b;
00998     m\_sluB = SluMatrix::Map(b\_cpy.const\_cast\_derived());  
00999   \}
01000   
01001   \textcolor{keywordtype}{int} info = 0;
01002   RealScalar recip\_pivot\_growth, rcond;
01003 
01004   StatInit(&m\_sluStat);
01005   SuperLU\_gsisx(&m\_sluOptions, &m\_sluA,
01006                 m\_q.data(), m\_p.data(),
01007                 &m\_sluEtree[0], &m\_sluEqued,
01008                 &m\_sluRscale[0], &m\_sluCscale[0],
01009                 &m\_sluL, &m\_sluU,
01010                 NULL, 0,
01011                 &m\_sluB, &m\_sluX,
01012                 &recip\_pivot\_growth, &rcond,
01013                 &m\_sluStat, &info, Scalar());
01014   StatFree(&m\_sluStat);
01015   
01016   \textcolor{keywordflow}{if}(x.derived().data() != x\_ref.data())
01017     x = x\_ref;
01018 
01019   m\_info = info==0 ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} : \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
01020 \}
01021 \textcolor{preprocessor}{#endif}
01022 
01023 \textcolor{preprocessor}{#endif}
01024 
01025 \} \textcolor{comment}{// end namespace Eigen}
01026 
01027 \textcolor{preprocessor}{#endif // EIGEN\_SUPERLUSUPPORT\_H}
\end{DoxyCode}
