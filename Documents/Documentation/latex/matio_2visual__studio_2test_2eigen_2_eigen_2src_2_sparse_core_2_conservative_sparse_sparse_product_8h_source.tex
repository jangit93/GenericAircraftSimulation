\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_conservative_sparse_sparse_product_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+Core/\+Conservative\+Sparse\+Sparse\+Product.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_conservative_sparse_sparse_product_8h_source}\index{Conservative\+Sparse\+Sparse\+Product.\+h@{Conservative\+Sparse\+Sparse\+Product.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CONSERVATIVESPARSESPARSEPRODUCT\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CONSERVATIVESPARSESPARSEPRODUCT\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00018 \textcolor{keyword}{static} \textcolor{keywordtype}{void} conservative\_sparse\_sparse\_product\_impl(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res, \textcolor{keywordtype}{bool} 
      sortedInsertion = \textcolor{keyword}{false})
00019 \{
00020   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<Lhs>::type::Scalar Scalar;
00021 
00022   \textcolor{comment}{// make sure to call innerSize/outerSize since we fake the storage order.}
00023   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows = lhs.innerSize();
00024   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols = rhs.outerSize();
00025   eigen\_assert(lhs.outerSize() == rhs.innerSize());
00026   
00027   ei\_declare\_aligned\_stack\_constructed\_variable(\textcolor{keywordtype}{bool},   mask,     rows, 0);
00028   ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, values,   rows, 0);
00029   ei\_declare\_aligned\_stack\_constructed\_variable(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},  indices,  rows, 0);
00030   
00031   std::memset(mask,0,\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{bool})*rows);
00032 
00033   evaluator<Lhs> lhsEval(lhs);
00034   evaluator<Rhs> rhsEval(rhs);
00035   
00036   \textcolor{comment}{// estimate the number of non zero entries}
00037   \textcolor{comment}{// given a rhs column containing Y non zeros, we assume that the respective Y columns}
00038   \textcolor{comment}{// of the lhs differs in average of one non zeros, thus the number of non zeros for}
00039   \textcolor{comment}{// the product of a rhs column with the lhs is X+Y where X is the average number of non zero}
00040   \textcolor{comment}{// per column of the lhs.}
00041   \textcolor{comment}{// Therefore, we have nnz(lhs*rhs) = nnz(lhs) + nnz(rhs)}
00042   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} estimated\_nnz\_prod = lhsEval.nonZerosEstimate() + rhsEval.nonZerosEstimate();
00043 
00044   res.setZero();
00045   res.reserve(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(estimated\_nnz\_prod));
00046   \textcolor{comment}{// we compute each column of the result, one after the other}
00047   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<cols; ++j)
00048   \{
00049 
00050     res.startVec(j);
00051     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nnz = 0;
00052     \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} evaluator<Rhs>::InnerIterator rhsIt(rhsEval, j); rhsIt; ++rhsIt)
00053     \{
00054       Scalar y = rhsIt.value();
00055       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = rhsIt.index();
00056       \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} evaluator<Lhs>::InnerIterator lhsIt(lhsEval, k); lhsIt; ++lhsIt)
00057       \{
00058         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = lhsIt.index();
00059         Scalar x = lhsIt.value();
00060         \textcolor{keywordflow}{if}(!mask[i])
00061         \{
00062           mask[i] = \textcolor{keyword}{true};
00063           values[i] = x * y;
00064           indices[nnz] = i;
00065           ++nnz;
00066         \}
00067         \textcolor{keywordflow}{else}
00068           values[i] += x * y;
00069       \}
00070     \}
00071     \textcolor{keywordflow}{if}(!sortedInsertion)
00072     \{
00073       \textcolor{comment}{// unordered insertion}
00074       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<nnz; ++k)
00075       \{
00076         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = indices[k];
00077         res.insertBackByOuterInnerUnordered(j,i) = values[i];
00078         mask[i] = \textcolor{keyword}{false};
00079       \}
00080     \}
00081     \textcolor{keywordflow}{else}
00082     \{
00083       \textcolor{comment}{// alternative ordered insertion code:}
00084       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} t200 = rows/11; \textcolor{comment}{// 11 == (log2(200)*1.39)}
00085       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} t = (rows*100)/139;
00086 
00087       \textcolor{comment}{// FIXME reserve nnz non zeros}
00088       \textcolor{comment}{// FIXME implement faster sorting algorithms for very small nnz}
00089       \textcolor{comment}{// if the result is sparse enough => use a quick sort}
00090       \textcolor{comment}{// otherwise => loop through the entire vector}
00091       \textcolor{comment}{// In order to avoid to perform an expensive log2 when the}
00092       \textcolor{comment}{// result is clearly very sparse we use a linear bound up to 200.}
00093       \textcolor{keywordflow}{if}((nnz<200 && nnz<t200) || nnz * numext::log2(\textcolor{keywordtype}{int}(nnz)) < t)
00094       \{
00095         \textcolor{keywordflow}{if}(nnz>1) std::sort(indices,indices+nnz);
00096         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<nnz; ++k)
00097         \{
00098           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = indices[k];
00099           res.insertBackByOuterInner(j,i) = values[i];
00100           mask[i] = \textcolor{keyword}{false};
00101         \}
00102       \}
00103       \textcolor{keywordflow}{else}
00104       \{
00105         \textcolor{comment}{// dense path}
00106         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<rows; ++i)
00107         \{
00108           \textcolor{keywordflow}{if}(mask[i])
00109           \{
00110             mask[i] = \textcolor{keyword}{false};
00111             res.insertBackByOuterInner(j,i) = values[i];
00112           \}
00113         \}
00114       \}
00115     \}
00116   \}
00117   res.finalize();
00118 \}
00119 
00120 
00121 \} \textcolor{comment}{// end namespace internal}
00122 
00123 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00124 
00125 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType,
00126   \textcolor{keywordtype}{int} LhsStorageOrder = (traits<Lhs>::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},
00127   \textcolor{keywordtype}{int} RhsStorageOrder = (traits<Rhs>::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},
00128   \textcolor{keywordtype}{int} ResStorageOrder = (traits<ResultType>::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : ColMajor>
00129 \textcolor{keyword}{struct} conservative\_sparse\_sparse\_product\_selector;
00130 
00131 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00132 \textcolor{keyword}{struct }conservative\_sparse\_sparse\_product\_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>
00133 \{
00134   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<Lhs>::type LhsCleaned;
00135   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsCleaned::Scalar Scalar;
00136 
00137   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00138   \{
00139     \textcolor{keyword}{typedef} SparseMatrix<typename ResultType::Scalar,RowMajor,typename ResultType::StorageIndex> 
      RowMajorMatrix;
00140     \textcolor{keyword}{typedef} SparseMatrix<typename ResultType::Scalar,ColMajor,typename ResultType::StorageIndex> 
      ColMajorMatrixAux;
00141     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      sparse\_eval<ColMajorMatrixAux,ResultType::RowsAtCompileTime,ResultType::ColsAtCompileTime,ColMajorMatrixAux::Flags>::type ColMajorMatrix;
00142     
00143     \textcolor{comment}{// If the result is tall and thin (in the extreme case a column vector)}
00144     \textcolor{comment}{// then it is faster to sort the coefficients inplace instead of transposing twice.}
00145     \textcolor{comment}{// FIXME, the following heuristic is probably not very good.}
00146     \textcolor{keywordflow}{if}(lhs.rows()>rhs.cols())
00147     \{
00148       ColMajorMatrix resCol(lhs.rows(),rhs.cols());
00149       \textcolor{comment}{// perform sorted insertion}
00150       internal::conservative\_sparse\_sparse\_product\_impl<Lhs,Rhs,ColMajorMatrix>(lhs, rhs, resCol, \textcolor{keyword}{true});
00151       res = resCol.markAsRValue();
00152     \}
00153     \textcolor{keywordflow}{else}
00154     \{
00155       ColMajorMatrixAux resCol(lhs.rows(),rhs.cols());
00156       \textcolor{comment}{// ressort to transpose to sort the entries}
00157       internal::conservative\_sparse\_sparse\_product\_impl<Lhs,Rhs,ColMajorMatrixAux>(lhs, rhs, resCol, \textcolor{keyword}{false})
      ;
00158       RowMajorMatrix resRow(resCol);
00159       res = resRow.markAsRValue();
00160     \}
00161   \}
00162 \};
00163 
00164 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00165 \textcolor{keyword}{struct }conservative\_sparse\_sparse\_product\_selector<Lhs,Rhs,ResultType,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},ColMajor,ColMajor>
00166 \{
00167   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00168   \{
00169      \textcolor{keyword}{typedef} SparseMatrix<typename ResultType::Scalar,RowMajor,typename ResultType::StorageIndex> 
      RowMajorMatrix;
00170      RowMajorMatrix rhsRow = rhs;
00171      RowMajorMatrix resRow(lhs.rows(), rhs.cols());
00172      internal::conservative\_sparse\_sparse\_product\_impl<RowMajorMatrix,Lhs,RowMajorMatrix>(rhsRow, lhs, 
      resRow);
00173      res = resRow;
00174   \}
00175 \};
00176 
00177 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00178 \textcolor{keyword}{struct }conservative\_sparse\_sparse\_product\_selector<Lhs,Rhs,ResultType,ColMajor,
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},ColMajor>
00179 \{
00180   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00181   \{
00182     \textcolor{keyword}{typedef} SparseMatrix<typename ResultType::Scalar,RowMajor,typename ResultType::StorageIndex> 
      RowMajorMatrix;
00183     RowMajorMatrix lhsRow = lhs;
00184     RowMajorMatrix resRow(lhs.rows(), rhs.cols());
00185     internal::conservative\_sparse\_sparse\_product\_impl<Rhs,RowMajorMatrix,RowMajorMatrix>(rhs, lhsRow, 
      resRow);
00186     res = resRow;
00187   \}
00188 \};
00189 
00190 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00191 \textcolor{keyword}{struct }conservative\_sparse\_sparse\_product\_selector<Lhs,Rhs,ResultType,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},ColMajor>
00192 \{
00193   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00194   \{
00195     \textcolor{keyword}{typedef} SparseMatrix<typename ResultType::Scalar,RowMajor,typename ResultType::StorageIndex> 
      RowMajorMatrix;
00196     RowMajorMatrix resRow(lhs.rows(), rhs.cols());
00197     internal::conservative\_sparse\_sparse\_product\_impl<Rhs,Lhs,RowMajorMatrix>(rhs, lhs, resRow);
00198     res = resRow;
00199   \}
00200 \};
00201 
00202 
00203 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00204 \textcolor{keyword}{struct }conservative\_sparse\_sparse\_product\_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}>
00205 \{
00206   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<typename remove\_all<Lhs>::type>::Scalar Scalar;
00207 
00208   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00209   \{
00210     \textcolor{keyword}{typedef} SparseMatrix<typename ResultType::Scalar,ColMajor,typename ResultType::StorageIndex> 
      ColMajorMatrix;
00211     ColMajorMatrix resCol(lhs.rows(), rhs.cols());
00212     internal::conservative\_sparse\_sparse\_product\_impl<Lhs,Rhs,ColMajorMatrix>(lhs, rhs, resCol);
00213     res = resCol;
00214   \}
00215 \};
00216 
00217 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00218 \textcolor{keyword}{struct }conservative\_sparse\_sparse\_product\_selector<Lhs,Rhs,ResultType,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},ColMajor,
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}>
00219 \{
00220   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00221   \{
00222     \textcolor{keyword}{typedef} SparseMatrix<typename ResultType::Scalar,ColMajor,typename ResultType::StorageIndex> 
      ColMajorMatrix;
00223     ColMajorMatrix lhsCol = lhs;
00224     ColMajorMatrix resCol(lhs.rows(), rhs.cols());
00225     internal::conservative\_sparse\_sparse\_product\_impl<ColMajorMatrix,Rhs,ColMajorMatrix>(lhsCol, rhs, 
      resCol);
00226     res = resCol;
00227   \}
00228 \};
00229 
00230 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00231 \textcolor{keyword}{struct }conservative\_sparse\_sparse\_product\_selector<Lhs,Rhs,ResultType,ColMajor,
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}>
00232 \{
00233   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00234   \{
00235     \textcolor{keyword}{typedef} SparseMatrix<typename ResultType::Scalar,ColMajor,typename ResultType::StorageIndex> 
      ColMajorMatrix;
00236     ColMajorMatrix rhsCol = rhs;
00237     ColMajorMatrix resCol(lhs.rows(), rhs.cols());
00238     internal::conservative\_sparse\_sparse\_product\_impl<Lhs,ColMajorMatrix,ColMajorMatrix>(lhs, rhsCol, 
      resCol);
00239     res = resCol;
00240   \}
00241 \};
00242 
00243 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00244 \textcolor{keyword}{struct }conservative\_sparse\_sparse\_product\_selector<Lhs,Rhs,ResultType,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}>
00245 \{
00246   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00247   \{
00248     \textcolor{keyword}{typedef} SparseMatrix<typename ResultType::Scalar,RowMajor,typename ResultType::StorageIndex> 
      RowMajorMatrix;
00249     \textcolor{keyword}{typedef} SparseMatrix<typename ResultType::Scalar,ColMajor,typename ResultType::StorageIndex> 
      ColMajorMatrix;
00250     RowMajorMatrix resRow(lhs.rows(),rhs.cols());
00251     internal::conservative\_sparse\_sparse\_product\_impl<Rhs,Lhs,RowMajorMatrix>(rhs, lhs, resRow);
00252     \textcolor{comment}{// sort the non zeros:}
00253     ColMajorMatrix resCol(resRow);
00254     res = resCol;
00255   \}
00256 \};
00257 
00258 \} \textcolor{comment}{// end namespace internal}
00259 
00260 
00261 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00262 
00263 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00264 \textcolor{keyword}{static} \textcolor{keywordtype}{void} sparse\_sparse\_to\_dense\_product\_impl(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00265 \{
00266   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<Lhs>::type::Scalar Scalar;
00267   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols = rhs.outerSize();
00268   eigen\_assert(lhs.outerSize() == rhs.innerSize());
00269 
00270   evaluator<Lhs> lhsEval(lhs);
00271   evaluator<Rhs> rhsEval(rhs);
00272 
00273   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<cols; ++j)
00274   \{
00275     \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} evaluator<Rhs>::InnerIterator rhsIt(rhsEval, j); rhsIt; ++rhsIt)
00276     \{
00277       Scalar y = rhsIt.value();
00278       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = rhsIt.index();
00279       \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} evaluator<Lhs>::InnerIterator lhsIt(lhsEval, k); lhsIt; ++lhsIt)
00280       \{
00281         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = lhsIt.index();
00282         Scalar x = lhsIt.value();
00283         res.coeffRef(i,j) += x * y;
00284       \}
00285     \}
00286   \}
00287 \}
00288 
00289 
00290 \} \textcolor{comment}{// end namespace internal}
00291 
00292 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00293 
00294 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType,
00295   \textcolor{keywordtype}{int} LhsStorageOrder = (traits<Lhs>::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : ColMajor,
00296   \textcolor{keywordtype}{int} RhsStorageOrder = (traits<Rhs>::Flags&RowMajorBit) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : ColMajor>
00297 \textcolor{keyword}{struct }sparse\_sparse\_to\_dense\_product\_selector;
00298 
00299 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00300 \textcolor{keyword}{struct }sparse\_sparse\_to\_dense\_product\_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor>
00301 \{
00302   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00303   \{
00304     internal::sparse\_sparse\_to\_dense\_product\_impl<Lhs,Rhs,ResultType>(lhs, rhs, res);
00305   \}
00306 \};
00307 
00308 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00309 \textcolor{keyword}{struct }sparse\_sparse\_to\_dense\_product\_selector<Lhs,Rhs,ResultType,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},ColMajor>
00310 \{
00311   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00312   \{
00313     \textcolor{keyword}{typedef} SparseMatrix<typename ResultType::Scalar,ColMajor,typename ResultType::StorageIndex> 
      ColMajorMatrix;
00314     ColMajorMatrix lhsCol(lhs);
00315     internal::sparse\_sparse\_to\_dense\_product\_impl<ColMajorMatrix,Rhs,ResultType>(lhsCol, rhs, res);
00316   \}
00317 \};
00318 
00319 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00320 \textcolor{keyword}{struct }sparse\_sparse\_to\_dense\_product\_selector<Lhs,Rhs,ResultType,ColMajor,
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}>
00321 \{
00322   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00323   \{
00324     \textcolor{keyword}{typedef} SparseMatrix<typename ResultType::Scalar,ColMajor,typename ResultType::StorageIndex> 
      ColMajorMatrix;
00325     ColMajorMatrix rhsCol(rhs);
00326     internal::sparse\_sparse\_to\_dense\_product\_impl<Lhs,ColMajorMatrix,ResultType>(lhs, rhsCol, res);
00327   \}
00328 \};
00329 
00330 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} ResultType>
00331 \textcolor{keyword}{struct }sparse\_sparse\_to\_dense\_product\_selector<Lhs,Rhs,ResultType,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}>
00332 \{
00333   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, ResultType& res)
00334   \{
00335     Transpose<ResultType> trRes(res);
00336     internal::sparse\_sparse\_to\_dense\_product\_impl<Rhs,Lhs,Transpose<ResultType> >(rhs, lhs, trRes);
00337   \}
00338 \};
00339 
00340 
00341 \} \textcolor{comment}{// end namespace internal}
00342 
00343 \} \textcolor{comment}{// end namespace Eigen}
00344 
00345 \textcolor{preprocessor}{#endif // EIGEN\_CONSERVATIVESPARSESPARSEPRODUCT\_H}
\end{DoxyCode}
