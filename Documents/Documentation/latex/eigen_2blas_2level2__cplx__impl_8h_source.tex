\hypertarget{eigen_2blas_2level2__cplx__impl_8h_source}{}\section{eigen/blas/level2\+\_\+cplx\+\_\+impl.h}
\label{eigen_2blas_2level2__cplx__impl_8h_source}\index{level2\+\_\+cplx\+\_\+impl.\+h@{level2\+\_\+cplx\+\_\+impl.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "common.h"}
00011 
00019 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(hemv)(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *uplo, \textcolor{keyword}{const} \textcolor{keywordtype}{int} *n, \textcolor{keyword}{const} RealScalar *palpha, \textcolor{keyword}{const} RealScalar *pa, \textcolor{keyword}{
      const} \textcolor{keywordtype}{int} *lda,
00020                           \textcolor{keyword}{const} RealScalar *px, \textcolor{keyword}{const} \textcolor{keywordtype}{int} *incx, \textcolor{keyword}{const} RealScalar *pbeta, RealScalar *py, \textcolor{keyword}{
      const} \textcolor{keywordtype}{int} *incy)
00021 \{
00022   \textcolor{keyword}{typedef} void (*functype)(int, \textcolor{keyword}{const} Scalar*, int, \textcolor{keyword}{const} Scalar*, Scalar*, Scalar);
00023   \textcolor{keyword}{static} \textcolor{keyword}{const} functype \hyperlink{structfunc}{func}[2] = \{
00024     \textcolor{comment}{// array index: UP}
00025     (internal::selfadjoint\_matrix\_vector\_product<Scalar,int,ColMajor,Upper,false,false>::run),
00026     \textcolor{comment}{// array index: LO}
00027     (internal::selfadjoint\_matrix\_vector\_product<Scalar,int,ColMajor,Lower,false,false>::run),
00028   \};
00029 
00030   \textcolor{keyword}{const} Scalar* a = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }Scalar*\textcolor{keyword}{>}(pa);
00031   \textcolor{keyword}{const} Scalar* x = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }Scalar*\textcolor{keyword}{>}(px);
00032   Scalar* y = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(py);
00033   Scalar alpha  = *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }Scalar*\textcolor{keyword}{>}(palpha);
00034   Scalar beta   = *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }Scalar*\textcolor{keyword}{>}(pbeta);
00035 
00036   \textcolor{comment}{// check arguments}
00037   \textcolor{keywordtype}{int} info = 0;
00038   \textcolor{keywordflow}{if}(UPLO(*uplo)==INVALID)        info = 1;
00039   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*n<0)                   info = 2;
00040   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*lda<std::max(1,*n))    info = 5;
00041   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx==0)               info = 7;
00042   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incy==0)               info = 10;
00043   \textcolor{keywordflow}{if}(info)
00044     \textcolor{keywordflow}{return} xerbla\_(SCALAR\_SUFFIX\_UP\textcolor{stringliteral}{"HEMV "},&info,6);
00045 
00046   \textcolor{keywordflow}{if}(*n==0)
00047     \textcolor{keywordflow}{return} 1;
00048 
00049   \textcolor{keyword}{const} Scalar* actual\_x = get\_compact\_vector(x,*n,*incx);
00050   Scalar* actual\_y = get\_compact\_vector(y,*n,*incy);
00051 
00052   \textcolor{keywordflow}{if}(beta!=Scalar(1))
00053   \{
00054     \textcolor{keywordflow}{if}(beta==Scalar(0)) make\_vector(actual\_y, *n).setZero();
00055     \textcolor{keywordflow}{else}                make\_vector(actual\_y, *n) *= beta;
00056   \}
00057 
00058   \textcolor{keywordflow}{if}(alpha!=Scalar(0))
00059   \{
00060     \textcolor{keywordtype}{int} \hyperlink{structcode}{code} = UPLO(*uplo);
00061     \textcolor{keywordflow}{if}(code>=2 || func[code]==0)
00062       \textcolor{keywordflow}{return} 0;
00063 
00064     func[code](*n, a, *lda, actual\_x, actual\_y, alpha);
00065   \}
00066 
00067   \textcolor{keywordflow}{if}(actual\_x!=x) \textcolor{keyword}{delete}[] actual\_x;
00068   \textcolor{keywordflow}{if}(actual\_y!=y) \textcolor{keyword}{delete}[] copy\_back(actual\_y,y,*n,*incy);
00069 
00070   \textcolor{keywordflow}{return} 1;
00071 \}
00072 
00080 \textcolor{comment}{// int EIGEN\_BLAS\_FUNC(hbmv)(char *uplo, int *n, int *k, RealScalar *alpha, RealScalar *a, int *lda,}
00081 \textcolor{comment}{//                           RealScalar *x, int *incx, RealScalar *beta, RealScalar *y, int *incy)}
00082 \textcolor{comment}{// \{}
00083 \textcolor{comment}{//   return 1;}
00084 \textcolor{comment}{// \}}
00085 
00093 \textcolor{comment}{// int EIGEN\_BLAS\_FUNC(hpmv)(char *uplo, int *n, RealScalar *alpha, RealScalar *ap, RealScalar *x, int
       *incx, RealScalar *beta, RealScalar *y, int *incy)}
00094 \textcolor{comment}{// \{}
00095 \textcolor{comment}{//   return 1;}
00096 \textcolor{comment}{// \}}
00097 
00105 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(hpr)(\textcolor{keywordtype}{char} *uplo, \textcolor{keywordtype}{int} *n, RealScalar *palpha, RealScalar *px, \textcolor{keywordtype}{int} *incx, RealScalar *pap
      )
00106 \{
00107   \textcolor{keyword}{typedef} void (*functype)(int, Scalar*, \textcolor{keyword}{const} Scalar*, RealScalar);
00108   \textcolor{keyword}{static} \textcolor{keyword}{const} functype func[2] = \{
00109     \textcolor{comment}{// array index: UP}
00110     (
      \hyperlink{structinternal_1_1selfadjoint__packed__rank1__update}{internal::selfadjoint\_packed\_rank1\_update<Scalar,int,ColMajor,Upper,false,Conj>::run}
      ),
00111     \textcolor{comment}{// array index: LO}
00112     (
      \hyperlink{structinternal_1_1selfadjoint__packed__rank1__update}{internal::selfadjoint\_packed\_rank1\_update<Scalar,int,ColMajor,Lower,false,Conj>::run}
      ),
00113   \};
00114 
00115   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00116   Scalar* ap = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(pap);
00117   RealScalar alpha = *palpha;
00118 
00119   \textcolor{keywordtype}{int} info = 0;
00120   \textcolor{keywordflow}{if}(UPLO(*uplo)==INVALID)                                            info = 1;
00121   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*n<0)                                                       info = 2;
00122   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx==0)                                                   info = 5;
00123   \textcolor{keywordflow}{if}(info)
00124     \textcolor{keywordflow}{return} xerbla\_(SCALAR\_SUFFIX\_UP\textcolor{stringliteral}{"HPR  "},&info,6);
00125 
00126   \textcolor{keywordflow}{if}(alpha==Scalar(0))
00127     \textcolor{keywordflow}{return} 1;
00128 
00129   Scalar* x\_cpy = get\_compact\_vector(x, *n, *incx);
00130 
00131   \textcolor{keywordtype}{int} code = UPLO(*uplo);
00132   \textcolor{keywordflow}{if}(code>=2 || func[code]==0)
00133     \textcolor{keywordflow}{return} 0;
00134 
00135   func[code](*n, ap, x\_cpy, alpha);
00136 
00137   \textcolor{keywordflow}{if}(x\_cpy!=x)  \textcolor{keyword}{delete}[] x\_cpy;
00138 
00139   \textcolor{keywordflow}{return} 1;
00140 \}
00141 
00149 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(hpr2)(\textcolor{keywordtype}{char} *uplo, \textcolor{keywordtype}{int} *n, RealScalar *palpha, RealScalar *px, \textcolor{keywordtype}{int} *incx, RealScalar *py
      , \textcolor{keywordtype}{int} *incy, RealScalar *pap)
00150 \{
00151   \textcolor{keyword}{typedef} void (*functype)(int, Scalar*, \textcolor{keyword}{const} Scalar*, \textcolor{keyword}{const} Scalar*, Scalar);
00152   \textcolor{keyword}{static} \textcolor{keyword}{const} functype func[2] = \{
00153     \textcolor{comment}{// array index: UP}
00154     (\hyperlink{structinternal_1_1packed__rank2__update__selector}{internal::packed\_rank2\_update\_selector<Scalar,int,Upper>::run}
      ),
00155     \textcolor{comment}{// array index: LO}
00156     (\hyperlink{structinternal_1_1packed__rank2__update__selector}{internal::packed\_rank2\_update\_selector<Scalar,int,Lower>::run}
      ),
00157   \};
00158 
00159   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00160   Scalar* y = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(py);
00161   Scalar* ap = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(pap);
00162   Scalar alpha = *\textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(palpha);
00163 
00164   \textcolor{keywordtype}{int} info = 0;
00165   \textcolor{keywordflow}{if}(UPLO(*uplo)==INVALID)                                            info = 1;
00166   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*n<0)                                                       info = 2;
00167   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx==0)                                                   info = 5;
00168   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incy==0)                                                   info = 7;
00169   \textcolor{keywordflow}{if}(info)
00170     \textcolor{keywordflow}{return} xerbla\_(SCALAR\_SUFFIX\_UP\textcolor{stringliteral}{"HPR2 "},&info,6);
00171 
00172   \textcolor{keywordflow}{if}(alpha==Scalar(0))
00173     \textcolor{keywordflow}{return} 1;
00174 
00175   Scalar* x\_cpy = get\_compact\_vector(x, *n, *incx);
00176   Scalar* y\_cpy = get\_compact\_vector(y, *n, *incy);
00177 
00178   \textcolor{keywordtype}{int} code = UPLO(*uplo);
00179   \textcolor{keywordflow}{if}(code>=2 || func[code]==0)
00180     \textcolor{keywordflow}{return} 0;
00181 
00182   func[code](*n, ap, x\_cpy, y\_cpy, alpha);
00183 
00184   \textcolor{keywordflow}{if}(x\_cpy!=x)  \textcolor{keyword}{delete}[] x\_cpy;
00185   \textcolor{keywordflow}{if}(y\_cpy!=y)  \textcolor{keyword}{delete}[] y\_cpy;
00186 
00187   \textcolor{keywordflow}{return} 1;
00188 \}
00189 
00197 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(her)(\textcolor{keywordtype}{char} *uplo, \textcolor{keywordtype}{int} *n, RealScalar *palpha, RealScalar *px, \textcolor{keywordtype}{int} *incx, RealScalar *pa,
       \textcolor{keywordtype}{int} *lda)
00198 \{
00199   \textcolor{keyword}{typedef} void (*functype)(int, Scalar*, int, \textcolor{keyword}{const} Scalar*, \textcolor{keyword}{const} Scalar*, \textcolor{keyword}{const} Scalar&);
00200   \textcolor{keyword}{static} \textcolor{keyword}{const} functype func[2] = \{
00201     \textcolor{comment}{// array index: UP}
00202     (\hyperlink{struct_eigen_1_1selfadjoint__rank1__update}{selfadjoint\_rank1\_update<Scalar,int,ColMajor,Upper,false,Conj>::run}
      ),
00203     \textcolor{comment}{// array index: LO}
00204     (\hyperlink{struct_eigen_1_1selfadjoint__rank1__update}{selfadjoint\_rank1\_update<Scalar,int,ColMajor,Lower,false,Conj>::run}
      ),
00205   \};
00206 
00207   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00208   Scalar* a = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(pa);
00209   RealScalar alpha = *\textcolor{keyword}{reinterpret\_cast<}RealScalar*\textcolor{keyword}{>}(palpha);
00210 
00211   \textcolor{keywordtype}{int} info = 0;
00212   \textcolor{keywordflow}{if}(UPLO(*uplo)==INVALID)                                            info = 1;
00213   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*n<0)                                                       info = 2;
00214   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx==0)                                                   info = 5;
00215   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*lda<std::max(1,*n))                                        info = 7;
00216   \textcolor{keywordflow}{if}(info)
00217     \textcolor{keywordflow}{return} xerbla\_(SCALAR\_SUFFIX\_UP\textcolor{stringliteral}{"HER  "},&info,6);
00218 
00219   \textcolor{keywordflow}{if}(alpha==RealScalar(0))
00220     \textcolor{keywordflow}{return} 1;
00221 
00222   Scalar* x\_cpy = get\_compact\_vector(x, *n, *incx);
00223 
00224   \textcolor{keywordtype}{int} code = UPLO(*uplo);
00225   \textcolor{keywordflow}{if}(code>=2 || func[code]==0)
00226     \textcolor{keywordflow}{return} 0;
00227 
00228   func[code](*n, a, *lda, x\_cpy, x\_cpy, alpha);
00229 
00230   matrix(a,*n,*n,*lda).diagonal().imag().setZero();
00231 
00232   \textcolor{keywordflow}{if}(x\_cpy!=x)  \textcolor{keyword}{delete}[] x\_cpy;
00233 
00234   \textcolor{keywordflow}{return} 1;
00235 \}
00236 
00244 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(her2)(\textcolor{keywordtype}{char} *uplo, \textcolor{keywordtype}{int} *n, RealScalar *palpha, RealScalar *px, \textcolor{keywordtype}{int} *incx, RealScalar *py
      , \textcolor{keywordtype}{int} *incy, RealScalar *pa, \textcolor{keywordtype}{int} *lda)
00245 \{
00246   \textcolor{keyword}{typedef} void (*functype)(int, Scalar*, int, \textcolor{keyword}{const} Scalar*, \textcolor{keyword}{const} Scalar*, Scalar);
00247   \textcolor{keyword}{static} \textcolor{keyword}{const} functype func[2] = \{
00248     \textcolor{comment}{// array index: UP}
00249     (\hyperlink{structinternal_1_1rank2__update__selector}{internal::rank2\_update\_selector<Scalar,int,Upper>::run}
      ),
00250     \textcolor{comment}{// array index: LO}
00251     (\hyperlink{structinternal_1_1rank2__update__selector}{internal::rank2\_update\_selector<Scalar,int,Lower>::run}
      ),
00252   \};
00253 
00254   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00255   Scalar* y = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(py);
00256   Scalar* a = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(pa);
00257   Scalar alpha = *\textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(palpha);
00258 
00259   \textcolor{keywordtype}{int} info = 0;
00260   \textcolor{keywordflow}{if}(UPLO(*uplo)==INVALID)                                            info = 1;
00261   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*n<0)                                                       info = 2;
00262   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx==0)                                                   info = 5;
00263   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incy==0)                                                   info = 7;
00264   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*lda<std::max(1,*n))                                        info = 9;
00265   \textcolor{keywordflow}{if}(info)
00266     \textcolor{keywordflow}{return} xerbla\_(SCALAR\_SUFFIX\_UP\textcolor{stringliteral}{"HER2 "},&info,6);
00267 
00268   \textcolor{keywordflow}{if}(alpha==Scalar(0))
00269     \textcolor{keywordflow}{return} 1;
00270 
00271   Scalar* x\_cpy = get\_compact\_vector(x, *n, *incx);
00272   Scalar* y\_cpy = get\_compact\_vector(y, *n, *incy);
00273 
00274   \textcolor{keywordtype}{int} code = UPLO(*uplo);
00275   \textcolor{keywordflow}{if}(code>=2 || func[code]==0)
00276     \textcolor{keywordflow}{return} 0;
00277 
00278   func[code](*n, a, *lda, x\_cpy, y\_cpy, alpha);
00279 
00280   matrix(a,*n,*n,*lda).diagonal().imag().setZero();
00281 
00282   \textcolor{keywordflow}{if}(x\_cpy!=x)  \textcolor{keyword}{delete}[] x\_cpy;
00283   \textcolor{keywordflow}{if}(y\_cpy!=y)  \textcolor{keyword}{delete}[] y\_cpy;
00284 
00285   \textcolor{keywordflow}{return} 1;
00286 \}
00287 
00295 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(geru)(\textcolor{keywordtype}{int} *m, \textcolor{keywordtype}{int} *n, RealScalar *palpha, RealScalar *px, \textcolor{keywordtype}{int} *incx, RealScalar *py, \textcolor{keywordtype}{
      int} *incy, RealScalar *pa, \textcolor{keywordtype}{int} *lda)
00296 \{
00297   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00298   Scalar* y = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(py);
00299   Scalar* a = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(pa);
00300   Scalar alpha = *\textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(palpha);
00301 
00302   \textcolor{keywordtype}{int} info = 0;
00303        \textcolor{keywordflow}{if}(*m<0)                                                       info = 1;
00304   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*n<0)                                                       info = 2;
00305   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx==0)                                                   info = 5;
00306   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incy==0)                                                   info = 7;
00307   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*lda<std::max(1,*m))                                        info = 9;
00308   \textcolor{keywordflow}{if}(info)
00309     \textcolor{keywordflow}{return} xerbla\_(SCALAR\_SUFFIX\_UP\textcolor{stringliteral}{"GERU "},&info,6);
00310 
00311   \textcolor{keywordflow}{if}(alpha==Scalar(0))
00312     \textcolor{keywordflow}{return} 1;
00313 
00314   Scalar* x\_cpy = get\_compact\_vector(x,*m,*incx);
00315   Scalar* y\_cpy = get\_compact\_vector(y,*n,*incy);
00316 
00317   \hyperlink{structinternal_1_1general__rank1__update}{internal::general\_rank1\_update<Scalar,int,ColMajor,false,false>::run}
      (*m, *n, a, *lda, x\_cpy, y\_cpy, alpha);
00318 
00319   \textcolor{keywordflow}{if}(x\_cpy!=x)  \textcolor{keyword}{delete}[] x\_cpy;
00320   \textcolor{keywordflow}{if}(y\_cpy!=y)  \textcolor{keyword}{delete}[] y\_cpy;
00321 
00322   \textcolor{keywordflow}{return} 1;
00323 \}
00324 
00332 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(gerc)(\textcolor{keywordtype}{int} *m, \textcolor{keywordtype}{int} *n, RealScalar *palpha, RealScalar *px, \textcolor{keywordtype}{int} *incx, RealScalar *py, \textcolor{keywordtype}{
      int} *incy, RealScalar *pa, \textcolor{keywordtype}{int} *lda)
00333 \{
00334   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00335   Scalar* y = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(py);
00336   Scalar* a = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(pa);
00337   Scalar alpha = *\textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(palpha);
00338 
00339   \textcolor{keywordtype}{int} info = 0;
00340        \textcolor{keywordflow}{if}(*m<0)                                                       info = 1;
00341   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*n<0)                                                       info = 2;
00342   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx==0)                                                   info = 5;
00343   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incy==0)                                                   info = 7;
00344   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*lda<std::max(1,*m))                                        info = 9;
00345   \textcolor{keywordflow}{if}(info)
00346     \textcolor{keywordflow}{return} xerbla\_(SCALAR\_SUFFIX\_UP\textcolor{stringliteral}{"GERC "},&info,6);
00347 
00348   \textcolor{keywordflow}{if}(alpha==Scalar(0))
00349     \textcolor{keywordflow}{return} 1;
00350 
00351   Scalar* x\_cpy = get\_compact\_vector(x,*m,*incx);
00352   Scalar* y\_cpy = get\_compact\_vector(y,*n,*incy);
00353 
00354   \hyperlink{structinternal_1_1general__rank1__update}{internal::general\_rank1\_update<Scalar,int,ColMajor,false,Conj>::run}
      (*m, *n, a, *lda, x\_cpy, y\_cpy, alpha);
00355 
00356   \textcolor{keywordflow}{if}(x\_cpy!=x)  \textcolor{keyword}{delete}[] x\_cpy;
00357   \textcolor{keywordflow}{if}(y\_cpy!=y)  \textcolor{keyword}{delete}[] y\_cpy;
00358 
00359   \textcolor{keywordflow}{return} 1;
00360 \}
\end{DoxyCode}
