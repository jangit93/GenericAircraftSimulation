\hypertarget{zlib_2deflate_8h_source}{}\section{zlib/deflate.h}
\label{zlib_2deflate_8h_source}\index{deflate.\+h@{deflate.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* deflate.h -- internal compression state}
00002 \textcolor{comment}{ * Copyright (C) 1995-2016 Jean-loup Gailly}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ */}
00005 
00006 \textcolor{comment}{/* WARNING: this file should *not* be used by applications. It is}
00007 \textcolor{comment}{   part of the implementation of the compression library and is}
00008 \textcolor{comment}{   subject to change. Applications should only use zlib.h.}
00009 \textcolor{comment}{ */}
00010 
00011 \textcolor{comment}{/* @(#) $Id$ */}
00012 
00013 \textcolor{preprocessor}{#ifndef DEFLATE\_H}
00014 \textcolor{preprocessor}{#define DEFLATE\_H}
00015 
00016 \textcolor{preprocessor}{#include "zutil.h"}
00017 
00018 \textcolor{comment}{/* define NO\_GZIP when compiling if you want to disable gzip header and}
00019 \textcolor{comment}{   trailer creation by deflate().  NO\_GZIP would be used to avoid linking in}
00020 \textcolor{comment}{   the crc code when it is not needed.  For shared libraries, gzip encoding}
00021 \textcolor{comment}{   should be left enabled. */}
00022 \textcolor{preprocessor}{#ifndef NO\_GZIP}
00023 \textcolor{preprocessor}{#  define GZIP}
00024 \textcolor{preprocessor}{#endif}
00025 
00026 \textcolor{comment}{/* ===========================================================================}
00027 \textcolor{comment}{ * Internal compression state.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#define LENGTH\_CODES 29}
00031 \textcolor{comment}{/* number of length codes, not counting the special END\_BLOCK code */}
00032 
00033 \textcolor{preprocessor}{#define LITERALS  256}
00034 \textcolor{comment}{/* number of literal bytes 0..255 */}
00035 
00036 \textcolor{preprocessor}{#define L\_CODES (LITERALS+1+LENGTH\_CODES)}
00037 \textcolor{comment}{/* number of Literal or Length codes, including the END\_BLOCK code */}
00038 
00039 \textcolor{preprocessor}{#define D\_CODES   30}
00040 \textcolor{comment}{/* number of distance codes */}
00041 
00042 \textcolor{preprocessor}{#define BL\_CODES  19}
00043 \textcolor{comment}{/* number of codes used to transfer the bit lengths */}
00044 
00045 \textcolor{preprocessor}{#define HEAP\_SIZE (2*L\_CODES+1)}
00046 \textcolor{comment}{/* maximum heap size */}
00047 
00048 \textcolor{preprocessor}{#define MAX\_BITS 15}
00049 \textcolor{comment}{/* All codes must not exceed MAX\_BITS bits */}
00050 
00051 \textcolor{preprocessor}{#define Buf\_size 16}
00052 \textcolor{comment}{/* size of bit buffer in bi\_buf */}
00053 
00054 \textcolor{preprocessor}{#define INIT\_STATE    42    }\textcolor{comment}{/* zlib header -> BUSY\_STATE */}\textcolor{preprocessor}{}
00055 \textcolor{preprocessor}{#ifdef GZIP}
00056 \textcolor{preprocessor}{#  define GZIP\_STATE  57    }\textcolor{comment}{/* gzip header -> BUSY\_STATE | EXTRA\_STATE */}\textcolor{preprocessor}{}
00057 \textcolor{preprocessor}{#endif}
00058 \textcolor{preprocessor}{#define EXTRA\_STATE   69    }\textcolor{comment}{/* gzip extra block -> NAME\_STATE */}\textcolor{preprocessor}{}
00059 \textcolor{preprocessor}{#define NAME\_STATE    73    }\textcolor{comment}{/* gzip file name -> COMMENT\_STATE */}\textcolor{preprocessor}{}
00060 \textcolor{preprocessor}{#define COMMENT\_STATE 91    }\textcolor{comment}{/* gzip comment -> HCRC\_STATE */}\textcolor{preprocessor}{}
00061 \textcolor{preprocessor}{#define HCRC\_STATE   103    }\textcolor{comment}{/* gzip header CRC -> BUSY\_STATE */}\textcolor{preprocessor}{}
00062 \textcolor{preprocessor}{#define BUSY\_STATE   113    }\textcolor{comment}{/* deflate -> FINISH\_STATE */}\textcolor{preprocessor}{}
00063 \textcolor{preprocessor}{#define FINISH\_STATE 666    }\textcolor{comment}{/* stream complete */}\textcolor{preprocessor}{}
00064 \textcolor{comment}{/* Stream status */}
00065 
00066 
00067 \textcolor{comment}{/* Data structure describing a single value and its code string. */}
00068 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structct__data__s}{ct\_data\_s} \{
00069     \textcolor{keyword}{union }\{
00070         ush  freq;       \textcolor{comment}{/* frequency count */}
00071         ush  \hyperlink{structcode}{code};       \textcolor{comment}{/* bit string */}
00072     \} fc;
00073     \textcolor{keyword}{union }\{
00074         ush  dad;        \textcolor{comment}{/* father node in Huffman tree */}
00075         ush  len;        \textcolor{comment}{/* length of bit string */}
00076     \} dl;
00077 \} FAR \hyperlink{structct__data__s}{ct\_data};
00078 
00079 \textcolor{preprocessor}{#define Freq fc.freq}
00080 \textcolor{preprocessor}{#define Code fc.code}
00081 \textcolor{preprocessor}{#define Dad  dl.dad}
00082 \textcolor{preprocessor}{#define Len  dl.len}
00083 
00084 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structstatic__tree__desc__s}{static\_tree\_desc\_s}  \hyperlink{structstatic__tree__desc__s}{static\_tree\_desc};
00085 
00086 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structtree__desc__s}{tree\_desc\_s} \{
00087     \hyperlink{structct__data__s}{ct\_data} *dyn\_tree;           \textcolor{comment}{/* the dynamic tree */}
00088     \textcolor{keywordtype}{int}     max\_code;            \textcolor{comment}{/* largest code with non zero frequency */}
00089     \textcolor{keyword}{const} \hyperlink{structstatic__tree__desc__s}{static\_tree\_desc} *stat\_desc;  \textcolor{comment}{/* the corresponding static tree */}
00090 \} FAR \hyperlink{structtree__desc__s}{tree\_desc};
00091 
00092 \textcolor{keyword}{typedef} ush Pos;
00093 \textcolor{keyword}{typedef} Pos FAR Posf;
00094 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} IPos;
00095 
00096 \textcolor{comment}{/* A Pos is an index in the character window. We use short instead of int to}
00097 \textcolor{comment}{ * save space in the various tables. IPos is used only for parameter passing.}
00098 \textcolor{comment}{ */}
00099 
00100 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structinternal__state}{internal\_state} \{
00101     z\_streamp strm;      \textcolor{comment}{/* pointer back to this zlib stream */}
00102     \textcolor{keywordtype}{int}   status;        \textcolor{comment}{/* as the name implies */}
00103     Bytef *pending\_buf;  \textcolor{comment}{/* output still pending */}
00104     ulg   pending\_buf\_size; \textcolor{comment}{/* size of pending\_buf */}
00105     Bytef *pending\_out;  \textcolor{comment}{/* next pending byte to output to the stream */}
00106     ulg   pending;       \textcolor{comment}{/* nb of bytes in the pending buffer */}
00107     \textcolor{keywordtype}{int}   wrap;          \textcolor{comment}{/* bit 0 true for zlib, bit 1 true for gzip */}
00108     gz\_headerp  gzhead;  \textcolor{comment}{/* gzip header information to write */}
00109     ulg   gzindex;       \textcolor{comment}{/* where in extra, name, or comment */}
00110     Byte  method;        \textcolor{comment}{/* can only be DEFLATED */}
00111     \textcolor{keywordtype}{int}   last\_flush;    \textcolor{comment}{/* value of flush param for previous deflate call */}
00112 
00113                 \textcolor{comment}{/* used by deflate.c: */}
00114 
00115     uInt  w\_size;        \textcolor{comment}{/* LZ77 window size (32K by default) */}
00116     uInt  w\_bits;        \textcolor{comment}{/* log2(w\_size)  (8..16) */}
00117     uInt  w\_mask;        \textcolor{comment}{/* w\_size - 1 */}
00118 
00119     Bytef *window;
00120     \textcolor{comment}{/* Sliding window. Input bytes are read into the second half of the window,}
00121 \textcolor{comment}{     * and move to the first half later to keep a dictionary of at least wSize}
00122 \textcolor{comment}{     * bytes. With this organization, matches are limited to a distance of}
00123 \textcolor{comment}{     * wSize-MAX\_MATCH bytes, but this ensures that IO is always}
00124 \textcolor{comment}{     * performed with a length multiple of the block size. Also, it limits}
00125 \textcolor{comment}{     * the window size to 64K, which is quite useful on MSDOS.}
00126 \textcolor{comment}{     * To do: use the user input buffer as sliding window.}
00127 \textcolor{comment}{     */}
00128 
00129     ulg window\_size;
00130     \textcolor{comment}{/* Actual size of window: 2*wSize, except when the user input buffer}
00131 \textcolor{comment}{     * is directly used as sliding window.}
00132 \textcolor{comment}{     */}
00133 
00134     Posf *prev;
00135     \textcolor{comment}{/* Link to older string with same hash index. To limit the size of this}
00136 \textcolor{comment}{     * array to 64K, this link is maintained only for the last 32K strings.}
00137 \textcolor{comment}{     * An index in this array is thus a window index modulo 32K.}
00138 \textcolor{comment}{     */}
00139 
00140     Posf *head; \textcolor{comment}{/* Heads of the hash chains or NIL. */}
00141 
00142     uInt  ins\_h;          \textcolor{comment}{/* hash index of string to be inserted */}
00143     uInt  hash\_size;      \textcolor{comment}{/* number of elements in hash table */}
00144     uInt  hash\_bits;      \textcolor{comment}{/* log2(hash\_size) */}
00145     uInt  hash\_mask;      \textcolor{comment}{/* hash\_size-1 */}
00146 
00147     uInt  hash\_shift;
00148     \textcolor{comment}{/* Number of bits by which ins\_h must be shifted at each input}
00149 \textcolor{comment}{     * step. It must be such that after MIN\_MATCH steps, the oldest}
00150 \textcolor{comment}{     * byte no longer takes part in the hash key, that is:}
00151 \textcolor{comment}{     *   hash\_shift * MIN\_MATCH >= hash\_bits}
00152 \textcolor{comment}{     */}
00153 
00154     \textcolor{keywordtype}{long} block\_start;
00155     \textcolor{comment}{/* Window position at the beginning of the current output block. Gets}
00156 \textcolor{comment}{     * negative when the window is moved backwards.}
00157 \textcolor{comment}{     */}
00158 
00159     uInt match\_length;           \textcolor{comment}{/* length of best match */}
00160     IPos prev\_match;             \textcolor{comment}{/* previous match */}
00161     \textcolor{keywordtype}{int} match\_available;         \textcolor{comment}{/* set if previous match exists */}
00162     uInt strstart;               \textcolor{comment}{/* start of string to insert */}
00163     uInt match\_start;            \textcolor{comment}{/* start of matching string */}
00164     uInt lookahead;              \textcolor{comment}{/* number of valid bytes ahead in window */}
00165 
00166     uInt prev\_length;
00167     \textcolor{comment}{/* Length of the best match at previous step. Matches not greater than this}
00168 \textcolor{comment}{     * are discarded. This is used in the lazy match evaluation.}
00169 \textcolor{comment}{     */}
00170 
00171     uInt max\_chain\_length;
00172     \textcolor{comment}{/* To speed up deflation, hash chains are never searched beyond this}
00173 \textcolor{comment}{     * length.  A higher limit improves compression ratio but degrades the}
00174 \textcolor{comment}{     * speed.}
00175 \textcolor{comment}{     */}
00176 
00177     uInt max\_lazy\_match;
00178     \textcolor{comment}{/* Attempt to find a better match only when the current match is strictly}
00179 \textcolor{comment}{     * smaller than this value. This mechanism is used only for compression}
00180 \textcolor{comment}{     * levels >= 4.}
00181 \textcolor{comment}{     */}
00182 \textcolor{preprocessor}{#   define max\_insert\_length  max\_lazy\_match}
00183     \textcolor{comment}{/* Insert new strings in the hash table only if the match length is not}
00184 \textcolor{comment}{     * greater than this length. This saves time but degrades compression.}
00185 \textcolor{comment}{     * max\_insert\_length is used only for compression levels <= 3.}
00186 \textcolor{comment}{     */}
00187 
00188     \textcolor{keywordtype}{int} level;    \textcolor{comment}{/* compression level (1..9) */}
00189     \textcolor{keywordtype}{int} strategy; \textcolor{comment}{/* favor or force Huffman coding*/}
00190 
00191     uInt good\_match;
00192     \textcolor{comment}{/* Use a faster search when the previous match is longer than this */}
00193 
00194     \textcolor{keywordtype}{int} nice\_match; \textcolor{comment}{/* Stop searching when current match exceeds this */}
00195 
00196                 \textcolor{comment}{/* used by trees.c: */}
00197     \textcolor{comment}{/* Didn't use ct\_data typedef below to suppress compiler warning */}
00198     \textcolor{keyword}{struct }\hyperlink{structct__data__s}{ct\_data\_s} dyn\_ltree[HEAP\_SIZE];   \textcolor{comment}{/* literal and length tree */}
00199     \textcolor{keyword}{struct }\hyperlink{structct__data__s}{ct\_data\_s} dyn\_dtree[2*D\_CODES+1]; \textcolor{comment}{/* distance tree */}
00200     \textcolor{keyword}{struct }\hyperlink{structct__data__s}{ct\_data\_s} bl\_tree[2*BL\_CODES+1];  \textcolor{comment}{/* Huffman tree for bit lengths */}
00201 
00202     \textcolor{keyword}{struct }\hyperlink{structtree__desc__s}{tree\_desc\_s} l\_desc;               \textcolor{comment}{/* desc. for literal tree */}
00203     \textcolor{keyword}{struct }\hyperlink{structtree__desc__s}{tree\_desc\_s} d\_desc;               \textcolor{comment}{/* desc. for distance tree */}
00204     \textcolor{keyword}{struct }\hyperlink{structtree__desc__s}{tree\_desc\_s} bl\_desc;              \textcolor{comment}{/* desc. for bit length tree */}
00205 
00206     ush bl\_count[MAX\_BITS+1];
00207     \textcolor{comment}{/* number of codes at each bit length for an optimal tree */}
00208 
00209     \textcolor{keywordtype}{int} heap[2*L\_CODES+1];      \textcolor{comment}{/* heap used to build the Huffman trees */}
00210     \textcolor{keywordtype}{int} heap\_len;               \textcolor{comment}{/* number of elements in the heap */}
00211     \textcolor{keywordtype}{int} heap\_max;               \textcolor{comment}{/* element of largest frequency */}
00212     \textcolor{comment}{/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.}
00213 \textcolor{comment}{     * The same heap array is used to build all trees.}
00214 \textcolor{comment}{     */}
00215 
00216     uch depth[2*L\_CODES+1];
00217     \textcolor{comment}{/* Depth of each subtree used as tie breaker for trees of equal frequency}
00218 \textcolor{comment}{     */}
00219 
00220     uchf *l\_buf;          \textcolor{comment}{/* buffer for literals or lengths */}
00221 
00222     uInt  lit\_bufsize;
00223     \textcolor{comment}{/* Size of match buffer for literals/lengths.  There are 4 reasons for}
00224 \textcolor{comment}{     * limiting lit\_bufsize to 64K:}
00225 \textcolor{comment}{     *   - frequencies can be kept in 16 bit counters}
00226 \textcolor{comment}{     *   - if compression is not successful for the first block, all input}
00227 \textcolor{comment}{     *     data is still in the window so we can still emit a stored block even}
00228 \textcolor{comment}{     *     when input comes from standard input.  (This can also be done for}
00229 \textcolor{comment}{     *     all blocks if lit\_bufsize is not greater than 32K.)}
00230 \textcolor{comment}{     *   - if compression is not successful for a file smaller than 64K, we can}
00231 \textcolor{comment}{     *     even emit a stored file instead of a stored block (saving 5 bytes).}
00232 \textcolor{comment}{     *     This is applicable only for zip (not gzip or zlib).}
00233 \textcolor{comment}{     *   - creating new Huffman trees less frequently may not provide fast}
00234 \textcolor{comment}{     *     adaptation to changes in the input data statistics. (Take for}
00235 \textcolor{comment}{     *     example a binary file with poorly compressible code followed by}
00236 \textcolor{comment}{     *     a highly compressible string table.) Smaller buffer sizes give}
00237 \textcolor{comment}{     *     fast adaptation but have of course the overhead of transmitting}
00238 \textcolor{comment}{     *     trees more frequently.}
00239 \textcolor{comment}{     *   - I can't count above 4}
00240 \textcolor{comment}{     */}
00241 
00242     uInt last\_lit;      \textcolor{comment}{/* running index in l\_buf */}
00243 
00244     ushf *d\_buf;
00245     \textcolor{comment}{/* Buffer for distances. To simplify the code, d\_buf and l\_buf have}
00246 \textcolor{comment}{     * the same number of elements. To use different lengths, an extra flag}
00247 \textcolor{comment}{     * array would be necessary.}
00248 \textcolor{comment}{     */}
00249 
00250     ulg opt\_len;        \textcolor{comment}{/* bit length of current block with optimal trees */}
00251     ulg static\_len;     \textcolor{comment}{/* bit length of current block with static trees */}
00252     uInt matches;       \textcolor{comment}{/* number of string matches in current block */}
00253     uInt insert;        \textcolor{comment}{/* bytes at end of window left to insert */}
00254 
00255 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
00256     ulg compressed\_len; \textcolor{comment}{/* total bit length of compressed file mod 2^32 */}
00257     ulg bits\_sent;      \textcolor{comment}{/* bit length of compressed data sent mod 2^32 */}
00258 \textcolor{preprocessor}{#endif}
00259 
00260     ush bi\_buf;
00261     \textcolor{comment}{/* Output buffer. bits are inserted starting at the bottom (least}
00262 \textcolor{comment}{     * significant bits).}
00263 \textcolor{comment}{     */}
00264     \textcolor{keywordtype}{int} bi\_valid;
00265     \textcolor{comment}{/* Number of valid bits in bi\_buf.  All bits above the last valid bit}
00266 \textcolor{comment}{     * are always zero.}
00267 \textcolor{comment}{     */}
00268 
00269     ulg high\_water;
00270     \textcolor{comment}{/* High water mark offset in window for initialized bytes -- bytes above}
00271 \textcolor{comment}{     * this are set to zero in order to avoid memory check warnings when}
00272 \textcolor{comment}{     * longest match routines access bytes past the input.  This is then}
00273 \textcolor{comment}{     * updated to the new high water mark.}
00274 \textcolor{comment}{     */}
00275 
00276 \} FAR \hyperlink{structinternal__state}{deflate\_state};
00277 
00278 \textcolor{comment}{/* Output a byte on the stream.}
00279 \textcolor{comment}{ * IN assertion: there is enough room in pending\_buf.}
00280 \textcolor{comment}{ */}
00281 \textcolor{preprocessor}{#define put\_byte(s, c) \{s->pending\_buf[s->pending++] = (Bytef)(c);\}}
00282 
00283 
00284 \textcolor{preprocessor}{#define MIN\_LOOKAHEAD (MAX\_MATCH+MIN\_MATCH+1)}
00285 \textcolor{comment}{/* Minimum amount of lookahead, except at the end of the input file.}
00286 \textcolor{comment}{ * See deflate.c for comments about the MIN\_MATCH+1.}
00287 \textcolor{comment}{ */}
00288 
00289 \textcolor{preprocessor}{#define MAX\_DIST(s)  ((s)->w\_size-MIN\_LOOKAHEAD)}
00290 \textcolor{comment}{/* In order to simplify the code, particularly on 16 bit machines, match}
00291 \textcolor{comment}{ * distances are limited to MAX\_DIST instead of WSIZE.}
00292 \textcolor{comment}{ */}
00293 
00294 \textcolor{preprocessor}{#define WIN\_INIT MAX\_MATCH}
00295 \textcolor{comment}{/* Number of bytes after end of data in window to initialize in order to avoid}
00296 \textcolor{comment}{   memory checker errors from longest match routines */}
00297 
00298         \textcolor{comment}{/* in trees.c */}
00299 \textcolor{keywordtype}{void} ZLIB\_INTERNAL \_tr\_init OF((\hyperlink{structinternal__state}{deflate\_state} *s));
00300 \textcolor{keywordtype}{int} ZLIB\_INTERNAL \_tr\_tally OF((\hyperlink{structinternal__state}{deflate\_state} *s, \textcolor{keywordtype}{unsigned} dist, \textcolor{keywordtype}{unsigned} lc));
00301 \textcolor{keywordtype}{void} ZLIB\_INTERNAL \_tr\_flush\_block OF((\hyperlink{structinternal__state}{deflate\_state} *s, charf *buf,
00302                         ulg stored\_len, \textcolor{keywordtype}{int} last));
00303 \textcolor{keywordtype}{void} ZLIB\_INTERNAL \_tr\_flush\_bits OF((\hyperlink{structinternal__state}{deflate\_state} *s));
00304 \textcolor{keywordtype}{void} ZLIB\_INTERNAL \_tr\_align OF((\hyperlink{structinternal__state}{deflate\_state} *s));
00305 \textcolor{keywordtype}{void} ZLIB\_INTERNAL \_tr\_stored\_block OF((\hyperlink{structinternal__state}{deflate\_state} *s, charf *buf,
00306                         ulg stored\_len, \textcolor{keywordtype}{int} last));
00307 
00308 \textcolor{preprocessor}{#define d\_code(dist) \(\backslash\)}
00309 \textcolor{preprocessor}{   ((dist) < 256 ? \_dist\_code[dist] : \_dist\_code[256+((dist)>>7)])}
00310 \textcolor{comment}{/* Mapping from a distance to a distance code. dist is the distance - 1 and}
00311 \textcolor{comment}{ * must not have side effects. \_dist\_code[256] and \_dist\_code[257] are never}
00312 \textcolor{comment}{ * used.}
00313 \textcolor{comment}{ */}
00314 
00315 \textcolor{preprocessor}{#ifndef ZLIB\_DEBUG}
00316 \textcolor{comment}{/* Inline versions of \_tr\_tally for speed: */}
00317 
00318 \textcolor{preprocessor}{#if defined(GEN\_TREES\_H) || !defined(STDC)}
00319   \textcolor{keyword}{extern} uch ZLIB\_INTERNAL \_length\_code[];
00320   \textcolor{keyword}{extern} uch ZLIB\_INTERNAL \_dist\_code[];
00321 \textcolor{preprocessor}{#else}
00322   \textcolor{keyword}{extern} \textcolor{keyword}{const} uch ZLIB\_INTERNAL \_length\_code[];
00323   \textcolor{keyword}{extern} \textcolor{keyword}{const} uch ZLIB\_INTERNAL \_dist\_code[];
00324 \textcolor{preprocessor}{#endif}
00325 
00326 \textcolor{preprocessor}{# define \_tr\_tally\_lit(s, c, flush) \(\backslash\)}
00327 \textcolor{preprocessor}{  \{ uch cc = (c); \(\backslash\)}
00328 \textcolor{preprocessor}{    s->d\_buf[s->last\_lit] = 0; \(\backslash\)}
00329 \textcolor{preprocessor}{    s->l\_buf[s->last\_lit++] = cc; \(\backslash\)}
00330 \textcolor{preprocessor}{    s->dyn\_ltree[cc].Freq++; \(\backslash\)}
00331 \textcolor{preprocessor}{    flush = (s->last\_lit == s->lit\_bufsize-1); \(\backslash\)}
00332 \textcolor{preprocessor}{   \}}
00333 \textcolor{preprocessor}{# define \_tr\_tally\_dist(s, distance, length, flush) \(\backslash\)}
00334 \textcolor{preprocessor}{  \{ uch len = (uch)(length); \(\backslash\)}
00335 \textcolor{preprocessor}{    ush dist = (ush)(distance); \(\backslash\)}
00336 \textcolor{preprocessor}{    s->d\_buf[s->last\_lit] = dist; \(\backslash\)}
00337 \textcolor{preprocessor}{    s->l\_buf[s->last\_lit++] = len; \(\backslash\)}
00338 \textcolor{preprocessor}{    dist--; \(\backslash\)}
00339 \textcolor{preprocessor}{    s->dyn\_ltree[\_length\_code[len]+LITERALS+1].Freq++; \(\backslash\)}
00340 \textcolor{preprocessor}{    s->dyn\_dtree[d\_code(dist)].Freq++; \(\backslash\)}
00341 \textcolor{preprocessor}{    flush = (s->last\_lit == s->lit\_bufsize-1); \(\backslash\)}
00342 \textcolor{preprocessor}{  \}}
00343 \textcolor{preprocessor}{#else}
00344 \textcolor{preprocessor}{# define \_tr\_tally\_lit(s, c, flush) flush = \_tr\_tally(s, 0, c)}
00345 \textcolor{preprocessor}{# define \_tr\_tally\_dist(s, distance, length, flush) \(\backslash\)}
00346 \textcolor{preprocessor}{              flush = \_tr\_tally(s, distance, length)}
00347 \textcolor{preprocessor}{#endif}
00348 
00349 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* DEFLATE\_H */}\textcolor{preprocessor}{}
\end{DoxyCode}
