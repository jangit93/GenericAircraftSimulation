\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_eval_to_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Eval\+To.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_eval_to_8h_source}\index{Tensor\+Eval\+To.\+h@{Tensor\+Eval\+To.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_EVAL\_TO\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_EVAL\_TO\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
00024 \textcolor{keyword}{struct }traits<TensorEvalToOp<XprType, MakePointer\_> >
00025 \{
00026   \textcolor{comment}{// Type promotion to handle the case where the types of the lhs and the rhs are different.}
00027   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00028   \textcolor{keyword}{typedef} traits<XprType> XprTraits;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00032   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<Nested>::type \_Nested;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions;
00034   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00035 
00036   \textcolor{keyword}{enum} \{
00037     Flags = 0
00038   \};
00039   \textcolor{keyword}{template} <\textcolor{keyword}{class} T>
00040   \textcolor{keyword}{struct }MakePointer \{
00041     \textcolor{comment}{// Intermediate typedef to workaround MSVC issue.}
00042     \textcolor{keyword}{typedef} MakePointer\_<T> MakePointerT;
00043     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MakePointerT::Type Type;
00044   \};
00045 \};
00046 
00047 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
00048 \textcolor{keyword}{struct }eval<TensorEvalToOp<XprType, MakePointer\_>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00049 \{
00050   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorEvalToOp<XprType, MakePointer\_>& type;
00051 \};
00052 
00053 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
00054 \textcolor{keyword}{struct }nested<TensorEvalToOp<XprType, MakePointer\_>, 1, typename eval<TensorEvalToOp<XprType, MakePointer\_>
       >::type>
00055 \{
00056   \textcolor{keyword}{typedef} TensorEvalToOp<XprType, MakePointer\_> type;
00057 \};
00058 
00059 \}  \textcolor{comment}{// end namespace internal}
00060 
00061 
00062 
00063 
00064 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
00065 \textcolor{keyword}{class }TensorEvalToOp : \textcolor{keyword}{public} TensorBase<TensorEvalToOp<XprType, MakePointer\_>, ReadOnlyAccessors>
00066 \{
00067   \textcolor{keyword}{public}:
00068   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorEvalToOp>::Scalar}
       Scalar;
00069   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00070   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<typename XprType::CoeffReturnType>::type CoeffReturnType;
00071   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MakePointer\_<CoeffReturnType>::Type PointerType;
00072   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorEvalToOp>::type}
       Nested;
00073   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorEvalToOp>::StorageKind}
       StorageKind;
00074   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorEvalToOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00075 
00076   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvalToOp(PointerType buffer, \textcolor{keyword}{const} XprType& expr)
00077       : m\_xpr(expr), m\_buffer(buffer) \{\}
00078 
00079     EIGEN\_DEVICE\_FUNC
00080     \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type&
00081     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00082 
00083     EIGEN\_DEVICE\_FUNC PointerType buffer()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_buffer; \}
00084 
00085   \textcolor{keyword}{protected}:
00086     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00087     PointerType m\_buffer;
00088 \};
00089 
00090 
00091 
00092 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
00093 \textcolor{keyword}{struct }TensorEvaluator<const TensorEvalToOp<ArgType, MakePointer\_>, Device>
00094 \{
00095   \textcolor{keyword}{typedef} TensorEvalToOp<ArgType, MakePointer\_> XprType;
00096   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ArgType::Scalar Scalar;
00097   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} TensorEvaluator<ArgType, Device>::Dimensions Dimensions;
00098   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00099   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<typename XprType::CoeffReturnType>::type CoeffReturnType;
00100   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00101   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = internal::unpacket\_traits<PacketReturnType>::size;
00102 
00103   \textcolor{keyword}{enum} \{
00104     IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,
00105     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00106     Layout = TensorEvaluator<ArgType, Device>::Layout,
00107     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00108     RawAccess = \textcolor{keyword}{true}
00109   \};
00110 
00111   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00112       : m\_impl(op.expression(), device), m\_device(device),
00113           m\_buffer(op.buffer()), m\_op(op), m\_expression(op.expression())
00114   \{ \}
00115 
00116   \textcolor{comment}{// Used for accessor extraction in SYCL Managed TensorMap:}
00117   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} XprType& op()\textcolor{keyword}{ const }\{
00118     \textcolor{keywordflow}{return} m\_op;
00119   \}
00120   
00121   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE ~TensorEvaluator() \{
00122   \}
00123 
00124   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<const TensorEvalToOp<ArgType, MakePointer\_> >::template 
      MakePointer<CoeffReturnType>::Type DevicePointer;
00125   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_impl.dimensions(); \}
00126 
00127   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(DevicePointer scalar) \{
00128     EIGEN\_UNUSED\_VARIABLE(scalar);
00129     eigen\_assert(scalar == NULL);
00130     \textcolor{keywordflow}{return} m\_impl.evalSubExprsIfNeeded(m\_buffer);
00131   \}
00132 
00133   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} evalScalar(Index i) \{
00134     m\_buffer[i] = m\_impl.coeff(i);
00135   \}
00136   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} evalPacket(Index i) \{
00137     internal::pstoret<CoeffReturnType, PacketReturnType, Aligned>(m\_buffer + i, m\_impl.template 
      packet<TensorEvaluator<ArgType, Device>::IsAligned ? \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned} : \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned}>(i));
00138   \}
00139 
00140   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00141     m\_impl.cleanup();
00142   \}
00143 
00144   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00145 \textcolor{keyword}{  }\{
00146     \textcolor{keywordflow}{return} m\_buffer[index];
00147   \}
00148 
00149   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00150   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00151 \textcolor{keyword}{  }\{
00152     \textcolor{keywordflow}{return} internal::ploadt<PacketReturnType, LoadMode>(m\_buffer + index);
00153   \}
00154 
00155   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorOpCost costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00156     \textcolor{comment}{// We assume that evalPacket or evalScalar is called to perform the}
00157     \textcolor{comment}{// assignment and account for the cost of the write here.}
00158     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) +
00159         TensorOpCost(0, \textcolor{keyword}{sizeof}(CoeffReturnType), 0, vectorized, PacketSize);
00160   \}
00161 
00162   EIGEN\_DEVICE\_FUNC DevicePointer data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_buffer; \}
00163   ArgType expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_expression; \}
00164 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_eval_to_8h_source_l00166}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_eval_to_op_3_01_arg_type_00_01_make_pointer___01_4_00_01_device_01_4_a29fc7dbf9a2957f1e2ece1b2bdf33159}{00166}   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>}& \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_eval_to_op_3_01_arg_type_00_01_make_pointer___01_4_00_01_device_01_4_a29fc7dbf9a2957f1e2ece1b2bdf33159}{impl}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_impl;
       \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_eval_to_8h_source_l00168}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_eval_to_op_3_01_arg_type_00_01_make_pointer___01_4_00_01_device_01_4_a6a4c3f1f7993a251f2bd46b9c4498e2f}{00168}   \textcolor{keyword}{const} Device& \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_eval_to_op_3_01_arg_type_00_01_make_pointer___01_4_00_01_device_01_4_a6a4c3f1f7993a251f2bd46b9c4498e2f}{device}()\textcolor{keyword}{ const}\{\textcolor{keywordflow}{return} m\_device;\}
00169 
00170  \textcolor{keyword}{private}:
00171   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} m\_impl;
00172   \textcolor{keyword}{const} Device& m\_device;
00173   DevicePointer m\_buffer;
00174   \textcolor{keyword}{const} XprType& m\_op;
00175   \textcolor{keyword}{const} ArgType m\_expression;
00176 \};
00177 
00178 
00179 \} \textcolor{comment}{// end namespace Eigen}
00180 
00181 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_EVAL\_TO\_H}
\end{DoxyCode}
