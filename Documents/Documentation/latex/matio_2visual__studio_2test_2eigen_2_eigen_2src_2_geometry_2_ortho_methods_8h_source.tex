\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_geometry_2_ortho_methods_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Geometry/\+Ortho\+Methods.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_geometry_2_ortho_methods_8h_source}\index{Ortho\+Methods.\+h@{Ortho\+Methods.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_ORTHOMETHODS\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_ORTHOMETHODS\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00015 
00027 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00028 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00029 \textcolor{preprocessor}{#ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00030 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{typename} MatrixBase<Derived>::template 
      cross\_product\_return\_type<OtherDerived>::type
00031 \textcolor{preprocessor}{#else}
00032 \textcolor{keyword}{inline} \textcolor{keyword}{typename} MatrixBase<Derived>::PlainObject
00033 \textcolor{preprocessor}{#endif}
00034 MatrixBase<Derived>::cross(\textcolor{keyword}{const} MatrixBase<OtherDerived>& other)\textcolor{keyword}{ const}
00035 \textcolor{keyword}{}\{
00036   EIGEN\_STATIC\_ASSERT\_VECTOR\_SPECIFIC\_SIZE(Derived,3)
00037   EIGEN\_STATIC\_ASSERT\_VECTOR\_SPECIFIC\_SIZE(OtherDerived,3)
00038 
00039   \textcolor{comment}{// Note that there is no need for an expression here since the compiler}
00040   \textcolor{comment}{// optimize such a small temporary very well (even within a complex expression)}
00041   typename \hyperlink{namespaceinternal}{internal}::nested\_eval<Derived,2>::type lhs(derived());
00042   typename \hyperlink{namespaceinternal}{internal}::nested\_eval<OtherDerived,2>::type rhs(other.derived());
00043   return typename cross\_product\_return\_type<OtherDerived>::type(
00044     numext::conj(lhs.coeff(1) * rhs.coeff(2) - lhs.coeff(2) * rhs.coeff(1)),
00045     numext::conj(lhs.coeff(2) * rhs.coeff(0) - lhs.coeff(0) * rhs.coeff(2)),
00046     numext::conj(lhs.coeff(0) * rhs.coeff(1) - lhs.coeff(1) * rhs.coeff(0))
00047   );
00048 \}
00049 
00050 namespace \hyperlink{namespaceinternal}{internal} \{
00051 
00052 \textcolor{keyword}{template}< \textcolor{keywordtype}{int} Arch,\textcolor{keyword}{typename} VectorLhs,\textcolor{keyword}{typename} VectorRhs,
00053           \textcolor{keyword}{typename} Scalar = \textcolor{keyword}{typename} VectorLhs::Scalar,
00054           \textcolor{keywordtype}{bool} Vectorizable = bool((VectorLhs::Flags&VectorRhs::Flags)&
      \hyperlink{group__flags_ga1a306a438e1ab074e8be59512e887b9f}{PacketAccessBit})>
00055 \textcolor{keyword}{struct }cross3\_impl \{
00056   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{typename} internal::plain\_matrix\_type<VectorLhs>::type
00057   run(\textcolor{keyword}{const} VectorLhs& lhs, \textcolor{keyword}{const} VectorRhs& rhs)
00058   \{
00059     \textcolor{keywordflow}{return} \textcolor{keyword}{typename} internal::plain\_matrix\_type<VectorLhs>::type(
00060       numext::conj(lhs.coeff(1) * rhs.coeff(2) - lhs.coeff(2) * rhs.coeff(1)),
00061       numext::conj(lhs.coeff(2) * rhs.coeff(0) - lhs.coeff(0) * rhs.coeff(2)),
00062       numext::conj(lhs.coeff(0) * rhs.coeff(1) - lhs.coeff(1) * rhs.coeff(0)),
00063       0
00064     );
00065   \}
00066 \};
00067 
00068 \}
00069 
00079 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00080 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00081 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{typename} MatrixBase<Derived>::PlainObject
00082 \hyperlink{group___geometry___module_gaf10988c8393785423ae68a5afdf83226}{MatrixBase<Derived>::cross3}(\textcolor{keyword}{const} MatrixBase<OtherDerived>& other)\textcolor{keyword}{ const}
00083 \textcolor{keyword}{}\{
00084   EIGEN\_STATIC\_ASSERT\_VECTOR\_SPECIFIC\_SIZE(Derived,4)
00085   EIGEN\_STATIC\_ASSERT\_VECTOR\_SPECIFIC\_SIZE(OtherDerived,4)
00086 
00087   typedef typename internal::nested\_eval<Derived,2>::type DerivedNested;
00088   typedef typename internal::nested\_eval<OtherDerived,2>::type OtherDerivedNested;
00089   DerivedNested lhs(derived());
00090   OtherDerivedNested rhs(other.derived());
00091 
00092   return internal::cross3\_impl<Architecture::Target,
00093                         typename internal::remove\_all<DerivedNested>::type,
00094                         typename internal::remove\_all<OtherDerivedNested>::type>::run(lhs,rhs);
00095 \}
00096 
00106 template<typename ExpressionType, \textcolor{keywordtype}{int} Direction>
00107 template<typename OtherDerived>
00108 EIGEN\_DEVICE\_FUNC 
00109 const typename VectorwiseOp<ExpressionType,Direction>::CrossReturnType
00110 VectorwiseOp<ExpressionType,Direction>::cross(const MatrixBase<OtherDerived>& other)\textcolor{keyword}{ const}
00111 \textcolor{keyword}{}\{
00112   EIGEN\_STATIC\_ASSERT\_VECTOR\_SPECIFIC\_SIZE(OtherDerived,3)
00113   EIGEN\_STATIC\_ASSERT((internal::is\_same<Scalar, typename OtherDerived::Scalar>::value),
00114     
      YOU\_MIXED\_DIFFERENT\_NUMERIC\_TYPES\_\_YOU\_NEED\_TO\_USE\_THE\_CAST\_METHOD\_OF\_MATRIXBASE\_TO\_CAST\_NUMERIC\_TYPES\_EXPLICITLY)
00115   
00116   typename internal::nested\_eval<ExpressionType,2>::type mat(\_expression());
00117   typename internal::nested\_eval<OtherDerived,2>::type vec(other.derived());
00118 
00119   CrossReturnType res(\_expression().rows(),\_expression().cols());
00120   if(Direction==\hyperlink{group__enums_ggad49a7b3738e273eb00932271b36127f7addca718e0564723df21d61b94b1198be}{Vertical})
00121   \{
00122     eigen\_assert(CrossReturnType::RowsAtCompileTime==3 && \textcolor{stringliteral}{"the matrix must have exactly 3 rows"});
00123     res.row(0) = (mat.row(1) * vec.coeff(2) - mat.row(2) * vec.coeff(1)).conjugate();
00124     res.row(1) = (mat.row(2) * vec.coeff(0) - mat.row(0) * vec.coeff(2)).conjugate();
00125     res.row(2) = (mat.row(0) * vec.coeff(1) - mat.row(1) * vec.coeff(0)).conjugate();
00126   \}
00127   \textcolor{keywordflow}{else}
00128   \{
00129     eigen\_assert(CrossReturnType::ColsAtCompileTime==3 && \textcolor{stringliteral}{"the matrix must have exactly 3 columns"});
00130     res.col(0) = (mat.col(1) * vec.coeff(2) - mat.col(2) * vec.coeff(1)).conjugate();
00131     res.col(1) = (mat.col(2) * vec.coeff(0) - mat.col(0) * vec.coeff(2)).conjugate();
00132     res.col(2) = (mat.col(0) * vec.coeff(1) - mat.col(1) * vec.coeff(0)).conjugate();
00133   \}
00134   \textcolor{keywordflow}{return} res;
00135 \}
00136 
00137 \textcolor{keyword}{namespace }internal \{
00138 
00139 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keywordtype}{int} Size = Derived::SizeAtCompileTime>
00140 \textcolor{keyword}{struct }unitOrthogonal\_selector
00141 \{
00142   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} plain\_matrix\_type<Derived>::type \hyperlink{struct_vector_type}{VectorType};
00143   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<Derived>::Scalar Scalar;
00144   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar;
00145   \textcolor{keyword}{typedef} Matrix<Scalar,2,1> Vector2;
00146   EIGEN\_DEVICE\_FUNC
00147   \textcolor{keyword}{static} \textcolor{keyword}{inline} VectorType run(\textcolor{keyword}{const} Derived& src)
00148   \{
00149     VectorType perp = VectorType::Zero(src.size());
00150     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} maxi = 0;
00151     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} sndi = 0;
00152     src.cwiseAbs().maxCoeff(&maxi);
00153     \textcolor{keywordflow}{if} (maxi==0)
00154       sndi = 1;
00155     RealScalar invnm = RealScalar(1)/(Vector2() << src.coeff(sndi),src.coeff(maxi)).finished().norm();
00156     perp.coeffRef(maxi) = -numext::conj(src.coeff(sndi)) * invnm;
00157     perp.coeffRef(sndi) =  numext::conj(src.coeff(maxi)) * invnm;
00158 
00159     \textcolor{keywordflow}{return} perp;
00160    \}
00161 \};
00162 
00163 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00164 \textcolor{keyword}{struct }unitOrthogonal\_selector<Derived,3>
00165 \{
00166   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} plain\_matrix\_type<Derived>::type VectorType;
00167   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<Derived>::Scalar Scalar;
00168   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar;
00169   EIGEN\_DEVICE\_FUNC
00170   \textcolor{keyword}{static} \textcolor{keyword}{inline} VectorType run(\textcolor{keyword}{const} Derived& src)
00171   \{
00172     VectorType perp;
00173     \textcolor{comment}{/* Let us compute the crossed product of *this with a vector}
00174 \textcolor{comment}{     * that is not too close to being colinear to *this.}
00175 \textcolor{comment}{     */}
00176 
00177     \textcolor{comment}{/* unless the x and y coords are both close to zero, we can}
00178 \textcolor{comment}{     * simply take ( -y, x, 0 ) and normalize it.}
00179 \textcolor{comment}{     */}
00180     \textcolor{keywordflow}{if}((!isMuchSmallerThan(src.x(), src.z()))
00181     || (!isMuchSmallerThan(src.y(), src.z())))
00182     \{
00183       RealScalar invnm = RealScalar(1)/src.template head<2>().norm();
00184       perp.coeffRef(0) = -numext::conj(src.y())*invnm;
00185       perp.coeffRef(1) = numext::conj(src.x())*invnm;
00186       perp.coeffRef(2) = 0;
00187     \}
00188     \textcolor{comment}{/* if both x and y are close to zero, then the vector is close}
00189 \textcolor{comment}{     * to the z-axis, so it's far from colinear to the x-axis for instance.}
00190 \textcolor{comment}{     * So we take the crossed product with (1,0,0) and normalize it.}
00191 \textcolor{comment}{     */}
00192     \textcolor{keywordflow}{else}
00193     \{
00194       RealScalar invnm = RealScalar(1)/src.template tail<2>().norm();
00195       perp.coeffRef(0) = 0;
00196       perp.coeffRef(1) = -numext::conj(src.z())*invnm;
00197       perp.coeffRef(2) = numext::conj(src.y())*invnm;
00198     \}
00199 
00200     \textcolor{keywordflow}{return} perp;
00201    \}
00202 \};
00203 
00204 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00205 \textcolor{keyword}{struct }unitOrthogonal\_selector<Derived,2>
00206 \{
00207   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} plain\_matrix\_type<Derived>::type VectorType;
00208   EIGEN\_DEVICE\_FUNC
00209   \textcolor{keyword}{static} \textcolor{keyword}{inline} VectorType run(\textcolor{keyword}{const} Derived& src)
00210   \{ \textcolor{keywordflow}{return} VectorType(-numext::conj(src.y()), numext::conj(src.x())).normalized(); \}
00211 \};
00212 
00213 \} \textcolor{comment}{// end namespace internal}
00214 
00224 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00225 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{typename} MatrixBase<Derived>::PlainObject
00226 \hyperlink{group___geometry___module_ga2fd7a02d7bc4c339f0e97f12c09acb25}{MatrixBase<Derived>::unitOrthogonal}()\textcolor{keyword}{ const}
00227 \textcolor{keyword}{}\{
00228   EIGEN\_STATIC\_ASSERT\_VECTOR\_ONLY(Derived)
00229   \textcolor{keywordflow}{return} internal::unitOrthogonal\_selector<Derived>::run(derived());
00230 \}
00231 
00232 \} \textcolor{comment}{// end namespace Eigen}
00233 
00234 \textcolor{preprocessor}{#endif // EIGEN\_ORTHOMETHODS\_H}
\end{DoxyCode}
