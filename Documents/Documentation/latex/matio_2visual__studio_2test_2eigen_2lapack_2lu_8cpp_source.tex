\hypertarget{matio_2visual__studio_2test_2eigen_2lapack_2lu_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/lapack/lu.cpp}
\label{matio_2visual__studio_2test_2eigen_2lapack_2lu_8cpp_source}\index{lu.\+cpp@{lu.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2010-2011 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "common.h"}
00011 \textcolor{preprocessor}{#include <Eigen/LU>}
00012 
00013 \textcolor{comment}{// computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges}
00014 EIGEN\_LAPACK\_FUNC(getrf,(\textcolor{keywordtype}{int} *m, \textcolor{keywordtype}{int} *n, RealScalar *pa, \textcolor{keywordtype}{int} *lda, \textcolor{keywordtype}{int} *ipiv, \textcolor{keywordtype}{int} *info))
00015 \{
00016   *info = 0;
00017         \textcolor{keywordflow}{if}(*m<0)                  *info = -1;
00018   \textcolor{keywordflow}{else}  \textcolor{keywordflow}{if}(*n<0)                  *info = -2;
00019   \textcolor{keywordflow}{else}  \textcolor{keywordflow}{if}(*lda<std::max(1,*m))   *info = -4;
00020   \textcolor{keywordflow}{if}(*info!=0)
00021   \{
00022     \textcolor{keywordtype}{int} e = -*info;
00023     \textcolor{keywordflow}{return} xerbla\_(SCALAR\_SUFFIX\_UP\textcolor{stringliteral}{"GETRF"}, &e, 6);
00024   \}
00025 
00026   \textcolor{keywordflow}{if}(*m==0 || *n==0)
00027     \textcolor{keywordflow}{return} 0;
00028 
00029   Scalar* a = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(pa);
00030   \textcolor{keywordtype}{int} nb\_transpositions;
00031   \textcolor{keywordtype}{int} ret = int(\hyperlink{struct_eigen_1_1internal_1_1partial__lu__impl}{Eigen::internal::partial\_lu\_impl<Scalar,ColMajor,int>}
00032                      ::blocked\_lu(*m, *n, a, *lda, ipiv, nb\_transpositions));
00033 
00034   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<std::min(*m,*n); ++i)
00035     ipiv[i]++;
00036 
00037   \textcolor{keywordflow}{if}(ret>=0)
00038     *info = ret+1;
00039 
00040   \textcolor{keywordflow}{return} 0;
00041 \}
00042 
00043 \textcolor{comment}{//GETRS solves a system of linear equations}
00044 \textcolor{comment}{//    A * X = B  or  A' * X = B}
00045 \textcolor{comment}{//  with a general N-by-N matrix A using the LU factorization computed  by GETRF}
00046 EIGEN\_LAPACK\_FUNC(getrs,(\textcolor{keywordtype}{char} *trans, \textcolor{keywordtype}{int} *n, \textcolor{keywordtype}{int} *nrhs, RealScalar *pa, \textcolor{keywordtype}{int} *lda, \textcolor{keywordtype}{int} *ipiv, RealScalar *
      pb, \textcolor{keywordtype}{int} *ldb, \textcolor{keywordtype}{int} *info))
00047 \{
00048   *info = 0;
00049         \textcolor{keywordflow}{if}(OP(*trans)==INVALID)  *info = -1;
00050   \textcolor{keywordflow}{else}  \textcolor{keywordflow}{if}(*n<0)                 *info = -2;
00051   \textcolor{keywordflow}{else}  \textcolor{keywordflow}{if}(*nrhs<0)              *info = -3;
00052   \textcolor{keywordflow}{else}  \textcolor{keywordflow}{if}(*lda<std::max(1,*n))  *info = -5;
00053   \textcolor{keywordflow}{else}  \textcolor{keywordflow}{if}(*ldb<std::max(1,*n))  *info = -8;
00054   \textcolor{keywordflow}{if}(*info!=0)
00055   \{
00056     \textcolor{keywordtype}{int} e = -*info;
00057     \textcolor{keywordflow}{return} xerbla\_(SCALAR\_SUFFIX\_UP\textcolor{stringliteral}{"GETRS"}, &e, 6);
00058   \}
00059 
00060   Scalar* a = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(pa);
00061   Scalar* b = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(pb);
00062   MatrixType lu(a,*n,*n,*lda);
00063   MatrixType B(b,*n,*nrhs,*ldb);
00064 
00065   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<*n; ++i)
00066     ipiv[i]--;
00067   \textcolor{keywordflow}{if}(OP(*trans)==NOTR)
00068   \{
00069     B = \hyperlink{group___core___module_class_eigen_1_1_map}{PivotsType}(ipiv,*n) * B;
00070     lu.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda8155cfdfde9e75e7144dff0393d17181}{UnitLower}>().solveInPlace(B);
00071     lu.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>().solveInPlace(B);
00072   \}
00073   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(OP(*trans)==TR)
00074   \{
00075     lu.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>().transpose().solveInPlace(B);
00076     lu.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda8155cfdfde9e75e7144dff0393d17181}{UnitLower}>().transpose().solveInPlace(B);
00077     B = \hyperlink{group___core___module_class_eigen_1_1_map}{PivotsType}(ipiv,*n).transpose() * B;
00078   \}
00079   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(OP(*trans)==ADJ)
00080   \{
00081     lu.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}>().adjoint().solveInPlace(B);
00082     lu.triangularView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda8155cfdfde9e75e7144dff0393d17181}{UnitLower}>().adjoint().solveInPlace(B);
00083     B = \hyperlink{group___core___module_class_eigen_1_1_map}{PivotsType}(ipiv,*n).transpose() * B;
00084   \}
00085   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<*n; ++i)
00086     ipiv[i]++;
00087 
00088   \textcolor{keywordflow}{return} 0;
00089 \}
\end{DoxyCode}
