\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_condition_estimator_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/\+Condition\+Estimator.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_condition_estimator_8h_source}\index{Condition\+Estimator.\+h@{Condition\+Estimator.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2016 Rasmus Munk Larsen (rmlarsen@google.com)}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CONDITIONESTIMATOR\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CONDITIONESTIMATOR\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Vector, \textcolor{keyword}{typename} RealVector, \textcolor{keywordtype}{bool} IsComplex>
00018 \textcolor{keyword}{struct }rcond\_compute\_sign \{
00019   \textcolor{keyword}{static} \textcolor{keyword}{inline} Vector run(\textcolor{keyword}{const} Vector& v) \{
00020     \textcolor{keyword}{const} RealVector v\_abs = v.cwiseAbs();
00021     \textcolor{keywordflow}{return} (v\_abs.array() == \textcolor{keyword}{static\_cast<}typename Vector::RealScalar\textcolor{keyword}{>}(0))
00022             .select(Vector::Ones(v.size()), v.cwiseQuotient(v\_abs));
00023   \}
00024 \};
00025 
00026 \textcolor{comment}{// Partial specialization to avoid elementwise division for real vectors.}
00027 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Vector>
00028 \textcolor{keyword}{struct }rcond\_compute\_sign<Vector, Vector, false> \{
00029   \textcolor{keyword}{static} \textcolor{keyword}{inline} Vector run(\textcolor{keyword}{const} Vector& v) \{
00030     \textcolor{keywordflow}{return} (v.array() < \textcolor{keyword}{static\_cast<}typename Vector::RealScalar\textcolor{keyword}{>}(0))
00031            .select(-Vector::Ones(v.size()), Vector::Ones(v.size()));
00032   \}
00033 \};
00034 
00055 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Decomposition>
00056 \textcolor{keyword}{typename} Decomposition::RealScalar \hyperlink{namespace_eigen_1_1internal_aa3f5b3cfa34df750994a247d4823aa51}{rcond\_invmatrix\_L1\_norm\_estimate}(\textcolor{keyword}{const} 
      Decomposition& dec)
00057 \{
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Decomposition::MatrixType MatrixType;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Decomposition::Scalar Scalar;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Decomposition::RealScalar RealScalar;
00061   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_col\_type<MatrixType>::type Vector;
00062   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_col\_type<MatrixType, RealScalar>::type RealVector;
00063   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_complex = (NumTraits<Scalar>::IsComplex != 0);
00064 
00065   eigen\_assert(dec.rows() == dec.cols());
00066   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = dec.rows();
00067   \textcolor{keywordflow}{if} (n == 0)
00068     \textcolor{keywordflow}{return} 0;
00069 
00070   \textcolor{comment}{// Disable Index to float conversion warning}
00071 \textcolor{preprocessor}{#ifdef \_\_INTEL\_COMPILER}
00072 \textcolor{preprocessor}{  #pragma warning push}
00073 \textcolor{preprocessor}{  #pragma warning ( disable : 2259 )}
00074 \textcolor{preprocessor}{#endif}
00075   Vector v = dec.solve(Vector::Ones(n) / Scalar(n));
00076 \textcolor{preprocessor}{#ifdef \_\_INTEL\_COMPILER}
00077 \textcolor{preprocessor}{  #pragma warning pop}
00078 \textcolor{preprocessor}{#endif}
00079 
00080   \textcolor{comment}{// lower\_bound is a lower bound on}
00081   \textcolor{comment}{//   ||inv(matrix)||\_1  = sup\_v ||inv(matrix) v||\_1 / ||v||\_1}
00082   \textcolor{comment}{// and is the objective maximized by the ("super-") gradient ascent}
00083   \textcolor{comment}{// algorithm below.}
00084   RealScalar lower\_bound = v.template lpNorm<1>();
00085   \textcolor{keywordflow}{if} (n == 1)
00086     \textcolor{keywordflow}{return} lower\_bound;
00087 
00088   \textcolor{comment}{// Gradient ascent algorithm follows: We know that the optimum is achieved at}
00089   \textcolor{comment}{// one of the simplices v = e\_i, so in each iteration we follow a}
00090   \textcolor{comment}{// super-gradient to move towards the optimal one.}
00091   RealScalar old\_lower\_bound = lower\_bound;
00092   Vector sign\_vector(n);
00093   Vector old\_sign\_vector;
00094   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} v\_max\_abs\_index = -1;
00095   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} old\_v\_max\_abs\_index = v\_max\_abs\_index;
00096   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 0; k < 4; ++k)
00097   \{
00098     sign\_vector = internal::rcond\_compute\_sign<Vector, RealVector, is\_complex>::run(v);
00099     \textcolor{keywordflow}{if} (k > 0 && !is\_complex && sign\_vector == old\_sign\_vector) \{
00100       \textcolor{comment}{// Break if the solution stagnated.}
00101       \textcolor{keywordflow}{break};
00102     \}
00103     \textcolor{comment}{// v\_max\_abs\_index = argmax |real( inv(matrix)^T * sign\_vector )|}
00104     v = dec.adjoint().solve(sign\_vector);
00105     v.real().cwiseAbs().maxCoeff(&v\_max\_abs\_index);
00106     \textcolor{keywordflow}{if} (v\_max\_abs\_index == old\_v\_max\_abs\_index) \{
00107       \textcolor{comment}{// Break if the solution stagnated.}
00108       \textcolor{keywordflow}{break};
00109     \}
00110     \textcolor{comment}{// Move to the new simplex e\_j, where j = v\_max\_abs\_index.}
00111     v = dec.solve(Vector::Unit(n, v\_max\_abs\_index));  \textcolor{comment}{// v = inv(matrix) * e\_j.}
00112     lower\_bound = v.template lpNorm<1>();
00113     \textcolor{keywordflow}{if} (lower\_bound <= old\_lower\_bound) \{
00114       \textcolor{comment}{// Break if the gradient step did not increase the lower\_bound.}
00115       \textcolor{keywordflow}{break};
00116     \}
00117     \textcolor{keywordflow}{if} (!is\_complex) \{
00118       old\_sign\_vector = sign\_vector;
00119     \}
00120     old\_v\_max\_abs\_index = v\_max\_abs\_index;
00121     old\_lower\_bound = lower\_bound;
00122   \}
00123   \textcolor{comment}{// The following calculates an independent estimate of ||matrix||\_1 by}
00124   \textcolor{comment}{// multiplying matrix by a vector with entries of slowly increasing}
00125   \textcolor{comment}{// magnitude and alternating sign:}
00126   \textcolor{comment}{//   v\_i = (-1)^\{i\} (1 + (i / (dim-1))), i = 0,...,dim-1.}
00127   \textcolor{comment}{// This improvement to Hager's algorithm above is due to Higham. It was}
00128   \textcolor{comment}{// added to make the algorithm more robust in certain corner cases where}
00129   \textcolor{comment}{// large elements in the matrix might otherwise escape detection due to}
00130   \textcolor{comment}{// exact cancellation (especially when op and op\_adjoint correspond to a}
00131   \textcolor{comment}{// sequence of backsubstitutions and permutations), which could cause}
00132   \textcolor{comment}{// Hager's algorithm to vastly underestimate ||matrix||\_1.}
00133   Scalar alternating\_sign(RealScalar(1));
00134   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < n; ++i) \{
00135     \textcolor{comment}{// The static\_cast is needed when Scalar is a complex and RealScalar implements expression templates}
00136     v[i] = alternating\_sign * \textcolor{keyword}{static\_cast<}RealScalar\textcolor{keyword}{>}(RealScalar(1) + (RealScalar(i) / (RealScalar(n - 1)))
      );
00137     alternating\_sign = -alternating\_sign;
00138   \}
00139   v = dec.solve(v);
00140   \textcolor{keyword}{const} RealScalar alternate\_lower\_bound = (2 * v.template lpNorm<1>()) / (3 * RealScalar(n));
00141   \textcolor{keywordflow}{return} numext::maxi(lower\_bound, alternate\_lower\_bound);
00142 \}
00143 
00157 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Decomposition>
00158 \textcolor{keyword}{typename} Decomposition::RealScalar
00159 \hyperlink{namespace_eigen_1_1internal_ad1de0d785387bfb5435c410bf0554068}{rcond\_estimate\_helper}(\textcolor{keyword}{typename} Decomposition::RealScalar matrix\_norm, \textcolor{keyword}{const} 
      Decomposition& dec)
00160 \{
00161   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Decomposition::RealScalar RealScalar;
00162   eigen\_assert(dec.rows() == dec.cols());
00163   \textcolor{keywordflow}{if} (dec.rows() == 0)              \textcolor{keywordflow}{return} RealScalar(1);
00164   \textcolor{keywordflow}{if} (matrix\_norm == RealScalar(0)) \textcolor{keywordflow}{return} RealScalar(0);
00165   \textcolor{keywordflow}{if} (dec.rows() == 1)              \textcolor{keywordflow}{return} RealScalar(1);
00166   \textcolor{keyword}{const} RealScalar inverse\_matrix\_norm = \hyperlink{namespace_eigen_1_1internal_aa3f5b3cfa34df750994a247d4823aa51}{rcond\_invmatrix\_L1\_norm\_estimate}(
      dec);
00167   \textcolor{keywordflow}{return} (inverse\_matrix\_norm == RealScalar(0) ? RealScalar(0)
00168                                                : (RealScalar(1) / inverse\_matrix\_norm) / matrix\_norm);
00169 \}
00170 
00171 \}  \textcolor{comment}{// namespace internal}
00172 
00173 \}  \textcolor{comment}{// namespace Eigen}
00174 
00175 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
