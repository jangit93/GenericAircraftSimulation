\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_packet_math_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_packet_math_8h_source}\index{Packet\+Math.\+h@{Packet\+Math.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_PACKET\_MATH\_SSE\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_PACKET\_MATH\_SSE\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{preprocessor}{#ifndef EIGEN\_CACHEFRIENDLY\_PRODUCT\_THRESHOLD}
00018 \textcolor{preprocessor}{#define EIGEN\_CACHEFRIENDLY\_PRODUCT\_THRESHOLD 8}
00019 \textcolor{preprocessor}{#endif}
00020 
00021 \textcolor{preprocessor}{#ifndef EIGEN\_ARCH\_DEFAULT\_NUMBER\_OF\_REGISTERS}
00022 \textcolor{preprocessor}{#define EIGEN\_ARCH\_DEFAULT\_NUMBER\_OF\_REGISTERS (2*sizeof(void*))}
00023 \textcolor{preprocessor}{#endif}
00024 
00025 \textcolor{preprocessor}{#ifdef \_\_FMA\_\_}
00026 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD}
00027 \textcolor{preprocessor}{#define EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD 1}
00028 \textcolor{preprocessor}{#endif}
00029 \textcolor{preprocessor}{#endif}
00030 
00031 \textcolor{preprocessor}{#if (defined EIGEN\_VECTORIZE\_AVX) && (EIGEN\_COMP\_GNUC\_STRICT || EIGEN\_COMP\_MINGW) && (\_\_GXX\_ABI\_VERSION <
       1004)}
00032 \textcolor{comment}{// With GCC's default ABI version, a \_\_m128 or \_\_m256 are the same types and therefore we cannot}
00033 \textcolor{comment}{// have overloads for both types without linking error.}
00034 \textcolor{comment}{// One solution is to increase ABI version using -fabi-version=4 (or greater).}
00035 \textcolor{comment}{// Otherwise, we workaround this inconvenience by wrapping 128bit types into the following helper}
00036 \textcolor{comment}{// structure:}
00037 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00038 \textcolor{keyword}{struct }eigen\_packet\_wrapper
00039 \{
00040   EIGEN\_ALWAYS\_INLINE \textcolor{keyword}{operator} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&() \{ \textcolor{keywordflow}{return} m\_val; \}
00041   EIGEN\_ALWAYS\_INLINE \textcolor{keyword}{operator} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&() \textcolor{keyword}{const} \{ \textcolor{keywordflow}{return} m\_val; \}
00042   EIGEN\_ALWAYS\_INLINE eigen\_packet\_wrapper() \{\}
00043   EIGEN\_ALWAYS\_INLINE eigen\_packet\_wrapper(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} &v) : m\_val(v) \{\}
00044   EIGEN\_ALWAYS\_INLINE eigen\_packet\_wrapper& operator=(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} &v) \{
00045     m\_val = v;
00046     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00047   \}
00048   
00049   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} m\_val;
00050 \};
00051 \textcolor{keyword}{typedef} eigen\_packet\_wrapper<\_\_m128>  Packet4f;
00052 \textcolor{keyword}{typedef} eigen\_packet\_wrapper<\_\_m128i> Packet4i;
00053 \textcolor{keyword}{typedef} eigen\_packet\_wrapper<\_\_m128d> Packet2d;
00054 \textcolor{preprocessor}{#else}
00055 \textcolor{keyword}{typedef} \_\_m128  Packet4f;
00056 \textcolor{keyword}{typedef} \_\_m128i Packet4i;
00057 \textcolor{keyword}{typedef} \_\_m128d Packet2d;
00058 \textcolor{preprocessor}{#endif}
00059 
00060 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<\_\_m128>  \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00061 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<\_\_m128i> \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00062 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<\_\_m128d> \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00063 
00064 \textcolor{preprocessor}{#define vec4f\_swizzle1(v,p,q,r,s) \(\backslash\)}
00065 \textcolor{preprocessor}{  (\_mm\_castsi128\_ps(\_mm\_shuffle\_epi32( \_mm\_castps\_si128(v), ((s)<<6|(r)<<4|(q)<<2|(p)))))}
00066 
00067 \textcolor{preprocessor}{#define vec4i\_swizzle1(v,p,q,r,s) \(\backslash\)}
00068 \textcolor{preprocessor}{  (\_mm\_shuffle\_epi32( v, ((s)<<6|(r)<<4|(q)<<2|(p))))}
00069 
00070 \textcolor{preprocessor}{#define vec2d\_swizzle1(v,p,q) \(\backslash\)}
00071 \textcolor{preprocessor}{  (\_mm\_castsi128\_pd(\_mm\_shuffle\_epi32( \_mm\_castpd\_si128(v), ((q*2+1)<<6|(q*2)<<4|(p*2+1)<<2|(p*2)))))}
00072   
00073 \textcolor{preprocessor}{#define vec4f\_swizzle2(a,b,p,q,r,s) \(\backslash\)}
00074 \textcolor{preprocessor}{  (\_mm\_shuffle\_ps( (a), (b), ((s)<<6|(r)<<4|(q)<<2|(p))))}
00075 
00076 \textcolor{preprocessor}{#define vec4i\_swizzle2(a,b,p,q,r,s) \(\backslash\)}
00077 \textcolor{preprocessor}{  (\_mm\_castps\_si128( (\_mm\_shuffle\_ps( \_mm\_castsi128\_ps(a), \_mm\_castsi128\_ps(b),
       ((s)<<6|(r)<<4|(q)<<2|(p))))))}
00078 
00079 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet4f(NAME,X) \(\backslash\)}
00080 \textcolor{preprocessor}{  const Packet4f p4f\_##NAME = pset1<Packet4f>(X)}
00081 
00082 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet2d(NAME,X) \(\backslash\)}
00083 \textcolor{preprocessor}{  const Packet2d p2d\_##NAME = pset1<Packet2d>(X)}
00084 
00085 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(NAME,X) \(\backslash\)}
00086 \textcolor{preprocessor}{  const Packet4f p4f\_##NAME = \_mm\_castsi128\_ps(pset1<Packet4i>(X))}
00087 
00088 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet4i(NAME,X) \(\backslash\)}
00089 \textcolor{preprocessor}{  const Packet4i p4i\_##NAME = pset1<Packet4i>(X)}
00090 
00091 
00092 \textcolor{comment}{// Use the packet\_traits defined in AVX/PacketMath.h instead if we're going}
00093 \textcolor{comment}{// to leverage AVX instructions.}
00094 \textcolor{preprocessor}{#ifndef EIGEN\_VECTORIZE\_AVX}
00095 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<float>  : default\_packet\_traits
00096 \{
00097   \textcolor{keyword}{typedef} Packet4f type;
00098   \textcolor{keyword}{typedef} Packet4f half;
00099   \textcolor{keyword}{enum} \{
00100     Vectorizable = 1,
00101     AlignedOnScalar = 1,
00102     size=4,
00103     HasHalfPacket = 0,
00104 
00105     HasDiv  = 1,
00106     HasSin  = EIGEN\_FAST\_MATH,
00107     HasCos  = EIGEN\_FAST\_MATH,
00108     HasLog  = 1,
00109     HasExp  = 1,
00110     HasSqrt = 1,
00111     HasRsqrt = 1,
00112     HasTanh  = EIGEN\_FAST\_MATH,
00113     HasBlend = 1
00114 
00115 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00116     ,
00117     HasRound = 1,
00118     HasFloor = 1,
00119     HasCeil = 1
00120 \textcolor{preprocessor}{#endif}
00121   \};
00122 \};
00123 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<double> : default\_packet\_traits
00124 \{
00125   \textcolor{keyword}{typedef} Packet2d type;
00126   \textcolor{keyword}{typedef} Packet2d half;
00127   \textcolor{keyword}{enum} \{
00128     Vectorizable = 1,
00129     AlignedOnScalar = 1,
00130     size=2,
00131     HasHalfPacket = 0,
00132 
00133     HasDiv  = 1,
00134     HasExp  = 1,
00135     HasSqrt = 1,
00136     HasRsqrt = 1,
00137     HasBlend = 1
00138 
00139 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00140     ,
00141     HasRound = 1,
00142     HasFloor = 1,
00143     HasCeil = 1
00144 \textcolor{preprocessor}{#endif}
00145   \};
00146 \};
00147 \textcolor{preprocessor}{#endif}
00148 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<int>    : default\_packet\_traits
00149 \{
00150   \textcolor{keyword}{typedef} Packet4i type;
00151   \textcolor{keyword}{typedef} Packet4i half;
00152   \textcolor{keyword}{enum} \{
00153     Vectorizable = 1,
00154     AlignedOnScalar = 1,
00155     size=4,
00156 
00157     HasBlend = 1
00158   \};
00159 \};
00160 
00161 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet4f> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{float}  type; \textcolor{keyword}{enum} \{size=4, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet4f half; \};
00162 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet2d> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{double} type; \textcolor{keyword}{enum} \{size=2, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet2d half; \};
00163 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet4i> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{int}    type; \textcolor{keyword}{enum} \{size=4, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet4i half; \};
00164 
00165 \textcolor{preprocessor}{#ifndef EIGEN\_VECTORIZE\_AVX}
00166 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }scalar\_div\_cost<float,true> \{ \textcolor{keyword}{enum} \{ value = 7 \}; \};
00167 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }scalar\_div\_cost<double,true> \{ \textcolor{keyword}{enum} \{ value = 8 \}; \};
00168 \textcolor{preprocessor}{#endif}
00169 
00170 \textcolor{preprocessor}{#if EIGEN\_COMP\_MSVC==1500}
00171 \textcolor{comment}{// Workaround MSVC 9 internal compiler error.}
00172 \textcolor{comment}{// TODO: It has been detected with win64 builds (amd64), so let's check whether it also happens in
       32bits+SSE mode}
00173 \textcolor{comment}{// TODO: let's check whether there does not exist a better fix, like adding a pset0() function. (it crashed
       on pset1(0)).}
00174 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pset1<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}&  from) \{ \textcolor{keywordflow}{return} \_mm\_set\_ps(from,from,
      from,from); \}
00175 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pset1<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& from) \{ \textcolor{keywordflow}{return} \_mm\_set\_pd(from,from);
       \}
00176 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pset1<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}&    from) \{ \textcolor{keywordflow}{return} \_mm\_set\_epi32(from,
      from,from,from); \}
00177 \textcolor{preprocessor}{#else}
00178 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pset1<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}&  from) \{ \textcolor{keywordflow}{return} \_mm\_set\_ps1(from); \}
00179 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pset1<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& from) \{ \textcolor{keywordflow}{return} \_mm\_set1\_pd(from); \}
00180 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pset1<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}&    from) \{ \textcolor{keywordflow}{return} \_mm\_set1\_epi32(from); 
      \}
00181 \textcolor{preprocessor}{#endif}
00182 
00183 \textcolor{comment}{// GCC generates a shufps instruction for \_mm\_set1\_ps/\_mm\_load1\_ps instead of the more efficient pshufd
       instruction.}
00184 \textcolor{comment}{// However, using inrinsics for pset1 makes gcc to generate crappy code in some cases (see bug 203)}
00185 \textcolor{comment}{// Using inline assembly is also not an option because then gcc fails to reorder properly the instructions.}
00186 \textcolor{comment}{// Therefore, we introduced the pload1 functions to be used in product kernels for which bug 203 does not
       apply.}
00187 \textcolor{comment}{// Also note that with AVX, we want it to generate a vbroadcastss.}
00188 \textcolor{preprocessor}{#if EIGEN\_COMP\_GNUC\_STRICT && (!defined \_\_AVX\_\_)}
00189 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pload1<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float} *from) \{
00190   \textcolor{keywordflow}{return} vec4f\_swizzle1(\_mm\_load\_ss(from),0,0,0,0);
00191 \}
00192 \textcolor{preprocessor}{#endif}
00193   
00194 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f plset<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}& a) \{ \textcolor{keywordflow}{return} \_mm\_add\_ps(pset1<Packet4f>
      (a), \_mm\_set\_ps(3,2,1,0)); \}
00195 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d plset<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& a) \{ \textcolor{keywordflow}{return} \_mm\_add\_pd(
      pset1<Packet2d>(a),\_mm\_set\_pd(1,0)); \}
00196 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i plset<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}& a) \{ \textcolor{keywordflow}{return} \_mm\_add\_epi32(
      pset1<Packet4i>(a),\_mm\_set\_epi32(3,2,1,0)); \}
00197 
00198 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f padd<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_add\_ps(a,b); \}
00199 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d padd<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_add\_pd(a,b); \}
00200 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i padd<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_add\_epi32(a,b); \}
00201 
00202 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f psub<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_sub\_ps(a,b); \}
00203 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d psub<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_sub\_pd(a,b); \}
00204 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i psub<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_sub\_epi32(a,b); \}
00205 
00206 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pnegate(\textcolor{keyword}{const} Packet4f& a)
00207 \{
00208   \textcolor{keyword}{const} Packet4f mask = \_mm\_castsi128\_ps(\_mm\_setr\_epi32(0x80000000,0x80000000,0x80000000,0x80000000));
00209   \textcolor{keywordflow}{return} \_mm\_xor\_ps(a,mask);
00210 \}
00211 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pnegate(\textcolor{keyword}{const} Packet2d& a)
00212 \{
00213   \textcolor{keyword}{const} Packet2d mask = \_mm\_castsi128\_pd(\_mm\_setr\_epi32(0x0,0x80000000,0x0,0x80000000));
00214   \textcolor{keywordflow}{return} \_mm\_xor\_pd(a,mask);
00215 \}
00216 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pnegate(\textcolor{keyword}{const} Packet4i& a)
00217 \{
00218   \textcolor{keywordflow}{return} psub(Packet4i(\_mm\_setr\_epi32(0,0,0,0)), a);
00219 \}
00220 
00221 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pconj(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordflow}{return} a; \}
00222 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pconj(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} a; \}
00223 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pconj(\textcolor{keyword}{const} Packet4i& a) \{ \textcolor{keywordflow}{return} a; \}
00224 
00225 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pmul<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_mul\_ps(a,b); \}
00226 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pmul<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_mul\_pd(a,b); \}
00227 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pmul<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b)
00228 \{
00229 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00230   \textcolor{keywordflow}{return} \_mm\_mullo\_epi32(a,b);
00231 \textcolor{preprocessor}{#else}
00232   \textcolor{comment}{// this version is slightly faster than 4 scalar products}
00233   \textcolor{keywordflow}{return} vec4i\_swizzle1(
00234             vec4i\_swizzle2(
00235               \_mm\_mul\_epu32(a,b),
00236               \_mm\_mul\_epu32(vec4i\_swizzle1(a,1,0,3,2),
00237                             vec4i\_swizzle1(b,1,0,3,2)),
00238               0,2,0,2),
00239             0,2,1,3);
00240 \textcolor{preprocessor}{#endif}
00241 \}
00242 
00243 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pdiv<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_div\_ps(a,b); \}
00244 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pdiv<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_div\_pd(a,b); \}
00245 
00246 \textcolor{comment}{// for some weird raisons, it has to be overloaded for packet of integers}
00247 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pmadd(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b, \textcolor{keyword}{const} Packet4i& c) \{ \textcolor{keywordflow}{
      return} padd(pmul(a,b), c); \}
00248 \textcolor{preprocessor}{#ifdef \_\_FMA\_\_}
00249 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pmadd(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b, \textcolor{keyword}{const} Packet4f& c) \{ \textcolor{keywordflow}{
      return} \_mm\_fmadd\_ps(a,b,c); \}
00250 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pmadd(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b, \textcolor{keyword}{const} Packet2d& c) \{ \textcolor{keywordflow}{
      return} \_mm\_fmadd\_pd(a,b,c); \}
00251 \textcolor{preprocessor}{#endif}
00252 
00253 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pmin<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_min\_ps(a,b); \}
00254 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pmin<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_min\_pd(a,b); \}
00255 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pmin<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b)
00256 \{
00257 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00258   \textcolor{keywordflow}{return} \_mm\_min\_epi32(a,b);
00259 \textcolor{preprocessor}{#else}
00260   \textcolor{comment}{// after some bench, this version *is* faster than a scalar implementation}
00261   Packet4i mask = \_mm\_cmplt\_epi32(a,b);
00262   \textcolor{keywordflow}{return} \_mm\_or\_si128(\_mm\_and\_si128(mask,a),\_mm\_andnot\_si128(mask,b));
00263 \textcolor{preprocessor}{#endif}
00264 \}
00265 
00266 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pmax<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_max\_ps(a,b); \}
00267 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pmax<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_max\_pd(a,b); \}
00268 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pmax<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b)
00269 \{
00270 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00271   \textcolor{keywordflow}{return} \_mm\_max\_epi32(a,b);
00272 \textcolor{preprocessor}{#else}
00273   \textcolor{comment}{// after some bench, this version *is* faster than a scalar implementation}
00274   Packet4i mask = \_mm\_cmpgt\_epi32(a,b);
00275   \textcolor{keywordflow}{return} \_mm\_or\_si128(\_mm\_and\_si128(mask,a),\_mm\_andnot\_si128(mask,b));
00276 \textcolor{preprocessor}{#endif}
00277 \}
00278 
00279 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00280 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pround<Packet4f>(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordflow}{return} \_mm\_round\_ps(a, 0); \}
00281 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pround<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} \_mm\_round\_pd(a, 0); \}
00282 
00283 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pceil<Packet4f>(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordflow}{return} \_mm\_ceil\_ps(a); \}
00284 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pceil<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} \_mm\_ceil\_pd(a); \}
00285 
00286 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pfloor<Packet4f>(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordflow}{return} \_mm\_floor\_ps(a); \}
00287 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pfloor<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} \_mm\_floor\_pd(a); \}
00288 \textcolor{preprocessor}{#endif}
00289 
00290 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pand<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_and\_ps(a,b); \}
00291 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pand<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_and\_pd(a,b); \}
00292 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pand<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_and\_si128(a,b); \}
00293 
00294 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f por<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_or\_ps(a,b); \}
00295 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d por<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_or\_pd(a,b); \}
00296 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i por<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_or\_si128(a,b); \}
00297 
00298 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pxor<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_xor\_ps(a,b); \}
00299 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pxor<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_xor\_pd(a,b); \}
00300 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pxor<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_xor\_si128(a,b); \}
00301 
00302 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pandnot<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_andnot\_ps(a,b); \}
00303 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pandnot<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_andnot\_pd(a,b); \}
00304 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pandnot<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      \_mm\_andnot\_si128(a,b); \}
00305 
00306 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pload<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}*   from) \{ EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{
      return} \_mm\_load\_ps(from); \}
00307 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pload<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}*  from) \{ EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{
      return} \_mm\_load\_pd(from); \}
00308 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pload<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*     from) \{ EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{
      return} \_mm\_load\_si128(reinterpret\_cast<const \_\_m128i*>(from)); \}
00309 
00310 \textcolor{preprocessor}{#if EIGEN\_COMP\_MSVC}
00311   \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f ploadu<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}*  from) \{
00312     EIGEN\_DEBUG\_UNALIGNED\_LOAD
00313 \textcolor{preprocessor}{    #if (EIGEN\_COMP\_MSVC==1600)}
00314     \textcolor{comment}{// NOTE Some version of MSVC10 generates bad code when using \_mm\_loadu\_ps}
00315     \textcolor{comment}{// (i.e., it does not generate an unaligned load!!}
00316     \_\_m128 res = \_mm\_loadl\_pi(\_mm\_set1\_ps(0.0f), (\textcolor{keyword}{const} \_\_m64*)(from));
00317     res = \_mm\_loadh\_pi(res, (\textcolor{keyword}{const} \_\_m64*)(from+2));
00318     \textcolor{keywordflow}{return} res;
00319 \textcolor{preprocessor}{    #else}
00320     \textcolor{keywordflow}{return} \_mm\_loadu\_ps(from);
00321 \textcolor{preprocessor}{    #endif}
00322   \}
00323 \textcolor{preprocessor}{#else}
00324 \textcolor{comment}{// NOTE: with the code below, MSVC's compiler crashes!}
00325 
00326 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f ploadu<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}* from)
00327 \{
00328   EIGEN\_DEBUG\_UNALIGNED\_LOAD
00329   \textcolor{keywordflow}{return} \_mm\_loadu\_ps(from);
00330 \}
00331 \textcolor{preprocessor}{#endif}
00332 
00333 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d ploadu<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* from)
00334 \{
00335   EIGEN\_DEBUG\_UNALIGNED\_LOAD
00336   \textcolor{keywordflow}{return} \_mm\_loadu\_pd(from);
00337 \}
00338 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i ploadu<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}* from)
00339 \{
00340   EIGEN\_DEBUG\_UNALIGNED\_LOAD
00341   \textcolor{keywordflow}{return} \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i*>(from));
00342 \}
00343 
00344 
00345 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f ploaddup<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}*   from)
00346 \{
00347   \textcolor{keywordflow}{return} vec4f\_swizzle1(\_mm\_castpd\_ps(\_mm\_load\_sd(reinterpret\_cast<const double*>(from))), 0, 0, 1, 1);
00348 \}
00349 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d ploaddup<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}*  from)
00350 \{ \textcolor{keywordflow}{return} pset1<Packet2d>(from[0]); \}
00351 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i ploaddup<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*     from)
00352 \{
00353   Packet4i tmp;
00354   tmp = \_mm\_loadl\_epi64(reinterpret\_cast<const \_\_m128i*>(from));
00355   \textcolor{keywordflow}{return} vec4i\_swizzle1(tmp, 0, 0, 1, 1);
00356 \}
00357 
00358 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<float>(\textcolor{keywordtype}{float}*   to, \textcolor{keyword}{const} Packet4f& from) \{ 
      EIGEN\_DEBUG\_ALIGNED\_STORE \_mm\_store\_ps(to, from); \}
00359 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<double>(\textcolor{keywordtype}{double}* to, \textcolor{keyword}{const} Packet2d& from) \{ 
      EIGEN\_DEBUG\_ALIGNED\_STORE \_mm\_store\_pd(to, from); \}
00360 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<int>(\textcolor{keywordtype}{int}*       to, \textcolor{keyword}{const} Packet4i& from) \{ 
      EIGEN\_DEBUG\_ALIGNED\_STORE \_mm\_store\_si128(reinterpret\_cast<\_\_m128i*>(to), from); \}
00361 
00362 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<double>(\textcolor{keywordtype}{double}* to, \textcolor{keyword}{const} Packet2d& from) \{ 
      EIGEN\_DEBUG\_UNALIGNED\_STORE \_mm\_storeu\_pd(to, from); \}
00363 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<float>(\textcolor{keywordtype}{float}*   to, \textcolor{keyword}{const} Packet4f& from) \{ 
      EIGEN\_DEBUG\_UNALIGNED\_STORE \_mm\_storeu\_ps(to, from); \}
00364 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<int>(\textcolor{keywordtype}{int}*       to, \textcolor{keyword}{const} Packet4i& from) \{ 
      EIGEN\_DEBUG\_UNALIGNED\_STORE \_mm\_storeu\_si128(reinterpret\_cast<\_\_m128i*>(to), from); \}
00365 
00366 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet4f pgather<float, Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}* from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00367 \{
00368  \textcolor{keywordflow}{return} \_mm\_set\_ps(from[3*stride], from[2*stride], from[1*stride], from[0*stride]);
00369 \}
00370 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet2d pgather<double, Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00371 \{
00372  \textcolor{keywordflow}{return} \_mm\_set\_pd(from[1*stride], from[0*stride]);
00373 \}
00374 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet4i pgather<int, Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}* from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00375 \{
00376  \textcolor{keywordflow}{return} \_mm\_set\_epi32(from[3*stride], from[2*stride], from[1*stride], from[0*stride]);
00377  \}
00378 
00379 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<float, Packet4f>(\textcolor{keywordtype}{float}* to, \textcolor{keyword}{const} Packet4f& from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00380 \{
00381   to[stride*0] = \_mm\_cvtss\_f32(from);
00382   to[stride*1] = \_mm\_cvtss\_f32(\_mm\_shuffle\_ps(from, from, 1));
00383   to[stride*2] = \_mm\_cvtss\_f32(\_mm\_shuffle\_ps(from, from, 2));
00384   to[stride*3] = \_mm\_cvtss\_f32(\_mm\_shuffle\_ps(from, from, 3));
00385 \}
00386 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<double, Packet2d>(\textcolor{keywordtype}{double}* to, \textcolor{keyword}{const} Packet2d& from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00387 \{
00388   to[stride*0] = \_mm\_cvtsd\_f64(from);
00389   to[stride*1] = \_mm\_cvtsd\_f64(\_mm\_shuffle\_pd(from, from, 1));
00390 \}
00391 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<int, Packet4i>(\textcolor{keywordtype}{int}* to, \textcolor{keyword}{const} Packet4i& from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00392 \{
00393   to[stride*0] = \_mm\_cvtsi128\_si32(from);
00394   to[stride*1] = \_mm\_cvtsi128\_si32(\_mm\_shuffle\_epi32(from, 1));
00395   to[stride*2] = \_mm\_cvtsi128\_si32(\_mm\_shuffle\_epi32(from, 2));
00396   to[stride*3] = \_mm\_cvtsi128\_si32(\_mm\_shuffle\_epi32(from, 3));
00397 \}
00398 
00399 \textcolor{comment}{// some compilers might be tempted to perform multiple moves instead of using a vector path.}
00400 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore1<Packet4f>(\textcolor{keywordtype}{float}* to, \textcolor{keyword}{const} \textcolor{keywordtype}{float}& a)
00401 \{
00402   Packet4f pa = \_mm\_set\_ss(a);
00403   pstore(to, Packet4f(vec4f\_swizzle1(pa,0,0,0,0)));
00404 \}
00405 \textcolor{comment}{// some compilers might be tempted to perform multiple moves instead of using a vector path.}
00406 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore1<Packet2d>(\textcolor{keywordtype}{double}* to, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& a)
00407 \{
00408   Packet2d pa = \_mm\_set\_sd(a);
00409   pstore(to, Packet2d(vec2d\_swizzle1(pa,0,0)));
00410 \}
00411 
00412 \textcolor{preprocessor}{#ifndef EIGEN\_VECTORIZE\_AVX}
00413 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<float>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}*   addr) \{ \_mm\_prefetch((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)(addr)
      , \_MM\_HINT\_T0); \}
00414 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<double>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* addr) \{ \_mm\_prefetch((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)(addr)
      , \_MM\_HINT\_T0); \}
00415 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<int>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*       addr) \{ \_mm\_prefetch((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)(addr)
      , \_MM\_HINT\_T0); \}
00416 \textcolor{preprocessor}{#endif}
00417 
00418 \textcolor{preprocessor}{#if EIGEN\_COMP\_MSVC\_STRICT && EIGEN\_OS\_WIN64}
00419 \textcolor{comment}{// The temporary variable fixes an internal compilation error in vs <= 2008 and a wrong-result bug in vs
       2010}
00420 \textcolor{comment}{// Direct of the struct members fixed bug #62.}
00421 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float}  pfirst<Packet4f>(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordflow}{return} a.m128\_f32[0]; \}
00422 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} pfirst<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} a.m128d\_f64[0]; \}
00423 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int}    pfirst<Packet4i>(\textcolor{keyword}{const} Packet4i& a) \{ \textcolor{keywordtype}{int} x = \_mm\_cvtsi128\_si32(a); \textcolor{keywordflow}{
      return} x; \}
00424 \textcolor{preprocessor}{#elif EIGEN\_COMP\_MSVC\_STRICT}
00425 \textcolor{comment}{// The temporary variable fixes an internal compilation error in vs <= 2008 and a wrong-result bug in vs
       2010}
00426 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float}  pfirst<Packet4f>(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordtype}{float} x = \_mm\_cvtss\_f32(a); \textcolor{keywordflow}{
      return} x; \}
00427 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} pfirst<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordtype}{double} x = \_mm\_cvtsd\_f64(a); \textcolor{keywordflow}{
      return} x; \}
00428 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int}    pfirst<Packet4i>(\textcolor{keyword}{const} Packet4i& a) \{ \textcolor{keywordtype}{int} x = \_mm\_cvtsi128\_si32(a); \textcolor{keywordflow}{
      return} x; \}
00429 \textcolor{preprocessor}{#else}
00430 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float}  pfirst<Packet4f>(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordflow}{return} \_mm\_cvtss\_f32(a); \}
00431 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} pfirst<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} \_mm\_cvtsd\_f64(a); \}
00432 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int}    pfirst<Packet4i>(\textcolor{keyword}{const} Packet4i& a) \{ \textcolor{keywordflow}{return} \_mm\_cvtsi128\_si32(a); \}
00433 \textcolor{preprocessor}{#endif}
00434 
00435 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f preverse(\textcolor{keyword}{const} Packet4f& a)
00436 \{ \textcolor{keywordflow}{return} \_mm\_shuffle\_ps(a,a,0x1B); \}
00437 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d preverse(\textcolor{keyword}{const} Packet2d& a)
00438 \{ \textcolor{keywordflow}{return} \_mm\_shuffle\_pd(a,a,0x1); \}
00439 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i preverse(\textcolor{keyword}{const} Packet4i& a)
00440 \{ \textcolor{keywordflow}{return} \_mm\_shuffle\_epi32(a,0x1B); \}
00441 
00442 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pabs(\textcolor{keyword}{const} Packet4f& a)
00443 \{
00444   \textcolor{keyword}{const} Packet4f mask = \_mm\_castsi128\_ps(\_mm\_setr\_epi32(0x7FFFFFFF,0x7FFFFFFF,0x7FFFFFFF,0x7FFFFFFF));
00445   \textcolor{keywordflow}{return} \_mm\_and\_ps(a,mask);
00446 \}
00447 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pabs(\textcolor{keyword}{const} Packet2d& a)
00448 \{
00449   \textcolor{keyword}{const} Packet2d mask = \_mm\_castsi128\_pd(\_mm\_setr\_epi32(0xFFFFFFFF,0x7FFFFFFF,0xFFFFFFFF,0x7FFFFFFF));
00450   \textcolor{keywordflow}{return} \_mm\_and\_pd(a,mask);
00451 \}
00452 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pabs(\textcolor{keyword}{const} Packet4i& a)
00453 \{
00454 \textcolor{preprocessor}{  #ifdef EIGEN\_VECTORIZE\_SSSE3}
00455   \textcolor{keywordflow}{return} \_mm\_abs\_epi32(a);
00456 \textcolor{preprocessor}{  #else}
00457   Packet4i aux = \_mm\_srai\_epi32(a,31);
00458   \textcolor{keywordflow}{return} \_mm\_sub\_epi32(\_mm\_xor\_si128(a,aux),aux);
00459 \textcolor{preprocessor}{  #endif}
00460 \}
00461 
00462 \textcolor{comment}{// with AVX, the default implementations based on pload1 are faster}
00463 \textcolor{preprocessor}{#ifndef \_\_AVX\_\_}
00464 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00465 pbroadcast4<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float} *a,
00466                       Packet4f& a0, Packet4f& a1, Packet4f& a2, Packet4f& a3)
00467 \{
00468   a3 = pload<Packet4f>(a);
00469   a0 = vec4f\_swizzle1(a3, 0,0,0,0);
00470   a1 = vec4f\_swizzle1(a3, 1,1,1,1);
00471   a2 = vec4f\_swizzle1(a3, 2,2,2,2);
00472   a3 = vec4f\_swizzle1(a3, 3,3,3,3);
00473 \}
00474 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00475 pbroadcast4<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double} *a,
00476                       Packet2d& a0, Packet2d& a1, Packet2d& a2, Packet2d& a3)
00477 \{
00478 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE3}
00479   a0 = \_mm\_loaddup\_pd(a+0);
00480   a1 = \_mm\_loaddup\_pd(a+1);
00481   a2 = \_mm\_loaddup\_pd(a+2);
00482   a3 = \_mm\_loaddup\_pd(a+3);
00483 \textcolor{preprocessor}{#else}
00484   a1 = pload<Packet2d>(a);
00485   a0 = vec2d\_swizzle1(a1, 0,0);
00486   a1 = vec2d\_swizzle1(a1, 1,1);
00487   a3 = pload<Packet2d>(a+2);
00488   a2 = vec2d\_swizzle1(a3, 0,0);
00489   a3 = vec2d\_swizzle1(a3, 1,1);
00490 \textcolor{preprocessor}{#endif}
00491 \}
00492 \textcolor{preprocessor}{#endif}
00493 
00494 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} punpackp(Packet4f* vecs)
00495 \{
00496   vecs[1] = \_mm\_castsi128\_ps(\_mm\_shuffle\_epi32(\_mm\_castps\_si128(vecs[0]), 0x55));
00497   vecs[2] = \_mm\_castsi128\_ps(\_mm\_shuffle\_epi32(\_mm\_castps\_si128(vecs[0]), 0xAA));
00498   vecs[3] = \_mm\_castsi128\_ps(\_mm\_shuffle\_epi32(\_mm\_castps\_si128(vecs[0]), 0xFF));
00499   vecs[0] = \_mm\_castsi128\_ps(\_mm\_shuffle\_epi32(\_mm\_castps\_si128(vecs[0]), 0x00));
00500 \}
00501 
00502 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE3}
00503 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f preduxp<Packet4f>(\textcolor{keyword}{const} Packet4f* vecs)
00504 \{
00505   \textcolor{keywordflow}{return} \_mm\_hadd\_ps(\_mm\_hadd\_ps(vecs[0], vecs[1]),\_mm\_hadd\_ps(vecs[2], vecs[3]));
00506 \}
00507 
00508 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d preduxp<Packet2d>(\textcolor{keyword}{const} Packet2d* vecs)
00509 \{
00510   \textcolor{keywordflow}{return} \_mm\_hadd\_pd(vecs[0], vecs[1]);
00511 \}
00512 
00513 \textcolor{preprocessor}{#else}
00514 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f preduxp<Packet4f>(\textcolor{keyword}{const} Packet4f* vecs)
00515 \{
00516   Packet4f tmp0, tmp1, tmp2;
00517   tmp0 = \_mm\_unpacklo\_ps(vecs[0], vecs[1]);
00518   tmp1 = \_mm\_unpackhi\_ps(vecs[0], vecs[1]);
00519   tmp2 = \_mm\_unpackhi\_ps(vecs[2], vecs[3]);
00520   tmp0 = \_mm\_add\_ps(tmp0, tmp1);
00521   tmp1 = \_mm\_unpacklo\_ps(vecs[2], vecs[3]);
00522   tmp1 = \_mm\_add\_ps(tmp1, tmp2);
00523   tmp2 = \_mm\_movehl\_ps(tmp1, tmp0);
00524   tmp0 = \_mm\_movelh\_ps(tmp0, tmp1);
00525   \textcolor{keywordflow}{return} \_mm\_add\_ps(tmp0, tmp2);
00526 \}
00527 
00528 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d preduxp<Packet2d>(\textcolor{keyword}{const} Packet2d* vecs)
00529 \{
00530   \textcolor{keywordflow}{return} \_mm\_add\_pd(\_mm\_unpacklo\_pd(vecs[0], vecs[1]), \_mm\_unpackhi\_pd(vecs[0], vecs[1]));
00531 \}
00532 \textcolor{preprocessor}{#endif  // SSE3}
00533 
00534 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00535 \{
00536   \textcolor{comment}{// Disable SSE3 \_mm\_hadd\_pd that is extremely slow on all existing Intel's architectures}
00537   \textcolor{comment}{// (from Nehalem to Haswell)}
00538 \textcolor{comment}{// #ifdef EIGEN\_VECTORIZE\_SSE3}
00539 \textcolor{comment}{//   Packet4f tmp = \_mm\_add\_ps(a, vec4f\_swizzle1(a,2,3,2,3));}
00540 \textcolor{comment}{//   return pfirst<Packet4f>(\_mm\_hadd\_ps(tmp, tmp));}
00541 \textcolor{comment}{// #else}
00542   Packet4f tmp = \_mm\_add\_ps(a, \_mm\_movehl\_ps(a,a));
00543   \textcolor{keywordflow}{return} pfirst<Packet4f>(\_mm\_add\_ss(tmp, \_mm\_shuffle\_ps(tmp,tmp, 1)));
00544 \textcolor{comment}{// #endif}
00545 \}
00546 
00547 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux<Packet2d>(\textcolor{keyword}{const} Packet2d& a)
00548 \{
00549   \textcolor{comment}{// Disable SSE3 \_mm\_hadd\_pd that is extremely slow on all existing Intel's architectures}
00550   \textcolor{comment}{// (from Nehalem to Haswell)}
00551 \textcolor{comment}{// #ifdef EIGEN\_VECTORIZE\_SSE3}
00552 \textcolor{comment}{//   return pfirst<Packet2d>(\_mm\_hadd\_pd(a, a));}
00553 \textcolor{comment}{// #else}
00554   \textcolor{keywordflow}{return} pfirst<Packet2d>(\_mm\_add\_sd(a, \_mm\_unpackhi\_pd(a,a)));
00555 \textcolor{comment}{// #endif}
00556 \}
00557 
00558 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSSE3}
00559 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i preduxp<Packet4i>(\textcolor{keyword}{const} Packet4i* vecs)
00560 \{
00561   \textcolor{keywordflow}{return} \_mm\_hadd\_epi32(\_mm\_hadd\_epi32(vecs[0], vecs[1]),\_mm\_hadd\_epi32(vecs[2], vecs[3]));
00562 \}
00563 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00564 \{
00565   Packet4i tmp0 = \_mm\_hadd\_epi32(a,a);
00566   \textcolor{keywordflow}{return} pfirst<Packet4i>(\_mm\_hadd\_epi32(tmp0,tmp0));
00567 \}
00568 \textcolor{preprocessor}{#else}
00569 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00570 \{
00571   Packet4i tmp = \_mm\_add\_epi32(a, \_mm\_unpackhi\_epi64(a,a));
00572   \textcolor{keywordflow}{return} pfirst(tmp) + pfirst<Packet4i>(\_mm\_shuffle\_epi32(tmp, 1));
00573 \}
00574 
00575 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i preduxp<Packet4i>(\textcolor{keyword}{const} Packet4i* vecs)
00576 \{
00577   Packet4i tmp0, tmp1, tmp2;
00578   tmp0 = \_mm\_unpacklo\_epi32(vecs[0], vecs[1]);
00579   tmp1 = \_mm\_unpackhi\_epi32(vecs[0], vecs[1]);
00580   tmp2 = \_mm\_unpackhi\_epi32(vecs[2], vecs[3]);
00581   tmp0 = \_mm\_add\_epi32(tmp0, tmp1);
00582   tmp1 = \_mm\_unpacklo\_epi32(vecs[2], vecs[3]);
00583   tmp1 = \_mm\_add\_epi32(tmp1, tmp2);
00584   tmp2 = \_mm\_unpacklo\_epi64(tmp0, tmp1);
00585   tmp0 = \_mm\_unpackhi\_epi64(tmp0, tmp1);
00586   \textcolor{keywordflow}{return} \_mm\_add\_epi32(tmp0, tmp2);
00587 \}
00588 \textcolor{preprocessor}{#endif}
00589 \textcolor{comment}{// Other reduction functions:}
00590 
00591 \textcolor{comment}{// mul}
00592 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux\_mul<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00593 \{
00594   Packet4f tmp = \_mm\_mul\_ps(a, \_mm\_movehl\_ps(a,a));
00595   \textcolor{keywordflow}{return} pfirst<Packet4f>(\_mm\_mul\_ss(tmp, \_mm\_shuffle\_ps(tmp,tmp, 1)));
00596 \}
00597 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux\_mul<Packet2d>(\textcolor{keyword}{const} Packet2d& a)
00598 \{
00599   \textcolor{keywordflow}{return} pfirst<Packet2d>(\_mm\_mul\_sd(a, \_mm\_unpackhi\_pd(a,a)));
00600 \}
00601 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux\_mul<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00602 \{
00603   \textcolor{comment}{// after some experiments, it is seems this is the fastest way to implement it}
00604   \textcolor{comment}{// for GCC (eg., reusing pmul is very slow !)}
00605   \textcolor{comment}{// TODO try to call \_mm\_mul\_epu32 directly}
00606   EIGEN\_ALIGN16 \textcolor{keywordtype}{int} aux[4];
00607   pstore(aux, a);
00608   \textcolor{keywordflow}{return}  (aux[0] * aux[1]) * (aux[2] * aux[3]);;
00609 \}
00610 
00611 \textcolor{comment}{// min}
00612 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux\_min<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00613 \{
00614   Packet4f tmp = \_mm\_min\_ps(a, \_mm\_movehl\_ps(a,a));
00615   \textcolor{keywordflow}{return} pfirst<Packet4f>(\_mm\_min\_ss(tmp, \_mm\_shuffle\_ps(tmp,tmp, 1)));
00616 \}
00617 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux\_min<Packet2d>(\textcolor{keyword}{const} Packet2d& a)
00618 \{
00619   \textcolor{keywordflow}{return} pfirst<Packet2d>(\_mm\_min\_sd(a, \_mm\_unpackhi\_pd(a,a)));
00620 \}
00621 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux\_min<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00622 \{
00623 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00624   Packet4i tmp = \_mm\_min\_epi32(a, \_mm\_shuffle\_epi32(a, \_MM\_SHUFFLE(0,0,3,2)));
00625   \textcolor{keywordflow}{return} pfirst<Packet4i>(\_mm\_min\_epi32(tmp,\_mm\_shuffle\_epi32(tmp, 1)));
00626 \textcolor{preprocessor}{#else}
00627   \textcolor{comment}{// after some experiments, it is seems this is the fastest way to implement it}
00628   \textcolor{comment}{// for GCC (eg., it does not like using std::min after the pstore !!)}
00629   EIGEN\_ALIGN16 \textcolor{keywordtype}{int} aux[4];
00630   pstore(aux, a);
00631   \textcolor{keywordtype}{int} aux0 = aux[0]<aux[1] ? aux[0] : aux[1];
00632   \textcolor{keywordtype}{int} aux2 = aux[2]<aux[3] ? aux[2] : aux[3];
00633   \textcolor{keywordflow}{return} aux0<aux2 ? aux0 : aux2;
00634 \textcolor{preprocessor}{#endif // EIGEN\_VECTORIZE\_SSE4\_1}
00635 \}
00636 
00637 \textcolor{comment}{// max}
00638 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux\_max<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00639 \{
00640   Packet4f tmp = \_mm\_max\_ps(a, \_mm\_movehl\_ps(a,a));
00641   \textcolor{keywordflow}{return} pfirst<Packet4f>(\_mm\_max\_ss(tmp, \_mm\_shuffle\_ps(tmp,tmp, 1)));
00642 \}
00643 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux\_max<Packet2d>(\textcolor{keyword}{const} Packet2d& a)
00644 \{
00645   \textcolor{keywordflow}{return} pfirst<Packet2d>(\_mm\_max\_sd(a, \_mm\_unpackhi\_pd(a,a)));
00646 \}
00647 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux\_max<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00648 \{
00649 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00650   Packet4i tmp = \_mm\_max\_epi32(a, \_mm\_shuffle\_epi32(a, \_MM\_SHUFFLE(0,0,3,2)));
00651   \textcolor{keywordflow}{return} pfirst<Packet4i>(\_mm\_max\_epi32(tmp,\_mm\_shuffle\_epi32(tmp, 1)));
00652 \textcolor{preprocessor}{#else}
00653   \textcolor{comment}{// after some experiments, it is seems this is the fastest way to implement it}
00654   \textcolor{comment}{// for GCC (eg., it does not like using std::min after the pstore !!)}
00655   EIGEN\_ALIGN16 \textcolor{keywordtype}{int} aux[4];
00656   pstore(aux, a);
00657   \textcolor{keywordtype}{int} aux0 = aux[0]>aux[1] ? aux[0] : aux[1];
00658   \textcolor{keywordtype}{int} aux2 = aux[2]>aux[3] ? aux[2] : aux[3];
00659   \textcolor{keywordflow}{return} aux0>aux2 ? aux0 : aux2;
00660 \textcolor{preprocessor}{#endif // EIGEN\_VECTORIZE\_SSE4\_1}
00661 \}
00662 
00663 \textcolor{preprocessor}{#if EIGEN\_COMP\_GNUC}
00664 \textcolor{comment}{// template <> EIGEN\_STRONG\_INLINE Packet4f pmadd(const Packet4f&  a, const Packet4f&  b, const Packet4f& 
       c)}
00665 \textcolor{comment}{// \{}
00666 \textcolor{comment}{//   Packet4f res = b;}
00667 \textcolor{comment}{//   asm("mulps %[a], %[b] \(\backslash\)n\(\backslash\)taddps %[c], %[b]" : [b] "+x" (res) : [a] "x" (a), [c] "x" (c));}
00668 \textcolor{comment}{//   return res;}
00669 \textcolor{comment}{// \}}
00670 \textcolor{comment}{// EIGEN\_STRONG\_INLINE Packet4i \_mm\_alignr\_epi8(const Packet4i&  a, const Packet4i&  b, const int i)}
00671 \textcolor{comment}{// \{}
00672 \textcolor{comment}{//   Packet4i res = a;}
00673 \textcolor{comment}{//   asm("palignr %[i], %[a], %[b] " : [b] "+x" (res) : [a] "x" (a), [i] "i" (i));}
00674 \textcolor{comment}{//   return res;}
00675 \textcolor{comment}{// \}}
00676 \textcolor{preprocessor}{#endif}
00677 
00678 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSSE3}
00679 \textcolor{comment}{// SSSE3 versions}
00680 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00681 \textcolor{keyword}{struct }palign\_impl<Offset,Packet4f>
00682 \{
00683   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet4f& first, \textcolor{keyword}{const} Packet4f& second)
00684   \{
00685     \textcolor{keywordflow}{if} (Offset!=0)
00686       first = \_mm\_castsi128\_ps(\_mm\_alignr\_epi8(\_mm\_castps\_si128(second), \_mm\_castps\_si128(first), Offset*4)
      );
00687   \}
00688 \};
00689 
00690 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00691 \textcolor{keyword}{struct }palign\_impl<Offset,Packet4i>
00692 \{
00693   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet4i& first, \textcolor{keyword}{const} Packet4i& second)
00694   \{
00695     \textcolor{keywordflow}{if} (Offset!=0)
00696       first = \_mm\_alignr\_epi8(second,first, Offset*4);
00697   \}
00698 \};
00699 
00700 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00701 \textcolor{keyword}{struct }palign\_impl<Offset,Packet2d>
00702 \{
00703   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet2d& first, \textcolor{keyword}{const} Packet2d& second)
00704   \{
00705     \textcolor{keywordflow}{if} (Offset==1)
00706       first = \_mm\_castsi128\_pd(\_mm\_alignr\_epi8(\_mm\_castpd\_si128(second), \_mm\_castpd\_si128(first), 8));
00707   \}
00708 \};
00709 \textcolor{preprocessor}{#else}
00710 \textcolor{comment}{// SSE2 versions}
00711 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00712 \textcolor{keyword}{struct }palign\_impl<Offset,Packet4f>
00713 \{
00714   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet4f& first, \textcolor{keyword}{const} Packet4f& second)
00715   \{
00716     \textcolor{keywordflow}{if} (Offset==1)
00717     \{
00718       first = \_mm\_move\_ss(first,second);
00719       first = \_mm\_castsi128\_ps(\_mm\_shuffle\_epi32(\_mm\_castps\_si128(first),0x39));
00720     \}
00721     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Offset==2)
00722     \{
00723       first = \_mm\_movehl\_ps(first,first);
00724       first = \_mm\_movelh\_ps(first,second);
00725     \}
00726     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Offset==3)
00727     \{
00728       first = \_mm\_move\_ss(first,second);
00729       first = \_mm\_shuffle\_ps(first,second,0x93);
00730     \}
00731   \}
00732 \};
00733 
00734 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00735 \textcolor{keyword}{struct }palign\_impl<Offset,Packet4i>
00736 \{
00737   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet4i& first, \textcolor{keyword}{const} Packet4i& second)
00738   \{
00739     \textcolor{keywordflow}{if} (Offset==1)
00740     \{
00741       first = \_mm\_castps\_si128(\_mm\_move\_ss(\_mm\_castsi128\_ps(first),\_mm\_castsi128\_ps(second)));
00742       first = \_mm\_shuffle\_epi32(first,0x39);
00743     \}
00744     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Offset==2)
00745     \{
00746       first = \_mm\_castps\_si128(\_mm\_movehl\_ps(\_mm\_castsi128\_ps(first),\_mm\_castsi128\_ps(first)));
00747       first = \_mm\_castps\_si128(\_mm\_movelh\_ps(\_mm\_castsi128\_ps(first),\_mm\_castsi128\_ps(second)));
00748     \}
00749     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Offset==3)
00750     \{
00751       first = \_mm\_castps\_si128(\_mm\_move\_ss(\_mm\_castsi128\_ps(first),\_mm\_castsi128\_ps(second)));
00752       first = \_mm\_castps\_si128(\_mm\_shuffle\_ps(\_mm\_castsi128\_ps(first),\_mm\_castsi128\_ps(second),0x93));
00753     \}
00754   \}
00755 \};
00756 
00757 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00758 \textcolor{keyword}{struct }palign\_impl<Offset,Packet2d>
00759 \{
00760   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet2d& first, \textcolor{keyword}{const} Packet2d& second)
00761   \{
00762     \textcolor{keywordflow}{if} (Offset==1)
00763     \{
00764       first = \_mm\_castps\_pd(\_mm\_movehl\_ps(\_mm\_castpd\_ps(first),\_mm\_castpd\_ps(first)));
00765       first = \_mm\_castps\_pd(\_mm\_movelh\_ps(\_mm\_castpd\_ps(first),\_mm\_castpd\_ps(second)));
00766     \}
00767   \}
00768 \};
00769 \textcolor{preprocessor}{#endif}
00770 
00771 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00772 ptranspose(PacketBlock<Packet4f,4>& kernel) \{
00773   \_MM\_TRANSPOSE4\_PS(kernel.packet[0], kernel.packet[1], kernel.packet[2], kernel.packet[3]);
00774 \}
00775 
00776 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00777 ptranspose(PacketBlock<Packet2d,2>& kernel) \{
00778   \_\_m128d tmp = \_mm\_unpackhi\_pd(kernel.packet[0], kernel.packet[1]);
00779   kernel.packet[0] = \_mm\_unpacklo\_pd(kernel.packet[0], kernel.packet[1]);
00780   kernel.packet[1] = tmp;
00781 \}
00782 
00783 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00784 ptranspose(PacketBlock<Packet4i,4>& kernel) \{
00785   \_\_m128i T0 = \_mm\_unpacklo\_epi32(kernel.packet[0], kernel.packet[1]);
00786   \_\_m128i T1 = \_mm\_unpacklo\_epi32(kernel.packet[2], kernel.packet[3]);
00787   \_\_m128i T2 = \_mm\_unpackhi\_epi32(kernel.packet[0], kernel.packet[1]);
00788   \_\_m128i T3 = \_mm\_unpackhi\_epi32(kernel.packet[2], kernel.packet[3]);
00789 
00790   kernel.packet[0] = \_mm\_unpacklo\_epi64(T0, T1);
00791   kernel.packet[1] = \_mm\_unpackhi\_epi64(T0, T1);
00792   kernel.packet[2] = \_mm\_unpacklo\_epi64(T2, T3);
00793   kernel.packet[3] = \_mm\_unpackhi\_epi64(T2, T3);
00794 \}
00795 
00796 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pblend(\textcolor{keyword}{const} Selector<4>& ifPacket, \textcolor{keyword}{const} Packet4i& thenPacket, \textcolor{keyword}{
      const} Packet4i& elsePacket) \{
00797   \textcolor{keyword}{const} \_\_m128i zero = \_mm\_setzero\_si128();
00798   \textcolor{keyword}{const} \_\_m128i select = \_mm\_set\_epi32(ifPacket.select[3], ifPacket.select[2], ifPacket.select[1], ifPacket
      .select[0]);
00799   \_\_m128i false\_mask = \_mm\_cmpeq\_epi32(select, zero);
00800 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00801   \textcolor{keywordflow}{return} \_mm\_blendv\_epi8(thenPacket, elsePacket, false\_mask);
00802 \textcolor{preprocessor}{#else}
00803   \textcolor{keywordflow}{return} \_mm\_or\_si128(\_mm\_andnot\_si128(false\_mask, thenPacket), \_mm\_and\_si128(false\_mask, elsePacket));
00804 \textcolor{preprocessor}{#endif}
00805 \}
00806 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pblend(\textcolor{keyword}{const} Selector<4>& ifPacket, \textcolor{keyword}{const} Packet4f& thenPacket, \textcolor{keyword}{
      const} Packet4f& elsePacket) \{
00807   \textcolor{keyword}{const} \_\_m128 zero = \_mm\_setzero\_ps();
00808   \textcolor{keyword}{const} \_\_m128 select = \_mm\_set\_ps(ifPacket.select[3], ifPacket.select[2], ifPacket.select[1], ifPacket.
      select[0]);
00809   \_\_m128 false\_mask = \_mm\_cmpeq\_ps(select, zero);
00810 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00811   \textcolor{keywordflow}{return} \_mm\_blendv\_ps(thenPacket, elsePacket, false\_mask);
00812 \textcolor{preprocessor}{#else}
00813   \textcolor{keywordflow}{return} \_mm\_or\_ps(\_mm\_andnot\_ps(false\_mask, thenPacket), \_mm\_and\_ps(false\_mask, elsePacket));
00814 \textcolor{preprocessor}{#endif}
00815 \}
00816 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pblend(\textcolor{keyword}{const} Selector<2>& ifPacket, \textcolor{keyword}{const} Packet2d& thenPacket, \textcolor{keyword}{
      const} Packet2d& elsePacket) \{
00817   \textcolor{keyword}{const} \_\_m128d zero = \_mm\_setzero\_pd();
00818   \textcolor{keyword}{const} \_\_m128d select = \_mm\_set\_pd(ifPacket.select[1], ifPacket.select[0]);
00819   \_\_m128d false\_mask = \_mm\_cmpeq\_pd(select, zero);
00820 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00821   \textcolor{keywordflow}{return} \_mm\_blendv\_pd(thenPacket, elsePacket, false\_mask);
00822 \textcolor{preprocessor}{#else}
00823   \textcolor{keywordflow}{return} \_mm\_or\_pd(\_mm\_andnot\_pd(false\_mask, thenPacket), \_mm\_and\_pd(false\_mask, elsePacket));
00824 \textcolor{preprocessor}{#endif}
00825 \}
00826 
00827 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pinsertfirst(\textcolor{keyword}{const} Packet4f& a, \textcolor{keywordtype}{float} b)
00828 \{
00829 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00830   \textcolor{keywordflow}{return} \_mm\_blend\_ps(a,pset1<Packet4f>(b),1);
00831 \textcolor{preprocessor}{#else}
00832   \textcolor{keywordflow}{return} \_mm\_move\_ss(a, \_mm\_load\_ss(&b));
00833 \textcolor{preprocessor}{#endif}
00834 \}
00835 
00836 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pinsertfirst(\textcolor{keyword}{const} Packet2d& a, \textcolor{keywordtype}{double} b)
00837 \{
00838 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00839   \textcolor{keywordflow}{return} \_mm\_blend\_pd(a,pset1<Packet2d>(b),1);
00840 \textcolor{preprocessor}{#else}
00841   \textcolor{keywordflow}{return} \_mm\_move\_sd(a, \_mm\_load\_sd(&b));
00842 \textcolor{preprocessor}{#endif}
00843 \}
00844 
00845 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pinsertlast(\textcolor{keyword}{const} Packet4f& a, \textcolor{keywordtype}{float} b)
00846 \{
00847 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00848   \textcolor{keywordflow}{return} \_mm\_blend\_ps(a,pset1<Packet4f>(b),(1<<3));
00849 \textcolor{preprocessor}{#else}
00850   \textcolor{keyword}{const} Packet4f mask = \_mm\_castsi128\_ps(\_mm\_setr\_epi32(0x0,0x0,0x0,0xFFFFFFFF));
00851   \textcolor{keywordflow}{return} \_mm\_or\_ps(\_mm\_andnot\_ps(mask, a), \_mm\_and\_ps(mask, pset1<Packet4f>(b)));
00852 \textcolor{preprocessor}{#endif}
00853 \}
00854 
00855 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pinsertlast(\textcolor{keyword}{const} Packet2d& a, \textcolor{keywordtype}{double} b)
00856 \{
00857 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00858   \textcolor{keywordflow}{return} \_mm\_blend\_pd(a,pset1<Packet2d>(b),(1<<1));
00859 \textcolor{preprocessor}{#else}
00860   \textcolor{keyword}{const} Packet2d mask = \_mm\_castsi128\_pd(\_mm\_setr\_epi32(0x0,0x0,0xFFFFFFFF,0xFFFFFFFF));
00861   \textcolor{keywordflow}{return} \_mm\_or\_pd(\_mm\_andnot\_pd(mask, a), \_mm\_and\_pd(mask, pset1<Packet2d>(b)));
00862 \textcolor{preprocessor}{#endif}
00863 \}
00864 
00865 \textcolor{comment}{// Scalar path for pmadd with FMA to ensure consistency with vectorized path.}
00866 \textcolor{preprocessor}{#ifdef \_\_FMA\_\_}
00867 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} pmadd(\textcolor{keyword}{const} \textcolor{keywordtype}{float}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{float}& b, \textcolor{keyword}{const} \textcolor{keywordtype}{float}& c) \{
00868   return ::fmaf(a,b,c);
00869 \}
00870 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} pmadd(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& b, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& c) \{
00871   return ::fma(a,b,c);
00872 \}
00873 \textcolor{preprocessor}{#endif}
00874 
00875 \} \textcolor{comment}{// end namespace internal}
00876 
00877 \} \textcolor{comment}{// end namespace Eigen}
00878 
00879 \textcolor{preprocessor}{#endif // EIGEN\_PACKET\_MATH\_SSE\_H}
\end{DoxyCode}
