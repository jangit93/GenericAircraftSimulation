\hypertarget{eigen_2_eigen_2src_2_iterative_linear_solvers_2_basic_preconditioners_8h_source}{}\section{eigen/\+Eigen/src/\+Iterative\+Linear\+Solvers/\+Basic\+Preconditioners.h}
\label{eigen_2_eigen_2src_2_iterative_linear_solvers_2_basic_preconditioners_8h_source}\index{Basic\+Preconditioners.\+h@{Basic\+Preconditioners.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2011-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_BASIC\_PRECONDITIONERS\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_BASIC\_PRECONDITIONERS\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00035 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_Scalar>
\Hypertarget{eigen_2_eigen_2src_2_iterative_linear_solvers_2_basic_preconditioners_8h_source_l00036}\hyperlink{group___iterative_linear_solvers___module}{00036} \textcolor{keyword}{class }\hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_diagonal_preconditioner}{DiagonalPreconditioner}
00037 \{
00038     \textcolor{keyword}{typedef} \_Scalar Scalar;
00039     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} \hyperlink{group___core___module}{Vector};
00040   \textcolor{keyword}{public}:
00041     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Vector::StorageIndex StorageIndex;
00042     \textcolor{keyword}{enum} \{
00043       ColsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00044       MaxColsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}
00045     \};
00046 
00047     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_diagonal_preconditioner}{DiagonalPreconditioner}() : m\_isInitialized(\textcolor{keyword}{false}) \{\}
00048 
00049     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatType>
00050     \textcolor{keyword}{explicit} \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_diagonal_preconditioner}{DiagonalPreconditioner}(\textcolor{keyword}{const} MatType& mat) : m\_invdiag(mat.cols())
00051     \{
00052       compute(mat);
00053     \}
00054 
00055     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_invdiag.size(); \}
00056     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_invdiag.size(); \}
00057     
00058     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatType>
00059     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_diagonal_preconditioner}{DiagonalPreconditioner}& analyzePattern(\textcolor{keyword}{const} MatType& )
00060     \{
00061       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00062     \}
00063     
00064     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatType>
00065     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_diagonal_preconditioner}{DiagonalPreconditioner}& factorize(\textcolor{keyword}{const} MatType& mat)
00066     \{
00067       m\_invdiag.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(mat.cols());
00068       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<mat.outerSize(); ++j)
00069       \{
00070         \textcolor{keyword}{typename} MatType::InnerIterator it(mat,j);
00071         \textcolor{keywordflow}{while}(it && it.index()!=j) ++it;
00072         \textcolor{keywordflow}{if}(it && it.index()==j && it.value()!=Scalar(0))
00073           m\_invdiag(j) = Scalar(1)/it.value();
00074         \textcolor{keywordflow}{else}
00075           m\_invdiag(j) = Scalar(1);
00076       \}
00077       m\_isInitialized = \textcolor{keyword}{true};
00078       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00079     \}
00080     
00081     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatType>
00082     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_diagonal_preconditioner}{DiagonalPreconditioner}& compute(\textcolor{keyword}{const} MatType& mat)
00083     \{
00084       \textcolor{keywordflow}{return} factorize(mat);
00085     \}
00086 
00088     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest>
00089     \textcolor{keywordtype}{void} \_solve\_impl(\textcolor{keyword}{const} Rhs& b, Dest& x)\textcolor{keyword}{ const}
00090 \textcolor{keyword}{    }\{
00091       x = m\_invdiag.array() * b.array() ;
00092     \}
00093 
00094     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs> \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_solve}{Solve<DiagonalPreconditioner, Rhs>}
00095     solve(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>}& b)\textcolor{keyword}{ const}
00096 \textcolor{keyword}{    }\{
00097       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"DiagonalPreconditioner is not initialized."});
00098       eigen\_assert(m\_invdiag.size()==b.rows()
00099                 && \textcolor{stringliteral}{"DiagonalPreconditioner::solve(): invalid number of rows of the right hand side matrix b
      "});
00100       \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_solve}{Solve<DiagonalPreconditioner, Rhs>}(*\textcolor{keyword}{this}, b.derived());
00101     \}
00102     
00103     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} info() \{ \textcolor{keywordflow}{return} \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success}; \}
00104 
00105   \textcolor{keyword}{protected}:
00106     Vector m\_invdiag;
00107     \textcolor{keywordtype}{bool} m\_isInitialized;
00108 \};
00109 
00127 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_Scalar>
\Hypertarget{eigen_2_eigen_2src_2_iterative_linear_solvers_2_basic_preconditioners_8h_source_l00128}\hyperlink{group___iterative_linear_solvers___module}{00128} \textcolor{keyword}{class }\hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_least_square_diagonal_preconditioner}{LeastSquareDiagonalPreconditioner} : \textcolor{keyword}{public} 
      \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_diagonal_preconditioner}{DiagonalPreconditioner}<\_Scalar>
00129 \{
00130     \textcolor{keyword}{typedef} \_Scalar Scalar;
00131     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00132     \textcolor{keyword}{typedef} \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_diagonal_preconditioner}{DiagonalPreconditioner<\_Scalar>} \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_diagonal_preconditioner}{Base};
00133     \textcolor{keyword}{using} Base::m\_invdiag;
00134   \textcolor{keyword}{public}:
00135 
00136     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_least_square_diagonal_preconditioner}{LeastSquareDiagonalPreconditioner}() : Base() \{\}
00137 
00138     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatType>
00139     \textcolor{keyword}{explicit} \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_least_square_diagonal_preconditioner}{LeastSquareDiagonalPreconditioner}(\textcolor{keyword}{const} MatType& mat) : Base(
      )
00140     \{
00141       compute(mat);
00142     \}
00143 
00144     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatType>
00145     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_least_square_diagonal_preconditioner}{LeastSquareDiagonalPreconditioner}& analyzePattern(\textcolor{keyword}{const} MatType& )
00146     \{
00147       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00148     \}
00149     
00150     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatType>
00151     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_least_square_diagonal_preconditioner}{LeastSquareDiagonalPreconditioner}& factorize(\textcolor{keyword}{const} MatType& mat)
00152     \{
00153       \textcolor{comment}{// Compute the inverse squared-norm of each column of mat}
00154       m\_invdiag.resize(mat.cols());
00155       \textcolor{keywordflow}{if}(MatType::IsRowMajor)
00156       \{
00157         m\_invdiag.setZero();
00158         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<mat.outerSize(); ++j)
00159         \{
00160           \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} MatType::InnerIterator it(mat,j); it; ++it)
00161             m\_invdiag(it.index()) += numext::abs2(it.value());
00162         \}
00163         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<mat.cols(); ++j)
00164           \textcolor{keywordflow}{if}(numext::real(m\_invdiag(j))>RealScalar(0))
00165             m\_invdiag(j) = RealScalar(1)/numext::real(m\_invdiag(j));
00166       \}
00167       \textcolor{keywordflow}{else}
00168       \{
00169         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<mat.outerSize(); ++j)
00170         \{
00171           RealScalar sum = mat.innerVector(j).squaredNorm();
00172           \textcolor{keywordflow}{if}(sum>RealScalar(0))
00173             m\_invdiag(j) = RealScalar(1)/sum;
00174           \textcolor{keywordflow}{else}
00175             m\_invdiag(j) = RealScalar(1);
00176         \}
00177       \}
00178       Base::m\_isInitialized = \textcolor{keyword}{true};
00179       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00180     \}
00181     
00182     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatType>
00183     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_least_square_diagonal_preconditioner}{LeastSquareDiagonalPreconditioner}& compute(\textcolor{keyword}{const} MatType& mat)
00184     \{
00185       \textcolor{keywordflow}{return} factorize(mat);
00186     \}
00187     
00188     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} info() \{ \textcolor{keywordflow}{return} \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success}; \}
00189 
00190   \textcolor{keyword}{protected}:
00191 \};
00192 
\Hypertarget{eigen_2_eigen_2src_2_iterative_linear_solvers_2_basic_preconditioners_8h_source_l00200}\hyperlink{group___iterative_linear_solvers___module}{00200} \textcolor{keyword}{class }\hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_identity_preconditioner}{IdentityPreconditioner}
00201 \{
00202   \textcolor{keyword}{public}:
00203 
00204     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_identity_preconditioner}{IdentityPreconditioner}() \{\}
00205 
00206     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00207     \textcolor{keyword}{explicit} \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_identity_preconditioner}{IdentityPreconditioner}(\textcolor{keyword}{const} MatrixType& ) \{\}
00208     
00209     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00210     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_identity_preconditioner}{IdentityPreconditioner}& analyzePattern(\textcolor{keyword}{const} MatrixType& ) \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}
00211     
00212     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00213     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_identity_preconditioner}{IdentityPreconditioner}& factorize(\textcolor{keyword}{const} MatrixType& ) \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}
00214 
00215     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00216     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_identity_preconditioner}{IdentityPreconditioner}& compute(\textcolor{keyword}{const} MatrixType& ) \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}
00217     
00218     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs>
00219     \textcolor{keyword}{inline} \textcolor{keyword}{const} Rhs& solve(\textcolor{keyword}{const} Rhs& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} b; \}
00220     
00221     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} info() \{ \textcolor{keywordflow}{return} \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success}; \}
00222 \};
00223 
00224 \} \textcolor{comment}{// end namespace Eigen}
00225 
00226 \textcolor{preprocessor}{#endif // EIGEN\_BASIC\_PRECONDITIONERS\_H}
\end{DoxyCode}
