\hypertarget{eigen_2unsupported_2_eigen_2src_2_non_linear_optimization_2_hybrid_non_linear_solver_8h_source}{}\section{eigen/unsupported/\+Eigen/src/\+Non\+Linear\+Optimization/\+Hybrid\+Non\+Linear\+Solver.h}
\label{eigen_2unsupported_2_eigen_2src_2_non_linear_optimization_2_hybrid_non_linear_solver_8h_source}\index{Hybrid\+Non\+Linear\+Solver.\+h@{Hybrid\+Non\+Linear\+Solver.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// -*- coding: utf-8}
00002 \textcolor{comment}{// vim: set fileencoding=utf-8}
00003 
00004 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00005 \textcolor{comment}{// for linear algebra.}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// Copyright (C) 2009 Thomas Capricelli <orzel@freehackers.org>}
00008 \textcolor{comment}{//}
00009 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00010 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00011 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00012 
00013 \textcolor{preprocessor}{#ifndef EIGEN\_HYBRIDNONLINEARSOLVER\_H}
00014 \textcolor{preprocessor}{#define EIGEN\_HYBRIDNONLINEARSOLVER\_H}
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00017 
00018 \textcolor{keyword}{namespace }HybridNonLinearSolverSpace \{ 
00019     \textcolor{keyword}{enum} Status \{
00020         Running = -1,
00021         ImproperInputParameters = 0,
00022         RelativeErrorTooSmall = 1,
00023         TooManyFunctionEvaluation = 2,
00024         TolTooSmall = 3,
00025         NotMakingProgressJacobian = 4,
00026         NotMakingProgressIterations = 5,
00027         UserAsked = 6
00028     \};
00029 \}
00030 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar=\textcolor{keywordtype}{double}>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_non_linear_optimization_2_hybrid_non_linear_solver_8h_source_l00043}\hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{00043} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{HybridNonLinearSolver}
00044 \{
00045 \textcolor{keyword}{public}:
00046     \textcolor{keyword}{typedef} DenseIndex \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00047 
00048     \hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{HybridNonLinearSolver}(FunctorType &\_functor)
00049         : functor(\_functor) \{ nfev=njev=iter = 0;  fnorm= 0.; useExternalScaling=\textcolor{keyword}{false};\}
00050 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_non_linear_optimization_2_hybrid_non_linear_solver_8h_source_l00051}\hyperlink{struct_eigen_1_1_hybrid_non_linear_solver_1_1_parameters}{00051}     \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_hybrid_non_linear_solver_1_1_parameters}{Parameters} \{
00052         \hyperlink{struct_eigen_1_1_hybrid_non_linear_solver_1_1_parameters}{Parameters}()
00053             : factor(Scalar(100.))
00054             , maxfev(1000)
00055             , xtol(std::sqrt(\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}()))
00056             , nb\_of\_subdiagonals(-1)
00057             , nb\_of\_superdiagonals(-1)
00058             , epsfcn(Scalar(0.)) \{\}
00059         Scalar factor;
00060         Index maxfev;   \textcolor{comment}{// maximum number of function evaluation}
00061         Scalar xtol;
00062         Index nb\_of\_subdiagonals;
00063         Index nb\_of\_superdiagonals;
00064         Scalar epsfcn;
00065     \};
00066     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >} \hyperlink{group___core___module}{FVectorType};
00067     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, Dynamic >} 
      \hyperlink{group___core___module}{JacobianType};
00068     \textcolor{comment}{/* TODO: if eigen provides a triangular storage, use it here */}
00069     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, Dynamic >} 
      \hyperlink{group___core___module}{UpperTriangularType};
00070 
00071     HybridNonLinearSolverSpace::Status hybrj1(
00072             FVectorType  &x,
00073             \textcolor{keyword}{const} Scalar tol = std::sqrt(\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}())
00074             );
00075 
00076     HybridNonLinearSolverSpace::Status solveInit(FVectorType  &x);
00077     HybridNonLinearSolverSpace::Status solveOneStep(FVectorType  &x);
00078     HybridNonLinearSolverSpace::Status solve(FVectorType  &x);
00079 
00080     HybridNonLinearSolverSpace::Status hybrd1(
00081             FVectorType  &x,
00082             \textcolor{keyword}{const} Scalar tol = std::sqrt(\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}())
00083             );
00084 
00085     HybridNonLinearSolverSpace::Status solveNumericalDiffInit(FVectorType  &x);
00086     HybridNonLinearSolverSpace::Status solveNumericalDiffOneStep(FVectorType  &x);
00087     HybridNonLinearSolverSpace::Status solveNumericalDiff(FVectorType  &x);
00088 
00089     \textcolor{keywordtype}{void} resetParameters(\textcolor{keywordtype}{void}) \{ parameters = \hyperlink{struct_eigen_1_1_hybrid_non_linear_solver_1_1_parameters}{Parameters}(); \}
00090     \hyperlink{struct_eigen_1_1_hybrid_non_linear_solver_1_1_parameters}{Parameters} parameters;
00091     FVectorType  fvec, qtf, diag;
00092     JacobianType fjac;
00093     UpperTriangularType R;
00094     Index nfev;
00095     Index njev;
00096     Index iter;
00097     Scalar fnorm;
00098     \textcolor{keywordtype}{bool} useExternalScaling; 
00099 \textcolor{keyword}{private}:
00100     FunctorType &functor;
00101     Index n;
00102     Scalar sum;
00103     \textcolor{keywordtype}{bool} sing;
00104     Scalar temp;
00105     Scalar delta;
00106     \textcolor{keywordtype}{bool} jeval;
00107     Index ncsuc;
00108     Scalar ratio;
00109     Scalar pnorm, xnorm, fnorm1;
00110     Index nslow1, nslow2;
00111     Index ncfail;
00112     Scalar actred, prered;
00113     FVectorType wa1, wa2, wa3, wa4;
00114 
00115     \hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{HybridNonLinearSolver}& operator=(\textcolor{keyword}{const} 
      \hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{HybridNonLinearSolver}&);
00116 \};
00117 
00118 
00119 
00120 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00121 HybridNonLinearSolverSpace::Status
00122 \hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{HybridNonLinearSolver<FunctorType,Scalar>::hybrj1}(
00123         \hyperlink{group___core___module}{FVectorType}  &x,
00124         \textcolor{keyword}{const} Scalar tol
00125         )
00126 \{
00127     n = x.size();
00128 
00129     \textcolor{comment}{/* check the input parameters for errors. */}
00130     \textcolor{keywordflow}{if} (n <= 0 || tol < 0.)
00131         \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::ImproperInputParameters;
00132 
00133     resetParameters();
00134     parameters.maxfev = 100*(n+1);
00135     parameters.xtol = tol;
00136     diag.setConstant(n, 1.);
00137     useExternalScaling = \textcolor{keyword}{true};
00138     \textcolor{keywordflow}{return} solve(x);
00139 \}
00140 
00141 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00142 HybridNonLinearSolverSpace::Status
00143 \hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{HybridNonLinearSolver<FunctorType,Scalar>::solveInit}(
      \hyperlink{group___core___module}{FVectorType}  &x)
00144 \{
00145     n = x.size();
00146 
00147     wa1.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(n); wa2.resize(n); wa3.resize(n); wa4.resize(n);
00148     fvec.resize(n);
00149     qtf.resize(n);
00150     fjac.resize(n, n);
00151     \textcolor{keywordflow}{if} (!useExternalScaling)
00152         diag.resize(n);
00153     eigen\_assert( (!useExternalScaling || diag.size()==n) && \textcolor{stringliteral}{"When useExternalScaling is set, the caller
       must provide a valid 'diag'"});
00154 
00155     \textcolor{comment}{/* Function Body */}
00156     nfev = 0;
00157     njev = 0;
00158 
00159     \textcolor{comment}{/*     check the input parameters for errors. */}
00160     \textcolor{keywordflow}{if} (n <= 0 || parameters.xtol < 0. || parameters.maxfev <= 0 || parameters.factor <= 0. )
00161         \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::ImproperInputParameters;
00162     \textcolor{keywordflow}{if} (useExternalScaling)
00163         \textcolor{keywordflow}{for} (Index j = 0; j < n; ++j)
00164             \textcolor{keywordflow}{if} (diag[j] <= 0.)
00165                 \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::ImproperInputParameters;
00166 
00167     \textcolor{comment}{/*     evaluate the function at the starting point */}
00168     \textcolor{comment}{/*     and calculate its norm. */}
00169     nfev = 1;
00170     \textcolor{keywordflow}{if} ( functor(x, fvec) < 0)
00171         \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::UserAsked;
00172     fnorm = fvec.stableNorm();
00173 
00174     \textcolor{comment}{/*     initialize iteration counter and monitors. */}
00175     iter = 1;
00176     ncsuc = 0;
00177     ncfail = 0;
00178     nslow1 = 0;
00179     nslow2 = 0;
00180 
00181     \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::Running;
00182 \}
00183 
00184 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00185 HybridNonLinearSolverSpace::Status
00186 \hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{HybridNonLinearSolver<FunctorType,Scalar>::solveOneStep}
      (\hyperlink{group___core___module}{FVectorType}  &x)
00187 \{
00188     \textcolor{keyword}{using} std::abs;
00189     
00190     eigen\_assert(x.size()==n); \textcolor{comment}{// check the caller is not cheating us}
00191 
00192     Index j;
00193     std::vector<JacobiRotation<Scalar> > v\_givens(n), w\_givens(n);
00194 
00195     jeval = \textcolor{keyword}{true};
00196 
00197     \textcolor{comment}{/* calculate the jacobian matrix. */}
00198     \textcolor{keywordflow}{if} ( functor.df(x, fjac) < 0)
00199         \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::UserAsked;
00200     ++njev;
00201 
00202     wa2 = fjac.colwise().blueNorm();
00203 
00204     \textcolor{comment}{/* on the first iteration and if external scaling is not used, scale according */}
00205     \textcolor{comment}{/* to the norms of the columns of the initial jacobian. */}
00206     \textcolor{keywordflow}{if} (iter == 1) \{
00207         \textcolor{keywordflow}{if} (!useExternalScaling)
00208             \textcolor{keywordflow}{for} (j = 0; j < n; ++j)
00209                 diag[j] = (wa2[j]==0.) ? 1. : wa2[j];
00210 
00211         \textcolor{comment}{/* on the first iteration, calculate the norm of the scaled x */}
00212         \textcolor{comment}{/* and initialize the step bound delta. */}
00213         xnorm = diag.cwiseProduct(x).stableNorm();
00214         delta = parameters.factor * xnorm;
00215         \textcolor{keywordflow}{if} (delta == 0.)
00216             delta = parameters.factor;
00217     \}
00218 
00219     \textcolor{comment}{/* compute the qr factorization of the jacobian. */}
00220     \hyperlink{group___q_r___module_class_eigen_1_1_householder_q_r}{HouseholderQR<JacobianType>} qrfac(fjac); \textcolor{comment}{// no pivoting:}
00221 
00222     \textcolor{comment}{/* copy the triangular factor of the qr factorization into r. */}
00223     R = qrfac.\hyperlink{group___q_r___module_ae837f2fb30099212c53b3042c7d699c9}{matrixQR}();
00224 
00225     \textcolor{comment}{/* accumulate the orthogonal factor in fjac. */}
00226     fjac = qrfac.\hyperlink{group___q_r___module_affd506c10ef2d25f56e7b1f9f25ff885}{householderQ}();
00227 
00228     \textcolor{comment}{/* form (q transpose)*fvec and store in qtf. */}
00229     qtf = fjac.transpose() * fvec;
00230 
00231     \textcolor{comment}{/* rescale if necessary. */}
00232     \textcolor{keywordflow}{if} (!useExternalScaling)
00233         diag = diag.cwiseMax(wa2);
00234 
00235     \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
00236         \textcolor{comment}{/* determine the direction p. */}
00237         internal::dogleg<Scalar>(R, diag, qtf, delta, wa1);
00238 
00239         \textcolor{comment}{/* store the direction p and x + p. calculate the norm of p. */}
00240         wa1 = -wa1;
00241         wa2 = x + wa1;
00242         pnorm = diag.cwiseProduct(wa1).stableNorm();
00243 
00244         \textcolor{comment}{/* on the first iteration, adjust the initial step bound. */}
00245         \textcolor{keywordflow}{if} (iter == 1)
00246             delta = (std::min)(delta,pnorm);
00247 
00248         \textcolor{comment}{/* evaluate the function at x + p and calculate its norm. */}
00249         \textcolor{keywordflow}{if} ( functor(wa2, wa4) < 0)
00250             \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::UserAsked;
00251         ++nfev;
00252         fnorm1 = wa4.stableNorm();
00253 
00254         \textcolor{comment}{/* compute the scaled actual reduction. */}
00255         actred = -1.;
00256         \textcolor{keywordflow}{if} (fnorm1 < fnorm) \textcolor{comment}{/* Computing 2nd power */}
00257             actred = 1. - numext::abs2(fnorm1 / fnorm);
00258 
00259         \textcolor{comment}{/* compute the scaled predicted reduction. */}
00260         wa3 = R.template triangularView<Upper>()*wa1 + qtf;
00261         temp = wa3.stableNorm();
00262         prered = 0.;
00263         \textcolor{keywordflow}{if} (temp < fnorm) \textcolor{comment}{/* Computing 2nd power */}
00264             prered = 1. - numext::abs2(temp / fnorm);
00265 
00266         \textcolor{comment}{/* compute the ratio of the actual to the predicted reduction. */}
00267         ratio = 0.;
00268         \textcolor{keywordflow}{if} (prered > 0.)
00269             ratio = actred / prered;
00270 
00271         \textcolor{comment}{/* update the step bound. */}
00272         \textcolor{keywordflow}{if} (ratio < Scalar(.1)) \{
00273             ncsuc = 0;
00274             ++ncfail;
00275             delta = Scalar(.5) * delta;
00276         \} \textcolor{keywordflow}{else} \{
00277             ncfail = 0;
00278             ++ncsuc;
00279             \textcolor{keywordflow}{if} (ratio >= Scalar(.5) || ncsuc > 1)
00280                 delta = (std::max)(delta, pnorm / Scalar(.5));
00281             \textcolor{keywordflow}{if} (abs(ratio - 1.) <= Scalar(.1)) \{
00282                 delta = pnorm / Scalar(.5);
00283             \}
00284         \}
00285 
00286         \textcolor{comment}{/* test for successful iteration. */}
00287         \textcolor{keywordflow}{if} (ratio >= Scalar(1e-4)) \{
00288             \textcolor{comment}{/* successful iteration. update x, fvec, and their norms. */}
00289             x = wa2;
00290             wa2 = diag.cwiseProduct(x);
00291             fvec = wa4;
00292             xnorm = wa2.stableNorm();
00293             fnorm = fnorm1;
00294             ++iter;
00295         \}
00296 
00297         \textcolor{comment}{/* determine the progress of the iteration. */}
00298         ++nslow1;
00299         \textcolor{keywordflow}{if} (actred >= Scalar(.001))
00300             nslow1 = 0;
00301         \textcolor{keywordflow}{if} (jeval)
00302             ++nslow2;
00303         \textcolor{keywordflow}{if} (actred >= Scalar(.1))
00304             nslow2 = 0;
00305 
00306         \textcolor{comment}{/* test for convergence. */}
00307         \textcolor{keywordflow}{if} (delta <= parameters.xtol * xnorm || fnorm == 0.)
00308             \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::RelativeErrorTooSmall;
00309 
00310         \textcolor{comment}{/* tests for termination and stringent tolerances. */}
00311         \textcolor{keywordflow}{if} (nfev >= parameters.maxfev)
00312             \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::TooManyFunctionEvaluation;
00313         \textcolor{keywordflow}{if} (Scalar(.1) * (std::max)(Scalar(.1) * delta, pnorm) <= 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}() * xnorm)
00314             \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::TolTooSmall;
00315         \textcolor{keywordflow}{if} (nslow2 == 5)
00316             \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::NotMakingProgressJacobian;
00317         \textcolor{keywordflow}{if} (nslow1 == 10)
00318             \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::NotMakingProgressIterations;
00319 
00320         \textcolor{comment}{/* criterion for recalculating jacobian. */}
00321         \textcolor{keywordflow}{if} (ncfail == 2)
00322             \textcolor{keywordflow}{break}; \textcolor{comment}{// leave inner loop and go for the next outer loop iteration}
00323 
00324         \textcolor{comment}{/* calculate the rank one modification to the jacobian */}
00325         \textcolor{comment}{/* and update qtf if necessary. */}
00326         wa1 = diag.cwiseProduct( diag.cwiseProduct(wa1)/pnorm );
00327         wa2 = fjac.transpose() * wa4;
00328         \textcolor{keywordflow}{if} (ratio >= Scalar(1e-4))
00329             qtf = wa2;
00330         wa2 = (wa2-wa3)/pnorm;
00331 
00332         \textcolor{comment}{/* compute the qr factorization of the updated jacobian. */}
00333         internal::r1updt<Scalar>(R, wa1, v\_givens, w\_givens, wa2, wa3, &sing);
00334         internal::r1mpyq<Scalar>(n, n, fjac.data(), v\_givens, w\_givens);
00335         internal::r1mpyq<Scalar>(1, n, qtf.data(), v\_givens, w\_givens);
00336 
00337         jeval = \textcolor{keyword}{false};
00338     \}
00339     \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::Running;
00340 \}
00341 
00342 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00343 HybridNonLinearSolverSpace::Status
00344 \hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{HybridNonLinearSolver<FunctorType,Scalar>::solve}(
      \hyperlink{group___core___module}{FVectorType}  &x)
00345 \{
00346     HybridNonLinearSolverSpace::Status status = solveInit(x);
00347     \textcolor{keywordflow}{if} (status==HybridNonLinearSolverSpace::ImproperInputParameters)
00348         \textcolor{keywordflow}{return} status;
00349     \textcolor{keywordflow}{while} (status==HybridNonLinearSolverSpace::Running)
00350         status = solveOneStep(x);
00351     \textcolor{keywordflow}{return} status;
00352 \}
00353 
00354 
00355 
00356 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00357 HybridNonLinearSolverSpace::Status
00358 \hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{HybridNonLinearSolver<FunctorType,Scalar>::hybrd1}(
00359         \hyperlink{group___core___module}{FVectorType}  &x,
00360         \textcolor{keyword}{const} Scalar tol
00361         )
00362 \{
00363     n = x.size();
00364 
00365     \textcolor{comment}{/* check the input parameters for errors. */}
00366     \textcolor{keywordflow}{if} (n <= 0 || tol < 0.)
00367         \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::ImproperInputParameters;
00368 
00369     resetParameters();
00370     parameters.maxfev = 200*(n+1);
00371     parameters.xtol = tol;
00372 
00373     diag.setConstant(n, 1.);
00374     useExternalScaling = \textcolor{keyword}{true};
00375     \textcolor{keywordflow}{return} solveNumericalDiff(x);
00376 \}
00377 
00378 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00379 HybridNonLinearSolverSpace::Status
00380 \hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{HybridNonLinearSolver<FunctorType,Scalar>::solveNumericalDiffInit}
      (\hyperlink{group___core___module}{FVectorType}  &x)
00381 \{
00382     n = x.size();
00383 
00384     \textcolor{keywordflow}{if} (parameters.nb\_of\_subdiagonals<0) parameters.nb\_of\_subdiagonals= n-1;
00385     \textcolor{keywordflow}{if} (parameters.nb\_of\_superdiagonals<0) parameters.nb\_of\_superdiagonals= n-1;
00386 
00387     wa1.resize(n); wa2.resize(n); wa3.resize(n); wa4.resize(n);
00388     qtf.resize(n);
00389     fjac.resize(n, n);
00390     fvec.resize(n);
00391     \textcolor{keywordflow}{if} (!useExternalScaling)
00392         diag.resize(n);
00393     eigen\_assert( (!useExternalScaling || diag.size()==n) && \textcolor{stringliteral}{"When useExternalScaling is set, the caller
       must provide a valid 'diag'"});
00394 
00395     \textcolor{comment}{/* Function Body */}
00396     nfev = 0;
00397     njev = 0;
00398 
00399     \textcolor{comment}{/*     check the input parameters for errors. */}
00400     \textcolor{keywordflow}{if} (n <= 0 || parameters.xtol < 0. || parameters.maxfev <= 0 || parameters.nb\_of\_subdiagonals< 0 || 
      parameters.nb\_of\_superdiagonals< 0 || parameters.factor <= 0. )
00401         \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::ImproperInputParameters;
00402     \textcolor{keywordflow}{if} (useExternalScaling)
00403         \textcolor{keywordflow}{for} (Index j = 0; j < n; ++j)
00404             \textcolor{keywordflow}{if} (diag[j] <= 0.)
00405                 \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::ImproperInputParameters;
00406 
00407     \textcolor{comment}{/*     evaluate the function at the starting point */}
00408     \textcolor{comment}{/*     and calculate its norm. */}
00409     nfev = 1;
00410     \textcolor{keywordflow}{if} ( functor(x, fvec) < 0)
00411         \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::UserAsked;
00412     fnorm = fvec.stableNorm();
00413 
00414     \textcolor{comment}{/*     initialize iteration counter and monitors. */}
00415     iter = 1;
00416     ncsuc = 0;
00417     ncfail = 0;
00418     nslow1 = 0;
00419     nslow2 = 0;
00420 
00421     \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::Running;
00422 \}
00423 
00424 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00425 HybridNonLinearSolverSpace::Status
00426 \hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{HybridNonLinearSolver<FunctorType,Scalar>::solveNumericalDiffOneStep}
      (\hyperlink{group___core___module}{FVectorType}  &x)
00427 \{
00428     \textcolor{keyword}{using} std::sqrt;
00429     \textcolor{keyword}{using} std::abs;
00430     
00431     assert(x.size()==n); \textcolor{comment}{// check the caller is not cheating us}
00432 
00433     Index j;
00434     std::vector<JacobiRotation<Scalar> > v\_givens(n), w\_givens(n);
00435 
00436     jeval = \textcolor{keyword}{true};
00437     \textcolor{keywordflow}{if} (parameters.nb\_of\_subdiagonals<0) parameters.nb\_of\_subdiagonals= n-1;
00438     \textcolor{keywordflow}{if} (parameters.nb\_of\_superdiagonals<0) parameters.nb\_of\_superdiagonals= n-1;
00439 
00440     \textcolor{comment}{/* calculate the jacobian matrix. */}
00441     \textcolor{keywordflow}{if} (internal::fdjac1(functor, x, fvec, fjac, parameters.nb\_of\_subdiagonals, parameters.
      nb\_of\_superdiagonals, parameters.epsfcn) <0)
00442         \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::UserAsked;
00443     nfev += (std::min)(parameters.nb\_of\_subdiagonals+parameters.nb\_of\_superdiagonals+ 1, n);
00444 
00445     wa2 = fjac.colwise().blueNorm();
00446 
00447     \textcolor{comment}{/* on the first iteration and if external scaling is not used, scale according */}
00448     \textcolor{comment}{/* to the norms of the columns of the initial jacobian. */}
00449     \textcolor{keywordflow}{if} (iter == 1) \{
00450         \textcolor{keywordflow}{if} (!useExternalScaling)
00451             \textcolor{keywordflow}{for} (j = 0; j < n; ++j)
00452                 diag[j] = (wa2[j]==0.) ? 1. : wa2[j];
00453 
00454         \textcolor{comment}{/* on the first iteration, calculate the norm of the scaled x */}
00455         \textcolor{comment}{/* and initialize the step bound delta. */}
00456         xnorm = diag.cwiseProduct(x).stableNorm();
00457         delta = parameters.factor * xnorm;
00458         \textcolor{keywordflow}{if} (delta == 0.)
00459             delta = parameters.factor;
00460     \}
00461 
00462     \textcolor{comment}{/* compute the qr factorization of the jacobian. */}
00463     \hyperlink{group___q_r___module_class_eigen_1_1_householder_q_r}{HouseholderQR<JacobianType>} qrfac(fjac); \textcolor{comment}{// no pivoting:}
00464 
00465     \textcolor{comment}{/* copy the triangular factor of the qr factorization into r. */}
00466     R = qrfac.\hyperlink{group___q_r___module_ae837f2fb30099212c53b3042c7d699c9}{matrixQR}();
00467 
00468     \textcolor{comment}{/* accumulate the orthogonal factor in fjac. */}
00469     fjac = qrfac.\hyperlink{group___q_r___module_affd506c10ef2d25f56e7b1f9f25ff885}{householderQ}();
00470 
00471     \textcolor{comment}{/* form (q transpose)*fvec and store in qtf. */}
00472     qtf = fjac.transpose() * fvec;
00473 
00474     \textcolor{comment}{/* rescale if necessary. */}
00475     \textcolor{keywordflow}{if} (!useExternalScaling)
00476         diag = diag.cwiseMax(wa2);
00477 
00478     \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
00479         \textcolor{comment}{/* determine the direction p. */}
00480         internal::dogleg<Scalar>(R, diag, qtf, delta, wa1);
00481 
00482         \textcolor{comment}{/* store the direction p and x + p. calculate the norm of p. */}
00483         wa1 = -wa1;
00484         wa2 = x + wa1;
00485         pnorm = diag.cwiseProduct(wa1).stableNorm();
00486 
00487         \textcolor{comment}{/* on the first iteration, adjust the initial step bound. */}
00488         \textcolor{keywordflow}{if} (iter == 1)
00489             delta = (std::min)(delta,pnorm);
00490 
00491         \textcolor{comment}{/* evaluate the function at x + p and calculate its norm. */}
00492         \textcolor{keywordflow}{if} ( functor(wa2, wa4) < 0)
00493             \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::UserAsked;
00494         ++nfev;
00495         fnorm1 = wa4.stableNorm();
00496 
00497         \textcolor{comment}{/* compute the scaled actual reduction. */}
00498         actred = -1.;
00499         \textcolor{keywordflow}{if} (fnorm1 < fnorm) \textcolor{comment}{/* Computing 2nd power */}
00500             actred = 1. - numext::abs2(fnorm1 / fnorm);
00501 
00502         \textcolor{comment}{/* compute the scaled predicted reduction. */}
00503         wa3 = R.template triangularView<Upper>()*wa1 + qtf;
00504         temp = wa3.stableNorm();
00505         prered = 0.;
00506         \textcolor{keywordflow}{if} (temp < fnorm) \textcolor{comment}{/* Computing 2nd power */}
00507             prered = 1. - numext::abs2(temp / fnorm);
00508 
00509         \textcolor{comment}{/* compute the ratio of the actual to the predicted reduction. */}
00510         ratio = 0.;
00511         \textcolor{keywordflow}{if} (prered > 0.)
00512             ratio = actred / prered;
00513 
00514         \textcolor{comment}{/* update the step bound. */}
00515         \textcolor{keywordflow}{if} (ratio < Scalar(.1)) \{
00516             ncsuc = 0;
00517             ++ncfail;
00518             delta = Scalar(.5) * delta;
00519         \} \textcolor{keywordflow}{else} \{
00520             ncfail = 0;
00521             ++ncsuc;
00522             \textcolor{keywordflow}{if} (ratio >= Scalar(.5) || ncsuc > 1)
00523                 delta = (std::max)(delta, pnorm / Scalar(.5));
00524             \textcolor{keywordflow}{if} (abs(ratio - 1.) <= Scalar(.1)) \{
00525                 delta = pnorm / Scalar(.5);
00526             \}
00527         \}
00528 
00529         \textcolor{comment}{/* test for successful iteration. */}
00530         \textcolor{keywordflow}{if} (ratio >= Scalar(1e-4)) \{
00531             \textcolor{comment}{/* successful iteration. update x, fvec, and their norms. */}
00532             x = wa2;
00533             wa2 = diag.cwiseProduct(x);
00534             fvec = wa4;
00535             xnorm = wa2.stableNorm();
00536             fnorm = fnorm1;
00537             ++iter;
00538         \}
00539 
00540         \textcolor{comment}{/* determine the progress of the iteration. */}
00541         ++nslow1;
00542         \textcolor{keywordflow}{if} (actred >= Scalar(.001))
00543             nslow1 = 0;
00544         \textcolor{keywordflow}{if} (jeval)
00545             ++nslow2;
00546         \textcolor{keywordflow}{if} (actred >= Scalar(.1))
00547             nslow2 = 0;
00548 
00549         \textcolor{comment}{/* test for convergence. */}
00550         \textcolor{keywordflow}{if} (delta <= parameters.xtol * xnorm || fnorm == 0.)
00551             \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::RelativeErrorTooSmall;
00552 
00553         \textcolor{comment}{/* tests for termination and stringent tolerances. */}
00554         \textcolor{keywordflow}{if} (nfev >= parameters.maxfev)
00555             \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::TooManyFunctionEvaluation;
00556         \textcolor{keywordflow}{if} (Scalar(.1) * (std::max)(Scalar(.1) * delta, pnorm) <= 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}() * xnorm)
00557             \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::TolTooSmall;
00558         \textcolor{keywordflow}{if} (nslow2 == 5)
00559             \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::NotMakingProgressJacobian;
00560         \textcolor{keywordflow}{if} (nslow1 == 10)
00561             \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::NotMakingProgressIterations;
00562 
00563         \textcolor{comment}{/* criterion for recalculating jacobian. */}
00564         \textcolor{keywordflow}{if} (ncfail == 2)
00565             \textcolor{keywordflow}{break}; \textcolor{comment}{// leave inner loop and go for the next outer loop iteration}
00566 
00567         \textcolor{comment}{/* calculate the rank one modification to the jacobian */}
00568         \textcolor{comment}{/* and update qtf if necessary. */}
00569         wa1 = diag.cwiseProduct( diag.cwiseProduct(wa1)/pnorm );
00570         wa2 = fjac.transpose() * wa4;
00571         \textcolor{keywordflow}{if} (ratio >= Scalar(1e-4))
00572             qtf = wa2;
00573         wa2 = (wa2-wa3)/pnorm;
00574 
00575         \textcolor{comment}{/* compute the qr factorization of the updated jacobian. */}
00576         internal::r1updt<Scalar>(R, wa1, v\_givens, w\_givens, wa2, wa3, &sing);
00577         internal::r1mpyq<Scalar>(n, n, fjac.data(), v\_givens, w\_givens);
00578         internal::r1mpyq<Scalar>(1, n, qtf.data(), v\_givens, w\_givens);
00579 
00580         jeval = \textcolor{keyword}{false};
00581     \}
00582     \textcolor{keywordflow}{return} HybridNonLinearSolverSpace::Running;
00583 \}
00584 
00585 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00586 HybridNonLinearSolverSpace::Status
00587 \hyperlink{class_eigen_1_1_hybrid_non_linear_solver}{HybridNonLinearSolver<FunctorType,Scalar>::solveNumericalDiff}
      (\hyperlink{group___core___module}{FVectorType}  &x)
00588 \{
00589     HybridNonLinearSolverSpace::Status status = solveNumericalDiffInit(x);
00590     \textcolor{keywordflow}{if} (status==HybridNonLinearSolverSpace::ImproperInputParameters)
00591         \textcolor{keywordflow}{return} status;
00592     \textcolor{keywordflow}{while} (status==HybridNonLinearSolverSpace::Running)
00593         status = solveNumericalDiffOneStep(x);
00594     \textcolor{keywordflow}{return} status;
00595 \}
00596 
00597 \} \textcolor{comment}{// end namespace Eigen}
00598 
00599 \textcolor{preprocessor}{#endif // EIGEN\_HYBRIDNONLINEARSOLVER\_H}
00600 
00601 \textcolor{comment}{//vim: ai ts=4 sts=4 et sw=4}
\end{DoxyCode}
