\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_non_linear_optimization_2_levenberg_marquardt_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+Non\+Linear\+Optimization/\+Levenberg\+Marquardt.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_non_linear_optimization_2_levenberg_marquardt_8h_source}\index{Levenberg\+Marquardt.\+h@{Levenberg\+Marquardt.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// -*- coding: utf-8}
00002 \textcolor{comment}{// vim: set fileencoding=utf-8}
00003 
00004 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00005 \textcolor{comment}{// for linear algebra.}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// Copyright (C) 2009 Thomas Capricelli <orzel@freehackers.org>}
00008 \textcolor{comment}{//}
00009 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00010 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00011 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00012 
00013 \textcolor{preprocessor}{#ifndef EIGEN\_LEVENBERGMARQUARDT\_\_H}
00014 \textcolor{preprocessor}{#define EIGEN\_LEVENBERGMARQUARDT\_\_H}
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00017 
00018 \textcolor{keyword}{namespace }LevenbergMarquardtSpace \{
00019     \textcolor{keyword}{enum} Status \{
00020         NotStarted = -2,
00021         Running = -1,
00022         ImproperInputParameters = 0,
00023         RelativeReductionTooSmall = 1,
00024         RelativeErrorTooSmall = 2,
00025         RelativeErrorAndReductionTooSmall = 3,
00026         CosinusTooSmall = 4,
00027         TooManyFunctionEvaluation = 5,
00028         FtolTooSmall = 6,
00029         XtolTooSmall = 7,
00030         GtolTooSmall = 8,
00031         UserAsked = 9
00032     \};
00033 \}
00034 
00035 
00036 
00045 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar=\textcolor{keywordtype}{double}>
00046 \textcolor{keyword}{class }LevenbergMarquardt
00047 \{
00048     \textcolor{keyword}{static} Scalar sqrt\_epsilon()
00049     \{
00050       \textcolor{keyword}{using} std::sqrt;
00051       \textcolor{keywordflow}{return} sqrt(NumTraits<Scalar>::epsilon());
00052     \}
00053     
00054 \textcolor{keyword}{public}:
00055     LevenbergMarquardt(FunctorType &\_functor)
00056         : functor(\_functor) \{ nfev = njev = iter = 0;  fnorm = gnorm = 0.; useExternalScaling=\textcolor{keyword}{false}; \}
00057 
00058     \textcolor{keyword}{typedef} DenseIndex \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00059     
00060     \textcolor{keyword}{struct }Parameters \{
00061         Parameters()
00062             : factor(Scalar(100.))
00063             , maxfev(400)
00064             , ftol(sqrt\_epsilon())
00065             , xtol(sqrt\_epsilon())
00066             , gtol(Scalar(0.))
00067             , epsfcn(Scalar(0.)) \{\}
00068         Scalar factor;
00069         Index maxfev;   \textcolor{comment}{// maximum number of function evaluation}
00070         Scalar ftol;
00071         Scalar xtol;
00072         Scalar gtol;
00073         Scalar epsfcn;
00074     \};
00075 
00076     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >} FVectorType;
00077     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, Dynamic >} JacobianType;
00078 
00079     LevenbergMarquardtSpace::Status lmder1(
00080             FVectorType &x,
00081             \textcolor{keyword}{const} Scalar tol = sqrt\_epsilon()
00082             );
00083 
00084     LevenbergMarquardtSpace::Status minimize(FVectorType &x);
00085     LevenbergMarquardtSpace::Status minimizeInit(FVectorType &x);
00086     LevenbergMarquardtSpace::Status minimizeOneStep(FVectorType &x);
00087 
00088     \textcolor{keyword}{static} LevenbergMarquardtSpace::Status lmdif1(
00089             FunctorType &functor,
00090             FVectorType &x,
00091             Index *nfev,
00092             \textcolor{keyword}{const} Scalar tol = sqrt\_epsilon()
00093             );
00094 
00095     LevenbergMarquardtSpace::Status lmstr1(
00096             FVectorType  &x,
00097             \textcolor{keyword}{const} Scalar tol = sqrt\_epsilon()
00098             );
00099 
00100     LevenbergMarquardtSpace::Status minimizeOptimumStorage(FVectorType  &x);
00101     LevenbergMarquardtSpace::Status minimizeOptimumStorageInit(FVectorType  &x);
00102     LevenbergMarquardtSpace::Status minimizeOptimumStorageOneStep(FVectorType  &x);
00103 
00104     \textcolor{keywordtype}{void} resetParameters(\textcolor{keywordtype}{void}) \{ parameters = Parameters(); \}
00105 
00106     Parameters parameters;
00107     FVectorType  fvec, qtf, diag;
00108     JacobianType fjac;
00109     PermutationMatrix<Dynamic,Dynamic> permutation;
00110     Index nfev;
00111     Index njev;
00112     Index iter;
00113     Scalar fnorm, gnorm;
00114     \textcolor{keywordtype}{bool} useExternalScaling; 
00115 
00116     Scalar lm\_param(\textcolor{keywordtype}{void}) \{ \textcolor{keywordflow}{return} par; \}
00117 \textcolor{keyword}{private}:
00118     
00119     FunctorType &functor;
00120     Index n;
00121     Index m;
00122     FVectorType wa1, wa2, wa3, wa4;
00123 
00124     Scalar par, sum;
00125     Scalar temp, temp1, temp2;
00126     Scalar delta;
00127     Scalar ratio;
00128     Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;
00129 
00130     LevenbergMarquardt& operator=(\textcolor{keyword}{const} LevenbergMarquardt&);
00131 \};
00132 
00133 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00134 LevenbergMarquardtSpace::Status
00135 LevenbergMarquardt<FunctorType,Scalar>::lmder1(
00136         FVectorType  &x,
00137         \textcolor{keyword}{const} Scalar tol
00138         )
00139 \{
00140     n = x.size();
00141     m = functor.values();
00142 
00143     \textcolor{comment}{/* check the input parameters for errors. */}
00144     \textcolor{keywordflow}{if} (n <= 0 || m < n || tol < 0.)
00145         \textcolor{keywordflow}{return} LevenbergMarquardtSpace::ImproperInputParameters;
00146 
00147     resetParameters();
00148     parameters.ftol = tol;
00149     parameters.xtol = tol;
00150     parameters.maxfev = 100*(n+1);
00151 
00152     \textcolor{keywordflow}{return} minimize(x);
00153 \}
00154 
00155 
00156 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00157 LevenbergMarquardtSpace::Status
00158 LevenbergMarquardt<FunctorType,Scalar>::minimize(FVectorType  &x)
00159 \{
00160     LevenbergMarquardtSpace::Status status = minimizeInit(x);
00161     \textcolor{keywordflow}{if} (status==LevenbergMarquardtSpace::ImproperInputParameters)
00162         \textcolor{keywordflow}{return} status;
00163     \textcolor{keywordflow}{do} \{
00164         status = minimizeOneStep(x);
00165     \} \textcolor{keywordflow}{while} (status==LevenbergMarquardtSpace::Running);
00166     \textcolor{keywordflow}{return} status;
00167 \}
00168 
00169 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00170 LevenbergMarquardtSpace::Status
00171 LevenbergMarquardt<FunctorType,Scalar>::minimizeInit(FVectorType  &x)
00172 \{
00173     n = x.size();
00174     m = functor.values();
00175 
00176     wa1.resize(n); wa2.resize(n); wa3.resize(n);
00177     wa4.resize(m);
00178     fvec.resize(m);
00179     fjac.resize(m, n);
00180     \textcolor{keywordflow}{if} (!useExternalScaling)
00181         diag.resize(n);
00182     eigen\_assert( (!useExternalScaling || diag.size()==n) && \textcolor{stringliteral}{"When useExternalScaling is set, the caller
       must provide a valid 'diag'"});
00183     qtf.resize(n);
00184 
00185     \textcolor{comment}{/* Function Body */}
00186     nfev = 0;
00187     njev = 0;
00188 
00189     \textcolor{comment}{/*     check the input parameters for errors. */}
00190     \textcolor{keywordflow}{if} (n <= 0 || m < n || parameters.ftol < 0. || parameters.xtol < 0. || parameters.gtol < 0. || 
      parameters.maxfev <= 0 || parameters.factor <= 0.)
00191         \textcolor{keywordflow}{return} LevenbergMarquardtSpace::ImproperInputParameters;
00192 
00193     \textcolor{keywordflow}{if} (useExternalScaling)
00194         \textcolor{keywordflow}{for} (Index j = 0; j < n; ++j)
00195             \textcolor{keywordflow}{if} (diag[j] <= 0.)
00196                 \textcolor{keywordflow}{return} LevenbergMarquardtSpace::ImproperInputParameters;
00197 
00198     \textcolor{comment}{/*     evaluate the function at the starting point */}
00199     \textcolor{comment}{/*     and calculate its norm. */}
00200     nfev = 1;
00201     \textcolor{keywordflow}{if} ( functor(x, fvec) < 0)
00202         \textcolor{keywordflow}{return} LevenbergMarquardtSpace::UserAsked;
00203     fnorm = fvec.stableNorm();
00204 
00205     \textcolor{comment}{/*     initialize levenberg-marquardt parameter and iteration counter. */}
00206     par = 0.;
00207     iter = 1;
00208 
00209     \textcolor{keywordflow}{return} LevenbergMarquardtSpace::NotStarted;
00210 \}
00211 
00212 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00213 LevenbergMarquardtSpace::Status
00214 LevenbergMarquardt<FunctorType,Scalar>::minimizeOneStep(FVectorType  &x)
00215 \{
00216     \textcolor{keyword}{using} std::abs;
00217     \textcolor{keyword}{using} std::sqrt;
00218 
00219     eigen\_assert(x.size()==n); \textcolor{comment}{// check the caller is not cheating us}
00220 
00221     \textcolor{comment}{/* calculate the jacobian matrix. */}
00222     Index df\_ret = functor.df(x, fjac);
00223     \textcolor{keywordflow}{if} (df\_ret<0)
00224         \textcolor{keywordflow}{return} LevenbergMarquardtSpace::UserAsked;
00225     \textcolor{keywordflow}{if} (df\_ret>0)
00226         \textcolor{comment}{// numerical diff, we evaluated the function df\_ret times}
00227         nfev += df\_ret;
00228     \textcolor{keywordflow}{else} njev++;
00229 
00230     \textcolor{comment}{/* compute the qr factorization of the jacobian. */}
00231     wa2 = fjac.colwise().blueNorm();
00232     ColPivHouseholderQR<JacobianType> qrfac(fjac);
00233     fjac = qrfac.matrixQR();
00234     permutation = qrfac.colsPermutation();
00235 
00236     \textcolor{comment}{/* on the first iteration and if external scaling is not used, scale according */}
00237     \textcolor{comment}{/* to the norms of the columns of the initial jacobian. */}
00238     \textcolor{keywordflow}{if} (iter == 1) \{
00239         \textcolor{keywordflow}{if} (!useExternalScaling)
00240             \textcolor{keywordflow}{for} (Index j = 0; j < n; ++j)
00241                 diag[j] = (wa2[j]==0.)? 1. : wa2[j];
00242 
00243         \textcolor{comment}{/* on the first iteration, calculate the norm of the scaled x */}
00244         \textcolor{comment}{/* and initialize the step bound delta. */}
00245         xnorm = diag.cwiseProduct(x).stableNorm();
00246         delta = parameters.factor * xnorm;
00247         \textcolor{keywordflow}{if} (delta == 0.)
00248             delta = parameters.factor;
00249     \}
00250 
00251     \textcolor{comment}{/* form (q transpose)*fvec and store the first n components in */}
00252     \textcolor{comment}{/* qtf. */}
00253     wa4 = fvec;
00254     wa4.applyOnTheLeft(qrfac.householderQ().adjoint());
00255     qtf = wa4.head(n);
00256 
00257     \textcolor{comment}{/* compute the norm of the scaled gradient. */}
00258     gnorm = 0.;
00259     \textcolor{keywordflow}{if} (fnorm != 0.)
00260         \textcolor{keywordflow}{for} (Index j = 0; j < n; ++j)
00261             \textcolor{keywordflow}{if} (wa2[permutation.indices()[j]] != 0.)
00262                 gnorm = (std::max)(gnorm, abs( fjac.col(j).head(j+1).dot(qtf.head(j+1)/fnorm) / wa2[
      permutation.indices()[j]]));
00263 
00264     \textcolor{comment}{/* test for convergence of the gradient norm. */}
00265     \textcolor{keywordflow}{if} (gnorm <= parameters.gtol)
00266         \textcolor{keywordflow}{return} LevenbergMarquardtSpace::CosinusTooSmall;
00267 
00268     \textcolor{comment}{/* rescale if necessary. */}
00269     \textcolor{keywordflow}{if} (!useExternalScaling)
00270         diag = diag.cwiseMax(wa2);
00271 
00272     \textcolor{keywordflow}{do} \{
00273 
00274         \textcolor{comment}{/* determine the levenberg-marquardt parameter. */}
00275         internal::lmpar2<Scalar>(qrfac, diag, qtf, delta, par, wa1);
00276 
00277         \textcolor{comment}{/* store the direction p and x + p. calculate the norm of p. */}
00278         wa1 = -wa1;
00279         wa2 = x + wa1;
00280         pnorm = diag.cwiseProduct(wa1).stableNorm();
00281 
00282         \textcolor{comment}{/* on the first iteration, adjust the initial step bound. */}
00283         \textcolor{keywordflow}{if} (iter == 1)
00284             delta = (std::min)(delta,pnorm);
00285 
00286         \textcolor{comment}{/* evaluate the function at x + p and calculate its norm. */}
00287         \textcolor{keywordflow}{if} ( functor(wa2, wa4) < 0)
00288             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::UserAsked;
00289         ++nfev;
00290         fnorm1 = wa4.stableNorm();
00291 
00292         \textcolor{comment}{/* compute the scaled actual reduction. */}
00293         actred = -1.;
00294         \textcolor{keywordflow}{if} (Scalar(.1) * fnorm1 < fnorm)
00295             actred = 1. - numext::abs2(fnorm1 / fnorm);
00296 
00297         \textcolor{comment}{/* compute the scaled predicted reduction and */}
00298         \textcolor{comment}{/* the scaled directional derivative. */}
00299         wa3 = fjac.template triangularView<Upper>() * (qrfac.colsPermutation().inverse() *wa1);
00300         temp1 = numext::abs2(wa3.stableNorm() / fnorm);
00301         temp2 = numext::abs2(sqrt(par) * pnorm / fnorm);
00302         prered = temp1 + temp2 / Scalar(.5);
00303         dirder = -(temp1 + temp2);
00304 
00305         \textcolor{comment}{/* compute the ratio of the actual to the predicted */}
00306         \textcolor{comment}{/* reduction. */}
00307         ratio = 0.;
00308         \textcolor{keywordflow}{if} (prered != 0.)
00309             ratio = actred / prered;
00310 
00311         \textcolor{comment}{/* update the step bound. */}
00312         \textcolor{keywordflow}{if} (ratio <= Scalar(.25)) \{
00313             \textcolor{keywordflow}{if} (actred >= 0.)
00314                 temp = Scalar(.5);
00315             \textcolor{keywordflow}{if} (actred < 0.)
00316                 temp = Scalar(.5) * dirder / (dirder + Scalar(.5) * actred);
00317             \textcolor{keywordflow}{if} (Scalar(.1) * fnorm1 >= fnorm || temp < Scalar(.1))
00318                 temp = Scalar(.1);
00319             \textcolor{comment}{/* Computing MIN */}
00320             delta = temp * (std::min)(delta, pnorm / Scalar(.1));
00321             par /= temp;
00322         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!(par != 0. && ratio < Scalar(.75))) \{
00323             delta = pnorm / Scalar(.5);
00324             par = Scalar(.5) * par;
00325         \}
00326 
00327         \textcolor{comment}{/* test for successful iteration. */}
00328         \textcolor{keywordflow}{if} (ratio >= Scalar(1e-4)) \{
00329             \textcolor{comment}{/* successful iteration. update x, fvec, and their norms. */}
00330             x = wa2;
00331             wa2 = diag.cwiseProduct(x);
00332             fvec = wa4;
00333             xnorm = wa2.stableNorm();
00334             fnorm = fnorm1;
00335             ++iter;
00336         \}
00337 
00338         \textcolor{comment}{/* tests for convergence. */}
00339         \textcolor{keywordflow}{if} (abs(actred) <= parameters.ftol && prered <= parameters.ftol && Scalar(.5) * ratio <= 1. && 
      delta <= parameters.xtol * xnorm)
00340             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::RelativeErrorAndReductionTooSmall;
00341         \textcolor{keywordflow}{if} (abs(actred) <= parameters.ftol && prered <= parameters.ftol && Scalar(.5) * ratio <= 1.)
00342             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::RelativeReductionTooSmall;
00343         \textcolor{keywordflow}{if} (delta <= parameters.xtol * xnorm)
00344             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::RelativeErrorTooSmall;
00345 
00346         \textcolor{comment}{/* tests for termination and stringent tolerances. */}
00347         \textcolor{keywordflow}{if} (nfev >= parameters.maxfev)
00348             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::TooManyFunctionEvaluation;
00349         \textcolor{keywordflow}{if} (abs(actred) <= NumTraits<Scalar>::epsilon() && prered <= NumTraits<Scalar>::epsilon() && Scalar
      (.5) * ratio <= 1.)
00350             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::FtolTooSmall;
00351         \textcolor{keywordflow}{if} (delta <= NumTraits<Scalar>::epsilon() * xnorm)
00352             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::XtolTooSmall;
00353         \textcolor{keywordflow}{if} (gnorm <= NumTraits<Scalar>::epsilon())
00354             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::GtolTooSmall;
00355 
00356     \} \textcolor{keywordflow}{while} (ratio < Scalar(1e-4));
00357 
00358     \textcolor{keywordflow}{return} LevenbergMarquardtSpace::Running;
00359 \}
00360 
00361 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00362 LevenbergMarquardtSpace::Status
00363 LevenbergMarquardt<FunctorType,Scalar>::lmstr1(
00364         FVectorType  &x,
00365         \textcolor{keyword}{const} Scalar tol
00366         )
00367 \{
00368     n = x.size();
00369     m = functor.values();
00370 
00371     \textcolor{comment}{/* check the input parameters for errors. */}
00372     \textcolor{keywordflow}{if} (n <= 0 || m < n || tol < 0.)
00373         \textcolor{keywordflow}{return} LevenbergMarquardtSpace::ImproperInputParameters;
00374 
00375     resetParameters();
00376     parameters.ftol = tol;
00377     parameters.xtol = tol;
00378     parameters.maxfev = 100*(n+1);
00379 
00380     \textcolor{keywordflow}{return} minimizeOptimumStorage(x);
00381 \}
00382 
00383 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00384 LevenbergMarquardtSpace::Status
00385 LevenbergMarquardt<FunctorType,Scalar>::minimizeOptimumStorageInit(FVectorType  &x)
00386 \{
00387     n = x.size();
00388     m = functor.values();
00389 
00390     wa1.resize(n); wa2.resize(n); wa3.resize(n);
00391     wa4.resize(m);
00392     fvec.resize(m);
00393     \textcolor{comment}{// Only R is stored in fjac. Q is only used to compute 'qtf', which is}
00394     \textcolor{comment}{// Q.transpose()*rhs. qtf will be updated using givens rotation,}
00395     \textcolor{comment}{// instead of storing them in Q.}
00396     \textcolor{comment}{// The purpose it to only use a nxn matrix, instead of mxn here, so}
00397     \textcolor{comment}{// that we can handle cases where m>>n :}
00398     fjac.resize(n, n);
00399     \textcolor{keywordflow}{if} (!useExternalScaling)
00400         diag.resize(n);
00401     eigen\_assert( (!useExternalScaling || diag.size()==n) && \textcolor{stringliteral}{"When useExternalScaling is set, the caller
       must provide a valid 'diag'"});
00402     qtf.resize(n);
00403 
00404     \textcolor{comment}{/* Function Body */}
00405     nfev = 0;
00406     njev = 0;
00407 
00408     \textcolor{comment}{/*     check the input parameters for errors. */}
00409     \textcolor{keywordflow}{if} (n <= 0 || m < n || parameters.ftol < 0. || parameters.xtol < 0. || parameters.gtol < 0. || 
      parameters.maxfev <= 0 || parameters.factor <= 0.)
00410         \textcolor{keywordflow}{return} LevenbergMarquardtSpace::ImproperInputParameters;
00411 
00412     \textcolor{keywordflow}{if} (useExternalScaling)
00413         \textcolor{keywordflow}{for} (Index j = 0; j < n; ++j)
00414             \textcolor{keywordflow}{if} (diag[j] <= 0.)
00415                 \textcolor{keywordflow}{return} LevenbergMarquardtSpace::ImproperInputParameters;
00416 
00417     \textcolor{comment}{/*     evaluate the function at the starting point */}
00418     \textcolor{comment}{/*     and calculate its norm. */}
00419     nfev = 1;
00420     \textcolor{keywordflow}{if} ( functor(x, fvec) < 0)
00421         \textcolor{keywordflow}{return} LevenbergMarquardtSpace::UserAsked;
00422     fnorm = fvec.stableNorm();
00423 
00424     \textcolor{comment}{/*     initialize levenberg-marquardt parameter and iteration counter. */}
00425     par = 0.;
00426     iter = 1;
00427 
00428     \textcolor{keywordflow}{return} LevenbergMarquardtSpace::NotStarted;
00429 \}
00430 
00431 
00432 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00433 LevenbergMarquardtSpace::Status
00434 LevenbergMarquardt<FunctorType,Scalar>::minimizeOptimumStorageOneStep(FVectorType  &x)
00435 \{
00436     \textcolor{keyword}{using} std::abs;
00437     \textcolor{keyword}{using} std::sqrt;
00438     
00439     eigen\_assert(x.size()==n); \textcolor{comment}{// check the caller is not cheating us}
00440 
00441     Index i, j;
00442     \textcolor{keywordtype}{bool} sing;
00443 
00444     \textcolor{comment}{/* compute the qr factorization of the jacobian matrix */}
00445     \textcolor{comment}{/* calculated one row at a time, while simultaneously */}
00446     \textcolor{comment}{/* forming (q transpose)*fvec and storing the first */}
00447     \textcolor{comment}{/* n components in qtf. */}
00448     qtf.fill(0.);
00449     fjac.fill(0.);
00450     Index rownb = 2;
00451     \textcolor{keywordflow}{for} (i = 0; i < m; ++i) \{
00452         \textcolor{keywordflow}{if} (functor.df(x, wa3, rownb) < 0) \textcolor{keywordflow}{return} LevenbergMarquardtSpace::UserAsked;
00453         internal::rwupdt<Scalar>(fjac, wa3, qtf, fvec[i]);
00454         ++rownb;
00455     \}
00456     ++njev;
00457 
00458     \textcolor{comment}{/* if the jacobian is rank deficient, call qrfac to */}
00459     \textcolor{comment}{/* reorder its columns and update the components of qtf. */}
00460     sing = \textcolor{keyword}{false};
00461     \textcolor{keywordflow}{for} (j = 0; j < n; ++j) \{
00462         \textcolor{keywordflow}{if} (fjac(j,j) == 0.)
00463             sing = \textcolor{keyword}{true};
00464         wa2[j] = fjac.col(j).head(j).stableNorm();
00465     \}
00466     permutation.setIdentity(n);
00467     \textcolor{keywordflow}{if} (sing) \{
00468         wa2 = fjac.colwise().blueNorm();
00469         \textcolor{comment}{// TODO We have no unit test covering this code path, do not modify}
00470         \textcolor{comment}{// until it is carefully tested}
00471         ColPivHouseholderQR<JacobianType> qrfac(fjac);
00472         fjac = qrfac.matrixQR();
00473         wa1 = fjac.diagonal();
00474         fjac.diagonal() = qrfac.hCoeffs();
00475         permutation = qrfac.colsPermutation();
00476         \textcolor{comment}{// TODO : avoid this:}
00477         \textcolor{keywordflow}{for}(Index ii=0; ii< fjac.cols(); ii++) fjac.col(ii).segment(ii+1, fjac.rows()-ii-1) *= fjac(ii,ii);
       \textcolor{comment}{// rescale vectors}
00478 
00479         \textcolor{keywordflow}{for} (j = 0; j < n; ++j) \{
00480             \textcolor{keywordflow}{if} (fjac(j,j) != 0.) \{
00481                 sum = 0.;
00482                 \textcolor{keywordflow}{for} (i = j; i < n; ++i)
00483                     sum += fjac(i,j) * qtf[i];
00484                 temp = -sum / fjac(j,j);
00485                 \textcolor{keywordflow}{for} (i = j; i < n; ++i)
00486                     qtf[i] += fjac(i,j) * temp;
00487             \}
00488             fjac(j,j) = wa1[j];
00489         \}
00490     \}
00491 
00492     \textcolor{comment}{/* on the first iteration and if external scaling is not used, scale according */}
00493     \textcolor{comment}{/* to the norms of the columns of the initial jacobian. */}
00494     \textcolor{keywordflow}{if} (iter == 1) \{
00495         \textcolor{keywordflow}{if} (!useExternalScaling)
00496             \textcolor{keywordflow}{for} (j = 0; j < n; ++j)
00497                 diag[j] = (wa2[j]==0.)? 1. : wa2[j];
00498 
00499         \textcolor{comment}{/* on the first iteration, calculate the norm of the scaled x */}
00500         \textcolor{comment}{/* and initialize the step bound delta. */}
00501         xnorm = diag.cwiseProduct(x).stableNorm();
00502         delta = parameters.factor * xnorm;
00503         \textcolor{keywordflow}{if} (delta == 0.)
00504             delta = parameters.factor;
00505     \}
00506 
00507     \textcolor{comment}{/* compute the norm of the scaled gradient. */}
00508     gnorm = 0.;
00509     \textcolor{keywordflow}{if} (fnorm != 0.)
00510         \textcolor{keywordflow}{for} (j = 0; j < n; ++j)
00511             \textcolor{keywordflow}{if} (wa2[permutation.indices()[j]] != 0.)
00512                 gnorm = (std::max)(gnorm, abs( fjac.col(j).head(j+1).dot(qtf.head(j+1)/fnorm) / wa2[
      permutation.indices()[j]]));
00513 
00514     \textcolor{comment}{/* test for convergence of the gradient norm. */}
00515     \textcolor{keywordflow}{if} (gnorm <= parameters.gtol)
00516         \textcolor{keywordflow}{return} LevenbergMarquardtSpace::CosinusTooSmall;
00517 
00518     \textcolor{comment}{/* rescale if necessary. */}
00519     \textcolor{keywordflow}{if} (!useExternalScaling)
00520         diag = diag.cwiseMax(wa2);
00521 
00522     \textcolor{keywordflow}{do} \{
00523 
00524         \textcolor{comment}{/* determine the levenberg-marquardt parameter. */}
00525         internal::lmpar<Scalar>(fjac, permutation.indices(), diag, qtf, delta, par, wa1);
00526 
00527         \textcolor{comment}{/* store the direction p and x + p. calculate the norm of p. */}
00528         wa1 = -wa1;
00529         wa2 = x + wa1;
00530         pnorm = diag.cwiseProduct(wa1).stableNorm();
00531 
00532         \textcolor{comment}{/* on the first iteration, adjust the initial step bound. */}
00533         \textcolor{keywordflow}{if} (iter == 1)
00534             delta = (std::min)(delta,pnorm);
00535 
00536         \textcolor{comment}{/* evaluate the function at x + p and calculate its norm. */}
00537         \textcolor{keywordflow}{if} ( functor(wa2, wa4) < 0)
00538             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::UserAsked;
00539         ++nfev;
00540         fnorm1 = wa4.stableNorm();
00541 
00542         \textcolor{comment}{/* compute the scaled actual reduction. */}
00543         actred = -1.;
00544         \textcolor{keywordflow}{if} (Scalar(.1) * fnorm1 < fnorm)
00545             actred = 1. - numext::abs2(fnorm1 / fnorm);
00546 
00547         \textcolor{comment}{/* compute the scaled predicted reduction and */}
00548         \textcolor{comment}{/* the scaled directional derivative. */}
00549         wa3 = fjac.topLeftCorner(n,n).template triangularView<Upper>() * (permutation.inverse() * wa1);
00550         temp1 = numext::abs2(wa3.stableNorm() / fnorm);
00551         temp2 = numext::abs2(sqrt(par) * pnorm / fnorm);
00552         prered = temp1 + temp2 / Scalar(.5);
00553         dirder = -(temp1 + temp2);
00554 
00555         \textcolor{comment}{/* compute the ratio of the actual to the predicted */}
00556         \textcolor{comment}{/* reduction. */}
00557         ratio = 0.;
00558         \textcolor{keywordflow}{if} (prered != 0.)
00559             ratio = actred / prered;
00560 
00561         \textcolor{comment}{/* update the step bound. */}
00562         \textcolor{keywordflow}{if} (ratio <= Scalar(.25)) \{
00563             \textcolor{keywordflow}{if} (actred >= 0.)
00564                 temp = Scalar(.5);
00565             \textcolor{keywordflow}{if} (actred < 0.)
00566                 temp = Scalar(.5) * dirder / (dirder + Scalar(.5) * actred);
00567             \textcolor{keywordflow}{if} (Scalar(.1) * fnorm1 >= fnorm || temp < Scalar(.1))
00568                 temp = Scalar(.1);
00569             \textcolor{comment}{/* Computing MIN */}
00570             delta = temp * (std::min)(delta, pnorm / Scalar(.1));
00571             par /= temp;
00572         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!(par != 0. && ratio < Scalar(.75))) \{
00573             delta = pnorm / Scalar(.5);
00574             par = Scalar(.5) * par;
00575         \}
00576 
00577         \textcolor{comment}{/* test for successful iteration. */}
00578         \textcolor{keywordflow}{if} (ratio >= Scalar(1e-4)) \{
00579             \textcolor{comment}{/* successful iteration. update x, fvec, and their norms. */}
00580             x = wa2;
00581             wa2 = diag.cwiseProduct(x);
00582             fvec = wa4;
00583             xnorm = wa2.stableNorm();
00584             fnorm = fnorm1;
00585             ++iter;
00586         \}
00587 
00588         \textcolor{comment}{/* tests for convergence. */}
00589         \textcolor{keywordflow}{if} (abs(actred) <= parameters.ftol && prered <= parameters.ftol && Scalar(.5) * ratio <= 1. && 
      delta <= parameters.xtol * xnorm)
00590             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::RelativeErrorAndReductionTooSmall;
00591         \textcolor{keywordflow}{if} (abs(actred) <= parameters.ftol && prered <= parameters.ftol && Scalar(.5) * ratio <= 1.)
00592             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::RelativeReductionTooSmall;
00593         \textcolor{keywordflow}{if} (delta <= parameters.xtol * xnorm)
00594             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::RelativeErrorTooSmall;
00595 
00596         \textcolor{comment}{/* tests for termination and stringent tolerances. */}
00597         \textcolor{keywordflow}{if} (nfev >= parameters.maxfev)
00598             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::TooManyFunctionEvaluation;
00599         \textcolor{keywordflow}{if} (abs(actred) <= NumTraits<Scalar>::epsilon() && prered <= NumTraits<Scalar>::epsilon() && Scalar
      (.5) * ratio <= 1.)
00600             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::FtolTooSmall;
00601         \textcolor{keywordflow}{if} (delta <= NumTraits<Scalar>::epsilon() * xnorm)
00602             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::XtolTooSmall;
00603         \textcolor{keywordflow}{if} (gnorm <= NumTraits<Scalar>::epsilon())
00604             \textcolor{keywordflow}{return} LevenbergMarquardtSpace::GtolTooSmall;
00605 
00606     \} \textcolor{keywordflow}{while} (ratio < Scalar(1e-4));
00607 
00608     \textcolor{keywordflow}{return} LevenbergMarquardtSpace::Running;
00609 \}
00610 
00611 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00612 LevenbergMarquardtSpace::Status
00613 LevenbergMarquardt<FunctorType,Scalar>::minimizeOptimumStorage(FVectorType  &x)
00614 \{
00615     LevenbergMarquardtSpace::Status status = minimizeOptimumStorageInit(x);
00616     \textcolor{keywordflow}{if} (status==LevenbergMarquardtSpace::ImproperInputParameters)
00617         \textcolor{keywordflow}{return} status;
00618     \textcolor{keywordflow}{do} \{
00619         status = minimizeOptimumStorageOneStep(x);
00620     \} \textcolor{keywordflow}{while} (status==LevenbergMarquardtSpace::Running);
00621     \textcolor{keywordflow}{return} status;
00622 \}
00623 
00624 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType, \textcolor{keyword}{typename} Scalar>
00625 LevenbergMarquardtSpace::Status
00626 LevenbergMarquardt<FunctorType,Scalar>::lmdif1(
00627         FunctorType &functor,
00628         FVectorType  &x,
00629         Index *nfev,
00630         \textcolor{keyword}{const} Scalar tol
00631         )
00632 \{
00633     Index n = x.size();
00634     Index m = functor.values();
00635 
00636     \textcolor{comment}{/* check the input parameters for errors. */}
00637     \textcolor{keywordflow}{if} (n <= 0 || m < n || tol < 0.)
00638         \textcolor{keywordflow}{return} LevenbergMarquardtSpace::ImproperInputParameters;
00639 
00640     NumericalDiff<FunctorType> numDiff(functor);
00641     \textcolor{comment}{// embedded LevenbergMarquardt}
00642     LevenbergMarquardt<NumericalDiff<FunctorType>, Scalar > lm(numDiff);
00643     lm.parameters.ftol = tol;
00644     lm.parameters.xtol = tol;
00645     lm.parameters.maxfev = 200*(n+1);
00646 
00647     LevenbergMarquardtSpace::Status info = LevenbergMarquardtSpace::Status(lm.minimize(x));
00648     \textcolor{keywordflow}{if} (nfev)
00649         * nfev = lm.nfev;
00650     \textcolor{keywordflow}{return} info;
00651 \}
00652 
00653 \} \textcolor{comment}{// end namespace Eigen}
00654 
00655 \textcolor{preprocessor}{#endif // EIGEN\_LEVENBERGMARQUARDT\_\_H}
00656 
00657 \textcolor{comment}{//vim: ai ts=4 sts=4 et sw=4}
\end{DoxyCode}
