\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_broadcasting_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Broadcasting.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_broadcasting_8h_source}\index{Tensor\+Broadcasting.\+h@{Tensor\+Broadcasting.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_BROADCASTING\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_BROADCASTING\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Broadcast, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_broadcasting_8h_source_l00024}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_broadcasting_op_3_01_broadcast_00_01_xpr_type_01_4_01_4}{00024} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_broadcasting_op}{TensorBroadcastingOp}<Broadcast, XprType> > : \textcolor{keyword}{public} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<XprType>
00025 \{
00026   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00027   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>} \hyperlink{struct_eigen_1_1internal_1_1traits}{XprTraits};
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<Nested>::type} 
      \hyperlink{group___sparse_core___module}{\_Nested};
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00034 \};
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Broadcast, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_broadcasting_8h_source_l00037}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_broadcasting_op_3_01_broadcast_00_01_xpr_type_01_4_00_01_eigen_1_1_dense_01_4}{00037} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_broadcasting_op}{TensorBroadcastingOp}<Broadcast, XprType>, 
      \hyperlink{namespace_eigen}{Eigen}::\hyperlink{struct_eigen_1_1_dense}{Dense}>
00038 \{
00039   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_broadcasting_op}{TensorBroadcastingOp<Broadcast, XprType>}& 
      \hyperlink{class_eigen_1_1_tensor_broadcasting_op}{type};
00040 \};
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Broadcast, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_broadcasting_8h_source_l00043}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_broadcasting_op_3_01_broadcast_00_01_xpr_type_01_a47ea903448f98ead504205e509645e7}{00043} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_broadcasting_op}{TensorBroadcastingOp}<Broadcast, XprType>, 1, typename 
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_broadcasting_op}{TensorBroadcastingOp}<Broadcast, XprType> >::\hyperlink{class_eigen_1_1_tensor_broadcasting_op}{type}>
00044 \{
00045   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_broadcasting_op}{TensorBroadcastingOp<Broadcast, XprType>} 
      \hyperlink{class_eigen_1_1_tensor_broadcasting_op}{type};
00046 \};
00047 
00048 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Dims>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_broadcasting_8h_source_l00049}\hyperlink{struct_eigen_1_1internal_1_1is__input__scalar}{00049} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1is__input__scalar}{is\_input\_scalar} \{
00050   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false};
00051 \};
00052 \textcolor{keyword}{template} <>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_broadcasting_8h_source_l00053}\hyperlink{struct_eigen_1_1internal_1_1is__input__scalar_3_01_sizes_3_4_01_4}{00053} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1is__input__scalar}{is\_input\_scalar}<\hyperlink{struct_eigen_1_1_sizes}{Sizes}<> > \{
00054   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{true};
00055 \};
00056 \textcolor{preprocessor}{#ifndef EIGEN\_EMULATE\_CXX11\_META\_H}
00057 \textcolor{keyword}{template} <\textcolor{keyword}{typename} std::size\_t... Indices>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_broadcasting_8h_source_l00058}\hyperlink{struct_eigen_1_1internal_1_1is__input__scalar_3_01_sizes_3_01_indices_8_8_8_01_4_01_4}{00058} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1is__input__scalar}{is\_input\_scalar}<\hyperlink{struct_eigen_1_1_sizes}{Sizes}<Indices...> > \{
00059   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = (\hyperlink{struct_eigen_1_1_sizes}{Sizes}<Indices...>::total\_size == 1);
00060 \};
00061 \textcolor{preprocessor}{#endif}
00062 
00063 \}  \textcolor{comment}{// end namespace internal}
00064 
00065 
00066 
00067 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Broadcast, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_broadcasting_8h_source_l00068}\hyperlink{class_eigen_1_1_tensor_broadcasting_op}{00068} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_broadcasting_op}{TensorBroadcastingOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorBroadcastingOp<Broadcast
      , XprType>, ReadOnlyAccessors>
00069 \{
00070   \textcolor{keyword}{public}:
00071   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorBroadcastingOp>::Scalar}
       Scalar;
00072   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} 
      \hyperlink{group___sparse_core___module}{RealScalar};
00073   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00074   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorBroadcastingOp>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Nested};
00075   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorBroadcastingOp>::StorageKind}
       StorageKind;
00076   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorBroadcastingOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00077 
00078   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_broadcasting_op}{TensorBroadcastingOp}(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const}
       Broadcast& broadcast)
00079       : m\_xpr(expr), m\_broadcast(broadcast) \{\}
00080 
00081     EIGEN\_DEVICE\_FUNC
00082     \textcolor{keyword}{const} Broadcast& broadcast()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_broadcast; \}
00083 
00084     EIGEN\_DEVICE\_FUNC
00085     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename XprType::Nested>::type}
      &
00086     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00087 
00088   \textcolor{keyword}{protected}:
00089     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00090     \textcolor{keyword}{const} Broadcast m\_broadcast;
00091 \};
00092 
00093 
00094 \textcolor{comment}{// Eval as rvalue}
00095 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Broadcast, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_broadcasting_8h_source_l00096}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_broadcasting_op_3_01_broadcast_00_01_arg_type_01_4_00_01_device_01_4}{00096} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_broadcasting_op}{TensorBroadcastingOp}<Broadcast, ArgType>, 
      Device>
00097 \{
00098   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_broadcasting_op}{TensorBroadcastingOp<Broadcast, ArgType>} 
      \hyperlink{class_eigen_1_1_tensor_broadcasting_op}{XprType};
00099   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00100   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<ArgType, Device>::Dimensions}
      >::value;
00101   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumDims>} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00102   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00103   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Dimensions}
       InputDimensions;
00104   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00105   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00106   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size};
00107 
00108   \textcolor{keyword}{enum} \{
00109     IsAligned = \textcolor{keyword}{true},
00110     PacketAccess = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::PacketAccess}
      ,
00111     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Layout},
00112     RawAccess = \textcolor{keyword}{false}
00113   \};
00114 
00115   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00116     : m\_broadcast(op.broadcast()),m\_impl(op.expression(), device)
00117   \{
00118     \textcolor{comment}{// The broadcasting op doesn't change the rank of the tensor. One can't broadcast a scalar}
00119     \textcolor{comment}{// and store the result in a scalar. Instead one should reshape the scalar into a a N-D}
00120     \textcolor{comment}{// tensor with N >= 1 of 1 element first and then broadcast.}
00121     EIGEN\_STATIC\_ASSERT((NumDims > 0), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00122     \textcolor{keyword}{const} InputDimensions& input\_dims = m\_impl.dimensions();
00123     \textcolor{keyword}{const} Broadcast& broadcast = op.broadcast();
00124     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i) \{
00125       eigen\_assert(input\_dims[i] > 0);
00126       m\_dimensions[i] = input\_dims[i] * broadcast[i];
00127     \}
00128 
00129     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00130       m\_inputStrides[0] = 1;
00131       m\_outputStrides[0] = 1;
00132       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00133         m\_inputStrides[i] = m\_inputStrides[i-1] * input\_dims[i-1];
00134         m\_outputStrides[i] = m\_outputStrides[i-1] * m\_dimensions[i-1];
00135       \}
00136     \} \textcolor{keywordflow}{else} \{
00137       m\_inputStrides[NumDims-1] = 1;
00138       m\_outputStrides[NumDims-1] = 1;
00139       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims-2; i >= 0; --i) \{
00140         m\_inputStrides[i] = m\_inputStrides[i+1] * input\_dims[i+1];
00141         m\_outputStrides[i] = m\_outputStrides[i+1] * m\_dimensions[i+1];
00142       \}
00143     \}
00144   \}
00145 
00146   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00147 
00148   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/}) \{
00149     m\_impl.evalSubExprsIfNeeded(NULL);
00150     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00151   \}
00152 
00153   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00154     m\_impl.cleanup();
00155   \}
00156 
00157   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00158 \textcolor{keyword}{  }\{
00159     \textcolor{keywordflow}{if} (\hyperlink{struct_eigen_1_1internal_1_1is__input__scalar}{internal::is\_input\_scalar}<\textcolor{keyword}{typename} 
      \hyperlink{group___sparse_core___module}{internal::remove\_all<InputDimensions>::type}>::value) \{
00160       \textcolor{keywordflow}{return} m\_impl.coeff(0);
00161     \}
00162 
00163     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00164       \textcolor{keywordflow}{return} coeffColMajor(index);
00165     \} \textcolor{keywordflow}{else} \{
00166       \textcolor{keywordflow}{return} coeffRowMajor(index);
00167     \}
00168   \}
00169 
00170   \textcolor{comment}{// TODO: attempt to speed this up. The integer divisions and modulo are slow}
00171   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeffColMajor(Index index)\textcolor{keyword}{ const}
00172 \textcolor{keyword}{  }\{
00173     Index inputIndex = 0;
00174     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00175       \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00176       \textcolor{keywordflow}{if} (internal::index\_statically\_eq<Broadcast>(i, 1)) \{
00177         eigen\_assert(idx < m\_impl.dimensions()[i]);
00178         inputIndex += idx * m\_inputStrides[i];
00179       \} \textcolor{keywordflow}{else} \{
00180         \textcolor{keywordflow}{if} (internal::index\_statically\_eq<InputDimensions>(i, 1)) \{
00181           eigen\_assert(idx % m\_impl.dimensions()[i] == 0);
00182         \} \textcolor{keywordflow}{else} \{
00183           inputIndex += (idx % m\_impl.dimensions()[i]) * m\_inputStrides[i];
00184         \}
00185       \}
00186       index -= idx * m\_outputStrides[i];
00187     \}
00188     \textcolor{keywordflow}{if} (internal::index\_statically\_eq<Broadcast>(0, 1)) \{
00189       eigen\_assert(index < m\_impl.dimensions()[0]);
00190       inputIndex += index;
00191     \} \textcolor{keywordflow}{else} \{
00192       \textcolor{keywordflow}{if} (internal::index\_statically\_eq<InputDimensions>(0, 1)) \{
00193         eigen\_assert(index % m\_impl.dimensions()[0] == 0);
00194       \} \textcolor{keywordflow}{else} \{
00195         inputIndex += (index % m\_impl.dimensions()[0]);
00196       \}
00197     \}
00198     \textcolor{keywordflow}{return} m\_impl.coeff(inputIndex);
00199   \}
00200 
00201   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeffRowMajor(Index index)\textcolor{keyword}{ const}
00202 \textcolor{keyword}{  }\{
00203     Index inputIndex = 0;
00204     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00205       \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00206       \textcolor{keywordflow}{if} (internal::index\_statically\_eq<Broadcast>(i, 1)) \{
00207         eigen\_assert(idx < m\_impl.dimensions()[i]);
00208         inputIndex += idx * m\_inputStrides[i];
00209       \} \textcolor{keywordflow}{else} \{
00210         \textcolor{keywordflow}{if} (internal::index\_statically\_eq<InputDimensions>(i, 1)) \{
00211           eigen\_assert(idx % m\_impl.dimensions()[i] == 0);
00212         \} \textcolor{keywordflow}{else} \{
00213           inputIndex += (idx % m\_impl.dimensions()[i]) * m\_inputStrides[i];
00214         \}
00215       \}
00216       index -= idx * m\_outputStrides[i];
00217     \}
00218     \textcolor{keywordflow}{if} (internal::index\_statically\_eq<Broadcast>(NumDims-1, 1)) \{
00219       eigen\_assert(index < m\_impl.dimensions()[NumDims-1]);
00220       inputIndex += index;
00221     \} \textcolor{keywordflow}{else} \{
00222       \textcolor{keywordflow}{if} (internal::index\_statically\_eq<InputDimensions>(NumDims-1, 1)) \{
00223         eigen\_assert(index % m\_impl.dimensions()[NumDims-1] == 0);
00224       \} \textcolor{keywordflow}{else} \{
00225         inputIndex += (index % m\_impl.dimensions()[NumDims-1]);
00226       \}
00227     \}
00228     \textcolor{keywordflow}{return} m\_impl.coeff(inputIndex);
00229   \}
00230 
00231   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00232   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00233 \textcolor{keyword}{  }\{
00234     \textcolor{keywordflow}{if} (\hyperlink{struct_eigen_1_1internal_1_1is__input__scalar}{internal::is\_input\_scalar}<\textcolor{keyword}{typename} 
      \hyperlink{group___sparse_core___module}{internal::remove\_all<InputDimensions>::type}>::value) \{
00235       \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(m\_impl.coeff(0));
00236     \}
00237 
00238     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00239       \textcolor{keywordflow}{return} packetColMajor<LoadMode>(index);
00240     \} \textcolor{keywordflow}{else} \{
00241       \textcolor{keywordflow}{return} packetRowMajor<LoadMode>(index);
00242     \}
00243   \}
00244 
00245   \textcolor{comment}{// Ignore the LoadMode and always use unaligned loads since we can't guarantee}
00246   \textcolor{comment}{// the alignment at compile time.}
00247   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00248   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packetColMajor(Index index)\textcolor{keyword}{ const}
00249 \textcolor{keyword}{  }\{
00250     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00251     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00252 
00253     \textcolor{keyword}{const} Index originalIndex = index;
00254 
00255     Index inputIndex = 0;
00256     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00257       \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00258       \textcolor{keywordflow}{if} (internal::index\_statically\_eq<Broadcast>(i, 1)) \{
00259         eigen\_assert(idx < m\_impl.dimensions()[i]);
00260         inputIndex += idx * m\_inputStrides[i];
00261       \} \textcolor{keywordflow}{else} \{
00262         \textcolor{keywordflow}{if} (internal::index\_statically\_eq<InputDimensions>(i, 1)) \{
00263           eigen\_assert(idx % m\_impl.dimensions()[i] == 0);
00264         \} \textcolor{keywordflow}{else} \{
00265           inputIndex += (idx % m\_impl.dimensions()[i]) * m\_inputStrides[i];
00266         \}
00267       \}
00268       index -= idx * m\_outputStrides[i];
00269     \}
00270     Index innermostLoc;
00271     \textcolor{keywordflow}{if} (internal::index\_statically\_eq<Broadcast>(0, 1)) \{
00272       eigen\_assert(index < m\_impl.dimensions()[0]);
00273       innermostLoc = index;
00274     \} \textcolor{keywordflow}{else} \{
00275       \textcolor{keywordflow}{if} (internal::index\_statically\_eq<InputDimensions>(0, 1)) \{
00276         eigen\_assert(index % m\_impl.dimensions()[0] == 0);
00277         innermostLoc = 0;
00278       \} \textcolor{keywordflow}{else} \{
00279         innermostLoc = index % m\_impl.dimensions()[0];
00280       \}
00281     \}
00282     inputIndex += innermostLoc;
00283 
00284     \textcolor{comment}{// Todo: this could be extended to the second dimension if we're not}
00285     \textcolor{comment}{// broadcasting alongside the first dimension, and so on.}
00286     \textcolor{keywordflow}{if} (innermostLoc + PacketSize <= m\_impl.dimensions()[0]) \{
00287       \textcolor{keywordflow}{return} m\_impl.template packet<Unaligned>(inputIndex);
00288     \} \textcolor{keywordflow}{else} \{
00289       EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<CoeffReturnType>::type}
       values[PacketSize];
00290       values[0] = m\_impl.coeff(inputIndex);
00291       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < PacketSize; ++i) \{
00292         values[i] = coeffColMajor(originalIndex+i);
00293       \}
00294       PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00295       \textcolor{keywordflow}{return} rslt;
00296     \}
00297   \}
00298 
00299   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00300   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packetRowMajor(Index index)\textcolor{keyword}{ const}
00301 \textcolor{keyword}{  }\{
00302     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00303     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00304 
00305     \textcolor{keyword}{const} Index originalIndex = index;
00306 
00307     Index inputIndex = 0;
00308     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00309       \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00310       \textcolor{keywordflow}{if} (internal::index\_statically\_eq<Broadcast>(i, 1)) \{
00311         eigen\_assert(idx < m\_impl.dimensions()[i]);
00312         inputIndex += idx * m\_inputStrides[i];
00313       \} \textcolor{keywordflow}{else} \{
00314         \textcolor{keywordflow}{if} (internal::index\_statically\_eq<InputDimensions>(i, 1)) \{
00315           eigen\_assert(idx % m\_impl.dimensions()[i] == 0);
00316         \} \textcolor{keywordflow}{else} \{
00317           inputIndex += (idx % m\_impl.dimensions()[i]) * m\_inputStrides[i];
00318         \}
00319       \}
00320       index -= idx * m\_outputStrides[i];
00321     \}
00322     Index innermostLoc;
00323     \textcolor{keywordflow}{if} (internal::index\_statically\_eq<Broadcast>(NumDims-1, 1)) \{
00324       eigen\_assert(index < m\_impl.dimensions()[NumDims-1]);
00325       innermostLoc = index;
00326     \} \textcolor{keywordflow}{else} \{
00327       \textcolor{keywordflow}{if} (internal::index\_statically\_eq<InputDimensions>(NumDims-1, 1)) \{
00328         eigen\_assert(index % m\_impl.dimensions()[NumDims-1] == 0);
00329         innermostLoc = 0;
00330       \} \textcolor{keywordflow}{else} \{
00331         innermostLoc = index % m\_impl.dimensions()[NumDims-1];
00332       \}
00333     \}
00334     inputIndex += innermostLoc;
00335 
00336     \textcolor{comment}{// Todo: this could be extended to the second dimension if we're not}
00337     \textcolor{comment}{// broadcasting alongside the first dimension, and so on.}
00338     \textcolor{keywordflow}{if} (innermostLoc + PacketSize <= m\_impl.dimensions()[NumDims-1]) \{
00339       \textcolor{keywordflow}{return} m\_impl.template packet<Unaligned>(inputIndex);
00340     \} \textcolor{keywordflow}{else} \{
00341       EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<CoeffReturnType>::type}
       values[PacketSize];
00342       values[0] = m\_impl.coeff(inputIndex);
00343       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < PacketSize; ++i) \{
00344         values[i] = coeffRowMajor(originalIndex+i);
00345       \}
00346       PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00347       \textcolor{keywordflow}{return} rslt;
00348     \}
00349   \}
00350 
00351   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}
00352   costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00353     \textcolor{keywordtype}{double} compute\_cost = TensorOpCost::AddCost<Index>();
00354     \textcolor{keywordflow}{if} (NumDims > 0) \{
00355       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00356         compute\_cost += TensorOpCost::DivCost<Index>();
00357         \textcolor{keywordflow}{if} (internal::index\_statically\_eq<Broadcast>(i, 1)) \{
00358           compute\_cost +=
00359               TensorOpCost::MulCost<Index>() + TensorOpCost::AddCost<Index>();
00360         \} \textcolor{keywordflow}{else} \{
00361           \textcolor{keywordflow}{if} (!internal::index\_statically\_eq<InputDimensions>(i, 1)) \{
00362             compute\_cost += TensorOpCost::MulCost<Index>() +
00363                             TensorOpCost::ModCost<Index>() +
00364                             TensorOpCost::AddCost<Index>();
00365           \}
00366         \}
00367         compute\_cost +=
00368             TensorOpCost::MulCost<Index>() + TensorOpCost::AddCost<Index>();
00369       \}
00370     \}
00371     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) +
00372            \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, compute\_cost, vectorized, PacketSize);
00373   \}
00374 
00375   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00376 
00377   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>}& impl()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_impl; \}
00378 
00379   Broadcast functor()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_broadcast; \}
00380 
00381  \textcolor{keyword}{protected}:
00382   \textcolor{keyword}{const} Broadcast m\_broadcast;
00383   Dimensions m\_dimensions;
00384   \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} m\_outputStrides;
00385   \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} m\_inputStrides;
00386   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} m\_impl;
00387 \};
00388 
00389 
00390 \} \textcolor{comment}{// end namespace Eigen}
00391 
00392 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_BROADCASTING\_H}
\end{DoxyCode}
