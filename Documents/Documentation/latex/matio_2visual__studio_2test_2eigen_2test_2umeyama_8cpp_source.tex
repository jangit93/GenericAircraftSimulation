\hypertarget{matio_2visual__studio_2test_2eigen_2test_2umeyama_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/umeyama.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2umeyama_8cpp_source}\index{umeyama.\+cpp@{umeyama.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Hauke Heibel <hauke.heibel@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{preprocessor}{#include <Eigen/Core>}
00013 \textcolor{preprocessor}{#include <Eigen/Geometry>}
00014 
00015 \textcolor{preprocessor}{#include <Eigen/LU>} \textcolor{comment}{// required for MatrixBase::determinant}
00016 \textcolor{preprocessor}{#include <Eigen/SVD>} \textcolor{comment}{// required for SVD}
00017 
00018 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00019 
00020 \textcolor{comment}{//  Constructs a random matrix from the unitary group U(size).}
00021 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00022 \hyperlink{group___core___module_class_eigen_1_1_matrix}{Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>} 
      randMatrixUnitary(\textcolor{keywordtype}{int} size)
00023 \{
00024   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{T} Scalar;
00025   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic>}
       MatrixType;
00026 
00027   MatrixType Q;
00028 
00029   \textcolor{keywordtype}{int} max\_tries = 40;
00030   \textcolor{keywordtype}{double} is\_unitary = \textcolor{keyword}{false};
00031 
00032   \textcolor{keywordflow}{while} (!is\_unitary && max\_tries > 0)
00033   \{
00034     \textcolor{comment}{// initialize random matrix}
00035     Q = MatrixType::Random(size, size);
00036 
00037     \textcolor{comment}{// orthogonalize columns using the Gram-Schmidt algorithm}
00038     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} col = 0; col < size; ++col)
00039     \{
00040       \textcolor{keyword}{typename} MatrixType::ColXpr colVec = Q.col(col);
00041       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} prevCol = 0; prevCol < col; ++prevCol)
00042       \{
00043         \textcolor{keyword}{typename} MatrixType::ColXpr prevColVec = Q.col(prevCol);
00044         colVec -= colVec.dot(prevColVec)*prevColVec;
00045       \}
00046       Q.col(col) = colVec.normalized();
00047     \}
00048 
00049     \textcolor{comment}{// this additional orthogonalization is not necessary in theory but should enhance}
00050     \textcolor{comment}{// the numerical orthogonality of the matrix}
00051     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} row = 0; row < size; ++row)
00052     \{
00053       \textcolor{keyword}{typename} MatrixType::RowXpr rowVec = Q.row(row);
00054       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} prevRow = 0; prevRow < row; ++prevRow)
00055       \{
00056         \textcolor{keyword}{typename} MatrixType::RowXpr prevRowVec = Q.row(prevRow);
00057         rowVec -= rowVec.dot(prevRowVec)*prevRowVec;
00058       \}
00059       Q.row(row) = rowVec.normalized();
00060     \}
00061 
00062     \textcolor{comment}{// final check}
00063     is\_unitary = Q.isUnitary();
00064     --max\_tries;
00065   \}
00066 
00067   \textcolor{keywordflow}{if} (max\_tries == 0)
00068     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"randMatrixUnitary: Could not construct unitary matrix!"});
00069 
00070   \textcolor{keywordflow}{return} Q;
00071 \}
00072 
00073 \textcolor{comment}{//  Constructs a random matrix from the special unitary group SU(size).}
00074 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00075 \hyperlink{group___core___module_class_eigen_1_1_matrix}{Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>} 
      randMatrixSpecialUnitary(\textcolor{keywordtype}{int} size)
00076 \{
00077   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{T} Scalar;
00078 
00079   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic>}
       MatrixType;
00080 
00081   \textcolor{comment}{// initialize unitary matrix}
00082   MatrixType Q = randMatrixUnitary<Scalar>(size);
00083 
00084   \textcolor{comment}{// tweak the first column to make the determinant be 1}
00085   Q.col(0) *= numext::conj(Q.determinant());
00086 
00087   \textcolor{keywordflow}{return} Q;
00088 \}
00089 
00090 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00091 \textcolor{keywordtype}{void} run\_test(\textcolor{keywordtype}{int} dim, \textcolor{keywordtype}{int} num\_elements)
00092 \{
00093   \textcolor{keyword}{using} std::abs;
00094   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<MatrixType>::Scalar Scalar;
00095   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic>} 
      MatrixX;
00096   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Eigen::Dynamic, 1>} 
      \hyperlink{group___core___module}{VectorX};
00097 
00098   \textcolor{comment}{// MUST be positive because in any other case det(cR\_t) may become negative for}
00099   \textcolor{comment}{// odd dimensions!}
00100   \textcolor{keyword}{const} Scalar c = abs(internal::random<Scalar>());
00101 
00102   MatrixX R = randMatrixSpecialUnitary<Scalar>(dim);
00103   VectorX t = Scalar(50)*VectorX::Random(dim,1);
00104 
00105   MatrixX cR\_t = MatrixX::Identity(dim+1,dim+1);
00106   cR\_t.block(0,0,dim,dim) = c*R;
00107   cR\_t.block(0,dim,dim,1) = t;
00108 
00109   MatrixX src = MatrixX::Random(dim+1, num\_elements);
00110   src.row(dim) = \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, 1, Dynamic>::Constant}(num\_elements, 
      Scalar(1));
00111 
00112   MatrixX dst = cR\_t*src;
00113 
00114   MatrixX cR\_t\_umeyama = \hyperlink{group___geometry___module_ga033d6550c1fc82e232f2b4c380c19a54}{umeyama}(src.block(0,0,dim,num\_elements), dst.block(0,0,dim,num\_elements));
00115 
00116   \textcolor{keyword}{const} Scalar error = ( cR\_t\_umeyama*src - dst ).norm() / dst.norm();
00117   VERIFY(error < Scalar(40)*std::numeric\_limits<Scalar>::epsilon());
00118 \}
00119 
00120 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Dimension>
00121 \textcolor{keywordtype}{void} run\_fixed\_size\_test(\textcolor{keywordtype}{int} num\_elements)
00122 \{
00123   \textcolor{keyword}{using} std::abs;
00124   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dimension+1, Dynamic>} MatrixX;
00125   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dimension+1, Dimension+1>} HomMatrix;
00126   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dimension, Dimension>} FixedMatrix;
00127   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dimension, 1>} FixedVector;
00128 
00129   \textcolor{keyword}{const} \textcolor{keywordtype}{int} dim = Dimension;
00130 
00131   \textcolor{comment}{// MUST be positive because in any other case det(cR\_t) may become negative for}
00132   \textcolor{comment}{// odd dimensions!}
00133   \textcolor{comment}{// Also if c is to small compared to t.norm(), problem is ill-posed (cf. Bug 744)}
00134   \textcolor{keyword}{const} Scalar c = internal::random<Scalar>(0.5, 2.0);
00135 
00136   FixedMatrix R = randMatrixSpecialUnitary<Scalar>(dim);
00137   FixedVector t = Scalar(32)*FixedVector::Random(dim,1);
00138 
00139   HomMatrix cR\_t = HomMatrix::Identity(dim+1,dim+1);
00140   cR\_t.block(0,0,dim,dim) = c*R;
00141   cR\_t.block(0,dim,dim,1) = t;
00142 
00143   MatrixX src = MatrixX::Random(dim+1, num\_elements);
00144   src.row(dim) = \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, 1, Dynamic>::Constant}(num\_elements, 
      Scalar(1));
00145 
00146   MatrixX dst = cR\_t*src;
00147 
00148   \hyperlink{group___core___module_class_eigen_1_1_block}{Block<MatrixX, Dimension, Dynamic>} src\_block(src,0,0,dim,num\_elements);
00149   \hyperlink{group___core___module_class_eigen_1_1_block}{Block<MatrixX, Dimension, Dynamic>} dst\_block(dst,0,0,dim,num\_elements);
00150 
00151   HomMatrix cR\_t\_umeyama = \hyperlink{group___geometry___module_ga033d6550c1fc82e232f2b4c380c19a54}{umeyama}(src\_block, dst\_block);
00152 
00153   \textcolor{keyword}{const} Scalar error = ( cR\_t\_umeyama*src - dst ).squaredNorm();
00154 
00155   VERIFY(error < Scalar(16)*std::numeric\_limits<Scalar>::epsilon());
00156 \}
00157 
00158 \textcolor{keywordtype}{void} test\_umeyama()
00159 \{
00160   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<g\_repeat; ++i)
00161   \{
00162     \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_elements = internal::random<int>(40,500);
00163 
00164     \textcolor{comment}{// works also for dimensions bigger than 3...}
00165     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} dim=2; dim<8; ++dim)
00166     \{
00167       CALL\_SUBTEST\_1(run\_test<MatrixXd>(dim, num\_elements));
00168       CALL\_SUBTEST\_2(run\_test<MatrixXf>(dim, num\_elements));
00169     \}
00170 
00171     CALL\_SUBTEST\_3((run\_fixed\_size\_test<float, 2>(num\_elements)));
00172     CALL\_SUBTEST\_4((run\_fixed\_size\_test<float, 3>(num\_elements)));
00173     CALL\_SUBTEST\_5((run\_fixed\_size\_test<float, 4>(num\_elements)));
00174 
00175     CALL\_SUBTEST\_6((run\_fixed\_size\_test<double, 2>(num\_elements)));
00176     CALL\_SUBTEST\_7((run\_fixed\_size\_test<double, 3>(num\_elements)));
00177     CALL\_SUBTEST\_8((run\_fixed\_size\_test<double, 4>(num\_elements)));
00178   \}
00179 
00180   \textcolor{comment}{// Those two calls don't compile and result in meaningful error messages!}
00181   \textcolor{comment}{// umeyama(MatrixXcf(),MatrixXcf());}
00182   \textcolor{comment}{// umeyama(MatrixXcd(),MatrixXcd());}
00183 \}
\end{DoxyCode}
