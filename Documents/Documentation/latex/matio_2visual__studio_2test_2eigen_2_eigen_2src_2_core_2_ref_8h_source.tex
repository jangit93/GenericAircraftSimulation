\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_ref_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/\+Ref.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_ref_8h_source}\index{Ref.\+h@{Ref.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_REF\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_REF\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_PlainObjectType, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_Str\textcolor{keywordtype}{id}eType>
00018 \textcolor{keyword}{struct }traits<Ref<\_PlainObjectType, \_Options, \_StrideType> >
00019   : \textcolor{keyword}{public} traits<Map<\_PlainObjectType, \_Options, \_StrideType> >
00020 \{
00021   \textcolor{keyword}{typedef} \_PlainObjectType PlainObjectType;
00022   \textcolor{keyword}{typedef} \_StrideType StrideType;
00023   \textcolor{keyword}{enum} \{
00024     Options = \_Options,
00025     Flags = traits<Map<\_PlainObjectType, \_Options, \_StrideType> >::Flags | NestByRefBit,
00026     Alignment = traits<Map<\_PlainObjectType, \_Options, \_StrideType> >::Alignment
00027   \};
00028 
00029   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{struct }match \{
00030     \textcolor{keyword}{enum} \{
00031       HasDirectAccess = internal::has\_direct\_access<Derived>::ret,
00032       StorageOrderMatch = PlainObjectType::IsVectorAtCompileTime || Derived::IsVectorAtCompileTime || ((
      PlainObjectType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==(Derived::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})),
00033       InnerStrideMatch = \textcolor{keywordtype}{int}(StrideType::InnerStrideAtCompileTime)==int(\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic})
00034                       || int(StrideType::InnerStrideAtCompileTime)==int(Derived::InnerStrideAtCompileTime)
00035                       || (int(StrideType::InnerStrideAtCompileTime)==0 && int(
      Derived::InnerStrideAtCompileTime)==1),
00036       OuterStrideMatch = Derived::IsVectorAtCompileTime
00037                       || \textcolor{keywordtype}{int}(StrideType::OuterStrideAtCompileTime)==int(\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}) || int(
      StrideType::OuterStrideAtCompileTime)==int(Derived::OuterStrideAtCompileTime),
00038       \textcolor{comment}{// NOTE, this indirection of evaluator<Derived>::Alignment is needed}
00039       \textcolor{comment}{// to workaround a very strange bug in MSVC related to the instantiation}
00040       \textcolor{comment}{// of has\_*ary\_operator in evaluator<CwiseNullaryOp>.}
00041       \textcolor{comment}{// This line is surprisingly very sensitive. For instance, simply adding parenthesis}
00042       \textcolor{comment}{// as "DerivedAlignment = (int(evaluator<Derived>::Alignment))," will make MSVC fail...}
00043       DerivedAlignment = int(evaluator<Derived>::Alignment),
00044       AlignmentMatch = (int(traits<PlainObjectType>::Alignment)==int(\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned})) || (
      DerivedAlignment >= \textcolor{keywordtype}{int}(Alignment)), \textcolor{comment}{// FIXME the first condition is not very clear, it should be replaced by the
       required alignment}
00045       ScalarTypeMatch = internal::is\_same<typename PlainObjectType::Scalar, typename
       Derived::Scalar>::value,
00046       MatchAtCompileTime = HasDirectAccess && StorageOrderMatch && InnerStrideMatch && OuterStrideMatch && 
      AlignmentMatch && ScalarTypeMatch
00047     \};
00048     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      internal::conditional<MatchAtCompileTime,internal::true\_type,internal::false\_type>::type type;
00049   \};
00050   
00051 \};
00052 
00053 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00054 \textcolor{keyword}{struct }traits<RefBase<Derived> > : \textcolor{keyword}{public} traits<Derived> \{\};
00055 
00056 \}
00057 
00058 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }RefBase
00059  : \textcolor{keyword}{public} MapBase<Derived>
00060 \{
00061   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<Derived>::PlainObjectType PlainObjectType;
00062   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<Derived>::StrideType StrideType;
00063 
00064 \textcolor{keyword}{public}:
00065 
00066   \textcolor{keyword}{typedef} MapBase<Derived> Base;
00067   EIGEN\_DENSE\_PUBLIC\_INTERFACE(RefBase)
00068 
00069   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} innerStride()\textcolor{keyword}{ const}
00070 \textcolor{keyword}{  }\{
00071     \textcolor{keywordflow}{return} StrideType::InnerStrideAtCompileTime != 0 ? m\_stride.inner() : 1;
00072   \}
00073 
00074   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerStride()\textcolor{keyword}{ const}
00075 \textcolor{keyword}{  }\{
00076     \textcolor{keywordflow}{return} StrideType::OuterStrideAtCompileTime != 0 ? m\_stride.outer()
00077          : IsVectorAtCompileTime ? this->size()
00078          : int(Flags)&RowMajorBit ? this->cols()
00079          : this->rows();
00080   \}
00081 
00082   EIGEN\_DEVICE\_FUNC RefBase()
00083     : Base(0,RowsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}?0:RowsAtCompileTime,ColsAtCompileTime==
      \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}?0:ColsAtCompileTime),
00084       \textcolor{comment}{// Stride<> does not allow default ctor for Dynamic strides, so let' initialize it with dummy values:}
00085       m\_stride(StrideType::OuterStrideAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}?0:StrideType::OuterStrideAtCompileTime,
00086                StrideType::InnerStrideAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}?0:StrideType::InnerStrideAtCompileTime)
00087   \{\}
00088   
00089   EIGEN\_INHERIT\_ASSIGNMENT\_OPERATORS(RefBase)
00090 
00091 \textcolor{keyword}{protected}:
00092 
00093   \textcolor{keyword}{typedef} Stride<StrideType::OuterStrideAtCompileTime,StrideType::InnerStrideAtCompileTime> StrideBase;
00094 
00095   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Expression>
00096   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} construct(Expression& expr)
00097   \{
00098     \textcolor{keywordflow}{if}(PlainObjectType::RowsAtCompileTime==1)
00099     \{
00100       eigen\_assert(expr.rows()==1 || expr.cols()==1);
00101       ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(expr.data(), 1, expr.size());
00102     \}
00103     else if(PlainObjectType::ColsAtCompileTime==1)
00104     \{
00105       eigen\_assert(expr.rows()==1 || expr.cols()==1);
00106       ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(expr.data(), expr.size(), 1);
00107     \}
00108     else
00109       ::new (static\_cast<Base*>(this)) Base(expr.data(), expr.rows(), expr.cols());
00110     
00111     if(Expression::IsVectorAtCompileTime && (!PlainObjectType::IsVectorAtCompileTime) && ((Expression::
      Flags&RowMajorBit)!=(PlainObjectType::Flags&RowMajorBit)))
00112       ::new (&m\_stride) StrideBase(expr.innerStride(), StrideType::InnerStrideAtCompileTime==0?0:1);
00113     else
00114       ::new (&m\_stride) StrideBase(StrideType::OuterStrideAtCompileTime==0?0:expr.outerStride(),
00115                                    StrideType::InnerStrideAtCompileTime==0?0:expr.innerStride());    
00116   \}
00117 
00118   StrideBase m\_stride;
00119 \};
00120 
00190 template<typename PlainObjectType, \textcolor{keywordtype}{int} Options, typename StrideType> class Ref
00191   : public RefBase<Ref<PlainObjectType, Options, StrideType> >
00192 \{
00193   \textcolor{keyword}{private}:
00194     \textcolor{keyword}{typedef} internal::traits<Ref> Traits;
00195     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00196     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Ref(\textcolor{keyword}{const} PlainObjectBase<Derived>& expr,
00197                                  \textcolor{keyword}{typename} internal::enable\_if<\textcolor{keywordtype}{bool}(Traits::template 
      match<Derived>::MatchAtCompileTime),Derived>::type* = 0);
00198   \textcolor{keyword}{public}:
00199 
00200     \textcolor{keyword}{typedef} RefBase<Ref> Base;
00201     EIGEN\_DENSE\_PUBLIC\_INTERFACE(Ref)
00202 
00203 
00204     \textcolor{preprocessor}{#ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00205     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00206     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Ref(PlainObjectBase<Derived>& expr,
00207                                  \textcolor{keyword}{typename} internal::enable\_if<\textcolor{keywordtype}{bool}(Traits::template 
      match<Derived>::MatchAtCompileTime),Derived>::type* = 0)
00208     \{
00209       EIGEN\_STATIC\_ASSERT(\textcolor{keywordtype}{bool}(Traits::template match<Derived>::MatchAtCompileTime), 
      STORAGE\_LAYOUT\_DOES\_NOT\_MATCH);
00210       Base::construct(expr.derived());
00211     \}
00212     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00213     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Ref(\textcolor{keyword}{const} DenseBase<Derived>& expr,
00214                                  \textcolor{keyword}{typename} internal::enable\_if<\textcolor{keywordtype}{bool}(Traits::template 
      match<Derived>::MatchAtCompileTime),Derived>::type* = 0)
00215     \textcolor{preprocessor}{#else}
00216 
00217     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00218     \textcolor{keyword}{inline} Ref(DenseBase<Derived>& expr)
00219     \textcolor{preprocessor}{#endif}
00220     \{
00221       EIGEN\_STATIC\_ASSERT(\textcolor{keywordtype}{bool}(internal::is\_lvalue<Derived>::value), 
      THIS\_EXPRESSION\_IS\_NOT\_A\_LVALUE\_\_IT\_IS\_READ\_ONLY);
00222       EIGEN\_STATIC\_ASSERT(\textcolor{keywordtype}{bool}(Traits::template match<Derived>::MatchAtCompileTime), 
      STORAGE\_LAYOUT\_DOES\_NOT\_MATCH);
00223       EIGEN\_STATIC\_ASSERT(!Derived::IsPlainObjectBase,THIS\_EXPRESSION\_IS\_NOT\_A\_LVALUE\_\_IT\_IS\_READ\_ONLY);
00224       Base::construct(expr.const\_cast\_derived());
00225     \}
00226 
00227     EIGEN\_INHERIT\_ASSIGNMENT\_OPERATORS(Ref)
00228 
00229 \};
00230 
00231 \textcolor{comment}{// this is the const ref version}
00232 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TPlainObjectType, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}eType> \textcolor{keyword}{class }Ref<const TPlainObjectType, 
      Options, StrideType>
00233   : \textcolor{keyword}{public} RefBase<Ref<const TPlainObjectType, Options, StrideType> >
00234 \{
00235     \textcolor{keyword}{typedef} internal::traits<Ref> Traits;
00236   \textcolor{keyword}{public}:
00237 
00238     \textcolor{keyword}{typedef} RefBase<Ref> Base;
00239     EIGEN\_DENSE\_PUBLIC\_INTERFACE(Ref)
00240 
00241     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00242     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Ref(\textcolor{keyword}{const} DenseBase<Derived>& expr,
00243                                  \textcolor{keyword}{typename} internal::enable\_if<\textcolor{keywordtype}{bool}(Traits::template 
      match<Derived>::ScalarTypeMatch),Derived>::type* = 0)
00244     \{
00245 \textcolor{comment}{//      std::cout << match\_helper<Derived>::HasDirectAccess << "," <<
       match\_helper<Derived>::OuterStrideMatch << "," << match\_helper<Derived>::InnerStrideMatch << "\(\backslash\)n";}
00246 \textcolor{comment}{//      std::cout << int(StrideType::OuterStrideAtCompileTime) << " - " <<
       int(Derived::OuterStrideAtCompileTime) << "\(\backslash\)n";}
00247 \textcolor{comment}{//      std::cout << int(StrideType::InnerStrideAtCompileTime) << " - " <<
       int(Derived::InnerStrideAtCompileTime) << "\(\backslash\)n";}
00248       construct(expr.derived(), \textcolor{keyword}{typename} Traits::template match<Derived>::type());
00249     \}
00250 
00251     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Ref(\textcolor{keyword}{const} Ref& other) : Base(other) \{
00252       \textcolor{comment}{// copy constructor shall not copy the m\_object, to avoid unnecessary malloc and copy}
00253     \}
00254 
00255     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherRef>
00256     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Ref(\textcolor{keyword}{const} RefBase<OtherRef>& other) \{
00257       construct(other.derived(), \textcolor{keyword}{typename} Traits::template match<OtherRef>::type());
00258     \}
00259 
00260   \textcolor{keyword}{protected}:
00261 
00262     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Expression>
00263     EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} construct(\textcolor{keyword}{const} Expression& expr,internal::true\_type)
00264     \{
00265       Base::construct(expr);
00266     \}
00267 
00268     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Expression>
00269     EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} construct(\textcolor{keyword}{const} Expression& expr, internal::false\_type)
00270     \{
00271       internal::call\_assignment\_no\_alias(m\_object,expr,internal::assign\_op<Scalar,Scalar>());
00272       Base::construct(m\_object);
00273     \}
00274 
00275   \textcolor{keyword}{protected}:
00276     TPlainObjectType m\_object;
00277 \};
00278 
00279 \} \textcolor{comment}{// end namespace Eigen}
00280 
00281 \textcolor{preprocessor}{#endif // EIGEN\_REF\_H}
\end{DoxyCode}
