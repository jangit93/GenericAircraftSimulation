\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_math_functions_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/arch/\+S\+S\+E/\+Math\+Functions.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_math_functions_8h_source}\index{Math\+Functions.\+h@{Math\+Functions.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2007 Julien Pommier}
00005 \textcolor{comment}{// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{comment}{/* The sin, cos, exp, and log functions of this file come from}
00012 \textcolor{comment}{ * Julien Pommier's sse math library: http://gruntthepeon.free.fr/ssemath/}
00013 \textcolor{comment}{ */}
00014 
00015 \textcolor{preprocessor}{#ifndef EIGEN\_MATH\_FUNCTIONS\_SSE\_H}
00016 \textcolor{preprocessor}{#define EIGEN\_MATH\_FUNCTIONS\_SSE\_H}
00017 
00018 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00019 
00020 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00021 
00022 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00023 Packet4f plog<Packet4f>(\textcolor{keyword}{const} Packet4f& \_x)
00024 \{
00025   Packet4f x = \_x;
00026   \_EIGEN\_DECLARE\_CONST\_Packet4f(1 , 1.0f);
00027   \_EIGEN\_DECLARE\_CONST\_Packet4f(half, 0.5f);
00028   \_EIGEN\_DECLARE\_CONST\_Packet4i(0x7f, 0x7f);
00029 
00030   \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(inv\_mant\_mask, ~0x7f800000);
00031 
00032   \textcolor{comment}{/* the smallest non denormalized float number */}
00033   \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(min\_norm\_pos,  0x00800000);
00034   \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(minus\_inf,     0xff800000);\textcolor{comment}{//-1.f/0.f);}
00035 
00036   \textcolor{comment}{/* natural logarithm computed for 4 simultaneous float}
00037 \textcolor{comment}{    return NaN for x <= 0}
00038 \textcolor{comment}{  */}
00039   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_SQRTHF, 0.707106781186547524f);
00040   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p0, 7.0376836292E-2f);
00041   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p1, - 1.1514610310E-1f);
00042   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p2, 1.1676998740E-1f);
00043   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p3, - 1.2420140846E-1f);
00044   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p4, + 1.4249322787E-1f);
00045   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p5, - 1.6668057665E-1f);
00046   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p6, + 2.0000714765E-1f);
00047   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p7, - 2.4999993993E-1f);
00048   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p8, + 3.3333331174E-1f);
00049   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_q1, -2.12194440e-4f);
00050   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_q2, 0.693359375f);
00051 
00052 
00053   Packet4i emm0;
00054 
00055   Packet4f invalid\_mask = \_mm\_cmpnge\_ps(x, \_mm\_setzero\_ps()); \textcolor{comment}{// not greater equal is true if x is NaN}
00056   Packet4f iszero\_mask = \_mm\_cmpeq\_ps(x, \_mm\_setzero\_ps());
00057 
00058   x = pmax(x, p4f\_min\_norm\_pos);  \textcolor{comment}{/* cut off denormalized stuff */}
00059   emm0 = \_mm\_srli\_epi32(\_mm\_castps\_si128(x), 23);
00060 
00061   \textcolor{comment}{/* keep only the fractional part */}
00062   x = \_mm\_and\_ps(x, p4f\_inv\_mant\_mask);
00063   x = \_mm\_or\_ps(x, p4f\_half);
00064 
00065   emm0 = \_mm\_sub\_epi32(emm0, p4i\_0x7f);
00066   Packet4f e = padd(Packet4f(\_mm\_cvtepi32\_ps(emm0)), p4f\_1);
00067 
00068   \textcolor{comment}{/* part2:}
00069 \textcolor{comment}{     if( x < SQRTHF ) \{}
00070 \textcolor{comment}{       e -= 1;}
00071 \textcolor{comment}{       x = x + x - 1.0;}
00072 \textcolor{comment}{     \} else \{ x = x - 1.0; \}}
00073 \textcolor{comment}{  */}
00074   Packet4f mask = \_mm\_cmplt\_ps(x, p4f\_cephes\_SQRTHF);
00075   Packet4f tmp = pand(x, mask);
00076   x = psub(x, p4f\_1);
00077   e = psub(e, pand(p4f\_1, mask));
00078   x = padd(x, tmp);
00079 
00080   Packet4f x2 = pmul(x,x);
00081   Packet4f x3 = pmul(x2,x);
00082 
00083   Packet4f y, y1, y2;
00084   y  = pmadd(p4f\_cephes\_log\_p0, x, p4f\_cephes\_log\_p1);
00085   y1 = pmadd(p4f\_cephes\_log\_p3, x, p4f\_cephes\_log\_p4);
00086   y2 = pmadd(p4f\_cephes\_log\_p6, x, p4f\_cephes\_log\_p7);
00087   y  = pmadd(y , x, p4f\_cephes\_log\_p2);
00088   y1 = pmadd(y1, x, p4f\_cephes\_log\_p5);
00089   y2 = pmadd(y2, x, p4f\_cephes\_log\_p8);
00090   y = pmadd(y, x3, y1);
00091   y = pmadd(y, x3, y2);
00092   y = pmul(y, x3);
00093 
00094   y1 = pmul(e, p4f\_cephes\_log\_q1);
00095   tmp = pmul(x2, p4f\_half);
00096   y = padd(y, y1);
00097   x = psub(x, tmp);
00098   y2 = pmul(e, p4f\_cephes\_log\_q2);
00099   x = padd(x, y);
00100   x = padd(x, y2);
00101   \textcolor{comment}{// negative arg will be NAN, 0 will be -INF}
00102   \textcolor{keywordflow}{return} \_mm\_or\_ps(\_mm\_andnot\_ps(iszero\_mask, \_mm\_or\_ps(x, invalid\_mask)),
00103                    \_mm\_and\_ps(iszero\_mask, p4f\_minus\_inf));
00104 \}
00105 
00106 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00107 Packet4f pexp<Packet4f>(\textcolor{keyword}{const} Packet4f& \_x)
00108 \{
00109   Packet4f x = \_x;
00110   \_EIGEN\_DECLARE\_CONST\_Packet4f(1 , 1.0f);
00111   \_EIGEN\_DECLARE\_CONST\_Packet4f(half, 0.5f);
00112   \_EIGEN\_DECLARE\_CONST\_Packet4i(0x7f, 0x7f);
00113 
00114 
00115   \_EIGEN\_DECLARE\_CONST\_Packet4f(exp\_hi,  88.3762626647950f);
00116   \_EIGEN\_DECLARE\_CONST\_Packet4f(exp\_lo, -88.3762626647949f);
00117 
00118   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_LOG2EF, 1.44269504088896341f);
00119   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_C1, 0.693359375f);
00120   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_C2, -2.12194440e-4f);
00121 
00122   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_p0, 1.9875691500E-4f);
00123   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_p1, 1.3981999507E-3f);
00124   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_p2, 8.3334519073E-3f);
00125   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_p3, 4.1665795894E-2f);
00126   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_p4, 1.6666665459E-1f);
00127   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_p5, 5.0000001201E-1f);
00128 
00129   Packet4f tmp, fx;
00130   Packet4i emm0;
00131 
00132   \textcolor{comment}{// clamp x}
00133   x = pmax(pmin(x, p4f\_exp\_hi), p4f\_exp\_lo);
00134 
00135   \textcolor{comment}{/* express exp(x) as exp(g + n*log(2)) */}
00136   fx = pmadd(x, p4f\_cephes\_LOG2EF, p4f\_half);
00137 
00138 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00139   fx = \_mm\_floor\_ps(fx);
00140 \textcolor{preprocessor}{#else}
00141   emm0 = \_mm\_cvttps\_epi32(fx);
00142   tmp  = \_mm\_cvtepi32\_ps(emm0);
00143   \textcolor{comment}{/* if greater, substract 1 */}
00144   Packet4f mask = \_mm\_cmpgt\_ps(tmp, fx);
00145   mask = \_mm\_and\_ps(mask, p4f\_1);
00146   fx = psub(tmp, mask);
00147 \textcolor{preprocessor}{#endif}
00148 
00149   tmp = pmul(fx, p4f\_cephes\_exp\_C1);
00150   Packet4f z = pmul(fx, p4f\_cephes\_exp\_C2);
00151   x = psub(x, tmp);
00152   x = psub(x, z);
00153 
00154   z = pmul(x,x);
00155 
00156   Packet4f y = p4f\_cephes\_exp\_p0;
00157   y = pmadd(y, x, p4f\_cephes\_exp\_p1);
00158   y = pmadd(y, x, p4f\_cephes\_exp\_p2);
00159   y = pmadd(y, x, p4f\_cephes\_exp\_p3);
00160   y = pmadd(y, x, p4f\_cephes\_exp\_p4);
00161   y = pmadd(y, x, p4f\_cephes\_exp\_p5);
00162   y = pmadd(y, z, x);
00163   y = padd(y, p4f\_1);
00164 
00165   \textcolor{comment}{// build 2^n}
00166   emm0 = \_mm\_cvttps\_epi32(fx);
00167   emm0 = \_mm\_add\_epi32(emm0, p4i\_0x7f);
00168   emm0 = \_mm\_slli\_epi32(emm0, 23);
00169   \textcolor{keywordflow}{return} pmax(pmul(y, Packet4f(\_mm\_castsi128\_ps(emm0))), \_x);
00170 \}
00171 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00172 Packet2d pexp<Packet2d>(\textcolor{keyword}{const} Packet2d& \_x)
00173 \{
00174   Packet2d x = \_x;
00175 
00176   \_EIGEN\_DECLARE\_CONST\_Packet2d(1 , 1.0);
00177   \_EIGEN\_DECLARE\_CONST\_Packet2d(2 , 2.0);
00178   \_EIGEN\_DECLARE\_CONST\_Packet2d(half, 0.5);
00179 
00180   \_EIGEN\_DECLARE\_CONST\_Packet2d(exp\_hi,  709.437);
00181   \_EIGEN\_DECLARE\_CONST\_Packet2d(exp\_lo, -709.436139303);
00182 
00183   \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_LOG2EF, 1.4426950408889634073599);
00184 
00185   \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_p0, 1.26177193074810590878e-4);
00186   \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_p1, 3.02994407707441961300e-2);
00187   \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_p2, 9.99999999999999999910e-1);
00188 
00189   \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_q0, 3.00198505138664455042e-6);
00190   \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_q1, 2.52448340349684104192e-3);
00191   \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_q2, 2.27265548208155028766e-1);
00192   \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_q3, 2.00000000000000000009e0);
00193 
00194   \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_C1, 0.693145751953125);
00195   \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_C2, 1.42860682030941723212e-6);
00196   \textcolor{keyword}{static} \textcolor{keyword}{const} \_\_m128i p4i\_1023\_0 = \_mm\_setr\_epi32(1023, 1023, 0, 0);
00197 
00198   Packet2d tmp, fx;
00199   Packet4i emm0;
00200 
00201   \textcolor{comment}{// clamp x}
00202   x = pmax(pmin(x, p2d\_exp\_hi), p2d\_exp\_lo);
00203   \textcolor{comment}{/* express exp(x) as exp(g + n*log(2)) */}
00204   fx = pmadd(p2d\_cephes\_LOG2EF, x, p2d\_half);
00205 
00206 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE4\_1}
00207   fx = \_mm\_floor\_pd(fx);
00208 \textcolor{preprocessor}{#else}
00209   emm0 = \_mm\_cvttpd\_epi32(fx);
00210   tmp  = \_mm\_cvtepi32\_pd(emm0);
00211   \textcolor{comment}{/* if greater, substract 1 */}
00212   Packet2d mask = \_mm\_cmpgt\_pd(tmp, fx);
00213   mask = \_mm\_and\_pd(mask, p2d\_1);
00214   fx = psub(tmp, mask);
00215 \textcolor{preprocessor}{#endif}
00216 
00217   tmp = pmul(fx, p2d\_cephes\_exp\_C1);
00218   Packet2d z = pmul(fx, p2d\_cephes\_exp\_C2);
00219   x = psub(x, tmp);
00220   x = psub(x, z);
00221 
00222   Packet2d x2 = pmul(x,x);
00223 
00224   Packet2d px = p2d\_cephes\_exp\_p0;
00225   px = pmadd(px, x2, p2d\_cephes\_exp\_p1);
00226   px = pmadd(px, x2, p2d\_cephes\_exp\_p2);
00227   px = pmul (px, x);
00228 
00229   Packet2d qx = p2d\_cephes\_exp\_q0;
00230   qx = pmadd(qx, x2, p2d\_cephes\_exp\_q1);
00231   qx = pmadd(qx, x2, p2d\_cephes\_exp\_q2);
00232   qx = pmadd(qx, x2, p2d\_cephes\_exp\_q3);
00233 
00234   x = pdiv(px,psub(qx,px));
00235   x = pmadd(p2d\_2,x,p2d\_1);
00236 
00237   \textcolor{comment}{// build 2^n}
00238   emm0 = \_mm\_cvttpd\_epi32(fx);
00239   emm0 = \_mm\_add\_epi32(emm0, p4i\_1023\_0);
00240   emm0 = \_mm\_slli\_epi32(emm0, 20);
00241   emm0 = \_mm\_shuffle\_epi32(emm0, \_MM\_SHUFFLE(1,2,0,3));
00242   \textcolor{keywordflow}{return} pmax(pmul(x, Packet2d(\_mm\_castsi128\_pd(emm0))), \_x);
00243 \}
00244 
00245 \textcolor{comment}{/* evaluation of 4 sines at onces, using SSE2 intrinsics.}
00246 \textcolor{comment}{}
00247 \textcolor{comment}{   The code is the exact rewriting of the cephes sinf function.}
00248 \textcolor{comment}{   Precision is excellent as long as x < 8192 (I did not bother to}
00249 \textcolor{comment}{   take into account the special handling they have for greater values}
00250 \textcolor{comment}{   -- it does not return garbage for arguments over 8192, though, but}
00251 \textcolor{comment}{   the extra precision is missing).}
00252 \textcolor{comment}{}
00253 \textcolor{comment}{   Note that it is such that sinf((float)M\_PI) = 8.74e-8, which is the}
00254 \textcolor{comment}{   surprising but correct result.}
00255 \textcolor{comment}{*/}
00256 
00257 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00258 Packet4f psin<Packet4f>(\textcolor{keyword}{const} Packet4f& \_x)
00259 \{
00260   Packet4f x = \_x;
00261   \_EIGEN\_DECLARE\_CONST\_Packet4f(1 , 1.0f);
00262   \_EIGEN\_DECLARE\_CONST\_Packet4f(half, 0.5f);
00263 
00264   \_EIGEN\_DECLARE\_CONST\_Packet4i(1, 1);
00265   \_EIGEN\_DECLARE\_CONST\_Packet4i(not1, ~1);
00266   \_EIGEN\_DECLARE\_CONST\_Packet4i(2, 2);
00267   \_EIGEN\_DECLARE\_CONST\_Packet4i(4, 4);
00268 
00269   \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(sign\_mask, 0x80000000);
00270 
00271   \_EIGEN\_DECLARE\_CONST\_Packet4f(minus\_cephes\_DP1,-0.78515625f);
00272   \_EIGEN\_DECLARE\_CONST\_Packet4f(minus\_cephes\_DP2, -2.4187564849853515625e-4f);
00273   \_EIGEN\_DECLARE\_CONST\_Packet4f(minus\_cephes\_DP3, -3.77489497744594108e-8f);
00274   \_EIGEN\_DECLARE\_CONST\_Packet4f(sincof\_p0, -1.9515295891E-4f);
00275   \_EIGEN\_DECLARE\_CONST\_Packet4f(sincof\_p1,  8.3321608736E-3f);
00276   \_EIGEN\_DECLARE\_CONST\_Packet4f(sincof\_p2, -1.6666654611E-1f);
00277   \_EIGEN\_DECLARE\_CONST\_Packet4f(coscof\_p0,  2.443315711809948E-005f);
00278   \_EIGEN\_DECLARE\_CONST\_Packet4f(coscof\_p1, -1.388731625493765E-003f);
00279   \_EIGEN\_DECLARE\_CONST\_Packet4f(coscof\_p2,  4.166664568298827E-002f);
00280   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_FOPI, 1.27323954473516f); \textcolor{comment}{// 4 / M\_PI}
00281 
00282   Packet4f xmm1, xmm2, xmm3, sign\_bit, y;
00283 
00284   Packet4i emm0, emm2;
00285   sign\_bit = x;
00286   \textcolor{comment}{/* take the absolute value */}
00287   x = pabs(x);
00288 
00289   \textcolor{comment}{/* take the modulo */}
00290 
00291   \textcolor{comment}{/* extract the sign bit (upper one) */}
00292   sign\_bit = \_mm\_and\_ps(sign\_bit, p4f\_sign\_mask);
00293 
00294   \textcolor{comment}{/* scale by 4/Pi */}
00295   y = pmul(x, p4f\_cephes\_FOPI);
00296 
00297   \textcolor{comment}{/* store the integer part of y in mm0 */}
00298   emm2 = \_mm\_cvttps\_epi32(y);
00299   \textcolor{comment}{/* j=(j+1) & (~1) (see the cephes sources) */}
00300   emm2 = \_mm\_add\_epi32(emm2, p4i\_1);
00301   emm2 = \_mm\_and\_si128(emm2, p4i\_not1);
00302   y = \_mm\_cvtepi32\_ps(emm2);
00303   \textcolor{comment}{/* get the swap sign flag */}
00304   emm0 = \_mm\_and\_si128(emm2, p4i\_4);
00305   emm0 = \_mm\_slli\_epi32(emm0, 29);
00306   \textcolor{comment}{/* get the polynom selection mask}
00307 \textcolor{comment}{     there is one polynom for 0 <= x <= Pi/4}
00308 \textcolor{comment}{     and another one for Pi/4<x<=Pi/2}
00309 \textcolor{comment}{}
00310 \textcolor{comment}{     Both branches will be computed.}
00311 \textcolor{comment}{  */}
00312   emm2 = \_mm\_and\_si128(emm2, p4i\_2);
00313   emm2 = \_mm\_cmpeq\_epi32(emm2, \_mm\_setzero\_si128());
00314 
00315   Packet4f swap\_sign\_bit = \_mm\_castsi128\_ps(emm0);
00316   Packet4f poly\_mask = \_mm\_castsi128\_ps(emm2);
00317   sign\_bit = \_mm\_xor\_ps(sign\_bit, swap\_sign\_bit);
00318 
00319   \textcolor{comment}{/* The magic pass: "Extended precision modular arithmetic"}
00320 \textcolor{comment}{     x = ((x - y * DP1) - y * DP2) - y * DP3; */}
00321   xmm1 = pmul(y, p4f\_minus\_cephes\_DP1);
00322   xmm2 = pmul(y, p4f\_minus\_cephes\_DP2);
00323   xmm3 = pmul(y, p4f\_minus\_cephes\_DP3);
00324   x = padd(x, xmm1);
00325   x = padd(x, xmm2);
00326   x = padd(x, xmm3);
00327 
00328   \textcolor{comment}{/* Evaluate the first polynom  (0 <= x <= Pi/4) */}
00329   y = p4f\_coscof\_p0;
00330   Packet4f z = \_mm\_mul\_ps(x,x);
00331 
00332   y = pmadd(y, z, p4f\_coscof\_p1);
00333   y = pmadd(y, z, p4f\_coscof\_p2);
00334   y = pmul(y, z);
00335   y = pmul(y, z);
00336   Packet4f tmp = pmul(z, p4f\_half);
00337   y = psub(y, tmp);
00338   y = padd(y, p4f\_1);
00339 
00340   \textcolor{comment}{/* Evaluate the second polynom  (Pi/4 <= x <= 0) */}
00341 
00342   Packet4f y2 = p4f\_sincof\_p0;
00343   y2 = pmadd(y2, z, p4f\_sincof\_p1);
00344   y2 = pmadd(y2, z, p4f\_sincof\_p2);
00345   y2 = pmul(y2, z);
00346   y2 = pmul(y2, x);
00347   y2 = padd(y2, x);
00348 
00349   \textcolor{comment}{/* select the correct result from the two polynoms */}
00350   y2 = \_mm\_and\_ps(poly\_mask, y2);
00351   y = \_mm\_andnot\_ps(poly\_mask, y);
00352   y = \_mm\_or\_ps(y,y2);
00353   \textcolor{comment}{/* update the sign */}
00354   \textcolor{keywordflow}{return} \_mm\_xor\_ps(y, sign\_bit);
00355 \}
00356 
00357 \textcolor{comment}{/* almost the same as psin */}
00358 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00359 Packet4f pcos<Packet4f>(\textcolor{keyword}{const} Packet4f& \_x)
00360 \{
00361   Packet4f x = \_x;
00362   \_EIGEN\_DECLARE\_CONST\_Packet4f(1 , 1.0f);
00363   \_EIGEN\_DECLARE\_CONST\_Packet4f(half, 0.5f);
00364 
00365   \_EIGEN\_DECLARE\_CONST\_Packet4i(1, 1);
00366   \_EIGEN\_DECLARE\_CONST\_Packet4i(not1, ~1);
00367   \_EIGEN\_DECLARE\_CONST\_Packet4i(2, 2);
00368   \_EIGEN\_DECLARE\_CONST\_Packet4i(4, 4);
00369 
00370   \_EIGEN\_DECLARE\_CONST\_Packet4f(minus\_cephes\_DP1,-0.78515625f);
00371   \_EIGEN\_DECLARE\_CONST\_Packet4f(minus\_cephes\_DP2, -2.4187564849853515625e-4f);
00372   \_EIGEN\_DECLARE\_CONST\_Packet4f(minus\_cephes\_DP3, -3.77489497744594108e-8f);
00373   \_EIGEN\_DECLARE\_CONST\_Packet4f(sincof\_p0, -1.9515295891E-4f);
00374   \_EIGEN\_DECLARE\_CONST\_Packet4f(sincof\_p1,  8.3321608736E-3f);
00375   \_EIGEN\_DECLARE\_CONST\_Packet4f(sincof\_p2, -1.6666654611E-1f);
00376   \_EIGEN\_DECLARE\_CONST\_Packet4f(coscof\_p0,  2.443315711809948E-005f);
00377   \_EIGEN\_DECLARE\_CONST\_Packet4f(coscof\_p1, -1.388731625493765E-003f);
00378   \_EIGEN\_DECLARE\_CONST\_Packet4f(coscof\_p2,  4.166664568298827E-002f);
00379   \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_FOPI, 1.27323954473516f); \textcolor{comment}{// 4 / M\_PI}
00380 
00381   Packet4f xmm1, xmm2, xmm3, y;
00382   Packet4i emm0, emm2;
00383 
00384   x = pabs(x);
00385 
00386   \textcolor{comment}{/* scale by 4/Pi */}
00387   y = pmul(x, p4f\_cephes\_FOPI);
00388 
00389   \textcolor{comment}{/* get the integer part of y */}
00390   emm2 = \_mm\_cvttps\_epi32(y);
00391   \textcolor{comment}{/* j=(j+1) & (~1) (see the cephes sources) */}
00392   emm2 = \_mm\_add\_epi32(emm2, p4i\_1);
00393   emm2 = \_mm\_and\_si128(emm2, p4i\_not1);
00394   y = \_mm\_cvtepi32\_ps(emm2);
00395 
00396   emm2 = \_mm\_sub\_epi32(emm2, p4i\_2);
00397 
00398   \textcolor{comment}{/* get the swap sign flag */}
00399   emm0 = \_mm\_andnot\_si128(emm2, p4i\_4);
00400   emm0 = \_mm\_slli\_epi32(emm0, 29);
00401   \textcolor{comment}{/* get the polynom selection mask */}
00402   emm2 = \_mm\_and\_si128(emm2, p4i\_2);
00403   emm2 = \_mm\_cmpeq\_epi32(emm2, \_mm\_setzero\_si128());
00404 
00405   Packet4f sign\_bit = \_mm\_castsi128\_ps(emm0);
00406   Packet4f poly\_mask = \_mm\_castsi128\_ps(emm2);
00407 
00408   \textcolor{comment}{/* The magic pass: "Extended precision modular arithmetic"}
00409 \textcolor{comment}{     x = ((x - y * DP1) - y * DP2) - y * DP3; */}
00410   xmm1 = pmul(y, p4f\_minus\_cephes\_DP1);
00411   xmm2 = pmul(y, p4f\_minus\_cephes\_DP2);
00412   xmm3 = pmul(y, p4f\_minus\_cephes\_DP3);
00413   x = padd(x, xmm1);
00414   x = padd(x, xmm2);
00415   x = padd(x, xmm3);
00416 
00417   \textcolor{comment}{/* Evaluate the first polynom  (0 <= x <= Pi/4) */}
00418   y = p4f\_coscof\_p0;
00419   Packet4f z = pmul(x,x);
00420 
00421   y = pmadd(y,z,p4f\_coscof\_p1);
00422   y = pmadd(y,z,p4f\_coscof\_p2);
00423   y = pmul(y, z);
00424   y = pmul(y, z);
00425   Packet4f tmp = \_mm\_mul\_ps(z, p4f\_half);
00426   y = psub(y, tmp);
00427   y = padd(y, p4f\_1);
00428 
00429   \textcolor{comment}{/* Evaluate the second polynom  (Pi/4 <= x <= 0) */}
00430   Packet4f y2 = p4f\_sincof\_p0;
00431   y2 = pmadd(y2, z, p4f\_sincof\_p1);
00432   y2 = pmadd(y2, z, p4f\_sincof\_p2);
00433   y2 = pmul(y2, z);
00434   y2 = pmadd(y2, x, x);
00435 
00436   \textcolor{comment}{/* select the correct result from the two polynoms */}
00437   y2 = \_mm\_and\_ps(poly\_mask, y2);
00438   y  = \_mm\_andnot\_ps(poly\_mask, y);
00439   y  = \_mm\_or\_ps(y,y2);
00440 
00441   \textcolor{comment}{/* update the sign */}
00442   \textcolor{keywordflow}{return} \_mm\_xor\_ps(y, sign\_bit);
00443 \}
00444 
00445 \textcolor{preprocessor}{#if EIGEN\_FAST\_MATH}
00446 
00447 \textcolor{comment}{// Functions for sqrt.}
00448 \textcolor{comment}{// The EIGEN\_FAST\_MATH version uses the \_mm\_rsqrt\_ps approximation and one step}
00449 \textcolor{comment}{// of Newton's method, at a cost of 1-2 bits of precision as opposed to the}
00450 \textcolor{comment}{// exact solution. It does not handle +inf, or denormalized numbers correctly.}
00451 \textcolor{comment}{// The main advantage of this approach is not just speed, but also the fact that}
00452 \textcolor{comment}{// it can be inlined and pipelined with other computations, further reducing its}
00453 \textcolor{comment}{// effective latency. This is similar to Quake3's fast inverse square root.}
00454 \textcolor{comment}{// For detail see here: http://www.beyond3d.com/content/articles/8/}
00455 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00456 Packet4f psqrt<Packet4f>(\textcolor{keyword}{const} Packet4f& \_x)
00457 \{
00458   Packet4f half = pmul(\_x, pset1<Packet4f>(.5f));
00459   Packet4f denormal\_mask = \_mm\_and\_ps(
00460       \_mm\_cmpge\_ps(\_x, \_mm\_setzero\_ps()),
00461       \_mm\_cmplt\_ps(\_x, pset1<Packet4f>((std::numeric\_limits<float>::min)())));
00462 
00463   \textcolor{comment}{// Compute approximate reciprocal sqrt.}
00464   Packet4f x = \_mm\_rsqrt\_ps(\_x);
00465   \textcolor{comment}{// Do a single step of Newton's iteration.}
00466   x = pmul(x, psub(pset1<Packet4f>(1.5f), pmul(half, pmul(x,x))));
00467   \textcolor{comment}{// Flush results for denormals to zero.}
00468   \textcolor{keywordflow}{return} \_mm\_andnot\_ps(denormal\_mask, pmul(\_x,x));
00469 \}
00470 
00471 \textcolor{preprocessor}{#else}
00472 
00473 \textcolor{keyword}{template}<>EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00474 Packet4f psqrt<Packet4f>(\textcolor{keyword}{const} Packet4f& x) \{ \textcolor{keywordflow}{return} \_mm\_sqrt\_ps(x); \}
00475 
00476 \textcolor{preprocessor}{#endif}
00477 
00478 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00479 Packet2d psqrt<Packet2d>(\textcolor{keyword}{const} Packet2d& x) \{ \textcolor{keywordflow}{return} \_mm\_sqrt\_pd(x); \}
00480 
00481 \textcolor{preprocessor}{#if EIGEN\_FAST\_MATH}
00482 
00483 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00484 Packet4f prsqrt<Packet4f>(\textcolor{keyword}{const} Packet4f& \_x) \{
00485   \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(inf, 0x7f800000);
00486   \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(nan, 0x7fc00000);
00487   \_EIGEN\_DECLARE\_CONST\_Packet4f(one\_point\_five, 1.5f);
00488   \_EIGEN\_DECLARE\_CONST\_Packet4f(minus\_half, -0.5f);
00489   \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(flt\_min, 0x00800000);
00490 
00491   Packet4f neg\_half = pmul(\_x, p4f\_minus\_half);
00492 
00493   \textcolor{comment}{// select only the inverse sqrt of positive normal inputs (denormals are}
00494   \textcolor{comment}{// flushed to zero and cause infs as well).}
00495   Packet4f le\_zero\_mask = \_mm\_cmple\_ps(\_x, p4f\_flt\_min);
00496   Packet4f x = \_mm\_andnot\_ps(le\_zero\_mask, \_mm\_rsqrt\_ps(\_x));
00497 
00498   \textcolor{comment}{// Fill in NaNs and Infs for the negative/zero entries.}
00499   Packet4f neg\_mask = \_mm\_cmplt\_ps(\_x, \_mm\_setzero\_ps());
00500   Packet4f zero\_mask = \_mm\_andnot\_ps(neg\_mask, le\_zero\_mask);
00501   Packet4f infs\_and\_nans = \_mm\_or\_ps(\_mm\_and\_ps(neg\_mask, p4f\_nan),
00502                                      \_mm\_and\_ps(zero\_mask, p4f\_inf));
00503 
00504   \textcolor{comment}{// Do a single step of Newton's iteration.}
00505   x = pmul(x, pmadd(neg\_half, pmul(x, x), p4f\_one\_point\_five));
00506 
00507   \textcolor{comment}{// Insert NaNs and Infs in all the right places.}
00508   \textcolor{keywordflow}{return} \_mm\_or\_ps(x, infs\_and\_nans);
00509 \}
00510 
00511 \textcolor{preprocessor}{#else}
00512 
00513 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00514 Packet4f prsqrt<Packet4f>(\textcolor{keyword}{const} Packet4f& x) \{
00515   \textcolor{comment}{// Unfortunately we can't use the much faster mm\_rqsrt\_ps since it only provides an approximation.}
00516   \textcolor{keywordflow}{return} \_mm\_div\_ps(pset1<Packet4f>(1.0f), \_mm\_sqrt\_ps(x));
00517 \}
00518 
00519 \textcolor{preprocessor}{#endif}
00520 
00521 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00522 Packet2d prsqrt<Packet2d>(\textcolor{keyword}{const} Packet2d& x) \{
00523   \textcolor{comment}{// Unfortunately we can't use the much faster mm\_rqsrt\_pd since it only provides an approximation.}
00524   \textcolor{keywordflow}{return} \_mm\_div\_pd(pset1<Packet2d>(1.0), \_mm\_sqrt\_pd(x));
00525 \}
00526 
00527 \textcolor{comment}{// Hyperbolic Tangent function.}
00528 \textcolor{keyword}{template} <>
00529 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet4f
00530 ptanh<Packet4f>(\textcolor{keyword}{const} Packet4f& x) \{
00531   \textcolor{keywordflow}{return} internal::generic\_fast\_tanh\_float(x);
00532 \}
00533 
00534 \} \textcolor{comment}{// end namespace internal}
00535 
00536 \textcolor{keyword}{namespace }numext \{
00537 
00538 \textcolor{keyword}{template}<>
00539 EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE
00540 \textcolor{keywordtype}{float} sqrt(\textcolor{keyword}{const} \textcolor{keywordtype}{float} &x)
00541 \{
00542   \textcolor{keywordflow}{return} internal::pfirst(internal::Packet4f(\_mm\_sqrt\_ss(\_mm\_set\_ss(x))));
00543 \}
00544 
00545 \textcolor{keyword}{template}<>
00546 EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE
00547 \textcolor{keywordtype}{double} sqrt(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &x)
00548 \{
00549 \textcolor{preprocessor}{#if EIGEN\_COMP\_GNUC\_STRICT}
00550   \textcolor{comment}{// This works around a GCC bug generating poor code for \_mm\_sqrt\_pd}
00551   \textcolor{comment}{// See https://bitbucket.org/eigen/eigen/commits/14f468dba4d350d7c19c9b93072e19f7b3df563b}
00552   \textcolor{keywordflow}{return} internal::pfirst(internal::Packet2d(\_\_builtin\_ia32\_sqrtsd(\_mm\_set\_sd(x))));
00553 \textcolor{preprocessor}{#else}
00554   \textcolor{keywordflow}{return} internal::pfirst(internal::Packet2d(\_mm\_sqrt\_pd(\_mm\_set\_sd(x))));
00555 \textcolor{preprocessor}{#endif}
00556 \}
00557 
00558 \} \textcolor{comment}{// end namespace numex}
00559 
00560 \} \textcolor{comment}{// end namespace Eigen}
00561 
00562 \textcolor{preprocessor}{#endif // EIGEN\_MATH\_FUNCTIONS\_SSE\_H}
\end{DoxyCode}
