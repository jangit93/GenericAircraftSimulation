\hypertarget{eigen_2test_2unalignedassert_8cpp_source}{}\section{eigen/test/unalignedassert.cpp}
\label{eigen_2test_2unalignedassert_8cpp_source}\index{unalignedassert.\+cpp@{unalignedassert.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#if defined(EIGEN\_TEST\_PART\_1)}
00012   \textcolor{comment}{// default}
00013 \textcolor{preprocessor}{#elif defined(EIGEN\_TEST\_PART\_2)}
00014 \textcolor{preprocessor}{  #define EIGEN\_MAX\_STATIC\_ALIGN\_BYTES 16}
00015 \textcolor{preprocessor}{  #define EIGEN\_MAX\_ALIGN\_BYTES 16}
00016 \textcolor{preprocessor}{#elif defined(EIGEN\_TEST\_PART\_3)}
00017 \textcolor{preprocessor}{  #define EIGEN\_MAX\_STATIC\_ALIGN\_BYTES 32}
00018 \textcolor{preprocessor}{  #define EIGEN\_MAX\_ALIGN\_BYTES 32}
00019 \textcolor{preprocessor}{#elif defined(EIGEN\_TEST\_PART\_4)}
00020 \textcolor{preprocessor}{  #define EIGEN\_MAX\_STATIC\_ALIGN\_BYTES 64}
00021 \textcolor{preprocessor}{  #define EIGEN\_MAX\_ALIGN\_BYTES 64}
00022 \textcolor{preprocessor}{#endif}
00023 
00024 \textcolor{preprocessor}{#include "main.h"}
00025 
00026 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,  6,1>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Vector6f};
00027 \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<float,  8,1>} \hyperlink{group___core___module}{Vector8f};
00028 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float, 12,1>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Vector12f};
00029 
00030 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double, 5,1>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Vector5d};
00031 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double, 6,1>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Vector6d};
00032 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double, 7,1>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Vector7d};
00033 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double, 8,1>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Vector8d};
00034 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double, 9,1>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Vector9d};
00035 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,10,1>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Vector10d};
00036 \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,12,1>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Vector12d};
00037 
\Hypertarget{eigen_2test_2unalignedassert_8cpp_source_l00038}\hyperlink{struct_test_new1}{00038} \textcolor{keyword}{struct }\hyperlink{struct_test_new1}{TestNew1}
00039 \{
00040   MatrixXd m; \textcolor{comment}{// good: m will allocate its own array, taking care of alignment.}
00041   \hyperlink{struct_test_new1}{TestNew1}() : m(20,20) \{\}
00042 \};
00043 
\Hypertarget{eigen_2test_2unalignedassert_8cpp_source_l00044}\hyperlink{struct_test_new2}{00044} \textcolor{keyword}{struct }\hyperlink{struct_test_new2}{TestNew2}
00045 \{
00046   Matrix3d m; \textcolor{comment}{// good: m's size isn't a multiple of 16 bytes, so m doesn't have to be 16-byte aligned,}
00047               \textcolor{comment}{// 8-byte alignment is good enough here, which we'll get automatically}
00048 \};
00049 
\Hypertarget{eigen_2test_2unalignedassert_8cpp_source_l00050}\hyperlink{struct_test_new3}{00050} \textcolor{keyword}{struct }\hyperlink{struct_test_new3}{TestNew3}
00051 \{
00052   Vector2f m; \textcolor{comment}{// good: m's size isn't a multiple of 16 bytes, so m doesn't have to be 16-byte aligned}
00053 \};
00054 
\Hypertarget{eigen_2test_2unalignedassert_8cpp_source_l00055}\hyperlink{struct_test_new4}{00055} \textcolor{keyword}{struct }\hyperlink{struct_test_new4}{TestNew4}
00056 \{
00057   EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW
00058   Vector2d m;
00059   \textcolor{keywordtype}{float} f; \textcolor{comment}{// make the struct have sizeof%16!=0 to make it a little more tricky when we allow an array of 2
       such objects}
00060 \};
00061 
\Hypertarget{eigen_2test_2unalignedassert_8cpp_source_l00062}\hyperlink{struct_test_new5}{00062} \textcolor{keyword}{struct }\hyperlink{struct_test_new5}{TestNew5}
00063 \{
00064   EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW
00065   \textcolor{keywordtype}{float} f; \textcolor{comment}{// try the f at first -- the EIGEN\_ALIGN\_MAX attribute of m should make that still work}
00066   Matrix4f m;
00067 \};
00068 
\Hypertarget{eigen_2test_2unalignedassert_8cpp_source_l00069}\hyperlink{struct_test_new6}{00069} \textcolor{keyword}{struct }\hyperlink{struct_test_new6}{TestNew6}
00070 \{
00071   \hyperlink{group___core___module}{Matrix<float,2,2,DontAlign>} m; \textcolor{comment}{// good: no alignment requested}
00072   \textcolor{keywordtype}{float} f;
00073 \};
00074 
\Hypertarget{eigen_2test_2unalignedassert_8cpp_source_l00075}\hyperlink{struct_depends}{00075} \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Align> \textcolor{keyword}{struct }\hyperlink{struct_depends}{Depends}
00076 \{
00077   EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF(Align)
00078   Vector2d m;
00079   \textcolor{keywordtype}{float} f;
00080 \};
00081 
00082 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00083 \textcolor{keywordtype}{void} check\_unalignedassert\_good()
00084 \{
00085   \hyperlink{group___sparse_core___module}{T} *x, *y;
00086   x = \textcolor{keyword}{new} \hyperlink{group___sparse_core___module}{T};
00087   \textcolor{keyword}{delete} x;
00088   y = \textcolor{keyword}{new} \hyperlink{group___sparse_core___module}{T}[2];
00089   \textcolor{keyword}{delete}[] y;
00090 \}
00091 
00092 \textcolor{preprocessor}{#if EIGEN\_MAX\_STATIC\_ALIGN\_BYTES>0}
00093 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00094 \textcolor{keywordtype}{void} construct\_at\_boundary(\textcolor{keywordtype}{int} boundary)
00095 \{
00096   \textcolor{keywordtype}{char} buf[\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module}{T})+256];
00097   \textcolor{keywordtype}{size\_t} \_buf = \textcolor{keyword}{reinterpret\_cast<}internal::UIntPtr\textcolor{keyword}{>}(buf);
00098   \_buf += (EIGEN\_MAX\_ALIGN\_BYTES - (\_buf % EIGEN\_MAX\_ALIGN\_BYTES)); \textcolor{comment}{// make 16/32/...-byte aligned}
00099   \_buf += boundary; \textcolor{comment}{// make exact boundary-aligned}
00100   \hyperlink{group___sparse_core___module}{T} *x = ::new(reinterpret\_cast<void*>(\_buf)) \hyperlink{group___sparse_core___module}{T};
00101   x[0].setZero(); \textcolor{comment}{// just in order to silence warnings}
00102   x->~T();
00103 \}
00104 \textcolor{preprocessor}{#endif}
00105 
00106 \textcolor{keywordtype}{void} unalignedassert()
00107 \{
00108 \textcolor{preprocessor}{#if EIGEN\_MAX\_STATIC\_ALIGN\_BYTES>0}
00109   construct\_at\_boundary<Vector2f>(4);
00110   construct\_at\_boundary<Vector3f>(4);
00111   construct\_at\_boundary<Vector4f>(16);
00112   construct\_at\_boundary<Vector6f>(4);
00113   construct\_at\_boundary<Vector8f>(EIGEN\_MAX\_ALIGN\_BYTES);
00114   construct\_at\_boundary<Vector12f>(16);
00115   construct\_at\_boundary<Matrix2f>(16);
00116   construct\_at\_boundary<Matrix3f>(4);
00117   construct\_at\_boundary<Matrix4f>(EIGEN\_MAX\_ALIGN\_BYTES);
00118 
00119   construct\_at\_boundary<Vector2d>(16);
00120   construct\_at\_boundary<Vector3d>(4);
00121   construct\_at\_boundary<Vector4d>(EIGEN\_MAX\_ALIGN\_BYTES);
00122   construct\_at\_boundary<Vector5d>(4);
00123   construct\_at\_boundary<Vector6d>(16);
00124   construct\_at\_boundary<Vector7d>(4);
00125   construct\_at\_boundary<Vector8d>(EIGEN\_MAX\_ALIGN\_BYTES);
00126   construct\_at\_boundary<Vector9d>(4);
00127   construct\_at\_boundary<Vector10d>(16);
00128   construct\_at\_boundary<Vector12d>(EIGEN\_MAX\_ALIGN\_BYTES);
00129   construct\_at\_boundary<Matrix2d>(EIGEN\_MAX\_ALIGN\_BYTES);
00130   construct\_at\_boundary<Matrix3d>(4);
00131   construct\_at\_boundary<Matrix4d>(EIGEN\_MAX\_ALIGN\_BYTES);
00132 
00133   construct\_at\_boundary<Vector2cf>(16);
00134   construct\_at\_boundary<Vector3cf>(4);
00135   construct\_at\_boundary<Vector2cd>(EIGEN\_MAX\_ALIGN\_BYTES);
00136   construct\_at\_boundary<Vector3cd>(16);
00137 \textcolor{preprocessor}{#endif}
00138 
00139   check\_unalignedassert\_good<TestNew1>();
00140   check\_unalignedassert\_good<TestNew2>();
00141   check\_unalignedassert\_good<TestNew3>();
00142 
00143   check\_unalignedassert\_good<TestNew4>();
00144   check\_unalignedassert\_good<TestNew5>();
00145   check\_unalignedassert\_good<TestNew6>();
00146   check\_unalignedassert\_good<Depends<true> >();
00147 
00148 \textcolor{preprocessor}{#if EIGEN\_MAX\_STATIC\_ALIGN\_BYTES>0}
00149   \textcolor{keywordflow}{if}(EIGEN\_MAX\_ALIGN\_BYTES>=16)
00150   \{
00151     VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector4f>(8));
00152     VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector8f>(8));
00153     VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector12f>(8));
00154     VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector2d>(8));
00155     VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector4d>(8));
00156     VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector6d>(8));
00157     VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector8d>(8));
00158     VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector10d>(8));
00159     VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector12d>(8));
00160     \textcolor{comment}{// Complexes are disabled because the compiler might aggressively vectorize}
00161     \textcolor{comment}{// the initialization of complex coeffs to 0 before we can check for alignedness}
00162     \textcolor{comment}{//VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector2cf>(8));}
00163     VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector4i>(8));
00164   \}
00165   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} b=8; b<EIGEN\_MAX\_ALIGN\_BYTES; b+=8)
00166   \{
00167     \textcolor{keywordflow}{if}(b<32)  VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector8f>(b));
00168     \textcolor{keywordflow}{if}(b<64)  VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Matrix4f>(b));
00169     \textcolor{keywordflow}{if}(b<32)  VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector4d>(b));
00170     \textcolor{keywordflow}{if}(b<32)  VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Matrix2d>(b));
00171     \textcolor{keywordflow}{if}(b<128) VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Matrix4d>(b));
00172     \textcolor{comment}{//if(b<32)  VERIFY\_RAISES\_ASSERT(construct\_at\_boundary<Vector2cd>(b));}
00173   \}
00174 \textcolor{preprocessor}{#endif}
00175 \}
00176 
00177 \textcolor{keywordtype}{void} test\_unalignedassert()
00178 \{
00179   CALL\_SUBTEST(unalignedassert());
00180 \}
\end{DoxyCode}
