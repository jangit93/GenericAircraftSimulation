\hypertarget{eigen_2unsupported_2_eigen_2src_2_b_v_h_2_b_v_algorithms_8h_source}{}\section{eigen/unsupported/\+Eigen/src/\+B\+V\+H/\+B\+V\+Algorithms.h}
\label{eigen_2unsupported_2_eigen_2src_2_b_v_h_2_b_v_algorithms_8h_source}\index{B\+V\+Algorithms.\+h@{B\+V\+Algorithms.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Ilya Baran <ibaran@mit.edu>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_BVALGORITHMS\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_BVALGORITHMS\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{preprocessor}{#ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00018 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BVH, \textcolor{keyword}{typename} Intersector>
00019 \textcolor{keywordtype}{bool} intersect\_helper(\textcolor{keyword}{const} BVH &tree, Intersector &intersector, \textcolor{keyword}{typename} BVH::Index root)
00020 \{
00021   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00022   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH::VolumeIterator VolIter;
00023   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH::ObjectIterator ObjIter;
00024 
00025   VolIter vBegin = VolIter(), vEnd = VolIter();
00026   ObjIter oBegin = ObjIter(), oEnd = ObjIter();
00027 
00028   std::vector<Index> todo(1, root);
00029 
00030   \textcolor{keywordflow}{while}(!todo.empty()) \{
00031     tree.getChildren(todo.back(), vBegin, vEnd, oBegin, oEnd);
00032     todo.pop\_back();
00033 
00034     \textcolor{keywordflow}{for}(; vBegin != vEnd; ++vBegin) \textcolor{comment}{//go through child volumes}
00035       \textcolor{keywordflow}{if}(intersector.intersectVolume(tree.getVolume(*vBegin)))
00036         todo.push\_back(*vBegin);
00037 
00038     \textcolor{keywordflow}{for}(; oBegin != oEnd; ++oBegin) \textcolor{comment}{//go through child objects}
00039       \textcolor{keywordflow}{if}(intersector.intersectObject(*oBegin))
00040         \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \textcolor{comment}{//intersector said to stop query}
00041   \}
00042   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00043 \}
00044 \textcolor{preprocessor}{#endif //not EIGEN\_PARSED\_BY\_DOXYGEN}
00045 
00046 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Volume1, \textcolor{keyword}{typename} Object1, \textcolor{keyword}{typename} Object2, \textcolor{keyword}{typename} Intersector>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_b_v_h_2_b_v_algorithms_8h_source_l00047}\hyperlink{struct_eigen_1_1internal_1_1intersector__helper1}{00047} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1intersector__helper1}{intersector\_helper1}
00048 \{
00049   \hyperlink{struct_eigen_1_1internal_1_1intersector__helper1}{intersector\_helper1}(\textcolor{keyword}{const} Object2 &inStored, Intersector &in) : stored(inStored), 
      intersector(in) \{\}
00050   \textcolor{keywordtype}{bool} intersectVolume(\textcolor{keyword}{const} Volume1 &vol) \{ \textcolor{keywordflow}{return} intersector.intersectVolumeObject(vol, stored); \}
00051   \textcolor{keywordtype}{bool} intersectObject(\textcolor{keyword}{const} Object1 &obj) \{ \textcolor{keywordflow}{return} intersector.intersectObjectObject(obj, stored); \}
00052   Object2 stored;
00053   Intersector &intersector;
00054 \textcolor{keyword}{private}:
00055   \hyperlink{struct_eigen_1_1internal_1_1intersector__helper1}{intersector\_helper1}& operator=(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1intersector__helper1}{intersector\_helper1}&);
00056 \};
00057 
00058 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Volume2, \textcolor{keyword}{typename} Object2, \textcolor{keyword}{typename} Object1, \textcolor{keyword}{typename} Intersector>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_b_v_h_2_b_v_algorithms_8h_source_l00059}\hyperlink{struct_eigen_1_1internal_1_1intersector__helper2}{00059} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1intersector__helper2}{intersector\_helper2}
00060 \{
00061   \hyperlink{struct_eigen_1_1internal_1_1intersector__helper2}{intersector\_helper2}(\textcolor{keyword}{const} Object1 &inStored, Intersector &in) : stored(inStored), 
      intersector(in) \{\}
00062   \textcolor{keywordtype}{bool} intersectVolume(\textcolor{keyword}{const} Volume2 &vol) \{ \textcolor{keywordflow}{return} intersector.intersectObjectVolume(stored, vol); \}
00063   \textcolor{keywordtype}{bool} intersectObject(\textcolor{keyword}{const} Object2 &obj) \{ \textcolor{keywordflow}{return} intersector.intersectObjectObject(stored, obj); \}
00064   Object1 stored;
00065   Intersector &intersector;
00066 \textcolor{keyword}{private}:
00067   \hyperlink{struct_eigen_1_1internal_1_1intersector__helper2}{intersector\_helper2}& operator=(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1intersector__helper2}{intersector\_helper2}&);
00068 \};
00069 
00070 \} \textcolor{comment}{// end namespace internal}
00071 
00078 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BVH, \textcolor{keyword}{typename} Intersector>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_b_v_h_2_b_v_algorithms_8h_source_l00079}\hyperlink{namespace_eigen_a07d8e283f082c972338f3fc4f644b2a9}{00079} \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_a07d8e283f082c972338f3fc4f644b2a9}{BVIntersect}(\textcolor{keyword}{const} BVH &tree, Intersector &intersector)
00080 \{
00081   internal::intersect\_helper(tree, intersector, tree.getRootIndex());
00082 \}
00083 
00092 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BVH1, \textcolor{keyword}{typename} BVH2, \textcolor{keyword}{typename} Intersector>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_b_v_h_2_b_v_algorithms_8h_source_l00093}\hyperlink{namespace_eigen_ac3b8047a3ee05b5e6fec4668197a9a43}{00093} \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_a07d8e283f082c972338f3fc4f644b2a9}{BVIntersect}(\textcolor{keyword}{const} BVH1 &tree1, \textcolor{keyword}{const} BVH2 &tree2, Intersector &intersector) \textcolor{comment}{//TODO: tandem
       descent when it makes sense}
00094 \{
00095   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH1::Index Index1;
00096   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH2::Index Index2;
00097   \textcolor{keyword}{typedef} 
      \hyperlink{struct_eigen_1_1internal_1_1intersector__helper1}{internal::intersector\_helper1<typename BVH1::Volume, typename BVH1::Object, typename BVH2::Object,
       Intersector>}
       Helper1;
00098   \textcolor{keyword}{typedef} 
      \hyperlink{struct_eigen_1_1internal_1_1intersector__helper2}{internal::intersector\_helper2<typename BVH2::Volume, typename BVH2::Object, typename BVH1::Object,
       Intersector>}
       Helper2;
00099   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH1::VolumeIterator VolIter1;
00100   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH1::ObjectIterator ObjIter1;
00101   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH2::VolumeIterator VolIter2;
00102   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH2::ObjectIterator ObjIter2;
00103 
00104   VolIter1 vBegin1 = VolIter1(), vEnd1 = VolIter1();
00105   ObjIter1 oBegin1 = ObjIter1(), oEnd1 = ObjIter1();
00106   VolIter2 vBegin2 = VolIter2(), vEnd2 = VolIter2(), vCur2 = VolIter2();
00107   ObjIter2 oBegin2 = ObjIter2(), oEnd2 = ObjIter2(), oCur2 = ObjIter2();
00108 
00109   std::vector<std::pair<Index1, Index2> > todo(1, std::make\_pair(tree1.getRootIndex(), tree2.getRootIndex()
      ));
00110 
00111   \textcolor{keywordflow}{while}(!todo.empty()) \{
00112     tree1.getChildren(todo.back().first, vBegin1, vEnd1, oBegin1, oEnd1);
00113     tree2.getChildren(todo.back().second, vBegin2, vEnd2, oBegin2, oEnd2);
00114     todo.pop\_back();
00115 
00116     \textcolor{keywordflow}{for}(; vBegin1 != vEnd1; ++vBegin1) \{ \textcolor{comment}{//go through child volumes of first tree}
00117       \textcolor{keyword}{const} \textcolor{keyword}{typename} BVH1::Volume &vol1 = tree1.getVolume(*vBegin1);
00118       \textcolor{keywordflow}{for}(vCur2 = vBegin2; vCur2 != vEnd2; ++vCur2) \{ \textcolor{comment}{//go through child volumes of second tree}
00119         \textcolor{keywordflow}{if}(intersector.intersectVolumeVolume(vol1, tree2.getVolume(*vCur2)))
00120           todo.push\_back(std::make\_pair(*vBegin1, *vCur2));
00121       \}
00122 
00123       \textcolor{keywordflow}{for}(oCur2 = oBegin2; oCur2 != oEnd2; ++oCur2) \{\textcolor{comment}{//go through child objects of second tree}
00124         Helper1 helper(*oCur2, intersector);
00125         \textcolor{keywordflow}{if}(internal::intersect\_helper(tree1, helper, *vBegin1))
00126           \textcolor{keywordflow}{return}; \textcolor{comment}{//intersector said to stop query}
00127       \}
00128     \}
00129 
00130     \textcolor{keywordflow}{for}(; oBegin1 != oEnd1; ++oBegin1) \{ \textcolor{comment}{//go through child objects of first tree}
00131       \textcolor{keywordflow}{for}(vCur2 = vBegin2; vCur2 != vEnd2; ++vCur2) \{ \textcolor{comment}{//go through child volumes of second tree}
00132         Helper2 helper(*oBegin1, intersector);
00133         \textcolor{keywordflow}{if}(internal::intersect\_helper(tree2, helper, *vCur2))
00134           \textcolor{keywordflow}{return}; \textcolor{comment}{//intersector said to stop query}
00135       \}
00136 
00137       \textcolor{keywordflow}{for}(oCur2 = oBegin2; oCur2 != oEnd2; ++oCur2) \{\textcolor{comment}{//go through child objects of second tree}
00138         \textcolor{keywordflow}{if}(intersector.intersectObjectObject(*oBegin1, *oCur2))
00139           \textcolor{keywordflow}{return}; \textcolor{comment}{//intersector said to stop query}
00140       \}
00141     \}
00142   \}
00143 \}
00144 
00145 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00146 
00147 \textcolor{preprocessor}{#ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00148 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BVH, \textcolor{keyword}{typename} Minimizer>
00149 \textcolor{keyword}{typename} Minimizer::Scalar minimize\_helper(\textcolor{keyword}{const} BVH &tree, Minimizer &minimizer, \textcolor{keyword}{typename} BVH::Index root,
       \textcolor{keyword}{typename} Minimizer::Scalar minimum)
00150 \{
00151   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Minimizer::Scalar Scalar;
00152   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00153   \textcolor{keyword}{typedef} std::pair<Scalar, Index> QueueElement; \textcolor{comment}{//first element is priority}
00154   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH::VolumeIterator VolIter;
00155   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH::ObjectIterator ObjIter;
00156 
00157   VolIter vBegin = VolIter(), vEnd = VolIter();
00158   ObjIter oBegin = ObjIter(), oEnd = ObjIter();
00159   std::priority\_queue<QueueElement, std::vector<QueueElement>, std::greater<QueueElement> > todo; \textcolor{comment}{//
      smallest is at the top}
00160 
00161   todo.push(std::make\_pair(Scalar(), root));
00162 
00163   \textcolor{keywordflow}{while}(!todo.empty()) \{
00164     tree.getChildren(todo.top().second, vBegin, vEnd, oBegin, oEnd);
00165     todo.pop();
00166 
00167     \textcolor{keywordflow}{for}(; oBegin != oEnd; ++oBegin) \textcolor{comment}{//go through child objects}
00168       minimum = (std::min)(minimum, minimizer.minimumOnObject(*oBegin));
00169 
00170     \textcolor{keywordflow}{for}(; vBegin != vEnd; ++vBegin) \{ \textcolor{comment}{//go through child volumes}
00171       Scalar val = minimizer.minimumOnVolume(tree.getVolume(*vBegin));
00172       \textcolor{keywordflow}{if}(val < minimum)
00173         todo.push(std::make\_pair(val, *vBegin));
00174     \}
00175   \}
00176 
00177   \textcolor{keywordflow}{return} minimum;
00178 \}
00179 \textcolor{preprocessor}{#endif //not EIGEN\_PARSED\_BY\_DOXYGEN}
00180 
00181 
00182 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Volume1, \textcolor{keyword}{typename} Object1, \textcolor{keyword}{typename} Object2, \textcolor{keyword}{typename} Minimizer>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_b_v_h_2_b_v_algorithms_8h_source_l00183}\hyperlink{struct_eigen_1_1internal_1_1minimizer__helper1}{00183} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1minimizer__helper1}{minimizer\_helper1}
00184 \{
00185   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Minimizer::Scalar Scalar;
00186   \hyperlink{struct_eigen_1_1internal_1_1minimizer__helper1}{minimizer\_helper1}(\textcolor{keyword}{const} Object2 &inStored, Minimizer &m) : stored(inStored), minimizer(m
      ) \{\}
00187   Scalar minimumOnVolume(\textcolor{keyword}{const} Volume1 &vol) \{ \textcolor{keywordflow}{return} minimizer.minimumOnVolumeObject(vol, stored); \}
00188   Scalar minimumOnObject(\textcolor{keyword}{const} Object1 &obj) \{ \textcolor{keywordflow}{return} minimizer.minimumOnObjectObject(obj, stored); \}
00189   Object2 stored;
00190   Minimizer &minimizer;
00191 \textcolor{keyword}{private}:
00192   \hyperlink{struct_eigen_1_1internal_1_1minimizer__helper1}{minimizer\_helper1}& operator=(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1minimizer__helper1}{minimizer\_helper1}&);
00193 \};
00194 
00195 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Volume2, \textcolor{keyword}{typename} Object2, \textcolor{keyword}{typename} Object1, \textcolor{keyword}{typename} Minimizer>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_b_v_h_2_b_v_algorithms_8h_source_l00196}\hyperlink{struct_eigen_1_1internal_1_1minimizer__helper2}{00196} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1minimizer__helper2}{minimizer\_helper2}
00197 \{
00198   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Minimizer::Scalar Scalar;
00199   \hyperlink{struct_eigen_1_1internal_1_1minimizer__helper2}{minimizer\_helper2}(\textcolor{keyword}{const} Object1 &inStored, Minimizer &m) : stored(inStored), minimizer(m
      ) \{\}
00200   Scalar minimumOnVolume(\textcolor{keyword}{const} Volume2 &vol) \{ \textcolor{keywordflow}{return} minimizer.minimumOnObjectVolume(stored, vol); \}
00201   Scalar minimumOnObject(\textcolor{keyword}{const} Object2 &obj) \{ \textcolor{keywordflow}{return} minimizer.minimumOnObjectObject(stored, obj); \}
00202   Object1 stored;
00203   Minimizer &minimizer;
00204 \textcolor{keyword}{private}:
00205   \hyperlink{struct_eigen_1_1internal_1_1minimizer__helper2}{minimizer\_helper2}& operator=(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1minimizer__helper2}{minimizer\_helper2}&);
00206 \};
00207 
00208 \} \textcolor{comment}{// end namespace internal}
00209 
00218 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BVH, \textcolor{keyword}{typename} Minimizer>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_b_v_h_2_b_v_algorithms_8h_source_l00219}\hyperlink{namespace_eigen_adcbe73ac1482eacab0e18ee32c25508e}{00219} \textcolor{keyword}{typename} Minimizer::Scalar \hyperlink{namespace_eigen_adcbe73ac1482eacab0e18ee32c25508e}{BVMinimize}(\textcolor{keyword}{const} BVH &tree, Minimizer &minimizer)
00220 \{
00221   \textcolor{keywordflow}{return} internal::minimize\_helper(tree, minimizer, tree.getRootIndex(), (std::numeric\_limits<typename
       Minimizer::Scalar>::max)());
00222 \}
00223 
00234 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BVH1, \textcolor{keyword}{typename} BVH2, \textcolor{keyword}{typename} Minimizer>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_b_v_h_2_b_v_algorithms_8h_source_l00235}\hyperlink{namespace_eigen_a915f6adc8b195c94a83c35de6a842556}{00235} \textcolor{keyword}{typename} Minimizer::Scalar \hyperlink{namespace_eigen_adcbe73ac1482eacab0e18ee32c25508e}{BVMinimize}(\textcolor{keyword}{const} BVH1 &tree1, \textcolor{keyword}{const} BVH2 &tree2, Minimizer &minimizer)
00236 \{
00237   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Minimizer::Scalar Scalar;
00238   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH1::Index Index1;
00239   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH2::Index Index2;
00240   \textcolor{keyword}{typedef} 
      \hyperlink{struct_eigen_1_1internal_1_1minimizer__helper1}{internal::minimizer\_helper1<typename BVH1::Volume, typename BVH1::Object, typename BVH2::Object, Minimizer>}
       Helper1;
00241   \textcolor{keyword}{typedef} 
      \hyperlink{struct_eigen_1_1internal_1_1minimizer__helper2}{internal::minimizer\_helper2<typename BVH2::Volume, typename BVH2::Object, typename BVH1::Object, Minimizer>}
       Helper2;
00242   \textcolor{keyword}{typedef} std::pair<Scalar, std::pair<Index1, Index2> > QueueElement; \textcolor{comment}{//first element is priority}
00243   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH1::VolumeIterator VolIter1;
00244   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH1::ObjectIterator ObjIter1;
00245   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH2::VolumeIterator VolIter2;
00246   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BVH2::ObjectIterator ObjIter2;
00247 
00248   VolIter1 vBegin1 = VolIter1(), vEnd1 = VolIter1();
00249   ObjIter1 oBegin1 = ObjIter1(), oEnd1 = ObjIter1();
00250   VolIter2 vBegin2 = VolIter2(), vEnd2 = VolIter2(), vCur2 = VolIter2();
00251   ObjIter2 oBegin2 = ObjIter2(), oEnd2 = ObjIter2(), oCur2 = ObjIter2();
00252   std::priority\_queue<QueueElement, std::vector<QueueElement>, std::greater<QueueElement> > todo; \textcolor{comment}{//
      smallest is at the top}
00253 
00254   Scalar minimum = (std::numeric\_limits<Scalar>::max)();
00255   todo.push(std::make\_pair(Scalar(), std::make\_pair(tree1.getRootIndex(), tree2.getRootIndex())));
00256 
00257   \textcolor{keywordflow}{while}(!todo.empty()) \{
00258     tree1.getChildren(todo.top().second.first, vBegin1, vEnd1, oBegin1, oEnd1);
00259     tree2.getChildren(todo.top().second.second, vBegin2, vEnd2, oBegin2, oEnd2);
00260     todo.pop();
00261 
00262     \textcolor{keywordflow}{for}(; oBegin1 != oEnd1; ++oBegin1) \{ \textcolor{comment}{//go through child objects of first tree}
00263       \textcolor{keywordflow}{for}(oCur2 = oBegin2; oCur2 != oEnd2; ++oCur2) \{\textcolor{comment}{//go through child objects of second tree}
00264         minimum = (std::min)(minimum, minimizer.minimumOnObjectObject(*oBegin1, *oCur2));
00265       \}
00266 
00267       \textcolor{keywordflow}{for}(vCur2 = vBegin2; vCur2 != vEnd2; ++vCur2) \{ \textcolor{comment}{//go through child volumes of second tree}
00268         Helper2 helper(*oBegin1, minimizer);
00269         minimum = (std::min)(minimum, internal::minimize\_helper(tree2, helper, *vCur2, minimum));
00270       \}
00271     \}
00272 
00273     \textcolor{keywordflow}{for}(; vBegin1 != vEnd1; ++vBegin1) \{ \textcolor{comment}{//go through child volumes of first tree}
00274       \textcolor{keyword}{const} \textcolor{keyword}{typename} BVH1::Volume &vol1 = tree1.getVolume(*vBegin1);
00275 
00276       \textcolor{keywordflow}{for}(oCur2 = oBegin2; oCur2 != oEnd2; ++oCur2) \{\textcolor{comment}{//go through child objects of second tree}
00277         Helper1 helper(*oCur2, minimizer);
00278         minimum = (std::min)(minimum, internal::minimize\_helper(tree1, helper, *vBegin1, minimum));
00279       \}
00280 
00281       \textcolor{keywordflow}{for}(vCur2 = vBegin2; vCur2 != vEnd2; ++vCur2) \{ \textcolor{comment}{//go through child volumes of second tree}
00282         Scalar val = minimizer.minimumOnVolumeVolume(vol1, tree2.getVolume(*vCur2));
00283         \textcolor{keywordflow}{if}(val < minimum)
00284           todo.push(std::make\_pair(val, std::make\_pair(*vBegin1, *vCur2)));
00285       \}
00286     \}
00287   \}
00288   \textcolor{keywordflow}{return} minimum;
00289 \}
00290 
00291 \} \textcolor{comment}{// end namespace Eigen}
00292 
00293 \textcolor{preprocessor}{#endif // EIGEN\_BVALGORITHMS\_H}
\end{DoxyCode}
