\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_b_v_h_2_kd_b_v_h_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+B\+V\+H/\+Kd\+B\+VH.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_b_v_h_2_kd_b_v_h_8h_source}\index{Kd\+B\+V\+H.\+h@{Kd\+B\+V\+H.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Ilya Baran <ibaran@mit.edu>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef KDBVH\_H\_INCLUDED}
00011 \textcolor{preprocessor}{#define KDBVH\_H\_INCLUDED}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{comment}{//internal pair class for the BVH--used instead of std::pair because of alignment}
00018 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Dim>
00019 \textcolor{keyword}{struct }vector\_int\_pair
00020 \{
00021 EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF\_VECTORIZABLE\_FIXED\_SIZE(Scalar, Dim)
00022   \textcolor{keyword}{typedef} Matrix<Scalar, Dim, 1> \hyperlink{struct_vector_type}{VectorType};
00023 
00024   vector\_int\_pair(\textcolor{keyword}{const} VectorType &v, \textcolor{keywordtype}{int} i) : first(v), second(i) \{\}
00025 
00026   VectorType first;
00027   \textcolor{keywordtype}{int} second;
00028 \};
00029 
00030 \textcolor{comment}{//these templates help the tree initializer get the bounding boxes either from a provided}
00031 \textcolor{comment}{//iterator range or using bounding\_box in a unified way}
00032 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ObjectList, \textcolor{keyword}{typename} VolumeList, \textcolor{keyword}{typename} BoxIter>
00033 \textcolor{keyword}{struct }get\_boxes\_helper \{
00034   \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} ObjectList &objects, BoxIter boxBegin, BoxIter boxEnd, VolumeList &outBoxes)
00035   \{
00036     outBoxes.insert(outBoxes.end(), boxBegin, boxEnd);
00037     eigen\_assert(outBoxes.size() == objects.size());
00038   \}
00039 \};
00040 
00041 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ObjectList, \textcolor{keyword}{typename} VolumeList>
00042 \textcolor{keyword}{struct }get\_boxes\_helper<ObjectList, VolumeList, int> \{
00043   \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} ObjectList &objects, \textcolor{keywordtype}{int}, \textcolor{keywordtype}{int}, VolumeList &outBoxes)
00044   \{
00045     outBoxes.reserve(objects.size());
00046     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < (int)objects.size(); ++i)
00047       outBoxes.push\_back(bounding\_box(objects[i]));
00048   \}
00049 \};
00050 
00051 \} \textcolor{comment}{// end namespace internal}
00052 
00053 
00067 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Dim, \textcolor{keyword}{typename} \_Object> \textcolor{keyword}{class }KdBVH
00068 \{
00069 \textcolor{keyword}{public}:
00070   \textcolor{keyword}{enum} \{ Dim = \_Dim \};
00071   \textcolor{keyword}{typedef} \_Object Object;
00072   \textcolor{keyword}{typedef} std::vector<Object, aligned\_allocator<Object> > ObjectList;
00073   \textcolor{keyword}{typedef} \_Scalar Scalar;
00074   \textcolor{keyword}{typedef} AlignedBox<Scalar, Dim> Volume;
00075   \textcolor{keyword}{typedef} std::vector<Volume, aligned\_allocator<Volume> > VolumeList;
00076   \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00077   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \textcolor{keywordtype}{int} *VolumeIterator; \textcolor{comment}{//the iterators are just pointers into the tree's vectors}
00078   \textcolor{keyword}{typedef} \textcolor{keyword}{const} Object *ObjectIterator;
00079 
00080   KdBVH() \{\}
00081 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_b_v_h_2_kd_b_v_h_8h_source_l00083}\hyperlink{class_eigen_1_1_kd_b_v_h_a87d240e2d6ac5e87fc2e4ae6e0fe4bdc}{00083}   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Iter> \hyperlink{class_eigen_1_1_kd_b_v_h_a87d240e2d6ac5e87fc2e4ae6e0fe4bdc}{KdBVH}(Iter begin, Iter end) \{ \hyperlink{structinit}{init}(begin, end, 0, 0); \} \textcolor{comment}{//int is
       recognized by init as not being an iterator type}
00084 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_b_v_h_2_kd_b_v_h_8h_source_l00086}\hyperlink{class_eigen_1_1_kd_b_v_h_a94f781127eeec80a7659b8a625e2fa94}{00086}   \textcolor{keyword}{template}<\textcolor{keyword}{typename} OIter, \textcolor{keyword}{typename} BIter> \hyperlink{class_eigen_1_1_kd_b_v_h_a94f781127eeec80a7659b8a625e2fa94}{KdBVH}(OIter begin, OIter end, BIter boxBegin, BIter boxEnd)
       \{ \hyperlink{structinit}{init}(begin, end, boxBegin, boxEnd); \}
00087 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_b_v_h_2_kd_b_v_h_8h_source_l00090}\hyperlink{class_eigen_1_1_kd_b_v_h_a431eed3c2567a854fb350f0b327d3307}{00090}   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Iter> \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_kd_b_v_h_a431eed3c2567a854fb350f0b327d3307}{init}(Iter begin, Iter end) \{ \hyperlink{class_eigen_1_1_kd_b_v_h_a431eed3c2567a854fb350f0b327d3307}{init}(begin, end, 0, 0); \}
00091 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_b_v_h_2_kd_b_v_h_8h_source_l00094}\hyperlink{class_eigen_1_1_kd_b_v_h_a10a9c8f6d596d7a2cd285a3fb3e8c053}{00094}   \textcolor{keyword}{template}<\textcolor{keyword}{typename} OIter, \textcolor{keyword}{typename} BIter> \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_kd_b_v_h_a10a9c8f6d596d7a2cd285a3fb3e8c053}{init}(OIter begin, OIter end, BIter boxBegin, BIter 
      boxEnd)
00095   \{
00096     objects.clear();
00097     boxes.clear();
00098     children.clear();
00099 
00100     objects.insert(objects.end(), begin, end);
00101     \textcolor{keywordtype}{int} n = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(objects.size());
00102 
00103     \textcolor{keywordflow}{if}(n < 2)
00104       \textcolor{keywordflow}{return}; \textcolor{comment}{//if we have at most one object, we don't need any internal nodes}
00105 
00106     VolumeList objBoxes;
00107     VIPairList objCenters;
00108 
00109     \textcolor{comment}{//compute the bounding boxes depending on BIter type}
00110     \hyperlink{struct_eigen_1_1internal_1_1get__boxes__helper}{internal::get\_boxes\_helper<ObjectList, VolumeList, BIter>}
      ()(objects, boxBegin, boxEnd, objBoxes);
00111 
00112     objCenters.reserve(n);
00113     boxes.reserve(n - 1);
00114     children.reserve(2 * n - 2);
00115 
00116     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < n; ++i)
00117       objCenters.push\_back(\hyperlink{struct_eigen_1_1internal_1_1vector__int__pair}{VIPair}(objBoxes[i].center(), i));
00118 
00119     build(objCenters, 0, n, objBoxes, 0); \textcolor{comment}{//the recursive part of the algorithm}
00120 
00121     ObjectList tmp(n);
00122     tmp.swap(objects);
00123     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < n; ++i)
00124       objects[i] = tmp[objCenters[i].second];
00125   \}
00126 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_b_v_h_2_kd_b_v_h_8h_source_l00128}\hyperlink{class_eigen_1_1_kd_b_v_h_a8111486ece7980dd8f0d10aff9693d11}{00128}   \textcolor{keyword}{inline} Index \hyperlink{class_eigen_1_1_kd_b_v_h_a8111486ece7980dd8f0d10aff9693d11}{getRootIndex}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} (\textcolor{keywordtype}{int})boxes.size() - 1; \}
00129 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_b_v_h_2_kd_b_v_h_8h_source_l00132}\hyperlink{class_eigen_1_1_kd_b_v_h_a67326b18fcf16f341d2e4a16006d0205}{00132}   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_kd_b_v_h_a67326b18fcf16f341d2e4a16006d0205}{getChildren}(Index index, VolumeIterator &outVBegin, VolumeIterator &
      outVEnd,
00133                                        ObjectIterator &outOBegin, ObjectIterator &outOEnd)\textcolor{keyword}{ const}
00134 \textcolor{keyword}{  }\{ \textcolor{comment}{//inlining this function should open lots of optimization opportunities to the compiler}
00135     \textcolor{keywordflow}{if}(index < 0) \{
00136       outVBegin = outVEnd;
00137       \textcolor{keywordflow}{if}(!objects.empty())
00138         outOBegin = &(objects[0]);
00139       outOEnd = outOBegin + objects.size(); \textcolor{comment}{//output all objects--necessary when the tree has only one
       object}
00140       \textcolor{keywordflow}{return};
00141     \}
00142 
00143     \textcolor{keywordtype}{int} numBoxes = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(boxes.size());
00144 
00145     \textcolor{keywordtype}{int} idx = index * 2;
00146     \textcolor{keywordflow}{if}(children[idx + 1] < numBoxes) \{ \textcolor{comment}{//second index is always bigger}
00147       outVBegin = &(children[idx]);
00148       outVEnd = outVBegin + 2;
00149       outOBegin = outOEnd;
00150     \}
00151     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(children[idx] >= numBoxes) \{ \textcolor{comment}{//if both children are objects}
00152       outVBegin = outVEnd;
00153       outOBegin = &(objects[children[idx] - numBoxes]);
00154       outOEnd = outOBegin + 2;
00155     \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{//if the first child is a volume and the second is an object}
00156       outVBegin = &(children[idx]);
00157       outVEnd = outVBegin + 1;
00158       outOBegin = &(objects[children[idx + 1] - numBoxes]);
00159       outOEnd = outOBegin + 1;
00160     \}
00161   \}
00162 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_b_v_h_2_kd_b_v_h_8h_source_l00164}\hyperlink{class_eigen_1_1_kd_b_v_h_a59e7a2afb19fe7ae919fb95425bd6bf0}{00164}   \textcolor{keyword}{inline} \textcolor{keyword}{const} Volume &\hyperlink{class_eigen_1_1_kd_b_v_h_a59e7a2afb19fe7ae919fb95425bd6bf0}{getVolume}(Index index)\textcolor{keyword}{ const}
00165 \textcolor{keyword}{  }\{
00166     \textcolor{keywordflow}{return} boxes[index];
00167   \}
00168 
00169 \textcolor{keyword}{private}:
00170   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1vector__int__pair}{internal::vector\_int\_pair<Scalar, Dim>} 
      \hyperlink{struct_eigen_1_1internal_1_1vector__int__pair}{VIPair};
00171   \textcolor{keyword}{typedef} std::vector<VIPair, aligned\_allocator<VIPair> > VIPairList;
00172   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar, Dim, 1>} \hyperlink{group___core___module}{VectorType};
00173   \textcolor{keyword}{struct }VectorComparator \textcolor{comment}{//compares vectors, or, more specificall, VIPairs along a particular dimension}
00174   \{
00175     VectorComparator(\textcolor{keywordtype}{int} inDim) : dim(inDim) \{\}
00176     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} VIPair &v1, \textcolor{keyword}{const} VIPair &v2)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} v1.first[dim] < v2.first[dim]
      ; \}
00177     \textcolor{keywordtype}{int} dim;
00178   \};
00179 
00180   \textcolor{comment}{//Build the part of the tree between objects[from] and objects[to] (not including objects[to]).}
00181   \textcolor{comment}{//This routine partitions the objCenters in [from, to) along the dimension dim, recursively constructs}
00182   \textcolor{comment}{//the two halves, and adds their parent node.  TODO: a cache-friendlier layout}
00183   \textcolor{keywordtype}{void} build(VIPairList &objCenters, \textcolor{keywordtype}{int} from, \textcolor{keywordtype}{int} to, \textcolor{keyword}{const} VolumeList &objBoxes, \textcolor{keywordtype}{int} dim)
00184   \{
00185     eigen\_assert(to - from > 1);
00186     \textcolor{keywordflow}{if}(to - from == 2) \{
00187       boxes.push\_back(objBoxes[objCenters[from].second].merged(objBoxes[objCenters[from + 1].second]));
00188       children.push\_back(from + (\textcolor{keywordtype}{int})objects.size() - 1); \textcolor{comment}{//there are objects.size() - 1 tree nodes}
00189       children.push\_back(from + (\textcolor{keywordtype}{int})objects.size());
00190     \}
00191     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(to - from == 3) \{
00192       \textcolor{keywordtype}{int} mid = from + 2;
00193       std::nth\_element(objCenters.begin() + from, objCenters.begin() + mid,
00194                         objCenters.begin() + to, VectorComparator(dim)); \textcolor{comment}{//partition}
00195       build(objCenters, from, mid, objBoxes, (dim + 1) % Dim);
00196       \textcolor{keywordtype}{int} idx1 = (int)boxes.size() - 1;
00197       boxes.push\_back(boxes[idx1].merged(objBoxes[objCenters[mid].second]));
00198       children.push\_back(idx1);
00199       children.push\_back(mid + (\textcolor{keywordtype}{int})objects.size() - 1);
00200     \}
00201     \textcolor{keywordflow}{else} \{
00202       \textcolor{keywordtype}{int} mid = from + (to - from) / 2;
00203       nth\_element(objCenters.begin() + from, objCenters.begin() + mid,
00204                   objCenters.begin() + to, VectorComparator(dim)); \textcolor{comment}{//partition}
00205       build(objCenters, from, mid, objBoxes, (dim + 1) % Dim);
00206       \textcolor{keywordtype}{int} idx1 = (int)boxes.size() - 1;
00207       build(objCenters, mid, to, objBoxes, (dim + 1) % Dim);
00208       \textcolor{keywordtype}{int} idx2 = (int)boxes.size() - 1;
00209       boxes.push\_back(boxes[idx1].merged(boxes[idx2]));
00210       children.push\_back(idx1);
00211       children.push\_back(idx2);
00212     \}
00213   \}
00214 
00215   std::vector<int> children; \textcolor{comment}{//children of x are children[2x] and children[2x+1], indices bigger than
       boxes.size() index into objects.}
00216   VolumeList boxes;
00217   ObjectList objects;
00218 \};
00219 
00220 \} \textcolor{comment}{// end namespace Eigen}
00221 
00222 \textcolor{preprocessor}{#endif //KDBVH\_H\_INCLUDED}
\end{DoxyCode}
