\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_alti_vec_2_complex_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/arch/\+Alti\+Vec/\+Complex.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_alti_vec_2_complex_8h_source}\index{Complex.\+h@{Complex.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2010-2016 Konstantinos Margaritis <markos@freevec.org>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_COMPLEX32\_ALTIVEC\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_COMPLEX32\_ALTIVEC\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00017 
00018 \textcolor{keyword}{static} Packet4ui  p4ui\_CONJ\_XOR = vec\_mergeh((Packet4ui)p4i\_ZERO, (Packet4ui)p4f\_MZERO);\textcolor{comment}{//\{ 0x00000000,
       0x80000000, 0x00000000, 0x80000000 \};}
00019 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00020 \textcolor{preprocessor}{#if defined(\_BIG\_ENDIAN)}
00021 \textcolor{keyword}{static} Packet2ul  p2ul\_CONJ\_XOR1 = (Packet2ul) vec\_sld((Packet4ui) p2d\_MZERO, (Packet4ui) p2l\_ZERO, 8);\textcolor{comment}{//\{
       0x8000000000000000, 0x0000000000000000 \};}
00022 \textcolor{keyword}{static} Packet2ul  p2ul\_CONJ\_XOR2 = (Packet2ul) vec\_sld((Packet4ui) p2l\_ZERO,  (Packet4ui) p2d\_MZERO, 8);\textcolor{comment}{//\{
       0x8000000000000000, 0x0000000000000000 \};}
00023 \textcolor{preprocessor}{#else}
00024 \textcolor{keyword}{static} Packet2ul  p2ul\_CONJ\_XOR1 = (Packet2ul) vec\_sld((Packet4ui) p2l\_ZERO,  (Packet4ui) p2d\_MZERO, 8);\textcolor{comment}{//\{
       0x8000000000000000, 0x0000000000000000 \};}
00025 \textcolor{keyword}{static} Packet2ul  p2ul\_CONJ\_XOR2 = (Packet2ul) vec\_sld((Packet4ui) p2d\_MZERO, (Packet4ui) p2l\_ZERO, 8);\textcolor{comment}{//\{
       0x8000000000000000, 0x0000000000000000 \};}
00026 \textcolor{preprocessor}{#endif}
00027 \textcolor{preprocessor}{#endif}
00028 
00029 \textcolor{comment}{//---------- float ----------}
00030 \textcolor{keyword}{struct }Packet2cf
00031 \{
00032   EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} Packet2cf() : v(p4f\_ZERO) \{\}
00033   EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} Packet2cf(\textcolor{keyword}{const} Packet4f& a) : v(a) \{\}
00034   Packet4f  v;
00035 \};
00036 
00037 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<float> >  : default\_packet\_traits
00038 \{
00039   \textcolor{keyword}{typedef} Packet2cf type;
00040   \textcolor{keyword}{typedef} Packet2cf half;
00041   \textcolor{keyword}{enum} \{
00042     Vectorizable = 1,
00043     AlignedOnScalar = 1,
00044     size = 2,
00045     HasHalfPacket = 0,
00046 
00047     HasAdd    = 1,
00048     HasSub    = 1,
00049     HasMul    = 1,
00050     HasDiv    = 1,
00051     HasNegate = 1,
00052     HasAbs    = 0,
00053     HasAbs2   = 0,
00054     HasMin    = 0,
00055     HasMax    = 0,
00056 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00057     HasBlend  = 1,
00058 \textcolor{preprocessor}{#endif}
00059     HasSetLinear = 0
00060   \};
00061 \};
00062 
00063 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet2cf> \{ \textcolor{keyword}{typedef} std::complex<float> type; \textcolor{keyword}{enum} \{size=2, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet2cf half; \};
00064 
00065 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pset1<Packet2cf>(\textcolor{keyword}{const} std::complex<float>&  from)
00066 \{
00067   Packet2cf res;
00068   \textcolor{keywordflow}{if}((std::ptrdiff\_t(&from) % 16) == 0)
00069     res.v = pload<Packet4f>((\textcolor{keyword}{const} \textcolor{keywordtype}{float} *)&from);
00070   \textcolor{keywordflow}{else}
00071     res.v = ploadu<Packet4f>((\textcolor{keyword}{const} \textcolor{keywordtype}{float} *)&from);
00072   res.v = vec\_perm(res.v, res.v, p16uc\_PSET64\_HI);
00073   \textcolor{keywordflow}{return} res;
00074 \}
00075 
00076 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pload<Packet2cf>(\textcolor{keyword}{const} std::complex<float>*        from) \{ \textcolor{keywordflow}{return} 
      Packet2cf(pload<Packet4f>((\textcolor{keyword}{const} \textcolor{keywordtype}{float} *) from)); \}
00077 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf ploadu<Packet2cf>(\textcolor{keyword}{const} std::complex<float>*       from) \{ \textcolor{keywordflow}{return} 
      Packet2cf(ploadu<Packet4f>((\textcolor{keyword}{const} \textcolor{keywordtype}{float}*) from)); \}
00078 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf ploaddup<Packet2cf>(\textcolor{keyword}{const} std::complex<float>*     from) \{ \textcolor{keywordflow}{return} 
      pset1<Packet2cf>(*from); \}
00079 
00080 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore <std::complex<float> >(std::complex<float> *   to, \textcolor{keyword}{const} 
      Packet2cf& from) \{ pstore((\textcolor{keywordtype}{float}*)to, from.v); \}
00081 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<std::complex<float> >(std::complex<float> *   to, \textcolor{keyword}{const} 
      Packet2cf& from) \{ pstoreu((\textcolor{keywordtype}{float}*)to, from.v); \}
00082 
00083 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet2cf pgather<std::complex<float>, Packet2cf>(\textcolor{keyword}{const} 
      std::complex<float>* from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00084 \{
00085   std::complex<float> EIGEN\_ALIGN16 af[2];
00086   af[0] = from[0*stride];
00087   af[1] = from[1*stride];
00088   \textcolor{keywordflow}{return} pload<Packet2cf>(af);
00089 \}
00090 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, \textcolor{keyword}{
      const} Packet2cf& from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00091 \{
00092   std::complex<float> EIGEN\_ALIGN16 af[2];
00093   pstore<std::complex<float> >((std::complex<float> *) af, from);
00094   to[0*stride] = af[0];
00095   to[1*stride] = af[1];
00096 \}
00097 
00098 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf padd<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{return} 
      Packet2cf(a.v + b.v); \}
00099 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf psub<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{return} 
      Packet2cf(a.v - b.v); \}
00100 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pnegate(\textcolor{keyword}{const} Packet2cf& a) \{ \textcolor{keywordflow}{return} Packet2cf(pnegate(a.v)); \}
00101 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pconj(\textcolor{keyword}{const} Packet2cf& a) \{ \textcolor{keywordflow}{return} Packet2cf(pxor<Packet4f>(a.v, 
      reinterpret\_cast<Packet4f>(p4ui\_CONJ\_XOR))); \}
00102 
00103 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pmul<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)
00104 \{
00105   Packet4f v1, v2;
00106 
00107   \textcolor{comment}{// Permute and multiply the real parts of a and b}
00108   v1 = vec\_perm(a.v, a.v, p16uc\_PSET32\_WODD);
00109   \textcolor{comment}{// Get the imaginary parts of a}
00110   v2 = vec\_perm(a.v, a.v, p16uc\_PSET32\_WEVEN);
00111   \textcolor{comment}{// multiply a\_re * b }
00112   v1 = vec\_madd(v1, b.v, p4f\_ZERO);
00113   \textcolor{comment}{// multiply a\_im * b and get the conjugate result}
00114   v2 = vec\_madd(v2, b.v, p4f\_ZERO);
00115   v2 = \textcolor{keyword}{reinterpret\_cast<}Packet4f\textcolor{keyword}{>}(pxor(v2, reinterpret\_cast<Packet4f>(p4ui\_CONJ\_XOR)));
00116   \textcolor{comment}{// permute back to a proper order}
00117   v2 = vec\_perm(v2, v2, p16uc\_COMPLEX32\_REV);
00118   
00119   \textcolor{keywordflow}{return} Packet2cf(padd<Packet4f>(v1, v2));
00120 \}
00121 
00122 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pand   <Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{
      return} Packet2cf(pand<Packet4f>(a.v, b.v)); \}
00123 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf por    <Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{
      return} Packet2cf(por<Packet4f>(a.v, b.v)); \}
00124 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pxor   <Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{
      return} Packet2cf(pxor<Packet4f>(a.v, b.v)); \}
00125 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pandnot<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{
      return} Packet2cf(pandnot<Packet4f>(a.v, b.v)); \}
00126 
00127 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<std::complex<float> >(\textcolor{keyword}{const} std::complex<float> * addr)    \{ 
      EIGEN\_PPC\_PREFETCH(addr); \}
00128 
00129 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float>  pfirst<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00130 \{
00131   std::complex<float> EIGEN\_ALIGN16 res[2];
00132   pstore((\textcolor{keywordtype}{float} *)&res, a.v);
00133 
00134   \textcolor{keywordflow}{return} res[0];
00135 \}
00136 
00137 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf preverse(\textcolor{keyword}{const} Packet2cf& a)
00138 \{
00139   Packet4f rev\_a;
00140   rev\_a = vec\_perm(a.v, a.v, p16uc\_COMPLEX32\_REV2);
00141   \textcolor{keywordflow}{return} Packet2cf(rev\_a);
00142 \}
00143 
00144 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> predux<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00145 \{
00146   Packet4f b;
00147   b = vec\_sld(a.v, a.v, 8);
00148   b = padd<Packet4f>(a.v, b);
00149   \textcolor{keywordflow}{return} pfirst<Packet2cf>(Packet2cf(b));
00150 \}
00151 
00152 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf preduxp<Packet2cf>(\textcolor{keyword}{const} Packet2cf* vecs)
00153 \{
00154   Packet4f b1, b2;
00155 \textcolor{preprocessor}{#ifdef \_BIG\_ENDIAN  }
00156   b1 = vec\_sld(vecs[0].v, vecs[1].v, 8);
00157   b2 = vec\_sld(vecs[1].v, vecs[0].v, 8);
00158 \textcolor{preprocessor}{#else}
00159   b1 = vec\_sld(vecs[1].v, vecs[0].v, 8);
00160   b2 = vec\_sld(vecs[0].v, vecs[1].v, 8);
00161 \textcolor{preprocessor}{#endif}
00162   b2 = vec\_sld(b2, b2, 8);
00163   b2 = padd<Packet4f>(b1, b2);
00164 
00165   \textcolor{keywordflow}{return} Packet2cf(b2);
00166 \}
00167 
00168 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> predux\_mul<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00169 \{
00170   Packet4f b;
00171   Packet2cf prod;
00172   b = vec\_sld(a.v, a.v, 8);
00173   prod = pmul<Packet2cf>(a, Packet2cf(b));
00174 
00175   \textcolor{keywordflow}{return} pfirst<Packet2cf>(prod);
00176 \}
00177 
00178 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00179 \textcolor{keyword}{struct }palign\_impl<Offset,Packet2cf>
00180 \{
00181   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet2cf& first, \textcolor{keyword}{const} Packet2cf& second)
00182   \{
00183     \textcolor{keywordflow}{if} (Offset==1)
00184     \{
00185 \textcolor{preprocessor}{#ifdef \_BIG\_ENDIAN}
00186       first.v = vec\_sld(first.v, second.v, 8);
00187 \textcolor{preprocessor}{#else}
00188       first.v = vec\_sld(second.v, first.v, 8);
00189 \textcolor{preprocessor}{#endif}
00190     \}
00191   \}
00192 \};
00193 
00194 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet2cf, false,true>
00195 \{
00196   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00197 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00198 
00199   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)\textcolor{keyword}{ const}
00200 \textcolor{keyword}{  }\{
00201     \textcolor{keywordflow}{return} internal::pmul(a, pconj(b));
00202   \}
00203 \};
00204 
00205 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet2cf, true,false>
00206 \{
00207   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00208 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00209 
00210   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)\textcolor{keyword}{ const}
00211 \textcolor{keyword}{  }\{
00212     \textcolor{keywordflow}{return} internal::pmul(pconj(a), b);
00213   \}
00214 \};
00215 
00216 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet2cf, true,true>
00217 \{
00218   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00219 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00220 
00221   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)\textcolor{keyword}{ const}
00222 \textcolor{keyword}{  }\{
00223     \textcolor{keywordflow}{return} pconj(internal::pmul(a, b));
00224   \}
00225 \};
00226 
00227 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet4f, Packet2cf, false,false>
00228 \{
00229   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet4f& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00230 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00231 
00232   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet4f& x, \textcolor{keyword}{const} Packet2cf& y)\textcolor{keyword}{ const}
00233 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} Packet2cf(internal::pmul<Packet4f>(x, y.v)); \}
00234 \};
00235 
00236 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet4f, false,false>
00237 \{
00238   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet4f& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00239 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00240 
00241   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet4f& y)\textcolor{keyword}{ const}
00242 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} Packet2cf(internal::pmul<Packet4f>(x.v, y)); \}
00243 \};
00244 
00245 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pdiv<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)
00246 \{
00247   \textcolor{comment}{// TODO optimize it for AltiVec}
00248   Packet2cf res = conj\_helper<Packet2cf,Packet2cf,false,true>().pmul(a, b);
00249   Packet4f s = pmul<Packet4f>(b.v, b.v);
00250   \textcolor{keywordflow}{return} Packet2cf(pdiv(res.v, padd<Packet4f>(s, vec\_perm(s, s, p16uc\_COMPLEX32\_REV))));
00251 \}
00252 
00253 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pcplxflip<Packet2cf>(\textcolor{keyword}{const} Packet2cf& x)
00254 \{
00255   \textcolor{keywordflow}{return} Packet2cf(vec\_perm(x.v, x.v, p16uc\_COMPLEX32\_REV));
00256 \}
00257 
00258 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} ptranspose(PacketBlock<Packet2cf,2>& kernel)
00259 \{
00260   Packet4f tmp = vec\_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc\_TRANSPOSE64\_HI);
00261   kernel.packet[1].v = vec\_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc\_TRANSPOSE64\_LO);
00262   kernel.packet[0].v = tmp;
00263 \}
00264 
00265 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00266 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pblend(\textcolor{keyword}{const} Selector<2>& ifPacket, \textcolor{keyword}{const} Packet2cf& thenPacket, \textcolor{keyword}{
      const} Packet2cf& elsePacket) \{
00267   Packet2cf result;
00268   result.v = \textcolor{keyword}{reinterpret\_cast<}Packet4f\textcolor{keyword}{>}(pblend<Packet2d>(ifPacket, \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(thenPacket.v)
      , reinterpret\_cast<Packet2d>(elsePacket.v)));
00269   \textcolor{keywordflow}{return} result;
00270 \}
00271 \textcolor{preprocessor}{#endif}
00272 
00273 \textcolor{comment}{//---------- double ----------}
00274 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00275 \textcolor{keyword}{struct }Packet1cd
00276 \{
00277   EIGEN\_STRONG\_INLINE Packet1cd() \{\}
00278   EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} Packet1cd(\textcolor{keyword}{const} Packet2d& a) : v(a) \{\}
00279   Packet2d v;
00280 \};
00281 
00282 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<double> >  : default\_packet\_traits
00283 \{
00284   \textcolor{keyword}{typedef} Packet1cd type;
00285   \textcolor{keyword}{typedef} Packet1cd half;
00286   \textcolor{keyword}{enum} \{
00287     Vectorizable = 1,
00288     AlignedOnScalar = 0,
00289     size = 1,
00290     HasHalfPacket = 0,
00291 
00292     HasAdd    = 1,
00293     HasSub    = 1,
00294     HasMul    = 1,
00295     HasDiv    = 1,
00296     HasNegate = 1,
00297     HasAbs    = 0,
00298     HasAbs2   = 0,
00299     HasMin    = 0,
00300     HasMax    = 0,
00301     HasSetLinear = 0
00302   \};
00303 \};
00304 
00305 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet1cd> \{ \textcolor{keyword}{typedef} std::complex<double> type; \textcolor{keyword}{enum} \{size=1, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet1cd half; \};
00306 
00307 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pload <Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from) \{ \textcolor{keywordflow}{return} 
      Packet1cd(pload<Packet2d>((\textcolor{keyword}{const} \textcolor{keywordtype}{double}*)from)); \}
00308 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd ploadu<Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from) \{ \textcolor{keywordflow}{return} 
      Packet1cd(ploadu<Packet2d>((\textcolor{keyword}{const} \textcolor{keywordtype}{double}*)from)); \}
00309 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore <std::complex<double> >(std::complex<double> *   to, \textcolor{keyword}{const} 
      Packet1cd& from) \{ pstore((\textcolor{keywordtype}{double}*)to, from.v); \}
00310 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<std::complex<double> >(std::complex<double> *   to, \textcolor{keyword}{const} 
      Packet1cd& from) \{ pstoreu((\textcolor{keywordtype}{double}*)to, from.v); \}
00311 
00312 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pset1<Packet1cd>(\textcolor{keyword}{const} std::complex<double>&  from)
00313 \{ \textcolor{comment}{/* here we really have to use unaligned loads :( */} \textcolor{keywordflow}{return} ploadu<Packet1cd>(&from); \}
00314 
00315 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet1cd pgather<std::complex<double>, Packet1cd>(\textcolor{keyword}{const} 
      std::complex<double>* from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00316 \{
00317   std::complex<double> EIGEN\_ALIGN16 af[2];
00318   af[0] = from[0*stride];
00319   af[1] = from[1*stride];
00320   \textcolor{keywordflow}{return} pload<Packet1cd>(af);
00321 \}
00322 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to
      , \textcolor{keyword}{const} Packet1cd& from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00323 \{
00324   std::complex<double> EIGEN\_ALIGN16 af[2];
00325   pstore<std::complex<double> >(af, from);
00326   to[0*stride] = af[0];
00327   to[1*stride] = af[1];
00328 \}
00329 
00330 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd padd<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{return} 
      Packet1cd(a.v + b.v); \}
00331 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd psub<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{return} 
      Packet1cd(a.v - b.v); \}
00332 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pnegate(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} Packet1cd(pnegate(Packet2d(a.
      v))); \}
00333 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pconj(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} Packet1cd(pxor(a.v, 
      reinterpret\_cast<Packet2d>(p2ul\_CONJ\_XOR2))); \}
00334 
00335 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pmul<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)
00336 \{
00337   Packet2d a\_re, a\_im, v1, v2;
00338 
00339   \textcolor{comment}{// Permute and multiply the real parts of a and b}
00340   a\_re = vec\_perm(a.v, a.v, p16uc\_PSET64\_HI);
00341   \textcolor{comment}{// Get the imaginary parts of a}
00342   a\_im = vec\_perm(a.v, a.v, p16uc\_PSET64\_LO);
00343   \textcolor{comment}{// multiply a\_re * b}
00344   v1 = vec\_madd(a\_re, b.v, p2d\_ZERO);
00345   \textcolor{comment}{// multiply a\_im * b and get the conjugate result}
00346   v2 = vec\_madd(a\_im, b.v, p2d\_ZERO);
00347   v2 = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4ui>(v2), reinterpret\_cast<Packet4ui>(v2),
       8));
00348   v2 = pxor(v2, reinterpret\_cast<Packet2d>(p2ul\_CONJ\_XOR1));
00349 
00350   \textcolor{keywordflow}{return} Packet1cd(padd<Packet2d>(v1, v2));
00351 \}
00352 
00353 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pand   <Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{
      return} Packet1cd(pand(a.v,b.v)); \}
00354 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd por    <Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{
      return} Packet1cd(por(a.v,b.v)); \}
00355 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pxor   <Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{
      return} Packet1cd(pxor(a.v,b.v)); \}
00356 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pandnot<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{
      return} Packet1cd(pandnot(a.v, b.v)); \}
00357 
00358 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd ploaddup<Packet1cd>(\textcolor{keyword}{const} std::complex<double>*     from)  \{ \textcolor{keywordflow}{
      return} pset1<Packet1cd>(*from); \}
00359 
00360 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<std::complex<double> >(\textcolor{keyword}{const} std::complex<double> * addr)    \{
       EIGEN\_PPC\_PREFETCH(addr); \}
00361 
00362 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double>  pfirst<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a)
00363 \{
00364   std::complex<double> EIGEN\_ALIGN16 res[2];
00365   pstore<std::complex<double> >(res, a);
00366 
00367   \textcolor{keywordflow}{return} res[0];
00368 \}
00369 
00370 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd preverse(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} a; \}
00371 
00372 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double> predux<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} pfirst(a
      ); \}
00373 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd preduxp<Packet1cd>(\textcolor{keyword}{const} Packet1cd* vecs)        \{ \textcolor{keywordflow}{return} vecs[0];
       \}
00374 
00375 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double> predux\_mul<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} 
      pfirst(a); \}
00376 
00377 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00378 \textcolor{keyword}{struct }palign\_impl<Offset,Packet1cd>
00379 \{
00380   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet1cd& \textcolor{comment}{/*first*/}, \textcolor{keyword}{const} Packet1cd& \textcolor{comment}{/*second*/})
00381   \{
00382     \textcolor{comment}{// FIXME is it sure we never have to align a Packet1cd?}
00383     \textcolor{comment}{// Even though a std::complex<double> has 16 bytes, it is not necessarily aligned on a 16 bytes
       boundary...}
00384   \}
00385 \};
00386 
00387 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet1cd, Packet1cd, false,true>
00388 \{
00389   EIGEN\_STRONG\_INLINE Packet1cd pmadd(\textcolor{keyword}{const} Packet1cd& x, \textcolor{keyword}{const} Packet1cd& y, \textcolor{keyword}{const} Packet1cd& c)\textcolor{keyword}{ const}
00390 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00391 
00392   EIGEN\_STRONG\_INLINE Packet1cd pmul(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)\textcolor{keyword}{ const}
00393 \textcolor{keyword}{  }\{
00394     \textcolor{keywordflow}{return} internal::pmul(a, pconj(b));
00395   \}
00396 \};
00397 
00398 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet1cd, Packet1cd, true,false>
00399 \{
00400   EIGEN\_STRONG\_INLINE Packet1cd pmadd(\textcolor{keyword}{const} Packet1cd& x, \textcolor{keyword}{const} Packet1cd& y, \textcolor{keyword}{const} Packet1cd& c)\textcolor{keyword}{ const}
00401 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00402 
00403   EIGEN\_STRONG\_INLINE Packet1cd pmul(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)\textcolor{keyword}{ const}
00404 \textcolor{keyword}{  }\{
00405     \textcolor{keywordflow}{return} internal::pmul(pconj(a), b);
00406   \}
00407 \};
00408 
00409 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet1cd, Packet1cd, true,true>
00410 \{
00411   EIGEN\_STRONG\_INLINE Packet1cd pmadd(\textcolor{keyword}{const} Packet1cd& x, \textcolor{keyword}{const} Packet1cd& y, \textcolor{keyword}{const} Packet1cd& c)\textcolor{keyword}{ const}
00412 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00413 
00414   EIGEN\_STRONG\_INLINE Packet1cd pmul(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)\textcolor{keyword}{ const}
00415 \textcolor{keyword}{  }\{
00416     \textcolor{keywordflow}{return} pconj(internal::pmul(a, b));
00417   \}
00418 \};
00419 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2d, Packet1cd, false,false>
00420 \{
00421   EIGEN\_STRONG\_INLINE Packet1cd pmadd(\textcolor{keyword}{const} Packet2d& x, \textcolor{keyword}{const} Packet1cd& y, \textcolor{keyword}{const} Packet1cd& c)\textcolor{keyword}{ const}
00422 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00423 
00424   EIGEN\_STRONG\_INLINE Packet1cd pmul(\textcolor{keyword}{const} Packet2d& x, \textcolor{keyword}{const} Packet1cd& y)\textcolor{keyword}{ const}
00425 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} Packet1cd(internal::pmul<Packet2d>(x, y.v)); \}
00426 \};
00427 
00428 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet1cd, Packet2d, false,false>
00429 \{
00430   EIGEN\_STRONG\_INLINE Packet1cd pmadd(\textcolor{keyword}{const} Packet1cd& x, \textcolor{keyword}{const} Packet2d& y, \textcolor{keyword}{const} Packet1cd& c)\textcolor{keyword}{ const}
00431 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00432 
00433   EIGEN\_STRONG\_INLINE Packet1cd pmul(\textcolor{keyword}{const} Packet1cd& x, \textcolor{keyword}{const} Packet2d& y)\textcolor{keyword}{ const}
00434 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} Packet1cd(internal::pmul<Packet2d>(x.v, y)); \}
00435 \};
00436 
00437 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pdiv<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)
00438 \{
00439   \textcolor{comment}{// TODO optimize it for AltiVec}
00440   Packet1cd res = conj\_helper<Packet1cd,Packet1cd,false,true>().pmul(a,b);
00441   Packet2d s = pmul<Packet2d>(b.v, b.v);
00442   \textcolor{keywordflow}{return} Packet1cd(pdiv(res.v, padd<Packet2d>(s, vec\_perm(s, s, p16uc\_REVERSE64))));
00443 \}
00444 
00445 EIGEN\_STRONG\_INLINE Packet1cd pcplxflip\textcolor{comment}{/*<Packet1cd>*/}(\textcolor{keyword}{const} Packet1cd& x)
00446 \{
00447   \textcolor{keywordflow}{return} Packet1cd(preverse(Packet2d(x.v)));
00448 \}
00449 
00450 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} ptranspose(PacketBlock<Packet1cd,2>& kernel)
00451 \{
00452   Packet2d tmp = vec\_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc\_TRANSPOSE64\_HI);
00453   kernel.packet[1].v = vec\_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc\_TRANSPOSE64\_LO);
00454   kernel.packet[0].v = tmp;
00455 \}
00456 \textcolor{preprocessor}{#endif // \_\_VSX\_\_}
00457 \} \textcolor{comment}{// end namespace internal}
00458 
00459 \} \textcolor{comment}{// end namespace Eigen}
00460 
00461 \textcolor{preprocessor}{#endif // EIGEN\_COMPLEX32\_ALTIVEC\_H}
\end{DoxyCode}
