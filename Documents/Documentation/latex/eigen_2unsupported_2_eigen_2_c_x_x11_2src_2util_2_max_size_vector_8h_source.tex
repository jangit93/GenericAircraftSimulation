\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_max_size_vector_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/util/\+Max\+Size\+Vector.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_max_size_vector_8h_source}\index{Max\+Size\+Vector.\+h@{Max\+Size\+Vector.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_FIXEDSIZEVECTOR\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_FIXEDSIZEVECTOR\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00030 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_max_size_vector_8h_source_l00031}\hyperlink{class_eigen_1_1_max_size_vector}{00031} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_max_size_vector}{MaxSizeVector} \{
00032  \textcolor{keyword}{public}:
00033   \textcolor{comment}{// Construct a new MaxSizeVector, reserve n elements.}
00034   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00035   \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1_max_size_vector}{MaxSizeVector}(\textcolor{keywordtype}{size\_t} n)
00036       : reserve\_(n), size\_(0),
00037         data\_(static\_cast<T*>(internal::aligned\_malloc(n * \textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module}{T})))) \{
00038     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < n; ++i) \{ \textcolor{keyword}{new} (&data\_[i]) \hyperlink{group___sparse_core___module}{T}; \}
00039   \}
00040 
00041   \textcolor{comment}{// Construct a new MaxSizeVector, reserve and resize to n.}
00042   \textcolor{comment}{// Copy the init value to all elements.}
00043   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00044   MaxSizeVector(\textcolor{keywordtype}{size\_t} n, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& \hyperlink{structinit}{init})
00045       : reserve\_(n), size\_(n),
00046         data\_(static\_cast<T*>(internal::aligned\_malloc(n * \textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module}{T})))) \{
00047     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < n; ++i) \{ \textcolor{keyword}{new} (&data\_[i]) \hyperlink{group___sparse_core___module}{T}(init); \}
00048   \}
00049 
00050   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00051   ~MaxSizeVector() \{
00052     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size\_; ++i) \{
00053       data\_[i].~T();
00054     \}
00055     internal::aligned\_free(data\_);
00056   \}
00057 
00058   \textcolor{keywordtype}{void} resize(\textcolor{keywordtype}{size\_t} n) \{
00059     eigen\_assert(n <= reserve\_);
00060     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = size\_; i < n; ++i) \{
00061       \textcolor{keyword}{new} (&data\_[i]) \hyperlink{group___sparse_core___module}{T};
00062     \}
00063     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = n; i < size\_; ++i) \{
00064       data\_[i].~T();
00065     \}
00066     size\_ = n;
00067   \}
00068 
00069   \textcolor{comment}{// Append new elements (up to reserved size).}
00070   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00071   \textcolor{keywordtype}{void} push\_back(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& t) \{
00072     eigen\_assert(size\_ < reserve\_);
00073     data\_[size\_++] = t;
00074   \}
00075 
00076   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00077   \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& operator[] (\textcolor{keywordtype}{size\_t} i)\textcolor{keyword}{ const }\{
00078     eigen\_assert(i < size\_);
00079     \textcolor{keywordflow}{return} data\_[i];
00080   \}
00081 
00082   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00083   \hyperlink{group___sparse_core___module}{T}& operator[] (\textcolor{keywordtype}{size\_t} i) \{
00084     eigen\_assert(i < size\_);
00085     \textcolor{keywordflow}{return} data\_[i];
00086   \}
00087 
00088   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00089   \hyperlink{group___sparse_core___module}{T}& back() \{
00090     eigen\_assert(size\_ > 0);
00091     \textcolor{keywordflow}{return} data\_[size\_ - 1];
00092   \}
00093 
00094   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00095   \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& back()\textcolor{keyword}{ const }\{
00096     eigen\_assert(size\_ > 0);
00097     \textcolor{keywordflow}{return} data\_[size\_ - 1];
00098   \}
00099 
00100   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00101   \textcolor{keywordtype}{void} pop\_back() \{
00102     \textcolor{comment}{// NOTE: This does not destroy the value at the end the way}
00103     \textcolor{comment}{// std::vector's version of pop\_back() does.  That happens when}
00104     \textcolor{comment}{// the Vector is destroyed.}
00105     eigen\_assert(size\_ > 0);
00106     size\_--;
00107   \}
00108 
00109   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00110   \textcolor{keywordtype}{size\_t} size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} size\_; \}
00111 
00112   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00113   \textcolor{keywordtype}{bool} empty()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} size\_ == 0; \}
00114 
00115   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00116   \hyperlink{group___sparse_core___module}{T}* data() \{ \textcolor{keywordflow}{return} data\_; \}
00117 
00118   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00119   \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} data\_; \}
00120 
00121   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00122   \hyperlink{group___sparse_core___module}{T}* begin() \{ \textcolor{keywordflow}{return} data\_; \}
00123 
00124   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00125   \hyperlink{group___sparse_core___module}{T}* end() \{ \textcolor{keywordflow}{return} data\_ + size\_; \}
00126 
00127   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00128   \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}* begin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} data\_; \}
00129 
00130   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00131   \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}* end()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} data\_ + size\_; \}
00132 
00133  \textcolor{keyword}{private}:
00134   \textcolor{keywordtype}{size\_t} reserve\_;
00135   \textcolor{keywordtype}{size\_t} size\_;
00136   \hyperlink{group___sparse_core___module}{T}* data\_;
00137 \};
00138 
00139 \}  \textcolor{comment}{// namespace Eigen}
00140 
00141 \textcolor{preprocessor}{#endif  // EIGEN\_FIXEDSIZEVECTOR\_H}
\end{DoxyCode}
