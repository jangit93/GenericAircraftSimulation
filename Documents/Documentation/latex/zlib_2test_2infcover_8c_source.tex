\hypertarget{zlib_2test_2infcover_8c_source}{}\section{zlib/test/infcover.c}
\label{zlib_2test_2infcover_8c_source}\index{infcover.\+c@{infcover.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* infcover.c -- test zlib's inflate routines with full code coverage}
00002 \textcolor{comment}{ * Copyright (C) 2011, 2016 Mark Adler}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ */}
00005 
00006 \textcolor{comment}{/* to use, do: ./configure --cover && make cover */}
00007 
00008 \textcolor{preprocessor}{#include <stdio.h>}
00009 \textcolor{preprocessor}{#include <stdlib.h>}
00010 \textcolor{preprocessor}{#include <string.h>}
00011 \textcolor{preprocessor}{#include <assert.h>}
00012 \textcolor{preprocessor}{#include "zlib.h"}
00013 
00014 \textcolor{comment}{/* get definition of internal structure so we can mess with it (see pull()),}
00015 \textcolor{comment}{   and so we can call inflate\_trees() (see cover5()) */}
00016 \textcolor{preprocessor}{#define ZLIB\_INTERNAL}
00017 \textcolor{preprocessor}{#include "inftrees.h"}
00018 \textcolor{preprocessor}{#include "inflate.h"}
00019 
00020 \textcolor{preprocessor}{#define local static}
00021 
00022 \textcolor{comment}{/* -- memory tracking routines -- */}
00023 
00024 \textcolor{comment}{/*}
00025 \textcolor{comment}{   These memory tracking routines are provided to zlib and track all of zlib's}
00026 \textcolor{comment}{   allocations and deallocations, check for LIFO operations, keep a current}
00027 \textcolor{comment}{   and high water mark of total bytes requested, optionally set a limit on the}
00028 \textcolor{comment}{   total memory that can be allocated, and when done check for memory leaks.}
00029 \textcolor{comment}{}
00030 \textcolor{comment}{   They are used as follows:}
00031 \textcolor{comment}{}
00032 \textcolor{comment}{   z\_stream strm;}
00033 \textcolor{comment}{   mem\_setup(&strm)         initializes the memory tracking and sets the}
00034 \textcolor{comment}{                            zalloc, zfree, and opaque members of strm to use}
00035 \textcolor{comment}{                            memory tracking for all zlib operations on strm}
00036 \textcolor{comment}{   mem\_limit(&strm, limit)  sets a limit on the total bytes requested -- a}
00037 \textcolor{comment}{                            request that exceeds this limit will result in an}
00038 \textcolor{comment}{                            allocation failure (returns NULL) -- setting the}
00039 \textcolor{comment}{                            limit to zero means no limit, which is the default}
00040 \textcolor{comment}{                            after mem\_setup()}
00041 \textcolor{comment}{   mem\_used(&strm, "msg")   prints to stderr "msg" and the total bytes used}
00042 \textcolor{comment}{   mem\_high(&strm, "msg")   prints to stderr "msg" and the high water mark}
00043 \textcolor{comment}{   mem\_done(&strm, "msg")   ends memory tracking, releases all allocations}
00044 \textcolor{comment}{                            for the tracking as well as leaked zlib blocks, if}
00045 \textcolor{comment}{                            any.  If there was anything unusual, such as leaked}
00046 \textcolor{comment}{                            blocks, non-FIFO frees, or frees of addresses not}
00047 \textcolor{comment}{                            allocated, then "msg" and information about the}
00048 \textcolor{comment}{                            problem is printed to stderr.  If everything is}
00049 \textcolor{comment}{                            normal, nothing is printed. mem\_done resets the}
00050 \textcolor{comment}{                            strm members to Z\_NULL to use the default memory}
00051 \textcolor{comment}{                            allocation routines on the next zlib initialization}
00052 \textcolor{comment}{                            using strm.}
00053 \textcolor{comment}{ */}
00054 
00055 \textcolor{comment}{/* these items are strung together in a linked list, one for each allocation */}
00056 \textcolor{keyword}{struct }\hyperlink{structmem__item}{mem\_item} \{
00057     \textcolor{keywordtype}{void} *ptr;                  \textcolor{comment}{/* pointer to allocated memory */}
00058     \textcolor{keywordtype}{size\_t} size;                \textcolor{comment}{/* requested size of allocation */}
00059     \textcolor{keyword}{struct }\hyperlink{structmem__item}{mem\_item} *next;      \textcolor{comment}{/* pointer to next item in list, or NULL */}
00060 \};
00061 
00062 \textcolor{comment}{/* this structure is at the root of the linked list, and tracks statistics */}
00063 \textcolor{keyword}{struct }\hyperlink{structmem__zone}{mem\_zone} \{
00064     \textcolor{keyword}{struct }\hyperlink{structmem__item}{mem\_item} *first;     \textcolor{comment}{/* pointer to first item in list, or NULL */}
00065     \textcolor{keywordtype}{size\_t} total, highwater;    \textcolor{comment}{/* total allocations, and largest total */}
00066     \textcolor{keywordtype}{size\_t} limit;               \textcolor{comment}{/* memory allocation limit, or 0 if no limit */}
00067     \textcolor{keywordtype}{int} notlifo, rogue;         \textcolor{comment}{/* counts of non-LIFO frees and rogue frees */}
00068 \};
00069 
00070 \textcolor{comment}{/* memory allocation routine to pass to zlib */}
00071 local \textcolor{keywordtype}{void} *mem\_alloc(\textcolor{keywordtype}{void} *mem, \textcolor{keywordtype}{unsigned} count, \textcolor{keywordtype}{unsigned} size)
00072 \{
00073     \textcolor{keywordtype}{void} *ptr;
00074     \textcolor{keyword}{struct }\hyperlink{structmem__item}{mem\_item} *item;
00075     \textcolor{keyword}{struct }\hyperlink{structmem__zone}{mem\_zone} *zone = mem;
00076     \textcolor{keywordtype}{size\_t} len = count * (size\_t)size;
00077 
00078     \textcolor{comment}{/* induced allocation failure */}
00079     \textcolor{keywordflow}{if} (zone == NULL || (zone->limit && zone->total + len > zone->limit))
00080         \textcolor{keywordflow}{return} NULL;
00081 
00082     \textcolor{comment}{/* perform allocation using the standard library, fill memory with a}
00083 \textcolor{comment}{       non-zero value to make sure that the code isn't depending on zeros */}
00084     ptr = malloc(len);
00085     \textcolor{keywordflow}{if} (ptr == NULL)
00086         \textcolor{keywordflow}{return} NULL;
00087     memset(ptr, 0xa5, len);
00088 
00089     \textcolor{comment}{/* create a new item for the list */}
00090     item = malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structmem__item}{mem\_item}));
00091     \textcolor{keywordflow}{if} (item == NULL) \{
00092         free(ptr);
00093         \textcolor{keywordflow}{return} NULL;
00094     \}
00095     item->ptr = ptr;
00096     item->size = len;
00097 
00098     \textcolor{comment}{/* insert item at the beginning of the list */}
00099     item->next = zone->first;
00100     zone->first = item;
00101 
00102     \textcolor{comment}{/* update the statistics */}
00103     zone->total += item->size;
00104     \textcolor{keywordflow}{if} (zone->total > zone->highwater)
00105         zone->highwater = zone->total;
00106 
00107     \textcolor{comment}{/* return the allocated memory */}
00108     \textcolor{keywordflow}{return} ptr;
00109 \}
00110 
00111 \textcolor{comment}{/* memory free routine to pass to zlib */}
00112 local \textcolor{keywordtype}{void} mem\_free(\textcolor{keywordtype}{void} *mem, \textcolor{keywordtype}{void} *ptr)
00113 \{
00114     \textcolor{keyword}{struct }\hyperlink{structmem__item}{mem\_item} *item, *next;
00115     \textcolor{keyword}{struct }\hyperlink{structmem__zone}{mem\_zone} *zone = mem;
00116 
00117     \textcolor{comment}{/* if no zone, just do a free */}
00118     \textcolor{keywordflow}{if} (zone == NULL) \{
00119         free(ptr);
00120         \textcolor{keywordflow}{return};
00121     \}
00122 
00123     \textcolor{comment}{/* point next to the item that matches ptr, or NULL if not found -- remove}
00124 \textcolor{comment}{       the item from the linked list if found */}
00125     next = zone->first;
00126     \textcolor{keywordflow}{if} (next) \{
00127         \textcolor{keywordflow}{if} (next->ptr == ptr)
00128             zone->first = next->next;   \textcolor{comment}{/* first one is it, remove from list */}
00129         \textcolor{keywordflow}{else} \{
00130             \textcolor{keywordflow}{do} \{                        \textcolor{comment}{/* search the linked list */}
00131                 item = next;
00132                 next = item->next;
00133             \} \textcolor{keywordflow}{while} (next != NULL && next->ptr != ptr);
00134             \textcolor{keywordflow}{if} (next) \{                 \textcolor{comment}{/* if found, remove from linked list */}
00135                 item->next = next->next;
00136                 zone->notlifo++;        \textcolor{comment}{/* not a LIFO free */}
00137             \}
00138 
00139         \}
00140     \}
00141 
00142     \textcolor{comment}{/* if found, update the statistics and free the item */}
00143     \textcolor{keywordflow}{if} (next) \{
00144         zone->total -= next->size;
00145         free(next);
00146     \}
00147 
00148     \textcolor{comment}{/* if not found, update the rogue count */}
00149     \textcolor{keywordflow}{else}
00150         zone->rogue++;
00151 
00152     \textcolor{comment}{/* in any case, do the requested free with the standard library function */}
00153     free(ptr);
00154 \}
00155 
00156 \textcolor{comment}{/* set up a controlled memory allocation space for monitoring, set the stream}
00157 \textcolor{comment}{   parameters to the controlled routines, with opaque pointing to the space */}
00158 local \textcolor{keywordtype}{void} mem\_setup(\hyperlink{structz__stream__s}{z\_stream} *strm)
00159 \{
00160     \textcolor{keyword}{struct }\hyperlink{structmem__zone}{mem\_zone} *zone;
00161 
00162     zone = malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structmem__zone}{mem\_zone}));
00163     assert(zone != NULL);
00164     zone->first = NULL;
00165     zone->total = 0;
00166     zone->highwater = 0;
00167     zone->limit = 0;
00168     zone->notlifo = 0;
00169     zone->rogue = 0;
00170     strm->opaque = zone;
00171     strm->zalloc = mem\_alloc;
00172     strm->zfree = mem\_free;
00173 \}
00174 
00175 \textcolor{comment}{/* set a limit on the total memory allocation, or 0 to remove the limit */}
00176 local \textcolor{keywordtype}{void} mem\_limit(\hyperlink{structz__stream__s}{z\_stream} *strm, \textcolor{keywordtype}{size\_t} limit)
00177 \{
00178     \textcolor{keyword}{struct }\hyperlink{structmem__zone}{mem\_zone} *zone = strm->opaque;
00179 
00180     zone->limit = limit;
00181 \}
00182 
00183 \textcolor{comment}{/* show the current total requested allocations in bytes */}
00184 local \textcolor{keywordtype}{void} mem\_used(\hyperlink{structz__stream__s}{z\_stream} *strm, \textcolor{keywordtype}{char} *prefix)
00185 \{
00186     \textcolor{keyword}{struct }\hyperlink{structmem__zone}{mem\_zone} *zone = strm->opaque;
00187 
00188     fprintf(stderr, \textcolor{stringliteral}{"%s: %lu allocated\(\backslash\)n"}, prefix, zone->total);
00189 \}
00190 
00191 \textcolor{comment}{/* show the high water allocation in bytes */}
00192 local \textcolor{keywordtype}{void} mem\_high(\hyperlink{structz__stream__s}{z\_stream} *strm, \textcolor{keywordtype}{char} *prefix)
00193 \{
00194     \textcolor{keyword}{struct }\hyperlink{structmem__zone}{mem\_zone} *zone = strm->opaque;
00195 
00196     fprintf(stderr, \textcolor{stringliteral}{"%s: %lu high water mark\(\backslash\)n"}, prefix, zone->highwater);
00197 \}
00198 
00199 \textcolor{comment}{/* release the memory allocation zone -- if there are any surprises, notify */}
00200 local \textcolor{keywordtype}{void} mem\_done(\hyperlink{structz__stream__s}{z\_stream} *strm, \textcolor{keywordtype}{char} *prefix)
00201 \{
00202     \textcolor{keywordtype}{int} count = 0;
00203     \textcolor{keyword}{struct }\hyperlink{structmem__item}{mem\_item} *item, *next;
00204     \textcolor{keyword}{struct }\hyperlink{structmem__zone}{mem\_zone} *zone = strm->opaque;
00205 
00206     \textcolor{comment}{/* show high water mark */}
00207     mem\_high(strm, prefix);
00208 
00209     \textcolor{comment}{/* free leftover allocations and item structures, if any */}
00210     item = zone->first;
00211     \textcolor{keywordflow}{while} (item != NULL) \{
00212         free(item->ptr);
00213         next = item->next;
00214         free(item);
00215         item = next;
00216         count++;
00217     \}
00218 
00219     \textcolor{comment}{/* issue alerts about anything unexpected */}
00220     \textcolor{keywordflow}{if} (count || zone->total)
00221         fprintf(stderr, \textcolor{stringliteral}{"** %s: %lu bytes in %d blocks not freed\(\backslash\)n"},
00222                 prefix, zone->total, count);
00223     \textcolor{keywordflow}{if} (zone->notlifo)
00224         fprintf(stderr, \textcolor{stringliteral}{"** %s: %d frees not LIFO\(\backslash\)n"}, prefix, zone->notlifo);
00225     \textcolor{keywordflow}{if} (zone->rogue)
00226         fprintf(stderr, \textcolor{stringliteral}{"** %s: %d frees not recognized\(\backslash\)n"},
00227                 prefix, zone->rogue);
00228 
00229     \textcolor{comment}{/* free the zone and delete from the stream */}
00230     free(zone);
00231     strm->opaque = Z\_NULL;
00232     strm->zalloc = Z\_NULL;
00233     strm->zfree = Z\_NULL;
00234 \}
00235 
00236 \textcolor{comment}{/* -- inflate test routines -- */}
00237 
00238 \textcolor{comment}{/* Decode a hexadecimal string, set *len to length, in[] to the bytes.  This}
00239 \textcolor{comment}{   decodes liberally, in that hex digits can be adjacent, in which case two in}
00240 \textcolor{comment}{   a row writes a byte.  Or they can be delimited by any non-hex character,}
00241 \textcolor{comment}{   where the delimiters are ignored except when a single hex digit is followed}
00242 \textcolor{comment}{   by a delimiter, where that single digit writes a byte.  The returned data is}
00243 \textcolor{comment}{   allocated and must eventually be freed.  NULL is returned if out of memory.}
00244 \textcolor{comment}{   If the length is not needed, then len can be NULL. */}
00245 local \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *h2b(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *hex, \textcolor{keywordtype}{unsigned} *len)
00246 \{
00247     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *in, *re;
00248     \textcolor{keywordtype}{unsigned} next, val;
00249 
00250     in = malloc((strlen(hex) + 1) >> 1);
00251     \textcolor{keywordflow}{if} (in == NULL)
00252         \textcolor{keywordflow}{return} NULL;
00253     next = 0;
00254     val = 1;
00255     \textcolor{keywordflow}{do} \{
00256         \textcolor{keywordflow}{if} (*hex >= \textcolor{charliteral}{'0'} && *hex <= \textcolor{charliteral}{'9'})
00257             val = (val << 4) + *hex - \textcolor{charliteral}{'0'};
00258         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*hex >= \textcolor{charliteral}{'A'} && *hex <= \textcolor{charliteral}{'F'})
00259             val = (val << 4) + *hex - \textcolor{charliteral}{'A'} + 10;
00260         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*hex >= \textcolor{charliteral}{'a'} && *hex <= \textcolor{charliteral}{'f'})
00261             val = (val << 4) + *hex - \textcolor{charliteral}{'a'} + 10;
00262         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (val != 1 && val < 32)  \textcolor{comment}{/* one digit followed by delimiter */}
00263             val += 240;                 \textcolor{comment}{/* make it look like two digits */}
00264         \textcolor{keywordflow}{if} (val > 255) \{                \textcolor{comment}{/* have two digits */}
00265             in[next++] = val & 0xff;    \textcolor{comment}{/* save the decoded byte */}
00266             val = 1;                    \textcolor{comment}{/* start over */}
00267         \}
00268     \} \textcolor{keywordflow}{while} (*hex++);       \textcolor{comment}{/* go through the loop with the terminating null */}
00269     \textcolor{keywordflow}{if} (len != NULL)
00270         *len = next;
00271     re = realloc(in, next);
00272     \textcolor{keywordflow}{return} re == NULL ? in : re;
00273 \}
00274 
00275 \textcolor{comment}{/* generic inflate() run, where hex is the hexadecimal input data, what is the}
00276 \textcolor{comment}{   text to include in an error message, step is how much input data to feed}
00277 \textcolor{comment}{   inflate() on each call, or zero to feed it all, win is the window bits}
00278 \textcolor{comment}{   parameter to inflateInit2(), len is the size of the output buffer, and err}
00279 \textcolor{comment}{   is the error code expected from the first inflate() call (the second}
00280 \textcolor{comment}{   inflate() call is expected to return Z\_STREAM\_END).  If win is 47, then}
00281 \textcolor{comment}{   header information is collected with inflateGetHeader().  If a zlib stream}
00282 \textcolor{comment}{   is looking for a dictionary, then an empty dictionary is provided.}
00283 \textcolor{comment}{   inflate() is run until all of the input data is consumed. */}
00284 local \textcolor{keywordtype}{void} inf(\textcolor{keywordtype}{char} *hex, \textcolor{keywordtype}{char} *what, \textcolor{keywordtype}{unsigned} step, \textcolor{keywordtype}{int} win, \textcolor{keywordtype}{unsigned} len,
00285                \textcolor{keywordtype}{int} err)
00286 \{
00287     \textcolor{keywordtype}{int} ret;
00288     \textcolor{keywordtype}{unsigned} have;
00289     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *in, *out;
00290     \hyperlink{structz__stream__s}{z\_stream} strm, copy;
00291     \hyperlink{structgz__header__s}{gz\_header} head;
00292 
00293     mem\_setup(&strm);
00294     strm.avail\_in = 0;
00295     strm.next\_in = Z\_NULL;
00296     ret = inflateInit2(&strm, win);
00297     \textcolor{keywordflow}{if} (ret != Z\_OK) \{
00298         mem\_done(&strm, what);
00299         \textcolor{keywordflow}{return};
00300     \}
00301     out = malloc(len);                          assert(out != NULL);
00302     \textcolor{keywordflow}{if} (win == 47) \{
00303         head.extra = out;
00304         head.extra\_max = len;
00305         head.name = out;
00306         head.name\_max = len;
00307         head.comment = out;
00308         head.comm\_max = len;
00309         ret = inflateGetHeader(&strm, &head);   assert(ret == Z\_OK);
00310     \}
00311     in = h2b(hex, &have);                       assert(in != NULL);
00312     \textcolor{keywordflow}{if} (step == 0 || step > have)
00313         step = have;
00314     strm.avail\_in = step;
00315     have -= step;
00316     strm.next\_in = in;
00317     \textcolor{keywordflow}{do} \{
00318         strm.avail\_out = len;
00319         strm.next\_out = out;
00320         ret = inflate(&strm, Z\_NO\_FLUSH);       assert(err == 9 || ret == err);
00321         \textcolor{keywordflow}{if} (ret != Z\_OK && ret != Z\_BUF\_ERROR && ret != Z\_NEED\_DICT)
00322             \textcolor{keywordflow}{break};
00323         \textcolor{keywordflow}{if} (ret == Z\_NEED\_DICT) \{
00324             ret = inflateSetDictionary(&strm, in, 1);
00325                                                 assert(ret == Z\_DATA\_ERROR);
00326             mem\_limit(&strm, 1);
00327             ret = inflateSetDictionary(&strm, out, 0);
00328                                                 assert(ret == Z\_MEM\_ERROR);
00329             mem\_limit(&strm, 0);
00330             ((\textcolor{keyword}{struct }\hyperlink{structinflate__state}{inflate\_state} *)strm.state)->mode = DICT;
00331             ret = inflateSetDictionary(&strm, out, 0);
00332                                                 assert(ret == Z\_OK);
00333             ret = inflate(&strm, Z\_NO\_FLUSH);   assert(ret == Z\_BUF\_ERROR);
00334         \}
00335         ret = inflateCopy(&copy, &strm);        assert(ret == Z\_OK);
00336         ret = inflateEnd(&copy);                assert(ret == Z\_OK);
00337         err = 9;                        \textcolor{comment}{/* don't care next time around */}
00338         have += strm.avail\_in;
00339         strm.avail\_in = step > have ? have : step;
00340         have -= strm.avail\_in;
00341     \} \textcolor{keywordflow}{while} (strm.avail\_in);
00342     free(in);
00343     free(out);
00344     ret = inflateReset2(&strm, -8);             assert(ret == Z\_OK);
00345     ret = inflateEnd(&strm);                    assert(ret == Z\_OK);
00346     mem\_done(&strm, what);
00347 \}
00348 
00349 \textcolor{comment}{/* cover all of the lines in inflate.c up to inflate() */}
00350 local \textcolor{keywordtype}{void} cover\_support(\textcolor{keywordtype}{void})
00351 \{
00352     \textcolor{keywordtype}{int} ret;
00353     \hyperlink{structz__stream__s}{z\_stream} strm;
00354 
00355     mem\_setup(&strm);
00356     strm.avail\_in = 0;
00357     strm.next\_in = Z\_NULL;
00358     ret = inflateInit(&strm);                   assert(ret == Z\_OK);
00359     mem\_used(&strm, \textcolor{stringliteral}{"inflate init"});
00360     ret = inflatePrime(&strm, 5, 31);           assert(ret == Z\_OK);
00361     ret = inflatePrime(&strm, -1, 0);           assert(ret == Z\_OK);
00362     ret = inflateSetDictionary(&strm, Z\_NULL, 0);
00363                                                 assert(ret == Z\_STREAM\_ERROR);
00364     ret = inflateEnd(&strm);                    assert(ret == Z\_OK);
00365     mem\_done(&strm, \textcolor{stringliteral}{"prime"});
00366 
00367     inf(\textcolor{stringliteral}{"63 0"}, \textcolor{stringliteral}{"force window allocation"}, 0, -15, 1, Z\_OK);
00368     inf(\textcolor{stringliteral}{"63 18 5"}, \textcolor{stringliteral}{"force window replacement"}, 0, -8, 259, Z\_OK);
00369     inf(\textcolor{stringliteral}{"63 18 68 30 d0 0 0"}, \textcolor{stringliteral}{"force split window update"}, 4, -8, 259, Z\_OK);
00370     inf(\textcolor{stringliteral}{"3 0"}, \textcolor{stringliteral}{"use fixed blocks"}, 0, -15, 1, Z\_STREAM\_END);
00371     inf(\textcolor{stringliteral}{""}, \textcolor{stringliteral}{"bad window size"}, 0, 1, 0, Z\_STREAM\_ERROR);
00372 
00373     mem\_setup(&strm);
00374     strm.avail\_in = 0;
00375     strm.next\_in = Z\_NULL;
00376     ret = inflateInit\_(&strm, ZLIB\_VERSION - 1, (\textcolor{keywordtype}{int})\textcolor{keyword}{sizeof}(\hyperlink{structz__stream__s}{z\_stream}));
00377                                                 assert(ret == Z\_VERSION\_ERROR);
00378     mem\_done(&strm, \textcolor{stringliteral}{"wrong version"});
00379 
00380     strm.avail\_in = 0;
00381     strm.next\_in = Z\_NULL;
00382     ret = inflateInit(&strm);                   assert(ret == Z\_OK);
00383     ret = inflateEnd(&strm);                    assert(ret == Z\_OK);
00384     fputs(\textcolor{stringliteral}{"inflate built-in memory routines\(\backslash\)n"}, stderr);
00385 \}
00386 
00387 \textcolor{comment}{/* cover all inflate() header and trailer cases and code after inflate() */}
00388 local \textcolor{keywordtype}{void} cover\_wrap(\textcolor{keywordtype}{void})
00389 \{
00390     \textcolor{keywordtype}{int} ret;
00391     \hyperlink{structz__stream__s}{z\_stream} strm, copy;
00392     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} dict[257];
00393 
00394     ret = inflate(Z\_NULL, 0);                   assert(ret == Z\_STREAM\_ERROR);
00395     ret = inflateEnd(Z\_NULL);                   assert(ret == Z\_STREAM\_ERROR);
00396     ret = inflateCopy(Z\_NULL, Z\_NULL);          assert(ret == Z\_STREAM\_ERROR);
00397     fputs(\textcolor{stringliteral}{"inflate bad parameters\(\backslash\)n"}, stderr);
00398 
00399     inf(\textcolor{stringliteral}{"1f 8b 0 0"}, \textcolor{stringliteral}{"bad gzip method"}, 0, 31, 0, Z\_DATA\_ERROR);
00400     inf(\textcolor{stringliteral}{"1f 8b 8 80"}, \textcolor{stringliteral}{"bad gzip flags"}, 0, 31, 0, Z\_DATA\_ERROR);
00401     inf(\textcolor{stringliteral}{"77 85"}, \textcolor{stringliteral}{"bad zlib method"}, 0, 15, 0, Z\_DATA\_ERROR);
00402     inf(\textcolor{stringliteral}{"8 99"}, \textcolor{stringliteral}{"set window size from header"}, 0, 0, 0, Z\_OK);
00403     inf(\textcolor{stringliteral}{"78 9c"}, \textcolor{stringliteral}{"bad zlib window size"}, 0, 8, 0, Z\_DATA\_ERROR);
00404     inf(\textcolor{stringliteral}{"78 9c 63 0 0 0 1 0 1"}, \textcolor{stringliteral}{"check adler32"}, 0, 15, 1, Z\_STREAM\_END);
00405     inf(\textcolor{stringliteral}{"1f 8b 8 1e 0 0 0 0 0 0 1 0 0 0 0 0 0"}, \textcolor{stringliteral}{"bad header crc"}, 0, 47, 1,
00406         Z\_DATA\_ERROR);
00407     inf(\textcolor{stringliteral}{"1f 8b 8 2 0 0 0 0 0 0 1d 26 3 0 0 0 0 0 0 0 0 0"}, \textcolor{stringliteral}{"check gzip length"},
00408         0, 47, 0, Z\_STREAM\_END);
00409     inf(\textcolor{stringliteral}{"78 90"}, \textcolor{stringliteral}{"bad zlib header check"}, 0, 47, 0, Z\_DATA\_ERROR);
00410     inf(\textcolor{stringliteral}{"8 b8 0 0 0 1"}, \textcolor{stringliteral}{"need dictionary"}, 0, 8, 0, Z\_NEED\_DICT);
00411     inf(\textcolor{stringliteral}{"78 9c 63 0"}, \textcolor{stringliteral}{"compute adler32"}, 0, 15, 1, Z\_OK);
00412 
00413     mem\_setup(&strm);
00414     strm.avail\_in = 0;
00415     strm.next\_in = Z\_NULL;
00416     ret = inflateInit2(&strm, -8);
00417     strm.avail\_in = 2;
00418     strm.next\_in = (\textcolor{keywordtype}{void} *)\textcolor{stringliteral}{"\(\backslash\)x63"};
00419     strm.avail\_out = 1;
00420     strm.next\_out = (\textcolor{keywordtype}{void} *)&ret;
00421     mem\_limit(&strm, 1);
00422     ret = inflate(&strm, Z\_NO\_FLUSH);           assert(ret == Z\_MEM\_ERROR);
00423     ret = inflate(&strm, Z\_NO\_FLUSH);           assert(ret == Z\_MEM\_ERROR);
00424     mem\_limit(&strm, 0);
00425     memset(dict, 0, 257);
00426     ret = inflateSetDictionary(&strm, dict, 257);
00427                                                 assert(ret == Z\_OK);
00428     mem\_limit(&strm, (\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structinflate__state}{inflate\_state}) << 1) + 256);
00429     ret = inflatePrime(&strm, 16, 0);           assert(ret == Z\_OK);
00430     strm.avail\_in = 2;
00431     strm.next\_in = (\textcolor{keywordtype}{void} *)\textcolor{stringliteral}{"\(\backslash\)x80"};
00432     ret = inflateSync(&strm);                   assert(ret == Z\_DATA\_ERROR);
00433     ret = inflate(&strm, Z\_NO\_FLUSH);           assert(ret == Z\_STREAM\_ERROR);
00434     strm.avail\_in = 4;
00435     strm.next\_in = (\textcolor{keywordtype}{void} *)\textcolor{stringliteral}{"\(\backslash\)0\(\backslash\)0\(\backslash\)xff\(\backslash\)xff"};
00436     ret = inflateSync(&strm);                   assert(ret == Z\_OK);
00437     (void)inflateSyncPoint(&strm);
00438     ret = inflateCopy(&copy, &strm);            assert(ret == Z\_MEM\_ERROR);
00439     mem\_limit(&strm, 0);
00440     ret = inflateUndermine(&strm, 1);           assert(ret == Z\_DATA\_ERROR);
00441     (void)inflateMark(&strm);
00442     ret = inflateEnd(&strm);                    assert(ret == Z\_OK);
00443     mem\_done(&strm, \textcolor{stringliteral}{"miscellaneous, force memory errors"});
00444 \}
00445 
00446 \textcolor{comment}{/* input and output functions for inflateBack() */}
00447 local \textcolor{keywordtype}{unsigned} pull(\textcolor{keywordtype}{void} *desc, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **buf)
00448 \{
00449     \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} next = 0;
00450     \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} dat[] = \{0x63, 0, 2, 0\};
00451     \textcolor{keyword}{struct }\hyperlink{structinflate__state}{inflate\_state} *\hyperlink{structstate}{state};
00452 
00453     \textcolor{keywordflow}{if} (desc == Z\_NULL) \{
00454         next = 0;
00455         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* no input (already provided at next\_in) */}
00456     \}
00457     state = (\textcolor{keywordtype}{void} *)((\hyperlink{structz__stream__s}{z\_stream} *)desc)->state;
00458     \textcolor{keywordflow}{if} (state != Z\_NULL)
00459         state->mode = SYNC;     \textcolor{comment}{/* force an otherwise impossible situation */}
00460     \textcolor{keywordflow}{return} next < \textcolor{keyword}{sizeof}(dat) ? (*buf = dat + next++, 1) : 0;
00461 \}
00462 
00463 local \textcolor{keywordtype}{int} push(\textcolor{keywordtype}{void} *desc, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf, \textcolor{keywordtype}{unsigned} len)
00464 \{
00465     buf += len;
00466     \textcolor{keywordflow}{return} desc != Z\_NULL;      \textcolor{comment}{/* force error if desc not null */}
00467 \}
00468 
00469 \textcolor{comment}{/* cover inflateBack() up to common deflate data cases and after those */}
00470 local \textcolor{keywordtype}{void} cover\_back(\textcolor{keywordtype}{void})
00471 \{
00472     \textcolor{keywordtype}{int} ret;
00473     \hyperlink{structz__stream__s}{z\_stream} strm;
00474     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} win[32768];
00475 
00476     ret = inflateBackInit\_(Z\_NULL, 0, win, 0, 0);
00477                                                 assert(ret == Z\_VERSION\_ERROR);
00478     ret = inflateBackInit(Z\_NULL, 0, win);      assert(ret == Z\_STREAM\_ERROR);
00479     ret = inflateBack(Z\_NULL, Z\_NULL, Z\_NULL, Z\_NULL, Z\_NULL);
00480                                                 assert(ret == Z\_STREAM\_ERROR);
00481     ret = inflateBackEnd(Z\_NULL);               assert(ret == Z\_STREAM\_ERROR);
00482     fputs(\textcolor{stringliteral}{"inflateBack bad parameters\(\backslash\)n"}, stderr);
00483 
00484     mem\_setup(&strm);
00485     ret = inflateBackInit(&strm, 15, win);      assert(ret == Z\_OK);
00486     strm.avail\_in = 2;
00487     strm.next\_in = (\textcolor{keywordtype}{void} *)\textcolor{stringliteral}{"\(\backslash\)x03"};
00488     ret = inflateBack(&strm, pull, Z\_NULL, push, Z\_NULL);
00489                                                 assert(ret == Z\_STREAM\_END);
00490         \textcolor{comment}{/* force output error */}
00491     strm.avail\_in = 3;
00492     strm.next\_in = (\textcolor{keywordtype}{void} *)\textcolor{stringliteral}{"\(\backslash\)x63\(\backslash\)x00"};
00493     ret = inflateBack(&strm, pull, Z\_NULL, push, &strm);
00494                                                 assert(ret == Z\_BUF\_ERROR);
00495         \textcolor{comment}{/* force mode error by mucking with state */}
00496     ret = inflateBack(&strm, pull, &strm, push, Z\_NULL);
00497                                                 assert(ret == Z\_STREAM\_ERROR);
00498     ret = inflateBackEnd(&strm);                assert(ret == Z\_OK);
00499     mem\_done(&strm, \textcolor{stringliteral}{"inflateBack bad state"});
00500 
00501     ret = inflateBackInit(&strm, 15, win);      assert(ret == Z\_OK);
00502     ret = inflateBackEnd(&strm);                assert(ret == Z\_OK);
00503     fputs(\textcolor{stringliteral}{"inflateBack built-in memory routines\(\backslash\)n"}, stderr);
00504 \}
00505 
00506 \textcolor{comment}{/* do a raw inflate of data in hexadecimal with both inflate and inflateBack */}
00507 local \textcolor{keywordtype}{int} \textcolor{keywordflow}{try}(\textcolor{keywordtype}{char} *hex, \textcolor{keywordtype}{char} *\textcolor{keywordtype}{id}, \textcolor{keywordtype}{int} err)
00508 \{
00509     \textcolor{keywordtype}{int} ret;
00510     \textcolor{keywordtype}{unsigned} len, size;
00511     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *in, *out, *win;
00512     \textcolor{keywordtype}{char} *prefix;
00513     \hyperlink{structz__stream__s}{z\_stream} strm;
00514 
00515     \textcolor{comment}{/* convert to hex */}
00516     in = h2b(hex, &len);
00517     assert(in != NULL);
00518 
00519     \textcolor{comment}{/* allocate work areas */}
00520     size = len << 3;
00521     out = malloc(size);
00522     assert(out != NULL);
00523     win = malloc(32768);
00524     assert(win != NULL);
00525     prefix = malloc(strlen(\textcolor{keywordtype}{id}) + 6);
00526     assert(prefix != NULL);
00527 
00528     \textcolor{comment}{/* first with inflate */}
00529     strcpy(prefix, \textcolor{keywordtype}{id});
00530     strcat(prefix, \textcolor{stringliteral}{"-late"});
00531     mem\_setup(&strm);
00532     strm.avail\_in = 0;
00533     strm.next\_in = Z\_NULL;
00534     ret = inflateInit2(&strm, err < 0 ? 47 : -15);
00535     assert(ret == Z\_OK);
00536     strm.avail\_in = len;
00537     strm.next\_in = in;
00538     \textcolor{keywordflow}{do} \{
00539         strm.avail\_out = size;
00540         strm.next\_out = out;
00541         ret = inflate(&strm, Z\_TREES);
00542         assert(ret != Z\_STREAM\_ERROR && ret != Z\_MEM\_ERROR);
00543         \textcolor{keywordflow}{if} (ret == Z\_DATA\_ERROR || ret == Z\_NEED\_DICT)
00544             \textcolor{keywordflow}{break};
00545     \} \textcolor{keywordflow}{while} (strm.avail\_in || strm.avail\_out == 0);
00546     \textcolor{keywordflow}{if} (err) \{
00547         assert(ret == Z\_DATA\_ERROR);
00548         assert(strcmp(\textcolor{keywordtype}{id}, strm.msg) == 0);
00549     \}
00550     inflateEnd(&strm);
00551     mem\_done(&strm, prefix);
00552 
00553     \textcolor{comment}{/* then with inflateBack */}
00554     \textcolor{keywordflow}{if} (err >= 0) \{
00555         strcpy(prefix, \textcolor{keywordtype}{id});
00556         strcat(prefix, \textcolor{stringliteral}{"-back"});
00557         mem\_setup(&strm);
00558         ret = inflateBackInit(&strm, 15, win);
00559         assert(ret == Z\_OK);
00560         strm.avail\_in = len;
00561         strm.next\_in = in;
00562         ret = inflateBack(&strm, pull, Z\_NULL, push, Z\_NULL);
00563         assert(ret != Z\_STREAM\_ERROR);
00564         \textcolor{keywordflow}{if} (err) \{
00565             assert(ret == Z\_DATA\_ERROR);
00566             assert(strcmp(\textcolor{keywordtype}{id}, strm.msg) == 0);
00567         \}
00568         inflateBackEnd(&strm);
00569         mem\_done(&strm, prefix);
00570     \}
00571 
00572     \textcolor{comment}{/* clean up */}
00573     free(prefix);
00574     free(win);
00575     free(out);
00576     free(in);
00577     \textcolor{keywordflow}{return} ret;
00578 \}
00579 
00580 \textcolor{comment}{/* cover deflate data cases in both inflate() and inflateBack() */}
00581 local \textcolor{keywordtype}{void} cover\_inflate(\textcolor{keywordtype}{void})
00582 \{
00583     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"0 0 0 0 0"}, \textcolor{stringliteral}{"invalid stored block lengths"}, 1);
00584     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"3 0"}, \textcolor{stringliteral}{"fixed"}, 0);
00585     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"6"}, \textcolor{stringliteral}{"invalid block type"}, 1);
00586     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"1 1 0 fe ff 0"}, \textcolor{stringliteral}{"stored"}, 0);
00587     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"fc 0 0"}, \textcolor{stringliteral}{"too many length or distance symbols"}, 1);
00588     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"4 0 fe ff"}, \textcolor{stringliteral}{"invalid code lengths set"}, 1);
00589     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"4 0 24 49 0"}, \textcolor{stringliteral}{"invalid bit length repeat"}, 1);
00590     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"4 0 24 e9 ff ff"}, \textcolor{stringliteral}{"invalid bit length repeat"}, 1);
00591     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"4 0 24 e9 ff 6d"}, \textcolor{stringliteral}{"invalid code -- missing end-of-block"}, 1);
00592     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"4 80 49 92 24 49 92 24 71 ff ff 93 11 0"},
00593         \textcolor{stringliteral}{"invalid literal/lengths set"}, 1);
00594     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"4 80 49 92 24 49 92 24 f b4 ff ff c3 84"}, \textcolor{stringliteral}{"invalid distances set"}, 1);
00595     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"4 c0 81 8 0 0 0 0 20 7f eb b 0 0"}, \textcolor{stringliteral}{"invalid literal/length code"}, 1);
00596     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"2 7e ff ff"}, \textcolor{stringliteral}{"invalid distance code"}, 1);
00597     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"c c0 81 0 0 0 0 0 90 ff 6b 4 0"}, \textcolor{stringliteral}{"invalid distance too far back"}, 1);
00598 
00599     \textcolor{comment}{/* also trailer mismatch just in inflate() */}
00600     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 1"}, \textcolor{stringliteral}{"incorrect data check"}, -1);
00601     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 1"},
00602         \textcolor{stringliteral}{"incorrect length check"}, -1);
00603     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"5 c0 21 d 0 0 0 80 b0 fe 6d 2f 91 6c"}, \textcolor{stringliteral}{"pull 17"}, 0);
00604     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"5 e0 81 91 24 cb b2 2c 49 e2 f 2e 8b 9a 47 56 9f fb fe ec d2 ff 1f"},
00605         \textcolor{stringliteral}{"long code"}, 0);
00606     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"ed c0 1 1 0 0 0 40 20 ff 57 1b 42 2c 4f"}, \textcolor{stringliteral}{"length extra"}, 0);
00607     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"ed cf c1 b1 2c 47 10 c4 30 fa 6f 35 1d 1 82 59 3d fb be 2e 2a fc f c"},
00608         \textcolor{stringliteral}{"long distance and extra"}, 0);
00609     \textcolor{keywordflow}{try}(\textcolor{stringliteral}{"ed c0 81 0 0 0 0 80 a0 fd a9 17 a9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "}
00610         \textcolor{stringliteral}{"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6"}, \textcolor{stringliteral}{"window end"}, 0);
00611     inf(\textcolor{stringliteral}{"2 8 20 80 0 3 0"}, \textcolor{stringliteral}{"inflate\_fast TYPE return"}, 0, -15, 258,
00612         Z\_STREAM\_END);
00613     inf(\textcolor{stringliteral}{"63 18 5 40 c 0"}, \textcolor{stringliteral}{"window wrap"}, 3, -8, 300, Z\_OK);
00614 \}
00615 
00616 \textcolor{comment}{/* cover remaining lines in inftrees.c */}
00617 local \textcolor{keywordtype}{void} cover\_trees(\textcolor{keywordtype}{void})
00618 \{
00619     \textcolor{keywordtype}{int} ret;
00620     \textcolor{keywordtype}{unsigned} bits;
00621     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} lens[16], work[16];
00622     \hyperlink{structcode}{code} *next, table[ENOUGH\_DISTS];
00623 
00624     \textcolor{comment}{/* we need to call inflate\_table() directly in order to manifest not-}
00625 \textcolor{comment}{       enough errors, since zlib insures that enough is always enough */}
00626     \textcolor{keywordflow}{for} (bits = 0; bits < 15; bits++)
00627         lens[bits] = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short})(bits + 1);
00628     lens[15] = 15;
00629     next = table;
00630     bits = 15;
00631     ret = inflate\_table(DISTS, lens, 16, &next, &bits, work);
00632                                                 assert(ret == 1);
00633     next = table;
00634     bits = 1;
00635     ret = inflate\_table(DISTS, lens, 16, &next, &bits, work);
00636                                                 assert(ret == 1);
00637     fputs(\textcolor{stringliteral}{"inflate\_table not enough errors\(\backslash\)n"}, stderr);
00638 \}
00639 
00640 \textcolor{comment}{/* cover remaining inffast.c decoding and window copying */}
00641 local \textcolor{keywordtype}{void} cover\_fast(\textcolor{keywordtype}{void})
00642 \{
00643     inf(\textcolor{stringliteral}{"e5 e0 81 ad 6d cb b2 2c c9 01 1e 59 63 ae 7d ee fb 4d fd b5 35 41 68"}
00644         \textcolor{stringliteral}{" ff 7f 0f 0 0 0"}, \textcolor{stringliteral}{"fast length extra bits"}, 0, -8, 258, Z\_DATA\_ERROR);
00645     inf(\textcolor{stringliteral}{"25 fd 81 b5 6d 59 b6 6a 49 ea af 35 6 34 eb 8c b9 f6 b9 1e ef 67 49"}
00646         \textcolor{stringliteral}{" 50 fe ff ff 3f 0 0"}, \textcolor{stringliteral}{"fast distance extra bits"}, 0, -8, 258,
00647         Z\_DATA\_ERROR);
00648     inf(\textcolor{stringliteral}{"3 7e 0 0 0 0 0"}, \textcolor{stringliteral}{"fast invalid distance code"}, 0, -8, 258,
00649         Z\_DATA\_ERROR);
00650     inf(\textcolor{stringliteral}{"1b 7 0 0 0 0 0"}, \textcolor{stringliteral}{"fast invalid literal/length code"}, 0, -8, 258,
00651         Z\_DATA\_ERROR);
00652     inf(\textcolor{stringliteral}{"d c7 1 ae eb 38 c 4 41 a0 87 72 de df fb 1f b8 36 b1 38 5d ff ff 0"},
00653         \textcolor{stringliteral}{"fast 2nd level codes and too far back"}, 0, -8, 258, Z\_DATA\_ERROR);
00654     inf(\textcolor{stringliteral}{"63 18 5 8c 10 8 0 0 0 0"}, \textcolor{stringliteral}{"very common case"}, 0, -8, 259, Z\_OK);
00655     inf(\textcolor{stringliteral}{"63 60 60 18 c9 0 8 18 18 18 26 c0 28 0 29 0 0 0"},
00656         \textcolor{stringliteral}{"contiguous and wrap around window"}, 6, -8, 259, Z\_OK);
00657     inf(\textcolor{stringliteral}{"63 0 3 0 0 0 0 0"}, \textcolor{stringliteral}{"copy direct from output"}, 0, -8, 259,
00658         Z\_STREAM\_END);
00659 \}
00660 
00661 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{void})
00662 \{
00663     fprintf(stderr, \textcolor{stringliteral}{"%s\(\backslash\)n"}, zlibVersion());
00664     cover\_support();
00665     cover\_wrap();
00666     cover\_back();
00667     cover\_inflate();
00668     cover\_trees();
00669     cover\_fast();
00670     \textcolor{keywordflow}{return} 0;
00671 \}
\end{DoxyCode}
