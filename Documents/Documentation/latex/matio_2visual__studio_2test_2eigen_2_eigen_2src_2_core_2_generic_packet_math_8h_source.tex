\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_generic_packet_math_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/\+Generic\+Packet\+Math.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_generic_packet_math_8h_source}\index{Generic\+Packet\+Math.\+h@{Generic\+Packet\+Math.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_GENERIC\_PACKET\_MATH\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_GENERIC\_PACKET\_MATH\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00017 
00026 \textcolor{preprocessor}{#ifndef EIGEN\_DEBUG\_ALIGNED\_LOAD}
00027 \textcolor{preprocessor}{#define EIGEN\_DEBUG\_ALIGNED\_LOAD}
00028 \textcolor{preprocessor}{#endif}
00029 
00030 \textcolor{preprocessor}{#ifndef EIGEN\_DEBUG\_UNALIGNED\_LOAD}
00031 \textcolor{preprocessor}{#define EIGEN\_DEBUG\_UNALIGNED\_LOAD}
00032 \textcolor{preprocessor}{#endif}
00033 
00034 \textcolor{preprocessor}{#ifndef EIGEN\_DEBUG\_ALIGNED\_STORE}
00035 \textcolor{preprocessor}{#define EIGEN\_DEBUG\_ALIGNED\_STORE}
00036 \textcolor{preprocessor}{#endif}
00037 
00038 \textcolor{preprocessor}{#ifndef EIGEN\_DEBUG\_UNALIGNED\_STORE}
00039 \textcolor{preprocessor}{#define EIGEN\_DEBUG\_UNALIGNED\_STORE}
00040 \textcolor{preprocessor}{#endif}
00041 
00042 \textcolor{keyword}{struct }default\_packet\_traits
00043 \{
00044   \textcolor{keyword}{enum} \{
00045     HasHalfPacket = 0,
00046 
00047     HasAdd    = 1,
00048     HasSub    = 1,
00049     HasMul    = 1,
00050     HasNegate = 1,
00051     HasAbs    = 1,
00052     HasArg    = 0,
00053     HasAbs2   = 1,
00054     HasMin    = 1,
00055     HasMax    = 1,
00056     HasConj   = 1,
00057     HasSetLinear = 1,
00058     HasBlend  = 0,
00059 
00060     HasDiv    = 0,
00061     HasSqrt   = 0,
00062     HasRsqrt  = 0,
00063     HasExp    = 0,
00064     HasLog    = 0,
00065     HasLog1p  = 0,
00066     HasLog10  = 0,
00067     HasPow    = 0,
00068 
00069     HasSin    = 0,
00070     HasCos    = 0,
00071     HasTan    = 0,
00072     HasASin   = 0,
00073     HasACos   = 0,
00074     HasATan   = 0,
00075     HasSinh   = 0,
00076     HasCosh   = 0,
00077     HasTanh   = 0,
00078     HasLGamma = 0,
00079     HasDiGamma = 0,
00080     HasZeta = 0,
00081     HasPolygamma = 0,
00082     HasErf = 0,
00083     HasErfc = 0,
00084     HasIGamma = 0,
00085     HasIGammac = 0,
00086     HasBetaInc = 0,
00087 
00088     HasRound  = 0,
00089     HasFloor  = 0,
00090     HasCeil   = 0,
00091 
00092     HasSign   = 0
00093   \};
00094 \};
00095 
00096 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }packet\_traits : default\_packet\_traits
00097 \{
00098   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type;
00099   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} half;
00100   \textcolor{keyword}{enum} \{
00101     Vectorizable = 0,
00102     size = 1,
00103     AlignedOnScalar = 0,
00104     HasHalfPacket = 0
00105   \};
00106   \textcolor{keyword}{enum} \{
00107     HasAdd    = 0,
00108     HasSub    = 0,
00109     HasMul    = 0,
00110     HasNegate = 0,
00111     HasAbs    = 0,
00112     HasAbs2   = 0,
00113     HasMin    = 0,
00114     HasMax    = 0,
00115     HasConj   = 0,
00116     HasSetLinear = 0
00117   \};
00118 \};
00119 
00120 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }packet\_traits<const \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}> : packet\_traits<T> \{ \};
00121 
00122 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Src, \textcolor{keyword}{typename} Tgt> \textcolor{keyword}{struct }type\_casting\_traits \{
00123   \textcolor{keyword}{enum} \{
00124     VectorizedCast = 0,
00125     SrcCoeffRatio = 1,
00126     TgtCoeffRatio = 1
00127   \};
00128 \};
00129 
00130 
00132 \textcolor{keyword}{template} <\textcolor{keyword}{typename} SrcPacket, \textcolor{keyword}{typename} TgtPacket>
00133 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} TgtPacket
00134 pcast(\textcolor{keyword}{const} SrcPacket& a) \{
00135   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}TgtPacket\textcolor{keyword}{>}(a);
00136 \}
00137 \textcolor{keyword}{template} <\textcolor{keyword}{typename} SrcPacket, \textcolor{keyword}{typename} TgtPacket>
00138 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} TgtPacket
00139 pcast(\textcolor{keyword}{const} SrcPacket& a, \textcolor{keyword}{const} SrcPacket& \textcolor{comment}{/*b*/}) \{
00140   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}TgtPacket\textcolor{keyword}{>}(a);
00141 \}
00142 
00143 \textcolor{keyword}{template} <\textcolor{keyword}{typename} SrcPacket, \textcolor{keyword}{typename} TgtPacket>
00144 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} TgtPacket
00145 pcast(\textcolor{keyword}{const} SrcPacket& a, \textcolor{keyword}{const} SrcPacket& \textcolor{comment}{/*b*/}, \textcolor{keyword}{const} SrcPacket& \textcolor{comment}{/*c*/}, \textcolor{keyword}{const} SrcPacket& \textcolor{comment}{/*d*/}) \{
00146   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}TgtPacket\textcolor{keyword}{>}(a);
00147 \}
00148 
00150 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00151 padd(\textcolor{keyword}{const} Packet& a,
00152         \textcolor{keyword}{const} Packet& b) \{ \textcolor{keywordflow}{return} a+b; \}
00153 
00155 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00156 psub(\textcolor{keyword}{const} Packet& a,
00157         \textcolor{keyword}{const} Packet& b) \{ \textcolor{keywordflow}{return} a-b; \}
00158 
00160 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00161 pnegate(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keywordflow}{return} -a; \}
00162 
00165 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00166 pconj(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keywordflow}{return} numext::conj(a); \}
00167 
00169 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00170 pmul(\textcolor{keyword}{const} Packet& a,
00171         \textcolor{keyword}{const} Packet& b) \{ \textcolor{keywordflow}{return} a*b; \}
00172 
00174 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00175 pdiv(\textcolor{keyword}{const} Packet& a,
00176         \textcolor{keyword}{const} Packet& b) \{ \textcolor{keywordflow}{return} a/b; \}
00177 
00179 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00180 pmin(\textcolor{keyword}{const} Packet& a,
00181         \textcolor{keyword}{const} Packet& b) \{ \textcolor{keywordflow}{return} numext::mini(a, b); \}
00182 
00184 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00185 pmax(\textcolor{keyword}{const} Packet& a,
00186         \textcolor{keyword}{const} Packet& b) \{ \textcolor{keywordflow}{return} numext::maxi(a, b); \}
00187 
00189 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00190 pabs(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::abs; \textcolor{keywordflow}{return} abs(a); \}
00191 
00193 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00194 parg(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} numext::arg; \textcolor{keywordflow}{return} arg(a); \}
00195 
00197 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00198 pand(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{const} Packet& b) \{ \textcolor{keywordflow}{return} a & b; \}
00199 
00201 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00202 por(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{const} Packet& b) \{ \textcolor{keywordflow}{return} a | b; \}
00203 
00205 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00206 pxor(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{const} Packet& b) \{ \textcolor{keywordflow}{return} a ^ b; \}
00207 
00209 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00210 pandnot(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{const} Packet& b) \{ \textcolor{keywordflow}{return} a & (!b); \}
00211 
00213 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00214 pload(\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type* from) \{ \textcolor{keywordflow}{return} *from; \}
00215 
00217 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00218 ploadu(\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type* from) \{ \textcolor{keywordflow}{return} *from; \}
00219 
00221 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00222 pset1(\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type& a) \{ \textcolor{keywordflow}{return} a; \}
00223 
00225 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00226 pload1(\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type  *a) \{ \textcolor{keywordflow}{return} pset1<Packet>(*a); \}
00227 
00233 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Packet
00234 ploaddup(\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type* from) \{ \textcolor{keywordflow}{return} *from; \}
00235 
00242 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00243 ploadquad(\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type* from)
00244 \{ \textcolor{keywordflow}{return} pload1<Packet>(from); \}
00245 
00255 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC
00256 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pbroadcast4(\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type *a,
00257                         Packet& a0, Packet& a1, Packet& a2, Packet& a3)
00258 \{
00259   a0 = pload1<Packet>(a+0);
00260   a1 = pload1<Packet>(a+1);
00261   a2 = pload1<Packet>(a+2);
00262   a3 = pload1<Packet>(a+3);
00263 \}
00264 
00272 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC
00273 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pbroadcast2(\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type *a,
00274                         Packet& a0, Packet& a1)
00275 \{
00276   a0 = pload1<Packet>(a+0);
00277   a1 = pload1<Packet>(a+1);
00278 \}
00279 
00281 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Packet
00282 plset(\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type& a) \{ \textcolor{keywordflow}{return} a; \}
00283 
00285 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pstore(Scalar* to, \textcolor{keyword}{const} Packet& 
      from)
00286 \{ (*to) = from; \}
00287 
00289 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pstoreu(Scalar* to, \textcolor{keyword}{const} Packet& 
      from)
00290 \{  (*to) = from; \}
00291 
00292  \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet pgather(\textcolor{keyword}{const} Scalar* from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \textcolor{comment}{/*stride*/})
00293  \{ \textcolor{keywordflow}{return} ploadu<Packet>(from); \}
00294 
00295  \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter(Scalar* to, \textcolor{keyword}{const} Packet
      & from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \textcolor{comment}{/*stride*/})
00296  \{ pstore(to, from); \}
00297 
00299 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} prefetch(\textcolor{keyword}{const} Scalar* addr)
00300 \{
00301 \textcolor{preprocessor}{#ifdef \_\_CUDA\_ARCH\_\_}
00302 \textcolor{preprocessor}{#if defined(\_\_LP64\_\_)}
00303   \textcolor{comment}{// 64-bit pointer operand constraint for inlined asm}
00304   \textcolor{keyword}{asm}(\textcolor{stringliteral}{" prefetch.L1 [ %1 ];"} : \textcolor{stringliteral}{"=l"}(addr) : \textcolor{stringliteral}{"l"}(addr));
00305 \textcolor{preprocessor}{#else}
00306   \textcolor{comment}{// 32-bit pointer operand constraint for inlined asm}
00307   \textcolor{keyword}{asm}(\textcolor{stringliteral}{" prefetch.L1 [ %1 ];"} : \textcolor{stringliteral}{"=r"}(addr) : \textcolor{stringliteral}{"r"}(addr));
00308 \textcolor{preprocessor}{#endif}
00309 \textcolor{preprocessor}{#elif (!EIGEN\_COMP\_MSVC) && (EIGEN\_COMP\_GNUC || EIGEN\_COMP\_CLANG || EIGEN\_COMP\_ICC)}
00310   \_\_builtin\_prefetch(addr);
00311 \textcolor{preprocessor}{#endif}
00312 \}
00313 
00315 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type pfirst(\textcolor{keyword}{const} 
      Packet& a)
00316 \{ \textcolor{keywordflow}{return} a; \}
00317 
00319 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00320 preduxp(\textcolor{keyword}{const} Packet* vecs) \{ \textcolor{keywordflow}{return} vecs[0]; \}
00321 
00323 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type predux(\textcolor{keyword}{const} 
      Packet& a)
00324 \{ \textcolor{keywordflow}{return} a; \}
00325 
00330 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline}
00331 \textcolor{keyword}{typename} conditional<(unpacket\_traits<Packet>::size%8)==0,\textcolor{keyword}{typename} unpacket\_traits<Packet>::half,Packet>::
      type
00332 predux\_downto4(\textcolor{keyword}{const} Packet& a)
00333 \{ \textcolor{keywordflow}{return} a; \}
00334 
00336 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type predux\_mul(\textcolor{keyword}{const} 
      Packet& a)
00337 \{ \textcolor{keywordflow}{return} a; \}
00338 
00340 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type predux\_min(\textcolor{keyword}{const} 
      Packet& a)
00341 \{ \textcolor{keywordflow}{return} a; \}
00342 
00344 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type predux\_max(\textcolor{keyword}{const} 
      Packet& a)
00345 \{ \textcolor{keywordflow}{return} a; \}
00346 
00348 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet preverse(\textcolor{keyword}{const} Packet& a)
00349 \{ \textcolor{keywordflow}{return} a; \}
00350 
00352 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet pcplxflip(\textcolor{keyword}{const} Packet& a)
00353 \{
00354   \textcolor{comment}{// FIXME: uncomment the following in case we drop the internal imag and real functions.}
00355 \textcolor{comment}{//   using std::imag;}
00356 \textcolor{comment}{//   using std::real;}
00357   \textcolor{keywordflow}{return} Packet(imag(a),real(a));
00358 \}
00359 
00360 \textcolor{comment}{/**************************}
00361 \textcolor{comment}{* Special math functions}
00362 \textcolor{comment}{***************************/}
00363 
00365 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00366 Packet psin(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::sin; \textcolor{keywordflow}{return} sin(a); \}
00367 
00369 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00370 Packet pcos(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::cos; \textcolor{keywordflow}{return} cos(a); \}
00371 
00373 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00374 Packet ptan(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::tan; \textcolor{keywordflow}{return} tan(a); \}
00375 
00377 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00378 Packet pasin(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::asin; \textcolor{keywordflow}{return} asin(a); \}
00379 
00381 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00382 Packet pacos(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::acos; \textcolor{keywordflow}{return} acos(a); \}
00383 
00385 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00386 Packet patan(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::atan; \textcolor{keywordflow}{return} atan(a); \}
00387 
00389 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00390 Packet psinh(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::sinh; \textcolor{keywordflow}{return} sinh(a); \}
00391 
00393 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00394 Packet pcosh(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::cosh; \textcolor{keywordflow}{return} cosh(a); \}
00395 
00397 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00398 Packet ptanh(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::tanh; \textcolor{keywordflow}{return} tanh(a); \}
00399 
00401 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00402 Packet pexp(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::exp; \textcolor{keywordflow}{return} exp(a); \}
00403 
00405 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00406 Packet plog(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::log; \textcolor{keywordflow}{return} \hyperlink{structlog}{log}(a); \}
00407 
00409 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00410 Packet plog1p(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keywordflow}{return} numext::log1p(a); \}
00411 
00413 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00414 Packet plog10(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::log10; \textcolor{keywordflow}{return} log10(a); \}
00415 
00417 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00418 Packet psqrt(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} std::sqrt; \textcolor{keywordflow}{return} sqrt(a); \}
00419 
00421 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00422 Packet prsqrt(\textcolor{keyword}{const} Packet& a) \{
00423   \textcolor{keywordflow}{return} pdiv(pset1<Packet>(1), psqrt(a));
00424 \}
00425 
00427 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00428 Packet pround(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} numext::round; \textcolor{keywordflow}{return} round(a); \}
00429 
00431 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00432 Packet pfloor(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} numext::floor; \textcolor{keywordflow}{return} floor(a); \}
00433 
00435 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS
00436 Packet pceil(\textcolor{keyword}{const} Packet& a) \{ \textcolor{keyword}{using} numext::ceil; \textcolor{keywordflow}{return} ceil(a); \}
00437 
00438 \textcolor{comment}{/***************************************************************************}
00439 \textcolor{comment}{* The following functions might not have to be overwritten for vectorized types}
00440 \textcolor{comment}{***************************************************************************/}
00441 
00443 \textcolor{comment}{// NOTE: this function must really be templated on the packet type (think about different packet types for
       the same scalar type)}
00444 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00445 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pstore1(\textcolor{keyword}{typename} unpacket\_traits<Packet>::type* to, \textcolor{keyword}{const} \textcolor{keyword}{typename} 
      unpacket\_traits<Packet>::type& a)
00446 \{
00447   pstore(to, pset1<Packet>(a));
00448 \}
00449 
00451 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00452 pmadd(\textcolor{keyword}{const} Packet&  a,
00453          \textcolor{keyword}{const} Packet&  b,
00454          \textcolor{keyword}{const} Packet&  c)
00455 \{ \textcolor{keywordflow}{return} padd(pmul(a, b),c); \}
00456 
00459 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet, \textcolor{keywordtype}{int} Alignment>
00460 EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE Packet ploadt(\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type* from)
00461 \{
00462   \textcolor{keywordflow}{if}(Alignment >= unpacket\_traits<Packet>::alignment)
00463     \textcolor{keywordflow}{return} pload<Packet>(from);
00464   \textcolor{keywordflow}{else}
00465     \textcolor{keywordflow}{return} ploadu<Packet>(from);
00466 \}
00467 
00470 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet, \textcolor{keywordtype}{int} Alignment>
00471 EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \textcolor{keywordtype}{void} pstoret(Scalar* to, \textcolor{keyword}{const} Packet& from)
00472 \{
00473   \textcolor{keywordflow}{if}(Alignment >= unpacket\_traits<Packet>::alignment)
00474     pstore(to, from);
00475   \textcolor{keywordflow}{else}
00476     pstoreu(to, from);
00477 \}
00478 
00484 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet, \textcolor{keywordtype}{int} LoadMode>
00485 EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE Packet ploadt\_ro(\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<Packet>::type* from)
00486 \{
00487   \textcolor{keywordflow}{return} ploadt<Packet, LoadMode>(from);
00488 \}
00489 
00491 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset,\textcolor{keyword}{typename} PacketType>
00492 \textcolor{keyword}{struct }palign\_impl
00493 \{
00494   \textcolor{comment}{// by default data are aligned, so there is nothing to be done :)}
00495   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(PacketType&, \textcolor{keyword}{const} PacketType&) \{\}
00496 \};
00497 
00513 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset,\textcolor{keyword}{typename} PacketType>
00514 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} palign(PacketType& first, \textcolor{keyword}{const} PacketType& second)
00515 \{
00516   palign\_impl<Offset,PacketType>::run(first,second);
00517 \}
00518 
00519 \textcolor{comment}{/***************************************************************************}
00520 \textcolor{comment}{* Fast complex products (GCC generates a function call which is very slow)}
00521 \textcolor{comment}{***************************************************************************/}
00522 
00523 \textcolor{comment}{// Eigen+CUDA does not support complexes.}
00524 \textcolor{preprocessor}{#ifndef \_\_CUDACC\_\_}
00525 
00526 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} std::complex<float> pmul(\textcolor{keyword}{const} std::complex<float>& a, \textcolor{keyword}{const} std::complex<float>& b)
00527 \{ \textcolor{keywordflow}{return} std::complex<float>(real(a)*real(b) - imag(a)*imag(b), imag(a)*real(b) + real(a)*imag(b)); \}
00528 
00529 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} std::complex<double> pmul(\textcolor{keyword}{const} std::complex<double>& a, \textcolor{keyword}{const} std::complex<double>& b)
00530 \{ \textcolor{keywordflow}{return} std::complex<double>(real(a)*real(b) - imag(a)*imag(b), imag(a)*real(b) + real(a)*imag(b)); \}
00531 
00532 \textcolor{preprocessor}{#endif}
00533 
00534 
00535 \textcolor{comment}{/***************************************************************************}
00536 \textcolor{comment}{ * PacketBlock, that is a collection of N packets where the number of words}
00537 \textcolor{comment}{ * in the packet is a multiple of N.}
00538 \textcolor{comment}{***************************************************************************/}
00539 template <typename Packet,int N=unpacket\_traits<Packet>::size> \textcolor{keyword}{struct }PacketBlock \{
00540   Packet packet[N];
00541 \};
00542 
00543 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00544 ptranspose(PacketBlock<Packet,1>& \textcolor{comment}{/*kernel*/}) \{
00545   \textcolor{comment}{// Nothing to do in the scalar case, i.e. a 1x1 matrix.}
00546 \}
00547 
00548 \textcolor{comment}{/***************************************************************************}
00549 \textcolor{comment}{ * Selector, i.e. vector of N boolean values used to select (i.e. blend)}
00550 \textcolor{comment}{ * words from 2 packets.}
00551 \textcolor{comment}{***************************************************************************/}
00552 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N> \textcolor{keyword}{struct }Selector \{
00553   \textcolor{keywordtype}{bool} select[N];
00554 \};
00555 
00556 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00557 pblend(\textcolor{keyword}{const} Selector<unpacket\_traits<Packet>::size>& ifPacket, \textcolor{keyword}{const} Packet& thenPacket, \textcolor{keyword}{const} Packet& 
      elsePacket) \{
00558   \textcolor{keywordflow}{return} ifPacket.select[0] ? thenPacket : elsePacket;
00559 \}
00560 
00562 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00563 pinsertfirst(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{typename} unpacket\_traits<Packet>::type b)
00564 \{
00565   \textcolor{comment}{// Default implementation based on pblend.}
00566   \textcolor{comment}{// It must be specialized for higher performance.}
00567   Selector<unpacket\_traits<Packet>::size> mask;
00568   mask.select[0] = \textcolor{keyword}{true};
00569   \textcolor{comment}{// This for loop should be optimized away by the compiler.}
00570   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=1; i<unpacket\_traits<Packet>::size; ++i)
00571     mask.select[i] = \textcolor{keyword}{false};
00572   \textcolor{keywordflow}{return} pblend(mask, pset1<Packet>(b), a);
00573 \}
00574 
00576 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet
00577 pinsertlast(\textcolor{keyword}{const} Packet& a, \textcolor{keyword}{typename} unpacket\_traits<Packet>::type b)
00578 \{
00579   \textcolor{comment}{// Default implementation based on pblend.}
00580   \textcolor{comment}{// It must be specialized for higher performance.}
00581   Selector<unpacket\_traits<Packet>::size> mask;
00582   \textcolor{comment}{// This for loop should be optimized away by the compiler.}
00583   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<unpacket\_traits<Packet>::size-1; ++i)
00584     mask.select[i] = \textcolor{keyword}{false};
00585   mask.select[unpacket\_traits<Packet>::size-1] = \textcolor{keyword}{true};
00586   \textcolor{keywordflow}{return} pblend(mask, pset1<Packet>(b), a);
00587 \}
00588 
00589 \} \textcolor{comment}{// end namespace internal}
00590 
00591 \} \textcolor{comment}{// end namespace Eigen}
00592 
00593 \textcolor{preprocessor}{#endif // EIGEN\_GENERIC\_PACKET\_MATH\_H}
\end{DoxyCode}
