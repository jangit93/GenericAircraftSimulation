\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2test_2cxx11__tensor__volume__patch_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/test/cxx11\+\_\+tensor\+\_\+volume\+\_\+patch.cpp}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2test_2cxx11__tensor__volume__patch_8cpp_source}\index{cxx11\+\_\+tensor\+\_\+volume\+\_\+patch.\+cpp@{cxx11\+\_\+tensor\+\_\+volume\+\_\+patch.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#include "main.h"}
00002 
00003 \textcolor{preprocessor}{#include <Eigen/CXX11/Tensor>}
00004 
00005 \textcolor{keyword}{using} \hyperlink{class_eigen_1_1_tensor}{Eigen::Tensor};
00006 
00007 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_single\_voxel\_patch()
00008 \{
00009   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 5>} tensor(4,2,3,5,7);
00010   tensor.setRandom();
00011   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 5, RowMajor>} tensor\_row\_major = tensor.swap\_layout();
00012 
00013   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 6>} single\_voxel\_patch;
00014   single\_voxel\_patch = tensor.extract\_volume\_patches(1, 1, 1);
00015   VERIFY\_IS\_EQUAL(single\_voxel\_patch.dimension(0), 4);
00016   VERIFY\_IS\_EQUAL(single\_voxel\_patch.dimension(1), 1);
00017   VERIFY\_IS\_EQUAL(single\_voxel\_patch.dimension(2), 1);
00018   VERIFY\_IS\_EQUAL(single\_voxel\_patch.dimension(3), 1);
00019   VERIFY\_IS\_EQUAL(single\_voxel\_patch.dimension(4), 2 * 3 * 5);
00020   VERIFY\_IS\_EQUAL(single\_voxel\_patch.dimension(5), 7);
00021 
00022   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 6, RowMajor>} single\_voxel\_patch\_row\_major;
00023   single\_voxel\_patch\_row\_major = tensor\_row\_major.extract\_volume\_patches(1, 1, 1);
00024   VERIFY\_IS\_EQUAL(single\_voxel\_patch\_row\_major.dimension(0), 7);
00025   VERIFY\_IS\_EQUAL(single\_voxel\_patch\_row\_major.dimension(1), 2 * 3 * 5);
00026   VERIFY\_IS\_EQUAL(single\_voxel\_patch\_row\_major.dimension(2), 1);
00027   VERIFY\_IS\_EQUAL(single\_voxel\_patch\_row\_major.dimension(3), 1);
00028   VERIFY\_IS\_EQUAL(single\_voxel\_patch\_row\_major.dimension(4), 1);
00029   VERIFY\_IS\_EQUAL(single\_voxel\_patch\_row\_major.dimension(5), 4);
00030 
00031   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < tensor.size(); ++i) \{
00032     VERIFY\_IS\_EQUAL(tensor.data()[i], single\_voxel\_patch.data()[i]);
00033     VERIFY\_IS\_EQUAL(tensor\_row\_major.data()[i], single\_voxel\_patch\_row\_major.data()[i]);
00034     VERIFY\_IS\_EQUAL(tensor.data()[i], tensor\_row\_major.data()[i]);
00035   \}
00036 \}
00037 
00038 
00039 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_entire\_volume\_patch()
00040 \{
00041   \textcolor{keyword}{const} \textcolor{keywordtype}{int} depth = 4;
00042   \textcolor{keyword}{const} \textcolor{keywordtype}{int} patch\_z = 2;
00043   \textcolor{keyword}{const} \textcolor{keywordtype}{int} patch\_y = 3;
00044   \textcolor{keyword}{const} \textcolor{keywordtype}{int} patch\_x = 5;
00045   \textcolor{keyword}{const} \textcolor{keywordtype}{int} batch = 7;
00046 
00047   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 5>} tensor(depth, patch\_z, patch\_y, patch\_x, batch);
00048   tensor.setRandom();
00049   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 5, RowMajor>} tensor\_row\_major = tensor.swap\_layout();
00050 
00051   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 6>} entire\_volume\_patch;
00052   entire\_volume\_patch = tensor.extract\_volume\_patches(patch\_z, patch\_y, patch\_x);
00053   VERIFY\_IS\_EQUAL(entire\_volume\_patch.dimension(0), depth);
00054   VERIFY\_IS\_EQUAL(entire\_volume\_patch.dimension(1), patch\_z);
00055   VERIFY\_IS\_EQUAL(entire\_volume\_patch.dimension(2), patch\_y);
00056   VERIFY\_IS\_EQUAL(entire\_volume\_patch.dimension(3), patch\_x);
00057   VERIFY\_IS\_EQUAL(entire\_volume\_patch.dimension(4), patch\_z * patch\_y * patch\_x);
00058   VERIFY\_IS\_EQUAL(entire\_volume\_patch.dimension(5), batch);
00059 
00060   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 6, RowMajor>} entire\_volume\_patch\_row\_major;
00061   entire\_volume\_patch\_row\_major = tensor\_row\_major.extract\_volume\_patches(patch\_z, patch\_y, patch\_x);
00062   VERIFY\_IS\_EQUAL(entire\_volume\_patch\_row\_major.dimension(0), batch);
00063   VERIFY\_IS\_EQUAL(entire\_volume\_patch\_row\_major.dimension(1), patch\_z * patch\_y * patch\_x);
00064   VERIFY\_IS\_EQUAL(entire\_volume\_patch\_row\_major.dimension(2), patch\_x);
00065   VERIFY\_IS\_EQUAL(entire\_volume\_patch\_row\_major.dimension(3), patch\_y);
00066   VERIFY\_IS\_EQUAL(entire\_volume\_patch\_row\_major.dimension(4), patch\_z);
00067   VERIFY\_IS\_EQUAL(entire\_volume\_patch\_row\_major.dimension(5), depth);
00068 
00069   \textcolor{keyword}{const} \textcolor{keywordtype}{int} dz = patch\_z - 1;
00070   \textcolor{keyword}{const} \textcolor{keywordtype}{int} dy = patch\_y - 1;
00071   \textcolor{keyword}{const} \textcolor{keywordtype}{int} dx = patch\_x - 1;
00072 
00073   \textcolor{keyword}{const} \textcolor{keywordtype}{int} forward\_pad\_z = dz - dz / 2;
00074   \textcolor{keyword}{const} \textcolor{keywordtype}{int} forward\_pad\_y = dy - dy / 2;
00075   \textcolor{keyword}{const} \textcolor{keywordtype}{int} forward\_pad\_x = dx - dx / 2;
00076 
00077   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} pz = 0; pz < patch\_z; pz++) \{
00078     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} py = 0; py < patch\_y; py++) \{
00079       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} px = 0; px < patch\_x; px++) \{
00080         \textcolor{keyword}{const} \textcolor{keywordtype}{int} patchId = pz + patch\_z * (py + px * patch\_y);
00081         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} z = 0; z < patch\_z; z++) \{
00082           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y = 0; y < patch\_y; y++) \{
00083             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x = 0; x < patch\_x; x++) \{
00084               \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} b = 0; b < batch; b++) \{
00085                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} d = 0; d < depth; d++) \{
00086                   \textcolor{keywordtype}{float} expected = 0.0f;
00087                   \textcolor{keywordtype}{float} expected\_row\_major = 0.0f;
00088                   \textcolor{keyword}{const} \textcolor{keywordtype}{int} eff\_z = z - forward\_pad\_z + pz;
00089                   \textcolor{keyword}{const} \textcolor{keywordtype}{int} eff\_y = y - forward\_pad\_y + py;
00090                   \textcolor{keyword}{const} \textcolor{keywordtype}{int} eff\_x = x - forward\_pad\_x + px;
00091                   \textcolor{keywordflow}{if} (eff\_z >= 0 && eff\_y >= 0 && eff\_x >= 0 &&
00092                       eff\_z < patch\_z && eff\_y < patch\_y && eff\_x < patch\_x) \{
00093                     expected = tensor(d, eff\_z, eff\_y, eff\_x, b);
00094                     expected\_row\_major = tensor\_row\_major(b, eff\_x, eff\_y, eff\_z, d);
00095                   \}
00096                   VERIFY\_IS\_EQUAL(entire\_volume\_patch(d, z, y, x, patchId, b), expected);
00097                   VERIFY\_IS\_EQUAL(entire\_volume\_patch\_row\_major(b, patchId, x, y, z, d), expected\_row\_major
      );
00098                 \}
00099               \}
00100             \}
00101           \}
00102         \}
00103       \}
00104     \}
00105   \}
00106 \}
00107 
00108 \textcolor{keywordtype}{void} test\_cxx11\_tensor\_volume\_patch()
00109 \{
00110   CALL\_SUBTEST(test\_single\_voxel\_patch());
00111   CALL\_SUBTEST(test\_entire\_volume\_patch());
00112 \}
\end{DoxyCode}
