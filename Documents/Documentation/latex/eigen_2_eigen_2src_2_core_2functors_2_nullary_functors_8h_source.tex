\hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source}{}\section{eigen/\+Eigen/src/\+Core/functors/\+Nullary\+Functors.h}
\label{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source}\index{Nullary\+Functors.\+h@{Nullary\+Functors.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2016 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_NULLARY\_FUNCTORS\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_NULLARY\_FUNCTORS\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00018}\hyperlink{struct_eigen_1_1internal_1_1scalar__constant__op}{00018} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__constant__op}{scalar\_constant\_op} \{
00019   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1scalar__constant__op}{scalar\_constant\_op}(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1scalar__constant__op}{scalar\_constant\_op}& other) : m\_other(other.m\_other) \{ \}
00020   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE scalar\_constant\_op(\textcolor{keyword}{const} Scalar& other) : m\_other(other) \{ \}
00021   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator() ()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_other; \}
00022   \textcolor{keyword}{template}<\textcolor{keyword}{typename} PacketType>
00023   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_packet_type}{PacketType} packetOp()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 
      internal::pset1<PacketType>(m\_other); \}
00024   \textcolor{keyword}{const} Scalar m\_other;
00025 \};
00026 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00027}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__constant__op_3_01_scalar_01_4_01_4}{00027} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__constant__op}{scalar\_constant\_op}<Scalar> >
00028 \{ \textcolor{keyword}{enum} \{ Cost = 0 \textcolor{comment}{/* as the constant value should be loaded in register only once for the whole expression 
      */},
00029          PacketAccess = \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<Scalar>::Vectorizable}, 
      IsRepeatable = \textcolor{keyword}{true} \}; \};
00030 
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00031}\hyperlink{struct_eigen_1_1internal_1_1scalar__identity__op}{00031} \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1scalar__identity__op}{scalar\_identity\_op} \{
00032   EIGEN\_EMPTY\_STRUCT\_CTOR(\hyperlink{struct_eigen_1_1internal_1_1scalar__identity__op}{scalar\_identity\_op})
00033   \textcolor{keyword}{template}<\textcolor{keyword}{typename} IndexType>
00034   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator() (IndexType row, IndexType col)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{
      return} row==col ? Scalar(1) : Scalar(0); \}
00035 \};
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00037}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01scalar__identity__op_3_01_scalar_01_4_01_4}{00037} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}<\hyperlink{struct_eigen_1_1internal_1_1scalar__identity__op}{scalar\_identity\_op}<Scalar> >
00038 \{ \textcolor{keyword}{enum} \{ Cost = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::AddCost}, PacketAccess = \textcolor{keyword}{false}, IsRepeatable = \textcolor{keyword}{
      true} \}; \};
00039 
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00040}\hyperlink{struct_eigen_1_1internal_1_1linspaced__op__impl}{00040} \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet, \textcolor{keywordtype}{bool} IsInteger> \textcolor{keyword}{struct }
      \hyperlink{struct_eigen_1_1internal_1_1linspaced__op__impl}{linspaced\_op\_impl};
00041 
00042 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00043}\hyperlink{struct_eigen_1_1internal_1_1linspaced__op__impl_3_01_scalar_00_01_packet_00_01false_01_4}{00043} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1linspaced__op__impl}{linspaced\_op\_impl}<Scalar,\hyperlink{union_eigen_1_1internal_1_1_packet}{Packet},\textcolor{comment}{/*IsInteger*/}false>
00044 \{
00045   \hyperlink{struct_eigen_1_1internal_1_1linspaced__op__impl}{linspaced\_op\_impl}(\textcolor{keyword}{const} Scalar& low, \textcolor{keyword}{const} Scalar& high, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} num\_steps) :
00046     m\_low(low), m\_high(high), m\_size1(num\_steps==1 ? 1 : num\_steps-1), m\_step(num\_steps==1 ? Scalar() : (
      high-low)/Scalar(num\_steps-1)),
00047     m\_flip(numext::abs(high)<numext::abs(low))
00048   \{\}
00049 
00050   \textcolor{keyword}{template}<\textcolor{keyword}{typename} IndexType>
00051   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator() (IndexType i)\textcolor{keyword}{ const }\{
00052     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00053     \textcolor{keywordflow}{if}(m\_flip)
00054       \textcolor{keywordflow}{return} (i==0)? m\_low : (m\_high - RealScalar(m\_size1-i)*m\_step);
00055     \textcolor{keywordflow}{else}
00056       \textcolor{keywordflow}{return} (i==m\_size1)? m\_high : (m\_low + RealScalar(i)*m\_step);
00057   \}
00058 
00059   \textcolor{keyword}{template}<\textcolor{keyword}{typename} IndexType>
00060   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} packetOp(IndexType i)\textcolor{keyword}{ const}
00061 \textcolor{keyword}{  }\{
00062     \textcolor{comment}{// Principle:}
00063     \textcolor{comment}{// [low, ..., low] + ( [step, ..., step] * ( [i, ..., i] + [0, ..., size] ) )}
00064     \textcolor{keywordflow}{if}(m\_flip)
00065     \{
00066       \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} pi = plset<Packet>(Scalar(i-m\_size1));
00067       \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} res = padd(pset1<Packet>(m\_high), pmul(pset1<Packet>(m\_step), pi));
00068       \textcolor{keywordflow}{if}(i==0)
00069         res = pinsertfirst(res, m\_low);
00070       \textcolor{keywordflow}{return} res;
00071     \}
00072     \textcolor{keywordflow}{else}
00073     \{
00074       \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} pi = plset<Packet>(Scalar(i));
00075       \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} res = padd(pset1<Packet>(m\_low), pmul(pset1<Packet>(m\_step), pi));
00076       \textcolor{keywordflow}{if}(i==m\_size1-\hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{unpacket\_traits<Packet>::size}+1)
00077         res = pinsertlast(res, m\_high);
00078       \textcolor{keywordflow}{return} res;
00079     \}
00080   \}
00081 
00082   \textcolor{keyword}{const} Scalar m\_low;
00083   \textcolor{keyword}{const} Scalar m\_high;
00084   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_size1;
00085   \textcolor{keyword}{const} Scalar m\_step;
00086   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} m\_flip;
00087 \};
00088 
00089 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00090}\hyperlink{struct_eigen_1_1internal_1_1linspaced__op__impl_3_01_scalar_00_01_packet_00_01true_01_4}{00090} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1linspaced__op__impl}{linspaced\_op\_impl}<Scalar,\hyperlink{union_eigen_1_1internal_1_1_packet}{Packet},\textcolor{comment}{/*IsInteger*/}true>
00091 \{
00092   \hyperlink{struct_eigen_1_1internal_1_1linspaced__op__impl}{linspaced\_op\_impl}(\textcolor{keyword}{const} Scalar& low, \textcolor{keyword}{const} Scalar& high, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} num\_steps) :
00093     m\_low(low),
00094     m\_multiplier((high-low)/convert\_index<Scalar>(num\_steps<=1 ? 1 : num\_steps-1)),
00095     m\_divisor(convert\_index<Scalar>((high>=low?num\_steps:-num\_steps)+(high-low))/((numext::abs(high-low)+1)
      ==0?1:(numext::abs(high-low)+1))),
00096     m\_use\_divisor(num\_steps>1 && (numext::abs(high-low)+1)<num\_steps)
00097   \{\}
00098 
00099   \textcolor{keyword}{template}<\textcolor{keyword}{typename} IndexType>
00100   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00101   \textcolor{keyword}{const} Scalar operator() (IndexType i)\textcolor{keyword}{ const}
00102 \textcolor{keyword}{  }\{
00103     \textcolor{keywordflow}{if}(m\_use\_divisor) \textcolor{keywordflow}{return} m\_low + convert\_index<Scalar>(i)/m\_divisor;
00104     \textcolor{keywordflow}{else}              \textcolor{keywordflow}{return} m\_low + convert\_index<Scalar>(i)*m\_multiplier;
00105   \}
00106 
00107   \textcolor{keyword}{const} Scalar m\_low;
00108   \textcolor{keyword}{const} Scalar m\_multiplier;
00109   \textcolor{keyword}{const} Scalar m\_divisor;
00110   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} m\_use\_divisor;
00111 \};
00112 
00113 \textcolor{comment}{// ----- Linspace functor ----------------------------------------------------------------}
00114 
00115 \textcolor{comment}{// Forward declaration (we default to random access which does not really give}
00116 \textcolor{comment}{// us a speed gain when using packet access but it allows to use the functor in}
00117 \textcolor{comment}{// nested expressions).}
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00118}\hyperlink{struct_eigen_1_1internal_1_1linspaced__op}{00118} \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} PacketType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1linspaced__op}{linspaced\_op};
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00119}\hyperlink{struct_eigen_1_1internal_1_1functor__traits_3_01linspaced__op_3_01_scalar_00_01_packet_type_01_4_01_4}{00119} \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} PacketType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__traits}{functor\_traits}< 
      \hyperlink{struct_eigen_1_1internal_1_1linspaced__op}{linspaced\_op}<Scalar,\hyperlink{struct_eigen_1_1_packet_type}{PacketType}> >
00120 \{
00121   \textcolor{keyword}{enum}
00122   \{
00123     Cost = 1,
00124     PacketAccess =   (!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsInteger}) && 
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<Scalar>::HasSetLinear} && 
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<Scalar>::HasBlend},
00125                   \textcolor{comment}{/*&& ((!NumTraits<Scalar>::IsInteger) || packet\_traits<Scalar>::HasDiv),*/} \textcolor{comment}{// <-
       vectorization for integer is currently disabled}
00126     IsRepeatable = \textcolor{keyword}{true}
00127   \};
00128 \};
00129 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} PacketType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1linspaced__op}{linspaced\_op}
00130 \{
00131   \hyperlink{struct_eigen_1_1internal_1_1linspaced__op}{linspaced\_op}(\textcolor{keyword}{const} Scalar& low, \textcolor{keyword}{const} Scalar& high, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} num\_steps)
00132     : impl((num\_steps==1 ? high : low),high,num\_steps)
00133   \{\}
00134 
00135   \textcolor{keyword}{template}<\textcolor{keyword}{typename} IndexType>
00136   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator() (IndexType i)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} impl(i); \}
00137 
00138   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet,\textcolor{keyword}{typename} IndexType>
00139   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} packetOp(IndexType i)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} impl.
      packetOp(i); \}
00140 
00141   \textcolor{comment}{// This proxy object handles the actual required temporaries and the different}
00142   \textcolor{comment}{// implementations (integer vs. floating point).}
00143   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1linspaced__op__impl}{linspaced\_op\_impl<Scalar,PacketType,NumTraits<Scalar>::IsInteger}
      > impl;
00144 \};
00145 
00146 \textcolor{comment}{// Linear access is automatically determined from the operator() prototypes available for the given
       functor.}
00147 \textcolor{comment}{// If it exposes an operator()(i,j), then we assume the i and j coefficients are required independently}
00148 \textcolor{comment}{// and linear access is not possible. In all other cases, linear access is enabled.}
00149 \textcolor{comment}{// Users should not have to deal with this structure.}
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00150}\hyperlink{struct_eigen_1_1internal_1_1functor__has__linear__access}{00150} \textcolor{keyword}{template}<\textcolor{keyword}{typename} Functor> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1functor__has__linear__access}{functor\_has\_linear\_access} \{ \textcolor{keyword}{enum} \{ ret = !
      \hyperlink{struct_eigen_1_1internal_1_1has__binary__operator}{has\_binary\_operator<Functor>::value} \}; \};
00151 
00152 \textcolor{comment}{// For unreliable compilers, let's specialize the has\_*ary\_operator}
00153 \textcolor{comment}{// helpers so that at least built-in nullary functors work fine.}
00154 \textcolor{preprocessor}{#if !( (EIGEN\_COMP\_MSVC>1600) || (EIGEN\_GNUC\_AT\_LEAST(4,8)) || (EIGEN\_COMP\_ICC>=1600))}
00155 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} IndexType>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00156}\hyperlink{struct_eigen_1_1internal_1_1has__nullary__operator_3_01scalar__constant__op_3_01_scalar_01_4_00_01_index_type_01_4}{00156} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1has__nullary__operator}{has\_nullary\_operator}<\hyperlink{struct_eigen_1_1internal_1_1scalar__constant__op}{scalar\_constant\_op}<Scalar>,IndexType> \{ \textcolor{keyword}{
      enum} \{ value = 1\}; \};
00157 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} IndexType>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00158}\hyperlink{struct_eigen_1_1internal_1_1has__unary__operator_3_01scalar__constant__op_3_01_scalar_01_4_00_01_index_type_01_4}{00158} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1has__unary__operator}{has\_unary\_operator}<\hyperlink{struct_eigen_1_1internal_1_1scalar__constant__op}{scalar\_constant\_op}<Scalar>,IndexType> \{ \textcolor{keyword}{enum} 
      \{ value = 0\}; \};
00159 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} IndexType>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00160}\hyperlink{struct_eigen_1_1internal_1_1has__binary__operator_3_01scalar__constant__op_3_01_scalar_01_4_00_01_index_type_01_4}{00160} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1has__binary__operator}{has\_binary\_operator}<\hyperlink{struct_eigen_1_1internal_1_1scalar__constant__op}{scalar\_constant\_op}<Scalar>,IndexType> \{ \textcolor{keyword}{
      enum} \{ value = 0\}; \};
00161 
00162 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} IndexType>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00163}\hyperlink{struct_eigen_1_1internal_1_1has__nullary__operator_3_01scalar__identity__op_3_01_scalar_01_4_00_01_index_type_01_4}{00163} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1has__nullary__operator}{has\_nullary\_operator}<\hyperlink{struct_eigen_1_1internal_1_1scalar__identity__op}{scalar\_identity\_op}<Scalar>,IndexType> \{ \textcolor{keyword}{
      enum} \{ value = 0\}; \};
00164 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} IndexType>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00165}\hyperlink{struct_eigen_1_1internal_1_1has__unary__operator_3_01scalar__identity__op_3_01_scalar_01_4_00_01_index_type_01_4}{00165} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1has__unary__operator}{has\_unary\_operator}<\hyperlink{struct_eigen_1_1internal_1_1scalar__identity__op}{scalar\_identity\_op}<Scalar>,IndexType> \{ \textcolor{keyword}{enum} 
      \{ value = 0\}; \};
00166 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} IndexType>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00167}\hyperlink{struct_eigen_1_1internal_1_1has__binary__operator_3_01scalar__identity__op_3_01_scalar_01_4_00_01_index_type_01_4}{00167} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1has__binary__operator}{has\_binary\_operator}<\hyperlink{struct_eigen_1_1internal_1_1scalar__identity__op}{scalar\_identity\_op}<Scalar>,IndexType> \{ \textcolor{keyword}{
      enum} \{ value = 1\}; \};
00168 
00169 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} PacketType,\textcolor{keyword}{typename} IndexType>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00170}\hyperlink{struct_eigen_1_1internal_1_1has__nullary__operator_3_01linspaced__op_3_01_scalar_00_01_packet_type_01_4_00_01_index_type_01_4}{00170} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1has__nullary__operator}{has\_nullary\_operator}<\hyperlink{struct_eigen_1_1internal_1_1linspaced__op}{linspaced\_op}<Scalar,
      \hyperlink{struct_eigen_1_1_packet_type}{PacketType}>,IndexType> \{ \textcolor{keyword}{enum} \{ value = 0\}; \};
00171 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} PacketType,\textcolor{keyword}{typename} IndexType>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00172}\hyperlink{struct_eigen_1_1internal_1_1has__unary__operator_3_01linspaced__op_3_01_scalar_00_01_packet_type_01_4_00_01_index_type_01_4}{00172} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1has__unary__operator}{has\_unary\_operator}<\hyperlink{struct_eigen_1_1internal_1_1linspaced__op}{linspaced\_op}<Scalar,
      \hyperlink{struct_eigen_1_1_packet_type}{PacketType}>,IndexType> \{ \textcolor{keyword}{enum} \{ value = 1\}; \};
00173 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} PacketType,\textcolor{keyword}{typename} IndexType>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00174}\hyperlink{struct_eigen_1_1internal_1_1has__binary__operator_3_01linspaced__op_3_01_scalar_00_01_packet_type_01_4_00_01_index_type_01_4}{00174} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1has__binary__operator}{has\_binary\_operator}<\hyperlink{struct_eigen_1_1internal_1_1linspaced__op}{linspaced\_op}<Scalar,
      \hyperlink{struct_eigen_1_1_packet_type}{PacketType}>,IndexType> \{ \textcolor{keyword}{enum} \{ value = 0\}; \};
00175 
00176 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} IndexType>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00177}\hyperlink{struct_eigen_1_1internal_1_1has__nullary__operator_3_01scalar__random__op_3_01_scalar_01_4_00_01_index_type_01_4}{00177} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1has__nullary__operator}{has\_nullary\_operator}<\hyperlink{struct_eigen_1_1internal_1_1scalar__random__op}{scalar\_random\_op}<Scalar>,IndexType> \{ \textcolor{keyword}{enum} 
      \{ value = 1\}; \};
00178 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} IndexType>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00179}\hyperlink{struct_eigen_1_1internal_1_1has__unary__operator_3_01scalar__random__op_3_01_scalar_01_4_00_01_index_type_01_4}{00179} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1has__unary__operator}{has\_unary\_operator}<\hyperlink{struct_eigen_1_1internal_1_1scalar__random__op}{scalar\_random\_op}<Scalar>,IndexType> \{ \textcolor{keyword}{enum} \{ 
      value = 0\}; \};
00180 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} IndexType>
\Hypertarget{eigen_2_eigen_2src_2_core_2functors_2_nullary_functors_8h_source_l00181}\hyperlink{struct_eigen_1_1internal_1_1has__binary__operator_3_01scalar__random__op_3_01_scalar_01_4_00_01_index_type_01_4}{00181} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1has__binary__operator}{has\_binary\_operator}<\hyperlink{struct_eigen_1_1internal_1_1scalar__random__op}{scalar\_random\_op}<Scalar>,IndexType> \{ \textcolor{keyword}{enum} \{ 
      value = 0\}; \};
00182 \textcolor{preprocessor}{#endif}
00183 
00184 \} \textcolor{comment}{// end namespace internal}
00185 
00186 \} \textcolor{comment}{// end namespace Eigen}
00187 
00188 \textcolor{preprocessor}{#endif // EIGEN\_NULLARY\_FUNCTORS\_H}
\end{DoxyCode}
