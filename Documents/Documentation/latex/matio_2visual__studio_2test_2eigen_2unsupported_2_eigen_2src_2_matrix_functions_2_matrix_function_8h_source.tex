\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_function_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+Matrix\+Functions/\+Matrix\+Function.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_function_8h_source}\index{Matrix\+Function.\+h@{Matrix\+Function.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2011, 2013 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_MATRIX\_FUNCTION}
00011 \textcolor{preprocessor}{#define EIGEN\_MATRIX\_FUNCTION}
00012 
00013 \textcolor{preprocessor}{#include "StemFunction.h"}
00014 
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00017 
00018 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00019 
00021 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{float} matrix\_function\_separation = 0.1f;
00022 
00029 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00030 \textcolor{keyword}{class }MatrixFunctionAtomic 
00031 \{
00032   \textcolor{keyword}{public}:
00033 
00034     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00035     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} stem\_function<Scalar>::type StemFunction;
00036 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_function_8h_source_l00040}\hyperlink{class_eigen_1_1internal_1_1_matrix_function_atomic_a0786bb0349fe5ca5f8df13db7e21e882}{00040}     \hyperlink{class_eigen_1_1internal_1_1_matrix_function_atomic_a0786bb0349fe5ca5f8df13db7e21e882}{MatrixFunctionAtomic}(StemFunction f) : m\_f(f) \{ \}
00041 
00046     MatrixType \hyperlink{class_eigen_1_1internal_1_1_matrix_function_atomic_a704ccdc87d66cb6f93d16e0a0b9e8acf}{compute}(\textcolor{keyword}{const} MatrixType& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A});
00047 
00048   \textcolor{keyword}{private}:
00049     StemFunction* m\_f;
00050 \};
00051 
00052 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00053 \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename MatrixType::Scalar>::Real} 
      matrix\_function\_compute\_mu(\textcolor{keyword}{const} MatrixType& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A})
00054 \{
00055   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1plain__col__type}{plain\_col\_type<MatrixType>::type} 
      \hyperlink{struct_vector_type}{VectorType};
00056   \textcolor{keyword}{typename} MatrixType::Index rows = A.rows();
00057   \textcolor{keyword}{const} MatrixType N = MatrixType::Identity(rows, rows) - A;
00058   VectorType e = VectorType::Ones(rows);
00059   N.template triangularView<Upper>().solveInPlace(e);
00060   \textcolor{keywordflow}{return} e.cwiseAbs().maxCoeff();
00061 \}
00062 
00063 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00064 MatrixType \hyperlink{class_eigen_1_1internal_1_1_matrix_function_atomic_a704ccdc87d66cb6f93d16e0a0b9e8acf}{MatrixFunctionAtomic<MatrixType>::compute}(\textcolor{keyword}{const} 
      MatrixType& A)
00065 \{
00066   \textcolor{comment}{// TODO: Use that A is upper triangular}
00067   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00068   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00069   Index rows = A.rows();
00070   Scalar avgEival = A.trace() / Scalar(RealScalar(rows));
00071   MatrixType Ashifted = A - avgEival * MatrixType::Identity(rows, rows);
00072   RealScalar mu = matrix\_function\_compute\_mu(Ashifted);
00073   MatrixType F = m\_f(avgEival, 0) * MatrixType::Identity(rows, rows);
00074   MatrixType P = Ashifted;
00075   MatrixType Fincr;
00076   \textcolor{keywordflow}{for} (Index s = 1; s < 1.1 * rows + 10; s++) \{ \textcolor{comment}{// upper limit is fairly arbitrary}
00077     Fincr = m\_f(avgEival, static\_cast<int>(s)) * P;
00078     F += Fincr;
00079     P = Scalar(RealScalar(1.0/(s + 1))) * P * Ashifted;
00080 
00081     \textcolor{comment}{// test whether Taylor series converged}
00082     \textcolor{keyword}{const} RealScalar F\_norm = F.cwiseAbs().rowwise().sum().maxCoeff();
00083     \textcolor{keyword}{const} RealScalar Fincr\_norm = Fincr.cwiseAbs().rowwise().sum().maxCoeff();
00084     \textcolor{keywordflow}{if} (Fincr\_norm < \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}() * F\_norm) \{
00085       RealScalar delta = 0;
00086       RealScalar rfactorial = 1;
00087       \textcolor{keywordflow}{for} (Index r = 0; r < rows; r++) \{
00088         RealScalar mx = 0;
00089         \textcolor{keywordflow}{for} (Index i = 0; i < rows; i++)
00090           mx = (std::max)(mx, std::abs(m\_f(Ashifted(i, i) + avgEival, static\_cast<int>(s+r))));
00091         \textcolor{keywordflow}{if} (r != 0)
00092           rfactorial *= RealScalar(r);
00093         delta = (std::max)(delta, mx / rfactorial);
00094       \}
00095       \textcolor{keyword}{const} RealScalar P\_norm = P.cwiseAbs().rowwise().sum().maxCoeff();
00096       \textcolor{keywordflow}{if} (mu * delta * P\_norm < \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}() * F\_norm) \textcolor{comment}{// series
       converged}
00097         \textcolor{keywordflow}{break};
00098     \}
00099   \}
00100   \textcolor{keywordflow}{return} F;
00101 \}
00102 
00108 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} ListOfClusters>
00109 \textcolor{keyword}{typename} ListOfClusters::iterator \hyperlink{namespace_eigen_1_1internal_af9cdbae9f4f166fae876c54b97c0f2bb}{matrix\_function\_find\_cluster}(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} key, ListOfClusters& clusters)
00110 \{
00111   \textcolor{keyword}{typename} std::list<Index>::iterator j;
00112   \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} ListOfClusters::iterator i = clusters.begin(); i != clusters.end(); ++i) \{
00113     j = std::find(i->begin(), i->end(), key);
00114     \textcolor{keywordflow}{if} (j != i->end())
00115       \textcolor{keywordflow}{return} i;
00116   \}
00117   \textcolor{keywordflow}{return} clusters.end();
00118 \}
00119 
00131 \textcolor{keyword}{template} <\textcolor{keyword}{typename} EivalsType, \textcolor{keyword}{typename} Cluster>
00132 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a9291a6ab4fe0ad1346049a8f2feddeaa}{matrix\_function\_partition\_eigenvalues}(\textcolor{keyword}{const} EivalsType& eivals, 
      std::list<Cluster>& clusters)
00133 \{
00134   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} EivalsType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00135   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} EivalsType::RealScalar RealScalar;
00136   \textcolor{keywordflow}{for} (Index i=0; i<eivals.rows(); ++i) \{
00137     \textcolor{comment}{// Find cluster containing i-th ei'val, adding a new cluster if necessary}
00138     \textcolor{keyword}{typename} std::list<Cluster>::iterator qi = \hyperlink{namespace_eigen_1_1internal_af9cdbae9f4f166fae876c54b97c0f2bb}{matrix\_function\_find\_cluster}(i, 
      clusters);
00139     \textcolor{keywordflow}{if} (qi == clusters.end()) \{
00140       Cluster l;
00141       l.push\_back(i);
00142       clusters.push\_back(l);
00143       qi = clusters.end();
00144       --qi;
00145     \}
00146 
00147     \textcolor{comment}{// Look for other element to add to the set}
00148     \textcolor{keywordflow}{for} (Index j=i+1; j<eivals.rows(); ++j) \{
00149       \textcolor{keywordflow}{if} (abs(eivals(j) - eivals(i)) <= RealScalar(matrix\_function\_separation)
00150           && std::find(qi->begin(), qi->end(), j) == qi->end()) \{
00151         \textcolor{keyword}{typename} std::list<Cluster>::iterator qj = \hyperlink{namespace_eigen_1_1internal_af9cdbae9f4f166fae876c54b97c0f2bb}{matrix\_function\_find\_cluster}
      (j, clusters);
00152         \textcolor{keywordflow}{if} (qj == clusters.end()) \{
00153           qi->push\_back(j);
00154         \} \textcolor{keywordflow}{else} \{
00155           qi->insert(qi->end(), qj->begin(), qj->end());
00156           clusters.erase(qj);
00157         \}
00158       \}
00159     \}
00160   \}
00161 \}
00162 
00164 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ListOfClusters, \textcolor{keyword}{typename} Index>
00165 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a1073ba7ac499827baa04c814e4251326}{matrix\_function\_compute\_cluster\_size}(\textcolor{keyword}{const} ListOfClusters& 
      clusters, \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Index, Dynamic, 1>}& clusterSize)
00166 \{
00167   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} numClusters = \textcolor{keyword}{static\_cast<}\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}\textcolor{keyword}{>}(clusters.size());
00168   clusterSize.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}(numClusters);
00169   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} clusterIndex = 0;
00170   \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} ListOfClusters::const\_iterator cluster = clusters.begin(); cluster != clusters.end(); ++
      cluster) \{
00171     clusterSize[clusterIndex] = cluster->size();
00172     ++clusterIndex;
00173   \}
00174 \}
00175 
00177 \textcolor{keyword}{template} <\textcolor{keyword}{typename} VectorType>
00178 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a2144f635d30028a25e7eb3510c315ad3}{matrix\_function\_compute\_block\_start}(\textcolor{keyword}{const} 
      \hyperlink{struct_vector_type}{VectorType}& clusterSize, \hyperlink{struct_vector_type}{VectorType}& blockStart)
00179 \{
00180   blockStart.resize(clusterSize.rows());
00181   blockStart(0) = 0;
00182   \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} VectorType::Index i = 1; i < clusterSize.rows(); i++) \{
00183     blockStart(i) = blockStart(i-1) + clusterSize(i-1);
00184   \}
00185 \}
00186 
00188 \textcolor{keyword}{template} <\textcolor{keyword}{typename} EivalsType, \textcolor{keyword}{typename} ListOfClusters, \textcolor{keyword}{typename} VectorType>
00189 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_ade67364a006320cd7103f0f3366def09}{matrix\_function\_compute\_map}(\textcolor{keyword}{const} EivalsType& eivals, \textcolor{keyword}{const} ListOfClusters&
       clusters, \hyperlink{struct_vector_type}{VectorType}& eivalToCluster)
00190 \{
00191   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} EivalsType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00192   eivalToCluster.resize(eivals.rows());
00193   Index clusterIndex = 0;
00194   \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} ListOfClusters::const\_iterator cluster = clusters.begin(); cluster != clusters.end(); ++
      cluster) \{
00195     \textcolor{keywordflow}{for} (Index i = 0; i < eivals.rows(); ++i) \{
00196       \textcolor{keywordflow}{if} (std::find(cluster->begin(), cluster->end(), i) != cluster->end()) \{
00197         eivalToCluster[i] = clusterIndex;
00198       \}
00199     \}
00200     ++clusterIndex;
00201   \}
00202 \}
00203 
00205 \textcolor{keyword}{template} <\textcolor{keyword}{typename} DynVectorType, \textcolor{keyword}{typename} VectorType>
00206 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a0434fe5b0ec47e69b8e351ef9e131bcd}{matrix\_function\_compute\_permutation}(\textcolor{keyword}{const} DynVectorType& blockStart
      , \textcolor{keyword}{const} DynVectorType& eivalToCluster, \hyperlink{struct_vector_type}{VectorType}& permutation)
00207 \{
00208   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00209   DynVectorType indexNextEntry = blockStart;
00210   permutation.resize(eivalToCluster.rows());
00211   \textcolor{keywordflow}{for} (Index i = 0; i < eivalToCluster.rows(); i++) \{
00212     Index cluster = eivalToCluster[i];
00213     permutation[i] = indexNextEntry[cluster];
00214     ++indexNextEntry[cluster];
00215   \}
00216 \}  
00217 
00219 \textcolor{keyword}{template} <\textcolor{keyword}{typename} VectorType, \textcolor{keyword}{typename} MatrixType>
00220 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a59cacdc2f9b480da246258bc9399aa2c}{matrix\_function\_permute\_schur}(\hyperlink{struct_vector_type}{VectorType}& permutation, 
      MatrixType& U, MatrixType& \hyperlink{group___sparse_core___module}{T})
00221 \{
00222   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00223   \textcolor{keywordflow}{for} (Index i = 0; i < permutation.rows() - 1; i++) \{
00224     Index j;
00225     \textcolor{keywordflow}{for} (j = i; j < permutation.rows(); j++) \{
00226       \textcolor{keywordflow}{if} (permutation(j) == i) \textcolor{keywordflow}{break};
00227     \}
00228     eigen\_assert(permutation(j) == i);
00229     \textcolor{keywordflow}{for} (Index k = j-1; k >= i; k--) \{
00230       \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<typename MatrixType::Scalar>} rotation;
00231       rotation.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(T(k, k+1), T(k+1, k+1) - T(k, k));
00232       T.applyOnTheLeft(k, k+1, rotation.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00233       T.applyOnTheRight(k, k+1, rotation);
00234       U.applyOnTheRight(k, k+1, rotation);
00235       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(permutation.coeffRef(k), permutation.coeffRef(k+1));
00236     \}
00237   \}
00238 \}
00239 
00246 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} AtomicType, \textcolor{keyword}{typename} VectorType>
00247 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a53e617df189868a791e44d2c4e94403f}{matrix\_function\_compute\_block\_atomic}(\textcolor{keyword}{const} MatrixType& T, 
      AtomicType& atomic, \textcolor{keyword}{const} \hyperlink{struct_vector_type}{VectorType}& blockStart, \textcolor{keyword}{const} \hyperlink{struct_vector_type}{VectorType}& clusterSize, MatrixType& fT)
00248 \{ 
00249   fT.setZero(T.rows(), T.cols());
00250   \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} VectorType::Index i = 0; i < clusterSize.rows(); ++i) \{
00251     fT.block(blockStart(i), blockStart(i), clusterSize(i), clusterSize(i))
00252       = atomic.compute(T.block(blockStart(i), blockStart(i), clusterSize(i), clusterSize(i)));
00253   \}
00254 \}
00255 
00278 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00279 MatrixType \hyperlink{namespace_eigen_1_1internal_a9f7e5b9803071057e7ed4e887da4a1bb}{matrix\_function\_solve\_triangular\_sylvester}(\textcolor{keyword}{const} 
      MatrixType& A, \textcolor{keyword}{const} MatrixType& \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, \textcolor{keyword}{const} MatrixType& \hyperlink{group___core___module}{C})
00280 \{
00281   eigen\_assert(A.rows() == A.cols());
00282   eigen\_assert(A.isUpperTriangular());
00283   eigen\_assert(B.rows() == B.cols());
00284   eigen\_assert(B.isUpperTriangular());
00285   eigen\_assert(C.rows() == A.rows());
00286   eigen\_assert(C.cols() == B.rows());
00287 
00288   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00289   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00290 
00291   Index m = A.rows();
00292   Index n = B.rows();
00293   MatrixType X(m, n);
00294 
00295   \textcolor{keywordflow}{for} (Index i = m - 1; i >= 0; --i) \{
00296     \textcolor{keywordflow}{for} (Index j = 0; j < n; ++j) \{
00297 
00298       \textcolor{comment}{// Compute AX = \(\backslash\)sum\_\{k=i+1\}^m A\_\{ik\} X\_\{kj\}}
00299       Scalar AX;
00300       \textcolor{keywordflow}{if} (i == m - 1) \{
00301     AX = 0; 
00302       \} \textcolor{keywordflow}{else} \{
00303     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,1,1>} AXmatrix = A.row(i).tail(m-1-i) * X.col(j).tail(m-1-i);
00304     AX = AXmatrix(0,0);
00305       \}
00306 
00307       \textcolor{comment}{// Compute XB = \(\backslash\)sum\_\{k=1\}^\{j-1\} X\_\{ik\} B\_\{kj\}}
00308       Scalar XB;
00309       \textcolor{keywordflow}{if} (j == 0) \{
00310     XB = 0; 
00311       \} \textcolor{keywordflow}{else} \{
00312     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,1,1>} XBmatrix = X.row(i).head(j) * B.col(j).head(j);
00313     XB = XBmatrix(0,0);
00314       \}
00315 
00316       X(i,j) = (C(i,j) - AX - XB) / (A(i,i) + B(j,j));
00317     \}
00318   \}
00319   \textcolor{keywordflow}{return} X;
00320 \}
00321 
00328 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} VectorType>
00329 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a8ff76c47bde59d8af688e5925bed8f17}{matrix\_function\_compute\_above\_diagonal}(\textcolor{keyword}{const} MatrixType& T, \textcolor{keyword}{
      const} \hyperlink{struct_vector_type}{VectorType}& blockStart, \textcolor{keyword}{const} \hyperlink{struct_vector_type}{VectorType}& clusterSize, MatrixType& fT)
00330 \{ 
00331   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<MatrixType>} Traits;
00332   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00333   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00334   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} RowsAtCompileTime = Traits::RowsAtCompileTime;
00335   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} ColsAtCompileTime = Traits::ColsAtCompileTime;
00336   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Options = MatrixType::Options;
00337   \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, Dynamic, Options, RowsAtCompileTime, ColsAtCompileTime>}
       DynMatrixType;
00338 
00339   \textcolor{keywordflow}{for} (Index k = 1; k < clusterSize.rows(); k++) \{
00340     \textcolor{keywordflow}{for} (Index i = 0; i < clusterSize.rows() - k; i++) \{
00341       \textcolor{comment}{// compute (i, i+k) block}
00342       DynMatrixType A = T.block(blockStart(i), blockStart(i), clusterSize(i), clusterSize(i));
00343       DynMatrixType B = -T.block(blockStart(i+k), blockStart(i+k), clusterSize(i+k), clusterSize(i+k));
00344       DynMatrixType C = fT.block(blockStart(i), blockStart(i), clusterSize(i), clusterSize(i))
00345         * T.block(blockStart(i), blockStart(i+k), clusterSize(i), clusterSize(i+k));
00346       C -= T.block(blockStart(i), blockStart(i+k), clusterSize(i), clusterSize(i+k))
00347         * fT.block(blockStart(i+k), blockStart(i+k), clusterSize(i+k), clusterSize(i+k));
00348       \textcolor{keywordflow}{for} (Index m = i + 1; m < i + k; m++) \{
00349         C += fT.block(blockStart(i), blockStart(m), clusterSize(i), clusterSize(m))
00350           * T.block(blockStart(m), blockStart(i+k), clusterSize(m), clusterSize(i+k));
00351         C -= T.block(blockStart(i), blockStart(m), clusterSize(i), clusterSize(m))
00352           * fT.block(blockStart(m), blockStart(i+k), clusterSize(m), clusterSize(i+k));
00353       \}
00354       fT.block(blockStart(i), blockStart(i+k), clusterSize(i), clusterSize(i+k))
00355         = \hyperlink{namespace_eigen_1_1internal_a9f7e5b9803071057e7ed4e887da4a1bb}{matrix\_function\_solve\_triangular\_sylvester}(A, B, C);
00356     \}
00357   \}
00358 \}
00359 
00375 template <typename MatrixType, int IsComplex = NumTraits<typename internal::traits<MatrixType>::Scalar>
      ::IsComplex>
00376 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1matrix__function__compute}{matrix\_function\_compute}
00377 \{  
00388     \textcolor{keyword}{template} <\textcolor{keyword}{typename} AtomicType, \textcolor{keyword}{typename} ResultType> 
00389     \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} MatrixType& A, AtomicType& atomic, ResultType &result);    
00390 \};
00391 
00398 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00399 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1matrix__function__compute}{matrix\_function\_compute}<MatrixType, 0>
00400 \{  
00401   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatA, \textcolor{keyword}{typename} AtomicType, \textcolor{keyword}{typename} ResultType>
00402   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} MatA& A, AtomicType& atomic, ResultType &result)
00403   \{
00404     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<MatrixType>} Traits;
00405     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Traits::Scalar Scalar;
00406     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Rows = Traits::RowsAtCompileTime, Cols = Traits::ColsAtCompileTime;
00407     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} MaxRows = Traits::MaxRowsAtCompileTime, MaxCols = Traits::MaxColsAtCompileTime;
00408 
00409     \textcolor{keyword}{typedef} std::complex<Scalar> ComplexScalar;
00410     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<ComplexScalar, Rows, Cols, 0, MaxRows, MaxCols>}
       ComplexMatrix;
00411 
00412     ComplexMatrix CA = A.template cast<ComplexScalar>();
00413     ComplexMatrix Cresult;
00414     \hyperlink{struct_eigen_1_1internal_1_1matrix__function__compute_a55a328773f5254d0cd29ac699bc2634f}{matrix\_function\_compute<ComplexMatrix>::run}(CA, atomic, 
      Cresult);
00415     result = Cresult.real();
00416   \}
00417 \};
00418 
00422 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00423 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1matrix__function__compute}{matrix\_function\_compute}<MatrixType, 1>
00424 \{
00425   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatA, \textcolor{keyword}{typename} AtomicType, \textcolor{keyword}{typename} ResultType>
00426   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} MatA& A, AtomicType& atomic, ResultType &result)
00427   \{
00428     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<MatrixType>} Traits;
00429     
00430     \textcolor{comment}{// compute Schur decomposition of A}
00431     \textcolor{keyword}{const} \hyperlink{group___eigenvalues___module}{ComplexSchur<MatrixType>} schurOfA(A);  
00432     MatrixType T = schurOfA.\hyperlink{group___eigenvalues___module_add3ab5ed83f7f2f06b79fa910a2d5684}{matrixT}();
00433     MatrixType U = schurOfA.\hyperlink{group___eigenvalues___module_afed8177cf9836f032d42bdb6c6bc6e01}{matrixU}();
00434 
00435     \textcolor{comment}{// partition eigenvalues into clusters of ei'vals "close" to each other}
00436     std::list<std::list<Index> > clusters; 
00437     \hyperlink{namespace_eigen_1_1internal_a9291a6ab4fe0ad1346049a8f2feddeaa}{matrix\_function\_partition\_eigenvalues}(T.diagonal(), clusters);
00438 
00439     \textcolor{comment}{// compute size of each cluster}
00440     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Index, Dynamic, 1>} clusterSize;
00441     \hyperlink{namespace_eigen_1_1internal_a1073ba7ac499827baa04c814e4251326}{matrix\_function\_compute\_cluster\_size}(clusters, clusterSize);
00442 
00443     \textcolor{comment}{// blockStart[i] is row index at which block corresponding to i-th cluster starts }
00444     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Index, Dynamic, 1>} blockStart; 
00445     \hyperlink{namespace_eigen_1_1internal_a2144f635d30028a25e7eb3510c315ad3}{matrix\_function\_compute\_block\_start}(clusterSize, blockStart);
00446 
00447     \textcolor{comment}{// compute map so that eivalToCluster[i] = j means that i-th ei'val is in j-th cluster }
00448     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Index, Dynamic, 1>} eivalToCluster;
00449     \hyperlink{namespace_eigen_1_1internal_ade67364a006320cd7103f0f3366def09}{matrix\_function\_compute\_map}(T.diagonal(), clusters, eivalToCluster);
00450 
00451     \textcolor{comment}{// compute permutation which groups ei'vals in same cluster together }
00452     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Index, Traits::RowsAtCompileTime, 1>} permutation;
00453     \hyperlink{namespace_eigen_1_1internal_a0434fe5b0ec47e69b8e351ef9e131bcd}{matrix\_function\_compute\_permutation}(blockStart, eivalToCluster, 
      permutation);
00454 
00455     \textcolor{comment}{// permute Schur decomposition}
00456     \hyperlink{namespace_eigen_1_1internal_a59cacdc2f9b480da246258bc9399aa2c}{matrix\_function\_permute\_schur}(permutation, U, T);
00457 
00458     \textcolor{comment}{// compute result}
00459     MatrixType fT; \textcolor{comment}{// matrix function applied to T}
00460     \hyperlink{namespace_eigen_1_1internal_a53e617df189868a791e44d2c4e94403f}{matrix\_function\_compute\_block\_atomic}(T, atomic, blockStart, 
      clusterSize, fT);
00461     \hyperlink{namespace_eigen_1_1internal_a8ff76c47bde59d8af688e5925bed8f17}{matrix\_function\_compute\_above\_diagonal}(T, blockStart, clusterSize
      , fT);
00462     result = U * (fT.template triangularView<Upper>() * U.adjoint());
00463   \}
00464 \};
00465 
00466 \} \textcolor{comment}{// end of namespace internal}
00467 
00478 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_matrix_function_return_value}{MatrixFunctionReturnValue}
00479 : \textcolor{keyword}{public} \hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue}<MatrixFunctionReturnValue<Derived> >
00480 \{
00481   \textcolor{keyword}{public}:
00482     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00483     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00484     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1stem__function}{internal::stem\_function<Scalar>::type} 
      StemFunction;
00485 
00486   \textcolor{keyword}{protected}:
00487     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::ref\_selector<Derived>::type} 
      DerivedNested;
00488 
00489   \textcolor{keyword}{public}:
00490 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_function_8h_source_l00496}\hyperlink{class_eigen_1_1_matrix_function_return_value_af193d7a3e1b4e65dc70e64eb4bc8e17f}{00496}     \hyperlink{class_eigen_1_1_matrix_function_return_value_af193d7a3e1b4e65dc70e64eb4bc8e17f}{MatrixFunctionReturnValue}(\textcolor{keyword}{const} Derived& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, StemFunction f) : m\_A(A), m\_f(f) 
      \{ \}
00497 
00502     \textcolor{keyword}{template} <\textcolor{keyword}{typename} ResultType>
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_function_8h_source_l00503}\hyperlink{class_eigen_1_1_matrix_function_return_value_a202d594ae254e3ea5420ff95d9f03a67}{00503}     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_function_return_value_a202d594ae254e3ea5420ff95d9f03a67}{evalTo}(ResultType& result)\textcolor{keyword}{ const}
00504 \textcolor{keyword}{    }\{
00505       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<Derived, 10>::type} 
      NestedEvalType;
00506       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<NestedEvalType>::type}
       NestedEvalTypeClean;
00507       \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<NestedEvalTypeClean>} Traits;
00508       \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} RowsAtCompileTime = Traits::RowsAtCompileTime;
00509       \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} ColsAtCompileTime = Traits::ColsAtCompileTime;
00510       \textcolor{keyword}{typedef} std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;
00511       \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<ComplexScalar, Dynamic, Dynamic, 0, RowsAtCompileTime, ColsAtCompileTime>}
       DynMatrixType;
00512 
00513       \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1_matrix_function_atomic}{internal::MatrixFunctionAtomic<DynMatrixType>} 
      AtomicType;
00514       AtomicType atomic(m\_f);
00515 
00516       
      \hyperlink{struct_eigen_1_1internal_1_1matrix__function__compute_a55a328773f5254d0cd29ac699bc2634f}{internal::matrix\_function\_compute<typename NestedEvalTypeClean::PlainObject>::run}
      (m\_A, atomic, result);
00517     \}
00518 
00519     Index rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_A.rows(); \}
00520     Index cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_A.cols(); \}
00521 
00522   \textcolor{keyword}{private}:
00523     \textcolor{keyword}{const} DerivedNested m\_A;
00524     StemFunction *m\_f;
00525 \};
00526 
00527 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00528 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00529 \textcolor{keyword}{struct }traits<MatrixFunctionReturnValue<Derived> >
00530 \{
00531   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::PlainObject ReturnType;
00532 \};
00533 \}
00534 
00535 
00536 \textcolor{comment}{/********** MatrixBase methods **********/}
00537 
00538 
00539 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>
00540 \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_matrix_function_return_value}{MatrixFunctionReturnValue<Derived>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>::matrixFunction}(\textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1stem__function}{internal::stem\_function}<\textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Scalar}>::type f)\textcolor{keyword}{ const}
00541 \textcolor{keyword}{}\{
00542   eigen\_assert(rows() == cols());
00543   \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_matrix_function_return_value}{MatrixFunctionReturnValue<Derived>}(derived(), f);
00544 \}
00545 
00546 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>
00547 \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_matrix_function_return_value}{MatrixFunctionReturnValue<Derived>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>::sin}()\textcolor{keyword}{ const}
00548 \textcolor{keyword}{}\{
00549   eigen\_assert(rows() == cols());
00550   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::stem\_function<Scalar>::ComplexScalar ComplexScalar;
00551   \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_matrix_function_return_value}{MatrixFunctionReturnValue<Derived>}(derived(), 
      internal::stem\_function\_sin<ComplexScalar>);
00552 \}
00553 
00554 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>
00555 \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_matrix_function_return_value}{MatrixFunctionReturnValue<Derived>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>::cos}()\textcolor{keyword}{ const}
00556 \textcolor{keyword}{}\{
00557   eigen\_assert(rows() == cols());
00558   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::stem\_function<Scalar>::ComplexScalar ComplexScalar;
00559   \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_matrix_function_return_value}{MatrixFunctionReturnValue<Derived>}(derived(), 
      internal::stem\_function\_cos<ComplexScalar>);
00560 \}
00561 
00562 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>
00563 \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_matrix_function_return_value}{MatrixFunctionReturnValue<Derived>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>::sinh}()\textcolor{keyword}{ const}
00564 \textcolor{keyword}{}\{
00565   eigen\_assert(rows() == cols());
00566   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::stem\_function<Scalar>::ComplexScalar ComplexScalar;
00567   \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_matrix_function_return_value}{MatrixFunctionReturnValue<Derived>}(derived(), 
      internal::stem\_function\_sinh<ComplexScalar>);
00568 \}
00569 
00570 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>
00571 \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_matrix_function_return_value}{MatrixFunctionReturnValue<Derived>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>::cosh}()\textcolor{keyword}{ const}
00572 \textcolor{keyword}{}\{
00573   eigen\_assert(rows() == cols());
00574   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::stem\_function<Scalar>::ComplexScalar ComplexScalar;
00575   \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_matrix_function_return_value}{MatrixFunctionReturnValue<Derived>}(derived(), 
      internal::stem\_function\_cosh<ComplexScalar>);
00576 \}
00577 
00578 \} \textcolor{comment}{// end namespace Eigen}
00579 
00580 \textcolor{preprocessor}{#endif // EIGEN\_MATRIX\_FUNCTION}
\end{DoxyCode}
