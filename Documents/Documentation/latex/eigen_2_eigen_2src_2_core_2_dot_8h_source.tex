\hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source}{}\section{eigen/\+Eigen/src/\+Core/\+Dot.h}
\label{eigen_2_eigen_2src_2_core_2_dot_8h_source}\index{Dot.\+h@{Dot.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2006-2008, 2010 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_DOT\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_DOT\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{comment}{// helper function for dot(). The problem is that if we put that in the body of dot(), then upon calling
       dot}
00018 \textcolor{comment}{// with mismatched types, the compiler emits errors about failing to instantiate cwiseProduct BEFORE}
00019 \textcolor{comment}{// looking at the static assertions. Thus this is a trick to get better compile errors.}
00020 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \textcolor{keyword}{typename} U,
00021 \textcolor{comment}{// the NeedToTranspose condition here is taken straight from Assign.h}
00022          \textcolor{keywordtype}{bool} NeedToTranspose = T::IsVectorAtCompileTime
00023                 && U::IsVectorAtCompileTime
00024                 && ((int(T::RowsAtCompileTime) == 1 && int(U::ColsAtCompileTime) == 1)
00025                       |  \textcolor{comment}{// FIXME | instead of || to please GCC 4.4.0 stupid warning "suggest parentheses
       around &&".}
00026                          \textcolor{comment}{// revert to || as soon as not needed anymore.}
00027                     (\textcolor{keywordtype}{int}(T::ColsAtCompileTime) == 1 && int(U::RowsAtCompileTime) == 1))
00028 >
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00029}\hyperlink{struct_eigen_1_1internal_1_1dot__nocheck}{00029} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1dot__nocheck}{dot\_nocheck}
00030 \{
00031   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1scalar__conj__product__op}{scalar\_conj\_product\_op<typename traits<T>::Scalar}
      ,\textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<U>::Scalar}> \hyperlink{struct_eigen_1_1internal_1_1scalar__conj__product__op}{conj\_prod};
00032   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conj\_prod::result\_type ResScalar;
00033   EIGEN\_DEVICE\_FUNC
00034   \textcolor{keyword}{static} \textcolor{keyword}{inline} ResScalar run(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<T>}& a, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<U>}& b)
00035   \{
00036     \textcolor{keywordflow}{return} a.template binaryExpr<conj\_prod>(b).sum();
00037   \}
00038 \};
00039 
00040 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00041}\hyperlink{struct_eigen_1_1internal_1_1dot__nocheck_3_01_t_00_01_u_00_01true_01_4}{00041} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1dot__nocheck}{dot\_nocheck}<\hyperlink{group___sparse_core___module}{T}, U, true>
00042 \{
00043   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1scalar__conj__product__op}{scalar\_conj\_product\_op<typename traits<T>::Scalar}
      ,\textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<U>::Scalar}> \hyperlink{struct_eigen_1_1internal_1_1scalar__conj__product__op}{conj\_prod};
00044   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conj\_prod::result\_type ResScalar;
00045   EIGEN\_DEVICE\_FUNC
00046   \textcolor{keyword}{static} \textcolor{keyword}{inline} ResScalar run(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<T>}& a, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<U>}& b)
00047   \{
00048     \textcolor{keywordflow}{return} a.\hyperlink{group___core___module_ac8952c19644a4ac7e41bea45c19b909c}{transpose}().template binaryExpr<conj\_prod>(b).sum();
00049   \}
00050 \};
00051 
00052 \} \textcolor{comment}{// end namespace internal}
00053 
00065 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00066 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00067 EIGEN\_DEVICE\_FUNC
00068 \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<typename internal::traits<Derived>::Scalar}
      ,\textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<OtherDerived>::Scalar}>::ReturnType
00069 \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>::dot}(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<OtherDerived>}& 
      other)\textcolor{keyword}{ const}
00070 \textcolor{keyword}{}\{
00071   EIGEN\_STATIC\_ASSERT\_VECTOR\_ONLY(Derived)
00072   EIGEN\_STATIC\_ASSERT\_VECTOR\_ONLY(OtherDerived)
00073   EIGEN\_STATIC\_ASSERT\_SAME\_VECTOR\_SIZE(Derived,OtherDerived)
00074 \textcolor{preprocessor}{#if !(defined(EIGEN\_NO\_STATIC\_ASSERT) && defined(EIGEN\_NO\_DEBUG))}
00075   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1scalar__conj__product__op}{internal::scalar\_conj\_product\_op<Scalar,typename OtherDerived::Scalar>}
       \hyperlink{structfunc}{func};
00076   EIGEN\_CHECK\_BINARY\_COMPATIBILIY(func,Scalar,\textcolor{keyword}{typename} OtherDerived::Scalar);
00077 \textcolor{preprocessor}{#endif}
00078   
00079   eigen\_assert(size() == other.size());
00080 
00081   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1dot__nocheck}{internal::dot\_nocheck<Derived,OtherDerived>::run}(*\textcolor{keyword}{
      this}, other);
00082 \}
00083 
00084 \textcolor{comment}{//---------- implementation of L2 norm and related functions ----------}
00085 
00092 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00093}\hyperlink{group___core___module_a8782faeb21e43908cdce47cec06fba23}{00093} EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename internal::traits<Derived>::Scalar}>
      ::Real \hyperlink{group___core___module_a8782faeb21e43908cdce47cec06fba23}{MatrixBase<Derived>::squaredNorm}()\textcolor{keyword}{ const}
00094 \textcolor{keyword}{}\{
00095   \textcolor{keywordflow}{return} numext::real((*this).cwiseAbs2().sum());
00096 \}
00097 
00104 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00105}\hyperlink{group___core___module_a196c4ec3c8ffdf5bda45d0f617154975}{00105} \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename internal::traits<Derived>::Scalar}
      >::Real \hyperlink{group___core___module_a196c4ec3c8ffdf5bda45d0f617154975}{MatrixBase<Derived>::norm}()\textcolor{keyword}{ const}
00106 \textcolor{keyword}{}\{
00107   \textcolor{keywordflow}{return} numext::sqrt(squaredNorm());
00108 \}
00109 
00119 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00120 \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixBase<Derived>::PlainObject
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00121}\hyperlink{group___core___module_a5cf2fd4c57e59604fd4116158fd34308}{00121} \hyperlink{group___core___module_a5cf2fd4c57e59604fd4116158fd34308}{MatrixBase<Derived>::normalized}()\textcolor{keyword}{ const}
00122 \textcolor{keyword}{}\{
00123   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<Derived,2>::type} \_Nested;
00124   \_Nested n(derived());
00125   RealScalar z = n.squaredNorm();
00126   \textcolor{comment}{// NOTE: after extensive benchmarking, this conditional does not impact performance, at least on recent
       x86 CPU}
00127   \textcolor{keywordflow}{if}(z>RealScalar(0))
00128     \textcolor{keywordflow}{return} n / numext::sqrt(z);
00129   \textcolor{keywordflow}{else}
00130     \textcolor{keywordflow}{return} n;
00131 \}
00132 
00141 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00142}\hyperlink{group___core___module_ad16303c47ba36f7a41ea264cb26bceb6}{00142} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___core___module_ad16303c47ba36f7a41ea264cb26bceb6}{MatrixBase<Derived>::normalize}()
00143 \{
00144   RealScalar z = squaredNorm();
00145   \textcolor{comment}{// NOTE: after extensive benchmarking, this conditional does not impact performance, at least on recent
       x86 CPU}
00146   \textcolor{keywordflow}{if}(z>RealScalar(0))
00147     derived() /= numext::sqrt(z);
00148 \}
00149 
00162 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00163 \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixBase<Derived>::PlainObject
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00164}\hyperlink{group___core___module_a399dca938633b9f8df5ec4beefeccec0}{00164} \hyperlink{group___core___module_a399dca938633b9f8df5ec4beefeccec0}{MatrixBase<Derived>::stableNormalized}()\textcolor{keyword}{ const}
00165 \textcolor{keyword}{}\{
00166   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<Derived,3>::type} \_Nested;
00167   \_Nested n(derived());
00168   RealScalar w = n.cwiseAbs().maxCoeff();
00169   RealScalar z = (n/w).squaredNorm();
00170   \textcolor{keywordflow}{if}(z>RealScalar(0))
00171     \textcolor{keywordflow}{return} n / (numext::sqrt(z)*w);
00172   \textcolor{keywordflow}{else}
00173     \textcolor{keywordflow}{return} n;
00174 \}
00175 
00187 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00188}\hyperlink{group___core___module_a0b1443fa322615379557ade3399a3c3c}{00188} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___core___module_a0b1443fa322615379557ade3399a3c3c}{MatrixBase<Derived>::stableNormalize}()
00189 \{
00190   RealScalar w = cwiseAbs().maxCoeff();
00191   RealScalar z = (derived()/w).squaredNorm();
00192   \textcolor{keywordflow}{if}(z>RealScalar(0))
00193     derived() /= numext::sqrt(z)*w;
00194 \}
00195 
00196 \textcolor{comment}{//---------- implementation of other norms ----------}
00197 
00198 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00199 
00200 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keywordtype}{int} p>
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00201}\hyperlink{struct_eigen_1_1internal_1_1lp_norm__selector}{00201} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1lp_norm__selector}{lpNorm\_selector}
00202 \{
00203   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename traits<Derived>::Scalar}>
      ::Real \hyperlink{group___sparse_core___module}{RealScalar};
00204   EIGEN\_DEVICE\_FUNC
00205   \textcolor{keyword}{static} \textcolor{keyword}{inline} RealScalar run(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& m)
00206   \{
00207     EIGEN\_USING\_STD\_MATH(pow)
00208     \textcolor{keywordflow}{return} pow(m.\hyperlink{group___core___module_a8f2dbd5d9573c79c5dd356ddb29a0ee9}{cwiseAbs}().array().pow(p).sum(), RealScalar(1)/p);
00209   \}
00210 \};
00211 
00212 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00213}\hyperlink{struct_eigen_1_1internal_1_1lp_norm__selector_3_01_derived_00_011_01_4}{00213} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1lp_norm__selector}{lpNorm\_selector}<Derived, 1>
00214 \{
00215   EIGEN\_DEVICE\_FUNC
00216   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename traits<Derived>::Scalar}
      >::Real run(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& m)
00217   \{
00218     \textcolor{keywordflow}{return} m.\hyperlink{group___core___module_a8f2dbd5d9573c79c5dd356ddb29a0ee9}{cwiseAbs}().sum();
00219   \}
00220 \};
00221 
00222 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00223}\hyperlink{struct_eigen_1_1internal_1_1lp_norm__selector_3_01_derived_00_012_01_4}{00223} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1lp_norm__selector}{lpNorm\_selector}<Derived, 2>
00224 \{
00225   EIGEN\_DEVICE\_FUNC
00226   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename traits<Derived>::Scalar}
      >::Real run(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& m)
00227   \{
00228     \textcolor{keywordflow}{return} m.\hyperlink{group___core___module_a196c4ec3c8ffdf5bda45d0f617154975}{norm}();
00229   \}
00230 \};
00231 
00232 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00233}\hyperlink{struct_eigen_1_1internal_1_1lp_norm__selector_3_01_derived_00_01_infinity_01_4}{00233} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1lp_norm__selector}{lpNorm\_selector}<Derived, \hyperlink{namespace_eigen_a7951593b031e13d90223c83d022ce99e}{Infinity}>
00234 \{
00235   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename traits<Derived>::Scalar}>
      ::Real \hyperlink{group___sparse_core___module}{RealScalar};
00236   EIGEN\_DEVICE\_FUNC
00237   \textcolor{keyword}{static} \textcolor{keyword}{inline} RealScalar run(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& m)
00238   \{
00239     \textcolor{keywordflow}{if}(Derived::SizeAtCompileTime==0 || (Derived::SizeAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} && m.size()==0))
00240       \textcolor{keywordflow}{return} RealScalar(0);
00241     \textcolor{keywordflow}{return} m.\hyperlink{group___core___module_a8f2dbd5d9573c79c5dd356ddb29a0ee9}{cwiseAbs}().maxCoeff();
00242   \}
00243 \};
00244 
00245 \} \textcolor{comment}{// end namespace internal}
00246 
00257 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00258 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} p>
00259 \textcolor{preprocessor}{#ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00260 \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename internal::traits<Derived>::Scalar}
      >::Real
00261 \textcolor{preprocessor}{#else}
00262 MatrixBase<Derived>::RealScalar
00263 \textcolor{preprocessor}{#endif}
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00264}\hyperlink{group___core___module_aca6bcf9d89ffab92d572929b151bd8a2}{00264} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>::lpNorm}()\textcolor{keyword}{ const}
00265 \textcolor{keyword}{}\{
00266   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1lp_norm__selector}{internal::lpNorm\_selector<Derived, p>::run}(*\textcolor{keyword}{this});
00267 \}
00268 
00269 \textcolor{comment}{//---------- implementation of isOrthogonal / isUnitary ----------}
00270 
00277 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00278 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00279 \textcolor{keywordtype}{bool} \hyperlink{group___core___module_aefdc8e4e4c156fdd79a21479e75dcd8a}{MatrixBase<Derived>::isOrthogonal}
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00280}\hyperlink{group___core___module_aefdc8e4e4c156fdd79a21479e75dcd8a}{00280} (\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<OtherDerived>}& other, \textcolor{keyword}{const} RealScalar& prec) \textcolor{keyword}{const}
00281 \{
00282   \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<Derived,2>::type} nested(derived());
00283   \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<OtherDerived,2>::type} 
      otherNested(other.derived());
00284   \textcolor{keywordflow}{return} numext::abs2(nested.dot(otherNested)) <= prec * prec * nested.squaredNorm() * otherNested.
      squaredNorm();
00285 \}
00286 
00298 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2_eigen_2src_2_core_2_dot_8h_source_l00299}\hyperlink{group___core___module_a8a7ee34ce202cac3eeea9cf20c9e4833}{00299} \textcolor{keywordtype}{bool} \hyperlink{group___core___module_a8a7ee34ce202cac3eeea9cf20c9e4833}{MatrixBase<Derived>::isUnitary}(\textcolor{keyword}{const} RealScalar& prec)\textcolor{keyword}{ const}
00300 \textcolor{keyword}{}\{
00301   \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<Derived,1>::type} \textcolor{keyword}{self}(derived());
00302   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < cols(); ++i)
00303   \{
00304     \textcolor{keywordflow}{if}(!internal::isApprox(\textcolor{keyword}{self}.col(i).squaredNorm(), static\_cast<RealScalar>(1), prec))
00305       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00306     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < i; ++j)
00307       \textcolor{keywordflow}{if}(!internal::isMuchSmallerThan(\textcolor{keyword}{self}.col(i).dot(\textcolor{keyword}{self}.col(j)), static\_cast<Scalar>(1), prec))
00308         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00309   \}
00310   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00311 \}
00312 
00313 \} \textcolor{comment}{// end namespace Eigen}
00314 
00315 \textcolor{preprocessor}{#endif // EIGEN\_DOT\_H}
\end{DoxyCode}
