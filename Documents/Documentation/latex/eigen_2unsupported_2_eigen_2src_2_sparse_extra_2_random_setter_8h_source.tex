\hypertarget{eigen_2unsupported_2_eigen_2src_2_sparse_extra_2_random_setter_8h_source}{}\section{eigen/unsupported/\+Eigen/src/\+Sparse\+Extra/\+Random\+Setter.h}
\label{eigen_2unsupported_2_eigen_2src_2_sparse_extra_2_random_setter_8h_source}\index{Random\+Setter.\+h@{Random\+Setter.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_RANDOMSETTER\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_RANDOMSETTER\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_sparse_extra_2_random_setter_8h_source_l00019}\hyperlink{struct_eigen_1_1_std_map_traits}{00019} \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_std_map_traits}{StdMapTraits}
00020 \{
00021   \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} KeyType;
00022   \textcolor{keyword}{typedef} std::map<KeyType,Scalar> Type;
00023   \textcolor{keyword}{enum} \{
00024     IsSorted = 1
00025   \};
00026 
00027   \textcolor{keyword}{static} \textcolor{keywordtype}{void} setInvalidKey(Type&, \textcolor{keyword}{const} KeyType&) \{\}
00028 \};
00029 
00030 \textcolor{preprocessor}{#ifdef EIGEN\_UNORDERED\_MAP\_SUPPORT}
00031 
00047 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }StdUnorderedMapTraits
00048 \{
00049   \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} KeyType;
00050   \textcolor{keyword}{typedef} std::unordered\_map<KeyType,Scalar> Type;
00051   \textcolor{keyword}{enum} \{
00052     IsSorted = 0
00053   \};
00054 
00055   \textcolor{keyword}{static} \textcolor{keywordtype}{void} setInvalidKey(Type&, \textcolor{keyword}{const} KeyType&) \{\}
00056 \};
00057 \textcolor{preprocessor}{#endif // EIGEN\_UNORDERED\_MAP\_SUPPORT}
00058 
00059 \textcolor{preprocessor}{#ifdef \_DENSE\_HASH\_MAP\_H\_}
00060 
00064 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }GoogleDenseHashMapTraits
00065 \{
00066   \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} KeyType;
00067   \textcolor{keyword}{typedef} google::dense\_hash\_map<KeyType,Scalar> Type;
00068   \textcolor{keyword}{enum} \{
00069     IsSorted = 0
00070   \};
00071 
00072   \textcolor{keyword}{static} \textcolor{keywordtype}{void} setInvalidKey(Type& map, \textcolor{keyword}{const} KeyType& k)
00073   \{ map.set\_empty\_key(k); \}
00074 \};
00075 \textcolor{preprocessor}{#endif}
00076 
00077 \textcolor{preprocessor}{#ifdef \_SPARSE\_HASH\_MAP\_H\_}
00078 
00082 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }GoogleSparseHashMapTraits
00083 \{
00084   \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} KeyType;
00085   \textcolor{keyword}{typedef} google::sparse\_hash\_map<KeyType,Scalar> Type;
00086   \textcolor{keyword}{enum} \{
00087     IsSorted = 0
00088   \};
00089 
00090   \textcolor{keyword}{static} \textcolor{keywordtype}{void} setInvalidKey(Type&, \textcolor{keyword}{const} KeyType&) \{\}
00091 \};
00092 \textcolor{preprocessor}{#endif}
00093 
00144 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseMatrixType,
00145          \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }MapTraits =
00146 \textcolor{preprocessor}{#if defined \_DENSE\_HASH\_MAP\_H\_}
00147           GoogleDenseHashMapTraits
00148 \textcolor{preprocessor}{#elif defined \_HASH\_MAP}
00149           GnuHashMapTraits
00150 \textcolor{preprocessor}{#else}
00151           \hyperlink{struct_eigen_1_1_std_map_traits}{StdMapTraits}
00152 \textcolor{preprocessor}{#endif}
00153          ,\textcolor{keywordtype}{int} OuterPacketBits = 6>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_sparse_extra_2_random_setter_8h_source_l00154}\hyperlink{class_eigen_1_1_random_setter}{00154} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_random_setter}{RandomSetter}
00155 \{
00156     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::Scalar Scalar;
00157     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::StorageIndex StorageIndex;
00158 
00159     \textcolor{keyword}{struct }ScalarWrapper
00160     \{
00161       ScalarWrapper() : value(0) \{\}
00162       Scalar value;
00163     \};
00164     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MapTraits<ScalarWrapper>::KeyType KeyType;
00165     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MapTraits<ScalarWrapper>::Type HashMapType;
00166     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} OuterPacketMask = (1 << OuterPacketBits) - 1;
00167     \textcolor{keyword}{enum} \{
00168       SwapStorage = 1 - MapTraits<ScalarWrapper>::IsSorted,
00169       TargetRowMajor = (SparseMatrixType::Flags & \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? 1 : 0,
00170       SetterRowMajor = SwapStorage ? 1-TargetRowMajor : TargetRowMajor
00171     \};
00172 
00173   \textcolor{keyword}{public}:
00174 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_sparse_extra_2_random_setter_8h_source_l00181}\hyperlink{class_eigen_1_1_random_setter_a62e960bd52cec62a59ebb285f381138f}{00181}     \textcolor{keyword}{inline} \hyperlink{class_eigen_1_1_random_setter_a62e960bd52cec62a59ebb285f381138f}{RandomSetter}(SparseMatrixType& target)
00182       : mp\_target(&target)
00183     \{
00184       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerSize = SwapStorage ? target.innerSize() : target.outerSize();
00185       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} innerSize = SwapStorage ? target.outerSize() : target.innerSize();
00186       m\_outerPackets = outerSize >> OuterPacketBits;
00187       \textcolor{keywordflow}{if} (outerSize&OuterPacketMask)
00188         m\_outerPackets += 1;
00189       m\_hashmaps = \textcolor{keyword}{new} HashMapType[m\_outerPackets];
00190       \textcolor{comment}{// compute number of bits needed to store inner indices}
00191       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} aux = innerSize - 1;
00192       m\_keyBitsOffset = 0;
00193       \textcolor{keywordflow}{while} (aux)
00194       \{
00195         ++m\_keyBitsOffset;
00196         aux = aux >> 1;
00197       \}
00198       KeyType ik = (1<<(OuterPacketBits+m\_keyBitsOffset));
00199       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<m\_outerPackets; ++k)
00200         MapTraits<ScalarWrapper>::setInvalidKey(m\_hashmaps[k],ik);
00201 
00202       \textcolor{comment}{// insert current coeffs}
00203       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<mp\_target->outerSize(); ++j)
00204         \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} SparseMatrixType::InnerIterator it(*mp\_target,j); it; ++it)
00205           (*\textcolor{keyword}{this})(TargetRowMajor?j:it.index(), TargetRowMajor?it.index():j) = it.value();
00206     \}
00207 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_sparse_extra_2_random_setter_8h_source_l00209}\hyperlink{class_eigen_1_1_random_setter_a3e4a78672df59ab4dd2799919b431027}{00209}     \hyperlink{class_eigen_1_1_random_setter_a3e4a78672df59ab4dd2799919b431027}{~RandomSetter}()
00210     \{
00211       KeyType keyBitsMask = (1<<m\_keyBitsOffset)-1;
00212       \textcolor{keywordflow}{if} (!SwapStorage) \textcolor{comment}{// also means the map is sorted}
00213       \{
00214         mp\_target->setZero();
00215         mp\_target->makeCompressed();
00216         mp\_target->reserve(nonZeros());
00217         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} prevOuter = -1;
00218         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<m\_outerPackets; ++k)
00219         \{
00220           \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerOffset = (1<<OuterPacketBits) * k;
00221           \textcolor{keyword}{typename} HashMapType::iterator end = m\_hashmaps[k].end();
00222           \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} HashMapType::iterator it = m\_hashmaps[k].begin(); it!=end; ++it)
00223           \{
00224             \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer = (it->first >> m\_keyBitsOffset) + outerOffset;
00225             \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner = it->first & keyBitsMask;
00226             \textcolor{keywordflow}{if} (prevOuter!=outer)
00227             \{
00228               \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=prevOuter+1;j<=outer;++j)
00229                 mp\_target->startVec(j);
00230               prevOuter = outer;
00231             \}
00232             mp\_target->insertBackByOuterInner(outer, inner) = it->second.value;
00233           \}
00234         \}
00235         mp\_target->finalize();
00236       \}
00237       \textcolor{keywordflow}{else}
00238       \{
00239         VectorXi positions(mp\_target->outerSize());
00240         positions.setZero();
00241         \textcolor{comment}{// pass 1}
00242         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<m\_outerPackets; ++k)
00243         \{
00244           \textcolor{keyword}{typename} HashMapType::iterator end = m\_hashmaps[k].end();
00245           \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} HashMapType::iterator it = m\_hashmaps[k].begin(); it!=end; ++it)
00246           \{
00247             \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer = it->first & keyBitsMask;
00248             ++positions[outer];
00249           \}
00250         \}
00251         \textcolor{comment}{// prefix sum}
00252         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} count = 0;
00253         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<mp\_target->outerSize(); ++j)
00254         \{
00255           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} tmp = positions[j];
00256           mp\_target->outerIndexPtr()[j] = count;
00257           positions[j] = count;
00258           count += tmp;
00259         \}
00260         mp\_target->makeCompressed();
00261         mp\_target->outerIndexPtr()[mp\_target->outerSize()] = count;
00262         mp\_target->resizeNonZeros(count);
00263         \textcolor{comment}{// pass 2}
00264         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<m\_outerPackets; ++k)
00265         \{
00266           \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerOffset = (1<<OuterPacketBits) * k;
00267           \textcolor{keyword}{typename} HashMapType::iterator end = m\_hashmaps[k].end();
00268           \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} HashMapType::iterator it = m\_hashmaps[k].begin(); it!=end; ++it)
00269           \{
00270             \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner = (it->first >> m\_keyBitsOffset) + outerOffset;
00271             \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer = it->first & keyBitsMask;
00272             \textcolor{comment}{// sorted insertion}
00273             \textcolor{comment}{// Note that we have to deal with at most 2^OuterPacketBits unsorted coefficients,}
00274             \textcolor{comment}{// moreover those 2^OuterPacketBits coeffs are likely to be sparse, an so only a}
00275             \textcolor{comment}{// small fraction of them have to be sorted, whence the following simple procedure:}
00276             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} posStart = mp\_target->outerIndexPtr()[outer];
00277             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = (positions[outer]++) - 1;
00278             \textcolor{keywordflow}{while} ( (i >= posStart) && (mp\_target->innerIndexPtr()[i] > inner) )
00279             \{
00280               mp\_target->valuePtr()[i+1] = mp\_target->valuePtr()[i];
00281               mp\_target->innerIndexPtr()[i+1] = mp\_target->innerIndexPtr()[i];
00282               --i;
00283             \}
00284             mp\_target->innerIndexPtr()[i+1] = inner;
00285             mp\_target->valuePtr()[i+1] = it->second.value;
00286           \}
00287         \}
00288       \}
00289       \textcolor{keyword}{delete}[] m\_hashmaps;
00290     \}
00291 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_sparse_extra_2_random_setter_8h_source_l00293}\hyperlink{class_eigen_1_1_random_setter_a77dcbbc964b42027e00af269a5147c68}{00293}     Scalar& operator() (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
00294     \{
00295       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer = SetterRowMajor ? row : col;
00296       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} inner = SetterRowMajor ? col : row;
00297       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerMajor = outer >> OuterPacketBits; \textcolor{comment}{// index of the packet/map}
00298       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerMinor = outer & OuterPacketMask;  \textcolor{comment}{// index of the inner vector in the packet}
00299       \textcolor{keyword}{const} KeyType key = internal::convert\_index<KeyType>((outerMinor<<m\_keyBitsOffset) | inner);
00300       \textcolor{keywordflow}{return} m\_hashmaps[outerMajor][key].value;
00301     \}
00302 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_sparse_extra_2_random_setter_8h_source_l00308}\hyperlink{class_eigen_1_1_random_setter_ac34e5cd67e370641c3b48c8a91705046}{00308}     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{class_eigen_1_1_random_setter_ac34e5cd67e370641c3b48c8a91705046}{nonZeros}()\textcolor{keyword}{ const}
00309 \textcolor{keyword}{    }\{
00310       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nz = 0;
00311       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<m\_outerPackets; ++k)
00312         nz += static\_cast<Index>(m\_hashmaps[k].size());
00313       \textcolor{keywordflow}{return} nz;
00314     \}
00315 
00316 
00317   \textcolor{keyword}{protected}:
00318 
00319     HashMapType* m\_hashmaps;
00320     SparseMatrixType* mp\_target;
00321     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_outerPackets;
00322     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} m\_keyBitsOffset;
00323 \};
00324 
00325 \} \textcolor{comment}{// end namespace Eigen}
00326 
00327 \textcolor{preprocessor}{#endif // EIGEN\_RANDOMSETTER\_H}
\end{DoxyCode}
