\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_symmetry_2_static_symmetry_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor\+Symmetry/\+Static\+Symmetry.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_symmetry_2_static_symmetry_8h_source}\index{Static\+Symmetry.\+h@{Static\+Symmetry.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2013 Christian Seiler <christian@iwakd.de>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSORSYMMETRY\_STATICSYMMETRY\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSORSYMMETRY\_STATICSYMMETRY\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} list> \textcolor{keyword}{struct }tensor\_static\_symgroup\_permutate;
00018 
00019 \textcolor{keyword}{template}<\textcolor{keywordtype}{int}... nn>
00020 \textcolor{keyword}{struct }tensor\_static\_symgroup\_permutate<numeric\_list<int, nn...>>
00021 \{
00022   constexpr \textcolor{keyword}{static} std::size\_t N = \textcolor{keyword}{sizeof}...(nn);
00023 
00024   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00025   constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} std::array<T, N> run(\textcolor{keyword}{const} std::array<T, N>& indices)
00026   \{
00027     \textcolor{keywordflow}{return} \{\{indices[nn]...\}\};
00028   \}
00029 \};
00030 
00031 \textcolor{keyword}{template}<\textcolor{keyword}{typename} indices\_, \textcolor{keywordtype}{int} flags\_>
00032 \textcolor{keyword}{struct }tensor\_static\_symgroup\_element
00033 \{
00034   \textcolor{keyword}{typedef} indices\_ indices;
00035   constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} flags = flags\_;
00036 \};
00037 
00038 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Gen, \textcolor{keywordtype}{int} N>
00039 \textcolor{keyword}{struct }tensor\_static\_symgroup\_element\_ctor
00040 \{
00041   \textcolor{keyword}{typedef} tensor\_static\_symgroup\_element<
00042     \textcolor{keyword}{typename} gen\_numeric\_list\_swapped\_pair<int, N, Gen::One, Gen::Two>::type,
00043     Gen::Flags
00044   > type;
00045 \};
00046 
00047 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} N>
00048 \textcolor{keyword}{struct }tensor\_static\_symgroup\_identity\_ctor
00049 \{
00050   \textcolor{keyword}{typedef} tensor\_static\_symgroup\_element<
00051     \textcolor{keyword}{typename} gen\_numeric\_list<int, N>::type,
00052     0
00053   > type;
00054 \};
00055 
00056 \textcolor{keyword}{template}<\textcolor{keyword}{typename} iib>
00057 \textcolor{keyword}{struct }tensor\_static\_symgroup\_multiply\_helper
00058 \{
00059   \textcolor{keyword}{template}<\textcolor{keywordtype}{int}... iia>
00060   constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} numeric\_list<int, get<iia, iib>::value...> helper(numeric\_list<int, iia...>) \{
00061     \textcolor{keywordflow}{return} numeric\_list<int, get<iia, iib>::value...>();
00062   \}
00063 \};
00064 
00065 \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>
00066 \textcolor{keyword}{struct }tensor\_static\_symgroup\_multiply
00067 \{
00068   \textcolor{keyword}{private}:
00069     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} A::indices iia;
00070     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} B::indices iib;
00071     constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} ffa = A::flags;
00072     constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} ffb = B::flags;
00073   
00074   \textcolor{keyword}{public}:
00075     static\_assert(iia::count == iib::count, \textcolor{stringliteral}{"Cannot multiply symmetry elements with different number of
       indices."});
00076 
00077     \textcolor{keyword}{typedef} tensor\_static\_symgroup\_element<
00078       decltype(tensor\_static\_symgroup\_multiply\_helper<iib>::helper(iia())),
00079       ffa ^ ffb
00080     > type;
00081 \};
00082 
00083 \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>
00084 \textcolor{keyword}{struct }tensor\_static\_symgroup\_equality
00085 \{
00086     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} A::indices iia;
00087     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} B::indices iib;
00088     constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} ffa = A::flags;
00089     constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} ffb = B::flags;
00090     static\_assert(iia::count == iib::count, \textcolor{stringliteral}{"Cannot compare symmetry elements with different number of
       indices."});
00091 
00092     constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{bool} value = is\_same<iia, iib>::value;
00093 
00094   \textcolor{keyword}{private}:
00095     \textcolor{comment}{/* this should be zero if they are identical, or else the tensor}
00096 \textcolor{comment}{     * will be forced to be pure real, pure imaginary or even pure zero}
00097 \textcolor{comment}{     */}
00098     constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} flags\_cmp\_ = ffa ^ ffb;
00099 
00100     \textcolor{comment}{/* either they are not equal, then we don't care whether the flags}
00101 \textcolor{comment}{     * match, or they are equal, and then we have to check}
00102 \textcolor{comment}{     */}
00103     constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{bool} is\_zero      = value && flags\_cmp\_ == NegationFlag;
00104     constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{bool} is\_real      = value && flags\_cmp\_ == ConjugationFlag;
00105     constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{bool} is\_imag      = value && flags\_cmp\_ == (NegationFlag | ConjugationFlag);
00106 
00107   \textcolor{keyword}{public}:
00108     constexpr \textcolor{keyword}{static} \textcolor{keywordtype}{int} global\_flags = 
00109       (is\_real ? GlobalRealFlag : 0) |
00110       (is\_imag ? GlobalImagFlag : 0) |
00111       (is\_zero ? GlobalZeroFlag : 0);
00112 \};
00113 
00114 \textcolor{keyword}{template}<std::size\_t NumIndices, \textcolor{keyword}{typename}... Gen>
00115 \textcolor{keyword}{struct }tensor\_static\_symgroup
00116 \{
00117   \textcolor{keyword}{typedef} StaticSGroup<Gen...> type;
00118   constexpr \textcolor{keyword}{static} std::size\_t size = type::static\_size;
00119 \};
00120 
00121 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, std::size\_t N, \textcolor{keywordtype}{int}... ii, \textcolor{keywordtype}{int}... jj>
00122 constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} std::array<Index, N> tensor\_static\_symgroup\_index\_permute(std::array<Index, N> idx,
       internal::numeric\_list<int, ii...>, internal::numeric\_list<int, jj...>)
00123 \{
00124   \textcolor{keywordflow}{return} \{\{ idx[ii]..., idx[jj]... \}\};
00125 \}
00126 
00127 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keywordtype}{int}... ii>
00128 \textcolor{keyword}{static} \textcolor{keyword}{inline} std::vector<Index> tensor\_static\_symgroup\_index\_permute(std::vector<Index> idx, 
      internal::numeric\_list<int, ii...>)
00129 \{
00130   std::vector<Index> result\{\{ idx[ii]... \}\};
00131   std::size\_t target\_size = idx.size();
00132   \textcolor{keywordflow}{for} (std::size\_t i = result.size(); i < target\_size; i++)
00133     result.push\_back(idx[i]);
00134   \textcolor{keywordflow}{return} result;
00135 \}
00136 
00137 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }tensor\_static\_symgroup\_do\_apply;
00138 
00139 \textcolor{keyword}{template}<\textcolor{keyword}{typename} first, \textcolor{keyword}{typename}... next>
00140 \textcolor{keyword}{struct }tensor\_static\_symgroup\_do\_apply<\hyperlink{namespaceinternal}{internal}::type\_list<first, next...>>
00141 \{
00142   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} RV, std::size\_t SGNumIndices, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, std::size\_t NumIndices,
       \textcolor{keyword}{typename}... Args>
00143   \textcolor{keyword}{static} \textcolor{keyword}{inline} RV run(\textcolor{keyword}{const} std::array<Index, NumIndices>& idx, RV initial, Args&&... args)
00144   \{
00145     static\_assert(NumIndices >= SGNumIndices, \textcolor{stringliteral}{"Can only apply symmetry group to objects that have at least
       the required amount of indices."});
00146     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::gen\_numeric\_list<int, NumIndices - SGNumIndices, SGNumIndices>::type 
      remaining\_indices;
00147     initial = Op::run(tensor\_static\_symgroup\_index\_permute(idx, \textcolor{keyword}{typename} first::indices(), 
      remaining\_indices()), first::flags, initial, std::forward<Args>(args)...);
00148     \textcolor{keywordflow}{return} tensor\_static\_symgroup\_do\_apply<internal::type\_list<next...>>::template run<Op, RV,
       SGNumIndices>(idx, initial, args...);
00149   \}
00150 
00151   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} RV, std::size\_t SGNumIndices, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keyword}{typename}... Args>
00152   \textcolor{keyword}{static} \textcolor{keyword}{inline} RV run(\textcolor{keyword}{const} std::vector<Index>& idx, RV initial, Args&&... args)
00153   \{
00154     eigen\_assert(idx.size() >= SGNumIndices && \textcolor{stringliteral}{"Can only apply symmetry group to objects that have at least
       the required amount of indices."});
00155     initial = Op::run(tensor\_static\_symgroup\_index\_permute(idx, \textcolor{keyword}{typename} first::indices()), first::flags, 
      initial, std::forward<Args>(args)...);
00156     \textcolor{keywordflow}{return} tensor\_static\_symgroup\_do\_apply<internal::type\_list<next...>>::template run<Op, RV,
       SGNumIndices>(idx, initial, args...);
00157   \}
00158 \};
00159 
00160 \textcolor{keyword}{template}<EIGEN\_TPL\_PP\_SPEC\_HACK\_DEF(\textcolor{keyword}{typename}, empty)>
00161 \textcolor{keyword}{struct }tensor\_static\_symgroup\_do\_apply<\hyperlink{namespaceinternal}{internal}::type\_list<EIGEN\_TPL\_PP\_SPEC\_HACK\_USE(empty)>>
00162 \{
00163   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} RV, std::size\_t SGNumIndices, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, std::size\_t NumIndices,
       \textcolor{keyword}{typename}... Args>
00164   \textcolor{keyword}{static} \textcolor{keyword}{inline} RV run(\textcolor{keyword}{const} std::array<Index, NumIndices>&, RV initial, Args&&...)
00165   \{
00166     \textcolor{comment}{// do nothing}
00167     \textcolor{keywordflow}{return} initial;
00168   \}
00169 
00170   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} RV, std::size\_t SGNumIndices, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keyword}{typename}... Args>
00171   \textcolor{keyword}{static} \textcolor{keyword}{inline} RV run(\textcolor{keyword}{const} std::vector<Index>&, RV initial, Args&&...)
00172   \{
00173     \textcolor{comment}{// do nothing}
00174     \textcolor{keywordflow}{return} initial;
00175   \}
00176 \};
00177 
00178 \} \textcolor{comment}{// end namespace internal}
00179 
00180 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Gen>
00181 \textcolor{keyword}{class }StaticSGroup
00182 \{
00183     constexpr \textcolor{keyword}{static} std::size\_t NumIndices = internal::tensor\_symmetry\_num\_indices<Gen...>::value;
00184     \textcolor{keyword}{typedef} internal::group\_theory::enumerate\_group\_elements<
00185       internal::tensor\_static\_symgroup\_multiply,
00186       internal::tensor\_static\_symgroup\_equality,
00187       \textcolor{keyword}{typename} internal::tensor\_static\_symgroup\_identity\_ctor<NumIndices>::type,
00188       internal::type\_list<typename internal::tensor\_static\_symgroup\_element\_ctor<Gen, NumIndices>::type...>
00189     > group\_elements;
00190     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} group\_elements::type ge;
00191   \textcolor{keyword}{public}:
00192     constexpr \textcolor{keyword}{inline} StaticSGroup() \{\}
00193     constexpr \textcolor{keyword}{inline} StaticSGroup(\textcolor{keyword}{const} StaticSGroup<Gen...>&) \{\}
00194     constexpr \textcolor{keyword}{inline} StaticSGroup(StaticSGroup<Gen...>&&) \{\}
00195 
00196     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} RV, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, std::size\_t N, \textcolor{keyword}{typename}... Args>
00197     \textcolor{keyword}{static} \textcolor{keyword}{inline} RV apply(\textcolor{keyword}{const} std::array<Index, N>& idx, RV initial, Args&&... args)
00198     \{
00199       \textcolor{keywordflow}{return} internal::tensor\_static\_symgroup\_do\_apply<ge>::template run<Op, RV, NumIndices>(idx, initial, 
      args...);
00200     \}
00201 
00202     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} RV, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keyword}{typename}... Args>
00203     \textcolor{keyword}{static} \textcolor{keyword}{inline} RV apply(\textcolor{keyword}{const} std::vector<Index>& idx, RV initial, Args&&... args)
00204     \{
00205       eigen\_assert(idx.size() == NumIndices);
00206       \textcolor{keywordflow}{return} internal::tensor\_static\_symgroup\_do\_apply<ge>::template run<Op, RV, NumIndices>(idx, initial, 
      args...);
00207     \}
00208 
00209     constexpr \textcolor{keyword}{static} std::size\_t static\_size = ge::count;
00210 
00211     constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} std::size\_t size() \{
00212       \textcolor{keywordflow}{return} ge::count;
00213     \}
00214     constexpr \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} globalFlags() \{ \textcolor{keywordflow}{return} group\_elements::global\_flags; \}
00215 
00216     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Tensor\_, \textcolor{keyword}{typename}... IndexTypes>
00217     \textcolor{keyword}{inline} internal::tensor\_symmetry\_value\_setter<Tensor\_, StaticSGroup<Gen...>> operator()(Tensor\_& tensor
      , \textcolor{keyword}{typename} Tensor\_::Index firstIndex, IndexTypes... otherIndices)\textcolor{keyword}{ const}
00218 \textcolor{keyword}{    }\{
00219       static\_assert(\textcolor{keyword}{sizeof}...(otherIndices) + 1 == Tensor\_::NumIndices, \textcolor{stringliteral}{"Number of indices used to access a
       tensor coefficient must be equal to the rank of the tensor."});
00220       \textcolor{keywordflow}{return} operator()(tensor, std::array<typename Tensor\_::Index, Tensor\_::NumIndices>\{\{firstIndex, 
      otherIndices...\}\});
00221     \}
00222 
00223     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Tensor\_>
00224     \textcolor{keyword}{inline} internal::tensor\_symmetry\_value\_setter<Tensor\_, StaticSGroup<Gen...>> operator()(Tensor\_& tensor
      , std::array<typename Tensor\_::Index, Tensor\_::NumIndices> \textcolor{keyword}{const}& indices)\textcolor{keyword}{ const}
00225 \textcolor{keyword}{    }\{
00226       \textcolor{keywordflow}{return} internal::tensor\_symmetry\_value\_setter<Tensor\_, StaticSGroup<Gen...>>(tensor, *\textcolor{keyword}{this}, indices);
00227     \}
00228 \};
00229 
00230 \} \textcolor{comment}{// end namespace Eigen}
00231 
00232 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSORSYMMETRY\_STATICSYMMETRY\_H}
00233 
00234 \textcolor{comment}{/*}
00235 \textcolor{comment}{ * kate: space-indent on; indent-width 2; mixedindent off; indent-mode cstyle;}
00236 \textcolor{comment}{ */}
\end{DoxyCode}
