\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_device_thread_pool_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Device\+Thread\+Pool.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_device_thread_pool_8h_source}\index{Tensor\+Device\+Thread\+Pool.\+h@{Tensor\+Device\+Thread\+Pool.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#if defined(EIGEN\_USE\_THREADS) && !defined(EIGEN\_CXX11\_TENSOR\_TENSOR\_DEVICE\_THREAD\_POOL\_H)}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_DEVICE\_THREAD\_POOL\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{comment}{// Use the SimpleThreadPool by default. We'll switch to the new non blocking}
00016 \textcolor{comment}{// thread pool later.}
00017 \textcolor{preprocessor}{#ifndef EIGEN\_USE\_SIMPLE\_THREAD\_POOL}
00018 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Env> \textcolor{keyword}{using} ThreadPoolTempl = NonBlockingThreadPoolTempl<Env>;
00019 \textcolor{keyword}{typedef} NonBlockingThreadPool ThreadPool;
00020 \textcolor{preprocessor}{#else}
00021 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Env> \textcolor{keyword}{using} ThreadPoolTempl = SimpleThreadPoolTempl<Env>;
00022 \textcolor{keyword}{typedef} SimpleThreadPool ThreadPool;
00023 \textcolor{preprocessor}{#endif}
00024 
00025 
00026 \textcolor{comment}{// Barrier is an object that allows one or more threads to wait until}
00027 \textcolor{comment}{// Notify has been called a specified number of times.}
00028 \textcolor{keyword}{class }Barrier \{
00029  \textcolor{keyword}{public}:
00030   Barrier(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} count) : state\_(count << 1), notified\_(false) \{
00031     eigen\_assert(((count << 1) >> 1) == count);
00032   \}
00033   ~Barrier() \{
00034     eigen\_assert((state\_>>1) == 0);
00035   \}
00036 
00037   \textcolor{keywordtype}{void} Notify() \{
00038     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} v = state\_.fetch\_sub(2, std::memory\_order\_acq\_rel) - 2;
00039     \textcolor{keywordflow}{if} (v != 1) \{
00040       eigen\_assert(((v + 2) & ~1) != 0);
00041       \textcolor{keywordflow}{return};  \textcolor{comment}{// either count has not dropped to 0, or waiter is not waiting}
00042     \}
00043     std::unique\_lock<std::mutex> l(mu\_);
00044     eigen\_assert(!notified\_);
00045     notified\_ = \textcolor{keyword}{true};
00046     cv\_.notify\_all();
00047   \}
00048 
00049   \textcolor{keywordtype}{void} Wait() \{
00050     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} v = state\_.fetch\_or(1, std::memory\_order\_acq\_rel);
00051     \textcolor{keywordflow}{if} ((v >> 1) == 0) \textcolor{keywordflow}{return};
00052     std::unique\_lock<std::mutex> l(mu\_);
00053     \textcolor{keywordflow}{while} (!notified\_) \{
00054       cv\_.wait(l);
00055     \}
00056   \}
00057 
00058  \textcolor{keyword}{private}:
00059   std::mutex mu\_;
00060   std::condition\_variable cv\_;
00061   std::atomic<unsigned int> state\_;  \textcolor{comment}{// low bit is waiter flag}
00062   \textcolor{keywordtype}{bool} notified\_;
00063 \};
00064 
00065 
00066 \textcolor{comment}{// Notification is an object that allows a user to to wait for another}
00067 \textcolor{comment}{// thread to signal a notification that an event has occurred.}
00068 \textcolor{comment}{//}
00069 \textcolor{comment}{// Multiple threads can wait on the same Notification object,}
00070 \textcolor{comment}{// but only one caller must call Notify() on the object.}
00071 \textcolor{keyword}{struct }Notification : Barrier \{
00072   Notification() : Barrier(1) \{\};
00073 \};
00074 
00075 
00076 \textcolor{comment}{// Runs an arbitrary function and then calls Notify() on the passed in}
00077 \textcolor{comment}{// Notification.}
00078 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Function, \textcolor{keyword}{typename}... Args> \textcolor{keyword}{struct }FunctionWrapperWithNotification
00079 \{
00080   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(Notification* n, Function f, Args... args) \{
00081     f(args...);
00082     \textcolor{keywordflow}{if} (n) \{
00083       n->Notify();
00084     \}
00085   \}
00086 \};
00087 
00088 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Function, \textcolor{keyword}{typename}... Args> \textcolor{keyword}{struct }FunctionWrapperWithBarrier
00089 \{
00090   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(Barrier* b, Function f, Args... args) \{
00091     f(args...);
00092     \textcolor{keywordflow}{if} (b) \{
00093       b->Notify();
00094     \}
00095   \}
00096 \};
00097 
00098 \textcolor{keyword}{template} <\textcolor{keyword}{typename} SyncType>
00099 \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} wait\_until\_ready(SyncType* n) \{
00100   \textcolor{keywordflow}{if} (n) \{
00101     n->Wait();
00102   \}
00103 \}
00104 
00105 
00106 \textcolor{comment}{// Build a thread pool device on top the an existing pool of threads.}
00107 \textcolor{keyword}{struct }ThreadPoolDevice \{
00108   \textcolor{comment}{// The ownership of the thread pool remains with the caller.}
00109   ThreadPoolDevice(ThreadPoolInterface* pool, \textcolor{keywordtype}{int} num\_cores) : pool\_(pool), num\_threads\_(num\_cores) \{ \}
00110 
00111   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}* allocate(\textcolor{keywordtype}{size\_t} num\_bytes)\textcolor{keyword}{ const }\{
00112     \textcolor{keywordflow}{return} internal::aligned\_malloc(num\_bytes);
00113   \}
00114 
00115   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} deallocate(\textcolor{keywordtype}{void}* buffer)\textcolor{keyword}{ const }\{
00116     internal::aligned\_free(buffer);
00117   \}
00118 
00119   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} memcpy(\textcolor{keywordtype}{void}* dst, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* src, \textcolor{keywordtype}{size\_t} n)\textcolor{keyword}{ const }\{
00120     ::memcpy(dst, src, n);
00121   \}
00122   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} memcpyHostToDevice(\textcolor{keywordtype}{void}* dst, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* src, \textcolor{keywordtype}{size\_t} n)\textcolor{keyword}{ const }\{
00123     memcpy(dst, src, n);
00124   \}
00125   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} memcpyDeviceToHost(\textcolor{keywordtype}{void}* dst, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* src, \textcolor{keywordtype}{size\_t} n)\textcolor{keyword}{ const }\{
00126     memcpy(dst, src, n);
00127   \}
00128 
00129   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} memset(\textcolor{keywordtype}{void}* buffer, \textcolor{keywordtype}{int} c, \textcolor{keywordtype}{size\_t} n)\textcolor{keyword}{ const }\{
00130     ::memset(buffer, c, n);
00131   \}
00132 
00133   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} numThreads()\textcolor{keyword}{ const }\{
00134     \textcolor{keywordflow}{return} num\_threads\_;
00135   \}
00136 
00137   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{size\_t} firstLevelCacheSize()\textcolor{keyword}{ const }\{
00138     \textcolor{keywordflow}{return} \hyperlink{namespace_eigen_a2669f89ff38296a38e6d973552eb4e33}{l1CacheSize}();
00139   \}
00140 
00141   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{size\_t} lastLevelCacheSize()\textcolor{keyword}{ const }\{
00142     \textcolor{comment}{// The l3 cache size is shared between all the cores.}
00143     \textcolor{keywordflow}{return} \hyperlink{namespace_eigen_ae2efa4852ea90c2d47b7dcec5b40ba2b}{l3CacheSize}() / num\_threads\_;
00144   \}
00145 
00146   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} majorDeviceVersion()\textcolor{keyword}{ const }\{
00147     \textcolor{comment}{// Should return an enum that encodes the ISA supported by the CPU}
00148     \textcolor{keywordflow}{return} 1;
00149   \}
00150 
00151   \textcolor{keyword}{template} <\textcolor{keyword}{class }Function, \textcolor{keyword}{class}... Args>
00152   EIGEN\_STRONG\_INLINE Notification* enqueue(Function&& f, Args&&... args)\textcolor{keyword}{ const }\{
00153     Notification* n = \textcolor{keyword}{new} Notification();
00154     pool\_->Schedule(std::bind(&FunctionWrapperWithNotification<Function, Args...>::run, n, f, args...));
00155     \textcolor{keywordflow}{return} n;
00156   \}
00157 
00158   \textcolor{keyword}{template} <\textcolor{keyword}{class }Function, \textcolor{keyword}{class}... Args>
00159   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} enqueue\_with\_barrier(Barrier* b,
00160                                                 Function&& f,
00161                                                 Args&&... args)\textcolor{keyword}{ const }\{
00162     pool\_->Schedule(std::bind(
00163         &FunctionWrapperWithBarrier<Function, Args...>::run, b, f, args...));
00164   \}
00165 
00166   \textcolor{keyword}{template} <\textcolor{keyword}{class }Function, \textcolor{keyword}{class}... Args>
00167   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} enqueueNoNotification(Function&& f, Args&&... args)\textcolor{keyword}{ const }\{
00168     pool\_->Schedule(std::bind(f, args...));
00169   \}
00170 
00171   \textcolor{comment}{// Returns a logical thread index between 0 and pool\_->NumThreads() - 1 if}
00172   \textcolor{comment}{// called from one of the threads in pool\_. Returns -1 otherwise.}
00173   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} currentThreadId()\textcolor{keyword}{ const }\{
00174     \textcolor{keywordflow}{return} pool\_->CurrentThreadId();
00175   \}
00176 
00177   \textcolor{comment}{// parallelFor executes f with [0, n) arguments in parallel and waits for}
00178   \textcolor{comment}{// completion. F accepts a half-open interval [first, last).}
00179   \textcolor{comment}{// Block size is choosen based on the iteration cost and resulting parallel}
00180   \textcolor{comment}{// efficiency. If block\_align is not nullptr, it is called to round up the}
00181   \textcolor{comment}{// block size.}
00182   \textcolor{keywordtype}{void} parallelFor(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n, \textcolor{keyword}{const} TensorOpCost& cost,
00183                    std::function<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index})> block\_align,
00184                    std::function<\textcolor{keywordtype}{void}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index})> f)\textcolor{keyword}{ const }\{
00185     \textcolor{keyword}{typedef} TensorCostModel<ThreadPoolDevice> CostModel;
00186     \textcolor{keywordflow}{if} (n <= 1 || numThreads() == 1 ||
00187         CostModel::numThreads(n, cost, static\_cast<int>(numThreads())) == 1) \{
00188       f(0, n);
00189       \textcolor{keywordflow}{return};
00190     \}
00191 
00192     \textcolor{comment}{// Calculate block size based on (1) the iteration cost and (2) parallel}
00193     \textcolor{comment}{// efficiency. We want blocks to be not too small to mitigate}
00194     \textcolor{comment}{// parallelization overheads; not too large to mitigate tail}
00195     \textcolor{comment}{// effect and potential load imbalance and we also want number}
00196     \textcolor{comment}{// of blocks to be evenly dividable across threads.}
00197 
00198     \textcolor{keywordtype}{double} block\_size\_f = 1.0 / CostModel::taskSize(1, cost);
00199     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} block\_size = numext::mini(n, numext::maxi<Index>(1, block\_size\_f));
00200     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} max\_block\_size =
00201         numext::mini(n, numext::maxi<Index>(1, 2 * block\_size\_f));
00202     \textcolor{keywordflow}{if} (block\_align) \{
00203       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} new\_block\_size = block\_align(block\_size);
00204       eigen\_assert(new\_block\_size >= block\_size);
00205       block\_size = numext::mini(n, new\_block\_size);
00206     \}
00207     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} block\_count = divup(n, block\_size);
00208     \textcolor{comment}{// Calculate parallel efficiency as fraction of total CPU time used for}
00209     \textcolor{comment}{// computations:}
00210     \textcolor{keywordtype}{double} max\_efficiency =
00211         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(block\_count) /
00212         (divup<int>(block\_count, numThreads()) * numThreads());
00213     \textcolor{comment}{// Now try to increase block size up to max\_block\_size as long as it}
00214     \textcolor{comment}{// doesn't decrease parallel efficiency.}
00215     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} prev\_block\_count = block\_count; prev\_block\_count > 1;) \{
00216       \textcolor{comment}{// This is the next block size that divides size into a smaller number}
00217       \textcolor{comment}{// of blocks than the current block\_size.}
00218       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} coarser\_block\_size = divup(n, prev\_block\_count - 1);
00219       \textcolor{keywordflow}{if} (block\_align) \{
00220         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} new\_block\_size = block\_align(coarser\_block\_size);
00221         eigen\_assert(new\_block\_size >= coarser\_block\_size);
00222         coarser\_block\_size = numext::mini(n, new\_block\_size);
00223       \}
00224       \textcolor{keywordflow}{if} (coarser\_block\_size > max\_block\_size) \{
00225         \textcolor{keywordflow}{break};  \textcolor{comment}{// Reached max block size. Stop.}
00226       \}
00227       \textcolor{comment}{// Recalculate parallel efficiency.}
00228       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} coarser\_block\_count = divup(n, coarser\_block\_size);
00229       eigen\_assert(coarser\_block\_count < prev\_block\_count);
00230       prev\_block\_count = coarser\_block\_count;
00231       \textcolor{keyword}{const} \textcolor{keywordtype}{double} coarser\_efficiency =
00232           \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(coarser\_block\_count) /
00233           (divup<int>(coarser\_block\_count, numThreads()) * numThreads());
00234       \textcolor{keywordflow}{if} (coarser\_efficiency + 0.01 >= max\_efficiency) \{
00235         \textcolor{comment}{// Taking it.}
00236         block\_size = coarser\_block\_size;
00237         block\_count = coarser\_block\_count;
00238         \textcolor{keywordflow}{if} (max\_efficiency < coarser\_efficiency) \{
00239           max\_efficiency = coarser\_efficiency;
00240         \}
00241       \}
00242     \}
00243 
00244     \textcolor{comment}{// Recursively divide size into halves until we reach block\_size.}
00245     \textcolor{comment}{// Division code rounds mid to block\_size, so we are guaranteed to get}
00246     \textcolor{comment}{// block\_count leaves that do actual computations.}
00247     Barrier barrier(static\_cast<unsigned int>(block\_count));
00248     std::function<void(Index, Index)> handleRange;
00249     handleRange = [=, &handleRange, &barrier, &f](\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} first, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} last) \{
00250       \textcolor{keywordflow}{if} (last - first <= block\_size) \{
00251         \textcolor{comment}{// Single block or less, execute directly.}
00252         f(first, last);
00253         barrier.Notify();
00254         \textcolor{keywordflow}{return};
00255       \}
00256       \textcolor{comment}{// Split into halves and submit to the pool.}
00257       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} mid = first + divup((last - first) / 2, block\_size) * block\_size;
00258       pool\_->Schedule([=, &handleRange]() \{ handleRange(mid, last); \});
00259       pool\_->Schedule([=, &handleRange]() \{ handleRange(first, mid); \});
00260     \};
00261     handleRange(0, n);
00262     barrier.Wait();
00263   \}
00264 
00265   \textcolor{comment}{// Convenience wrapper for parallelFor that does not align blocks.}
00266   \textcolor{keywordtype}{void} parallelFor(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n, \textcolor{keyword}{const} TensorOpCost& cost,
00267                    std::function<\textcolor{keywordtype}{void}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index})> f)\textcolor{keyword}{ const }\{
00268     parallelFor(n, cost, \textcolor{keyword}{nullptr}, std::move(f));
00269   \}
00270 
00271  \textcolor{keyword}{private}:
00272   ThreadPoolInterface* pool\_;
00273   \textcolor{keywordtype}{int} num\_threads\_;
00274 \};
00275 
00276 
00277 \}  \textcolor{comment}{// end namespace Eigen}
00278 
00279 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_DEVICE\_THREAD\_POOL\_H}
\end{DoxyCode}
