\hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source}{}\section{eigen/\+Eigen/src/\+S\+P\+Q\+R\+Support/\+Suite\+Sparse\+Q\+R\+Support.h}
\label{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source}\index{Suite\+Sparse\+Q\+R\+Support.\+h@{Suite\+Sparse\+Q\+R\+Support.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Desire Nuentsa <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_SUITESPARSEQRSUPPORT\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_SUITESPARSEQRSUPPORT\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015   
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00016}\hyperlink{class_eigen_1_1_s_p_q_r}{00016}   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_s_p_q_r}{SPQR}; 
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00017}\hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_return_type}{00017}   \textcolor{keyword}{template}<\textcolor{keyword}{typename} SPQRType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_return_type}{SPQRMatrixQReturnType}; 
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00018}\hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_transpose_return_type}{00018}   \textcolor{keyword}{template}<\textcolor{keyword}{typename} SPQRType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_transpose_return_type}{SPQRMatrixQTransposeReturnType}; 
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00019}\hyperlink{struct_eigen_1_1_s_p_q_r___q_product}{00019}   \textcolor{keyword}{template} <\textcolor{keyword}{typename} SPQRType, \textcolor{keyword}{typename} Derived> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_s_p_q_r___q_product}{SPQR\_QProduct};
00020   \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00021}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_s_p_q_r_matrix_q_return_type_3_01_s_p_q_r_type_01_4_01_4}{00021}     \textcolor{keyword}{template} <\textcolor{keyword}{typename} SPQRType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_return_type}{SPQRMatrixQReturnType}<SPQRType> >
00022     \{
00023       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SPQRType::MatrixType ReturnType;
00024     \};
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00025}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_s_p_q_r_matrix_q_transpose_return_type_3_01_s_p_q_r_type_01_4_01_4}{00025}     \textcolor{keyword}{template} <\textcolor{keyword}{typename} SPQRType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<
      \hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_transpose_return_type}{SPQRMatrixQTransposeReturnType}<SPQRType> >
00026     \{
00027       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SPQRType::MatrixType ReturnType;
00028     \};
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00029}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_s_p_q_r___q_product_3_01_s_p_q_r_type_00_01_derived_01_4_01_4}{00029}     \textcolor{keyword}{template} <\textcolor{keyword}{typename} SPQRType, \textcolor{keyword}{typename} Derived> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<
      \hyperlink{struct_eigen_1_1_s_p_q_r___q_product}{SPQR\_QProduct}<SPQRType, Derived> >
00030     \{
00031       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::PlainObject ReturnType;
00032     \};
00033   \} \textcolor{comment}{// End namespace internal}
00034   
00059 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
00060 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_s_p_q_r}{SPQR} : \textcolor{keyword}{public} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase}<SPQR<\_MatrixType> >
00061 \{
00062   \textcolor{keyword}{protected}:
00063     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase<SPQR<\_MatrixType>} > Base;
00064     \textcolor{keyword}{using} Base::m\_isInitialized;
00065   \textcolor{keyword}{public}:
00066     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \_MatrixType::Scalar Scalar;
00067     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \_MatrixType::RealScalar RealScalar;
00068     \textcolor{keyword}{typedef} SuiteSparse\_long StorageIndex ;
00069     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar, ColMajor, StorageIndex>} 
      MatrixType;
00070     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<PermutationMatrix<Dynamic, Dynamic, StorageIndex>}
       > PermutationType;
00071     \textcolor{keyword}{enum} \{
00072       ColsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00073       MaxColsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}
00074     \};
00075   \textcolor{keyword}{public}:
00076     \hyperlink{class_eigen_1_1_s_p_q_r}{SPQR}() 
00077       : m\_ordering(SPQR\_ORDERING\_DEFAULT), m\_allow\_tol(SPQR\_DEFAULT\_TOL), m\_tolerance (
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}()), m\_useDefaultThreshold(\textcolor{keyword}{true})
00078     \{ 
00079       cholmod\_l\_start(&m\_cc);
00080     \}
00081     
00082     \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1_s_p_q_r}{SPQR}(\textcolor{keyword}{const} \_MatrixType& matrix)
00083     : m\_ordering(SPQR\_ORDERING\_DEFAULT), m\_allow\_tol(SPQR\_DEFAULT\_TOL), m\_tolerance (
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}()), m\_useDefaultThreshold(\textcolor{keyword}{true})
00084     \{
00085       cholmod\_l\_start(&m\_cc);
00086       compute(matrix);
00087     \}
00088     
00089     ~\hyperlink{class_eigen_1_1_s_p_q_r}{SPQR}()
00090     \{
00091       SPQR\_free();
00092       cholmod\_l\_finish(&m\_cc);
00093     \}
00094     \textcolor{keywordtype}{void} SPQR\_free()
00095     \{
00096       cholmod\_l\_free\_sparse(&m\_H, &m\_cc);
00097       cholmod\_l\_free\_sparse(&m\_cR, &m\_cc);
00098       cholmod\_l\_free\_dense(&m\_HTau, &m\_cc);
00099       std::free(m\_E);
00100       std::free(m\_HPinv);
00101     \}
00102 
00103     \textcolor{keywordtype}{void} compute(\textcolor{keyword}{const} \_MatrixType& matrix)
00104     \{
00105       \textcolor{keywordflow}{if}(m\_isInitialized) SPQR\_free();
00106 
00107       MatrixType mat(matrix);
00108       
00109       \textcolor{comment}{/* Compute the default threshold as in MatLab, see:}
00110 \textcolor{comment}{       * Tim Davis, "Algorithm 915, SuiteSparseQR: Multifrontal Multithreaded Rank-Revealing}
00111 \textcolor{comment}{       * Sparse QR Factorization, ACM Trans. on Math. Soft. 38(1), 2011, Page 8:3 }
00112 \textcolor{comment}{       */}
00113       RealScalar pivotThreshold = m\_tolerance;
00114       \textcolor{keywordflow}{if}(m\_useDefaultThreshold) 
00115       \{
00116         RealScalar max2Norm = 0.0;
00117         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < mat.cols(); j++) max2Norm = numext::maxi(max2Norm, mat.col(j).norm());
00118         \textcolor{keywordflow}{if}(max2Norm==RealScalar(0))
00119           max2Norm = RealScalar(1);
00120         pivotThreshold = 20 * (mat.rows() + mat.cols()) * max2Norm * 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::epsilon}();
00121       \}
00122       cholmod\_sparse \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}; 
00123       A = \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(mat);
00124       m\_rows = matrix.rows();
00125       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col = matrix.cols();
00126       m\_rank = SuiteSparseQR<Scalar>(m\_ordering, pivotThreshold, col, &A, 
00127                              &m\_cR, &m\_E, &m\_H, &m\_HPinv, &m\_HTau, &m\_cc);
00128 
00129       \textcolor{keywordflow}{if} (!m\_cR)
00130       \{
00131         m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00132         m\_isInitialized = \textcolor{keyword}{false};
00133         \textcolor{keywordflow}{return};
00134       \}
00135       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00136       m\_isInitialized = \textcolor{keyword}{true};
00137       m\_isRUpToDate = \textcolor{keyword}{false};
00138     \}
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00142}\hyperlink{class_eigen_1_1_s_p_q_r_a775e28a44fd466638114edbcd17ea50a}{00142}     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{class_eigen_1_1_s_p_q_r_a775e28a44fd466638114edbcd17ea50a}{rows}()\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} m\_rows; \}
00143     
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00147}\hyperlink{class_eigen_1_1_s_p_q_r_aa006d40963b05c7525b5ca0b02364d84}{00147}     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{class_eigen_1_1_s_p_q_r_aa006d40963b05c7525b5ca0b02364d84}{cols}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_cR->ncol; \}
00148     
00149     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest>
00150     \textcolor{keywordtype}{void} \_solve\_impl(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>} &b, \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>} &dest)\textcolor{keyword}{ const}
00151 \textcolor{keyword}{    }\{
00152       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{" The QR factorization should be computed first, call compute()"});
00153       eigen\_assert(b.cols()==1 && \textcolor{stringliteral}{"This method is for vectors only"});
00154 
00155       \textcolor{comment}{//Compute Q^T * b}
00156       \textcolor{keyword}{typename} Dest::PlainObject y, y2;
00157       y = matrixQ().transpose() * b;
00158       
00159       \textcolor{comment}{// Solves with the triangular matrix R}
00160       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rk = this->rank();
00161       y2 = y;
00162       y.resize((std::max)(cols(),\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(y.rows())),y.cols());
00163       y.topRows(rk) = this->matrixR().topLeftCorner(rk, rk).template triangularView<Upper>().solve(y2.
      topRows(rk));
00164 
00165       \textcolor{comment}{// Apply the column permutation }
00166       \textcolor{comment}{// colsPermutation() performs a copy of the permutation,}
00167       \textcolor{comment}{// so let's apply it manually:}
00168       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < rk; ++i) dest.\hyperlink{group___core___module_a4ea11afe36c7962c706caa93decd1380}{row}(m\_E[i]) = y.row(i);
00169       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = rk; i < cols(); ++i) dest.\hyperlink{group___core___module_a4ea11afe36c7962c706caa93decd1380}{row}(m\_E[i]).setZero();
00170       
00171 \textcolor{comment}{//       y.bottomRows(y.rows()-rk).setZero();}
00172 \textcolor{comment}{//       dest = colsPermutation() * y.topRows(cols());}
00173       
00174       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00175     \}
00176     
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00179}\hyperlink{class_eigen_1_1_s_p_q_r_ad51661be35674dd6a65e27699dbb3fb9}{00179}     \textcolor{keyword}{const} MatrixType \hyperlink{class_eigen_1_1_s_p_q_r_ad51661be35674dd6a65e27699dbb3fb9}{matrixR}()\textcolor{keyword}{ const}
00180 \textcolor{keyword}{    }\{
00181       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{" The QR factorization should be computed first, call compute()"});
00182       \textcolor{keywordflow}{if}(!m\_isRUpToDate) \{
00183         m\_R = viewAsEigen<Scalar,ColMajor, typename MatrixType::StorageIndex>(*m\_cR);
00184         m\_isRUpToDate = \textcolor{keyword}{true};
00185       \}
00186       \textcolor{keywordflow}{return} m\_R;
00187     \}
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00189}\hyperlink{class_eigen_1_1_s_p_q_r_a93dbf1b487e28948e1ca2a33a35b6a54}{00189}     \hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_return_type}{SPQRMatrixQReturnType<SPQR>} \hyperlink{class_eigen_1_1_s_p_q_r_a93dbf1b487e28948e1ca2a33a35b6a54}{matrixQ}()\textcolor{keyword}{ const}
00190 \textcolor{keyword}{    }\{
00191       \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_return_type}{SPQRMatrixQReturnType<SPQR>}(*this);
00192     \}
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00194}\hyperlink{class_eigen_1_1_s_p_q_r_ab1b7f54ba1cd8d77506ae676fea4fec0}{00194}     PermutationType \hyperlink{class_eigen_1_1_s_p_q_r_ab1b7f54ba1cd8d77506ae676fea4fec0}{colsPermutation}()\textcolor{keyword}{ const}
00195 \textcolor{keyword}{    }\{ 
00196       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"Decomposition is not initialized."});
00197       \textcolor{keywordflow}{return} PermutationType(m\_E, m\_cR->ncol);
00198     \}
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00203}\hyperlink{class_eigen_1_1_s_p_q_r_a539b394ddb4894089e6634c744ea2ddc}{00203}     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{class_eigen_1_1_s_p_q_r_a539b394ddb4894089e6634c744ea2ddc}{rank}()\textcolor{keyword}{ const}
00204 \textcolor{keyword}{    }\{
00205       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"Decomposition is not initialized."});
00206       \textcolor{keywordflow}{return} m\_cc.SPQR\_istat[4];
00207     \}
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00209}\hyperlink{class_eigen_1_1_s_p_q_r_afa0db7888d808b453c23f62d62a4ad22}{00209}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_s_p_q_r_afa0db7888d808b453c23f62d62a4ad22}{setSPQROrdering}(\textcolor{keywordtype}{int} ord) \{ m\_ordering = ord;\}
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00211}\hyperlink{class_eigen_1_1_s_p_q_r_ab7b42b75f621b0d4b5b0e090e23e2ce6}{00211}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_s_p_q_r_ab7b42b75f621b0d4b5b0e090e23e2ce6}{setPivotThreshold}(\textcolor{keyword}{const} RealScalar& tol)
00212     \{
00213       m\_useDefaultThreshold = \textcolor{keyword}{false};
00214       m\_tolerance = tol;
00215     \}
00216     
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00218}\hyperlink{class_eigen_1_1_s_p_q_r_a8c7d48d51a1fb08a3e27b8499e5c7f49}{00218}     cholmod\_common *\hyperlink{class_eigen_1_1_s_p_q_r_a8c7d48d51a1fb08a3e27b8499e5c7f49}{cholmodCommon}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} &m\_cc; \}
00219     
00220     
\Hypertarget{eigen_2_eigen_2src_2_s_p_q_r_support_2_suite_sparse_q_r_support_8h_source_l00226}\hyperlink{class_eigen_1_1_s_p_q_r_a3ab7bacba8d2be20adc10b4d5b6c071f}{00226}     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} \hyperlink{class_eigen_1_1_s_p_q_r_a3ab7bacba8d2be20adc10b4d5b6c071f}{info}()\textcolor{keyword}{ const}
00227 \textcolor{keyword}{    }\{
00228       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"Decomposition is not initialized."});
00229       \textcolor{keywordflow}{return} m\_info;
00230     \}
00231   \textcolor{keyword}{protected}:
00232     \textcolor{keywordtype}{bool} m\_analysisIsOk;
00233     \textcolor{keywordtype}{bool} m\_factorizationIsOk;
00234     \textcolor{keyword}{mutable} \textcolor{keywordtype}{bool} m\_isRUpToDate;
00235     \textcolor{keyword}{mutable} \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} m\_info;
00236     \textcolor{keywordtype}{int} m\_ordering; \textcolor{comment}{// Ordering method to use, see SPQR's manual}
00237     \textcolor{keywordtype}{int} m\_allow\_tol; \textcolor{comment}{// Allow to use some tolerance during numerical factorization.}
00238     RealScalar m\_tolerance; \textcolor{comment}{// treat columns with 2-norm below this tolerance as zero}
00239     \textcolor{keyword}{mutable} cholmod\_sparse *m\_cR; \textcolor{comment}{// The sparse R factor in cholmod format}
00240     \textcolor{keyword}{mutable} MatrixType m\_R; \textcolor{comment}{// The sparse matrix R in Eigen format}
00241     \textcolor{keyword}{mutable} StorageIndex *m\_E; \textcolor{comment}{// The permutation applied to columns}
00242     \textcolor{keyword}{mutable} cholmod\_sparse *m\_H;  \textcolor{comment}{//The householder vectors}
00243     \textcolor{keyword}{mutable} StorageIndex *m\_HPinv; \textcolor{comment}{// The row permutation of H}
00244     \textcolor{keyword}{mutable} cholmod\_dense *m\_HTau; \textcolor{comment}{// The Householder coefficients}
00245     \textcolor{keyword}{mutable} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_rank; \textcolor{comment}{// The rank of the matrix}
00246     \textcolor{keyword}{mutable} cholmod\_common m\_cc; \textcolor{comment}{// Workspace and parameters}
00247     \textcolor{keywordtype}{bool} m\_useDefaultThreshold;     \textcolor{comment}{// Use default threshold}
00248     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_rows;
00249     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ,\textcolor{keyword}{typename} > \textcolor{keyword}{friend} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_s_p_q_r___q_product}{SPQR\_QProduct};
00250 \};
00251 
00252 \textcolor{keyword}{template} <\textcolor{keyword}{typename} SPQRType, \textcolor{keyword}{typename} Derived>
00253 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_s_p_q_r___q_product}{SPQR\_QProduct} : \hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue}<SPQR\_QProduct<SPQRType,Derived> >
00254 \{
00255   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SPQRType::Scalar Scalar;
00256   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SPQRType::StorageIndex StorageIndex;
00257   \textcolor{comment}{//Define the constructor to get reference to argument types}
00258   \hyperlink{struct_eigen_1_1_s_p_q_r___q_product}{SPQR\_QProduct}(\textcolor{keyword}{const} SPQRType& spqr, \textcolor{keyword}{const} Derived& other, \textcolor{keywordtype}{bool} transpose) : m\_spqr(spqr),
      m\_other(other),m\_transpose(transpose) \{\}
00259   
00260   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_transpose ? m\_spqr.rows() : m\_spqr.cols(); \}
00261   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_other.cols(); \}
00262   \textcolor{comment}{// Assign to a vector}
00263   \textcolor{keyword}{template}<\textcolor{keyword}{typename} ResType>
00264   \textcolor{keywordtype}{void} evalTo(ResType& res)\textcolor{keyword}{ const}
00265 \textcolor{keyword}{  }\{
00266     cholmod\_dense y\_cd;
00267     cholmod\_dense *x\_cd; 
00268     \textcolor{keywordtype}{int} method = m\_transpose ? SPQR\_QTX : SPQR\_QX; 
00269     cholmod\_common *cc = m\_spqr.cholmodCommon();
00270     y\_cd = \hyperlink{namespace_eigen_ac9fb9e40cfc9ddbdc7da84ee01bb7545}{viewAsCholmod}(m\_other.const\_cast\_derived());
00271     x\_cd = SuiteSparseQR\_qmult<Scalar>(method, m\_spqr.m\_H, m\_spqr.m\_HTau, m\_spqr.m\_HPinv, &y\_cd, cc);
00272     res = 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,ResType::RowsAtCompileTime,ResType::ColsAtCompileTime>::Map}
      (reinterpret\_cast<Scalar*>(x\_cd->x), x\_cd->nrow, x\_cd->ncol);
00273     cholmod\_l\_free\_dense(&x\_cd, cc);
00274   \}
00275   \textcolor{keyword}{const} SPQRType& m\_spqr; 
00276   \textcolor{keyword}{const} Derived& m\_other; 
00277   \textcolor{keywordtype}{bool} m\_transpose; 
00278   
00279 \};
00280 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SPQRType>
00281 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_return_type}{SPQRMatrixQReturnType}\{
00282   
00283   \hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_return_type}{SPQRMatrixQReturnType}(\textcolor{keyword}{const} SPQRType& spqr) : m\_spqr(spqr) \{\}
00284   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00285   \hyperlink{struct_eigen_1_1_s_p_q_r___q_product}{SPQR\_QProduct<SPQRType, Derived>} operator*(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& other)
00286   \{
00287     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_s_p_q_r___q_product}{SPQR\_QProduct<SPQRType,Derived>}(m\_spqr,other.derived(),\textcolor{keyword}{false});
00288   \}
00289   \hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_transpose_return_type}{SPQRMatrixQTransposeReturnType<SPQRType>} adjoint()\textcolor{keyword}{ const}
00290 \textcolor{keyword}{  }\{
00291     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_transpose_return_type}{SPQRMatrixQTransposeReturnType<SPQRType>}(m\_spqr);
00292   \}
00293   \textcolor{comment}{// To use for operations with the transpose of Q}
00294   \hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_transpose_return_type}{SPQRMatrixQTransposeReturnType<SPQRType>} transpose()\textcolor{keyword}{ const}
00295 \textcolor{keyword}{  }\{
00296     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_transpose_return_type}{SPQRMatrixQTransposeReturnType<SPQRType>}(m\_spqr);
00297   \}
00298   \textcolor{keyword}{const} SPQRType& m\_spqr;
00299 \};
00300 
00301 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SPQRType>
00302 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_transpose_return_type}{SPQRMatrixQTransposeReturnType}\{
00303   \hyperlink{struct_eigen_1_1_s_p_q_r_matrix_q_transpose_return_type}{SPQRMatrixQTransposeReturnType}(\textcolor{keyword}{const} SPQRType& spqr) : m\_spqr(spqr) \{\}
00304   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00305   \hyperlink{struct_eigen_1_1_s_p_q_r___q_product}{SPQR\_QProduct<SPQRType,Derived>} operator*(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& other)
00306   \{
00307     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_s_p_q_r___q_product}{SPQR\_QProduct<SPQRType,Derived>}(m\_spqr,other.derived(), \textcolor{keyword}{true});
00308   \}
00309   \textcolor{keyword}{const} SPQRType& m\_spqr;
00310 \};
00311 
00312 \}\textcolor{comment}{// End namespace Eigen}
00313 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
