\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2util_2_static_assert_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/util/\+Static\+Assert.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2util_2_static_assert_8h_source}\index{Static\+Assert.\+h@{Static\+Assert.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_STATIC\_ASSERT\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_H}
00013 
00014 \textcolor{comment}{/* Some notes on Eigen's static assertion mechanism:}
00015 \textcolor{comment}{ *}
00016 \textcolor{comment}{ *  - in EIGEN\_STATIC\_ASSERT(CONDITION,MSG) the parameter CONDITION must be a compile time boolean}
00017 \textcolor{comment}{ *    expression, and MSG an enum listed in struct internal::static\_assertion<true>}
00018 \textcolor{comment}{ *}
00019 \textcolor{comment}{ *  - define EIGEN\_NO\_STATIC\_ASSERT to disable them (and save compilation time)}
00020 \textcolor{comment}{ *    in that case, the static assertion is converted to the following runtime assert:}
00021 \textcolor{comment}{ *      eigen\_assert(CONDITION && "MSG")}
00022 \textcolor{comment}{ *}
00023 \textcolor{comment}{ *  - currently EIGEN\_STATIC\_ASSERT can only be used in function scope}
00024 \textcolor{comment}{ *}
00025 \textcolor{comment}{ */}
00026 
00027 \textcolor{preprocessor}{#ifndef EIGEN\_NO\_STATIC\_ASSERT}
00028 
00029 \textcolor{preprocessor}{  #if EIGEN\_MAX\_CPP\_VER>=11 && (\_\_has\_feature(cxx\_static\_assert) || (defined(\_\_cplusplus) && \_\_cplusplus >=
       201103L) || (EIGEN\_COMP\_MSVC >= 1600))}
00030 
00031     \textcolor{comment}{// if native static\_assert is enabled, let's use it}
00032 \textcolor{preprocessor}{    #define EIGEN\_STATIC\_ASSERT(X,MSG) static\_assert(X,#MSG);}
00033 
00034 \textcolor{preprocessor}{  #else // not CXX0X}
00035 
00036     \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00037 
00038     \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00039 
00040     \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} condition>
00041     \textcolor{keyword}{struct }static\_assertion \{\};
00042 
00043     \textcolor{keyword}{template}<>
00044     \textcolor{keyword}{struct }static\_assertion<true>
00045     \{
00046       \textcolor{keyword}{enum} \{
00047         YOU\_TRIED\_CALLING\_A\_VECTOR\_METHOD\_ON\_A\_MATRIX,
00048         YOU\_MIXED\_VECTORS\_OF\_DIFFERENT\_SIZES,
00049         YOU\_MIXED\_MATRICES\_OF\_DIFFERENT\_SIZES,
00050         THIS\_METHOD\_IS\_ONLY\_FOR\_VECTORS\_OF\_A\_SPECIFIC\_SIZE,
00051         THIS\_METHOD\_IS\_ONLY\_FOR\_MATRICES\_OF\_A\_SPECIFIC\_SIZE,
00052         THIS\_METHOD\_IS\_ONLY\_FOR\_OBJECTS\_OF\_A\_SPECIFIC\_SIZE,
00053         OUT\_OF\_RANGE\_ACCESS,
00054         YOU\_MADE\_A\_PROGRAMMING\_MISTAKE,
00055         EIGEN\_INTERNAL\_ERROR\_PLEASE\_FILE\_A\_BUG\_REPORT,
00056         EIGEN\_INTERNAL\_COMPILATION\_ERROR\_OR\_YOU\_MADE\_A\_PROGRAMMING\_MISTAKE,
00057         YOU\_CALLED\_A\_FIXED\_SIZE\_METHOD\_ON\_A\_DYNAMIC\_SIZE\_MATRIX\_OR\_VECTOR,
00058         YOU\_CALLED\_A\_DYNAMIC\_SIZE\_METHOD\_ON\_A\_FIXED\_SIZE\_MATRIX\_OR\_VECTOR,
00059         UNALIGNED\_LOAD\_AND\_STORE\_OPERATIONS\_UNIMPLEMENTED\_ON\_ALTIVEC,
00060         THIS\_FUNCTION\_IS\_NOT\_FOR\_INTEGER\_NUMERIC\_TYPES,
00061         FLOATING\_POINT\_ARGUMENT\_PASSED\_\_INTEGER\_WAS\_EXPECTED,
00062         NUMERIC\_TYPE\_MUST\_BE\_REAL,
00063         COEFFICIENT\_WRITE\_ACCESS\_TO\_SELFADJOINT\_NOT\_SUPPORTED,
00064         WRITING\_TO\_TRIANGULAR\_PART\_WITH\_UNIT\_DIAGONAL\_IS\_NOT\_SUPPORTED,
00065         THIS\_METHOD\_IS\_ONLY\_FOR\_FIXED\_SIZE,
00066         INVALID\_MATRIX\_PRODUCT,
00067         
      INVALID\_VECTOR\_VECTOR\_PRODUCT\_\_IF\_YOU\_WANTED\_A\_DOT\_OR\_COEFF\_WISE\_PRODUCT\_YOU\_MUST\_USE\_THE\_EXPLICIT\_FUNCTIONS,
00068         INVALID\_MATRIX\_PRODUCT\_\_IF\_YOU\_WANTED\_A\_COEFF\_WISE\_PRODUCT\_YOU\_MUST\_USE\_THE\_EXPLICIT\_FUNCTION,
00069         
      YOU\_MIXED\_DIFFERENT\_NUMERIC\_TYPES\_\_YOU\_NEED\_TO\_USE\_THE\_CAST\_METHOD\_OF\_MATRIXBASE\_TO\_CAST\_NUMERIC\_TYPES\_EXPLICITLY,
00070         THIS\_METHOD\_IS\_ONLY\_FOR\_COLUMN\_MAJOR\_MATRICES,
00071         THIS\_METHOD\_IS\_ONLY\_FOR\_ROW\_MAJOR\_MATRICES,
00072         INVALID\_MATRIX\_TEMPLATE\_PARAMETERS,
00073         INVALID\_MATRIXBASE\_TEMPLATE\_PARAMETERS,
00074         BOTH\_MATRICES\_MUST\_HAVE\_THE\_SAME\_STORAGE\_ORDER,
00075         THIS\_METHOD\_IS\_ONLY\_FOR\_DIAGONAL\_MATRIX,
00076         THE\_MATRIX\_OR\_EXPRESSION\_THAT\_YOU\_PASSED\_DOES\_NOT\_HAVE\_THE\_EXPECTED\_TYPE,
00077         THIS\_METHOD\_IS\_ONLY\_FOR\_EXPRESSIONS\_WITH\_DIRECT\_MEMORY\_ACCESS\_SUCH\_AS\_MAP\_OR\_PLAIN\_MATRICES,
00078         YOU\_ALREADY\_SPECIFIED\_THIS\_STRIDE,
00079         INVALID\_STORAGE\_ORDER\_FOR\_THIS\_VECTOR\_EXPRESSION,
00080         THE\_BRACKET\_OPERATOR\_IS\_ONLY\_FOR\_VECTORS\_\_USE\_THE\_PARENTHESIS\_OPERATOR\_INSTEAD,
00081         PACKET\_ACCESS\_REQUIRES\_TO\_HAVE\_INNER\_STRIDE\_FIXED\_TO\_1,
00082         THIS\_METHOD\_IS\_ONLY\_FOR\_SPECIFIC\_TRANSFORMATIONS,
00083         YOU\_CANNOT\_MIX\_ARRAYS\_AND\_MATRICES,
00084         YOU\_PERFORMED\_AN\_INVALID\_TRANSFORMATION\_CONVERSION,
00085         THIS\_EXPRESSION\_IS\_NOT\_A\_LVALUE\_\_IT\_IS\_READ\_ONLY,
00086         YOU\_ARE\_TRYING\_TO\_USE\_AN\_INDEX\_BASED\_ACCESSOR\_ON\_AN\_EXPRESSION\_THAT\_DOES\_NOT\_SUPPORT\_THAT,
00087         THIS\_METHOD\_IS\_ONLY\_FOR\_1x1\_EXPRESSIONS,
00088         THIS\_METHOD\_IS\_ONLY\_FOR\_INNER\_OR\_LAZY\_PRODUCTS,
00089         THIS\_METHOD\_IS\_ONLY\_FOR\_EXPRESSIONS\_OF\_BOOL,
00090         THIS\_METHOD\_IS\_ONLY\_FOR\_ARRAYS\_NOT\_MATRICES,
00091         YOU\_PASSED\_A\_ROW\_VECTOR\_BUT\_A\_COLUMN\_VECTOR\_WAS\_EXPECTED,
00092         YOU\_PASSED\_A\_COLUMN\_VECTOR\_BUT\_A\_ROW\_VECTOR\_WAS\_EXPECTED,
00093         THE\_INDEX\_TYPE\_MUST\_BE\_A\_SIGNED\_TYPE,
00094         THE\_STORAGE\_ORDER\_OF\_BOTH\_SIDES\_MUST\_MATCH,
00095         OBJECT\_ALLOCATED\_ON\_STACK\_IS\_TOO\_BIG,
00096         IMPLICIT\_CONVERSION\_TO\_SCALAR\_IS\_FOR\_INNER\_PRODUCT\_ONLY,
00097         STORAGE\_LAYOUT\_DOES\_NOT\_MATCH,
00098         EIGEN\_INTERNAL\_ERROR\_PLEASE\_FILE\_A\_BUG\_REPORT\_\_INVALID\_COST\_VALUE,
00099         THIS\_COEFFICIENT\_ACCESSOR\_TAKING\_ONE\_ACCESS\_IS\_ONLY\_FOR\_EXPRESSIONS\_ALLOWING\_LINEAR\_ACCESS,
00100         MATRIX\_FREE\_CONJUGATE\_GRADIENT\_IS\_COMPATIBLE\_WITH\_UPPER\_UNION\_LOWER\_MODE\_ONLY,
00101         THIS\_TYPE\_IS\_NOT\_SUPPORTED,
00102         STORAGE\_KIND\_MUST\_MATCH,
00103         STORAGE\_INDEX\_MUST\_MATCH,
00104         CHOLMOD\_SUPPORTS\_DOUBLE\_PRECISION\_ONLY
00105       \};
00106     \};
00107 
00108     \} \textcolor{comment}{// end namespace internal}
00109 
00110     \} \textcolor{comment}{// end namespace Eigen}
00111 
00112     \textcolor{comment}{// Specialized implementation for MSVC to avoid "conditional}
00113     \textcolor{comment}{// expression is constant" warnings.  This implementation doesn't}
00114     \textcolor{comment}{// appear to work under GCC, hence the multiple implementations.}
00115 \textcolor{preprocessor}{    #if EIGEN\_COMP\_MSVC}
00116 
00117 \textcolor{preprocessor}{      #define EIGEN\_STATIC\_ASSERT(CONDITION,MSG) \(\backslash\)}
00118 \textcolor{preprocessor}{        \{Eigen::internal::static\_assertion<bool(CONDITION)>::MSG;\}}
00119 
00120 \textcolor{preprocessor}{    #else}
00121       \textcolor{comment}{// In some cases clang interprets bool(CONDITION) as function declaration}
00122 \textcolor{preprocessor}{      #define EIGEN\_STATIC\_ASSERT(CONDITION,MSG) \(\backslash\)}
00123 \textcolor{preprocessor}{        if (Eigen::internal::static\_assertion<static\_cast<bool>(CONDITION)>::MSG) \{\}}
00124 
00125 \textcolor{preprocessor}{    #endif}
00126 
00127 \textcolor{preprocessor}{  #endif // not CXX0X}
00128 
00129 \textcolor{preprocessor}{#else // EIGEN\_NO\_STATIC\_ASSERT}
00130 
00131 \textcolor{preprocessor}{  #define EIGEN\_STATIC\_ASSERT(CONDITION,MSG) eigen\_assert((CONDITION) && #MSG);}
00132 
00133 \textcolor{preprocessor}{#endif // EIGEN\_NO\_STATIC\_ASSERT}
00134 
00135 
00136 \textcolor{comment}{// static assertion failing if the type \(\backslash\)a TYPE is not a vector type}
00137 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_VECTOR\_ONLY(TYPE) \(\backslash\)}
00138 \textcolor{preprocessor}{  EIGEN\_STATIC\_ASSERT(TYPE::IsVectorAtCompileTime, \(\backslash\)}
00139 \textcolor{preprocessor}{                      YOU\_TRIED\_CALLING\_A\_VECTOR\_METHOD\_ON\_A\_MATRIX)}
00140 
00141 \textcolor{comment}{// static assertion failing if the type \(\backslash\)a TYPE is not fixed-size}
00142 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_FIXED\_SIZE(TYPE) \(\backslash\)}
00143 \textcolor{preprocessor}{  EIGEN\_STATIC\_ASSERT(TYPE::SizeAtCompileTime!=Eigen::Dynamic, \(\backslash\)}
00144 \textcolor{preprocessor}{                      YOU\_CALLED\_A\_FIXED\_SIZE\_METHOD\_ON\_A\_DYNAMIC\_SIZE\_MATRIX\_OR\_VECTOR)}
00145 
00146 \textcolor{comment}{// static assertion failing if the type \(\backslash\)a TYPE is not dynamic-size}
00147 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_DYNAMIC\_SIZE(TYPE) \(\backslash\)}
00148 \textcolor{preprocessor}{  EIGEN\_STATIC\_ASSERT(TYPE::SizeAtCompileTime==Eigen::Dynamic, \(\backslash\)}
00149 \textcolor{preprocessor}{                      YOU\_CALLED\_A\_DYNAMIC\_SIZE\_METHOD\_ON\_A\_FIXED\_SIZE\_MATRIX\_OR\_VECTOR)}
00150 
00151 \textcolor{comment}{// static assertion failing if the type \(\backslash\)a TYPE is not a vector type of the given size}
00152 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_VECTOR\_SPECIFIC\_SIZE(TYPE, SIZE) \(\backslash\)}
00153 \textcolor{preprocessor}{  EIGEN\_STATIC\_ASSERT(TYPE::IsVectorAtCompileTime && TYPE::SizeAtCompileTime==SIZE, \(\backslash\)}
00154 \textcolor{preprocessor}{                      THIS\_METHOD\_IS\_ONLY\_FOR\_VECTORS\_OF\_A\_SPECIFIC\_SIZE)}
00155 
00156 \textcolor{comment}{// static assertion failing if the type \(\backslash\)a TYPE is not a vector type of the given size}
00157 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_MATRIX\_SPECIFIC\_SIZE(TYPE, ROWS, COLS) \(\backslash\)}
00158 \textcolor{preprocessor}{  EIGEN\_STATIC\_ASSERT(TYPE::RowsAtCompileTime==ROWS && TYPE::ColsAtCompileTime==COLS, \(\backslash\)}
00159 \textcolor{preprocessor}{                      THIS\_METHOD\_IS\_ONLY\_FOR\_MATRICES\_OF\_A\_SPECIFIC\_SIZE)}
00160 
00161 \textcolor{comment}{// static assertion failing if the two vector expression types are not compatible (same fixed-size or
       dynamic size)}
00162 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_SAME\_VECTOR\_SIZE(TYPE0,TYPE1) \(\backslash\)}
00163 \textcolor{preprocessor}{  EIGEN\_STATIC\_ASSERT( \(\backslash\)}
00164 \textcolor{preprocessor}{      (int(TYPE0::SizeAtCompileTime)==Eigen::Dynamic \(\backslash\)}
00165 \textcolor{preprocessor}{    || int(TYPE1::SizeAtCompileTime)==Eigen::Dynamic \(\backslash\)}
00166 \textcolor{preprocessor}{    || int(TYPE0::SizeAtCompileTime)==int(TYPE1::SizeAtCompileTime)),\(\backslash\)}
00167 \textcolor{preprocessor}{    YOU\_MIXED\_VECTORS\_OF\_DIFFERENT\_SIZES)}
00168 
00169 \textcolor{preprocessor}{#define EIGEN\_PREDICATE\_SAME\_MATRIX\_SIZE(TYPE0,TYPE1) \(\backslash\)}
00170 \textcolor{preprocessor}{     ( \(\backslash\)}
00171 \textcolor{preprocessor}{        (int(Eigen::internal::size\_of\_xpr\_at\_compile\_time<TYPE0>::ret)==0 &&
       int(Eigen::internal::size\_of\_xpr\_at\_compile\_time<TYPE1>::ret)==0) \(\backslash\)}
00172 \textcolor{preprocessor}{    || (\(\backslash\)}
00173 \textcolor{preprocessor}{          (int(TYPE0::RowsAtCompileTime)==Eigen::Dynamic \(\backslash\)}
00174 \textcolor{preprocessor}{        || int(TYPE1::RowsAtCompileTime)==Eigen::Dynamic \(\backslash\)}
00175 \textcolor{preprocessor}{        || int(TYPE0::RowsAtCompileTime)==int(TYPE1::RowsAtCompileTime)) \(\backslash\)}
00176 \textcolor{preprocessor}{      &&  (int(TYPE0::ColsAtCompileTime)==Eigen::Dynamic \(\backslash\)}
00177 \textcolor{preprocessor}{        || int(TYPE1::ColsAtCompileTime)==Eigen::Dynamic \(\backslash\)}
00178 \textcolor{preprocessor}{        || int(TYPE0::ColsAtCompileTime)==int(TYPE1::ColsAtCompileTime))\(\backslash\)}
00179 \textcolor{preprocessor}{       ) \(\backslash\)}
00180 \textcolor{preprocessor}{     )}
00181 
00182 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_NON\_INTEGER(TYPE) \(\backslash\)}
00183 \textcolor{preprocessor}{    EIGEN\_STATIC\_ASSERT(!NumTraits<TYPE>::IsInteger, THIS\_FUNCTION\_IS\_NOT\_FOR\_INTEGER\_NUMERIC\_TYPES)}
00184 
00185 
00186 \textcolor{comment}{// static assertion failing if it is guaranteed at compile-time that the two matrix expression types have
       different sizes}
00187 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_SAME\_MATRIX\_SIZE(TYPE0,TYPE1) \(\backslash\)}
00188 \textcolor{preprocessor}{  EIGEN\_STATIC\_ASSERT( \(\backslash\)}
00189 \textcolor{preprocessor}{     EIGEN\_PREDICATE\_SAME\_MATRIX\_SIZE(TYPE0,TYPE1),\(\backslash\)}
00190 \textcolor{preprocessor}{    YOU\_MIXED\_MATRICES\_OF\_DIFFERENT\_SIZES)}
00191 
00192 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_SIZE\_1x1(TYPE) \(\backslash\)}
00193 \textcolor{preprocessor}{      EIGEN\_STATIC\_ASSERT((TYPE::RowsAtCompileTime == 1 || TYPE::RowsAtCompileTime == Dynamic) && \(\backslash\)}
00194 \textcolor{preprocessor}{                          (TYPE::ColsAtCompileTime == 1 || TYPE::ColsAtCompileTime == Dynamic), \(\backslash\)}
00195 \textcolor{preprocessor}{                          THIS\_METHOD\_IS\_ONLY\_FOR\_1x1\_EXPRESSIONS)}
00196 
00197 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_LVALUE(Derived) \(\backslash\)}
00198 \textcolor{preprocessor}{      EIGEN\_STATIC\_ASSERT(Eigen::internal::is\_lvalue<Derived>::value, \(\backslash\)}
00199 \textcolor{preprocessor}{                          THIS\_EXPRESSION\_IS\_NOT\_A\_LVALUE\_\_IT\_IS\_READ\_ONLY)}
00200 
00201 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_ARRAYXPR(Derived) \(\backslash\)}
00202 \textcolor{preprocessor}{      EIGEN\_STATIC\_ASSERT((Eigen::internal::is\_same<typename Eigen::internal::traits<Derived>::XprKind,
       ArrayXpr>::value), \(\backslash\)}
00203 \textcolor{preprocessor}{                          THIS\_METHOD\_IS\_ONLY\_FOR\_ARRAYS\_NOT\_MATRICES)}
00204 
00205 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_SAME\_XPR\_KIND(Derived1, Derived2) \(\backslash\)}
00206 \textcolor{preprocessor}{      EIGEN\_STATIC\_ASSERT((Eigen::internal::is\_same<typename Eigen::internal::traits<Derived1>::XprKind, \(\backslash\)}
00207 \textcolor{preprocessor}{                                             typename Eigen::internal::traits<Derived2>::XprKind \(\backslash\)}
00208 \textcolor{preprocessor}{                                            >::value), \(\backslash\)}
00209 \textcolor{preprocessor}{                          YOU\_CANNOT\_MIX\_ARRAYS\_AND\_MATRICES)}
00210 
00211 \textcolor{comment}{// Check that a cost value is positive, and that is stay within a reasonable range}
00212 \textcolor{comment}{// TODO this check could be enabled for internal debugging only}
00213 \textcolor{preprocessor}{#define EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(C) \(\backslash\)}
00214 \textcolor{preprocessor}{      EIGEN\_STATIC\_ASSERT((C)>=0 && (C)<=HugeCost*HugeCost,
       EIGEN\_INTERNAL\_ERROR\_PLEASE\_FILE\_A\_BUG\_REPORT\_\_INVALID\_COST\_VALUE);}
00215 
00216 \textcolor{preprocessor}{#endif // EIGEN\_STATIC\_ASSERT\_H}
\end{DoxyCode}
