\hypertarget{eigen_2test_2qr__colpivoting_8cpp_source}{}\section{eigen/test/qr\+\_\+colpivoting.cpp}
\label{eigen_2test_2qr__colpivoting_8cpp_source}\index{qr\+\_\+colpivoting.\+cpp@{qr\+\_\+colpivoting.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#include "main.h"}
00012 \textcolor{preprocessor}{#include <Eigen/QR>}
00013 \textcolor{preprocessor}{#include <Eigen/SVD>}
00014 
00015 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00016 \textcolor{keywordtype}{void} cod() \{
00017   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00018 
00019   Index rows = internal::random<Index>(2, EIGEN\_TEST\_MAX\_SIZE);
00020   Index cols = internal::random<Index>(2, EIGEN\_TEST\_MAX\_SIZE);
00021   Index cols2 = internal::random<Index>(2, EIGEN\_TEST\_MAX\_SIZE);
00022   Index rank = internal::random<Index>(1, (std::min)(rows, cols) - 1);
00023 
00024   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00025   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<Scalar, MatrixType::RowsAtCompileTime,
00026                  MatrixType::RowsAtCompileTime>
00027       MatrixQType;
00028   MatrixType matrix;
00029   \hyperlink{namespace_eigen_a0d9a7ddcee5c7c8defaba3628455efb2}{createRandomPIMatrixOfRank}(rank, rows, cols, matrix);
00030   \hyperlink{group___q_r___module_class_eigen_1_1_complete_orthogonal_decomposition}{CompleteOrthogonalDecomposition<MatrixType>} cod(matrix);
00031   VERIFY(rank == cod.rank());
00032   VERIFY(cols - cod.rank() == cod.dimensionOfKernel());
00033   VERIFY(!cod.isInjective());
00034   VERIFY(!cod.isInvertible());
00035   VERIFY(!cod.isSurjective());
00036 
00037   MatrixQType q = cod.householderQ();
00038   VERIFY\_IS\_UNITARY(q);
00039 
00040   MatrixType z = cod.matrixZ();
00041   VERIFY\_IS\_UNITARY(z);
00042 
00043   MatrixType t;
00044   t.setZero(rows, cols);
00045   t.topLeftCorner(rank, rank) =
00046       cod.matrixT().topLeftCorner(rank, rank).template triangularView<Upper>();
00047 
00048   MatrixType c = q * t * z * cod.colsPermutation().inverse();
00049   VERIFY\_IS\_APPROX(matrix, c);
00050 
00051   MatrixType exact\_solution = MatrixType::Random(cols, cols2);
00052   MatrixType rhs = matrix * exact\_solution;
00053   MatrixType cod\_solution = cod.solve(rhs);
00054   VERIFY\_IS\_APPROX(rhs, matrix * cod\_solution);
00055 
00056   \textcolor{comment}{// Verify that we get the same minimum-norm solution as the SVD.}
00057   \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD<MatrixType>} svd(matrix, \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9af8c742a1aa87773e165eae406c9ccaf8}{ComputeThinU} | 
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a1055e53fa95c8ae04a07ebb72cfafd95}{ComputeThinV});
00058   MatrixType svd\_solution = svd.solve(rhs);
00059   VERIFY\_IS\_APPROX(cod\_solution, svd\_solution);
00060 
00061   MatrixType pinv = cod.pseudoInverse();
00062   VERIFY\_IS\_APPROX(cod\_solution, pinv * rhs);
00063 \}
00064 
00065 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} Cols2>
00066 \textcolor{keywordtype}{void} cod\_fixedsize() \{
00067   \textcolor{keyword}{enum} \{
00068     Rows = MatrixType::RowsAtCompileTime,
00069     Cols = MatrixType::ColsAtCompileTime
00070   \};
00071   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00072   \textcolor{keywordtype}{int} rank = internal::random<int>(1, (std::min)(\textcolor{keywordtype}{int}(Rows), int(Cols)) - 1);
00073   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Rows, Cols>} matrix;
00074   \hyperlink{namespace_eigen_a0d9a7ddcee5c7c8defaba3628455efb2}{createRandomPIMatrixOfRank}(rank, Rows, Cols, matrix);
00075   \hyperlink{group___q_r___module_class_eigen_1_1_complete_orthogonal_decomposition}{CompleteOrthogonalDecomposition<Matrix<Scalar, Rows, Cols>}
       > cod(matrix);
00076   VERIFY(rank == cod.rank());
00077   VERIFY(Cols - cod.rank() == cod.dimensionOfKernel());
00078   VERIFY(cod.isInjective() == (rank == Rows));
00079   VERIFY(cod.isSurjective() == (rank == Cols));
00080   VERIFY(cod.isInvertible() == (cod.isInjective() && cod.isSurjective()));
00081 
00082   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Cols, Cols2>} exact\_solution;
00083   exact\_solution.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(Cols, Cols2);
00084   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Rows, Cols2>} rhs = matrix * exact\_solution;
00085   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Cols, Cols2>} cod\_solution = cod.solve(rhs);
00086   VERIFY\_IS\_APPROX(rhs, matrix * cod\_solution);
00087 
00088   \textcolor{comment}{// Verify that we get the same minimum-norm solution as the SVD.}
00089   \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD<MatrixType>} svd(matrix, \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a2b4f91ca5859a4159dbfe8090043817f}{ComputeFullU} | 
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a52c6f7e80bbf9a42297c88f700245b51}{ComputeFullV});
00090   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Cols, Cols2>} svd\_solution = svd.solve(rhs);
00091   VERIFY\_IS\_APPROX(cod\_solution, svd\_solution);
00092 \}
00093 
00094 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} qr()
00095 \{
00096   \textcolor{keyword}{using} std::sqrt;
00097   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index Index;
00098 
00099   Index rows = internal::random<Index>(2,EIGEN\_TEST\_MAX\_SIZE), cols = internal::random<Index>(2,
      EIGEN\_TEST\_MAX\_SIZE), cols2 = internal::random<Index>(2,EIGEN\_TEST\_MAX\_SIZE);
00100   Index rank = internal::random<Index>(1, (std::min)(rows, cols)-1);
00101 
00102   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00103   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00104   \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, MatrixType::RowsAtCompileTime>}
       MatrixQType;
00105   MatrixType m1;
00106   \hyperlink{namespace_eigen_a0d9a7ddcee5c7c8defaba3628455efb2}{createRandomPIMatrixOfRank}(rank,rows,cols,m1);
00107   \hyperlink{group___q_r___module}{ColPivHouseholderQR<MatrixType>} qr(m1);
00108   VERIFY\_IS\_EQUAL(rank, qr.rank());
00109   VERIFY\_IS\_EQUAL(cols - qr.rank(), qr.dimensionOfKernel());
00110   VERIFY(!qr.isInjective());
00111   VERIFY(!qr.isInvertible());
00112   VERIFY(!qr.isSurjective());
00113 
00114   MatrixQType q = qr.householderQ();
00115   VERIFY\_IS\_UNITARY(q);
00116 
00117   MatrixType r = qr.matrixQR().template triangularView<Upper>();
00118   MatrixType c = q * r * qr.colsPermutation().inverse();
00119   VERIFY\_IS\_APPROX(m1, c);
00120 
00121   \textcolor{comment}{// Verify that the absolute value of the diagonal elements in R are}
00122   \textcolor{comment}{// non-increasing until they reach the singularity threshold.}
00123   RealScalar threshold =
00124       sqrt(RealScalar(rows)) * numext::abs(r(0, 0)) * \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}(
      );
00125   \textcolor{keywordflow}{for} (Index i = 0; i < (std::min)(rows, cols) - 1; ++i) \{
00126     RealScalar x = numext::abs(r(i, i));
00127     RealScalar y = numext::abs(r(i + 1, i + 1));
00128     \textcolor{keywordflow}{if} (x < threshold && y < threshold) \textcolor{keywordflow}{continue};
00129     \textcolor{keywordflow}{if} (!test\_isApproxOrLessThan(y, x)) \{
00130       \textcolor{keywordflow}{for} (Index j = 0; j < (std::min)(rows, cols); ++j) \{
00131         std::cout << \textcolor{stringliteral}{"i = "} << j << \textcolor{stringliteral}{", |r\_ii| = "} << numext::abs(r(j, j)) << std::endl;
00132       \}
00133       std::cout << \textcolor{stringliteral}{"Failure at i="} << i << \textcolor{stringliteral}{", rank="} << rank
00134                 << \textcolor{stringliteral}{", threshold="} << threshold << std::endl;
00135     \}
00136     VERIFY\_IS\_APPROX\_OR\_LESS\_THAN(y, x);
00137   \}
00138 
00139   MatrixType m2 = MatrixType::Random(cols,cols2);
00140   MatrixType m3 = m1*m2;
00141   m2 = MatrixType::Random(cols,cols2);
00142   m2 = qr.solve(m3);
00143   VERIFY\_IS\_APPROX(m3, m1*m2);
00144 
00145   \{
00146     Index size = rows;
00147     \textcolor{keywordflow}{do} \{
00148       m1 = MatrixType::Random(size,size);
00149       qr.compute(m1);
00150     \} \textcolor{keywordflow}{while}(!qr.isInvertible());
00151     MatrixType m1\_inv = qr.inverse();
00152     m3 = m1 * MatrixType::Random(size,cols2);
00153     m2 = qr.solve(m3);
00154     VERIFY\_IS\_APPROX(m2, m1\_inv*m3);
00155   \}
00156 \}
00157 
00158 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} Cols2> \textcolor{keywordtype}{void} qr\_fixedsize()
00159 \{
00160   \textcolor{keyword}{using} std::sqrt;
00161   \textcolor{keyword}{using} std::abs;
00162   \textcolor{keyword}{enum} \{ Rows = MatrixType::RowsAtCompileTime, Cols = MatrixType::ColsAtCompileTime \};
00163   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00164   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00165   \textcolor{keywordtype}{int} rank = internal::random<int>(1, (std::min)(\textcolor{keywordtype}{int}(Rows), int(Cols))-1);
00166   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Rows,Cols>} m1;
00167   \hyperlink{namespace_eigen_a0d9a7ddcee5c7c8defaba3628455efb2}{createRandomPIMatrixOfRank}(rank,Rows,Cols,m1);
00168   \hyperlink{group___q_r___module_class_eigen_1_1_col_piv_householder_q_r}{ColPivHouseholderQR<Matrix<Scalar,Rows,Cols>} > qr(m1);
00169   VERIFY\_IS\_EQUAL(rank, qr.rank());
00170   VERIFY\_IS\_EQUAL(Cols - qr.rank(), qr.dimensionOfKernel());
00171   VERIFY\_IS\_EQUAL(qr.isInjective(), (rank == Rows));
00172   VERIFY\_IS\_EQUAL(qr.isSurjective(), (rank == Cols));
00173   VERIFY\_IS\_EQUAL(qr.isInvertible(), (qr.isInjective() && qr.isSurjective()));
00174 
00175   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Rows,Cols>} r = qr.matrixQR().template triangularView<Upper>();
00176   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Rows,Cols>} c = qr.householderQ() * r * qr.colsPermutation().inverse
      ();
00177   VERIFY\_IS\_APPROX(m1, c);
00178 
00179   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Cols,Cols2>} m2 = 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Cols,Cols2>::Random}(Cols,Cols2);
00180   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Rows,Cols2>} m3 = m1*m2;
00181   m2 = \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Cols,Cols2>::Random}(Cols,Cols2);
00182   m2 = qr.solve(m3);
00183   VERIFY\_IS\_APPROX(m3, m1*m2);
00184   \textcolor{comment}{// Verify that the absolute value of the diagonal elements in R are}
00185   \textcolor{comment}{// non-increasing until they reache the singularity threshold.}
00186   RealScalar threshold =
00187       sqrt(RealScalar(Rows)) * (std::abs)(r(0, 0)) * \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}()
      ;
00188   \textcolor{keywordflow}{for} (Index i = 0; i < (std::min)(\textcolor{keywordtype}{int}(Rows), int(Cols)) - 1; ++i) \{
00189     RealScalar x = numext::abs(r(i, i));
00190     RealScalar y = numext::abs(r(i + 1, i + 1));
00191     \textcolor{keywordflow}{if} (x < threshold && y < threshold) \textcolor{keywordflow}{continue};
00192     \textcolor{keywordflow}{if} (!test\_isApproxOrLessThan(y, x)) \{
00193       \textcolor{keywordflow}{for} (Index j = 0; j < (std::min)(\textcolor{keywordtype}{int}(Rows), \textcolor{keywordtype}{int}(Cols)); ++j) \{
00194         std::cout << \textcolor{stringliteral}{"i = "} << j << \textcolor{stringliteral}{", |r\_ii| = "} << numext::abs(r(j, j)) << std::endl;
00195       \}
00196       std::cout << \textcolor{stringliteral}{"Failure at i="} << i << \textcolor{stringliteral}{", rank="} << rank
00197                 << \textcolor{stringliteral}{", threshold="} << threshold << std::endl;
00198     \}
00199     VERIFY\_IS\_APPROX\_OR\_LESS\_THAN(y, x);
00200   \}
00201 \}
00202 
00203 \textcolor{comment}{// This test is meant to verify that pivots are chosen such that}
00204 \textcolor{comment}{// even for a graded matrix, the diagonal of R falls of roughly}
00205 \textcolor{comment}{// monotonically until it reaches the threshold for singularity.}
00206 \textcolor{comment}{// We use the so-called Kahan matrix, which is a famous counter-example}
00207 \textcolor{comment}{// for rank-revealing QR. See}
00208 \textcolor{comment}{// http://www.netlib.org/lapack/lawnspdf/lawn176.pdf}
00209 \textcolor{comment}{// page 3 for more detail.}
00210 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} qr\_kahan\_matrix()
00211 \{
00212   \textcolor{keyword}{using} std::sqrt;
00213   \textcolor{keyword}{using} std::abs;
00214   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index Index;
00215   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00216   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00217 
00218   Index rows = 300, cols = rows;
00219 
00220   MatrixType m1;
00221   m1.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}(rows,cols);
00222   RealScalar s = std::pow(\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::epsilon}(), 1.0 / rows);
00223   RealScalar c = std::sqrt(1 - s*s);
00224   RealScalar pow\_s\_i(1.0); \textcolor{comment}{// pow(s,i)}
00225   \textcolor{keywordflow}{for} (Index i = 0; i < rows; ++i) \{
00226     m1(i, i) = pow\_s\_i;
00227     m1.row(i).tail(rows - i - 1) = -pow\_s\_i * c * MatrixType::Ones(1, rows - i - 1);
00228     pow\_s\_i *= s;
00229   \}
00230   m1 = (m1 + m1.transpose()).eval();
00231   \hyperlink{group___q_r___module}{ColPivHouseholderQR<MatrixType>} qr(m1);
00232   MatrixType r = qr.matrixQR().template triangularView<Upper>();
00233 
00234   RealScalar threshold =
00235       std::sqrt(RealScalar(rows)) * numext::abs(r(0, 0)) * 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}();
00236   \textcolor{keywordflow}{for} (Index i = 0; i < (std::min)(rows, cols) - 1; ++i) \{
00237     RealScalar x = numext::abs(r(i, i));
00238     RealScalar y = numext::abs(r(i + 1, i + 1));
00239     \textcolor{keywordflow}{if} (x < threshold && y < threshold) \textcolor{keywordflow}{continue};
00240     \textcolor{keywordflow}{if} (!test\_isApproxOrLessThan(y, x)) \{
00241       \textcolor{keywordflow}{for} (Index j = 0; j < (std::min)(rows, cols); ++j) \{
00242         std::cout << \textcolor{stringliteral}{"i = "} << j << \textcolor{stringliteral}{", |r\_ii| = "} << numext::abs(r(j, j)) << std::endl;
00243       \}
00244       std::cout << \textcolor{stringliteral}{"Failure at i="} << i << \textcolor{stringliteral}{", rank="} << qr.rank()
00245                 << \textcolor{stringliteral}{", threshold="} << threshold << std::endl;
00246     \}
00247     VERIFY\_IS\_APPROX\_OR\_LESS\_THAN(y, x);
00248   \}
00249 \}
00250 
00251 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} qr\_invertible()
00252 \{
00253   \textcolor{keyword}{using} std::log;
00254   \textcolor{keyword}{using} std::abs;
00255   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename MatrixType::Scalar>::Real}
       RealScalar;
00256   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00257 
00258   \textcolor{keywordtype}{int} size = internal::random<int>(10,50);
00259 
00260   MatrixType m1(size, size), m2(size, size), m3(size, size);
00261   m1 = MatrixType::Random(size,size);
00262 
00263   \textcolor{keywordflow}{if} (internal::is\_same<RealScalar,float>::value)
00264   \{
00265     \textcolor{comment}{// let's build a matrix more stable to inverse}
00266     MatrixType a = MatrixType::Random(size,size*2);
00267     m1 += a * a.adjoint();
00268   \}
00269 
00270   \hyperlink{group___q_r___module}{ColPivHouseholderQR<MatrixType>} qr(m1);
00271   m3 = MatrixType::Random(size,size);
00272   m2 = qr.solve(m3);
00273   \textcolor{comment}{//VERIFY\_IS\_APPROX(m3, m1*m2);}
00274 
00275   \textcolor{comment}{// now construct a matrix with prescribed determinant}
00276   m1.setZero();
00277   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) m1(i,i) = internal::random<Scalar>();
00278   RealScalar absdet = abs(m1.diagonal().prod());
00279   m3 = qr.householderQ(); \textcolor{comment}{// get a unitary}
00280   m1 = m3 * m1 * m3;
00281   qr.compute(m1);
00282   VERIFY\_IS\_APPROX(absdet, qr.absDeterminant());
00283   VERIFY\_IS\_APPROX(\hyperlink{structlog}{log}(absdet), qr.logAbsDeterminant());
00284 \}
00285 
00286 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} qr\_verify\_assert()
00287 \{
00288   MatrixType tmp;
00289 
00290   \hyperlink{group___q_r___module}{ColPivHouseholderQR<MatrixType>} qr;
00291   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_aa572ac050c8d4fadd4f08a87f6b1e62b}{matrixQR}())
00292   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_aaa9c4af89930ab3bb7612ed9ae33d3f5}{solve}(tmp))
00293   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a28ab9d8916ca609c5469c4c192fbfa28}{householderQ}())
00294   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a7c9294565d179226133770160b827be1}{dimensionOfKernel}())
00295   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a0031998053c9c7345c9458f7443aa263}{isInjective}())
00296   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a87a7d06e0b0479e5b56b19c2a4f56365}{isSurjective}())
00297   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a945720f8d683f8ebe97fa807edd3142a}{isInvertible}())
00298   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a31c45402e74774d9cd13af0e57a6b72f}{inverse}())
00299   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_ac87c3bf42098d6f7324dafbc50fa83f7}{absDeterminant}())
00300   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_afdc29438a335871f67449c253369ce12}{logAbsDeterminant}())
00301 \}
00302 
00303 \textcolor{keywordtype}{void} test\_qr\_colpivoting()
00304 \{
00305   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00306     CALL\_SUBTEST\_1( qr<MatrixXf>() );
00307     CALL\_SUBTEST\_2( qr<MatrixXd>() );
00308     CALL\_SUBTEST\_3( qr<MatrixXcd>() );
00309     CALL\_SUBTEST\_4(( qr\_fixedsize<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,3,5>}, 4 >() ));
00310     CALL\_SUBTEST\_5(( qr\_fixedsize<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,6,2>}, 3 >() ));
00311     CALL\_SUBTEST\_5(( qr\_fixedsize<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,1,1>}, 1 >() ));
00312   \}
00313 
00314   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00315     CALL\_SUBTEST\_1( cod<MatrixXf>() );
00316     CALL\_SUBTEST\_2( cod<MatrixXd>() );
00317     CALL\_SUBTEST\_3( cod<MatrixXcd>() );
00318     CALL\_SUBTEST\_4(( cod\_fixedsize<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,3,5>}, 4 >() ));
00319     CALL\_SUBTEST\_5(( cod\_fixedsize<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,6,2>}, 3 >() ));
00320     CALL\_SUBTEST\_5(( cod\_fixedsize<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,1,1>}, 1 >() ));
00321   \}
00322 
00323   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00324     CALL\_SUBTEST\_1( qr\_invertible<MatrixXf>() );
00325     CALL\_SUBTEST\_2( qr\_invertible<MatrixXd>() );
00326     CALL\_SUBTEST\_6( qr\_invertible<MatrixXcf>() );
00327     CALL\_SUBTEST\_3( qr\_invertible<MatrixXcd>() );
00328   \}
00329 
00330   CALL\_SUBTEST\_7(qr\_verify\_assert<Matrix3f>());
00331   CALL\_SUBTEST\_8(qr\_verify\_assert<Matrix3d>());
00332   CALL\_SUBTEST\_1(qr\_verify\_assert<MatrixXf>());
00333   CALL\_SUBTEST\_2(qr\_verify\_assert<MatrixXd>());
00334   CALL\_SUBTEST\_6(qr\_verify\_assert<MatrixXcf>());
00335   CALL\_SUBTEST\_3(qr\_verify\_assert<MatrixXcd>());
00336 
00337   \textcolor{comment}{// Test problem size constructors}
00338   CALL\_SUBTEST\_9(\hyperlink{group___q_r___module_class_eigen_1_1_col_piv_householder_q_r}{ColPivHouseholderQR<MatrixXf>}(10, 20));
00339 
00340   CALL\_SUBTEST\_1( qr\_kahan\_matrix<MatrixXf>() );
00341   CALL\_SUBTEST\_2( qr\_kahan\_matrix<MatrixXd>() );
00342 \}
\end{DoxyCode}
