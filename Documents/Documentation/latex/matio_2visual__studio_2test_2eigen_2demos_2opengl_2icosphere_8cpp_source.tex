\hypertarget{matio_2visual__studio_2test_2eigen_2demos_2opengl_2icosphere_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/demos/opengl/icosphere.cpp}
\label{matio_2visual__studio_2test_2eigen_2demos_2opengl_2icosphere_8cpp_source}\index{icosphere.\+cpp@{icosphere.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "icosphere.h"}
00011 
00012 \textcolor{preprocessor}{#include <GL/gl.h>}
00013 \textcolor{preprocessor}{#include <map>}
00014 
00015 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00016 
00017 \textcolor{comment}{//--------------------------------------------------------------------------------}
00018 \textcolor{comment}{// icosahedron data}
00019 \textcolor{comment}{//--------------------------------------------------------------------------------}
00020 \textcolor{preprocessor}{#define X .525731112119133606}
00021 \textcolor{preprocessor}{#define Z .850650808352039932}
00022 
00023 \textcolor{keyword}{static} GLfloat vdata[12][3] = \{
00024    \{-X, 0.0, Z\}, \{X, 0.0, Z\}, \{-X, 0.0, -Z\}, \{X, 0.0, -Z\},
00025    \{0.0, Z, X\}, \{0.0, Z, -X\}, \{0.0, -Z, X\}, \{0.0, -Z, -X\},
00026    \{Z, X, 0.0\}, \{-Z, X, 0.0\}, \{Z, -X, 0.0\}, \{-Z, -X, 0.0\}
00027 \};
00028 
00029 \textcolor{keyword}{static} GLint tindices[20][3] = \{
00030    \{0,4,1\}, \{0,9,4\}, \{9,5,4\}, \{4,5,8\}, \{4,8,1\},
00031    \{8,10,1\}, \{8,3,10\}, \{5,3,8\}, \{5,2,3\}, \{2,7,3\},
00032    \{7,10,3\}, \{7,6,10\}, \{7,11,6\}, \{11,0,6\}, \{0,1,6\},
00033    \{6,1,10\}, \{9,0,11\}, \{9,11,2\}, \{9,2,5\}, \{7,2,11\} \};
00034 \textcolor{comment}{//--------------------------------------------------------------------------------}
00035 
00036 IcoSphere::IcoSphere(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} levels)
00037 \{
00038   \textcolor{comment}{// init with an icosahedron}
00039   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 12; i++)
00040     mVertices.push\_back(\hyperlink{group___core___module_class_eigen_1_1_map}{Map<Vector3f>}(vdata[i]));
00041   mIndices.push\_back(\textcolor{keyword}{new} std::vector<int>);
00042   std::vector<int>& indices = *mIndices.back();
00043   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00044   \{
00045     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 0; k < 3; k++)
00046       indices.push\_back(tindices[i][k]);
00047   \}
00048   mListIds.push\_back(0);
00049 
00050   \textcolor{keywordflow}{while}(mIndices.size()<levels)
00051     \_subdivide();
00052 \}
00053 
00054 \textcolor{keyword}{const} std::vector<int>& IcoSphere::indices(\textcolor{keywordtype}{int} level)\textcolor{keyword}{ const}
00055 \textcolor{keyword}{}\{
00056   \textcolor{keywordflow}{while} (level>=\textcolor{keywordtype}{int}(mIndices.size()))
00057     \textcolor{keyword}{const\_cast<}\hyperlink{class_ico_sphere}{IcoSphere}*\textcolor{keyword}{>}(\textcolor{keyword}{this})->\_subdivide();
00058   \textcolor{keywordflow}{return} *mIndices[level];
00059 \}
00060 
00061 \textcolor{keywordtype}{void} IcoSphere::\_subdivide(\textcolor{keywordtype}{void})
00062 \{
00063   \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} Key;
00064   std::map<Key,int> edgeMap;
00065   \textcolor{keyword}{const} std::vector<int>& indices = *mIndices.back();
00066   mIndices.push\_back(\textcolor{keyword}{new} std::vector<int>);
00067   std::vector<int>& refinedIndices = *mIndices.back();
00068   \textcolor{keywordtype}{int} end = indices.size();
00069   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<end; i+=3)
00070   \{
00071     \textcolor{keywordtype}{int} ids0[3],  \textcolor{comment}{// indices of outer vertices}
00072         ids1[3];  \textcolor{comment}{// indices of edge vertices}
00073     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<3; ++k)
00074     \{
00075       \textcolor{keywordtype}{int} k1 = (k+1)%3;
00076       \textcolor{keywordtype}{int} e0 = indices[i+k];
00077       \textcolor{keywordtype}{int} e1 = indices[i+k1];
00078       ids0[k] = e0;
00079       \textcolor{keywordflow}{if} (e1>e0)
00080         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(e0,e1);
00081       Key edgeKey = Key(e0) | (Key(e1)<<32);
00082       std::map<Key,int>::iterator it = edgeMap.find(edgeKey);
00083       \textcolor{keywordflow}{if} (it==edgeMap.end())
00084       \{
00085         ids1[k] = mVertices.size();
00086         edgeMap[edgeKey] = ids1[k];
00087         mVertices.push\_back( (mVertices[e0]+mVertices[e1]).normalized() );
00088       \}
00089       \textcolor{keywordflow}{else}
00090         ids1[k] = it->second;
00091     \}
00092     refinedIndices.push\_back(ids0[0]); refinedIndices.push\_back(ids1[0]); refinedIndices.push\_back(ids1[2])
      ;
00093     refinedIndices.push\_back(ids0[1]); refinedIndices.push\_back(ids1[1]); refinedIndices.push\_back(ids1[0])
      ;
00094     refinedIndices.push\_back(ids0[2]); refinedIndices.push\_back(ids1[2]); refinedIndices.push\_back(ids1[1])
      ;
00095     refinedIndices.push\_back(ids1[0]); refinedIndices.push\_back(ids1[1]); refinedIndices.push\_back(ids1[2])
      ;
00096   \}
00097   mListIds.push\_back(0);
00098 \}
00099 
00100 \textcolor{keywordtype}{void} IcoSphere::draw(\textcolor{keywordtype}{int} level)
00101 \{
00102   \textcolor{keywordflow}{while} (level>=\textcolor{keywordtype}{int}(mIndices.size()))
00103     \textcolor{keyword}{const\_cast<}\hyperlink{class_ico_sphere}{IcoSphere}*\textcolor{keyword}{>}(\textcolor{keyword}{this})->\_subdivide();
00104   \textcolor{keywordflow}{if} (mListIds[level]==0)
00105   \{
00106     mListIds[level] = glGenLists(1);
00107     glNewList(mListIds[level], GL\_COMPILE);
00108       glVertexPointer(3, GL\_FLOAT, 0, mVertices[0].data());
00109       glNormalPointer(GL\_FLOAT, 0, mVertices[0].data());
00110       glEnableClientState(GL\_VERTEX\_ARRAY);
00111       glEnableClientState(GL\_NORMAL\_ARRAY);
00112       glDrawElements(GL\_TRIANGLES, mIndices[level]->size(), GL\_UNSIGNED\_INT, &(mIndices[level]->at(0)));
00113       glDisableClientState(GL\_VERTEX\_ARRAY);
00114       glDisableClientState(GL\_NORMAL\_ARRAY);
00115     glEndList();
00116   \}
00117   glCallList(mListIds[level]);
00118 \}
00119 
00120 
\end{DoxyCode}
