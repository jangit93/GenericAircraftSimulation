\hypertarget{zlib_2zlib_8h_source}{}\section{zlib/zlib.h}
\label{zlib_2zlib_8h_source}\index{zlib.\+h@{zlib.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* zlib.h -- interface of the 'zlib' general purpose compression library}
00002 \textcolor{comment}{  version 1.2.11, January 15th, 2017}
00003 \textcolor{comment}{}
00004 \textcolor{comment}{  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler}
00005 \textcolor{comment}{}
00006 \textcolor{comment}{  This software is provided 'as-is', without any express or implied}
00007 \textcolor{comment}{  warranty.  In no event will the authors be held liable for any damages}
00008 \textcolor{comment}{  arising from the use of this software.}
00009 \textcolor{comment}{}
00010 \textcolor{comment}{  Permission is granted to anyone to use this software for any purpose,}
00011 \textcolor{comment}{  including commercial applications, and to alter it and redistribute it}
00012 \textcolor{comment}{  freely, subject to the following restrictions:}
00013 \textcolor{comment}{}
00014 \textcolor{comment}{  1. The origin of this software must not be misrepresented; you must not}
00015 \textcolor{comment}{     claim that you wrote the original software. If you use this software}
00016 \textcolor{comment}{     in a product, an acknowledgment in the product documentation would be}
00017 \textcolor{comment}{     appreciated but is not required.}
00018 \textcolor{comment}{  2. Altered source versions must be plainly marked as such, and must not be}
00019 \textcolor{comment}{     misrepresented as being the original software.}
00020 \textcolor{comment}{  3. This notice may not be removed or altered from any source distribution.}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{  Jean-loup Gailly        Mark Adler}
00023 \textcolor{comment}{  jloup@gzip.org          madler@alumni.caltech.edu}
00024 \textcolor{comment}{}
00025 \textcolor{comment}{}
00026 \textcolor{comment}{  The data format used by the zlib library is described by RFCs (Request for}
00027 \textcolor{comment}{  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950}
00028 \textcolor{comment}{  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).}
00029 \textcolor{comment}{*/}
00030 
00031 \textcolor{preprocessor}{#ifndef ZLIB\_H}
00032 \textcolor{preprocessor}{#define ZLIB\_H}
00033 
00034 \textcolor{preprocessor}{#include "zconf.h"}
00035 
00036 \textcolor{preprocessor}{#ifdef \_\_cplusplus}
00037 \textcolor{keyword}{extern} \textcolor{stringliteral}{"C"} \{
00038 \textcolor{preprocessor}{#endif}
00039 
00040 \textcolor{preprocessor}{#define ZLIB\_VERSION "1.2.11"}
00041 \textcolor{preprocessor}{#define ZLIB\_VERNUM 0x12b0}
00042 \textcolor{preprocessor}{#define ZLIB\_VER\_MAJOR 1}
00043 \textcolor{preprocessor}{#define ZLIB\_VER\_MINOR 2}
00044 \textcolor{preprocessor}{#define ZLIB\_VER\_REVISION 11}
00045 \textcolor{preprocessor}{#define ZLIB\_VER\_SUBREVISION 0}
00046 
00047 \textcolor{comment}{/*}
00048 \textcolor{comment}{    The 'zlib' compression library provides in-memory compression and}
00049 \textcolor{comment}{  decompression functions, including integrity checks of the uncompressed data.}
00050 \textcolor{comment}{  This version of the library supports only one compression method (deflation)}
00051 \textcolor{comment}{  but other algorithms will be added later and will have the same stream}
00052 \textcolor{comment}{  interface.}
00053 \textcolor{comment}{}
00054 \textcolor{comment}{    Compression can be done in a single step if the buffers are large enough,}
00055 \textcolor{comment}{  or can be done by repeated calls of the compression function.  In the latter}
00056 \textcolor{comment}{  case, the application must provide more input and/or consume the output}
00057 \textcolor{comment}{  (providing more output space) before each call.}
00058 \textcolor{comment}{}
00059 \textcolor{comment}{    The compressed data format used by default by the in-memory functions is}
00060 \textcolor{comment}{  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped}
00061 \textcolor{comment}{  around a deflate stream, which is itself documented in RFC 1951.}
00062 \textcolor{comment}{}
00063 \textcolor{comment}{    The library also supports reading and writing files in gzip (.gz) format}
00064 \textcolor{comment}{  with an interface similar to that of stdio using the functions that start}
00065 \textcolor{comment}{  with "gz".  The gzip format is different from the zlib format.  gzip is a}
00066 \textcolor{comment}{  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.}
00067 \textcolor{comment}{}
00068 \textcolor{comment}{    This library can optionally read and write gzip and raw deflate streams in}
00069 \textcolor{comment}{  memory as well.}
00070 \textcolor{comment}{}
00071 \textcolor{comment}{    The zlib format was designed to be compact and fast for use in memory}
00072 \textcolor{comment}{  and on communications channels.  The gzip format was designed for single-}
00073 \textcolor{comment}{  file compression on file systems, has a larger header than zlib to maintain}
00074 \textcolor{comment}{  directory information, and uses a different, slower check method than zlib.}
00075 \textcolor{comment}{}
00076 \textcolor{comment}{    The library does not install any signal handler.  The decoder checks}
00077 \textcolor{comment}{  the consistency of the compressed data, so the library should never crash}
00078 \textcolor{comment}{  even in the case of corrupted input.}
00079 \textcolor{comment}{*/}
00080 
00081 \textcolor{keyword}{typedef} voidpf (*alloc\_func) OF((voidpf opaque, uInt items, uInt size));
00082 \textcolor{keyword}{typedef} void   (*free\_func)  OF((voidpf opaque, voidpf address));
00083 
00084 \textcolor{keyword}{struct }\hyperlink{structinternal__state}{internal\_state};
00085 
00086 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structz__stream__s}{z\_stream\_s} \{
00087     z\_const Bytef *next\_in;     \textcolor{comment}{/* next input byte */}
00088     uInt     avail\_in;  \textcolor{comment}{/* number of bytes available at next\_in */}
00089     uLong    total\_in;  \textcolor{comment}{/* total number of input bytes read so far */}
00090 
00091     Bytef    *next\_out; \textcolor{comment}{/* next output byte will go here */}
00092     uInt     avail\_out; \textcolor{comment}{/* remaining free space at next\_out */}
00093     uLong    total\_out; \textcolor{comment}{/* total number of bytes output so far */}
00094 
00095     z\_const \textcolor{keywordtype}{char} *msg;  \textcolor{comment}{/* last error message, NULL if no error */}
00096     \textcolor{keyword}{struct }\hyperlink{structinternal__state}{internal\_state} FAR *\hyperlink{structstate}{state}; \textcolor{comment}{/* not visible by applications */}
00097 
00098     alloc\_func zalloc;  \textcolor{comment}{/* used to allocate the internal state */}
00099     free\_func  zfree;   \textcolor{comment}{/* used to free the internal state */}
00100     voidpf     opaque;  \textcolor{comment}{/* private data object passed to zalloc and zfree */}
00101 
00102     \textcolor{keywordtype}{int}     data\_type;  \textcolor{comment}{/* best guess about the data type: binary or text}
00103 \textcolor{comment}{                           for deflate, or the decoding state for inflate */}
00104     uLong   adler;      \textcolor{comment}{/* Adler-32 or CRC-32 value of the uncompressed data */}
00105     uLong   reserved;   \textcolor{comment}{/* reserved for future use */}
00106 \} \hyperlink{structz__stream__s}{z\_stream};
00107 
00108 \textcolor{keyword}{typedef} \hyperlink{structz__stream__s}{z\_stream} FAR *z\_streamp;
00109 
00110 \textcolor{comment}{/*}
00111 \textcolor{comment}{     gzip header information passed to and from zlib routines.  See RFC 1952}
00112 \textcolor{comment}{  for more details on the meanings of these fields.}
00113 \textcolor{comment}{*/}
00114 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structgz__header__s}{gz\_header\_s} \{
00115     \textcolor{keywordtype}{int}     text;       \textcolor{comment}{/* true if compressed data believed to be text */}
00116     uLong   time;       \textcolor{comment}{/* modification time */}
00117     \textcolor{keywordtype}{int}     xflags;     \textcolor{comment}{/* extra flags (not used when writing a gzip file) */}
00118     \textcolor{keywordtype}{int}     os;         \textcolor{comment}{/* operating system */}
00119     Bytef   *extra;     \textcolor{comment}{/* pointer to extra field or Z\_NULL if none */}
00120     uInt    extra\_len;  \textcolor{comment}{/* extra field length (valid if extra != Z\_NULL) */}
00121     uInt    extra\_max;  \textcolor{comment}{/* space at extra (only when reading header) */}
00122     Bytef   *name;      \textcolor{comment}{/* pointer to zero-terminated file name or Z\_NULL */}
00123     uInt    name\_max;   \textcolor{comment}{/* space at name (only when reading header) */}
00124     Bytef   *comment;   \textcolor{comment}{/* pointer to zero-terminated comment or Z\_NULL */}
00125     uInt    comm\_max;   \textcolor{comment}{/* space at comment (only when reading header) */}
00126     \textcolor{keywordtype}{int}     hcrc;       \textcolor{comment}{/* true if there was or will be a header crc */}
00127     \textcolor{keywordtype}{int}     done;       \textcolor{comment}{/* true when done reading gzip header (not used}
00128 \textcolor{comment}{                           when writing a gzip file) */}
00129 \} \hyperlink{structgz__header__s}{gz\_header};
00130 
00131 \textcolor{keyword}{typedef} \hyperlink{structgz__header__s}{gz\_header} FAR *gz\_headerp;
00132 
00133 \textcolor{comment}{/*}
00134 \textcolor{comment}{     The application must update next\_in and avail\_in when avail\_in has dropped}
00135 \textcolor{comment}{   to zero.  It must update next\_out and avail\_out when avail\_out has dropped}
00136 \textcolor{comment}{   to zero.  The application must initialize zalloc, zfree and opaque before}
00137 \textcolor{comment}{   calling the init function.  All other fields are set by the compression}
00138 \textcolor{comment}{   library and must not be updated by the application.}
00139 \textcolor{comment}{}
00140 \textcolor{comment}{     The opaque value provided by the application will be passed as the first}
00141 \textcolor{comment}{   parameter for calls of zalloc and zfree.  This can be useful for custom}
00142 \textcolor{comment}{   memory management.  The compression library attaches no meaning to the}
00143 \textcolor{comment}{   opaque value.}
00144 \textcolor{comment}{}
00145 \textcolor{comment}{     zalloc must return Z\_NULL if there is not enough memory for the object.}
00146 \textcolor{comment}{   If zlib is used in a multi-threaded application, zalloc and zfree must be}
00147 \textcolor{comment}{   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are}
00148 \textcolor{comment}{   Z\_NULL on entry to the initialization function, they are set to internal}
00149 \textcolor{comment}{   routines that use the standard library functions malloc() and free().}
00150 \textcolor{comment}{}
00151 \textcolor{comment}{     On 16-bit systems, the functions zalloc and zfree must be able to allocate}
00152 \textcolor{comment}{   exactly 65536 bytes, but will not be required to allocate more than this if}
00153 \textcolor{comment}{   the symbol MAXSEG\_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers}
00154 \textcolor{comment}{   returned by zalloc for objects of exactly 65536 bytes *must* have their}
00155 \textcolor{comment}{   offset normalized to zero.  The default allocation function provided by this}
00156 \textcolor{comment}{   library ensures this (see zutil.c).  To reduce memory requirements and avoid}
00157 \textcolor{comment}{   any allocation of 64K objects, at the expense of compression ratio, compile}
00158 \textcolor{comment}{   the library with -DMAX\_WBITS=14 (see zconf.h).}
00159 \textcolor{comment}{}
00160 \textcolor{comment}{     The fields total\_in and total\_out can be used for statistics or progress}
00161 \textcolor{comment}{   reports.  After compression, total\_in holds the total size of the}
00162 \textcolor{comment}{   uncompressed data and may be saved for use by the decompressor (particularly}
00163 \textcolor{comment}{   if the decompressor wants to decompress everything in a single step).}
00164 \textcolor{comment}{*/}
00165 
00166                         \textcolor{comment}{/* constants */}
00167 
00168 \textcolor{preprocessor}{#define Z\_NO\_FLUSH      0}
00169 \textcolor{preprocessor}{#define Z\_PARTIAL\_FLUSH 1}
00170 \textcolor{preprocessor}{#define Z\_SYNC\_FLUSH    2}
00171 \textcolor{preprocessor}{#define Z\_FULL\_FLUSH    3}
00172 \textcolor{preprocessor}{#define Z\_FINISH        4}
00173 \textcolor{preprocessor}{#define Z\_BLOCK         5}
00174 \textcolor{preprocessor}{#define Z\_TREES         6}
00175 \textcolor{comment}{/* Allowed flush values; see deflate() and inflate() below for details */}
00176 
00177 \textcolor{preprocessor}{#define Z\_OK            0}
00178 \textcolor{preprocessor}{#define Z\_STREAM\_END    1}
00179 \textcolor{preprocessor}{#define Z\_NEED\_DICT     2}
00180 \textcolor{preprocessor}{#define Z\_ERRNO        (-1)}
00181 \textcolor{preprocessor}{#define Z\_STREAM\_ERROR (-2)}
00182 \textcolor{preprocessor}{#define Z\_DATA\_ERROR   (-3)}
00183 \textcolor{preprocessor}{#define Z\_MEM\_ERROR    (-4)}
00184 \textcolor{preprocessor}{#define Z\_BUF\_ERROR    (-5)}
00185 \textcolor{preprocessor}{#define Z\_VERSION\_ERROR (-6)}
00186 \textcolor{comment}{/* Return codes for the compression/decompression functions. Negative values}
00187 \textcolor{comment}{ * are errors, positive values are used for special but normal events.}
00188 \textcolor{comment}{ */}
00189 
00190 \textcolor{preprocessor}{#define Z\_NO\_COMPRESSION         0}
00191 \textcolor{preprocessor}{#define Z\_BEST\_SPEED             1}
00192 \textcolor{preprocessor}{#define Z\_BEST\_COMPRESSION       9}
00193 \textcolor{preprocessor}{#define Z\_DEFAULT\_COMPRESSION  (-1)}
00194 \textcolor{comment}{/* compression levels */}
00195 
00196 \textcolor{preprocessor}{#define Z\_FILTERED            1}
00197 \textcolor{preprocessor}{#define Z\_HUFFMAN\_ONLY        2}
00198 \textcolor{preprocessor}{#define Z\_RLE                 3}
00199 \textcolor{preprocessor}{#define Z\_FIXED               4}
00200 \textcolor{preprocessor}{#define Z\_DEFAULT\_STRATEGY    0}
00201 \textcolor{comment}{/* compression strategy; see deflateInit2() below for details */}
00202 
00203 \textcolor{preprocessor}{#define Z\_BINARY   0}
00204 \textcolor{preprocessor}{#define Z\_TEXT     1}
00205 \textcolor{preprocessor}{#define Z\_ASCII    Z\_TEXT   }\textcolor{comment}{/* for compatibility with 1.2.2 and earlier */}\textcolor{preprocessor}{}
00206 \textcolor{preprocessor}{#define Z\_UNKNOWN  2}
00207 \textcolor{comment}{/* Possible values of the data\_type field for deflate() */}
00208 
00209 \textcolor{preprocessor}{#define Z\_DEFLATED   8}
00210 \textcolor{comment}{/* The deflate compression method (the only one supported in this version) */}
00211 
00212 \textcolor{preprocessor}{#define Z\_NULL  0  }\textcolor{comment}{/* for initializing zalloc, zfree, opaque */}\textcolor{preprocessor}{}
00213 
00214 \textcolor{preprocessor}{#define zlib\_version zlibVersion()}
00215 \textcolor{comment}{/* for compatibility with versions < 1.0.2 */}
00216 
00217 
00218                         \textcolor{comment}{/* basic functions */}
00219 
00220 ZEXTERN \textcolor{keyword}{const} \textcolor{keywordtype}{char} * ZEXPORT zlibVersion OF((\textcolor{keywordtype}{void}));
00221 \textcolor{comment}{/* The application can compare zlibVersion and ZLIB\_VERSION for consistency.}
00222 \textcolor{comment}{   If the first character differs, the library code actually used is not}
00223 \textcolor{comment}{   compatible with the zlib.h header file used by the application.  This check}
00224 \textcolor{comment}{   is automatically made by deflateInit and inflateInit.}
00225 \textcolor{comment}{ */}
00226 
00227 \textcolor{comment}{/*}
00228 \textcolor{comment}{ZEXTERN int ZEXPORT deflateInit OF((z\_streamp strm, int level));}
00229 \textcolor{comment}{}
00230 \textcolor{comment}{     Initializes the internal stream state for compression.  The fields}
00231 \textcolor{comment}{   zalloc, zfree and opaque must be initialized before by the caller.  If}
00232 \textcolor{comment}{   zalloc and zfree are set to Z\_NULL, deflateInit updates them to use default}
00233 \textcolor{comment}{   allocation functions.}
00234 \textcolor{comment}{}
00235 \textcolor{comment}{     The compression level must be Z\_DEFAULT\_COMPRESSION, or between 0 and 9:}
00236 \textcolor{comment}{   1 gives best speed, 9 gives best compression, 0 gives no compression at all}
00237 \textcolor{comment}{   (the input data is simply copied a block at a time).  Z\_DEFAULT\_COMPRESSION}
00238 \textcolor{comment}{   requests a default compromise between speed and compression (currently}
00239 \textcolor{comment}{   equivalent to level 6).}
00240 \textcolor{comment}{}
00241 \textcolor{comment}{     deflateInit returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough}
00242 \textcolor{comment}{   memory, Z\_STREAM\_ERROR if level is not a valid compression level, or}
00243 \textcolor{comment}{   Z\_VERSION\_ERROR if the zlib library version (zlib\_version) is incompatible}
00244 \textcolor{comment}{   with the version assumed by the caller (ZLIB\_VERSION).  msg is set to null}
00245 \textcolor{comment}{   if there is no error message.  deflateInit does not perform any compression:}
00246 \textcolor{comment}{   this will be done by deflate().}
00247 \textcolor{comment}{*/}
00248 
00249 
00250 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflate OF((z\_streamp strm, \textcolor{keywordtype}{int} flush));
00251 \textcolor{comment}{/*}
00252 \textcolor{comment}{    deflate compresses as much data as possible, and stops when the input}
00253 \textcolor{comment}{  buffer becomes empty or the output buffer becomes full.  It may introduce}
00254 \textcolor{comment}{  some output latency (reading input without producing any output) except when}
00255 \textcolor{comment}{  forced to flush.}
00256 \textcolor{comment}{}
00257 \textcolor{comment}{    The detailed semantics are as follows.  deflate performs one or both of the}
00258 \textcolor{comment}{  following actions:}
00259 \textcolor{comment}{}
00260 \textcolor{comment}{  - Compress more input starting at next\_in and update next\_in and avail\_in}
00261 \textcolor{comment}{    accordingly.  If not all input can be processed (because there is not}
00262 \textcolor{comment}{    enough room in the output buffer), next\_in and avail\_in are updated and}
00263 \textcolor{comment}{    processing will resume at this point for the next call of deflate().}
00264 \textcolor{comment}{}
00265 \textcolor{comment}{  - Generate more output starting at next\_out and update next\_out and avail\_out}
00266 \textcolor{comment}{    accordingly.  This action is forced if the parameter flush is non zero.}
00267 \textcolor{comment}{    Forcing flush frequently degrades the compression ratio, so this parameter}
00268 \textcolor{comment}{    should be set only when necessary.  Some output may be provided even if}
00269 \textcolor{comment}{    flush is zero.}
00270 \textcolor{comment}{}
00271 \textcolor{comment}{    Before the call of deflate(), the application should ensure that at least}
00272 \textcolor{comment}{  one of the actions is possible, by providing more input and/or consuming more}
00273 \textcolor{comment}{  output, and updating avail\_in or avail\_out accordingly; avail\_out should}
00274 \textcolor{comment}{  never be zero before the call.  The application can consume the compressed}
00275 \textcolor{comment}{  output when it wants, for example when the output buffer is full (avail\_out}
00276 \textcolor{comment}{  == 0), or after each call of deflate().  If deflate returns Z\_OK and with}
00277 \textcolor{comment}{  zero avail\_out, it must be called again after making room in the output}
00278 \textcolor{comment}{  buffer because there might be more output pending. See deflatePending(),}
00279 \textcolor{comment}{  which can be used if desired to determine whether or not there is more ouput}
00280 \textcolor{comment}{  in that case.}
00281 \textcolor{comment}{}
00282 \textcolor{comment}{    Normally the parameter flush is set to Z\_NO\_FLUSH, which allows deflate to}
00283 \textcolor{comment}{  decide how much data to accumulate before producing output, in order to}
00284 \textcolor{comment}{  maximize compression.}
00285 \textcolor{comment}{}
00286 \textcolor{comment}{    If the parameter flush is set to Z\_SYNC\_FLUSH, all pending output is}
00287 \textcolor{comment}{  flushed to the output buffer and the output is aligned on a byte boundary, so}
00288 \textcolor{comment}{  that the decompressor can get all input data available so far.  (In}
00289 \textcolor{comment}{  particular avail\_in is zero after the call if enough output space has been}
00290 \textcolor{comment}{  provided before the call.) Flushing may degrade compression for some}
00291 \textcolor{comment}{  compression algorithms and so it should be used only when necessary.  This}
00292 \textcolor{comment}{  completes the current deflate block and follows it with an empty stored block}
00293 \textcolor{comment}{  that is three bits plus filler bits to the next byte, followed by four bytes}
00294 \textcolor{comment}{  (00 00 ff ff).}
00295 \textcolor{comment}{}
00296 \textcolor{comment}{    If flush is set to Z\_PARTIAL\_FLUSH, all pending output is flushed to the}
00297 \textcolor{comment}{  output buffer, but the output is not aligned to a byte boundary.  All of the}
00298 \textcolor{comment}{  input data so far will be available to the decompressor, as for Z\_SYNC\_FLUSH.}
00299 \textcolor{comment}{  This completes the current deflate block and follows it with an empty fixed}
00300 \textcolor{comment}{  codes block that is 10 bits long.  This assures that enough bytes are output}
00301 \textcolor{comment}{  in order for the decompressor to finish the block before the empty fixed}
00302 \textcolor{comment}{  codes block.}
00303 \textcolor{comment}{}
00304 \textcolor{comment}{    If flush is set to Z\_BLOCK, a deflate block is completed and emitted, as}
00305 \textcolor{comment}{  for Z\_SYNC\_FLUSH, but the output is not aligned on a byte boundary, and up to}
00306 \textcolor{comment}{  seven bits of the current block are held to be written as the next byte after}
00307 \textcolor{comment}{  the next deflate block is completed.  In this case, the decompressor may not}
00308 \textcolor{comment}{  be provided enough bits at this point in order to complete decompression of}
00309 \textcolor{comment}{  the data provided so far to the compressor.  It may need to wait for the next}
00310 \textcolor{comment}{  block to be emitted.  This is for advanced applications that need to control}
00311 \textcolor{comment}{  the emission of deflate blocks.}
00312 \textcolor{comment}{}
00313 \textcolor{comment}{    If flush is set to Z\_FULL\_FLUSH, all output is flushed as with}
00314 \textcolor{comment}{  Z\_SYNC\_FLUSH, and the compression state is reset so that decompression can}
00315 \textcolor{comment}{  restart from this point if previous compressed data has been damaged or if}
00316 \textcolor{comment}{  random access is desired.  Using Z\_FULL\_FLUSH too often can seriously degrade}
00317 \textcolor{comment}{  compression.}
00318 \textcolor{comment}{}
00319 \textcolor{comment}{    If deflate returns with avail\_out == 0, this function must be called again}
00320 \textcolor{comment}{  with the same value of the flush parameter and more output space (updated}
00321 \textcolor{comment}{  avail\_out), until the flush is complete (deflate returns with non-zero}
00322 \textcolor{comment}{  avail\_out).  In the case of a Z\_FULL\_FLUSH or Z\_SYNC\_FLUSH, make sure that}
00323 \textcolor{comment}{  avail\_out is greater than six to avoid repeated flush markers due to}
00324 \textcolor{comment}{  avail\_out == 0 on return.}
00325 \textcolor{comment}{}
00326 \textcolor{comment}{    If the parameter flush is set to Z\_FINISH, pending input is processed,}
00327 \textcolor{comment}{  pending output is flushed and deflate returns with Z\_STREAM\_END if there was}
00328 \textcolor{comment}{  enough output space.  If deflate returns with Z\_OK or Z\_BUF\_ERROR, this}
00329 \textcolor{comment}{  function must be called again with Z\_FINISH and more output space (updated}
00330 \textcolor{comment}{  avail\_out) but no more input data, until it returns with Z\_STREAM\_END or an}
00331 \textcolor{comment}{  error.  After deflate has returned Z\_STREAM\_END, the only possible operations}
00332 \textcolor{comment}{  on the stream are deflateReset or deflateEnd.}
00333 \textcolor{comment}{}
00334 \textcolor{comment}{    Z\_FINISH can be used in the first deflate call after deflateInit if all the}
00335 \textcolor{comment}{  compression is to be done in a single step.  In order to complete in one}
00336 \textcolor{comment}{  call, avail\_out must be at least the value returned by deflateBound (see}
00337 \textcolor{comment}{  below).  Then deflate is guaranteed to return Z\_STREAM\_END.  If not enough}
00338 \textcolor{comment}{  output space is provided, deflate will not return Z\_STREAM\_END, and it must}
00339 \textcolor{comment}{  be called again as described above.}
00340 \textcolor{comment}{}
00341 \textcolor{comment}{    deflate() sets strm->adler to the Adler-32 checksum of all input read}
00342 \textcolor{comment}{  so far (that is, total\_in bytes).  If a gzip stream is being generated, then}
00343 \textcolor{comment}{  strm->adler will be the CRC-32 checksum of the input read so far.  (See}
00344 \textcolor{comment}{  deflateInit2 below.)}
00345 \textcolor{comment}{}
00346 \textcolor{comment}{    deflate() may update strm->data\_type if it can make a good guess about}
00347 \textcolor{comment}{  the input data type (Z\_BINARY or Z\_TEXT).  If in doubt, the data is}
00348 \textcolor{comment}{  considered binary.  This field is only for information purposes and does not}
00349 \textcolor{comment}{  affect the compression algorithm in any manner.}
00350 \textcolor{comment}{}
00351 \textcolor{comment}{    deflate() returns Z\_OK if some progress has been made (more input}
00352 \textcolor{comment}{  processed or more output produced), Z\_STREAM\_END if all input has been}
00353 \textcolor{comment}{  consumed and all output has been produced (only when flush is set to}
00354 \textcolor{comment}{  Z\_FINISH), Z\_STREAM\_ERROR if the stream state was inconsistent (for example}
00355 \textcolor{comment}{  if next\_in or next\_out was Z\_NULL or the state was inadvertently written over}
00356 \textcolor{comment}{  by the application), or Z\_BUF\_ERROR if no progress is possible (for example}
00357 \textcolor{comment}{  avail\_in or avail\_out was zero).  Note that Z\_BUF\_ERROR is not fatal, and}
00358 \textcolor{comment}{  deflate() can be called again with more input and more output space to}
00359 \textcolor{comment}{  continue compressing.}
00360 \textcolor{comment}{*/}
00361 
00362 
00363 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateEnd OF((z\_streamp strm));
00364 \textcolor{comment}{/*}
00365 \textcolor{comment}{     All dynamically allocated data structures for this stream are freed.}
00366 \textcolor{comment}{   This function discards any unprocessed input and does not flush any pending}
00367 \textcolor{comment}{   output.}
00368 \textcolor{comment}{}
00369 \textcolor{comment}{     deflateEnd returns Z\_OK if success, Z\_STREAM\_ERROR if the}
00370 \textcolor{comment}{   stream state was inconsistent, Z\_DATA\_ERROR if the stream was freed}
00371 \textcolor{comment}{   prematurely (some input or output was discarded).  In the error case, msg}
00372 \textcolor{comment}{   may be set but then points to a static string (which must not be}
00373 \textcolor{comment}{   deallocated).}
00374 \textcolor{comment}{*/}
00375 
00376 
00377 \textcolor{comment}{/*}
00378 \textcolor{comment}{ZEXTERN int ZEXPORT inflateInit OF((z\_streamp strm));}
00379 \textcolor{comment}{}
00380 \textcolor{comment}{     Initializes the internal stream state for decompression.  The fields}
00381 \textcolor{comment}{   next\_in, avail\_in, zalloc, zfree and opaque must be initialized before by}
00382 \textcolor{comment}{   the caller.  In the current version of inflate, the provided input is not}
00383 \textcolor{comment}{   read or consumed.  The allocation of a sliding window will be deferred to}
00384 \textcolor{comment}{   the first call of inflate (if the decompression does not complete on the}
00385 \textcolor{comment}{   first call).  If zalloc and zfree are set to Z\_NULL, inflateInit updates}
00386 \textcolor{comment}{   them to use default allocation functions.}
00387 \textcolor{comment}{}
00388 \textcolor{comment}{     inflateInit returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough}
00389 \textcolor{comment}{   memory, Z\_VERSION\_ERROR if the zlib library version is incompatible with the}
00390 \textcolor{comment}{   version assumed by the caller, or Z\_STREAM\_ERROR if the parameters are}
00391 \textcolor{comment}{   invalid, such as a null pointer to the structure.  msg is set to null if}
00392 \textcolor{comment}{   there is no error message.  inflateInit does not perform any decompression.}
00393 \textcolor{comment}{   Actual decompression will be done by inflate().  So next\_in, and avail\_in,}
00394 \textcolor{comment}{   next\_out, and avail\_out are unused and unchanged.  The current}
00395 \textcolor{comment}{   implementation of inflateInit() does not process any header information --}
00396 \textcolor{comment}{   that is deferred until inflate() is called.}
00397 \textcolor{comment}{*/}
00398 
00399 
00400 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflate OF((z\_streamp strm, \textcolor{keywordtype}{int} flush));
00401 \textcolor{comment}{/*}
00402 \textcolor{comment}{    inflate decompresses as much data as possible, and stops when the input}
00403 \textcolor{comment}{  buffer becomes empty or the output buffer becomes full.  It may introduce}
00404 \textcolor{comment}{  some output latency (reading input without producing any output) except when}
00405 \textcolor{comment}{  forced to flush.}
00406 \textcolor{comment}{}
00407 \textcolor{comment}{  The detailed semantics are as follows.  inflate performs one or both of the}
00408 \textcolor{comment}{  following actions:}
00409 \textcolor{comment}{}
00410 \textcolor{comment}{  - Decompress more input starting at next\_in and update next\_in and avail\_in}
00411 \textcolor{comment}{    accordingly.  If not all input can be processed (because there is not}
00412 \textcolor{comment}{    enough room in the output buffer), then next\_in and avail\_in are updated}
00413 \textcolor{comment}{    accordingly, and processing will resume at this point for the next call of}
00414 \textcolor{comment}{    inflate().}
00415 \textcolor{comment}{}
00416 \textcolor{comment}{  - Generate more output starting at next\_out and update next\_out and avail\_out}
00417 \textcolor{comment}{    accordingly.  inflate() provides as much output as possible, until there is}
00418 \textcolor{comment}{    no more input data or no more space in the output buffer (see below about}
00419 \textcolor{comment}{    the flush parameter).}
00420 \textcolor{comment}{}
00421 \textcolor{comment}{    Before the call of inflate(), the application should ensure that at least}
00422 \textcolor{comment}{  one of the actions is possible, by providing more input and/or consuming more}
00423 \textcolor{comment}{  output, and updating the next\_* and avail\_* values accordingly.  If the}
00424 \textcolor{comment}{  caller of inflate() does not provide both available input and available}
00425 \textcolor{comment}{  output space, it is possible that there will be no progress made.  The}
00426 \textcolor{comment}{  application can consume the uncompressed output when it wants, for example}
00427 \textcolor{comment}{  when the output buffer is full (avail\_out == 0), or after each call of}
00428 \textcolor{comment}{  inflate().  If inflate returns Z\_OK and with zero avail\_out, it must be}
00429 \textcolor{comment}{  called again after making room in the output buffer because there might be}
00430 \textcolor{comment}{  more output pending.}
00431 \textcolor{comment}{}
00432 \textcolor{comment}{    The flush parameter of inflate() can be Z\_NO\_FLUSH, Z\_SYNC\_FLUSH, Z\_FINISH,}
00433 \textcolor{comment}{  Z\_BLOCK, or Z\_TREES.  Z\_SYNC\_FLUSH requests that inflate() flush as much}
00434 \textcolor{comment}{  output as possible to the output buffer.  Z\_BLOCK requests that inflate()}
00435 \textcolor{comment}{  stop if and when it gets to the next deflate block boundary.  When decoding}
00436 \textcolor{comment}{  the zlib or gzip format, this will cause inflate() to return immediately}
00437 \textcolor{comment}{  after the header and before the first block.  When doing a raw inflate,}
00438 \textcolor{comment}{  inflate() will go ahead and process the first block, and will return when it}
00439 \textcolor{comment}{  gets to the end of that block, or when it runs out of data.}
00440 \textcolor{comment}{}
00441 \textcolor{comment}{    The Z\_BLOCK option assists in appending to or combining deflate streams.}
00442 \textcolor{comment}{  To assist in this, on return inflate() always sets strm->data\_type to the}
00443 \textcolor{comment}{  number of unused bits in the last byte taken from strm->next\_in, plus 64 if}
00444 \textcolor{comment}{  inflate() is currently decoding the last block in the deflate stream, plus}
00445 \textcolor{comment}{  128 if inflate() returned immediately after decoding an end-of-block code or}
00446 \textcolor{comment}{  decoding the complete header up to just before the first byte of the deflate}
00447 \textcolor{comment}{  stream.  The end-of-block will not be indicated until all of the uncompressed}
00448 \textcolor{comment}{  data from that block has been written to strm->next\_out.  The number of}
00449 \textcolor{comment}{  unused bits may in general be greater than seven, except when bit 7 of}
00450 \textcolor{comment}{  data\_type is set, in which case the number of unused bits will be less than}
00451 \textcolor{comment}{  eight.  data\_type is set as noted here every time inflate() returns for all}
00452 \textcolor{comment}{  flush options, and so can be used to determine the amount of currently}
00453 \textcolor{comment}{  consumed input in bits.}
00454 \textcolor{comment}{}
00455 \textcolor{comment}{    The Z\_TREES option behaves as Z\_BLOCK does, but it also returns when the}
00456 \textcolor{comment}{  end of each deflate block header is reached, before any actual data in that}
00457 \textcolor{comment}{  block is decoded.  This allows the caller to determine the length of the}
00458 \textcolor{comment}{  deflate block header for later use in random access within a deflate block.}
00459 \textcolor{comment}{  256 is added to the value of strm->data\_type when inflate() returns}
00460 \textcolor{comment}{  immediately after reaching the end of the deflate block header.}
00461 \textcolor{comment}{}
00462 \textcolor{comment}{    inflate() should normally be called until it returns Z\_STREAM\_END or an}
00463 \textcolor{comment}{  error.  However if all decompression is to be performed in a single step (a}
00464 \textcolor{comment}{  single call of inflate), the parameter flush should be set to Z\_FINISH.  In}
00465 \textcolor{comment}{  this case all pending input is processed and all pending output is flushed;}
00466 \textcolor{comment}{  avail\_out must be large enough to hold all of the uncompressed data for the}
00467 \textcolor{comment}{  operation to complete.  (The size of the uncompressed data may have been}
00468 \textcolor{comment}{  saved by the compressor for this purpose.)  The use of Z\_FINISH is not}
00469 \textcolor{comment}{  required to perform an inflation in one step.  However it may be used to}
00470 \textcolor{comment}{  inform inflate that a faster approach can be used for the single inflate()}
00471 \textcolor{comment}{  call.  Z\_FINISH also informs inflate to not maintain a sliding window if the}
00472 \textcolor{comment}{  stream completes, which reduces inflate's memory footprint.  If the stream}
00473 \textcolor{comment}{  does not complete, either because not all of the stream is provided or not}
00474 \textcolor{comment}{  enough output space is provided, then a sliding window will be allocated and}
00475 \textcolor{comment}{  inflate() can be called again to continue the operation as if Z\_NO\_FLUSH had}
00476 \textcolor{comment}{  been used.}
00477 \textcolor{comment}{}
00478 \textcolor{comment}{     In this implementation, inflate() always flushes as much output as}
00479 \textcolor{comment}{  possible to the output buffer, and always uses the faster approach on the}
00480 \textcolor{comment}{  first call.  So the effects of the flush parameter in this implementation are}
00481 \textcolor{comment}{  on the return value of inflate() as noted below, when inflate() returns early}
00482 \textcolor{comment}{  when Z\_BLOCK or Z\_TREES is used, and when inflate() avoids the allocation of}
00483 \textcolor{comment}{  memory for a sliding window when Z\_FINISH is used.}
00484 \textcolor{comment}{}
00485 \textcolor{comment}{     If a preset dictionary is needed after this call (see inflateSetDictionary}
00486 \textcolor{comment}{  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary}
00487 \textcolor{comment}{  chosen by the compressor and returns Z\_NEED\_DICT; otherwise it sets}
00488 \textcolor{comment}{  strm->adler to the Adler-32 checksum of all output produced so far (that is,}
00489 \textcolor{comment}{  total\_out bytes) and returns Z\_OK, Z\_STREAM\_END or an error code as described}
00490 \textcolor{comment}{  below.  At the end of the stream, inflate() checks that its computed Adler-32}
00491 \textcolor{comment}{  checksum is equal to that saved by the compressor and returns Z\_STREAM\_END}
00492 \textcolor{comment}{  only if the checksum is correct.}
00493 \textcolor{comment}{}
00494 \textcolor{comment}{    inflate() can decompress and check either zlib-wrapped or gzip-wrapped}
00495 \textcolor{comment}{  deflate data.  The header type is detected automatically, if requested when}
00496 \textcolor{comment}{  initializing with inflateInit2().  Any information contained in the gzip}
00497 \textcolor{comment}{  header is not retained unless inflateGetHeader() is used.  When processing}
00498 \textcolor{comment}{  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output}
00499 \textcolor{comment}{  produced so far.  The CRC-32 is checked against the gzip trailer, as is the}
00500 \textcolor{comment}{  uncompressed length, modulo 2^32.}
00501 \textcolor{comment}{}
00502 \textcolor{comment}{    inflate() returns Z\_OK if some progress has been made (more input processed}
00503 \textcolor{comment}{  or more output produced), Z\_STREAM\_END if the end of the compressed data has}
00504 \textcolor{comment}{  been reached and all uncompressed output has been produced, Z\_NEED\_DICT if a}
00505 \textcolor{comment}{  preset dictionary is needed at this point, Z\_DATA\_ERROR if the input data was}
00506 \textcolor{comment}{  corrupted (input stream not conforming to the zlib format or incorrect check}
00507 \textcolor{comment}{  value, in which case strm->msg points to a string with a more specific}
00508 \textcolor{comment}{  error), Z\_STREAM\_ERROR if the stream structure was inconsistent (for example}
00509 \textcolor{comment}{  next\_in or next\_out was Z\_NULL, or the state was inadvertently written over}
00510 \textcolor{comment}{  by the application), Z\_MEM\_ERROR if there was not enough memory, Z\_BUF\_ERROR}
00511 \textcolor{comment}{  if no progress was possible or if there was not enough room in the output}
00512 \textcolor{comment}{  buffer when Z\_FINISH is used.  Note that Z\_BUF\_ERROR is not fatal, and}
00513 \textcolor{comment}{  inflate() can be called again with more input and more output space to}
00514 \textcolor{comment}{  continue decompressing.  If Z\_DATA\_ERROR is returned, the application may}
00515 \textcolor{comment}{  then call inflateSync() to look for a good compression block if a partial}
00516 \textcolor{comment}{  recovery of the data is to be attempted.}
00517 \textcolor{comment}{*/}
00518 
00519 
00520 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateEnd OF((z\_streamp strm));
00521 \textcolor{comment}{/*}
00522 \textcolor{comment}{     All dynamically allocated data structures for this stream are freed.}
00523 \textcolor{comment}{   This function discards any unprocessed input and does not flush any pending}
00524 \textcolor{comment}{   output.}
00525 \textcolor{comment}{}
00526 \textcolor{comment}{     inflateEnd returns Z\_OK if success, or Z\_STREAM\_ERROR if the stream state}
00527 \textcolor{comment}{   was inconsistent.}
00528 \textcolor{comment}{*/}
00529 
00530 
00531                         \textcolor{comment}{/* Advanced functions */}
00532 
00533 \textcolor{comment}{/*}
00534 \textcolor{comment}{    The following functions are needed only in some special applications.}
00535 \textcolor{comment}{*/}
00536 
00537 \textcolor{comment}{/*}
00538 \textcolor{comment}{ZEXTERN int ZEXPORT deflateInit2 OF((z\_streamp strm,}
00539 \textcolor{comment}{                                     int  level,}
00540 \textcolor{comment}{                                     int  method,}
00541 \textcolor{comment}{                                     int  windowBits,}
00542 \textcolor{comment}{                                     int  memLevel,}
00543 \textcolor{comment}{                                     int  strategy));}
00544 \textcolor{comment}{}
00545 \textcolor{comment}{     This is another version of deflateInit with more compression options.  The}
00546 \textcolor{comment}{   fields next\_in, zalloc, zfree and opaque must be initialized before by the}
00547 \textcolor{comment}{   caller.}
00548 \textcolor{comment}{}
00549 \textcolor{comment}{     The method parameter is the compression method.  It must be Z\_DEFLATED in}
00550 \textcolor{comment}{   this version of the library.}
00551 \textcolor{comment}{}
00552 \textcolor{comment}{     The windowBits parameter is the base two logarithm of the window size}
00553 \textcolor{comment}{   (the size of the history buffer).  It should be in the range 8..15 for this}
00554 \textcolor{comment}{   version of the library.  Larger values of this parameter result in better}
00555 \textcolor{comment}{   compression at the expense of memory usage.  The default value is 15 if}
00556 \textcolor{comment}{   deflateInit is used instead.}
00557 \textcolor{comment}{}
00558 \textcolor{comment}{     For the current implementation of deflate(), a windowBits value of 8 (a}
00559 \textcolor{comment}{   window size of 256 bytes) is not supported.  As a result, a request for 8}
00560 \textcolor{comment}{   will result in 9 (a 512-byte window).  In that case, providing 8 to}
00561 \textcolor{comment}{   inflateInit2() will result in an error when the zlib header with 9 is}
00562 \textcolor{comment}{   checked against the initialization of inflate().  The remedy is to not use 8}
00563 \textcolor{comment}{   with deflateInit2() with this initialization, or at least in that case use 9}
00564 \textcolor{comment}{   with inflateInit2().}
00565 \textcolor{comment}{}
00566 \textcolor{comment}{     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits}
00567 \textcolor{comment}{   determines the window size.  deflate() will then generate raw deflate data}
00568 \textcolor{comment}{   with no zlib header or trailer, and will not compute a check value.}
00569 \textcolor{comment}{}
00570 \textcolor{comment}{     windowBits can also be greater than 15 for optional gzip encoding.  Add}
00571 \textcolor{comment}{   16 to windowBits to write a simple gzip header and trailer around the}
00572 \textcolor{comment}{   compressed data instead of a zlib wrapper.  The gzip header will have no}
00573 \textcolor{comment}{   file name, no extra data, no comment, no modification time (set to zero), no}
00574 \textcolor{comment}{   header crc, and the operating system will be set to the appropriate value,}
00575 \textcolor{comment}{   if the operating system was determined at compile time.  If a gzip stream is}
00576 \textcolor{comment}{   being written, strm->adler is a CRC-32 instead of an Adler-32.}
00577 \textcolor{comment}{}
00578 \textcolor{comment}{     For raw deflate or gzip encoding, a request for a 256-byte window is}
00579 \textcolor{comment}{   rejected as invalid, since only the zlib header provides a means of}
00580 \textcolor{comment}{   transmitting the window size to the decompressor.}
00581 \textcolor{comment}{}
00582 \textcolor{comment}{     The memLevel parameter specifies how much memory should be allocated}
00583 \textcolor{comment}{   for the internal compression state.  memLevel=1 uses minimum memory but is}
00584 \textcolor{comment}{   slow and reduces compression ratio; memLevel=9 uses maximum memory for}
00585 \textcolor{comment}{   optimal speed.  The default value is 8.  See zconf.h for total memory usage}
00586 \textcolor{comment}{   as a function of windowBits and memLevel.}
00587 \textcolor{comment}{}
00588 \textcolor{comment}{     The strategy parameter is used to tune the compression algorithm.  Use the}
00589 \textcolor{comment}{   value Z\_DEFAULT\_STRATEGY for normal data, Z\_FILTERED for data produced by a}
00590 \textcolor{comment}{   filter (or predictor), Z\_HUFFMAN\_ONLY to force Huffman encoding only (no}
00591 \textcolor{comment}{   string match), or Z\_RLE to limit match distances to one (run-length}
00592 \textcolor{comment}{   encoding).  Filtered data consists mostly of small values with a somewhat}
00593 \textcolor{comment}{   random distribution.  In this case, the compression algorithm is tuned to}
00594 \textcolor{comment}{   compress them better.  The effect of Z\_FILTERED is to force more Huffman}
00595 \textcolor{comment}{   coding and less string matching; it is somewhat intermediate between}
00596 \textcolor{comment}{   Z\_DEFAULT\_STRATEGY and Z\_HUFFMAN\_ONLY.  Z\_RLE is designed to be almost as}
00597 \textcolor{comment}{   fast as Z\_HUFFMAN\_ONLY, but give better compression for PNG image data.  The}
00598 \textcolor{comment}{   strategy parameter only affects the compression ratio but not the}
00599 \textcolor{comment}{   correctness of the compressed output even if it is not set appropriately.}
00600 \textcolor{comment}{   Z\_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler}
00601 \textcolor{comment}{   decoder for special applications.}
00602 \textcolor{comment}{}
00603 \textcolor{comment}{     deflateInit2 returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough}
00604 \textcolor{comment}{   memory, Z\_STREAM\_ERROR if any parameter is invalid (such as an invalid}
00605 \textcolor{comment}{   method), or Z\_VERSION\_ERROR if the zlib library version (zlib\_version) is}
00606 \textcolor{comment}{   incompatible with the version assumed by the caller (ZLIB\_VERSION).  msg is}
00607 \textcolor{comment}{   set to null if there is no error message.  deflateInit2 does not perform any}
00608 \textcolor{comment}{   compression: this will be done by deflate().}
00609 \textcolor{comment}{*/}
00610 
00611 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateSetDictionary OF((z\_streamp strm,
00612                                              \textcolor{keyword}{const} Bytef *dictionary,
00613                                              uInt  dictLength));
00614 \textcolor{comment}{/*}
00615 \textcolor{comment}{     Initializes the compression dictionary from the given byte sequence}
00616 \textcolor{comment}{   without producing any compressed output.  When using the zlib format, this}
00617 \textcolor{comment}{   function must be called immediately after deflateInit, deflateInit2 or}
00618 \textcolor{comment}{   deflateReset, and before any call of deflate.  When doing raw deflate, this}
00619 \textcolor{comment}{   function must be called either before any call of deflate, or immediately}
00620 \textcolor{comment}{   after the completion of a deflate block, i.e. after all input has been}
00621 \textcolor{comment}{   consumed and all output has been delivered when using any of the flush}
00622 \textcolor{comment}{   options Z\_BLOCK, Z\_PARTIAL\_FLUSH, Z\_SYNC\_FLUSH, or Z\_FULL\_FLUSH.  The}
00623 \textcolor{comment}{   compressor and decompressor must use exactly the same dictionary (see}
00624 \textcolor{comment}{   inflateSetDictionary).}
00625 \textcolor{comment}{}
00626 \textcolor{comment}{     The dictionary should consist of strings (byte sequences) that are likely}
00627 \textcolor{comment}{   to be encountered later in the data to be compressed, with the most commonly}
00628 \textcolor{comment}{   used strings preferably put towards the end of the dictionary.  Using a}
00629 \textcolor{comment}{   dictionary is most useful when the data to be compressed is short and can be}
00630 \textcolor{comment}{   predicted with good accuracy; the data can then be compressed better than}
00631 \textcolor{comment}{   with the default empty dictionary.}
00632 \textcolor{comment}{}
00633 \textcolor{comment}{     Depending on the size of the compression data structures selected by}
00634 \textcolor{comment}{   deflateInit or deflateInit2, a part of the dictionary may in effect be}
00635 \textcolor{comment}{   discarded, for example if the dictionary is larger than the window size}
00636 \textcolor{comment}{   provided in deflateInit or deflateInit2.  Thus the strings most likely to be}
00637 \textcolor{comment}{   useful should be put at the end of the dictionary, not at the front.  In}
00638 \textcolor{comment}{   addition, the current implementation of deflate will use at most the window}
00639 \textcolor{comment}{   size minus 262 bytes of the provided dictionary.}
00640 \textcolor{comment}{}
00641 \textcolor{comment}{     Upon return of this function, strm->adler is set to the Adler-32 value}
00642 \textcolor{comment}{   of the dictionary; the decompressor may later use this value to determine}
00643 \textcolor{comment}{   which dictionary has been used by the compressor.  (The Adler-32 value}
00644 \textcolor{comment}{   applies to the whole dictionary even if only a subset of the dictionary is}
00645 \textcolor{comment}{   actually used by the compressor.) If a raw deflate was requested, then the}
00646 \textcolor{comment}{   Adler-32 value is not computed and strm->adler is not set.}
00647 \textcolor{comment}{}
00648 \textcolor{comment}{     deflateSetDictionary returns Z\_OK if success, or Z\_STREAM\_ERROR if a}
00649 \textcolor{comment}{   parameter is invalid (e.g.  dictionary being Z\_NULL) or the stream state is}
00650 \textcolor{comment}{   inconsistent (for example if deflate has already been called for this stream}
00651 \textcolor{comment}{   or if not at a block boundary for raw deflate).  deflateSetDictionary does}
00652 \textcolor{comment}{   not perform any compression: this will be done by deflate().}
00653 \textcolor{comment}{*/}
00654 
00655 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateGetDictionary OF((z\_streamp strm,
00656                                              Bytef *dictionary,
00657                                              uInt  *dictLength));
00658 \textcolor{comment}{/*}
00659 \textcolor{comment}{     Returns the sliding dictionary being maintained by deflate.  dictLength is}
00660 \textcolor{comment}{   set to the number of bytes in the dictionary, and that many bytes are copied}
00661 \textcolor{comment}{   to dictionary.  dictionary must have enough space, where 32768 bytes is}
00662 \textcolor{comment}{   always enough.  If deflateGetDictionary() is called with dictionary equal to}
00663 \textcolor{comment}{   Z\_NULL, then only the dictionary length is returned, and nothing is copied.}
00664 \textcolor{comment}{   Similary, if dictLength is Z\_NULL, then it is not set.}
00665 \textcolor{comment}{}
00666 \textcolor{comment}{     deflateGetDictionary() may return a length less than the window size, even}
00667 \textcolor{comment}{   when more than the window size in input has been provided. It may return up}
00668 \textcolor{comment}{   to 258 bytes less in that case, due to how zlib's implementation of deflate}
00669 \textcolor{comment}{   manages the sliding window and lookahead for matches, where matches can be}
00670 \textcolor{comment}{   up to 258 bytes long. If the application needs the last window-size bytes of}
00671 \textcolor{comment}{   input, then that would need to be saved by the application outside of zlib.}
00672 \textcolor{comment}{}
00673 \textcolor{comment}{     deflateGetDictionary returns Z\_OK on success, or Z\_STREAM\_ERROR if the}
00674 \textcolor{comment}{   stream state is inconsistent.}
00675 \textcolor{comment}{*/}
00676 
00677 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateCopy OF((z\_streamp dest,
00678                                     z\_streamp source));
00679 \textcolor{comment}{/*}
00680 \textcolor{comment}{     Sets the destination stream as a complete copy of the source stream.}
00681 \textcolor{comment}{}
00682 \textcolor{comment}{     This function can be useful when several compression strategies will be}
00683 \textcolor{comment}{   tried, for example when there are several ways of pre-processing the input}
00684 \textcolor{comment}{   data with a filter.  The streams that will be discarded should then be freed}
00685 \textcolor{comment}{   by calling deflateEnd.  Note that deflateCopy duplicates the internal}
00686 \textcolor{comment}{   compression state which can be quite large, so this strategy is slow and can}
00687 \textcolor{comment}{   consume lots of memory.}
00688 \textcolor{comment}{}
00689 \textcolor{comment}{     deflateCopy returns Z\_OK if success, Z\_MEM\_ERROR if there was not}
00690 \textcolor{comment}{   enough memory, Z\_STREAM\_ERROR if the source stream state was inconsistent}
00691 \textcolor{comment}{   (such as zalloc being Z\_NULL).  msg is left unchanged in both source and}
00692 \textcolor{comment}{   destination.}
00693 \textcolor{comment}{*/}
00694 
00695 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateReset OF((z\_streamp strm));
00696 \textcolor{comment}{/*}
00697 \textcolor{comment}{     This function is equivalent to deflateEnd followed by deflateInit, but}
00698 \textcolor{comment}{   does not free and reallocate the internal compression state.  The stream}
00699 \textcolor{comment}{   will leave the compression level and any other attributes that may have been}
00700 \textcolor{comment}{   set unchanged.}
00701 \textcolor{comment}{}
00702 \textcolor{comment}{     deflateReset returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
00703 \textcolor{comment}{   stream state was inconsistent (such as zalloc or state being Z\_NULL).}
00704 \textcolor{comment}{*/}
00705 
00706 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateParams OF((z\_streamp strm,
00707                                       \textcolor{keywordtype}{int} level,
00708                                       \textcolor{keywordtype}{int} strategy));
00709 \textcolor{comment}{/*}
00710 \textcolor{comment}{     Dynamically update the compression level and compression strategy.  The}
00711 \textcolor{comment}{   interpretation of level and strategy is as in deflateInit2().  This can be}
00712 \textcolor{comment}{   used to switch between compression and straight copy of the input data, or}
00713 \textcolor{comment}{   to switch to a different kind of input data requiring a different strategy.}
00714 \textcolor{comment}{   If the compression approach (which is a function of the level) or the}
00715 \textcolor{comment}{   strategy is changed, and if any input has been consumed in a previous}
00716 \textcolor{comment}{   deflate() call, then the input available so far is compressed with the old}
00717 \textcolor{comment}{   level and strategy using deflate(strm, Z\_BLOCK).  There are three approaches}
00718 \textcolor{comment}{   for the compression levels 0, 1..3, and 4..9 respectively.  The new level}
00719 \textcolor{comment}{   and strategy will take effect at the next call of deflate().}
00720 \textcolor{comment}{}
00721 \textcolor{comment}{     If a deflate(strm, Z\_BLOCK) is performed by deflateParams(), and it does}
00722 \textcolor{comment}{   not have enough output space to complete, then the parameter change will not}
00723 \textcolor{comment}{   take effect.  In this case, deflateParams() can be called again with the}
00724 \textcolor{comment}{   same parameters and more output space to try again.}
00725 \textcolor{comment}{}
00726 \textcolor{comment}{     In order to assure a change in the parameters on the first try, the}
00727 \textcolor{comment}{   deflate stream should be flushed using deflate() with Z\_BLOCK or other flush}
00728 \textcolor{comment}{   request until strm.avail\_out is not zero, before calling deflateParams().}
00729 \textcolor{comment}{   Then no more input data should be provided before the deflateParams() call.}
00730 \textcolor{comment}{   If this is done, the old level and strategy will be applied to the data}
00731 \textcolor{comment}{   compressed before deflateParams(), and the new level and strategy will be}
00732 \textcolor{comment}{   applied to the the data compressed after deflateParams().}
00733 \textcolor{comment}{}
00734 \textcolor{comment}{     deflateParams returns Z\_OK on success, Z\_STREAM\_ERROR if the source stream}
00735 \textcolor{comment}{   state was inconsistent or if a parameter was invalid, or Z\_BUF\_ERROR if}
00736 \textcolor{comment}{   there was not enough output space to complete the compression of the}
00737 \textcolor{comment}{   available input data before a change in the strategy or approach.  Note that}
00738 \textcolor{comment}{   in the case of a Z\_BUF\_ERROR, the parameters are not changed.  A return}
00739 \textcolor{comment}{   value of Z\_BUF\_ERROR is not fatal, in which case deflateParams() can be}
00740 \textcolor{comment}{   retried with more output space.}
00741 \textcolor{comment}{*/}
00742 
00743 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateTune OF((z\_streamp strm,
00744                                     \textcolor{keywordtype}{int} good\_length,
00745                                     \textcolor{keywordtype}{int} max\_lazy,
00746                                     \textcolor{keywordtype}{int} nice\_length,
00747                                     \textcolor{keywordtype}{int} max\_chain));
00748 \textcolor{comment}{/*}
00749 \textcolor{comment}{     Fine tune deflate's internal compression parameters.  This should only be}
00750 \textcolor{comment}{   used by someone who understands the algorithm used by zlib's deflate for}
00751 \textcolor{comment}{   searching for the best matching string, and even then only by the most}
00752 \textcolor{comment}{   fanatic optimizer trying to squeeze out the last compressed bit for their}
00753 \textcolor{comment}{   specific input data.  Read the deflate.c source code for the meaning of the}
00754 \textcolor{comment}{   max\_lazy, good\_length, nice\_length, and max\_chain parameters.}
00755 \textcolor{comment}{}
00756 \textcolor{comment}{     deflateTune() can be called after deflateInit() or deflateInit2(), and}
00757 \textcolor{comment}{   returns Z\_OK on success, or Z\_STREAM\_ERROR for an invalid deflate stream.}
00758 \textcolor{comment}{ */}
00759 
00760 ZEXTERN uLong ZEXPORT deflateBound OF((z\_streamp strm,
00761                                        uLong sourceLen));
00762 \textcolor{comment}{/*}
00763 \textcolor{comment}{     deflateBound() returns an upper bound on the compressed size after}
00764 \textcolor{comment}{   deflation of sourceLen bytes.  It must be called after deflateInit() or}
00765 \textcolor{comment}{   deflateInit2(), and after deflateSetHeader(), if used.  This would be used}
00766 \textcolor{comment}{   to allocate an output buffer for deflation in a single pass, and so would be}
00767 \textcolor{comment}{   called before deflate().  If that first deflate() call is provided the}
00768 \textcolor{comment}{   sourceLen input bytes, an output buffer allocated to the size returned by}
00769 \textcolor{comment}{   deflateBound(), and the flush value Z\_FINISH, then deflate() is guaranteed}
00770 \textcolor{comment}{   to return Z\_STREAM\_END.  Note that it is possible for the compressed size to}
00771 \textcolor{comment}{   be larger than the value returned by deflateBound() if flush options other}
00772 \textcolor{comment}{   than Z\_FINISH or Z\_NO\_FLUSH are used.}
00773 \textcolor{comment}{*/}
00774 
00775 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflatePending OF((z\_streamp strm,
00776                                        \textcolor{keywordtype}{unsigned} *pending,
00777                                        \textcolor{keywordtype}{int} *bits));
00778 \textcolor{comment}{/*}
00779 \textcolor{comment}{     deflatePending() returns the number of bytes and bits of output that have}
00780 \textcolor{comment}{   been generated, but not yet provided in the available output.  The bytes not}
00781 \textcolor{comment}{   provided would be due to the available output space having being consumed.}
00782 \textcolor{comment}{   The number of bits of output not provided are between 0 and 7, where they}
00783 \textcolor{comment}{   await more bits to join them in order to fill out a full byte.  If pending}
00784 \textcolor{comment}{   or bits are Z\_NULL, then those values are not set.}
00785 \textcolor{comment}{}
00786 \textcolor{comment}{     deflatePending returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
00787 \textcolor{comment}{   stream state was inconsistent.}
00788 \textcolor{comment}{ */}
00789 
00790 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflatePrime OF((z\_streamp strm,
00791                                      \textcolor{keywordtype}{int} bits,
00792                                      \textcolor{keywordtype}{int} value));
00793 \textcolor{comment}{/*}
00794 \textcolor{comment}{     deflatePrime() inserts bits in the deflate output stream.  The intent}
00795 \textcolor{comment}{   is that this function is used to start off the deflate output with the bits}
00796 \textcolor{comment}{   leftover from a previous deflate stream when appending to it.  As such, this}
00797 \textcolor{comment}{   function can only be used for raw deflate, and must be used before the first}
00798 \textcolor{comment}{   deflate() call after a deflateInit2() or deflateReset().  bits must be less}
00799 \textcolor{comment}{   than or equal to 16, and that many of the least significant bits of value}
00800 \textcolor{comment}{   will be inserted in the output.}
00801 \textcolor{comment}{}
00802 \textcolor{comment}{     deflatePrime returns Z\_OK if success, Z\_BUF\_ERROR if there was not enough}
00803 \textcolor{comment}{   room in the internal buffer to insert the bits, or Z\_STREAM\_ERROR if the}
00804 \textcolor{comment}{   source stream state was inconsistent.}
00805 \textcolor{comment}{*/}
00806 
00807 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateSetHeader OF((z\_streamp strm,
00808                                          gz\_headerp head));
00809 \textcolor{comment}{/*}
00810 \textcolor{comment}{     deflateSetHeader() provides gzip header information for when a gzip}
00811 \textcolor{comment}{   stream is requested by deflateInit2().  deflateSetHeader() may be called}
00812 \textcolor{comment}{   after deflateInit2() or deflateReset() and before the first call of}
00813 \textcolor{comment}{   deflate().  The text, time, os, extra field, name, and comment information}
00814 \textcolor{comment}{   in the provided gz\_header structure are written to the gzip header (xflag is}
00815 \textcolor{comment}{   ignored -- the extra flags are set according to the compression level).  The}
00816 \textcolor{comment}{   caller must assure that, if not Z\_NULL, name and comment are terminated with}
00817 \textcolor{comment}{   a zero byte, and that if extra is not Z\_NULL, that extra\_len bytes are}
00818 \textcolor{comment}{   available there.  If hcrc is true, a gzip header crc is included.  Note that}
00819 \textcolor{comment}{   the current versions of the command-line version of gzip (up through version}
00820 \textcolor{comment}{   1.3.x) do not support header crc's, and will report that it is a "multi-part}
00821 \textcolor{comment}{   gzip file" and give up.}
00822 \textcolor{comment}{}
00823 \textcolor{comment}{     If deflateSetHeader is not used, the default gzip header has text false,}
00824 \textcolor{comment}{   the time set to zero, and os set to 255, with no extra, name, or comment}
00825 \textcolor{comment}{   fields.  The gzip header is returned to the default state by deflateReset().}
00826 \textcolor{comment}{}
00827 \textcolor{comment}{     deflateSetHeader returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
00828 \textcolor{comment}{   stream state was inconsistent.}
00829 \textcolor{comment}{*/}
00830 
00831 \textcolor{comment}{/*}
00832 \textcolor{comment}{ZEXTERN int ZEXPORT inflateInit2 OF((z\_streamp strm,}
00833 \textcolor{comment}{                                     int  windowBits));}
00834 \textcolor{comment}{}
00835 \textcolor{comment}{     This is another version of inflateInit with an extra parameter.  The}
00836 \textcolor{comment}{   fields next\_in, avail\_in, zalloc, zfree and opaque must be initialized}
00837 \textcolor{comment}{   before by the caller.}
00838 \textcolor{comment}{}
00839 \textcolor{comment}{     The windowBits parameter is the base two logarithm of the maximum window}
00840 \textcolor{comment}{   size (the size of the history buffer).  It should be in the range 8..15 for}
00841 \textcolor{comment}{   this version of the library.  The default value is 15 if inflateInit is used}
00842 \textcolor{comment}{   instead.  windowBits must be greater than or equal to the windowBits value}
00843 \textcolor{comment}{   provided to deflateInit2() while compressing, or it must be equal to 15 if}
00844 \textcolor{comment}{   deflateInit2() was not used.  If a compressed stream with a larger window}
00845 \textcolor{comment}{   size is given as input, inflate() will return with the error code}
00846 \textcolor{comment}{   Z\_DATA\_ERROR instead of trying to allocate a larger window.}
00847 \textcolor{comment}{}
00848 \textcolor{comment}{     windowBits can also be zero to request that inflate use the window size in}
00849 \textcolor{comment}{   the zlib header of the compressed stream.}
00850 \textcolor{comment}{}
00851 \textcolor{comment}{     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits}
00852 \textcolor{comment}{   determines the window size.  inflate() will then process raw deflate data,}
00853 \textcolor{comment}{   not looking for a zlib or gzip header, not generating a check value, and not}
00854 \textcolor{comment}{   looking for any check values for comparison at the end of the stream.  This}
00855 \textcolor{comment}{   is for use with other formats that use the deflate compressed data format}
00856 \textcolor{comment}{   such as zip.  Those formats provide their own check values.  If a custom}
00857 \textcolor{comment}{   format is developed using the raw deflate format for compressed data, it is}
00858 \textcolor{comment}{   recommended that a check value such as an Adler-32 or a CRC-32 be applied to}
00859 \textcolor{comment}{   the uncompressed data as is done in the zlib, gzip, and zip formats.  For}
00860 \textcolor{comment}{   most applications, the zlib format should be used as is.  Note that comments}
00861 \textcolor{comment}{   above on the use in deflateInit2() applies to the magnitude of windowBits.}
00862 \textcolor{comment}{}
00863 \textcolor{comment}{     windowBits can also be greater than 15 for optional gzip decoding.  Add}
00864 \textcolor{comment}{   32 to windowBits to enable zlib and gzip decoding with automatic header}
00865 \textcolor{comment}{   detection, or add 16 to decode only the gzip format (the zlib format will}
00866 \textcolor{comment}{   return a Z\_DATA\_ERROR).  If a gzip stream is being decoded, strm->adler is a}
00867 \textcolor{comment}{   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see}
00868 \textcolor{comment}{   below), inflate() will not automatically decode concatenated gzip streams.}
00869 \textcolor{comment}{   inflate() will return Z\_STREAM\_END at the end of the gzip stream.  The state}
00870 \textcolor{comment}{   would need to be reset to continue decoding a subsequent gzip stream.}
00871 \textcolor{comment}{}
00872 \textcolor{comment}{     inflateInit2 returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough}
00873 \textcolor{comment}{   memory, Z\_VERSION\_ERROR if the zlib library version is incompatible with the}
00874 \textcolor{comment}{   version assumed by the caller, or Z\_STREAM\_ERROR if the parameters are}
00875 \textcolor{comment}{   invalid, such as a null pointer to the structure.  msg is set to null if}
00876 \textcolor{comment}{   there is no error message.  inflateInit2 does not perform any decompression}
00877 \textcolor{comment}{   apart from possibly reading the zlib header if present: actual decompression}
00878 \textcolor{comment}{   will be done by inflate().  (So next\_in and avail\_in may be modified, but}
00879 \textcolor{comment}{   next\_out and avail\_out are unused and unchanged.) The current implementation}
00880 \textcolor{comment}{   of inflateInit2() does not process any header information -- that is}
00881 \textcolor{comment}{   deferred until inflate() is called.}
00882 \textcolor{comment}{*/}
00883 
00884 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateSetDictionary OF((z\_streamp strm,
00885                                              \textcolor{keyword}{const} Bytef *dictionary,
00886                                              uInt  dictLength));
00887 \textcolor{comment}{/*}
00888 \textcolor{comment}{     Initializes the decompression dictionary from the given uncompressed byte}
00889 \textcolor{comment}{   sequence.  This function must be called immediately after a call of inflate,}
00890 \textcolor{comment}{   if that call returned Z\_NEED\_DICT.  The dictionary chosen by the compressor}
00891 \textcolor{comment}{   can be determined from the Adler-32 value returned by that call of inflate.}
00892 \textcolor{comment}{   The compressor and decompressor must use exactly the same dictionary (see}
00893 \textcolor{comment}{   deflateSetDictionary).  For raw inflate, this function can be called at any}
00894 \textcolor{comment}{   time to set the dictionary.  If the provided dictionary is smaller than the}
00895 \textcolor{comment}{   window and there is already data in the window, then the provided dictionary}
00896 \textcolor{comment}{   will amend what's there.  The application must insure that the dictionary}
00897 \textcolor{comment}{   that was used for compression is provided.}
00898 \textcolor{comment}{}
00899 \textcolor{comment}{     inflateSetDictionary returns Z\_OK if success, Z\_STREAM\_ERROR if a}
00900 \textcolor{comment}{   parameter is invalid (e.g.  dictionary being Z\_NULL) or the stream state is}
00901 \textcolor{comment}{   inconsistent, Z\_DATA\_ERROR if the given dictionary doesn't match the}
00902 \textcolor{comment}{   expected one (incorrect Adler-32 value).  inflateSetDictionary does not}
00903 \textcolor{comment}{   perform any decompression: this will be done by subsequent calls of}
00904 \textcolor{comment}{   inflate().}
00905 \textcolor{comment}{*/}
00906 
00907 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateGetDictionary OF((z\_streamp strm,
00908                                              Bytef *dictionary,
00909                                              uInt  *dictLength));
00910 \textcolor{comment}{/*}
00911 \textcolor{comment}{     Returns the sliding dictionary being maintained by inflate.  dictLength is}
00912 \textcolor{comment}{   set to the number of bytes in the dictionary, and that many bytes are copied}
00913 \textcolor{comment}{   to dictionary.  dictionary must have enough space, where 32768 bytes is}
00914 \textcolor{comment}{   always enough.  If inflateGetDictionary() is called with dictionary equal to}
00915 \textcolor{comment}{   Z\_NULL, then only the dictionary length is returned, and nothing is copied.}
00916 \textcolor{comment}{   Similary, if dictLength is Z\_NULL, then it is not set.}
00917 \textcolor{comment}{}
00918 \textcolor{comment}{     inflateGetDictionary returns Z\_OK on success, or Z\_STREAM\_ERROR if the}
00919 \textcolor{comment}{   stream state is inconsistent.}
00920 \textcolor{comment}{*/}
00921 
00922 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateSync OF((z\_streamp strm));
00923 \textcolor{comment}{/*}
00924 \textcolor{comment}{     Skips invalid compressed data until a possible full flush point (see above}
00925 \textcolor{comment}{   for the description of deflate with Z\_FULL\_FLUSH) can be found, or until all}
00926 \textcolor{comment}{   available input is skipped.  No output is provided.}
00927 \textcolor{comment}{}
00928 \textcolor{comment}{     inflateSync searches for a 00 00 FF FF pattern in the compressed data.}
00929 \textcolor{comment}{   All full flush points have this pattern, but not all occurrences of this}
00930 \textcolor{comment}{   pattern are full flush points.}
00931 \textcolor{comment}{}
00932 \textcolor{comment}{     inflateSync returns Z\_OK if a possible full flush point has been found,}
00933 \textcolor{comment}{   Z\_BUF\_ERROR if no more input was provided, Z\_DATA\_ERROR if no flush point}
00934 \textcolor{comment}{   has been found, or Z\_STREAM\_ERROR if the stream structure was inconsistent.}
00935 \textcolor{comment}{   In the success case, the application may save the current current value of}
00936 \textcolor{comment}{   total\_in which indicates where valid compressed data was found.  In the}
00937 \textcolor{comment}{   error case, the application may repeatedly call inflateSync, providing more}
00938 \textcolor{comment}{   input each time, until success or end of the input data.}
00939 \textcolor{comment}{*/}
00940 
00941 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateCopy OF((z\_streamp dest,
00942                                     z\_streamp source));
00943 \textcolor{comment}{/*}
00944 \textcolor{comment}{     Sets the destination stream as a complete copy of the source stream.}
00945 \textcolor{comment}{}
00946 \textcolor{comment}{     This function can be useful when randomly accessing a large stream.  The}
00947 \textcolor{comment}{   first pass through the stream can periodically record the inflate state,}
00948 \textcolor{comment}{   allowing restarting inflate at those points when randomly accessing the}
00949 \textcolor{comment}{   stream.}
00950 \textcolor{comment}{}
00951 \textcolor{comment}{     inflateCopy returns Z\_OK if success, Z\_MEM\_ERROR if there was not}
00952 \textcolor{comment}{   enough memory, Z\_STREAM\_ERROR if the source stream state was inconsistent}
00953 \textcolor{comment}{   (such as zalloc being Z\_NULL).  msg is left unchanged in both source and}
00954 \textcolor{comment}{   destination.}
00955 \textcolor{comment}{*/}
00956 
00957 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateReset OF((z\_streamp strm));
00958 \textcolor{comment}{/*}
00959 \textcolor{comment}{     This function is equivalent to inflateEnd followed by inflateInit,}
00960 \textcolor{comment}{   but does not free and reallocate the internal decompression state.  The}
00961 \textcolor{comment}{   stream will keep attributes that may have been set by inflateInit2.}
00962 \textcolor{comment}{}
00963 \textcolor{comment}{     inflateReset returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
00964 \textcolor{comment}{   stream state was inconsistent (such as zalloc or state being Z\_NULL).}
00965 \textcolor{comment}{*/}
00966 
00967 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateReset2 OF((z\_streamp strm,
00968                                       \textcolor{keywordtype}{int} windowBits));
00969 \textcolor{comment}{/*}
00970 \textcolor{comment}{     This function is the same as inflateReset, but it also permits changing}
00971 \textcolor{comment}{   the wrap and window size requests.  The windowBits parameter is interpreted}
00972 \textcolor{comment}{   the same as it is for inflateInit2.  If the window size is changed, then the}
00973 \textcolor{comment}{   memory allocated for the window is freed, and the window will be reallocated}
00974 \textcolor{comment}{   by inflate() if needed.}
00975 \textcolor{comment}{}
00976 \textcolor{comment}{     inflateReset2 returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
00977 \textcolor{comment}{   stream state was inconsistent (such as zalloc or state being Z\_NULL), or if}
00978 \textcolor{comment}{   the windowBits parameter is invalid.}
00979 \textcolor{comment}{*/}
00980 
00981 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflatePrime OF((z\_streamp strm,
00982                                      \textcolor{keywordtype}{int} bits,
00983                                      \textcolor{keywordtype}{int} value));
00984 \textcolor{comment}{/*}
00985 \textcolor{comment}{     This function inserts bits in the inflate input stream.  The intent is}
00986 \textcolor{comment}{   that this function is used to start inflating at a bit position in the}
00987 \textcolor{comment}{   middle of a byte.  The provided bits will be used before any bytes are used}
00988 \textcolor{comment}{   from next\_in.  This function should only be used with raw inflate, and}
00989 \textcolor{comment}{   should be used before the first inflate() call after inflateInit2() or}
00990 \textcolor{comment}{   inflateReset().  bits must be less than or equal to 16, and that many of the}
00991 \textcolor{comment}{   least significant bits of value will be inserted in the input.}
00992 \textcolor{comment}{}
00993 \textcolor{comment}{     If bits is negative, then the input stream bit buffer is emptied.  Then}
00994 \textcolor{comment}{   inflatePrime() can be called again to put bits in the buffer.  This is used}
00995 \textcolor{comment}{   to clear out bits leftover after feeding inflate a block description prior}
00996 \textcolor{comment}{   to feeding inflate codes.}
00997 \textcolor{comment}{}
00998 \textcolor{comment}{     inflatePrime returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
00999 \textcolor{comment}{   stream state was inconsistent.}
01000 \textcolor{comment}{*/}
01001 
01002 ZEXTERN \textcolor{keywordtype}{long} ZEXPORT inflateMark OF((z\_streamp strm));
01003 \textcolor{comment}{/*}
01004 \textcolor{comment}{     This function returns two values, one in the lower 16 bits of the return}
01005 \textcolor{comment}{   value, and the other in the remaining upper bits, obtained by shifting the}
01006 \textcolor{comment}{   return value down 16 bits.  If the upper value is -1 and the lower value is}
01007 \textcolor{comment}{   zero, then inflate() is currently decoding information outside of a block.}
01008 \textcolor{comment}{   If the upper value is -1 and the lower value is non-zero, then inflate is in}
01009 \textcolor{comment}{   the middle of a stored block, with the lower value equaling the number of}
01010 \textcolor{comment}{   bytes from the input remaining to copy.  If the upper value is not -1, then}
01011 \textcolor{comment}{   it is the number of bits back from the current bit position in the input of}
01012 \textcolor{comment}{   the code (literal or length/distance pair) currently being processed.  In}
01013 \textcolor{comment}{   that case the lower value is the number of bytes already emitted for that}
01014 \textcolor{comment}{   code.}
01015 \textcolor{comment}{}
01016 \textcolor{comment}{     A code is being processed if inflate is waiting for more input to complete}
01017 \textcolor{comment}{   decoding of the code, or if it has completed decoding but is waiting for}
01018 \textcolor{comment}{   more output space to write the literal or match data.}
01019 \textcolor{comment}{}
01020 \textcolor{comment}{     inflateMark() is used to mark locations in the input data for random}
01021 \textcolor{comment}{   access, which may be at bit positions, and to note those cases where the}
01022 \textcolor{comment}{   output of a code may span boundaries of random access blocks.  The current}
01023 \textcolor{comment}{   location in the input stream can be determined from avail\_in and data\_type}
01024 \textcolor{comment}{   as noted in the description for the Z\_BLOCK flush parameter for inflate.}
01025 \textcolor{comment}{}
01026 \textcolor{comment}{     inflateMark returns the value noted above, or -65536 if the provided}
01027 \textcolor{comment}{   source stream state was inconsistent.}
01028 \textcolor{comment}{*/}
01029 
01030 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateGetHeader OF((z\_streamp strm,
01031                                          gz\_headerp head));
01032 \textcolor{comment}{/*}
01033 \textcolor{comment}{     inflateGetHeader() requests that gzip header information be stored in the}
01034 \textcolor{comment}{   provided gz\_header structure.  inflateGetHeader() may be called after}
01035 \textcolor{comment}{   inflateInit2() or inflateReset(), and before the first call of inflate().}
01036 \textcolor{comment}{   As inflate() processes the gzip stream, head->done is zero until the header}
01037 \textcolor{comment}{   is completed, at which time head->done is set to one.  If a zlib stream is}
01038 \textcolor{comment}{   being decoded, then head->done is set to -1 to indicate that there will be}
01039 \textcolor{comment}{   no gzip header information forthcoming.  Note that Z\_BLOCK or Z\_TREES can be}
01040 \textcolor{comment}{   used to force inflate() to return immediately after header processing is}
01041 \textcolor{comment}{   complete and before any actual data is decompressed.}
01042 \textcolor{comment}{}
01043 \textcolor{comment}{     The text, time, xflags, and os fields are filled in with the gzip header}
01044 \textcolor{comment}{   contents.  hcrc is set to true if there is a header CRC.  (The header CRC}
01045 \textcolor{comment}{   was valid if done is set to one.) If extra is not Z\_NULL, then extra\_max}
01046 \textcolor{comment}{   contains the maximum number of bytes to write to extra.  Once done is true,}
01047 \textcolor{comment}{   extra\_len contains the actual extra field length, and extra contains the}
01048 \textcolor{comment}{   extra field, or that field truncated if extra\_max is less than extra\_len.}
01049 \textcolor{comment}{   If name is not Z\_NULL, then up to name\_max characters are written there,}
01050 \textcolor{comment}{   terminated with a zero unless the length is greater than name\_max.  If}
01051 \textcolor{comment}{   comment is not Z\_NULL, then up to comm\_max characters are written there,}
01052 \textcolor{comment}{   terminated with a zero unless the length is greater than comm\_max.  When any}
01053 \textcolor{comment}{   of extra, name, or comment are not Z\_NULL and the respective field is not}
01054 \textcolor{comment}{   present in the header, then that field is set to Z\_NULL to signal its}
01055 \textcolor{comment}{   absence.  This allows the use of deflateSetHeader() with the returned}
01056 \textcolor{comment}{   structure to duplicate the header.  However if those fields are set to}
01057 \textcolor{comment}{   allocated memory, then the application will need to save those pointers}
01058 \textcolor{comment}{   elsewhere so that they can be eventually freed.}
01059 \textcolor{comment}{}
01060 \textcolor{comment}{     If inflateGetHeader is not used, then the header information is simply}
01061 \textcolor{comment}{   discarded.  The header is always checked for validity, including the header}
01062 \textcolor{comment}{   CRC if present.  inflateReset() will reset the process to discard the header}
01063 \textcolor{comment}{   information.  The application would need to call inflateGetHeader() again to}
01064 \textcolor{comment}{   retrieve the header from the next gzip stream.}
01065 \textcolor{comment}{}
01066 \textcolor{comment}{     inflateGetHeader returns Z\_OK if success, or Z\_STREAM\_ERROR if the source}
01067 \textcolor{comment}{   stream state was inconsistent.}
01068 \textcolor{comment}{*/}
01069 
01070 \textcolor{comment}{/*}
01071 \textcolor{comment}{ZEXTERN int ZEXPORT inflateBackInit OF((z\_streamp strm, int windowBits,}
01072 \textcolor{comment}{                                        unsigned char FAR *window));}
01073 \textcolor{comment}{}
01074 \textcolor{comment}{     Initialize the internal stream state for decompression using inflateBack()}
01075 \textcolor{comment}{   calls.  The fields zalloc, zfree and opaque in strm must be initialized}
01076 \textcolor{comment}{   before the call.  If zalloc and zfree are Z\_NULL, then the default library-}
01077 \textcolor{comment}{   derived memory allocation routines are used.  windowBits is the base two}
01078 \textcolor{comment}{   logarithm of the window size, in the range 8..15.  window is a caller}
01079 \textcolor{comment}{   supplied buffer of that size.  Except for special applications where it is}
01080 \textcolor{comment}{   assured that deflate was used with small window sizes, windowBits must be 15}
01081 \textcolor{comment}{   and a 32K byte window must be supplied to be able to decompress general}
01082 \textcolor{comment}{   deflate streams.}
01083 \textcolor{comment}{}
01084 \textcolor{comment}{     See inflateBack() for the usage of these routines.}
01085 \textcolor{comment}{}
01086 \textcolor{comment}{     inflateBackInit will return Z\_OK on success, Z\_STREAM\_ERROR if any of}
01087 \textcolor{comment}{   the parameters are invalid, Z\_MEM\_ERROR if the internal state could not be}
01088 \textcolor{comment}{   allocated, or Z\_VERSION\_ERROR if the version of the library does not match}
01089 \textcolor{comment}{   the version of the header file.}
01090 \textcolor{comment}{*/}
01091 
01092 \textcolor{keyword}{typedef} unsigned (*in\_func) OF((\textcolor{keywordtype}{void} FAR *,
01093                                 z\_const \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR * FAR *));
01094 \textcolor{keyword}{typedef} int (*out\_func) OF((\textcolor{keywordtype}{void} FAR *, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *, \textcolor{keywordtype}{unsigned}));
01095 
01096 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateBack OF((z\_streamp strm,
01097                                     in\_func in, \textcolor{keywordtype}{void} FAR *in\_desc,
01098                                     out\_func out, \textcolor{keywordtype}{void} FAR *out\_desc));
01099 \textcolor{comment}{/*}
01100 \textcolor{comment}{     inflateBack() does a raw inflate with a single call using a call-back}
01101 \textcolor{comment}{   interface for input and output.  This is potentially more efficient than}
01102 \textcolor{comment}{   inflate() for file i/o applications, in that it avoids copying between the}
01103 \textcolor{comment}{   output and the sliding window by simply making the window itself the output}
01104 \textcolor{comment}{   buffer.  inflate() can be faster on modern CPUs when used with large}
01105 \textcolor{comment}{   buffers.  inflateBack() trusts the application to not change the output}
01106 \textcolor{comment}{   buffer passed by the output function, at least until inflateBack() returns.}
01107 \textcolor{comment}{}
01108 \textcolor{comment}{     inflateBackInit() must be called first to allocate the internal state}
01109 \textcolor{comment}{   and to initialize the state with the user-provided window buffer.}
01110 \textcolor{comment}{   inflateBack() may then be used multiple times to inflate a complete, raw}
01111 \textcolor{comment}{   deflate stream with each call.  inflateBackEnd() is then called to free the}
01112 \textcolor{comment}{   allocated state.}
01113 \textcolor{comment}{}
01114 \textcolor{comment}{     A raw deflate stream is one with no zlib or gzip header or trailer.}
01115 \textcolor{comment}{   This routine would normally be used in a utility that reads zip or gzip}
01116 \textcolor{comment}{   files and writes out uncompressed files.  The utility would decode the}
01117 \textcolor{comment}{   header and process the trailer on its own, hence this routine expects only}
01118 \textcolor{comment}{   the raw deflate stream to decompress.  This is different from the default}
01119 \textcolor{comment}{   behavior of inflate(), which expects a zlib header and trailer around the}
01120 \textcolor{comment}{   deflate stream.}
01121 \textcolor{comment}{}
01122 \textcolor{comment}{     inflateBack() uses two subroutines supplied by the caller that are then}
01123 \textcolor{comment}{   called by inflateBack() for input and output.  inflateBack() calls those}
01124 \textcolor{comment}{   routines until it reads a complete deflate stream and writes out all of the}
01125 \textcolor{comment}{   uncompressed data, or until it encounters an error.  The function's}
01126 \textcolor{comment}{   parameters and return types are defined above in the in\_func and out\_func}
01127 \textcolor{comment}{   typedefs.  inflateBack() will call in(in\_desc, &buf) which should return the}
01128 \textcolor{comment}{   number of bytes of provided input, and a pointer to that input in buf.  If}
01129 \textcolor{comment}{   there is no input available, in() must return zero -- buf is ignored in that}
01130 \textcolor{comment}{   case -- and inflateBack() will return a buffer error.  inflateBack() will}
01131 \textcolor{comment}{   call out(out\_desc, buf, len) to write the uncompressed data buf[0..len-1].}
01132 \textcolor{comment}{   out() should return zero on success, or non-zero on failure.  If out()}
01133 \textcolor{comment}{   returns non-zero, inflateBack() will return with an error.  Neither in() nor}
01134 \textcolor{comment}{   out() are permitted to change the contents of the window provided to}
01135 \textcolor{comment}{   inflateBackInit(), which is also the buffer that out() uses to write from.}
01136 \textcolor{comment}{   The length written by out() will be at most the window size.  Any non-zero}
01137 \textcolor{comment}{   amount of input may be provided by in().}
01138 \textcolor{comment}{}
01139 \textcolor{comment}{     For convenience, inflateBack() can be provided input on the first call by}
01140 \textcolor{comment}{   setting strm->next\_in and strm->avail\_in.  If that input is exhausted, then}
01141 \textcolor{comment}{   in() will be called.  Therefore strm->next\_in must be initialized before}
01142 \textcolor{comment}{   calling inflateBack().  If strm->next\_in is Z\_NULL, then in() will be called}
01143 \textcolor{comment}{   immediately for input.  If strm->next\_in is not Z\_NULL, then strm->avail\_in}
01144 \textcolor{comment}{   must also be initialized, and then if strm->avail\_in is not zero, input will}
01145 \textcolor{comment}{   initially be taken from strm->next\_in[0 ..  strm->avail\_in - 1].}
01146 \textcolor{comment}{}
01147 \textcolor{comment}{     The in\_desc and out\_desc parameters of inflateBack() is passed as the}
01148 \textcolor{comment}{   first parameter of in() and out() respectively when they are called.  These}
01149 \textcolor{comment}{   descriptors can be optionally used to pass any information that the caller-}
01150 \textcolor{comment}{   supplied in() and out() functions need to do their job.}
01151 \textcolor{comment}{}
01152 \textcolor{comment}{     On return, inflateBack() will set strm->next\_in and strm->avail\_in to}
01153 \textcolor{comment}{   pass back any unused input that was provided by the last in() call.  The}
01154 \textcolor{comment}{   return values of inflateBack() can be Z\_STREAM\_END on success, Z\_BUF\_ERROR}
01155 \textcolor{comment}{   if in() or out() returned an error, Z\_DATA\_ERROR if there was a format error}
01156 \textcolor{comment}{   in the deflate stream (in which case strm->msg is set to indicate the nature}
01157 \textcolor{comment}{   of the error), or Z\_STREAM\_ERROR if the stream was not properly initialized.}
01158 \textcolor{comment}{   In the case of Z\_BUF\_ERROR, an input or output error can be distinguished}
01159 \textcolor{comment}{   using strm->next\_in which will be Z\_NULL only if in() returned an error.  If}
01160 \textcolor{comment}{   strm->next\_in is not Z\_NULL, then the Z\_BUF\_ERROR was due to out() returning}
01161 \textcolor{comment}{   non-zero.  (in() will always be called before out(), so strm->next\_in is}
01162 \textcolor{comment}{   assured to be defined if out() returns non-zero.)  Note that inflateBack()}
01163 \textcolor{comment}{   cannot return Z\_OK.}
01164 \textcolor{comment}{*/}
01165 
01166 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateBackEnd OF((z\_streamp strm));
01167 \textcolor{comment}{/*}
01168 \textcolor{comment}{     All memory allocated by inflateBackInit() is freed.}
01169 \textcolor{comment}{}
01170 \textcolor{comment}{     inflateBackEnd() returns Z\_OK on success, or Z\_STREAM\_ERROR if the stream}
01171 \textcolor{comment}{   state was inconsistent.}
01172 \textcolor{comment}{*/}
01173 
01174 ZEXTERN uLong ZEXPORT zlibCompileFlags OF((\textcolor{keywordtype}{void}));
01175 \textcolor{comment}{/* Return flags indicating compile-time options.}
01176 \textcolor{comment}{}
01177 \textcolor{comment}{    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:}
01178 \textcolor{comment}{     1.0: size of uInt}
01179 \textcolor{comment}{     3.2: size of uLong}
01180 \textcolor{comment}{     5.4: size of voidpf (pointer)}
01181 \textcolor{comment}{     7.6: size of z\_off\_t}
01182 \textcolor{comment}{}
01183 \textcolor{comment}{    Compiler, assembler, and debug options:}
01184 \textcolor{comment}{     8: ZLIB\_DEBUG}
01185 \textcolor{comment}{     9: ASMV or ASMINF -- use ASM code}
01186 \textcolor{comment}{     10: ZLIB\_WINAPI -- exported functions use the WINAPI calling convention}
01187 \textcolor{comment}{     11: 0 (reserved)}
01188 \textcolor{comment}{}
01189 \textcolor{comment}{    One-time table building (smaller code, but not thread-safe if true):}
01190 \textcolor{comment}{     12: BUILDFIXED -- build static block decoding tables when needed}
01191 \textcolor{comment}{     13: DYNAMIC\_CRC\_TABLE -- build CRC calculation tables when needed}
01192 \textcolor{comment}{     14,15: 0 (reserved)}
01193 \textcolor{comment}{}
01194 \textcolor{comment}{    Library content (indicates missing functionality):}
01195 \textcolor{comment}{     16: NO\_GZCOMPRESS -- gz* functions cannot compress (to avoid linking}
01196 \textcolor{comment}{                          deflate code when not needed)}
01197 \textcolor{comment}{     17: NO\_GZIP -- deflate can't write gzip streams, and inflate can't detect}
01198 \textcolor{comment}{                    and decode gzip streams (to avoid linking crc code)}
01199 \textcolor{comment}{     18-19: 0 (reserved)}
01200 \textcolor{comment}{}
01201 \textcolor{comment}{    Operation variations (changes in library functionality):}
01202 \textcolor{comment}{     20: PKZIP\_BUG\_WORKAROUND -- slightly more permissive inflate}
01203 \textcolor{comment}{     21: FASTEST -- deflate algorithm with only one, lowest compression level}
01204 \textcolor{comment}{     22,23: 0 (reserved)}
01205 \textcolor{comment}{}
01206 \textcolor{comment}{    The sprintf variant used by gzprintf (zero is best):}
01207 \textcolor{comment}{     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format}
01208 \textcolor{comment}{     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!}
01209 \textcolor{comment}{     26: 0 = returns value, 1 = void -- 1 means inferred string length returned}
01210 \textcolor{comment}{}
01211 \textcolor{comment}{    Remainder:}
01212 \textcolor{comment}{     27-31: 0 (reserved)}
01213 \textcolor{comment}{ */}
01214 
01215 \textcolor{preprocessor}{#ifndef Z\_SOLO}
01216 
01217                         \textcolor{comment}{/* utility functions */}
01218 
01219 \textcolor{comment}{/*}
01220 \textcolor{comment}{     The following utility functions are implemented on top of the basic}
01221 \textcolor{comment}{   stream-oriented functions.  To simplify the interface, some default options}
01222 \textcolor{comment}{   are assumed (compression level and memory usage, standard memory allocation}
01223 \textcolor{comment}{   functions).  The source code of these utility functions can be modified if}
01224 \textcolor{comment}{   you need special options.}
01225 \textcolor{comment}{*/}
01226 
01227 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
01228                                  \textcolor{keyword}{const} Bytef *source, uLong sourceLen));
01229 \textcolor{comment}{/*}
01230 \textcolor{comment}{     Compresses the source buffer into the destination buffer.  sourceLen is}
01231 \textcolor{comment}{   the byte length of the source buffer.  Upon entry, destLen is the total size}
01232 \textcolor{comment}{   of the destination buffer, which must be at least the value returned by}
01233 \textcolor{comment}{   compressBound(sourceLen).  Upon exit, destLen is the actual size of the}
01234 \textcolor{comment}{   compressed data.  compress() is equivalent to compress2() with a level}
01235 \textcolor{comment}{   parameter of Z\_DEFAULT\_COMPRESSION.}
01236 \textcolor{comment}{}
01237 \textcolor{comment}{     compress returns Z\_OK if success, Z\_MEM\_ERROR if there was not}
01238 \textcolor{comment}{   enough memory, Z\_BUF\_ERROR if there was not enough room in the output}
01239 \textcolor{comment}{   buffer.}
01240 \textcolor{comment}{*/}
01241 
01242 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
01243                                   \textcolor{keyword}{const} Bytef *source, uLong sourceLen,
01244                                   \textcolor{keywordtype}{int} level));
01245 \textcolor{comment}{/*}
01246 \textcolor{comment}{     Compresses the source buffer into the destination buffer.  The level}
01247 \textcolor{comment}{   parameter has the same meaning as in deflateInit.  sourceLen is the byte}
01248 \textcolor{comment}{   length of the source buffer.  Upon entry, destLen is the total size of the}
01249 \textcolor{comment}{   destination buffer, which must be at least the value returned by}
01250 \textcolor{comment}{   compressBound(sourceLen).  Upon exit, destLen is the actual size of the}
01251 \textcolor{comment}{   compressed data.}
01252 \textcolor{comment}{}
01253 \textcolor{comment}{     compress2 returns Z\_OK if success, Z\_MEM\_ERROR if there was not enough}
01254 \textcolor{comment}{   memory, Z\_BUF\_ERROR if there was not enough room in the output buffer,}
01255 \textcolor{comment}{   Z\_STREAM\_ERROR if the level parameter is invalid.}
01256 \textcolor{comment}{*/}
01257 
01258 ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
01259 \textcolor{comment}{/*}
01260 \textcolor{comment}{     compressBound() returns an upper bound on the compressed size after}
01261 \textcolor{comment}{   compress() or compress2() on sourceLen bytes.  It would be used before a}
01262 \textcolor{comment}{   compress() or compress2() call to allocate the destination buffer.}
01263 \textcolor{comment}{*/}
01264 
01265 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
01266                                    \textcolor{keyword}{const} Bytef *source, uLong sourceLen));
01267 \textcolor{comment}{/*}
01268 \textcolor{comment}{     Decompresses the source buffer into the destination buffer.  sourceLen is}
01269 \textcolor{comment}{   the byte length of the source buffer.  Upon entry, destLen is the total size}
01270 \textcolor{comment}{   of the destination buffer, which must be large enough to hold the entire}
01271 \textcolor{comment}{   uncompressed data.  (The size of the uncompressed data must have been saved}
01272 \textcolor{comment}{   previously by the compressor and transmitted to the decompressor by some}
01273 \textcolor{comment}{   mechanism outside the scope of this compression library.) Upon exit, destLen}
01274 \textcolor{comment}{   is the actual size of the uncompressed data.}
01275 \textcolor{comment}{}
01276 \textcolor{comment}{     uncompress returns Z\_OK if success, Z\_MEM\_ERROR if there was not}
01277 \textcolor{comment}{   enough memory, Z\_BUF\_ERROR if there was not enough room in the output}
01278 \textcolor{comment}{   buffer, or Z\_DATA\_ERROR if the input data was corrupted or incomplete.  In}
01279 \textcolor{comment}{   the case where there is not enough room, uncompress() will fill the output}
01280 \textcolor{comment}{   buffer with the uncompressed data up to that point.}
01281 \textcolor{comment}{*/}
01282 
01283 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT uncompress2 OF((Bytef *dest,   uLongf *destLen,
01284                                     \textcolor{keyword}{const} Bytef *source, uLong *sourceLen));
01285 \textcolor{comment}{/*}
01286 \textcolor{comment}{     Same as uncompress, except that sourceLen is a pointer, where the}
01287 \textcolor{comment}{   length of the source is *sourceLen.  On return, *sourceLen is the number of}
01288 \textcolor{comment}{   source bytes consumed.}
01289 \textcolor{comment}{*/}
01290 
01291                         \textcolor{comment}{/* gzip file access functions */}
01292 
01293 \textcolor{comment}{/*}
01294 \textcolor{comment}{     This library supports reading and writing files in gzip (.gz) format with}
01295 \textcolor{comment}{   an interface similar to that of stdio, using the functions that start with}
01296 \textcolor{comment}{   "gz".  The gzip format is different from the zlib format.  gzip is a gzip}
01297 \textcolor{comment}{   wrapper, documented in RFC 1952, wrapped around a deflate stream.}
01298 \textcolor{comment}{*/}
01299 
01300 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structgz_file__s}{gzFile\_s} *\hyperlink{structgz_file__s}{gzFile};    \textcolor{comment}{/* semi-opaque gzip file descriptor */}
01301 
01302 \textcolor{comment}{/*}
01303 \textcolor{comment}{ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));}
01304 \textcolor{comment}{}
01305 \textcolor{comment}{     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as}
01306 \textcolor{comment}{   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or}
01307 \textcolor{comment}{   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only}
01308 \textcolor{comment}{   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'}
01309 \textcolor{comment}{   for fixed code compression as in "wb9F".  (See the description of}
01310 \textcolor{comment}{   deflateInit2 for more information about the strategy parameter.)  'T' will}
01311 \textcolor{comment}{   request transparent writing or appending with no compression and not using}
01312 \textcolor{comment}{   the gzip format.}
01313 \textcolor{comment}{}
01314 \textcolor{comment}{     "a" can be used instead of "w" to request that the gzip stream that will}
01315 \textcolor{comment}{   be written be appended to the file.  "+" will result in an error, since}
01316 \textcolor{comment}{   reading and writing to the same gzip file is not supported.  The addition of}
01317 \textcolor{comment}{   "x" when writing will create the file exclusively, which fails if the file}
01318 \textcolor{comment}{   already exists.  On systems that support it, the addition of "e" when}
01319 \textcolor{comment}{   reading or writing will set the flag to close the file on an execve() call.}
01320 \textcolor{comment}{}
01321 \textcolor{comment}{     These functions, as well as gzip, will read and decode a sequence of gzip}
01322 \textcolor{comment}{   streams in a file.  The append function of gzopen() can be used to create}
01323 \textcolor{comment}{   such a file.  (Also see gzflush() for another way to do this.)  When}
01324 \textcolor{comment}{   appending, gzopen does not test whether the file begins with a gzip stream,}
01325 \textcolor{comment}{   nor does it look for the end of the gzip streams to begin appending.  gzopen}
01326 \textcolor{comment}{   will simply append a gzip stream to the existing file.}
01327 \textcolor{comment}{}
01328 \textcolor{comment}{     gzopen can be used to read a file which is not in gzip format; in this}
01329 \textcolor{comment}{   case gzread will directly read from the file without decompression.  When}
01330 \textcolor{comment}{   reading, this will be detected automatically by looking for the magic two-}
01331 \textcolor{comment}{   byte gzip header.}
01332 \textcolor{comment}{}
01333 \textcolor{comment}{     gzopen returns NULL if the file could not be opened, if there was}
01334 \textcolor{comment}{   insufficient memory to allocate the gzFile state, or if an invalid mode was}
01335 \textcolor{comment}{   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).}
01336 \textcolor{comment}{   errno can be checked to determine if the reason gzopen failed was that the}
01337 \textcolor{comment}{   file could not be opened.}
01338 \textcolor{comment}{*/}
01339 
01340 ZEXTERN gzFile ZEXPORT gzdopen OF((\textcolor{keywordtype}{int} fd, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *mode));
01341 \textcolor{comment}{/*}
01342 \textcolor{comment}{     gzdopen associates a gzFile with the file descriptor fd.  File descriptors}
01343 \textcolor{comment}{   are obtained from calls like open, dup, creat, pipe or fileno (if the file}
01344 \textcolor{comment}{   has been previously opened with fopen).  The mode parameter is as in gzopen.}
01345 \textcolor{comment}{}
01346 \textcolor{comment}{     The next call of gzclose on the returned gzFile will also close the file}
01347 \textcolor{comment}{   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor}
01348 \textcolor{comment}{   fd.  If you want to keep fd open, use fd = dup(fd\_keep); gz = gzdopen(fd,}
01349 \textcolor{comment}{   mode);.  The duplicated descriptor should be saved to avoid a leak, since}
01350 \textcolor{comment}{   gzdopen does not close fd if it fails.  If you are using fileno() to get the}
01351 \textcolor{comment}{   file descriptor from a FILE *, then you will have to use dup() to avoid}
01352 \textcolor{comment}{   double-close()ing the file descriptor.  Both gzclose() and fclose() will}
01353 \textcolor{comment}{   close the associated file descriptor, so they need to have different file}
01354 \textcolor{comment}{   descriptors.}
01355 \textcolor{comment}{}
01356 \textcolor{comment}{     gzdopen returns NULL if there was insufficient memory to allocate the}
01357 \textcolor{comment}{   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not}
01358 \textcolor{comment}{   provided, or '+' was provided), or if fd is -1.  The file descriptor is not}
01359 \textcolor{comment}{   used until the next gz* read, write, seek, or close operation, so gzdopen}
01360 \textcolor{comment}{   will not detect if fd is invalid (unless fd is -1).}
01361 \textcolor{comment}{*/}
01362 
01363 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzbuffer OF((gzFile \hyperlink{structfile}{file}, \textcolor{keywordtype}{unsigned} size));
01364 \textcolor{comment}{/*}
01365 \textcolor{comment}{     Set the internal buffer size used by this library's functions.  The}
01366 \textcolor{comment}{   default buffer size is 8192 bytes.  This function must be called after}
01367 \textcolor{comment}{   gzopen() or gzdopen(), and before any other calls that read or write the}
01368 \textcolor{comment}{   file.  The buffer memory allocation is always deferred to the first read or}
01369 \textcolor{comment}{   write.  Three times that size in buffer space is allocated.  A larger buffer}
01370 \textcolor{comment}{   size of, for example, 64K or 128K bytes will noticeably increase the speed}
01371 \textcolor{comment}{   of decompression (reading).}
01372 \textcolor{comment}{}
01373 \textcolor{comment}{     The new buffer size also affects the maximum length for gzprintf().}
01374 \textcolor{comment}{}
01375 \textcolor{comment}{     gzbuffer() returns 0 on success, or -1 on failure, such as being called}
01376 \textcolor{comment}{   too late.}
01377 \textcolor{comment}{*/}
01378 
01379 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzsetparams OF((gzFile \hyperlink{structfile}{file}, \textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} strategy));
01380 \textcolor{comment}{/*}
01381 \textcolor{comment}{     Dynamically update the compression level or strategy.  See the description}
01382 \textcolor{comment}{   of deflateInit2 for the meaning of these parameters.  Previously provided}
01383 \textcolor{comment}{   data is flushed before the parameter change.}
01384 \textcolor{comment}{}
01385 \textcolor{comment}{     gzsetparams returns Z\_OK if success, Z\_STREAM\_ERROR if the file was not}
01386 \textcolor{comment}{   opened for writing, Z\_ERRNO if there is an error writing the flushed data,}
01387 \textcolor{comment}{   or Z\_MEM\_ERROR if there is a memory allocation error.}
01388 \textcolor{comment}{*/}
01389 
01390 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzread OF((gzFile \hyperlink{structfile}{file}, voidp buf, \textcolor{keywordtype}{unsigned} len));
01391 \textcolor{comment}{/*}
01392 \textcolor{comment}{     Reads the given number of uncompressed bytes from the compressed file.  If}
01393 \textcolor{comment}{   the input file is not in gzip format, gzread copies the given number of}
01394 \textcolor{comment}{   bytes into the buffer directly from the file.}
01395 \textcolor{comment}{}
01396 \textcolor{comment}{     After reaching the end of a gzip stream in the input, gzread will continue}
01397 \textcolor{comment}{   to read, looking for another gzip stream.  Any number of gzip streams may be}
01398 \textcolor{comment}{   concatenated in the input file, and will all be decompressed by gzread().}
01399 \textcolor{comment}{   If something other than a gzip stream is encountered after a gzip stream,}
01400 \textcolor{comment}{   that remaining trailing garbage is ignored (and no error is returned).}
01401 \textcolor{comment}{}
01402 \textcolor{comment}{     gzread can be used to read a gzip file that is being concurrently written.}
01403 \textcolor{comment}{   Upon reaching the end of the input, gzread will return with the available}
01404 \textcolor{comment}{   data.  If the error code returned by gzerror is Z\_OK or Z\_BUF\_ERROR, then}
01405 \textcolor{comment}{   gzclearerr can be used to clear the end of file indicator in order to permit}
01406 \textcolor{comment}{   gzread to be tried again.  Z\_OK indicates that a gzip stream was completed}
01407 \textcolor{comment}{   on the last gzread.  Z\_BUF\_ERROR indicates that the input file ended in the}
01408 \textcolor{comment}{   middle of a gzip stream.  Note that gzread does not return -1 in the event}
01409 \textcolor{comment}{   of an incomplete gzip stream.  This error is deferred until gzclose(), which}
01410 \textcolor{comment}{   will return Z\_BUF\_ERROR if the last gzread ended in the middle of a gzip}
01411 \textcolor{comment}{   stream.  Alternatively, gzerror can be used before gzclose to detect this}
01412 \textcolor{comment}{   case.}
01413 \textcolor{comment}{}
01414 \textcolor{comment}{     gzread returns the number of uncompressed bytes actually read, less than}
01415 \textcolor{comment}{   len for end of file, or -1 for error.  If len is too large to fit in an int,}
01416 \textcolor{comment}{   then nothing is read, -1 is returned, and the error state is set to}
01417 \textcolor{comment}{   Z\_STREAM\_ERROR.}
01418 \textcolor{comment}{*/}
01419 
01420 ZEXTERN z\_size\_t ZEXPORT gzfread OF((voidp buf, z\_size\_t size, z\_size\_t nitems,
01421                                      gzFile \hyperlink{structfile}{file}));
01422 \textcolor{comment}{/*}
01423 \textcolor{comment}{     Read up to nitems items of size size from file to buf, otherwise operating}
01424 \textcolor{comment}{   as gzread() does.  This duplicates the interface of stdio's fread(), with}
01425 \textcolor{comment}{   size\_t request and return types.  If the library defines size\_t, then}
01426 \textcolor{comment}{   z\_size\_t is identical to size\_t.  If not, then z\_size\_t is an unsigned}
01427 \textcolor{comment}{   integer type that can contain a pointer.}
01428 \textcolor{comment}{}
01429 \textcolor{comment}{     gzfread() returns the number of full items read of size size, or zero if}
01430 \textcolor{comment}{   the end of the file was reached and a full item could not be read, or if}
01431 \textcolor{comment}{   there was an error.  gzerror() must be consulted if zero is returned in}
01432 \textcolor{comment}{   order to determine if there was an error.  If the multiplication of size and}
01433 \textcolor{comment}{   nitems overflows, i.e. the product does not fit in a z\_size\_t, then nothing}
01434 \textcolor{comment}{   is read, zero is returned, and the error state is set to Z\_STREAM\_ERROR.}
01435 \textcolor{comment}{}
01436 \textcolor{comment}{     In the event that the end of file is reached and only a partial item is}
01437 \textcolor{comment}{   available at the end, i.e. the remaining uncompressed data length is not a}
01438 \textcolor{comment}{   multiple of size, then the final partial item is nevetheless read into buf}
01439 \textcolor{comment}{   and the end-of-file flag is set.  The length of the partial item read is not}
01440 \textcolor{comment}{   provided, but could be inferred from the result of gztell().  This behavior}
01441 \textcolor{comment}{   is the same as the behavior of fread() implementations in common libraries,}
01442 \textcolor{comment}{   but it prevents the direct use of gzfread() to read a concurrently written}
01443 \textcolor{comment}{   file, reseting and retrying on end-of-file, when size is not 1.}
01444 \textcolor{comment}{*/}
01445 
01446 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzwrite OF((gzFile \hyperlink{structfile}{file},
01447                                 voidpc buf, \textcolor{keywordtype}{unsigned} len));
01448 \textcolor{comment}{/*}
01449 \textcolor{comment}{     Writes the given number of uncompressed bytes into the compressed file.}
01450 \textcolor{comment}{   gzwrite returns the number of uncompressed bytes written or 0 in case of}
01451 \textcolor{comment}{   error.}
01452 \textcolor{comment}{*/}
01453 
01454 ZEXTERN z\_size\_t ZEXPORT gzfwrite OF((voidpc buf, z\_size\_t size,
01455                                       z\_size\_t nitems, gzFile \hyperlink{structfile}{file}));
01456 \textcolor{comment}{/*}
01457 \textcolor{comment}{     gzfwrite() writes nitems items of size size from buf to file, duplicating}
01458 \textcolor{comment}{   the interface of stdio's fwrite(), with size\_t request and return types.  If}
01459 \textcolor{comment}{   the library defines size\_t, then z\_size\_t is identical to size\_t.  If not,}
01460 \textcolor{comment}{   then z\_size\_t is an unsigned integer type that can contain a pointer.}
01461 \textcolor{comment}{}
01462 \textcolor{comment}{     gzfwrite() returns the number of full items written of size size, or zero}
01463 \textcolor{comment}{   if there was an error.  If the multiplication of size and nitems overflows,}
01464 \textcolor{comment}{   i.e. the product does not fit in a z\_size\_t, then nothing is written, zero}
01465 \textcolor{comment}{   is returned, and the error state is set to Z\_STREAM\_ERROR.}
01466 \textcolor{comment}{*/}
01467 
01468 ZEXTERN \textcolor{keywordtype}{int} ZEXPORTVA gzprintf Z\_ARG((gzFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *format, ...));
01469 \textcolor{comment}{/*}
01470 \textcolor{comment}{     Converts, formats, and writes the arguments to the compressed file under}
01471 \textcolor{comment}{   control of the format string, as in fprintf.  gzprintf returns the number of}
01472 \textcolor{comment}{   uncompressed bytes actually written, or a negative zlib error code in case}
01473 \textcolor{comment}{   of error.  The number of uncompressed bytes written is limited to 8191, or}
01474 \textcolor{comment}{   one less than the buffer size given to gzbuffer().  The caller should assure}
01475 \textcolor{comment}{   that this limit is not exceeded.  If it is exceeded, then gzprintf() will}
01476 \textcolor{comment}{   return an error (0) with nothing written.  In this case, there may also be a}
01477 \textcolor{comment}{   buffer overflow with unpredictable consequences, which is possible only if}
01478 \textcolor{comment}{   zlib was compiled with the insecure functions sprintf() or vsprintf()}
01479 \textcolor{comment}{   because the secure snprintf() or vsnprintf() functions were not available.}
01480 \textcolor{comment}{   This can be determined using zlibCompileFlags().}
01481 \textcolor{comment}{*/}
01482 
01483 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzputs OF((gzFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s));
01484 \textcolor{comment}{/*}
01485 \textcolor{comment}{     Writes the given null-terminated string to the compressed file, excluding}
01486 \textcolor{comment}{   the terminating null character.}
01487 \textcolor{comment}{}
01488 \textcolor{comment}{     gzputs returns the number of characters written, or -1 in case of error.}
01489 \textcolor{comment}{*/}
01490 
01491 ZEXTERN \textcolor{keywordtype}{char} * ZEXPORT gzgets OF((gzFile \hyperlink{structfile}{file}, \textcolor{keywordtype}{char} *buf, \textcolor{keywordtype}{int} len));
01492 \textcolor{comment}{/*}
01493 \textcolor{comment}{     Reads bytes from the compressed file until len-1 characters are read, or a}
01494 \textcolor{comment}{   newline character is read and transferred to buf, or an end-of-file}
01495 \textcolor{comment}{   condition is encountered.  If any characters are read or if len == 1, the}
01496 \textcolor{comment}{   string is terminated with a null character.  If no characters are read due}
01497 \textcolor{comment}{   to an end-of-file or len < 1, then the buffer is left untouched.}
01498 \textcolor{comment}{}
01499 \textcolor{comment}{     gzgets returns buf which is a null-terminated string, or it returns NULL}
01500 \textcolor{comment}{   for end-of-file or in case of error.  If there was an error, the contents at}
01501 \textcolor{comment}{   buf are indeterminate.}
01502 \textcolor{comment}{*/}
01503 
01504 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzputc OF((gzFile \hyperlink{structfile}{file}, \textcolor{keywordtype}{int} c));
01505 \textcolor{comment}{/*}
01506 \textcolor{comment}{     Writes c, converted to an unsigned char, into the compressed file.  gzputc}
01507 \textcolor{comment}{   returns the value that was written, or -1 in case of error.}
01508 \textcolor{comment}{*/}
01509 
01510 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzgetc OF((gzFile \hyperlink{structfile}{file}));
01511 \textcolor{comment}{/*}
01512 \textcolor{comment}{     Reads one byte from the compressed file.  gzgetc returns this byte or -1}
01513 \textcolor{comment}{   in case of end of file or error.  This is implemented as a macro for speed.}
01514 \textcolor{comment}{   As such, it does not do all of the checking the other functions do.  I.e.}
01515 \textcolor{comment}{   it does not check to see if file is NULL, nor whether the structure file}
01516 \textcolor{comment}{   points to has been clobbered or not.}
01517 \textcolor{comment}{*/}
01518 
01519 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzungetc OF((\textcolor{keywordtype}{int} c, gzFile \hyperlink{structfile}{file}));
01520 \textcolor{comment}{/*}
01521 \textcolor{comment}{     Push one character back onto the stream to be read as the first character}
01522 \textcolor{comment}{   on the next read.  At least one character of push-back is allowed.}
01523 \textcolor{comment}{   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will}
01524 \textcolor{comment}{   fail if c is -1, and may fail if a character has been pushed but not read}
01525 \textcolor{comment}{   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the}
01526 \textcolor{comment}{   output buffer size of pushed characters is allowed.  (See gzbuffer above.)}
01527 \textcolor{comment}{   The pushed character will be discarded if the stream is repositioned with}
01528 \textcolor{comment}{   gzseek() or gzrewind().}
01529 \textcolor{comment}{*/}
01530 
01531 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzflush OF((gzFile \hyperlink{structfile}{file}, \textcolor{keywordtype}{int} flush));
01532 \textcolor{comment}{/*}
01533 \textcolor{comment}{     Flushes all pending output into the compressed file.  The parameter flush}
01534 \textcolor{comment}{   is as in the deflate() function.  The return value is the zlib error number}
01535 \textcolor{comment}{   (see function gzerror below).  gzflush is only permitted when writing.}
01536 \textcolor{comment}{}
01537 \textcolor{comment}{     If the flush parameter is Z\_FINISH, the remaining data is written and the}
01538 \textcolor{comment}{   gzip stream is completed in the output.  If gzwrite() is called again, a new}
01539 \textcolor{comment}{   gzip stream will be started in the output.  gzread() is able to read such}
01540 \textcolor{comment}{   concatenated gzip streams.}
01541 \textcolor{comment}{}
01542 \textcolor{comment}{     gzflush should be called only when strictly necessary because it will}
01543 \textcolor{comment}{   degrade compression if called too often.}
01544 \textcolor{comment}{*/}
01545 
01546 \textcolor{comment}{/*}
01547 \textcolor{comment}{ZEXTERN z\_off\_t ZEXPORT gzseek OF((gzFile file,}
01548 \textcolor{comment}{                                   z\_off\_t offset, int whence));}
01549 \textcolor{comment}{}
01550 \textcolor{comment}{     Sets the starting position for the next gzread or gzwrite on the given}
01551 \textcolor{comment}{   compressed file.  The offset represents a number of bytes in the}
01552 \textcolor{comment}{   uncompressed data stream.  The whence parameter is defined as in lseek(2);}
01553 \textcolor{comment}{   the value SEEK\_END is not supported.}
01554 \textcolor{comment}{}
01555 \textcolor{comment}{     If the file is opened for reading, this function is emulated but can be}
01556 \textcolor{comment}{   extremely slow.  If the file is opened for writing, only forward seeks are}
01557 \textcolor{comment}{   supported; gzseek then compresses a sequence of zeroes up to the new}
01558 \textcolor{comment}{   starting position.}
01559 \textcolor{comment}{}
01560 \textcolor{comment}{     gzseek returns the resulting offset location as measured in bytes from}
01561 \textcolor{comment}{   the beginning of the uncompressed stream, or -1 in case of error, in}
01562 \textcolor{comment}{   particular if the file is opened for writing and the new starting position}
01563 \textcolor{comment}{   would be before the current position.}
01564 \textcolor{comment}{*/}
01565 
01566 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT    gzrewind OF((gzFile \hyperlink{structfile}{file}));
01567 \textcolor{comment}{/*}
01568 \textcolor{comment}{     Rewinds the given file. This function is supported only for reading.}
01569 \textcolor{comment}{}
01570 \textcolor{comment}{     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK\_SET)}
01571 \textcolor{comment}{*/}
01572 
01573 \textcolor{comment}{/*}
01574 \textcolor{comment}{ZEXTERN z\_off\_t ZEXPORT    gztell OF((gzFile file));}
01575 \textcolor{comment}{}
01576 \textcolor{comment}{     Returns the starting position for the next gzread or gzwrite on the given}
01577 \textcolor{comment}{   compressed file.  This position represents a number of bytes in the}
01578 \textcolor{comment}{   uncompressed data stream, and is zero when starting, even if appending or}
01579 \textcolor{comment}{   reading a gzip stream from the middle of a file using gzdopen().}
01580 \textcolor{comment}{}
01581 \textcolor{comment}{     gztell(file) is equivalent to gzseek(file, 0L, SEEK\_CUR)}
01582 \textcolor{comment}{*/}
01583 
01584 \textcolor{comment}{/*}
01585 \textcolor{comment}{ZEXTERN z\_off\_t ZEXPORT gzoffset OF((gzFile file));}
01586 \textcolor{comment}{}
01587 \textcolor{comment}{     Returns the current offset in the file being read or written.  This offset}
01588 \textcolor{comment}{   includes the count of bytes that precede the gzip stream, for example when}
01589 \textcolor{comment}{   appending or when using gzdopen() for reading.  When reading, the offset}
01590 \textcolor{comment}{   does not include as yet unused buffered input.  This information can be used}
01591 \textcolor{comment}{   for a progress indicator.  On error, gzoffset() returns -1.}
01592 \textcolor{comment}{*/}
01593 
01594 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzeof OF((gzFile \hyperlink{structfile}{file}));
01595 \textcolor{comment}{/*}
01596 \textcolor{comment}{     Returns true (1) if the end-of-file indicator has been set while reading,}
01597 \textcolor{comment}{   false (0) otherwise.  Note that the end-of-file indicator is set only if the}
01598 \textcolor{comment}{   read tried to go past the end of the input, but came up short.  Therefore,}
01599 \textcolor{comment}{   just like feof(), gzeof() may return false even if there is no more data to}
01600 \textcolor{comment}{   read, in the event that the last read request was for the exact number of}
01601 \textcolor{comment}{   bytes remaining in the input file.  This will happen if the input file size}
01602 \textcolor{comment}{   is an exact multiple of the buffer size.}
01603 \textcolor{comment}{}
01604 \textcolor{comment}{     If gzeof() returns true, then the read functions will return no more data,}
01605 \textcolor{comment}{   unless the end-of-file indicator is reset by gzclearerr() and the input file}
01606 \textcolor{comment}{   has grown since the previous end of file was detected.}
01607 \textcolor{comment}{*/}
01608 
01609 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzdirect OF((gzFile \hyperlink{structfile}{file}));
01610 \textcolor{comment}{/*}
01611 \textcolor{comment}{     Returns true (1) if file is being copied directly while reading, or false}
01612 \textcolor{comment}{   (0) if file is a gzip stream being decompressed.}
01613 \textcolor{comment}{}
01614 \textcolor{comment}{     If the input file is empty, gzdirect() will return true, since the input}
01615 \textcolor{comment}{   does not contain a gzip stream.}
01616 \textcolor{comment}{}
01617 \textcolor{comment}{     If gzdirect() is used immediately after gzopen() or gzdopen() it will}
01618 \textcolor{comment}{   cause buffers to be allocated to allow reading the file to determine if it}
01619 \textcolor{comment}{   is a gzip file.  Therefore if gzbuffer() is used, it should be called before}
01620 \textcolor{comment}{   gzdirect().}
01621 \textcolor{comment}{}
01622 \textcolor{comment}{     When writing, gzdirect() returns true (1) if transparent writing was}
01623 \textcolor{comment}{   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:}
01624 \textcolor{comment}{   gzdirect() is not needed when writing.  Transparent writing must be}
01625 \textcolor{comment}{   explicitly requested, so the application already knows the answer.  When}
01626 \textcolor{comment}{   linking statically, using gzdirect() will include all of the zlib code for}
01627 \textcolor{comment}{   gzip file reading and decompression, which may not be desired.)}
01628 \textcolor{comment}{*/}
01629 
01630 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT    gzclose OF((gzFile \hyperlink{structfile}{file}));
01631 \textcolor{comment}{/*}
01632 \textcolor{comment}{     Flushes all pending output if necessary, closes the compressed file and}
01633 \textcolor{comment}{   deallocates the (de)compression state.  Note that once file is closed, you}
01634 \textcolor{comment}{   cannot call gzerror with file, since its structures have been deallocated.}
01635 \textcolor{comment}{   gzclose must not be called more than once on the same file, just as free}
01636 \textcolor{comment}{   must not be called more than once on the same allocation.}
01637 \textcolor{comment}{}
01638 \textcolor{comment}{     gzclose will return Z\_STREAM\_ERROR if file is not valid, Z\_ERRNO on a}
01639 \textcolor{comment}{   file operation error, Z\_MEM\_ERROR if out of memory, Z\_BUF\_ERROR if the}
01640 \textcolor{comment}{   last read ended in the middle of a gzip stream, or Z\_OK on success.}
01641 \textcolor{comment}{*/}
01642 
01643 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzclose\_r OF((gzFile \hyperlink{structfile}{file}));
01644 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzclose\_w OF((gzFile \hyperlink{structfile}{file}));
01645 \textcolor{comment}{/*}
01646 \textcolor{comment}{     Same as gzclose(), but gzclose\_r() is only for use when reading, and}
01647 \textcolor{comment}{   gzclose\_w() is only for use when writing or appending.  The advantage to}
01648 \textcolor{comment}{   using these instead of gzclose() is that they avoid linking in zlib}
01649 \textcolor{comment}{   compression or decompression code that is not used when only reading or only}
01650 \textcolor{comment}{   writing respectively.  If gzclose() is used, then both compression and}
01651 \textcolor{comment}{   decompression code will be included the application when linking to a static}
01652 \textcolor{comment}{   zlib library.}
01653 \textcolor{comment}{*/}
01654 
01655 ZEXTERN \textcolor{keyword}{const} \textcolor{keywordtype}{char} * ZEXPORT gzerror OF((gzFile \hyperlink{structfile}{file}, \textcolor{keywordtype}{int} *errnum));
01656 \textcolor{comment}{/*}
01657 \textcolor{comment}{     Returns the error message for the last error which occurred on the given}
01658 \textcolor{comment}{   compressed file.  errnum is set to zlib error number.  If an error occurred}
01659 \textcolor{comment}{   in the file system and not in the compression library, errnum is set to}
01660 \textcolor{comment}{   Z\_ERRNO and the application may consult errno to get the exact error code.}
01661 \textcolor{comment}{}
01662 \textcolor{comment}{     The application must not modify the returned string.  Future calls to}
01663 \textcolor{comment}{   this function may invalidate the previously returned string.  If file is}
01664 \textcolor{comment}{   closed, then the string previously returned by gzerror will no longer be}
01665 \textcolor{comment}{   available.}
01666 \textcolor{comment}{}
01667 \textcolor{comment}{     gzerror() should be used to distinguish errors from end-of-file for those}
01668 \textcolor{comment}{   functions above that do not distinguish those cases in their return values.}
01669 \textcolor{comment}{*/}
01670 
01671 ZEXTERN \textcolor{keywordtype}{void} ZEXPORT gzclearerr OF((gzFile \hyperlink{structfile}{file}));
01672 \textcolor{comment}{/*}
01673 \textcolor{comment}{     Clears the error and end-of-file flags for file.  This is analogous to the}
01674 \textcolor{comment}{   clearerr() function in stdio.  This is useful for continuing to read a gzip}
01675 \textcolor{comment}{   file that is being written concurrently.}
01676 \textcolor{comment}{*/}
01677 
01678 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !Z\_SOLO */}\textcolor{preprocessor}{}
01679 
01680                         \textcolor{comment}{/* checksum functions */}
01681 
01682 \textcolor{comment}{/*}
01683 \textcolor{comment}{     These functions are not related to compression but are exported}
01684 \textcolor{comment}{   anyway because they might be useful in applications using the compression}
01685 \textcolor{comment}{   library.}
01686 \textcolor{comment}{*/}
01687 
01688 ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, \textcolor{keyword}{const} Bytef *buf, uInt len));
01689 \textcolor{comment}{/*}
01690 \textcolor{comment}{     Update a running Adler-32 checksum with the bytes buf[0..len-1] and}
01691 \textcolor{comment}{   return the updated checksum.  If buf is Z\_NULL, this function returns the}
01692 \textcolor{comment}{   required initial value for the checksum.}
01693 \textcolor{comment}{}
01694 \textcolor{comment}{     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed}
01695 \textcolor{comment}{   much faster.}
01696 \textcolor{comment}{}
01697 \textcolor{comment}{   Usage example:}
01698 \textcolor{comment}{}
01699 \textcolor{comment}{     uLong adler = adler32(0L, Z\_NULL, 0);}
01700 \textcolor{comment}{}
01701 \textcolor{comment}{     while (read\_buffer(buffer, length) != EOF) \{}
01702 \textcolor{comment}{       adler = adler32(adler, buffer, length);}
01703 \textcolor{comment}{     \}}
01704 \textcolor{comment}{     if (adler != original\_adler) error();}
01705 \textcolor{comment}{*/}
01706 
01707 ZEXTERN uLong ZEXPORT adler32\_z OF((uLong adler, \textcolor{keyword}{const} Bytef *buf,
01708                                     z\_size\_t len));
01709 \textcolor{comment}{/*}
01710 \textcolor{comment}{     Same as adler32(), but with a size\_t length.}
01711 \textcolor{comment}{*/}
01712 
01713 \textcolor{comment}{/*}
01714 \textcolor{comment}{ZEXTERN uLong ZEXPORT adler32\_combine OF((uLong adler1, uLong adler2,}
01715 \textcolor{comment}{                                          z\_off\_t len2));}
01716 \textcolor{comment}{}
01717 \textcolor{comment}{     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1}
01718 \textcolor{comment}{   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for}
01719 \textcolor{comment}{   each, adler1 and adler2.  adler32\_combine() returns the Adler-32 checksum of}
01720 \textcolor{comment}{   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note}
01721 \textcolor{comment}{   that the z\_off\_t type (like off\_t) is a signed integer.  If len2 is}
01722 \textcolor{comment}{   negative, the result has no meaning or utility.}
01723 \textcolor{comment}{*/}
01724 
01725 ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, \textcolor{keyword}{const} Bytef *buf, uInt len));
01726 \textcolor{comment}{/*}
01727 \textcolor{comment}{     Update a running CRC-32 with the bytes buf[0..len-1] and return the}
01728 \textcolor{comment}{   updated CRC-32.  If buf is Z\_NULL, this function returns the required}
01729 \textcolor{comment}{   initial value for the crc.  Pre- and post-conditioning (one's complement) is}
01730 \textcolor{comment}{   performed within this function so it shouldn't be done by the application.}
01731 \textcolor{comment}{}
01732 \textcolor{comment}{   Usage example:}
01733 \textcolor{comment}{}
01734 \textcolor{comment}{     uLong crc = crc32(0L, Z\_NULL, 0);}
01735 \textcolor{comment}{}
01736 \textcolor{comment}{     while (read\_buffer(buffer, length) != EOF) \{}
01737 \textcolor{comment}{       crc = crc32(crc, buffer, length);}
01738 \textcolor{comment}{     \}}
01739 \textcolor{comment}{     if (crc != original\_crc) error();}
01740 \textcolor{comment}{*/}
01741 
01742 ZEXTERN uLong ZEXPORT crc32\_z OF((uLong adler, \textcolor{keyword}{const} Bytef *buf,
01743                                   z\_size\_t len));
01744 \textcolor{comment}{/*}
01745 \textcolor{comment}{     Same as crc32(), but with a size\_t length.}
01746 \textcolor{comment}{*/}
01747 
01748 \textcolor{comment}{/*}
01749 \textcolor{comment}{ZEXTERN uLong ZEXPORT crc32\_combine OF((uLong crc1, uLong crc2, z\_off\_t len2));}
01750 \textcolor{comment}{}
01751 \textcolor{comment}{     Combine two CRC-32 check values into one.  For two sequences of bytes,}
01752 \textcolor{comment}{   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were}
01753 \textcolor{comment}{   calculated for each, crc1 and crc2.  crc32\_combine() returns the CRC-32}
01754 \textcolor{comment}{   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and}
01755 \textcolor{comment}{   len2.}
01756 \textcolor{comment}{*/}
01757 
01758 
01759                         \textcolor{comment}{/* various hacks, don't look :) */}
01760 
01761 \textcolor{comment}{/* deflateInit and inflateInit are macros to allow checking the zlib version}
01762 \textcolor{comment}{ * and the compiler's view of z\_stream:}
01763 \textcolor{comment}{ */}
01764 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateInit\_ OF((z\_streamp strm, \textcolor{keywordtype}{int} level,
01765                                      \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version, \textcolor{keywordtype}{int} stream\_size));
01766 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateInit\_ OF((z\_streamp strm,
01767                                      \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version, \textcolor{keywordtype}{int} stream\_size));
01768 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT deflateInit2\_ OF((z\_streamp strm, \textcolor{keywordtype}{int}  level, \textcolor{keywordtype}{int}  method,
01769                                       \textcolor{keywordtype}{int} windowBits, \textcolor{keywordtype}{int} memLevel,
01770                                       \textcolor{keywordtype}{int} strategy, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version,
01771                                       \textcolor{keywordtype}{int} stream\_size));
01772 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateInit2\_ OF((z\_streamp strm, \textcolor{keywordtype}{int}  windowBits,
01773                                       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version, \textcolor{keywordtype}{int} stream\_size));
01774 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT inflateBackInit\_ OF((z\_streamp strm, \textcolor{keywordtype}{int} windowBits,
01775                                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *window,
01776                                          \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version,
01777                                          \textcolor{keywordtype}{int} stream\_size));
01778 \textcolor{preprocessor}{#ifdef Z\_PREFIX\_SET}
01779 \textcolor{preprocessor}{#  define z\_deflateInit(strm, level) \(\backslash\)}
01780 \textcolor{preprocessor}{          deflateInit\_((strm), (level), ZLIB\_VERSION, (int)sizeof(z\_stream))}
01781 \textcolor{preprocessor}{#  define z\_inflateInit(strm) \(\backslash\)}
01782 \textcolor{preprocessor}{          inflateInit\_((strm), ZLIB\_VERSION, (int)sizeof(z\_stream))}
01783 \textcolor{preprocessor}{#  define z\_deflateInit2(strm, level, method, windowBits, memLevel, strategy) \(\backslash\)}
01784 \textcolor{preprocessor}{          deflateInit2\_((strm),(level),(method),(windowBits),(memLevel),\(\backslash\)}
01785 \textcolor{preprocessor}{                        (strategy), ZLIB\_VERSION, (int)sizeof(z\_stream))}
01786 \textcolor{preprocessor}{#  define z\_inflateInit2(strm, windowBits) \(\backslash\)}
01787 \textcolor{preprocessor}{          inflateInit2\_((strm), (windowBits), ZLIB\_VERSION, \(\backslash\)}
01788 \textcolor{preprocessor}{                        (int)sizeof(z\_stream))}
01789 \textcolor{preprocessor}{#  define z\_inflateBackInit(strm, windowBits, window) \(\backslash\)}
01790 \textcolor{preprocessor}{          inflateBackInit\_((strm), (windowBits), (window), \(\backslash\)}
01791 \textcolor{preprocessor}{                           ZLIB\_VERSION, (int)sizeof(z\_stream))}
01792 \textcolor{preprocessor}{#else}
01793 \textcolor{preprocessor}{#  define deflateInit(strm, level) \(\backslash\)}
01794 \textcolor{preprocessor}{          deflateInit\_((strm), (level), ZLIB\_VERSION, (int)sizeof(z\_stream))}
01795 \textcolor{preprocessor}{#  define inflateInit(strm) \(\backslash\)}
01796 \textcolor{preprocessor}{          inflateInit\_((strm), ZLIB\_VERSION, (int)sizeof(z\_stream))}
01797 \textcolor{preprocessor}{#  define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \(\backslash\)}
01798 \textcolor{preprocessor}{          deflateInit2\_((strm),(level),(method),(windowBits),(memLevel),\(\backslash\)}
01799 \textcolor{preprocessor}{                        (strategy), ZLIB\_VERSION, (int)sizeof(z\_stream))}
01800 \textcolor{preprocessor}{#  define inflateInit2(strm, windowBits) \(\backslash\)}
01801 \textcolor{preprocessor}{          inflateInit2\_((strm), (windowBits), ZLIB\_VERSION, \(\backslash\)}
01802 \textcolor{preprocessor}{                        (int)sizeof(z\_stream))}
01803 \textcolor{preprocessor}{#  define inflateBackInit(strm, windowBits, window) \(\backslash\)}
01804 \textcolor{preprocessor}{          inflateBackInit\_((strm), (windowBits), (window), \(\backslash\)}
01805 \textcolor{preprocessor}{                           ZLIB\_VERSION, (int)sizeof(z\_stream))}
01806 \textcolor{preprocessor}{#endif}
01807 
01808 \textcolor{preprocessor}{#ifndef Z\_SOLO}
01809 
01810 \textcolor{comment}{/* gzgetc() macro and its supporting function and exposed data structure.  Note}
01811 \textcolor{comment}{ * that the real internal state is much larger than the exposed structure.}
01812 \textcolor{comment}{ * This abbreviated structure exposes just enough for the gzgetc() macro.  The}
01813 \textcolor{comment}{ * user should not mess with these exposed elements, since their names or}
01814 \textcolor{comment}{ * behavior could change in the future, perhaps even capriciously.  They can}
01815 \textcolor{comment}{ * only be used by the gzgetc() macro.  You have been warned.}
01816 \textcolor{comment}{ */}
01817 \textcolor{keyword}{struct }\hyperlink{structgz_file__s}{gzFile\_s} \{
01818     \textcolor{keywordtype}{unsigned} have;
01819     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *next;
01820     z\_off64\_t pos;
01821 \};
01822 ZEXTERN \textcolor{keywordtype}{int} ZEXPORT gzgetc\_ OF((gzFile \hyperlink{structfile}{file}));  \textcolor{comment}{/* backward compatibility */}
01823 \textcolor{preprocessor}{#ifdef Z\_PREFIX\_SET}
01824 \textcolor{preprocessor}{#  undef z\_gzgetc}
01825 \textcolor{preprocessor}{#  define z\_gzgetc(g) \(\backslash\)}
01826 \textcolor{preprocessor}{          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))}
01827 \textcolor{preprocessor}{#else}
01828 \textcolor{preprocessor}{#  define gzgetc(g) \(\backslash\)}
01829 \textcolor{preprocessor}{          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))}
01830 \textcolor{preprocessor}{#endif}
01831 
01832 \textcolor{comment}{/* provide 64-bit offset functions if \_LARGEFILE64\_SOURCE defined, and/or}
01833 \textcolor{comment}{ * change the regular functions to 64 bits if \_FILE\_OFFSET\_BITS is 64 (if}
01834 \textcolor{comment}{ * both are true, the application gets the *64 functions, and the regular}
01835 \textcolor{comment}{ * functions are changed to 64 bits) -- in case these are set on systems}
01836 \textcolor{comment}{ * without large file support, \_LFS64\_LARGEFILE must also be true}
01837 \textcolor{comment}{ */}
01838 \textcolor{preprocessor}{#ifdef Z\_LARGE64}
01839    ZEXTERN gzFile ZEXPORT gzopen64 OF((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *));
01840    ZEXTERN z\_off64\_t ZEXPORT gzseek64 OF((gzFile, z\_off64\_t, \textcolor{keywordtype}{int}));
01841    ZEXTERN z\_off64\_t ZEXPORT gztell64 OF((gzFile));
01842    ZEXTERN z\_off64\_t ZEXPORT gzoffset64 OF((gzFile));
01843    ZEXTERN uLong ZEXPORT adler32\_combine64 OF((uLong, uLong, z\_off64\_t));
01844    ZEXTERN uLong ZEXPORT crc32\_combine64 OF((uLong, uLong, z\_off64\_t));
01845 \textcolor{preprocessor}{#endif}
01846 
01847 \textcolor{preprocessor}{#if !defined(ZLIB\_INTERNAL) && defined(Z\_WANT64)}
01848 \textcolor{preprocessor}{#  ifdef Z\_PREFIX\_SET}
01849 \textcolor{preprocessor}{#    define z\_gzopen z\_gzopen64}
01850 \textcolor{preprocessor}{#    define z\_gzseek z\_gzseek64}
01851 \textcolor{preprocessor}{#    define z\_gztell z\_gztell64}
01852 \textcolor{preprocessor}{#    define z\_gzoffset z\_gzoffset64}
01853 \textcolor{preprocessor}{#    define z\_adler32\_combine z\_adler32\_combine64}
01854 \textcolor{preprocessor}{#    define z\_crc32\_combine z\_crc32\_combine64}
01855 \textcolor{preprocessor}{#  else}
01856 \textcolor{preprocessor}{#    define gzopen gzopen64}
01857 \textcolor{preprocessor}{#    define gzseek gzseek64}
01858 \textcolor{preprocessor}{#    define gztell gztell64}
01859 \textcolor{preprocessor}{#    define gzoffset gzoffset64}
01860 \textcolor{preprocessor}{#    define adler32\_combine adler32\_combine64}
01861 \textcolor{preprocessor}{#    define crc32\_combine crc32\_combine64}
01862 \textcolor{preprocessor}{#  endif}
01863 \textcolor{preprocessor}{#  ifndef Z\_LARGE64}
01864      ZEXTERN gzFile ZEXPORT gzopen64 OF((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *));
01865      ZEXTERN z\_off\_t ZEXPORT gzseek64 OF((gzFile, z\_off\_t, \textcolor{keywordtype}{int}));
01866      ZEXTERN z\_off\_t ZEXPORT gztell64 OF((gzFile));
01867      ZEXTERN z\_off\_t ZEXPORT gzoffset64 OF((gzFile));
01868      ZEXTERN uLong ZEXPORT adler32\_combine64 OF((uLong, uLong, z\_off\_t));
01869      ZEXTERN uLong ZEXPORT crc32\_combine64 OF((uLong, uLong, z\_off\_t));
01870 \textcolor{preprocessor}{#  endif}
01871 \textcolor{preprocessor}{#else}
01872    ZEXTERN gzFile ZEXPORT gzopen OF((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *));
01873    ZEXTERN z\_off\_t ZEXPORT gzseek OF((gzFile, z\_off\_t, \textcolor{keywordtype}{int}));
01874    ZEXTERN z\_off\_t ZEXPORT gztell OF((gzFile));
01875    ZEXTERN z\_off\_t ZEXPORT gzoffset OF((gzFile));
01876    ZEXTERN uLong ZEXPORT adler32\_combine OF((uLong, uLong, z\_off\_t));
01877    ZEXTERN uLong ZEXPORT crc32\_combine OF((uLong, uLong, z\_off\_t));
01878 \textcolor{preprocessor}{#endif}
01879 
01880 \textcolor{preprocessor}{#else }\textcolor{comment}{/* Z\_SOLO */}\textcolor{preprocessor}{}
01881 
01882    ZEXTERN uLong ZEXPORT adler32\_combine OF((uLong, uLong, z\_off\_t));
01883    ZEXTERN uLong ZEXPORT crc32\_combine OF((uLong, uLong, z\_off\_t));
01884 
01885 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !Z\_SOLO */}\textcolor{preprocessor}{}
01886 
01887 \textcolor{comment}{/* undocumented functions */}
01888 ZEXTERN \textcolor{keyword}{const} \textcolor{keywordtype}{char}   * ZEXPORT zError           OF((\textcolor{keywordtype}{int}));
01889 ZEXTERN \textcolor{keywordtype}{int}            ZEXPORT inflateSyncPoint OF((z\_streamp));
01890 ZEXTERN \textcolor{keyword}{const} z\_crc\_t FAR * ZEXPORT get\_crc\_table    OF((\textcolor{keywordtype}{void}));
01891 ZEXTERN \textcolor{keywordtype}{int}            ZEXPORT inflateUndermine OF((z\_streamp, \textcolor{keywordtype}{int}));
01892 ZEXTERN \textcolor{keywordtype}{int}            ZEXPORT inflateValidate OF((z\_streamp, \textcolor{keywordtype}{int}));
01893 ZEXTERN \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}  ZEXPORT inflateCodesUsed OF ((z\_streamp));
01894 ZEXTERN \textcolor{keywordtype}{int}            ZEXPORT inflateResetKeep OF((z\_streamp));
01895 ZEXTERN \textcolor{keywordtype}{int}            ZEXPORT deflateResetKeep OF((z\_streamp));
01896 \textcolor{preprocessor}{#if (defined(\_WIN32) || defined(\_\_CYGWIN\_\_)) && !defined(Z\_SOLO)}
01897 ZEXTERN gzFile         ZEXPORT gzopen\_w OF((\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t} *path,
01898                                             \textcolor{keyword}{const} \textcolor{keywordtype}{char} *mode));
01899 \textcolor{preprocessor}{#endif}
01900 \textcolor{preprocessor}{#if defined(STDC) || defined(Z\_HAVE\_STDARG\_H)}
01901 \textcolor{preprocessor}{#  ifndef Z\_SOLO}
01902 ZEXTERN \textcolor{keywordtype}{int}            ZEXPORTVA gzvprintf Z\_ARG((gzFile \hyperlink{structfile}{file},
01903                                                   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *format,
01904                                                   va\_list va));
01905 \textcolor{preprocessor}{#  endif}
01906 \textcolor{preprocessor}{#endif}
01907 
01908 \textcolor{preprocessor}{#ifdef \_\_cplusplus}
01909 \}
01910 \textcolor{preprocessor}{#endif}
01911 
01912 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* ZLIB\_H */}\textcolor{preprocessor}{}
\end{DoxyCode}
