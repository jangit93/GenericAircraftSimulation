\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_morphing_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Morphing.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_morphing_8h_source}\index{Tensor\+Morphing.\+h@{Tensor\+Morphing.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_MORPHING\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_MORPHING\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NewDimensions, \textcolor{keyword}{typename} XprType>
00024 \textcolor{keyword}{struct }traits<TensorReshapingOp<NewDimensions, XprType> > : \textcolor{keyword}{public} traits<XprType>
00025 \{
00026   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00027   \textcolor{keyword}{typedef} traits<XprType> XprTraits;
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<Nested>::type \_Nested;
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = array\_size<NewDimensions>::value;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00034 \};
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NewDimensions, \textcolor{keyword}{typename} XprType>
00037 \textcolor{keyword}{struct }eval<TensorReshapingOp<NewDimensions, XprType>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00038 \{
00039   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorReshapingOp<NewDimensions, XprType>& type;
00040 \};
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NewDimensions, \textcolor{keyword}{typename} XprType>
00043 \textcolor{keyword}{struct }nested<TensorReshapingOp<NewDimensions, XprType>, 1, typename eval<TensorReshapingOp<NewDimensions, 
      XprType> >::type>
00044 \{
00045   \textcolor{keyword}{typedef} TensorReshapingOp<NewDimensions, XprType> type;
00046 \};
00047 
00048 \}  \textcolor{comment}{// end namespace internal}
00049 
00050 
00051 
00052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NewDimensions, \textcolor{keyword}{typename} XprType>
00053 \textcolor{keyword}{class }TensorReshapingOp : \textcolor{keyword}{public} TensorBase<TensorReshapingOp<NewDimensions, XprType>, WriteAccessors>
00054 \{
00055   \textcolor{keyword}{public}:
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorReshapingOp>::Scalar}
       Scalar;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<typename XprType::CoeffReturnType>::type CoeffReturnType;
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorReshapingOp>::type}
       Nested;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorReshapingOp>::StorageKind}
       StorageKind;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorReshapingOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00061 
00062   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorReshapingOp(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} NewDimensions& dims)
00063       : m\_xpr(expr), m\_dims(dims) \{\}
00064 
00065     EIGEN\_DEVICE\_FUNC
00066     \textcolor{keyword}{const} NewDimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dims; \}
00067 
00068     EIGEN\_DEVICE\_FUNC
00069     \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type&
00070     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00071 
00072     EIGEN\_DEVICE\_FUNC
00073     EIGEN\_STRONG\_INLINE TensorReshapingOp& operator = (\textcolor{keyword}{const} TensorReshapingOp& other)
00074     \{
00075       \textcolor{keyword}{typedef} TensorAssignOp<TensorReshapingOp, const TensorReshapingOp> Assign;
00076       Assign assign(*\textcolor{keyword}{this}, other);
00077       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00078       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00079     \}
00080 
00081     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00082     EIGEN\_DEVICE\_FUNC
00083     EIGEN\_STRONG\_INLINE TensorReshapingOp& operator = (\textcolor{keyword}{const} OtherDerived& other)
00084     \{
00085       \textcolor{keyword}{typedef} TensorAssignOp<TensorReshapingOp, const OtherDerived> Assign;
00086       Assign assign(*\textcolor{keyword}{this}, other);
00087       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00088       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00089     \}
00090 
00091   \textcolor{keyword}{protected}:
00092     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00093     \textcolor{keyword}{const} NewDimensions m\_dims;
00094 \};
00095 
00096 
00097 \textcolor{comment}{// Eval as rvalue}
00098 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NewDimensions, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00099 \textcolor{keyword}{struct }TensorEvaluator<const TensorReshapingOp<NewDimensions, ArgType>, Device>
00100 \{
00101   \textcolor{keyword}{typedef} TensorReshapingOp<NewDimensions, ArgType> XprType;
00102   \textcolor{keyword}{typedef} NewDimensions Dimensions;
00103 
00104   \textcolor{keyword}{enum} \{
00105     IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,
00106     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00107     Layout = TensorEvaluator<ArgType, Device>::Layout,
00108     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00109     RawAccess = TensorEvaluator<ArgType, Device>::RawAccess
00110   \};
00111 
00112   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00113       : m\_impl(op.expression(), device), m\_dimensions(op.dimensions())
00114   \{
00115     \textcolor{comment}{// The total size of the reshaped tensor must be equal to the total size}
00116     \textcolor{comment}{// of the input tensor.}
00117     eigen\_assert(internal::array\_prod(m\_impl.dimensions()) == internal::array\_prod(op.dimensions()));
00118   \}
00119 
00120   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00121   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00122   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00123   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00124 
00125   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00126 
00127   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(CoeffReturnType* data) \{
00128     \textcolor{keywordflow}{return} m\_impl.evalSubExprsIfNeeded(data);
00129   \}
00130   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00131     m\_impl.cleanup();
00132   \}
00133 
00134   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00135 \textcolor{keyword}{  }\{
00136     \textcolor{keywordflow}{return} m\_impl.coeff(index);
00137   \}
00138 
00139   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00140   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00141 \textcolor{keyword}{  }\{
00142     \textcolor{keywordflow}{return} m\_impl.template packet<LoadMode>(index);
00143   \}
00144 
00145   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorOpCost costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00146     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized);
00147   \}
00148 
00149   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{const\_cast<}Scalar*\textcolor{keyword}{>}(m\_impl.data()); \}
00150 
00151   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} TensorEvaluator<ArgType, Device>& impl()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_impl; \}
00152 
00153  \textcolor{keyword}{protected}:
00154   TensorEvaluator<ArgType, Device> m\_impl;
00155   NewDimensions m\_dimensions;
00156 \};
00157 
00158 
00159 \textcolor{comment}{// Eval as lvalue}
00160 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NewDimensions, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00161   \textcolor{keyword}{struct }TensorEvaluator<TensorReshapingOp<NewDimensions, ArgType>, Device>
00162   : \textcolor{keyword}{public} TensorEvaluator<const TensorReshapingOp<NewDimensions, ArgType>, Device>
00163 
00164 \{
00165   \textcolor{keyword}{typedef} TensorEvaluator<const TensorReshapingOp<NewDimensions, ArgType>, Device> Base;
00166   \textcolor{keyword}{typedef} TensorReshapingOp<NewDimensions, ArgType> XprType;
00167   \textcolor{keyword}{typedef} NewDimensions Dimensions;
00168 
00169   \textcolor{keyword}{enum} \{
00170     IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,
00171     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00172     Layout = TensorEvaluator<ArgType, Device>::Layout,
00173     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00174     RawAccess = TensorEvaluator<ArgType, Device>::RawAccess
00175   \};
00176 
00177   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00178     : Base(op, device)
00179   \{ \}
00180 
00181   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00182   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00183   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00184   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00185 
00186   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType& coeffRef(Index index)
00187   \{
00188     \textcolor{keywordflow}{return} this->m\_impl.coeffRef(index);
00189   \}
00190   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} StoreMode> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00191   \textcolor{keywordtype}{void} writePacket(Index index, \textcolor{keyword}{const} PacketReturnType& x)
00192   \{
00193     this->m\_impl.template writePacket<StoreMode>(index, x);
00194   \}
00195 \};
00196 
00197 
00205 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00206 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StartIndices, \textcolor{keyword}{typename} Sizes, \textcolor{keyword}{typename} XprType>
00207 \textcolor{keyword}{struct }traits<TensorSlicingOp<StartIndices, Sizes, XprType> > : \textcolor{keyword}{public} traits<XprType>
00208 \{
00209   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00210   \textcolor{keyword}{typedef} traits<XprType> XprTraits;
00211   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00212   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00213   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00214   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<Nested>::type \_Nested;
00215   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = array\_size<StartIndices>::value;
00216   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00217 \};
00218 
00219 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StartIndices, \textcolor{keyword}{typename} Sizes, \textcolor{keyword}{typename} XprType>
00220 \textcolor{keyword}{struct }eval<TensorSlicingOp<StartIndices, Sizes, XprType>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00221 \{
00222   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorSlicingOp<StartIndices, Sizes, XprType>& type;
00223 \};
00224 
00225 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StartIndices, \textcolor{keyword}{typename} Sizes, \textcolor{keyword}{typename} XprType>
00226 \textcolor{keyword}{struct }nested<TensorSlicingOp<StartIndices, Sizes, XprType>, 1, typename eval<TensorSlicingOp<StartIndices,
       Sizes, XprType> >::type>
00227 \{
00228   \textcolor{keyword}{typedef} TensorSlicingOp<StartIndices, Sizes, XprType> type;
00229 \};
00230 
00231 \}  \textcolor{comment}{// end namespace internal}
00232 
00233 
00234 
00235 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StartIndices, \textcolor{keyword}{typename} Sizes, \textcolor{keyword}{typename} XprType>
00236 \textcolor{keyword}{class }TensorSlicingOp : \textcolor{keyword}{public} TensorBase<TensorSlicingOp<StartIndices, Sizes, XprType> >
00237 \{
00238   \textcolor{keyword}{public}:
00239   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorSlicingOp>::Scalar}
       Scalar;
00240   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00241   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorSlicingOp>::type}
       Nested;
00242   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorSlicingOp>::StorageKind}
       StorageKind;
00243   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorSlicingOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00244 
00245   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorSlicingOp(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} StartIndices& indices, \textcolor{keyword}{
      const} Sizes& sizes)
00246       : m\_xpr(expr), m\_indices(indices), m\_sizes(sizes) \{\}
00247 
00248     EIGEN\_DEVICE\_FUNC
00249     \textcolor{keyword}{const} StartIndices& startIndices()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_indices; \}
00250     EIGEN\_DEVICE\_FUNC
00251     \textcolor{keyword}{const} Sizes& sizes()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_sizes; \}
00252 
00253     EIGEN\_DEVICE\_FUNC
00254     \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type&
00255     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00256 
00257     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00258     EIGEN\_DEVICE\_FUNC
00259     EIGEN\_STRONG\_INLINE TensorSlicingOp& operator = (\textcolor{keyword}{const} OtherDerived& other)
00260     \{
00261       \textcolor{keyword}{typedef} TensorAssignOp<TensorSlicingOp, const OtherDerived> Assign;
00262       Assign assign(*\textcolor{keyword}{this}, other);
00263       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00264       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00265     \}
00266 
00267     EIGEN\_DEVICE\_FUNC
00268     EIGEN\_STRONG\_INLINE TensorSlicingOp& operator = (\textcolor{keyword}{const} TensorSlicingOp& other)
00269     \{
00270       \textcolor{keyword}{typedef} TensorAssignOp<TensorSlicingOp, const TensorSlicingOp> Assign;
00271       Assign assign(*\textcolor{keyword}{this}, other);
00272       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00273       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00274     \}
00275 
00276 
00277   \textcolor{keyword}{protected}:
00278     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00279     \textcolor{keyword}{const} StartIndices m\_indices;
00280     \textcolor{keyword}{const} Sizes m\_sizes;
00281 \};
00282 
00283 
00284 \textcolor{comment}{// Fixme: figure out the exact threshold}
00285 \textcolor{keyword}{namespace }\{
00286 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} Device> \textcolor{keyword}{struct }MemcpyTriggerForSlicing \{
00287   EIGEN\_DEVICE\_FUNC MemcpyTriggerForSlicing(\textcolor{keyword}{const} Device& device) : threshold\_(2 * device.numThreads()) \{ \}
00288   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{bool} operator ()(Index val)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} val > threshold\_; \}
00289 
00290  \textcolor{keyword}{private}:
00291   Index threshold\_;
00292 \};
00293 
00294 \textcolor{comment}{// It is very expensive to start the memcpy kernel on GPU: we therefore only}
00295 \textcolor{comment}{// use it for large copies.}
00296 \textcolor{preprocessor}{#ifdef EIGEN\_USE\_GPU}
00297 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Index> \textcolor{keyword}{struct }MemcpyTriggerForSlicing<Index, GpuDevice>  \{
00298   EIGEN\_DEVICE\_FUNC MemcpyTriggerForSlicing(\textcolor{keyword}{const} GpuDevice&) \{ \}
00299   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{bool} operator ()(Index val)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} val > 4*1024*1024; \}
00300 \};
00301 \textcolor{preprocessor}{#endif}
00302 \}
00303 
00304 \textcolor{comment}{// Eval as rvalue}
00305 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StartIndices, \textcolor{keyword}{typename} Sizes, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00306 \textcolor{keyword}{struct }TensorEvaluator<const TensorSlicingOp<StartIndices, Sizes, ArgType>, Device>
00307 \{
00308   \textcolor{keyword}{typedef} TensorSlicingOp<StartIndices, Sizes, ArgType> XprType;
00309   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::array\_size<Sizes>::value;
00310 
00311   \textcolor{keyword}{enum} \{
00312     \textcolor{comment}{// Alignment can't be guaranteed at compile time since it depends on the}
00313     \textcolor{comment}{// slice offsets and sizes.}
00314     IsAligned = \textcolor{comment}{/*TensorEvaluator<ArgType, Device>::IsAligned*/}\textcolor{keyword}{false},
00315     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00316     Layout = TensorEvaluator<ArgType, Device>::Layout,
00317     CoordAccess = \textcolor{keyword}{false},
00318     RawAccess = \textcolor{keyword}{false}
00319   \};
00320 
00321   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00322       : m\_impl(op.expression(), device), m\_device(device), m\_dimensions(op.sizes()), m\_offsets(op.
      startIndices())
00323   \{
00324     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < internal::array\_size<Dimensions>::value; ++i) \{
00325       eigen\_assert(m\_impl.dimensions()[i] >= op.sizes()[i] + op.startIndices()[i]);
00326     \}
00327 
00328     \textcolor{keyword}{const} \textcolor{keyword}{typename} TensorEvaluator<ArgType, Device>::Dimensions& input\_dims = m\_impl.dimensions();
00329     \textcolor{keyword}{const} Sizes& output\_dims = op.sizes();
00330     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00331       m\_inputStrides[0] = 1;
00332       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00333         m\_inputStrides[i] = m\_inputStrides[i-1] * input\_dims[i-1];
00334       \}
00335 
00336      \textcolor{comment}{// Don't initialize m\_fastOutputStrides[0] since it won't ever be accessed.}
00337       m\_outputStrides[0] = 1;
00338       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00339         m\_outputStrides[i] = m\_outputStrides[i-1] * output\_dims[i-1];
00340         m\_fastOutputStrides[i] = internal::TensorIntDivisor<Index>(m\_outputStrides[i]);
00341       \}
00342     \} \textcolor{keywordflow}{else} \{
00343       m\_inputStrides[NumDims-1] = 1;
00344       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00345         m\_inputStrides[i] = m\_inputStrides[i+1] * input\_dims[i+1];
00346       \}
00347 
00348      \textcolor{comment}{// Don't initialize m\_fastOutputStrides[NumDims-1] since it won't ever be accessed.}
00349       m\_outputStrides[NumDims-1] = 1;
00350       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00351         m\_outputStrides[i] = m\_outputStrides[i+1] * output\_dims[i+1];
00352         m\_fastOutputStrides[i] = internal::TensorIntDivisor<Index>(m\_outputStrides[i]);
00353       \}
00354     \}
00355   \}
00356 
00357   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00358   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00359   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00360   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00361   \textcolor{keyword}{typedef} Sizes Dimensions;
00362 
00363   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00364 
00365 
00366   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(CoeffReturnType* data) \{
00367     m\_impl.evalSubExprsIfNeeded(NULL);
00368     \textcolor{keywordflow}{if} (!NumTraits<\textcolor{keyword}{typename} internal::remove\_const<Scalar>::type>::RequireInitialization && data && m\_impl.
      data()) \{
00369       Index contiguous\_values = 1;
00370       \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00371         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i) \{
00372           contiguous\_values *= dimensions()[i];
00373           \textcolor{keywordflow}{if} (dimensions()[i] != m\_impl.dimensions()[i]) \{
00374             \textcolor{keywordflow}{break};
00375           \}
00376         \}
00377       \} \textcolor{keywordflow}{else} \{
00378         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims-1; i >= 0; --i) \{
00379           contiguous\_values *= dimensions()[i];
00380           \textcolor{keywordflow}{if} (dimensions()[i] != m\_impl.dimensions()[i]) \{
00381             \textcolor{keywordflow}{break};
00382           \}
00383         \}
00384       \}
00385       \textcolor{comment}{// Use memcpy if it's going to be faster than using the regular evaluation.}
00386       \textcolor{keyword}{const} MemcpyTriggerForSlicing<Index, Device> trigger(m\_device);
00387       \textcolor{keywordflow}{if} (trigger(contiguous\_values)) \{
00388         Scalar* src = (Scalar*)m\_impl.data();
00389         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < internal::array\_prod(dimensions()); i += contiguous\_values) \{
00390           Index offset = srcCoeff(i);
00391           m\_device.memcpy((\textcolor{keywordtype}{void}*)(data+i), src+offset, contiguous\_values * \textcolor{keyword}{sizeof}(Scalar));
00392         \}
00393         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00394       \}
00395     \}
00396     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00397   \}
00398 
00399   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00400     m\_impl.cleanup();
00401   \}
00402 
00403   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00404 \textcolor{keyword}{  }\{
00405     \textcolor{keywordflow}{return} m\_impl.coeff(srcCoeff(index));
00406   \}
00407 
00408   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00409   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00410 \textcolor{keyword}{  }\{
00411     \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetSize = internal::unpacket\_traits<PacketReturnType>::size;
00412     EIGEN\_STATIC\_ASSERT((packetSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00413     eigen\_assert(index+packetSize-1 < internal::array\_prod(dimensions()));
00414 
00415     Index inputIndices[] = \{0, 0\};
00416     Index indices[] = \{index, index + packetSize - 1\};
00417     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00418       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00419         \textcolor{keyword}{const} Index idx0 = indices[0] / m\_fastOutputStrides[i];
00420         \textcolor{keyword}{const} Index idx1 = indices[1] / m\_fastOutputStrides[i];
00421         inputIndices[0] += (idx0 + m\_offsets[i]) * m\_inputStrides[i];
00422         inputIndices[1] += (idx1 + m\_offsets[i]) * m\_inputStrides[i];
00423         indices[0] -= idx0 * m\_outputStrides[i];
00424         indices[1] -= idx1 * m\_outputStrides[i];
00425       \}
00426       inputIndices[0] += (indices[0] + m\_offsets[0]);
00427       inputIndices[1] += (indices[1] + m\_offsets[0]);
00428     \} \textcolor{keywordflow}{else} \{
00429       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00430         \textcolor{keyword}{const} Index idx0 = indices[0] / m\_fastOutputStrides[i];
00431         \textcolor{keyword}{const} Index idx1 = indices[1] / m\_fastOutputStrides[i];
00432         inputIndices[0] += (idx0 + m\_offsets[i]) * m\_inputStrides[i];
00433         inputIndices[1] += (idx1 + m\_offsets[i]) * m\_inputStrides[i];
00434         indices[0] -= idx0 * m\_outputStrides[i];
00435         indices[1] -= idx1 * m\_outputStrides[i];
00436       \}
00437       inputIndices[0] += (indices[0] + m\_offsets[NumDims-1]);
00438       inputIndices[1] += (indices[1] + m\_offsets[NumDims-1]);
00439     \}
00440     \textcolor{keywordflow}{if} (inputIndices[1] - inputIndices[0] == packetSize - 1) \{
00441       PacketReturnType rslt = m\_impl.template packet<Unaligned>(inputIndices[0]);
00442       \textcolor{keywordflow}{return} rslt;
00443     \}
00444     \textcolor{keywordflow}{else} \{
00445       EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} internal::remove\_const<CoeffReturnType>::type values[packetSize];
00446       values[0] = m\_impl.coeff(inputIndices[0]);
00447       values[packetSize-1] = m\_impl.coeff(inputIndices[1]);
00448       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < packetSize-1; ++i) \{
00449         values[i] = coeff(index+i);
00450       \}
00451       PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00452       \textcolor{keywordflow}{return} rslt;
00453     \}
00454   \}
00455 
00456   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorOpCost costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00457     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) + TensorOpCost(0, 0, NumDims);
00458   \}
00459 
00460 
00461   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar* data()\textcolor{keyword}{ const }\{
00462     Scalar* result = m\_impl.data();
00463     \textcolor{keywordflow}{if} (result) \{
00464       Index offset = 0;
00465       \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00466         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i) \{
00467           \textcolor{keywordflow}{if} (m\_dimensions[i] != m\_impl.dimensions()[i]) \{
00468             offset += m\_offsets[i] * m\_inputStrides[i];
00469             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = i+1; j < NumDims; ++j) \{
00470               \textcolor{keywordflow}{if} (m\_dimensions[j] > 1) \{
00471                 \textcolor{keywordflow}{return} NULL;
00472               \}
00473               offset += m\_offsets[j] * m\_inputStrides[j];
00474             \}
00475             \textcolor{keywordflow}{break};
00476           \}
00477         \}
00478       \} \textcolor{keywordflow}{else} \{
00479         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i >= 0; --i) \{
00480           \textcolor{keywordflow}{if} (m\_dimensions[i] != m\_impl.dimensions()[i]) \{
00481             offset += m\_offsets[i] * m\_inputStrides[i];
00482             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = i-1; j >= 0; --j) \{
00483               \textcolor{keywordflow}{if} (m\_dimensions[j] > 1) \{
00484                 \textcolor{keywordflow}{return} NULL;
00485               \}
00486               offset += m\_offsets[j] * m\_inputStrides[j];
00487             \}
00488             \textcolor{keywordflow}{break};
00489           \}
00490         \}
00491       \}
00492       \textcolor{keywordflow}{return} result + offset;
00493     \}
00494     \textcolor{keywordflow}{return} NULL;
00495   \}
00496 
00497  \textcolor{keyword}{protected}:
00498   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index srcCoeff(Index index)\textcolor{keyword}{ const}
00499 \textcolor{keyword}{  }\{
00500     Index inputIndex = 0;
00501     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00502       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00503         \textcolor{keyword}{const} Index idx = index / m\_fastOutputStrides[i];
00504         inputIndex += (idx + m\_offsets[i]) * m\_inputStrides[i];
00505         index -= idx * m\_outputStrides[i];
00506       \}
00507       inputIndex += (index + m\_offsets[0]);
00508     \} \textcolor{keywordflow}{else} \{
00509       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00510         \textcolor{keyword}{const} Index idx = index / m\_fastOutputStrides[i];
00511         inputIndex += (idx + m\_offsets[i]) * m\_inputStrides[i];
00512         index -= idx * m\_outputStrides[i];
00513       \}
00514       inputIndex += (index + m\_offsets[NumDims-1]);
00515     \}
00516     \textcolor{keywordflow}{return} inputIndex;
00517   \}
00518 
00519   array<Index, NumDims> m\_outputStrides;
00520   array<internal::TensorIntDivisor<Index>, NumDims> m\_fastOutputStrides;
00521   array<Index, NumDims> m\_inputStrides;
00522   TensorEvaluator<ArgType, Device> m\_impl;
00523   \textcolor{keyword}{const} Device& m\_device;
00524   Dimensions m\_dimensions;
00525   \textcolor{keyword}{const} StartIndices m\_offsets;
00526 \};
00527 
00528 
00529 \textcolor{comment}{// Eval as lvalue}
00530 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StartIndices, \textcolor{keyword}{typename} Sizes, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00531 \textcolor{keyword}{struct }TensorEvaluator<TensorSlicingOp<StartIndices, Sizes, ArgType>, Device>
00532   : \textcolor{keyword}{public} TensorEvaluator<const TensorSlicingOp<StartIndices, Sizes, ArgType>, Device>
00533 \{
00534   \textcolor{keyword}{typedef} TensorEvaluator<const TensorSlicingOp<StartIndices, Sizes, ArgType>, Device> Base;
00535   \textcolor{keyword}{typedef} TensorSlicingOp<StartIndices, Sizes, ArgType> XprType;
00536   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::array\_size<Sizes>::value;
00537 
00538   \textcolor{keyword}{enum} \{
00539     IsAligned = \textcolor{comment}{/*TensorEvaluator<ArgType, Device>::IsAligned*/}\textcolor{keyword}{false},
00540     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00541     Layout = TensorEvaluator<ArgType, Device>::Layout,
00542     CoordAccess = \textcolor{keyword}{false},
00543     RawAccess = \textcolor{keyword}{false}
00544   \};
00545 
00546   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00547     : Base(op, device)
00548     \{ \}
00549 
00550   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00551   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00552   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00553   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00554   \textcolor{keyword}{typedef} Sizes Dimensions;
00555 
00556   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType& coeffRef(Index index)
00557   \{
00558     \textcolor{keywordflow}{return} this->m\_impl.coeffRef(this->srcCoeff(index));
00559   \}
00560 
00561   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} StoreMode> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00562   \textcolor{keywordtype}{void} writePacket(Index index, \textcolor{keyword}{const} PacketReturnType& x)
00563   \{
00564     \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetSize = internal::unpacket\_traits<PacketReturnType>::size;
00565     Index inputIndices[] = \{0, 0\};
00566     Index indices[] = \{index, index + packetSize - 1\};
00567     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00568       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00569         \textcolor{keyword}{const} Index idx0 = indices[0] / this->m\_fastOutputStrides[i];
00570         \textcolor{keyword}{const} Index idx1 = indices[1] / this->m\_fastOutputStrides[i];
00571         inputIndices[0] += (idx0 + this->m\_offsets[i]) * this->m\_inputStrides[i];
00572         inputIndices[1] += (idx1 + this->m\_offsets[i]) * this->m\_inputStrides[i];
00573         indices[0] -= idx0 * this->m\_outputStrides[i];
00574         indices[1] -= idx1 * this->m\_outputStrides[i];
00575       \}
00576       inputIndices[0] += (indices[0] + this->m\_offsets[0]);
00577       inputIndices[1] += (indices[1] + this->m\_offsets[0]);
00578     \} \textcolor{keywordflow}{else} \{
00579       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00580         \textcolor{keyword}{const} Index idx0 = indices[0] / this->m\_fastOutputStrides[i];
00581         \textcolor{keyword}{const} Index idx1 = indices[1] / this->m\_fastOutputStrides[i];
00582         inputIndices[0] += (idx0 + this->m\_offsets[i]) * this->m\_inputStrides[i];
00583         inputIndices[1] += (idx1 + this->m\_offsets[i]) * this->m\_inputStrides[i];
00584         indices[0] -= idx0 * this->m\_outputStrides[i];
00585         indices[1] -= idx1 * this->m\_outputStrides[i];
00586       \}
00587       inputIndices[0] += (indices[0] + this->m\_offsets[NumDims-1]);
00588       inputIndices[1] += (indices[1] + this->m\_offsets[NumDims-1]);
00589     \}
00590     \textcolor{keywordflow}{if} (inputIndices[1] - inputIndices[0] == packetSize - 1) \{
00591       this->m\_impl.template writePacket<StoreMode>(inputIndices[0], x);
00592     \}
00593     \textcolor{keywordflow}{else} \{
00594       EIGEN\_ALIGN\_MAX CoeffReturnType values[packetSize];
00595       internal::pstore<CoeffReturnType, PacketReturnType>(values, x);
00596       this->m\_impl.coeffRef(inputIndices[0]) = values[0];
00597       this->m\_impl.coeffRef(inputIndices[1]) = values[packetSize-1];
00598       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < packetSize-1; ++i) \{
00599         this->coeffRef(index+i) = values[i];
00600       \}
00601     \}
00602   \}
00603 \};
00604 
00605 
00606 
00607 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00608 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StartIndices, \textcolor{keyword}{typename} StopIndices, \textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} XprType>
00609 \textcolor{keyword}{struct }traits<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> > : \textcolor{keyword}{public} traits<XprTyp
      e>
00610 \{
00611   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00612   \textcolor{keyword}{typedef} traits<XprType> XprTraits;
00613   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00614   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00615   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00616   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<Nested>::type \_Nested;
00617   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = array\_size<StartIndices>::value;
00618   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00619 \};
00620 
00621 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StartIndices, \textcolor{keyword}{typename} StopIndices, \textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} XprType>
00622 \textcolor{keyword}{struct }eval<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>, 
      \hyperlink{namespace_eigen}{Eigen}::Dense>
00623 \{
00624   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>& type;
00625 \};
00626 
00627 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StartIndices, \textcolor{keyword}{typename} StopIndices, \textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} XprType>
00628 \textcolor{keyword}{struct }nested<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>, 1, typename eval<
      TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> >::type>
00629 \{
00630   \textcolor{keyword}{typedef} TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> type;
00631 \};
00632 
00633 \}  \textcolor{comment}{// end namespace internal}
00634 
00635 
00636 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StartIndices, \textcolor{keyword}{typename} StopIndices, \textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} XprType>
00637 \textcolor{keyword}{class }TensorStridingSlicingOp : \textcolor{keyword}{public} TensorBase<TensorStridingSlicingOp<StartIndices, StopIndices, Stride
      s, XprType> >
00638 \{
00639   \textcolor{keyword}{public}:
00640   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<TensorStridingSlicingOp>::Scalar Scalar;
00641   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00642   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::nested<TensorStridingSlicingOp>::type Nested;
00643   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<TensorStridingSlicingOp>::StorageKind StorageKind;
00644   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<TensorStridingSlicingOp>::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00645 
00646   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorStridingSlicingOp(
00647     \textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} StartIndices& startIndices,
00648     \textcolor{keyword}{const} StopIndices& stopIndices, \textcolor{keyword}{const} Strides& strides)
00649       : m\_xpr(expr), m\_startIndices(startIndices), m\_stopIndices(stopIndices),
00650         m\_strides(strides) \{\}
00651 
00652     EIGEN\_DEVICE\_FUNC
00653     \textcolor{keyword}{const} StartIndices& startIndices()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_startIndices; \}
00654     EIGEN\_DEVICE\_FUNC
00655     \textcolor{keyword}{const} StartIndices& stopIndices()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_stopIndices; \}
00656     EIGEN\_DEVICE\_FUNC
00657     \textcolor{keyword}{const} StartIndices& strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_strides; \}
00658 
00659     EIGEN\_DEVICE\_FUNC
00660     \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type&
00661     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00662 
00663     EIGEN\_DEVICE\_FUNC
00664     EIGEN\_STRONG\_INLINE TensorStridingSlicingOp& operator = (\textcolor{keyword}{const} TensorStridingSlicingOp& other)
00665     \{
00666       \textcolor{keyword}{typedef} TensorAssignOp<TensorStridingSlicingOp, const TensorStridingSlicingOp> Assign;
00667       Assign assign(*\textcolor{keyword}{this}, other);
00668       internal::TensorExecutor<const Assign, DefaultDevice>::run(
00669           assign, DefaultDevice());
00670       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00671     \}
00672 
00673     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00674     EIGEN\_DEVICE\_FUNC
00675     EIGEN\_STRONG\_INLINE TensorStridingSlicingOp& operator = (\textcolor{keyword}{const} OtherDerived& other)
00676     \{
00677       \textcolor{keyword}{typedef} TensorAssignOp<TensorStridingSlicingOp, const OtherDerived> Assign;
00678       Assign assign(*\textcolor{keyword}{this}, other);
00679       internal::TensorExecutor<const Assign, DefaultDevice>::run(
00680           assign, DefaultDevice());
00681       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00682     \}
00683 
00684   \textcolor{keyword}{protected}:
00685     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00686     \textcolor{keyword}{const} StartIndices m\_startIndices;
00687     \textcolor{keyword}{const} StopIndices m\_stopIndices;
00688     \textcolor{keyword}{const} Strides m\_strides;
00689 \};
00690 
00691 \textcolor{comment}{// Eval as rvalue}
00692 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StartIndices, \textcolor{keyword}{typename} StopIndices, \textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00693 \textcolor{keyword}{struct }TensorEvaluator<const TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType>, Device>
00694 \{
00695   \textcolor{keyword}{typedef} TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType> XprType;
00696   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::array\_size<Strides>::value;
00697 
00698   \textcolor{keyword}{enum} \{
00699     \textcolor{comment}{// Alignment can't be guaranteed at compile time since it depends on the}
00700     \textcolor{comment}{// slice offsets and sizes.}
00701     IsAligned = \textcolor{keyword}{false},
00702     PacketAccess = \textcolor{keyword}{false},
00703     BlockAccess = \textcolor{keyword}{false},
00704     Layout = TensorEvaluator<ArgType, Device>::Layout,
00705     RawAccess = \textcolor{keyword}{false}
00706   \};
00707 
00708   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00709       : m\_impl(op.expression(), device), m\_device(device), m\_strides(op.strides())
00710   \{
00711     \textcolor{comment}{// Handle degenerate intervals by gracefully clamping and allowing m\_dimensions to be zero}
00712     DSizes<Index,NumDims> startIndicesClamped, stopIndicesClamped;
00713     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < internal::array\_size<Dimensions>::value; ++i) \{
00714       eigen\_assert(m\_strides[i] != 0 && \textcolor{stringliteral}{"0 stride is invalid"});
00715       \textcolor{keywordflow}{if}(m\_strides[i]>0)\{
00716         startIndicesClamped[i] = clamp(op.startIndices()[i], 0, m\_impl.dimensions()[i]);
00717         stopIndicesClamped[i] = clamp(op.stopIndices()[i], 0, m\_impl.dimensions()[i]);
00718       \}\textcolor{keywordflow}{else}\{
00719         \textcolor{comment}{/* implies m\_strides[i]<0 by assert */}
00720         startIndicesClamped[i] = clamp(op.startIndices()[i], -1, m\_impl.dimensions()[i] - 1);
00721         stopIndicesClamped[i] = clamp(op.stopIndices()[i], -1, m\_impl.dimensions()[i] - 1);
00722       \}
00723       m\_startIndices[i] = startIndicesClamped[i];
00724     \}
00725 
00726     \textcolor{keyword}{const} \textcolor{keyword}{typename} TensorEvaluator<ArgType, Device>::Dimensions& input\_dims = m\_impl.dimensions();
00727 
00728     \textcolor{comment}{// check for degenerate intervals and compute output tensor shape}
00729     \textcolor{keywordtype}{bool} degenerate = \textcolor{keyword}{false};;
00730     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < NumDims; i++)\{
00731       Index interval = stopIndicesClamped[i] - startIndicesClamped[i];
00732       \textcolor{keywordflow}{if}(interval == 0 || ((interval<0) != (m\_strides[i]<0)))\{
00733         m\_dimensions[i] = 0;
00734         degenerate = \textcolor{keyword}{true};
00735       \}\textcolor{keywordflow}{else}\{
00736         m\_dimensions[i] = interval / m\_strides[i]
00737                           + (interval % m\_strides[i] != 0 ? 1 : 0);
00738         eigen\_assert(m\_dimensions[i] >= 0);
00739       \}
00740     \}
00741     Strides output\_dims = m\_dimensions;
00742 
00743     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00744       m\_inputStrides[0] = m\_strides[0];
00745       m\_offsets[0] = startIndicesClamped[0];
00746       Index previousDimProduct = 1;
00747       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00748         previousDimProduct *= input\_dims[i-1];
00749         m\_inputStrides[i] = previousDimProduct * m\_strides[i];
00750         m\_offsets[i] = startIndicesClamped[i] * previousDimProduct;
00751       \}
00752 
00753       \textcolor{comment}{// Don't initialize m\_fastOutputStrides[0] since it won't ever be accessed.}
00754       m\_outputStrides[0] = 1;
00755       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00756         m\_outputStrides[i] = m\_outputStrides[i-1] * output\_dims[i-1];
00757         \textcolor{comment}{// NOTE: if tensor is degenerate, we send 1 to prevent TensorIntDivisor constructor crash}
00758         m\_fastOutputStrides[i] = internal::TensorIntDivisor<Index>(degenerate ? 1 : m\_outputStrides[i]);
00759       \}
00760     \} \textcolor{keywordflow}{else} \{
00761       m\_inputStrides[NumDims-1] = m\_strides[NumDims-1];
00762       m\_offsets[NumDims-1] = startIndicesClamped[NumDims-1];
00763       Index previousDimProduct = 1;
00764       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00765         previousDimProduct *= input\_dims[i+1];
00766         m\_inputStrides[i] = previousDimProduct * m\_strides[i];
00767         m\_offsets[i] = startIndicesClamped[i] * previousDimProduct;
00768       \}
00769 
00770       m\_outputStrides[NumDims-1] = 1;
00771       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00772         m\_outputStrides[i] = m\_outputStrides[i+1] * output\_dims[i+1];
00773         \textcolor{comment}{// NOTE: if tensor is degenerate, we send 1 to prevent TensorIntDivisor constructor crash}
00774         m\_fastOutputStrides[i] = internal::TensorIntDivisor<Index>(degenerate ? 1 : m\_outputStrides[i]);
00775       \}
00776     \}
00777     m\_block\_total\_size\_max = numext::maxi(static\_cast<std::size\_t>(1),
00778                                           device.lastLevelCacheSize() /
00779                                           \textcolor{keyword}{sizeof}(Scalar));
00780   \}
00781 
00782   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00783   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00784   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<Scalar>::type ScalarNonConst;
00785   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00786   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00787   \textcolor{keyword}{typedef} Strides Dimensions;
00788 
00789   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00790 
00791 
00792   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(CoeffReturnType*) \{
00793     m\_impl.evalSubExprsIfNeeded(NULL);
00794     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00795   \}
00796 
00797   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00798     m\_impl.cleanup();
00799   \}
00800 
00801   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00802 \textcolor{keyword}{  }\{
00803     \textcolor{keywordflow}{return} m\_impl.coeff(srcCoeff(index));
00804   \}
00805 
00806   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorOpCost costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00807     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) + TensorOpCost(0, 0, NumDims);
00808   \}
00809 
00810   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar* data()\textcolor{keyword}{ const }\{
00811     \textcolor{keywordflow}{return} NULL;
00812   \}
00813 
00814  \textcolor{keyword}{protected}:
00815   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index srcCoeff(Index index)\textcolor{keyword}{ const}
00816 \textcolor{keyword}{  }\{
00817     Index inputIndex = 0;
00818     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00819       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i >= 0; --i) \{
00820         \textcolor{keyword}{const} Index idx = index / m\_fastOutputStrides[i];
00821         inputIndex += idx * m\_inputStrides[i] + m\_offsets[i];
00822         index -= idx * m\_outputStrides[i];
00823       \}
00824     \} \textcolor{keywordflow}{else} \{
00825       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i) \{
00826         \textcolor{keyword}{const} Index idx = index / m\_fastOutputStrides[i];
00827         inputIndex += idx * m\_inputStrides[i] + m\_offsets[i];
00828         index -= idx * m\_outputStrides[i];
00829       \}
00830     \}
00831     \textcolor{keywordflow}{return} inputIndex;
00832   \}
00833 
00834   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE Index clamp(Index value, Index min, Index max) \{
00835     \textcolor{keywordflow}{return} numext::maxi(min, numext::mini(max,value));
00836   \}
00837 
00838   array<Index, NumDims> m\_outputStrides;
00839   array<internal::TensorIntDivisor<Index>, NumDims> m\_fastOutputStrides;
00840   array<Index, NumDims> m\_inputStrides;
00841   TensorEvaluator<ArgType, Device> m\_impl;
00842   \textcolor{keyword}{const} Device& m\_device;
00843   DSizes<Index, NumDims> m\_startIndices; \textcolor{comment}{// clamped startIndices}
00844   DSizes<Index, NumDims> m\_dimensions;
00845   DSizes<Index, NumDims> m\_offsets; \textcolor{comment}{// offset in a flattened shape}
00846   \textcolor{keyword}{const} Strides m\_strides;
00847   std::size\_t m\_block\_total\_size\_max;
00848 \};
00849 
00850 \textcolor{comment}{// Eval as lvalue}
00851 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StartIndices, \textcolor{keyword}{typename} StopIndices, \textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00852 \textcolor{keyword}{struct }TensorEvaluator<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType>, Device>
00853   : \textcolor{keyword}{public} TensorEvaluator<const TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType>, Devi
      ce>
00854 \{
00855   \textcolor{keyword}{typedef} TensorEvaluator<const TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType>, 
      Device> Base;
00856   \textcolor{keyword}{typedef} TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType> XprType;
00857   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::array\_size<Strides>::value;
00858 
00859   \textcolor{keyword}{enum} \{
00860     IsAligned = \textcolor{keyword}{false},
00861     PacketAccess = \textcolor{keyword}{false},
00862     BlockAccess = \textcolor{keyword}{false},
00863     Layout = TensorEvaluator<ArgType, Device>::Layout,
00864     CoordAccess = TensorEvaluator<ArgType, Device>::CoordAccess,
00865     RawAccess = \textcolor{keyword}{false}
00866   \};
00867 
00868   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00869     : Base(op, device)
00870     \{ \}
00871 
00872   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00873   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00874   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<Scalar>::type ScalarNonConst;
00875   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00876   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00877   \textcolor{keyword}{typedef} Strides Dimensions;
00878 
00879   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType& coeffRef(Index index)
00880   \{
00881     \textcolor{keywordflow}{return} this->m\_impl.coeffRef(this->srcCoeff(index));
00882   \}
00883 \};
00884 
00885 
00886 \} \textcolor{comment}{// end namespace Eigen}
00887 
00888 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_MORPHING\_H}
\end{DoxyCode}
