\hypertarget{eigen_2demos_2mandelbrot_2mandelbrot_8cpp_source}{}\section{eigen/demos/mandelbrot/mandelbrot.cpp}
\label{eigen_2demos_2mandelbrot_2mandelbrot_8cpp_source}\index{mandelbrot.\+cpp@{mandelbrot.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "mandelbrot.h"}
00011 \textcolor{preprocessor}{#include <iostream>}
00012 \textcolor{preprocessor}{#include<QtGui/QPainter>}
00013 \textcolor{preprocessor}{#include<QtGui/QImage>}
00014 \textcolor{preprocessor}{#include<QtGui/QMouseEvent>}
00015 \textcolor{preprocessor}{#include<QtCore/QTime>}
00016 
00017 \textcolor{keywordtype}{void} MandelbrotWidget::resizeEvent(QResizeEvent *)
00018 \{
00019   \textcolor{keywordflow}{if}(size < width() * height())
00020   \{
00021     std::cout << \textcolor{stringliteral}{"reallocate buffer"} << std::endl;
00022     size = width() * height();
00023     \textcolor{keywordflow}{if}(buffer) \textcolor{keyword}{delete}[]buffer;
00024     buffer = \textcolor{keyword}{new} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}[4*size];
00025   \}
00026 \}
00027 
\Hypertarget{eigen_2demos_2mandelbrot_2mandelbrot_8cpp_source_l00028}\hyperlink{structiters__before__test}{00028} \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\hyperlink{structiters__before__test}{iters\_before\_test} \{ \textcolor{keyword}{enum} \{ ret = 8 \}; \};
\Hypertarget{eigen_2demos_2mandelbrot_2mandelbrot_8cpp_source_l00029}\hyperlink{structiters__before__test_3_01double_01_4}{00029} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{structiters__before__test}{iters\_before\_test}<double> \{ \textcolor{keyword}{enum} \{ ret = 16 \}; \};
00030 
00031 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Real> \textcolor{keywordtype}{void} MandelbrotThread::render(\textcolor{keywordtype}{int} img\_width, \textcolor{keywordtype}{int} img\_height)
00032 \{
00033   \textcolor{keyword}{enum} \{ packetSize = \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{Eigen::internal::packet\_traits<Real>::size} 
      \}; \textcolor{comment}{// number of reals in a Packet}
00034   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_array}{Eigen::Array<Real, packetSize, 1>} 
      \hyperlink{group___sparse_core___module}{Packet}; \textcolor{comment}{// wrap a Packet as a vector}
00035 
00036   \textcolor{keyword}{enum} \{ \hyperlink{structiters__before__test}{iters\_before\_test} = \hyperlink{structiters__before__test}{iters\_before\_test<Real>::ret} \};
00037   max\_iter = (max\_iter / \hyperlink{structiters__before__test}{iters\_before\_test}) * \hyperlink{structiters__before__test}{iters\_before\_test};
00038   \textcolor{keyword}{const} \textcolor{keywordtype}{int} alignedWidth = (img\_width/packetSize)*packetSize;
00039   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} buffer = widget->buffer;
00040   \textcolor{keyword}{const} \textcolor{keywordtype}{double} xradius = widget->xradius;
00041   \textcolor{keyword}{const} \textcolor{keywordtype}{double} yradius = xradius * img\_height / img\_width;
00042   \textcolor{keyword}{const} \textcolor{keywordtype}{int} threadcount = widget->threadcount;
00043   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_array}{Eigen::Array<Real, 2, 1>} Vector2;
00044   Vector2 start(widget->center.x() - widget->xradius, widget->center.y() - yradius);
00045   Vector2 step(2*widget->xradius/img\_width, 2*yradius/img\_height);
00046   total\_iter = 0;
00047 
00048   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} y = \textcolor{keywordtype}{id}; y < img\_height; y += threadcount)
00049   \{
00050     \textcolor{keywordtype}{int} pix = y * img\_width;
00051 
00052     \textcolor{comment}{// for each pixel, we're going to do the iteration z := z^2 + c where z and c are complex numbers, }
00053     \textcolor{comment}{// starting with z = c = complex coord of the pixel. pzi and pzr denote the real and imaginary parts of
       z.}
00054     \textcolor{comment}{// pci and pcr denote the real and imaginary parts of c.}
00055 
00056     Packet pzi\_start, pci\_start;
00057     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < packetSize; i++) pzi\_start[i] = pci\_start[i] = start.y() + y * step.y();
00058 
00059     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} x = 0; x < alignedWidth; x += packetSize, pix += packetSize)
00060     \{
00061       Packet pcr, pci = pci\_start, pzr, pzi = pzi\_start, pzr\_buf;
00062       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < packetSize; i++) pzr[i] = pcr[i] = start.x() + (x+i) * step.x();
00063 
00064       \textcolor{comment}{// do the iterations. Every iters\_before\_test iterations we check for divergence,}
00065       \textcolor{comment}{// in which case we can stop iterating.}
00066       \textcolor{keywordtype}{int} j = 0;
00067       \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Eigen::Matrix<int, packetSize, 1>} Packeti;
00068       Packeti pix\_iter = Packeti::Zero(), \textcolor{comment}{// number of iteration per pixel in the packet}
00069               pix\_dont\_diverge; \textcolor{comment}{// whether or not each pixel has already diverged}
00070       \textcolor{keywordflow}{do}
00071       \{
00072         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < \hyperlink{structiters__before__test}{iters\_before\_test}/4; i++) \textcolor{comment}{// peel the inner loop by 4}
00073         \{
00074 \textcolor{preprocessor}{#         define ITERATE \(\backslash\)}
00075 \textcolor{preprocessor}{            pzr\_buf = pzr; \(\backslash\)}
00076 \textcolor{preprocessor}{            pzr = pzr.square(); \(\backslash\)}
00077 \textcolor{preprocessor}{            pzr -= pzi.square(); \(\backslash\)}
00078 \textcolor{preprocessor}{            pzr += pcr; \(\backslash\)}
00079 \textcolor{preprocessor}{            pzi = (2*pzr\_buf)*pzi; \(\backslash\)}
00080 \textcolor{preprocessor}{            pzi += pci;}
00081           ITERATE ITERATE ITERATE ITERATE
00082         \}
00083         pix\_dont\_diverge = ((pzr.square() + pzi.square())
00084                            .eval() \textcolor{comment}{// temporary fix as what follows is not yet vectorized by Eigen}
00085                            <= Packet::Constant(4))
00086                                 \textcolor{comment}{// the 4 here is not a magic value, it's a math fact that if}
00087                                 \textcolor{comment}{// the square modulus is >4 then divergence is inevitable.}
00088                            .\textcolor{keyword}{template} cast<int>();
00089         pix\_iter += \hyperlink{structiters__before__test}{iters\_before\_test} * pix\_dont\_diverge;
00090         j++;
00091         total\_iter += \hyperlink{structiters__before__test}{iters\_before\_test} * packetSize;
00092       \}
00093       \textcolor{keywordflow}{while}(j < max\_iter/\hyperlink{structiters__before__test}{iters\_before\_test} && pix\_dont\_diverge.any()); \textcolor{comment}{// any() is not yet
       vectorized by Eigen}
00094 
00095       \textcolor{comment}{// compute pixel colors}
00096       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < packetSize; i++)
00097       \{
00098         buffer[4*(pix+i)] = 255*pix\_iter[i]/max\_iter;
00099         buffer[4*(pix+i)+1] = 0;
00100         buffer[4*(pix+i)+2] = 0;
00101       \}
00102     \}
00103 
00104     \textcolor{comment}{// if the width is not a multiple of packetSize, fill the remainder in black}
00105     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} x = alignedWidth; x < img\_width; x++, pix++)
00106       buffer[4*pix] = buffer[4*pix+1] = buffer[4*pix+2] = 0;
00107   \}
00108   \textcolor{keywordflow}{return};
00109 \}
00110 
00111 \textcolor{keywordtype}{void} MandelbrotThread::run()
00112 \{
00113   setTerminationEnabled(\textcolor{keyword}{true});
00114   \textcolor{keywordtype}{double} resolution = widget->xradius*2/widget->width();
00115   max\_iter = 128;
00116   \textcolor{keywordflow}{if}(resolution < 1e-4f) max\_iter += 128 * ( - 4 - std::log10(resolution));
00117   \textcolor{keywordtype}{int} img\_width = widget->width()/widget->draft;
00118   \textcolor{keywordtype}{int} img\_height = widget->height()/widget->draft;
00119   single\_precision = resolution > 1e-7f;
00120 
00121   \textcolor{keywordflow}{if}(single\_precision)
00122     render<float>(img\_width, img\_height);
00123   \textcolor{keywordflow}{else}
00124     render<double>(img\_width, img\_height);
00125 \}
00126 
00127 \textcolor{keywordtype}{void} MandelbrotWidget::paintEvent(QPaintEvent *)
00128 \{
00129   \textcolor{keyword}{static} \textcolor{keywordtype}{float} max\_speed = 0;
00130   \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} total\_iter = 0;
00131 
00132   QTime time;
00133   time.start();
00134   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} th = 0; th < threadcount; th++)
00135     threads[th]->start(QThread::LowPriority);
00136   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} th = 0; th < threadcount; th++)
00137   \{
00138     threads[th]->wait();
00139     total\_iter += threads[th]->total\_iter;
00140   \}
00141   \textcolor{keywordtype}{int} elapsed = time.elapsed();
00142 
00143   \textcolor{keywordflow}{if}(draft == 1)
00144   \{
00145     \textcolor{keywordtype}{float} speed = elapsed ? float(total\_iter)*1000/elapsed : 0;
00146     max\_speed = std::max(max\_speed, speed);
00147     std::cout << threadcount << \textcolor{stringliteral}{" threads, "}
00148               << elapsed << \textcolor{stringliteral}{" ms, "}
00149               << speed << \textcolor{stringliteral}{" iters/s (max "} << max\_speed << \textcolor{stringliteral}{")"} << std::endl;
00150     \textcolor{keywordtype}{int} packetSize = threads[0]->single\_precision
00151                    ? int(\hyperlink{struct_eigen_1_1internal_1_1packet__traits}{Eigen::internal::packet\_traits<float>::size}
      )
00152                    : int(\hyperlink{struct_eigen_1_1internal_1_1packet__traits}{Eigen::internal::packet\_traits<double>::size}
      );
00153     setWindowTitle(QString(\textcolor{stringliteral}{"resolution "})+QString::number(xradius*2/width(), \textcolor{charliteral}{'e'}, 2)
00154                   +QString(\textcolor{stringliteral}{", %1 iterations per pixel, "}).arg(threads[0]->max\_iter)
00155                   +(threads[0]->single\_precision ? QString(\textcolor{stringliteral}{"single "}) : QString(\textcolor{stringliteral}{"double "}))
00156                   +QString(\textcolor{stringliteral}{"precision, "})
00157                   +(packetSize==1 ? QString(\textcolor{stringliteral}{"no vectorization"})
00158                                   : QString(\textcolor{stringliteral}{"vectorized (%1 per packet)"}).arg(packetSize)));
00159   \}
00160   
00161   QImage image(buffer, width()/draft, height()/draft, QImage::Format\_RGB32);
00162   QPainter painter(\textcolor{keyword}{this});
00163   painter.drawImage(QPoint(0, 0), image.scaled(width(), height()));
00164 
00165   \textcolor{keywordflow}{if}(draft>1)
00166   \{
00167     draft /= 2;
00168     setWindowTitle(QString(\textcolor{stringliteral}{"recomputing at 1/%1 resolution..."}).arg(draft));
00169     update();
00170   \}
00171 \}
00172 
00173 \textcolor{keywordtype}{void} MandelbrotWidget::mousePressEvent(QMouseEvent *event)
00174 \{
00175   \textcolor{keywordflow}{if}( event->buttons() & Qt::LeftButton )
00176   \{
00177     lastpos = \textcolor{keyword}{event}->pos();
00178     \textcolor{keywordtype}{double} yradius = xradius * height() / width();
00179     center = Eigen::Vector2d(center.x() + (\textcolor{keyword}{event}->pos().x() - width()/2) * xradius * 2 / width(),
00180                              center.y() + (\textcolor{keyword}{event}->pos().y() - height()/2) * yradius * 2 / height());
00181     draft = 16;
00182     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} th = 0; th < threadcount; th++)
00183       threads[th]->terminate();
00184     update();
00185   \}
00186 \}
00187 
00188 \textcolor{keywordtype}{void} MandelbrotWidget::mouseMoveEvent(QMouseEvent *event)
00189 \{
00190   QPoint delta = \textcolor{keyword}{event}->pos() - lastpos;
00191   lastpos = \textcolor{keyword}{event}->pos();
00192   \textcolor{keywordflow}{if}( event->buttons() & Qt::LeftButton )
00193   \{
00194     \textcolor{keywordtype}{double} t = 1 + 5 * double(delta.y()) / height();
00195     \textcolor{keywordflow}{if}(t < 0.5) t = 0.5;
00196     \textcolor{keywordflow}{if}(t > 2) t = 2;
00197     xradius *= t;
00198     draft = 16;
00199     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} th = 0; th < threadcount; th++)
00200       threads[th]->terminate();
00201     update();
00202   \}
00203 \}
00204 
00205 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[])
00206 \{
00207   QApplication app(argc, argv);
00208   \hyperlink{class_mandelbrot_widget}{MandelbrotWidget} w;
00209   w.show();
00210   \textcolor{keywordflow}{return} app.exec();
00211 \}
00212 
00213 \textcolor{preprocessor}{#include "mandelbrot.moc"}
\end{DoxyCode}
