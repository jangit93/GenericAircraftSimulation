\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_map_base_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/\+Map\+Base.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_map_base_8h_source}\index{Map\+Base.\+h@{Map\+Base.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2007-2010 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_MAPBASE\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_MAPBASE\_H}
00013 
00014 \textcolor{preprocessor}{#define EIGEN\_STATIC\_ASSERT\_INDEX\_BASED\_ACCESS(Derived) \(\backslash\)}
00015 \textcolor{preprocessor}{      EIGEN\_STATIC\_ASSERT((int(internal::evaluator<Derived>::Flags) & LinearAccessBit) ||
       Derived::IsVectorAtCompileTime, \(\backslash\)}
00016 \textcolor{preprocessor}{                         
       YOU\_ARE\_TRYING\_TO\_USE\_AN\_INDEX\_BASED\_ACCESSOR\_ON\_AN\_EXPRESSION\_THAT\_DOES\_NOT\_SUPPORT\_THAT)}
00017 
00018 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00019 
00037 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }MapBase<Derived, \hyperlink{group__enums_gga9f93eac38eb83deb0e8dbd42ddf11d5da42865f87356ad7e585a1bfbfd1b81699}{ReadOnlyAccessors}>
00038   : \textcolor{keyword}{public} internal::dense\_xpr\_base<Derived>::type
00039 \{
00040   \textcolor{keyword}{public}:
00041 
00042     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::dense\_xpr\_base<Derived>::type Base;
00043     \textcolor{keyword}{enum} \{
00044       RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,
00045       ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,
00046       SizeAtCompileTime = Base::SizeAtCompileTime
00047     \};
00048 
00049     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<Derived>::StorageKind StorageKind;
00050     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<Derived>::Scalar Scalar;
00051     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::packet\_traits<Scalar>::type PacketScalar;
00052     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar;
00053     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::conditional<
00054                          bool(internal::is\_lvalue<Derived>::value),
00055                          Scalar *,
00056                          \textcolor{keyword}{const} Scalar *>::type
00057                      PointerType;
00058 
00059     \textcolor{keyword}{using} Base::derived;
00060 \textcolor{comment}{//    using Base::RowsAtCompileTime;}
00061 \textcolor{comment}{//    using Base::ColsAtCompileTime;}
00062 \textcolor{comment}{//    using Base::SizeAtCompileTime;}
00063     \textcolor{keyword}{using} Base::MaxRowsAtCompileTime;
00064     \textcolor{keyword}{using} Base::MaxColsAtCompileTime;
00065     \textcolor{keyword}{using} Base::MaxSizeAtCompileTime;
00066     \textcolor{keyword}{using} Base::IsVectorAtCompileTime;
00067     \textcolor{keyword}{using} Base::Flags;
00068     \textcolor{keyword}{using} Base::IsRowMajor;
00069 
00070     \textcolor{keyword}{using} Base::rows;
00071     \textcolor{keyword}{using} Base::cols;
00072     \textcolor{keyword}{using} Base::size;
00073     \textcolor{keyword}{using} Base::coeff;
00074     \textcolor{keyword}{using} Base::coeffRef;
00075     \textcolor{keyword}{using} Base::lazyAssign;
00076     \textcolor{keyword}{using} Base::eval;
00077 
00078     \textcolor{keyword}{using} Base::innerStride;
00079     \textcolor{keyword}{using} Base::outerStride;
00080     \textcolor{keyword}{using} Base::rowStride;
00081     \textcolor{keyword}{using} Base::colStride;
00082 
00083     \textcolor{comment}{// bug 217 - compile error on ICC 11.1}
00084     \textcolor{keyword}{using} Base::operator=;
00085 
00086     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::CoeffReturnType CoeffReturnType;
00087 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_map_base_8h_source_l00089}\hyperlink{group___core___module_a78b3ab4983de51f112e6a062ac8f6ffd}{00089}     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{group___core___module_a78b3ab4983de51f112e6a062ac8f6ffd}{rows}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rows.value(); \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_map_base_8h_source_l00091}\hyperlink{group___core___module_ad345a6b995b9894e9b076ee174876659}{00091}     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{group___core___module_ad345a6b995b9894e9b076ee174876659}{cols}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_cols.value(); \}
00092 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_map_base_8h_source_l00099}\hyperlink{group___core___module_ad8c55bd47422cebca456f802c29c451e}{00099}     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar* \hyperlink{group___core___module_ad8c55bd47422cebca456f802c29c451e}{data}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data; \}
00100 
00102     EIGEN\_DEVICE\_FUNC
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_map_base_8h_source_l00103}\hyperlink{group___core___module_ac303d927b8d2e3ac1e2fd76053c8119f}{00103}     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar& \hyperlink{group___core___module_ac303d927b8d2e3ac1e2fd76053c8119f}{coeff}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rowId, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} colId)\textcolor{keyword}{ const}
00104 \textcolor{keyword}{    }\{
00105       \textcolor{keywordflow}{return} m\_data[colId * colStride() + rowId * rowStride()];
00106     \}
00107 
00109     EIGEN\_DEVICE\_FUNC
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_map_base_8h_source_l00110}\hyperlink{group___core___module_a3786c4aedbd29f75750bd434654b21f7}{00110}     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar& \hyperlink{group___core___module_a3786c4aedbd29f75750bd434654b21f7}{coeff}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00111 \textcolor{keyword}{    }\{
00112       EIGEN\_STATIC\_ASSERT\_INDEX\_BASED\_ACCESS(Derived)
00113       \textcolor{keywordflow}{return} m\_data[index * innerStride()];
00114     \}
00115 
00117     EIGEN\_DEVICE\_FUNC
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_map_base_8h_source_l00118}\hyperlink{group___core___module_ad4e9a2bf0255f870a45ce88e30815b59}{00118}     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar& \hyperlink{group___core___module_ad4e9a2bf0255f870a45ce88e30815b59}{coeffRef}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rowId, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} colId)\textcolor{keyword}{ const}
00119 \textcolor{keyword}{    }\{
00120       \textcolor{keywordflow}{return} this->m\_data[colId * colStride() + rowId * rowStride()];
00121     \}
00122 
00124     EIGEN\_DEVICE\_FUNC
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_map_base_8h_source_l00125}\hyperlink{group___core___module_abae7b3615ed05ef13cd06065fe71c98e}{00125}     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar& \hyperlink{group___core___module_abae7b3615ed05ef13cd06065fe71c98e}{coeffRef}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00126 \textcolor{keyword}{    }\{
00127       EIGEN\_STATIC\_ASSERT\_INDEX\_BASED\_ACCESS(Derived)
00128       \textcolor{keywordflow}{return} this->m\_data[index * innerStride()];
00129     \}
00130 
00132     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00133     \textcolor{keyword}{inline} PacketScalar packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rowId, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} colId)\textcolor{keyword}{ const}
00134 \textcolor{keyword}{    }\{
00135       \textcolor{keywordflow}{return} internal::ploadt<PacketScalar, LoadMode>
00136                (m\_data + (colId * colStride() + rowId * rowStride()));
00137     \}
00138 
00140     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00141     \textcolor{keyword}{inline} PacketScalar packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00142 \textcolor{keyword}{    }\{
00143       EIGEN\_STATIC\_ASSERT\_INDEX\_BASED\_ACCESS(Derived)
00144       \textcolor{keywordflow}{return} internal::ploadt<PacketScalar, LoadMode>(m\_data + index * innerStride());
00145     \}
00146 
00148     EIGEN\_DEVICE\_FUNC
00149     \textcolor{keyword}{explicit} \textcolor{keyword}{inline} \hyperlink{class_eigen_1_1_map_base}{MapBase}(PointerType dataPtr) : m\_data(dataPtr), m\_rows(RowsAtCompileTime), 
      m\_cols(ColsAtCompileTime)
00150     \{
00151       EIGEN\_STATIC\_ASSERT\_FIXED\_SIZE(Derived)
00152       checkSanity<Derived>();
00153     \}
00154 
00156     EIGEN\_DEVICE\_FUNC
00157     \textcolor{keyword}{inline} MapBase(PointerType dataPtr, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} vecSize)
00158             : m\_data(dataPtr),
00159               m\_rows(RowsAtCompileTime == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} ? vecSize : \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(RowsAtCompileTime)),
00160               m\_cols(ColsAtCompileTime == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} ? vecSize : \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(ColsAtCompileTime))
00161     \{
00162       EIGEN\_STATIC\_ASSERT\_VECTOR\_ONLY(Derived)
00163       eigen\_assert(vecSize >= 0);
00164       eigen\_assert(dataPtr == 0 || SizeAtCompileTime == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} || SizeAtCompileTime == vecSize);
00165       checkSanity<Derived>();
00166     \}
00167 
00169     EIGEN\_DEVICE\_FUNC
00170     \textcolor{keyword}{inline} MapBase(PointerType dataPtr, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols)
00171             : m\_data(dataPtr), m\_rows(rows), m\_cols(cols)
00172     \{
00173       eigen\_assert( (dataPtr == 0)
00174               || (   rows >= 0 && (RowsAtCompileTime == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} || RowsAtCompileTime == rows)
00175                   && cols >= 0 && (ColsAtCompileTime == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} || ColsAtCompileTime == cols)));
00176       checkSanity<Derived>();
00177     \}
00178 
00179 \textcolor{preprocessor}{    #ifdef EIGEN\_MAPBASE\_PLUGIN}
00180 \textcolor{preprocessor}{    #include EIGEN\_MAPBASE\_PLUGIN}
00181 \textcolor{preprocessor}{    #endif}
00182 
00183   \textcolor{keyword}{protected}:
00184 
00185     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00186     EIGEN\_DEVICE\_FUNC
00187     \textcolor{keywordtype}{void} checkSanity(\textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1enable__if}{internal::enable\_if}<(
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<T>::Alignment}>0),\textcolor{keywordtype}{void}*>::type = 0)\textcolor{keyword}{ const}
00188 \textcolor{keyword}{    }\{
00189 \textcolor{preprocessor}{#if EIGEN\_MAX\_ALIGN\_BYTES>0}
00190       eigen\_assert((   ((internal::UIntPtr(m\_data) % 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Alignment}) == 0)
00191                     || (cols() * rows() * innerStride() * \textcolor{keyword}{sizeof}(Scalar)) < 
      internal::traits<Derived>::Alignment ) && \textcolor{stringliteral}{"data is not aligned"});
00192 \textcolor{preprocessor}{#endif}
00193     \}
00194 
00195     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00196     EIGEN\_DEVICE\_FUNC
00197     \textcolor{keywordtype}{void} checkSanity(\textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1enable__if}{internal::enable\_if}<
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<T>::Alignment}==0,\textcolor{keywordtype}{void}*>::type = 0)\textcolor{keyword}{ const}
00198 \textcolor{keyword}{    }\{\}
00199 
00200     PointerType m\_data;
00201     \textcolor{keyword}{const} \hyperlink{class_eigen_1_1internal_1_1variable__if__dynamic}{internal::variable\_if\_dynamic<Index, RowsAtCompileTime>}
       m\_rows;
00202     \textcolor{keyword}{const} \hyperlink{class_eigen_1_1internal_1_1variable__if__dynamic}{internal::variable\_if\_dynamic<Index, ColsAtCompileTime>}
       m\_cols;
00203 \};
00204 
00215 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_map_base}{MapBase}<Derived, WriteAccessors>
00216   : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_map_base}{MapBase}<Derived, ReadOnlyAccessors>
00217 \{
00218     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_map_base_3_01_derived_00_01_read_only_accessors_01_4}{MapBase<Derived, ReadOnlyAccessors>} ReadOnlyMapBase;
00219   \textcolor{keyword}{public}:
00220 
00221     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_map_base_3_01_derived_00_01_read_only_accessors_01_4}{MapBase<Derived, ReadOnlyAccessors>} Base;
00222 
00223     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::Scalar Scalar;
00224     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::PacketScalar \hyperlink{group___sparse_core___module}{PacketScalar};
00225     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::StorageIndex StorageIndex;
00226     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::PointerType \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{PointerType};
00227 
00228     \textcolor{keyword}{using} Base::derived;
00229     \textcolor{keyword}{using} Base::rows;
00230     \textcolor{keyword}{using} Base::cols;
00231     \textcolor{keyword}{using} Base::size;
00232     \textcolor{keyword}{using} Base::coeff;
00233     \textcolor{keyword}{using} Base::coeffRef;
00234 
00235     \textcolor{keyword}{using} Base::innerStride;
00236     \textcolor{keyword}{using} Base::outerStride;
00237     \textcolor{keyword}{using} Base::rowStride;
00238     \textcolor{keyword}{using} Base::colStride;
00239 
00240     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{internal::conditional}<
00241                     \hyperlink{struct_eigen_1_1internal_1_1is__lvalue}{internal::is\_lvalue<Derived>::value},
00242                     Scalar,
00243                     \textcolor{keyword}{const} Scalar
00244                   >::type ScalarWithConstIfNotLvalue;
00245 
00246     EIGEN\_DEVICE\_FUNC
00247     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} this->m\_data; \}
00248     EIGEN\_DEVICE\_FUNC
00249     \textcolor{keyword}{inline} ScalarWithConstIfNotLvalue* data() \{ \textcolor{keywordflow}{return} this->m\_data; \} \textcolor{comment}{// no const-cast here so
       non-const-correct code will give a compile error}
00250 
00251     EIGEN\_DEVICE\_FUNC
00252     \textcolor{keyword}{inline} ScalarWithConstIfNotLvalue& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
00253     \{
00254       \textcolor{keywordflow}{return} this->m\_data[col * colStride() + row * rowStride()];
00255     \}
00256 
00257     EIGEN\_DEVICE\_FUNC
00258     \textcolor{keyword}{inline} ScalarWithConstIfNotLvalue& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)
00259     \{
00260       EIGEN\_STATIC\_ASSERT\_INDEX\_BASED\_ACCESS(Derived)
00261       \textcolor{keywordflow}{return} this->m\_data[index * innerStride()];
00262     \}
00263 
00264     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode>
00265     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col, \textcolor{keyword}{const} PacketScalar& val)
00266     \{
00267       internal::pstoret<Scalar, PacketScalar, StoreMode>
00268                (this->m\_data + (col * colStride() + row * rowStride()), val);
00269     \}
00270 
00271     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode>
00272     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} writePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index, \textcolor{keyword}{const} PacketScalar& val)
00273     \{
00274       EIGEN\_STATIC\_ASSERT\_INDEX\_BASED\_ACCESS(Derived)
00275       internal::pstoret<Scalar, PacketScalar, StoreMode>
00276                 (this->m\_data + index * innerStride(), val);
00277     \}
00278 
00279     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{explicit} \textcolor{keyword}{inline} \hyperlink{class_eigen_1_1_map_base}{MapBase}(PointerType dataPtr) : Base(dataPtr) \{\}
00280     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} MapBase(PointerType dataPtr, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} vecSize) : Base(dataPtr, vecSize) \{\}
00281     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} MapBase(PointerType dataPtr, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols) : Base(dataPtr,
       rows, cols) \{\}
00282 
00283     EIGEN\_DEVICE\_FUNC
00284     Derived& operator=(\textcolor{keyword}{const} MapBase& other)
00285     \{
00286       ReadOnlyMapBase::Base::operator=(other);
00287       \textcolor{keywordflow}{return} derived();
00288     \}
00289 
00290     \textcolor{comment}{// In theory we could simply refer to Base:Base::operator=, but MSVC does not like Base::Base,}
00291     \textcolor{comment}{// see bugs 821 and 920.}
00292     \textcolor{keyword}{using} ReadOnlyMapBase::Base::operator=;
00293 \};
00294 
00295 \textcolor{preprocessor}{#undef EIGEN\_STATIC\_ASSERT\_INDEX\_BASED\_ACCESS}
00296 
00297 \} \textcolor{comment}{// end namespace Eigen}
00298 
00299 \textcolor{preprocessor}{#endif // EIGEN\_MAPBASE\_H}
\end{DoxyCode}
