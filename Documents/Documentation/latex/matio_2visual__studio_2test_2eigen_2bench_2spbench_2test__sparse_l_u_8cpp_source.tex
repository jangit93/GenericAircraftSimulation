\hypertarget{matio_2visual__studio_2test_2eigen_2bench_2spbench_2test__sparse_l_u_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/bench/spbench/test\+\_\+sparse\+LU.cpp}
\label{matio_2visual__studio_2test_2eigen_2bench_2spbench_2test__sparse_l_u_8cpp_source}\index{test\+\_\+sparse\+L\+U.\+cpp@{test\+\_\+sparse\+L\+U.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// Small bench routine for Eigen available in Eigen}
00002 \textcolor{comment}{// (C) Desire NUENTSA WAKAM, INRIA}
00003 
00004 \textcolor{preprocessor}{#include <iostream>}
00005 \textcolor{preprocessor}{#include <fstream>}
00006 \textcolor{preprocessor}{#include <iomanip>}
00007 \textcolor{preprocessor}{#include <unsupported/Eigen/SparseExtra>}
00008 \textcolor{preprocessor}{#include <Eigen/SparseLU>}
00009 \textcolor{preprocessor}{#include <bench/BenchTimer.h>}
00010 \textcolor{preprocessor}{#ifdef EIGEN\_METIS\_SUPPORT}
00011 \textcolor{preprocessor}{#include <Eigen/MetisSupport>}
00012 \textcolor{preprocessor}{#endif}
00013 
00014 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00015 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00016 
00017 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **args)
00018 \{
00019 \textcolor{comment}{//   typedef complex<double> scalar; }
00020   \textcolor{keyword}{typedef} \textcolor{keywordtype}{double} scalar; 
00021   \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<scalar, ColMajor>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}; 
00022   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<scalar, ColMajor>::Index} 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00023   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<scalar, Dynamic, Dynamic>} 
      \hyperlink{group___core___module}{DenseMatrix};
00024   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<scalar, Dynamic, 1>} DenseRhs;
00025   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<scalar, Dynamic, 1>} b, x, tmp;
00026 \textcolor{comment}{//   SparseLU<SparseMatrix<scalar, ColMajor>, AMDOrdering<int> >   solver;}
00027 \textcolor{comment}{// #ifdef EIGEN\_METIS\_SUPPORT}
00028 \textcolor{comment}{//   SparseLU<SparseMatrix<scalar, ColMajor>, MetisOrdering<int> > solver; }
00029 \textcolor{comment}{//   std::cout<< "ORDERING : METIS\(\backslash\)n"; }
00030 \textcolor{comment}{// #else}
00031   \hyperlink{group___sparse_l_u___module_class_eigen_1_1_sparse_l_u}{SparseLU<SparseMatrix<scalar, ColMajor>}, 
      \hyperlink{group___ordering_methods___module_class_eigen_1_1_c_o_l_a_m_d_ordering}{COLAMDOrdering<int>} >  solver;
00032   std::cout<< \textcolor{stringliteral}{"ORDERING : COLAMD\(\backslash\)n"}; 
00033 \textcolor{comment}{// #endif}
00034   
00035   ifstream matrix\_file; 
00036   \textcolor{keywordtype}{string} line;
00037   \textcolor{keywordtype}{int}  n;
00038   \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} timer; 
00039   
00040   \textcolor{comment}{// Set parameters}
00041   \textcolor{comment}{/* Fill the matrix with sparse matrix stored in Matrix-Market coordinate column-oriented format */}
00042   \textcolor{keywordflow}{if} (argc < 2) assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"please, give the matrix market file "});
00043   loadMarket(A, args[1]);
00044   cout << \textcolor{stringliteral}{"End charging matrix "} << endl;
00045   \textcolor{keywordtype}{bool} iscomplex=\textcolor{keyword}{false}, isvector=\textcolor{keyword}{false};
00046   \textcolor{keywordtype}{int} sym;
00047   getMarketHeader(args[1], sym, iscomplex, isvector);
00048 \textcolor{comment}{//   if (iscomplex) \{ cout<< " Not for complex matrices \(\backslash\)n"; return -1; \}}
00049   \textcolor{keywordflow}{if} (isvector) \{ cout << \textcolor{stringliteral}{"The provided file is not a matrix file\(\backslash\)n"}; \textcolor{keywordflow}{return} -1;\}
00050   \textcolor{keywordflow}{if} (sym != 0) \{ \textcolor{comment}{// symmetric matrices, only the lower part is stored}
00051     \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<scalar, ColMajor>} temp; 
00052     temp = A;
00053     A = temp.selfadjointView<\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}>();
00054   \}
00055   n = A.\hyperlink{group___sparse_core___module_aa391750e3c530227e4a5c3c52e959975}{cols}();
00056   \textcolor{comment}{/* Fill the right hand side */}
00057 
00058   \textcolor{keywordflow}{if} (argc > 2)
00059     loadMarketVector(b, args[2]);
00060   \textcolor{keywordflow}{else} 
00061   \{
00062     b.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(n);
00063     tmp.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(n);
00064 \textcolor{comment}{//       tmp.setRandom();}
00065     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < n; i++) tmp(i) = i; 
00066     b = A * tmp ;
00067   \}
00068 
00069   \textcolor{comment}{/* Compute the factorization */}
00070 \textcolor{comment}{//   solver.isSymmetric(true);}
00071   timer.start(); 
00072 \textcolor{comment}{//   solver.compute(A);}
00073   solver.\hyperlink{group___sparse_l_u___module_aa907ff958c4f4855145091d2686f3a8a}{analyzePattern}(A); 
00074   timer.stop(); 
00075   cout << \textcolor{stringliteral}{"Time to analyze "} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << std::endl;
00076   timer.reset(); 
00077   timer.start(); 
00078   solver.\hyperlink{group___sparse_l_u___module_a39858b0e72f2659d596364e252b34cbc}{factorize}(A); 
00079   timer.stop(); 
00080   cout << \textcolor{stringliteral}{"Factorize Time "} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << std::endl;
00081   timer.reset(); 
00082   timer.start(); 
00083   x = solver.\hyperlink{group___sparse_core___module_a4a66e9498b06e3ec4ec36f06b26d4e8f}{solve}(b);
00084   timer.stop();
00085   cout << \textcolor{stringliteral}{"solve time "} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << std::endl; 
00086   \textcolor{comment}{/* Check the accuracy */}
00087   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<scalar, Dynamic, 1>} tmp2 = b - A*x;
00088   scalar tempNorm = tmp2.norm()/b.norm();
00089   cout << \textcolor{stringliteral}{"Relative norm of the computed solution : "} << tempNorm <<\textcolor{stringliteral}{"\(\backslash\)n"};
00090   cout << \textcolor{stringliteral}{"Number of nonzeros in the factor : "} << solver.nnzL() + solver.nnzU() << std::endl; 
00091   
00092   \textcolor{keywordflow}{return} 0;
00093 \}
\end{DoxyCode}
