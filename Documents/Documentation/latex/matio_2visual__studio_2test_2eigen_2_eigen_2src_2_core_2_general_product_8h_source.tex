\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_general_product_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/\+General\+Product.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_general_product_8h_source}\index{General\+Product.\+h@{General\+Product.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2008-2011 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_GENERAL\_PRODUCT\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_GENERAL\_PRODUCT\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 
00016 \textcolor{keyword}{enum} \{
00017   Large = 2,
00018   Small = 3
00019 \};
00020 
00021 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00022 
00023 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Rows, \textcolor{keywordtype}{int} Cols, \textcolor{keywordtype}{int} Depth> \textcolor{keyword}{struct }product\_type\_selector;
00024 
00025 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Size, \textcolor{keywordtype}{int} MaxSize> \textcolor{keyword}{struct }product\_size\_category
00026 \{
00027   \textcolor{keyword}{enum} \{ is\_large = MaxSize == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} ||
00028                     Size >= EIGEN\_CACHEFRIENDLY\_PRODUCT\_THRESHOLD ||
00029                     (Size==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} && MaxSize>=EIGEN\_CACHEFRIENDLY\_PRODUCT\_THRESHOLD),
00030          value = is\_large  ? Large
00031                : Size == 1 ? 1
00032                            : Small
00033   \};
00034 \};
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs> \textcolor{keyword}{struct }product\_type
00037 \{
00038   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<Lhs>::type \_Lhs;
00039   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<Rhs>::type \_Rhs;
00040   \textcolor{keyword}{enum} \{
00041     MaxRows = traits<\_Lhs>::MaxRowsAtCompileTime,
00042     Rows    = traits<\_Lhs>::RowsAtCompileTime,
00043     MaxCols = traits<\_Rhs>::MaxColsAtCompileTime,
00044     Cols    = traits<\_Rhs>::ColsAtCompileTime,
00045     MaxDepth = EIGEN\_SIZE\_MIN\_PREFER\_FIXED(traits<\_Lhs>::MaxColsAtCompileTime,
00046                                            traits<\_Rhs>::MaxRowsAtCompileTime),
00047     Depth = EIGEN\_SIZE\_MIN\_PREFER\_FIXED(traits<\_Lhs>::ColsAtCompileTime,
00048                                         traits<\_Rhs>::RowsAtCompileTime)
00049   \};
00050 
00051   \textcolor{comment}{// the splitting into different lines of code here, introducing the \_select enums and the typedef below,}
00052   \textcolor{comment}{// is to work around an internal compiler error with gcc 4.1 and 4.2.}
00053 \textcolor{keyword}{private}:
00054   \textcolor{keyword}{enum} \{
00055     rows\_select = product\_size\_category<Rows,MaxRows>::value,
00056     cols\_select = product\_size\_category<Cols,MaxCols>::value,
00057     depth\_select = product\_size\_category<Depth,MaxDepth>::value
00058   \};
00059   \textcolor{keyword}{typedef} product\_type\_selector<rows\_select, cols\_select, depth\_select> selector;
00060 
00061 \textcolor{keyword}{public}:
00062   \textcolor{keyword}{enum} \{
00063     value = selector::ret,
00064     ret = selector::ret
00065   \};
00066 \textcolor{preprocessor}{#ifdef EIGEN\_DEBUG\_PRODUCT}
00067   \textcolor{keyword}{static} \textcolor{keywordtype}{void} debug()
00068   \{
00069       EIGEN\_DEBUG\_VAR(Rows);
00070       EIGEN\_DEBUG\_VAR(Cols);
00071       EIGEN\_DEBUG\_VAR(Depth);
00072       EIGEN\_DEBUG\_VAR(rows\_select);
00073       EIGEN\_DEBUG\_VAR(cols\_select);
00074       EIGEN\_DEBUG\_VAR(depth\_select);
00075       EIGEN\_DEBUG\_VAR(value);
00076   \}
00077 \textcolor{preprocessor}{#endif}
00078 \};
00079 
00080 \textcolor{comment}{/* The following allows to select the kind of product at compile time}
00081 \textcolor{comment}{ * based on the three dimensions of the product.}
00082 \textcolor{comment}{ * This is a compile time mapping from \{1,Small,Large\}^3 -> \{product types\} */}
00083 \textcolor{comment}{// FIXME I'm not sure the current mapping is the ideal one.}
00084 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} M, \textcolor{keywordtype}{int} N>  \textcolor{keyword}{struct }product\_type\_selector<\hyperlink{group___core___module_class_eigen_1_1_matrix}{M},N,1>              \{ \textcolor{keyword}{enum} \{ ret = OuterProduct \}; \};
00085 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} M>         \textcolor{keyword}{struct }product\_type\_selector<\hyperlink{group___core___module_class_eigen_1_1_matrix}{M}, 1, 1>            \{ \textcolor{keyword}{enum} \{ ret = 
      LazyCoeffBasedProductMode \}; \};
00086 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} N>         \textcolor{keyword}{struct }product\_type\_selector<1, N, 1>            \{ \textcolor{keyword}{enum} \{ ret = 
      LazyCoeffBasedProductMode \}; \};
00087 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Depth>     \textcolor{keyword}{struct }product\_type\_selector<1,    1,    Depth>  \{ \textcolor{keyword}{enum} \{ ret = InnerProduct \}; \};
00088 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<1,    1,    1>      \{ \textcolor{keyword}{enum} \{ ret = InnerProduct \}; \};
00089 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Small,1,    Small>  \{ \textcolor{keyword}{enum} \{ ret = 
      CoeffBasedProductMode \}; \};
00090 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<1,    Small,Small>  \{ \textcolor{keyword}{enum} \{ ret = 
      CoeffBasedProductMode \}; \};
00091 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Small,Small,Small>  \{ \textcolor{keyword}{enum} \{ ret = 
      CoeffBasedProductMode \}; \};
00092 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Small, Small, 1>    \{ \textcolor{keyword}{enum} \{ ret = 
      LazyCoeffBasedProductMode \}; \};
00093 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Small, Large, 1>    \{ \textcolor{keyword}{enum} \{ ret = 
      LazyCoeffBasedProductMode \}; \};
00094 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Large, Small, 1>    \{ \textcolor{keyword}{enum} \{ ret = 
      LazyCoeffBasedProductMode \}; \};
00095 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<1,    Large,Small>  \{ \textcolor{keyword}{enum} \{ ret = 
      CoeffBasedProductMode \}; \};
00096 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<1,    Large,Large>  \{ \textcolor{keyword}{enum} \{ ret = GemvProduct \}; \};
00097 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<1,    Small,Large>  \{ \textcolor{keyword}{enum} \{ ret = 
      CoeffBasedProductMode \}; \};
00098 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Large,1,    Small>  \{ \textcolor{keyword}{enum} \{ ret = 
      CoeffBasedProductMode \}; \};
00099 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Large,1,    Large>  \{ \textcolor{keyword}{enum} \{ ret = GemvProduct \}; \};
00100 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Small,1,    Large>  \{ \textcolor{keyword}{enum} \{ ret = 
      CoeffBasedProductMode \}; \};
00101 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Small,Small,Large>  \{ \textcolor{keyword}{enum} \{ ret = GemmProduct \}; \};
00102 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Large,Small,Large>  \{ \textcolor{keyword}{enum} \{ ret = GemmProduct \}; \};
00103 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Small,Large,Large>  \{ \textcolor{keyword}{enum} \{ ret = GemmProduct \}; \};
00104 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Large,Large,Large>  \{ \textcolor{keyword}{enum} \{ ret = GemmProduct \}; \};
00105 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Large,Small,Small>  \{ \textcolor{keyword}{enum} \{ ret = 
      CoeffBasedProductMode \}; \};
00106 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Small,Large,Small>  \{ \textcolor{keyword}{enum} \{ ret = 
      CoeffBasedProductMode \}; \};
00107 \textcolor{keyword}{template}<>              \textcolor{keyword}{struct }product\_type\_selector<Large,Large,Small>  \{ \textcolor{keyword}{enum} \{ ret = GemmProduct \}; \};
00108 
00109 \} \textcolor{comment}{// end namespace internal}
00110 
00111 \textcolor{comment}{/***********************************************************************}
00112 \textcolor{comment}{*  Implementation of Inner Vector Vector Product}
00113 \textcolor{comment}{***********************************************************************/}
00114 
00115 \textcolor{comment}{// FIXME : maybe the "inner product" could return a Scalar}
00116 \textcolor{comment}{// instead of a 1x1 matrix ??}
00117 \textcolor{comment}{// Pro: more natural for the user}
00118 \textcolor{comment}{// Cons: this could be a problem if in a meta unrolled algorithm a matrix-matrix}
00119 \textcolor{comment}{// product ends up to a row-vector times col-vector product... To tackle this use}
00120 \textcolor{comment}{// case, we could have a specialization for Block<MatrixType,1,1> with: operator=(Scalar x);}
00121 
00122 \textcolor{comment}{/***********************************************************************}
00123 \textcolor{comment}{*  Implementation of Outer Vector Vector Product}
00124 \textcolor{comment}{***********************************************************************/}
00125 
00126 \textcolor{comment}{/***********************************************************************}
00127 \textcolor{comment}{*  Implementation of General Matrix Vector Product}
00128 \textcolor{comment}{***********************************************************************/}
00129 
00130 \textcolor{comment}{/*  According to the shape/flags of the matrix we have to distinghish 3 different cases:}
00131 \textcolor{comment}{ *   1 - the matrix is col-major, BLAS compatible and M is large => call fast BLAS-like colmajor routine}
00132 \textcolor{comment}{ *   2 - the matrix is row-major, BLAS compatible and N is large => call fast BLAS-like rowmajor routine}
00133 \textcolor{comment}{ *   3 - all other cases are handled using a simple loop along the outer-storage direction.}
00134 \textcolor{comment}{ *  Therefore we need a lower level meta selector.}
00135 \textcolor{comment}{ *  Furthermore, if the matrix is the rhs, then the product has to be transposed.}
00136 \textcolor{comment}{ */}
00137 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00138 
00139 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} S\textcolor{keywordtype}{id}e, \textcolor{keywordtype}{int} StorageOrder, \textcolor{keywordtype}{bool} BlasCompatible>
00140 \textcolor{keyword}{struct }gemv\_dense\_selector;
00141 
00142 \} \textcolor{comment}{// end namespace internal}
00143 
00144 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00145 
00146 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keywordtype}{int} Size,\textcolor{keywordtype}{int} MaxSize,\textcolor{keywordtype}{bool} Cond> \textcolor{keyword}{struct }gemv\_static\_vector\_if;
00147 
00148 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keywordtype}{int} Size,\textcolor{keywordtype}{int} MaxSize>
00149 \textcolor{keyword}{struct }gemv\_static\_vector\_if<Scalar,Size,MaxSize,false>
00150 \{
00151   EIGEN\_STRONG\_INLINE  Scalar* data() \{ eigen\_internal\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"should never be called"}); \textcolor{keywordflow}{return} 0;
       \}
00152 \};
00153 
00154 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keywordtype}{int} Size>
00155 \textcolor{keyword}{struct }gemv\_static\_vector\_if<Scalar,Size,\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},true>
00156 \{
00157   EIGEN\_STRONG\_INLINE Scalar* data() \{ \textcolor{keywordflow}{return} 0; \}
00158 \};
00159 
00160 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keywordtype}{int} Size,\textcolor{keywordtype}{int} MaxSize>
00161 \textcolor{keyword}{struct }gemv\_static\_vector\_if<Scalar,Size,MaxSize,true>
00162 \{
00163   \textcolor{keyword}{enum} \{
00164     ForceAlignment  = internal::packet\_traits<Scalar>::Vectorizable,
00165     PacketSize      = internal::packet\_traits<Scalar>::size
00166   \};
00167 \textcolor{preprocessor}{  #if EIGEN\_MAX\_STATIC\_ALIGN\_BYTES!=0}
00168   
      internal::plain\_array<Scalar,EIGEN\_SIZE\_MIN\_PREFER\_FIXED(Size,MaxSize),0,EIGEN\_PLAIN\_ENUM\_MIN(AlignedMax,PacketSize)> m\_data;
00169   EIGEN\_STRONG\_INLINE Scalar* data() \{ \textcolor{keywordflow}{return} m\_data.array; \}
00170 \textcolor{preprocessor}{  #else}
00171   \textcolor{comment}{// Some architectures cannot align on the stack,}
00172   \textcolor{comment}{// => let's manually enforce alignment by allocating more data and return the address of the first
       aligned element.}
00173   
      internal::plain\_array<Scalar,EIGEN\_SIZE\_MIN\_PREFER\_FIXED(Size,MaxSize)+(ForceAlignment?EIGEN\_MAX\_ALIGN\_BYTES:0),0> m\_data;
00174   EIGEN\_STRONG\_INLINE Scalar* data() \{
00175     \textcolor{keywordflow}{return} ForceAlignment
00176             ? \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}((internal::UIntPtr(m\_data.array) & ~(std::size\_t(
      EIGEN\_MAX\_ALIGN\_BYTES-1))) + EIGEN\_MAX\_ALIGN\_BYTES)
00177             : m\_data.array;
00178   \}
00179 \textcolor{preprocessor}{  #endif}
00180 \};
00181 
00182 \textcolor{comment}{// The vector is on the left => transposition}
00183 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} StorageOrder, \textcolor{keywordtype}{bool} BlasCompatible>
00184 \textcolor{keyword}{struct }gemv\_dense\_selector<\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4}{OnTheLeft},StorageOrder,BlasCompatible>
00185 \{
00186   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest>
00187   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs &lhs, \textcolor{keyword}{const} Rhs &rhs, Dest& dest, \textcolor{keyword}{const} \textcolor{keyword}{typename} Dest::Scalar& alpha)
00188   \{
00189     Transpose<Dest> destT(dest);
00190     \textcolor{keyword}{enum} \{ OtherStorageOrder = StorageOrder == \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor} : 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} \};
00191     gemv\_dense\_selector<OnTheRight,OtherStorageOrder,BlasCompatible>
00192       ::run(rhs.transpose(), lhs.transpose(), destT, alpha);
00193   \}
00194 \};
00195 
00196 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }gemv\_dense\_selector<\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b}{OnTheRight},\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},true>
00197 \{
00198   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest>
00199   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs &lhs, \textcolor{keyword}{const} Rhs &rhs, Dest& dest, \textcolor{keyword}{const} \textcolor{keyword}{typename} Dest::Scalar& alpha)
00200   \{
00201     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Lhs::Scalar   LhsScalar;
00202     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Rhs::Scalar   RhsScalar;
00203     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Dest::Scalar  ResScalar;
00204     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Dest::RealScalar  RealScalar;
00205     
00206     \textcolor{keyword}{typedef} internal::blas\_traits<Lhs> LhsBlasTraits;
00207     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsBlasTraits::DirectLinearAccessType ActualLhsType;
00208     \textcolor{keyword}{typedef} internal::blas\_traits<Rhs> RhsBlasTraits;
00209     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsBlasTraits::DirectLinearAccessType ActualRhsType;
00210   
00211     \textcolor{keyword}{typedef} Map<Matrix<ResScalar,Dynamic,1>, EIGEN\_PLAIN\_ENUM\_MIN(AlignedMax,
      internal::packet\_traits<ResScalar>::size)> MappedDest;
00212 
00213     ActualLhsType actualLhs = LhsBlasTraits::extract(lhs);
00214     ActualRhsType actualRhs = RhsBlasTraits::extract(rhs);
00215 
00216     ResScalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(lhs)
00217                                   * RhsBlasTraits::extractScalarFactor(rhs);
00218 
00219     \textcolor{comment}{// make sure Dest is a compile-time vector type (bug 1166)}
00220     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Dest::IsVectorAtCompileTime, Dest, typename Dest::ColXpr>::type ActualDest
      ;
00221 
00222     \textcolor{keyword}{enum} \{
00223       \textcolor{comment}{// FIXME find a way to allow an inner stride on the result if packet\_traits<Scalar>::size==1}
00224       \textcolor{comment}{// on, the other hand it is good for the cache to pack the vector anyways...}
00225       EvalToDestAtCompileTime = (ActualDest::InnerStrideAtCompileTime==1),
00226       ComplexByReal = (NumTraits<LhsScalar>::IsComplex) && (!NumTraits<RhsScalar>::IsComplex),
00227       MightCannotUseDest = (!EvalToDestAtCompileTime) || ComplexByReal
00228     \};
00229 
00230     \textcolor{keyword}{typedef} const\_blas\_data\_mapper<LhsScalar,Index,ColMajor> LhsMapper;
00231     \textcolor{keyword}{typedef} const\_blas\_data\_mapper<RhsScalar,Index,RowMajor> RhsMapper;
00232     RhsScalar compatibleAlpha = get\_factor<ResScalar,RhsScalar>::run(actualAlpha);
00233 
00234     \textcolor{keywordflow}{if}(!MightCannotUseDest)
00235     \{
00236       \textcolor{comment}{// shortcut if we are sure to be able to use dest directly,}
00237       \textcolor{comment}{// this ease the compiler to generate cleaner and more optimzized code for most common cases}
00238       general\_matrix\_vector\_product
00239           <\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},LhsScalar,LhsMapper,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},LhsBlasTraits::NeedToConjugate,RhsScalar,
      RhsMapper,RhsBlasTraits::NeedToConjugate>::run(
00240           actualLhs.rows(), actualLhs.cols(),
00241           LhsMapper(actualLhs.data(), actualLhs.outerStride()),
00242           RhsMapper(actualRhs.data(), actualRhs.innerStride()),
00243           dest.data(), 1,
00244           compatibleAlpha);
00245     \}
00246     \textcolor{keywordflow}{else}
00247     \{
00248       
      gemv\_static\_vector\_if<ResScalar,ActualDest::SizeAtCompileTime,ActualDest::MaxSizeAtCompileTime,MightCannotUseDest> static\_dest;
00249 
00250       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} alphaIsCompatible = (!ComplexByReal) || (numext::imag(actualAlpha)==RealScalar(0));
00251       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} evalToDest = EvalToDestAtCompileTime && alphaIsCompatible;
00252 
00253       ei\_declare\_aligned\_stack\_constructed\_variable(ResScalar,actualDestPtr,dest.size(),
00254                                                     evalToDest ? dest.data() : static\_dest.data());
00255 
00256       \textcolor{keywordflow}{if}(!evalToDest)
00257       \{
00258 \textcolor{preprocessor}{        #ifdef EIGEN\_DENSE\_STORAGE\_CTOR\_PLUGIN}
00259         Index size = dest.size();
00260         EIGEN\_DENSE\_STORAGE\_CTOR\_PLUGIN
00261 \textcolor{preprocessor}{        #endif}
00262         \textcolor{keywordflow}{if}(!alphaIsCompatible)
00263         \{
00264           MappedDest(actualDestPtr, dest.size()).setZero();
00265           compatibleAlpha = RhsScalar(1);
00266         \}
00267         \textcolor{keywordflow}{else}
00268           MappedDest(actualDestPtr, dest.size()) = dest;
00269       \}
00270 
00271       general\_matrix\_vector\_product
00272           <\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},LhsScalar,LhsMapper,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},LhsBlasTraits::NeedToConjugate,RhsScalar,
      RhsMapper,RhsBlasTraits::NeedToConjugate>::run(
00273           actualLhs.rows(), actualLhs.cols(),
00274           LhsMapper(actualLhs.data(), actualLhs.outerStride()),
00275           RhsMapper(actualRhs.data(), actualRhs.innerStride()),
00276           actualDestPtr, 1,
00277           compatibleAlpha);
00278 
00279       \textcolor{keywordflow}{if} (!evalToDest)
00280       \{
00281         \textcolor{keywordflow}{if}(!alphaIsCompatible)
00282           dest.matrix() += actualAlpha * MappedDest(actualDestPtr, dest.size());
00283         \textcolor{keywordflow}{else}
00284           dest = MappedDest(actualDestPtr, dest.size());
00285       \}
00286     \}
00287   \}
00288 \};
00289 
00290 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }gemv\_dense\_selector<\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b}{OnTheRight},\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},true>
00291 \{
00292   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest>
00293   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs &lhs, \textcolor{keyword}{const} Rhs &rhs, Dest& dest, \textcolor{keyword}{const} \textcolor{keyword}{typename} Dest::Scalar& alpha)
00294   \{
00295     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Lhs::Scalar   LhsScalar;
00296     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Rhs::Scalar   RhsScalar;
00297     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Dest::Scalar  ResScalar;
00298     
00299     \textcolor{keyword}{typedef} internal::blas\_traits<Lhs> LhsBlasTraits;
00300     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsBlasTraits::DirectLinearAccessType ActualLhsType;
00301     \textcolor{keyword}{typedef} internal::blas\_traits<Rhs> RhsBlasTraits;
00302     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsBlasTraits::DirectLinearAccessType ActualRhsType;
00303     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ActualRhsType>::type ActualRhsTypeCleaned;
00304 
00305     \textcolor{keyword}{typename} add\_const<ActualLhsType>::type actualLhs = LhsBlasTraits::extract(lhs);
00306     \textcolor{keyword}{typename} add\_const<ActualRhsType>::type actualRhs = RhsBlasTraits::extract(rhs);
00307 
00308     ResScalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(lhs)
00309                                   * RhsBlasTraits::extractScalarFactor(rhs);
00310 
00311     \textcolor{keyword}{enum} \{
00312       \textcolor{comment}{// FIXME find a way to allow an inner stride on the result if packet\_traits<Scalar>::size==1}
00313       \textcolor{comment}{// on, the other hand it is good for the cache to pack the vector anyways...}
00314       DirectlyUseRhs = ActualRhsTypeCleaned::InnerStrideAtCompileTime==1
00315     \};
00316 
00317     
      gemv\_static\_vector\_if<RhsScalar,ActualRhsTypeCleaned::SizeAtCompileTime,ActualRhsTypeCleaned::MaxSizeAtCompileTime,!DirectlyUseRhs> static\_rhs;
00318 
00319     ei\_declare\_aligned\_stack\_constructed\_variable(RhsScalar,actualRhsPtr,actualRhs.size(),
00320         DirectlyUseRhs ? \textcolor{keyword}{const\_cast<}RhsScalar*\textcolor{keyword}{>}(actualRhs.data()) : static\_rhs.data());
00321 
00322     \textcolor{keywordflow}{if}(!DirectlyUseRhs)
00323     \{
00324 \textcolor{preprocessor}{      #ifdef EIGEN\_DENSE\_STORAGE\_CTOR\_PLUGIN}
00325       Index size = actualRhs.size();
00326       EIGEN\_DENSE\_STORAGE\_CTOR\_PLUGIN
00327 \textcolor{preprocessor}{      #endif}
00328       Map<typename ActualRhsTypeCleaned::PlainObject>(actualRhsPtr, actualRhs.size()) = actualRhs;
00329     \}
00330 
00331     \textcolor{keyword}{typedef} const\_blas\_data\_mapper<LhsScalar,Index,RowMajor> LhsMapper;
00332     \textcolor{keyword}{typedef} const\_blas\_data\_mapper<RhsScalar,Index,ColMajor> RhsMapper;
00333     general\_matrix\_vector\_product
00334         <\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},LhsScalar,LhsMapper,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},LhsBlasTraits::NeedToConjugate,RhsScalar,RhsMapper
      ,RhsBlasTraits::NeedToConjugate>::run(
00335         actualLhs.rows(), actualLhs.cols(),
00336         LhsMapper(actualLhs.data(), actualLhs.outerStride()),
00337         RhsMapper(actualRhsPtr, 1),
00338         dest.data(), dest.col(0).innerStride(), \textcolor{comment}{//NOTE  if dest is not a vector at compile-time, then
       dest.innerStride() might be wrong. (bug 1166)}
00339         actualAlpha);
00340   \}
00341 \};
00342 
00343 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }gemv\_dense\_selector<\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b}{OnTheRight},ColMajor,false>
00344 \{
00345   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest>
00346   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs &lhs, \textcolor{keyword}{const} Rhs &rhs, Dest& dest, \textcolor{keyword}{const} \textcolor{keyword}{typename} Dest::Scalar& alpha)
00347   \{
00348     EIGEN\_STATIC\_ASSERT((!nested\_eval<Lhs,1>::Evaluate),
      EIGEN\_INTERNAL\_COMPILATION\_ERROR\_OR\_YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00349     \textcolor{comment}{// TODO if rhs is large enough it might be beneficial to make sure that dest is sequentially stored in
       memory, otherwise use a temp}
00350     \textcolor{keyword}{typename} nested\_eval<Rhs,1>::type actual\_rhs(rhs);
00351     \textcolor{keyword}{const} Index size = rhs.rows();
00352     \textcolor{keywordflow}{for}(Index k=0; k<size; ++k)
00353       dest += (alpha*actual\_rhs.coeff(k)) * lhs.col(k);
00354   \}
00355 \};
00356 
00357 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }gemv\_dense\_selector<\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b}{OnTheRight},RowMajor,false>
00358 \{
00359   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest>
00360   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Lhs &lhs, \textcolor{keyword}{const} Rhs &rhs, Dest& dest, \textcolor{keyword}{const} \textcolor{keyword}{typename} Dest::Scalar& alpha)
00361   \{
00362     EIGEN\_STATIC\_ASSERT((!nested\_eval<Lhs,1>::Evaluate),
      EIGEN\_INTERNAL\_COMPILATION\_ERROR\_OR\_YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00363     \textcolor{keyword}{typename} nested\_eval<Rhs,Lhs::RowsAtCompileTime>::type actual\_rhs(rhs);
00364     \textcolor{keyword}{const} Index rows = dest.rows();
00365     \textcolor{keywordflow}{for}(Index i=0; i<rows; ++i)
00366       dest.coeffRef(i) += alpha * (lhs.row(i).cwiseProduct(actual\_rhs.transpose())).sum();
00367   \}
00368 \};
00369 
00370 \} \textcolor{comment}{// end namespace internal}
00371 
00372 \textcolor{comment}{/***************************************************************************}
00373 \textcolor{comment}{* Implementation of matrix base methods}
00374 \textcolor{comment}{***************************************************************************/}
00375 
00382 \textcolor{preprocessor}{#ifndef \_\_CUDACC\_\_}
00383 
00384 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00385 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00386 \textcolor{keyword}{inline} \textcolor{keyword}{const} Product<Derived, OtherDerived>
00387 \hyperlink{group___core___module_ae2d220efbf7047f0894787888288cfcc}{MatrixBase<Derived>::operator*}(\textcolor{keyword}{const} MatrixBase<OtherDerived> &other)\textcolor{keyword}{ const}
00388 \textcolor{keyword}{}\{
00389   \textcolor{comment}{// A note regarding the function declaration: In MSVC, this function will sometimes}
00390   \textcolor{comment}{// not be inlined since DenseStorage is an unwindable object for dynamic}
00391   \textcolor{comment}{// matrices and product types are holding a member to store the result.}
00392   \textcolor{comment}{// Thus it does not help tagging this function with EIGEN\_STRONG\_INLINE.}
00393   \textcolor{keyword}{enum} \{
00394     ProductIsValid =  Derived::ColsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}
00395                    || OtherDerived::RowsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}
00396                    || int(Derived::ColsAtCompileTime)==int(OtherDerived::RowsAtCompileTime),
00397     AreVectors = Derived::IsVectorAtCompileTime && OtherDerived::IsVectorAtCompileTime,
00398     SameSizes = EIGEN\_PREDICATE\_SAME\_MATRIX\_SIZE(Derived,OtherDerived)
00399   \};
00400   \textcolor{comment}{// note to the lost user:}
00401   \textcolor{comment}{//    * for a dot product use: v1.dot(v2)}
00402   \textcolor{comment}{//    * for a coeff-wise product use: v1.cwiseProduct(v2)}
00403   EIGEN\_STATIC\_ASSERT(ProductIsValid || !(AreVectors && SameSizes),
00404     
      INVALID\_VECTOR\_VECTOR\_PRODUCT\_\_IF\_YOU\_WANTED\_A\_DOT\_OR\_COEFF\_WISE\_PRODUCT\_YOU\_MUST\_USE\_THE\_EXPLICIT\_FUNCTIONS)
00405   EIGEN\_STATIC\_ASSERT(ProductIsValid || !(SameSizes && !AreVectors),
00406     INVALID\_MATRIX\_PRODUCT\_\_IF\_YOU\_WANTED\_A\_COEFF\_WISE\_PRODUCT\_YOU\_MUST\_USE\_THE\_EXPLICIT\_FUNCTION)
00407   EIGEN\_STATIC\_ASSERT(ProductIsValid || SameSizes, INVALID\_MATRIX\_PRODUCT)
00408 \textcolor{preprocessor}{#ifdef EIGEN\_DEBUG\_PRODUCT}
00409   internal::product\_type<Derived,OtherDerived>::debug();
00410 \textcolor{preprocessor}{#endif}
00411 
00412   \textcolor{keywordflow}{return} Product<Derived, OtherDerived>(derived(), other.derived());
00413 \}
00414 
00415 \textcolor{preprocessor}{#endif // \_\_CUDACC\_\_}
00416 
00428 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00429 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00430 \textcolor{keyword}{const} Product<Derived,OtherDerived,LazyProduct>
00431 MatrixBase<Derived>::lazyProduct(\textcolor{keyword}{const} MatrixBase<OtherDerived> &other)\textcolor{keyword}{ const}
00432 \textcolor{keyword}{}\{
00433   \textcolor{keyword}{enum} \{
00434     ProductIsValid =  Derived::ColsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}
00435                    || OtherDerived::RowsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}
00436                    || int(Derived::ColsAtCompileTime)==int(OtherDerived::RowsAtCompileTime),
00437     AreVectors = Derived::IsVectorAtCompileTime && OtherDerived::IsVectorAtCompileTime,
00438     SameSizes = EIGEN\_PREDICATE\_SAME\_MATRIX\_SIZE(Derived,OtherDerived)
00439   \};
00440   \textcolor{comment}{// note to the lost user:}
00441   \textcolor{comment}{//    * for a dot product use: v1.dot(v2)}
00442   \textcolor{comment}{//    * for a coeff-wise product use: v1.cwiseProduct(v2)}
00443   EIGEN\_STATIC\_ASSERT(ProductIsValid || !(AreVectors && SameSizes),
00444     
      INVALID\_VECTOR\_VECTOR\_PRODUCT\_\_IF\_YOU\_WANTED\_A\_DOT\_OR\_COEFF\_WISE\_PRODUCT\_YOU\_MUST\_USE\_THE\_EXPLICIT\_FUNCTIONS)
00445   EIGEN\_STATIC\_ASSERT(ProductIsValid || !(SameSizes && !AreVectors),
00446     INVALID\_MATRIX\_PRODUCT\_\_IF\_YOU\_WANTED\_A\_COEFF\_WISE\_PRODUCT\_YOU\_MUST\_USE\_THE\_EXPLICIT\_FUNCTION)
00447   EIGEN\_STATIC\_ASSERT(ProductIsValid || SameSizes, INVALID\_MATRIX\_PRODUCT)
00448 
00449   \textcolor{keywordflow}{return} Product<Derived,OtherDerived,LazyProduct>(derived(), other.derived());
00450 \}
00451 
00452 \} \textcolor{comment}{// end namespace Eigen}
00453 
00454 \textcolor{preprocessor}{#endif // EIGEN\_PRODUCT\_H}
\end{DoxyCode}
