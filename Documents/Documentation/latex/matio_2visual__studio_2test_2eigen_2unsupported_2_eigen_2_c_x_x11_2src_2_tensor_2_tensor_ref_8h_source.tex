\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_ref_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Ref.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_ref_8h_source}\index{Tensor\+Ref.\+h@{Tensor\+Ref.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_REF\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_REF\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Dimensions, \textcolor{keyword}{typename} Scalar>
00018 \textcolor{keyword}{class }TensorLazyBaseEvaluator \{
00019  \textcolor{keyword}{public}:
00020   TensorLazyBaseEvaluator() : m\_refcount(0) \{ \}
00021   \textcolor{keyword}{virtual} ~TensorLazyBaseEvaluator() \{ \}
00022 
00023   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{virtual} \textcolor{keyword}{const} Dimensions& dimensions() \textcolor{keyword}{const} = 0;
00024   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{virtual} \textcolor{keyword}{const} Scalar* data() \textcolor{keyword}{const} = 0;
00025 
00026   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{virtual} \textcolor{keyword}{const} Scalar coeff(DenseIndex index) \textcolor{keyword}{const} = 0;
00027   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{virtual} Scalar& coeffRef(DenseIndex index) = 0;
00028 
00029   \textcolor{keywordtype}{void} incrRefCount() \{ ++m\_refcount; \}
00030   \textcolor{keywordtype}{void} decrRefCount() \{ --m\_refcount; \}
00031   \textcolor{keywordtype}{int} refCount()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_refcount; \}
00032 
00033  \textcolor{keyword}{private}:
00034   \textcolor{comment}{// No copy, no assigment;}
00035   TensorLazyBaseEvaluator(\textcolor{keyword}{const} TensorLazyBaseEvaluator& other);
00036   TensorLazyBaseEvaluator& operator = (\textcolor{keyword}{const} TensorLazyBaseEvaluator& other);
00037 
00038   \textcolor{keywordtype}{int} m\_refcount;
00039 \};
00040 
00041 
00042 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Dimensions, \textcolor{keyword}{typename} Expr, \textcolor{keyword}{typename} Device>
00043 \textcolor{keyword}{class }TensorLazyEvaluatorReadOnly : \textcolor{keyword}{public} TensorLazyBaseEvaluator<Dimensions, typename TensorEvaluator<Exp
      r, Device>::Scalar> \{
00044  \textcolor{keyword}{public}:
00045   \textcolor{comment}{//  typedef typename TensorEvaluator<Expr, Device>::Dimensions Dimensions;}
00046   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} TensorEvaluator<Expr, Device>::Scalar Scalar;
00047 
00048   TensorLazyEvaluatorReadOnly(\textcolor{keyword}{const} Expr& expr, \textcolor{keyword}{const} Device& device) : m\_impl(expr, device), m\_dummy(
      Scalar(0)) \{
00049     m\_dims = m\_impl.dimensions();
00050     m\_impl.evalSubExprsIfNeeded(NULL);
00051   \}
00052   \textcolor{keyword}{virtual} ~TensorLazyEvaluatorReadOnly() \{
00053     m\_impl.cleanup();
00054   \}
00055 
00056   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{virtual} \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{
00057     \textcolor{keywordflow}{return} m\_dims;
00058   \}
00059   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{virtual} \textcolor{keyword}{const} Scalar* data()\textcolor{keyword}{ const }\{
00060     \textcolor{keywordflow}{return} m\_impl.data();
00061   \}
00062 
00063   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{virtual} \textcolor{keyword}{const} Scalar coeff(DenseIndex index)\textcolor{keyword}{ const }\{
00064     \textcolor{keywordflow}{return} m\_impl.coeff(index);
00065   \}
00066   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{virtual} Scalar& coeffRef(DenseIndex \textcolor{comment}{/*index*/}) \{
00067     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"can't reference the coefficient of a rvalue"});
00068     \textcolor{keywordflow}{return} m\_dummy;
00069   \};
00070 
00071  \textcolor{keyword}{protected}:
00072   TensorEvaluator<Expr, Device> m\_impl;
00073   Dimensions m\_dims;
00074   Scalar m\_dummy;
00075 \};
00076 
00077 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Dimensions, \textcolor{keyword}{typename} Expr, \textcolor{keyword}{typename} Device>
00078 \textcolor{keyword}{class }TensorLazyEvaluatorWritable : \textcolor{keyword}{public} TensorLazyEvaluatorReadOnly<Dimensions, Expr, Device> \{
00079  \textcolor{keyword}{public}:
00080   \textcolor{keyword}{typedef} TensorLazyEvaluatorReadOnly<Dimensions, Expr, Device> Base;
00081   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::Scalar Scalar;
00082 
00083   TensorLazyEvaluatorWritable(\textcolor{keyword}{const} Expr& expr, \textcolor{keyword}{const} Device& device) : Base(expr, device) \{
00084   \}
00085   \textcolor{keyword}{virtual} ~TensorLazyEvaluatorWritable() \{
00086   \}
00087 
00088   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{virtual} Scalar& coeffRef(DenseIndex index) \{
00089     \textcolor{keywordflow}{return} this->m\_impl.coeffRef(index);
00090   \}
00091 \};
00092 
00093 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Dimensions, \textcolor{keyword}{typename} Expr, \textcolor{keyword}{typename} Device>
00094 \textcolor{keyword}{class }TensorLazyEvaluator : \textcolor{keyword}{public} internal::conditional<bool(internal::is\_lvalue<Expr>::value),
00095                             TensorLazyEvaluatorWritable<Dimensions, Expr, Device>,
00096                             TensorLazyEvaluatorReadOnly<Dimensions, const Expr, Device> >::type \{
00097  \textcolor{keyword}{public}:
00098   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::conditional<bool(internal::is\_lvalue<Expr>::value),
00099                                          TensorLazyEvaluatorWritable<Dimensions, Expr, Device>,
00100                                          TensorLazyEvaluatorReadOnly<Dimensions, const Expr, Device> >::
      type Base;
00101   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::Scalar Scalar;
00102 
00103   TensorLazyEvaluator(\textcolor{keyword}{const} Expr& expr, \textcolor{keyword}{const} Device& device) : Base(expr, device) \{
00104   \}
00105   \textcolor{keyword}{virtual} ~TensorLazyEvaluator() \{
00106   \}
00107 \};
00108 
00109 \}  \textcolor{comment}{// namespace internal}
00110 
00111 
00119 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType> \textcolor{keyword}{class }TensorRef : \textcolor{keyword}{public} TensorBase<TensorRef<PlainObjectType> >
00120 \{
00121   \textcolor{keyword}{public}:
00122     \textcolor{keyword}{typedef} TensorRef<PlainObjectType> Self;
00123     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PlainObjectType::Base Base;
00124     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<Self>::type} Nested;
00125     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<PlainObjectType>::StorageKind StorageKind;
00126     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<PlainObjectType>::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00127     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<PlainObjectType>::Scalar Scalar;
00128     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar;
00129     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::CoeffReturnType CoeffReturnType;
00130     \textcolor{keyword}{typedef} Scalar* PointerType;
00131     \textcolor{keyword}{typedef} PointerType PointerArgType;
00132 
00133     \textcolor{keyword}{static} \textcolor{keyword}{const} Index NumIndices = PlainObjectType::NumIndices;
00134     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PlainObjectType::Dimensions Dimensions;
00135 
00136     \textcolor{keyword}{enum} \{
00137       IsAligned = \textcolor{keyword}{false},
00138       PacketAccess = \textcolor{keyword}{false},
00139       Layout = PlainObjectType::Layout,
00140       CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00141       RawAccess = \textcolor{keyword}{false}
00142     \};
00143 
00144     EIGEN\_STRONG\_INLINE TensorRef() : m\_evaluator(NULL) \{
00145     \}
00146 
00147     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Expression>
00148     EIGEN\_STRONG\_INLINE TensorRef(\textcolor{keyword}{const} Expression& expr) : m\_evaluator(new 
      \hyperlink{namespaceinternal}{internal}::TensorLazyEvaluator<Dimensions, Expression, DefaultDevice>(expr, DefaultDevice())) \{
00149       m\_evaluator->incrRefCount();
00150     \}
00151 
00152     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Expression>
00153     EIGEN\_STRONG\_INLINE TensorRef& operator = (\textcolor{keyword}{const} Expression& expr) \{
00154       unrefEvaluator();
00155       m\_evaluator = \textcolor{keyword}{new} internal::TensorLazyEvaluator<Dimensions, Expression, DefaultDevice>(expr, 
      DefaultDevice());
00156       m\_evaluator->incrRefCount();
00157       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00158     \}
00159 
00160     ~TensorRef() \{
00161       unrefEvaluator();
00162     \}
00163 
00164     TensorRef(\textcolor{keyword}{const} TensorRef& other) : m\_evaluator(other.m\_evaluator) \{
00165       eigen\_assert(m\_evaluator->refCount() > 0);
00166       m\_evaluator->incrRefCount();
00167     \}
00168 
00169     TensorRef& operator = (\textcolor{keyword}{const} TensorRef& other) \{
00170       \textcolor{keywordflow}{if} (\textcolor{keyword}{this} != &other) \{
00171         unrefEvaluator();
00172         m\_evaluator = other.m\_evaluator;
00173         eigen\_assert(m\_evaluator->refCount() > 0);
00174         m\_evaluator->incrRefCount();
00175       \}
00176       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00177     \}
00178 
00179     EIGEN\_DEVICE\_FUNC
00180     EIGEN\_STRONG\_INLINE Index rank()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_evaluator->dimensions().size(); \}
00181     EIGEN\_DEVICE\_FUNC
00182     EIGEN\_STRONG\_INLINE Index dimension(Index n)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_evaluator->dimensions()[n]; \}
00183     EIGEN\_DEVICE\_FUNC
00184     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_evaluator->dimensions(); \}
00185     EIGEN\_DEVICE\_FUNC
00186     EIGEN\_STRONG\_INLINE Index size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_evaluator->dimensions().TotalSize(); \}
00187     EIGEN\_DEVICE\_FUNC
00188     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_evaluator->data(); \}
00189 
00190     EIGEN\_DEVICE\_FUNC
00191     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator()(Index index)\textcolor{keyword}{ const}
00192 \textcolor{keyword}{    }\{
00193       \textcolor{keywordflow}{return} m\_evaluator->coeff(index);
00194     \}
00195 
00196 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00197     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes> EIGEN\_DEVICE\_FUNC
00198     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator()(Index firstIndex, IndexTypes... otherIndices)\textcolor{keyword}{ const}
00199 \textcolor{keyword}{    }\{
00200       \textcolor{keyword}{const} std::size\_t num\_indices = (\textcolor{keyword}{sizeof}...(otherIndices) + 1);
00201       \textcolor{keyword}{const} array<Index, num\_indices> indices\{\{firstIndex, otherIndices...\}\};
00202       \textcolor{keywordflow}{return} coeff(indices);
00203     \}
00204     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes> EIGEN\_DEVICE\_FUNC
00205     EIGEN\_STRONG\_INLINE Scalar& coeffRef(Index firstIndex, IndexTypes... otherIndices)
00206     \{
00207       \textcolor{keyword}{const} std::size\_t num\_indices = (\textcolor{keyword}{sizeof}...(otherIndices) + 1);
00208       \textcolor{keyword}{const} array<Index, num\_indices> indices\{\{firstIndex, otherIndices...\}\};
00209       \textcolor{keywordflow}{return} coeffRef(indices);
00210     \}
00211 \textcolor{preprocessor}{#else}
00212 
00213     EIGEN\_DEVICE\_FUNC
00214     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator()(Index i0, Index i1)\textcolor{keyword}{ const}
00215 \textcolor{keyword}{    }\{
00216       array<Index, 2> indices;
00217       indices[0] = i0;
00218       indices[1] = i1;
00219       \textcolor{keywordflow}{return} coeff(indices);
00220     \}
00221     EIGEN\_DEVICE\_FUNC
00222     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator()(Index i0, Index i1, Index i2)\textcolor{keyword}{ const}
00223 \textcolor{keyword}{    }\{
00224       array<Index, 3> indices;
00225       indices[0] = i0;
00226       indices[1] = i1;
00227       indices[2] = i2;
00228       \textcolor{keywordflow}{return} coeff(indices);
00229     \}
00230     EIGEN\_DEVICE\_FUNC
00231     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator()(Index i0, Index i1, Index i2, Index i3)\textcolor{keyword}{ const}
00232 \textcolor{keyword}{    }\{
00233       array<Index, 4> indices;
00234       indices[0] = i0;
00235       indices[1] = i1;
00236       indices[2] = i2;
00237       indices[3] = i3;
00238       \textcolor{keywordflow}{return} coeff(indices);
00239     \}
00240     EIGEN\_DEVICE\_FUNC
00241     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator()(Index i0, Index i1, Index i2, Index i3, Index i4)\textcolor{keyword}{ const}
00242 \textcolor{keyword}{    }\{
00243       array<Index, 5> indices;
00244       indices[0] = i0;
00245       indices[1] = i1;
00246       indices[2] = i2;
00247       indices[3] = i3;
00248       indices[4] = i4;
00249       \textcolor{keywordflow}{return} coeff(indices);
00250     \}
00251     EIGEN\_DEVICE\_FUNC
00252     EIGEN\_STRONG\_INLINE Scalar& coeffRef(Index i0, Index i1)
00253     \{
00254       array<Index, 2> indices;
00255       indices[0] = i0;
00256       indices[1] = i1;
00257       \textcolor{keywordflow}{return} coeffRef(indices);
00258     \}
00259     EIGEN\_DEVICE\_FUNC
00260     EIGEN\_STRONG\_INLINE Scalar& coeffRef(Index i0, Index i1, Index i2)
00261     \{
00262       array<Index, 3> indices;
00263       indices[0] = i0;
00264       indices[1] = i1;
00265       indices[2] = i2;
00266       \textcolor{keywordflow}{return} coeffRef(indices);
00267     \}
00268     EIGEN\_DEVICE\_FUNC
00269     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3)
00270     \{
00271       array<Index, 4> indices;
00272       indices[0] = i0;
00273       indices[1] = i1;
00274       indices[2] = i2;
00275       indices[3] = i3;
00276       \textcolor{keywordflow}{return} coeffRef(indices);
00277     \}
00278     EIGEN\_DEVICE\_FUNC
00279     EIGEN\_STRONG\_INLINE Scalar& coeffRef(Index i0, Index i1, Index i2, Index i3, Index i4)
00280     \{
00281       array<Index, 5> indices;
00282       indices[0] = i0;
00283       indices[1] = i1;
00284       indices[2] = i2;
00285       indices[3] = i3;
00286       indices[4] = i4;
00287       \textcolor{keywordflow}{return} coeffRef(indices);
00288     \}
00289 \textcolor{preprocessor}{#endif}
00290 
00291     \textcolor{keyword}{template} <std::\textcolor{keywordtype}{size\_t} NumIndices> EIGEN\_DEVICE\_FUNC
00292     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar coeff(\textcolor{keyword}{const} array<Index, NumIndices>& indices)\textcolor{keyword}{ const}
00293 \textcolor{keyword}{    }\{
00294       \textcolor{keyword}{const} Dimensions& dims = this->dimensions();
00295       Index index = 0;
00296       \textcolor{keywordflow}{if} (PlainObjectType::Options & \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) \{
00297         index += indices[0];
00298         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 1; i < NumIndices; ++i) \{
00299           index = index * dims[i] + indices[i];
00300         \}
00301       \} \textcolor{keywordflow}{else} \{
00302         index += indices[NumIndices-1];
00303         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumIndices-2; i >= 0; --i) \{
00304           index = index * dims[i] + indices[i];
00305         \}
00306       \}
00307       \textcolor{keywordflow}{return} m\_evaluator->coeff(index);
00308     \}
00309     \textcolor{keyword}{template} <std::\textcolor{keywordtype}{size\_t} NumIndices> EIGEN\_DEVICE\_FUNC
00310     EIGEN\_STRONG\_INLINE Scalar& coeffRef(\textcolor{keyword}{const} array<Index, NumIndices>& indices)
00311     \{
00312       \textcolor{keyword}{const} Dimensions& dims = this->dimensions();
00313       Index index = 0;
00314       \textcolor{keywordflow}{if} (PlainObjectType::Options & RowMajor) \{
00315         index += indices[0];
00316         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 1; i < NumIndices; ++i) \{
00317           index = index * dims[i] + indices[i];
00318         \}
00319       \} \textcolor{keywordflow}{else} \{
00320         index += indices[NumIndices-1];
00321         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumIndices-2; i >= 0; --i) \{
00322           index = index * dims[i] + indices[i];
00323         \}
00324       \}
00325       \textcolor{keywordflow}{return} m\_evaluator->coeffRef(index);
00326     \}
00327 
00328     EIGEN\_DEVICE\_FUNC
00329     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar coeff(Index index)\textcolor{keyword}{ const}
00330 \textcolor{keyword}{    }\{
00331       \textcolor{keywordflow}{return} m\_evaluator->coeff(index);
00332     \}
00333 
00334     EIGEN\_DEVICE\_FUNC
00335     EIGEN\_STRONG\_INLINE Scalar& coeffRef(Index index)
00336     \{
00337       \textcolor{keywordflow}{return} m\_evaluator->coeffRef(index);
00338     \}
00339 
00340   \textcolor{keyword}{private}:
00341     EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} unrefEvaluator() \{
00342       \textcolor{keywordflow}{if} (m\_evaluator) \{
00343         m\_evaluator->decrRefCount();
00344         \textcolor{keywordflow}{if} (m\_evaluator->refCount() == 0) \{
00345           \textcolor{keyword}{delete} m\_evaluator;
00346         \}
00347       \}
00348     \}
00349 
00350   internal::TensorLazyBaseEvaluator<Dimensions, Scalar>* m\_evaluator;
00351 \};
00352 
00353 
00354 \textcolor{comment}{// evaluator for rvalues}
00355 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} Device>
00356 \textcolor{keyword}{struct }TensorEvaluator<const TensorRef<Derived>, Device>
00357 \{
00358   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00359   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00360   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar CoeffReturnType;
00361   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00362   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Dimensions Dimensions;
00363 
00364   \textcolor{keyword}{enum} \{
00365     IsAligned = \textcolor{keyword}{false},
00366     PacketAccess = \textcolor{keyword}{false},
00367     Layout = TensorRef<Derived>::Layout,
00368     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00369     RawAccess = \textcolor{keyword}{false}
00370   \};
00371 
00372   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} TensorRef<Derived>& m, \textcolor{keyword}{const} Device&)
00373       : m\_ref(m)
00374   \{ \}
00375 
00376   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_ref.dimensions(); \}
00377 
00378   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar*) \{
00379     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00380   \}
00381 
00382   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{ \}
00383 
00384   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const }\{
00385     \textcolor{keywordflow}{return} m\_ref.coeff(index);
00386   \}
00387 
00388   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& coeffRef(Index index) \{
00389     \textcolor{keywordflow}{return} m\_ref.coeffRef(index);
00390   \}
00391 
00392   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_ref.data(); \}
00393 
00394  \textcolor{keyword}{protected}:
00395   TensorRef<Derived> m\_ref;
00396 \};
00397 
00398 
00399 \textcolor{comment}{// evaluator for lvalues}
00400 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} Device>
00401 \textcolor{keyword}{struct }TensorEvaluator<TensorRef<Derived>, Device> : \textcolor{keyword}{public} TensorEvaluator<const TensorRef<Derived>, Devic
      e>
00402 \{
00403   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00404   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00405   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar CoeffReturnType;
00406   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00407   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Dimensions Dimensions;
00408 
00409   \textcolor{keyword}{typedef} TensorEvaluator<const TensorRef<Derived>, Device> Base;
00410 
00411   \textcolor{keyword}{enum} \{
00412     IsAligned = \textcolor{keyword}{false},
00413     PacketAccess = \textcolor{keyword}{false},
00414     RawAccess = \textcolor{keyword}{false}
00415   \};
00416 
00417   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(TensorRef<Derived>& m, \textcolor{keyword}{const} Device& d) : Base(m, d
      )
00418   \{ \}
00419 
00420   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& coeffRef(Index index) \{
00421     \textcolor{keywordflow}{return} this->m\_ref.coeffRef(index);
00422   \}
00423 \};
00424 
00425 
00426 
00427 \} \textcolor{comment}{// end namespace Eigen}
00428 
00429 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_REF\_H}
\end{DoxyCode}
