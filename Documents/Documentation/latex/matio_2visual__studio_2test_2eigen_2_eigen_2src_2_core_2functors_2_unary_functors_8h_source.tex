\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2functors_2_unary_functors_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/functors/\+Unary\+Functors.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2functors_2_unary_functors_8h_source}\index{Unary\+Functors.\+h@{Unary\+Functors.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2016 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_UNARY\_FUNCTORS\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_UNARY\_FUNCTORS\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_opposite\_op \{
00023   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_opposite\_op)
00024   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} -a; \}
00025   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00026   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const}
00027 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pnegate(a); \}
00028 \};
00029 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00030 \textcolor{keyword}{struct }functor\_traits<scalar\_opposite\_op<Scalar> >
00031 \{ \textcolor{keyword}{enum} \{
00032     Cost = NumTraits<Scalar>::AddCost,
00033     PacketAccess = packet\_traits<Scalar>::HasNegate \};
00034 \};
00035 
00041 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_abs\_op \{
00042   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_abs\_op)
00043   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real result\_type;
00044   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 
      numext::abs(a); \}
00045   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00046   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const}
00047 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pabs(a); \}
00048 \};
00049 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00050 \textcolor{keyword}{struct }functor\_traits<scalar\_abs\_op<Scalar> >
00051 \{
00052   \textcolor{keyword}{enum} \{
00053     Cost = NumTraits<Scalar>::AddCost,
00054     PacketAccess = packet\_traits<Scalar>::HasAbs
00055   \};
00056 \};
00057 
00063 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_score\_coeff\_op : scalar\_abs\_op<Scalar>
00064 \{
00065   \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} Score\_is\_abs;
00066 \};
00067 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00068 \textcolor{keyword}{struct }functor\_traits<scalar\_score\_coeff\_op<Scalar> > : functor\_traits<scalar\_abs\_op<Scalar> > \{\};
00069 
00070 \textcolor{comment}{/* Avoid recomputing abs when we know the score and they are the same. Not a true Eigen functor.  */}
00071 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename}=\textcolor{keywordtype}{void}> \textcolor{keyword}{struct }abs\_knowing\_score
00072 \{
00073   EIGEN\_EMPTY\_STRUCT\_CTOR(abs\_knowing\_score)
00074   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real result\_type;
00075   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Score>
00076   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} Scalar& a, \textcolor{keyword}{const} Score&)\textcolor{keyword}{ const }
      \{ \textcolor{keywordflow}{return} numext::abs(a); \}
00077 \};
00078 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }abs\_knowing\_score<Scalar, typename scalar\_score\_coeff\_op<Scalar>::
      Score\_is\_abs>
00079 \{
00080   EIGEN\_EMPTY\_STRUCT\_CTOR(abs\_knowing\_score)
00081   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real result\_type;
00082   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scal>
00083   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} Scal&, \textcolor{keyword}{const} result\_type& a)\textcolor{keyword}{
       const }\{ \textcolor{keywordflow}{return} a; \}
00084 \};
00085 
00091 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_abs2\_op \{
00092   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_abs2\_op)
00093   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real result\_type;
00094   EIGEN\_DEVICE\_FUNC
00095   EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::abs2(a); \}
00096   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00097   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const}
00098 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pmul(a,a); \}
00099 \};
00100 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00101 \textcolor{keyword}{struct }functor\_traits<scalar\_abs2\_op<Scalar> >
00102 \{ \textcolor{keyword}{enum} \{ Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet\_traits<Scalar>::HasAbs2 \}; \};
00103 
00109 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_conjugate\_op \{
00110   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_conjugate\_op)
00111   EIGEN\_DEVICE\_FUNC
00112   EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keyword}{using} numext::conj; \textcolor{keywordflow}{return} conj(a);
       \}
00113   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00114   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 
      internal::pconj(a); \}
00115 \};
00116 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00117 \textcolor{keyword}{struct }functor\_traits<scalar\_conjugate\_op<Scalar> >
00118 \{
00119   \textcolor{keyword}{enum} \{
00120     Cost = NumTraits<Scalar>::IsComplex ? NumTraits<Scalar>::AddCost : 0,
00121     PacketAccess = packet\_traits<Scalar>::HasConj
00122   \};
00123 \};
00124 
00130 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_arg\_op \{
00131   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_arg\_op)
00132   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real result\_type;
00133   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} result\_type operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keyword}{using} 
      numext::arg; \textcolor{keywordflow}{return} arg(a); \}
00134   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00135   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const}
00136 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::parg(a); \}
00137 \};
00138 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00139 \textcolor{keyword}{struct }functor\_traits<scalar\_arg\_op<Scalar> >
00140 \{
00141   \textcolor{keyword}{enum} \{
00142     Cost = NumTraits<Scalar>::IsComplex ? 5 * NumTraits<Scalar>::MulCost : NumTraits<Scalar>::AddCost,
00143     PacketAccess = packet\_traits<Scalar>::HasArg
00144   \};
00145 \};
00151 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} NewType>
00152 \textcolor{keyword}{struct }scalar\_cast\_op \{
00153   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_cast\_op)
00154   \textcolor{keyword}{typedef} NewType result\_type;
00155   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} NewType operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 
      cast<Scalar, NewType>(a); \}
00156 \};
00157 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} NewType>
00158 \textcolor{keyword}{struct }functor\_traits<scalar\_cast\_op<Scalar,NewType> >
00159 \{ \textcolor{keyword}{enum} \{ Cost = is\_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = \textcolor{keyword}{false} \}; 
      \};
00160 
00166 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00167 \textcolor{keyword}{struct }scalar\_real\_op \{
00168   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_real\_op)
00169   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real result\_type;
00170   EIGEN\_DEVICE\_FUNC
00171   EIGEN\_STRONG\_INLINE result\_type operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::real(a); \}
00172 \};
00173 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00174 \textcolor{keyword}{struct }functor\_traits<scalar\_real\_op<Scalar> >
00175 \{ \textcolor{keyword}{enum} \{ Cost = 0, PacketAccess = \textcolor{keyword}{false} \}; \};
00176 
00182 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00183 \textcolor{keyword}{struct }scalar\_imag\_op \{
00184   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_imag\_op)
00185   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real result\_type;
00186   EIGEN\_DEVICE\_FUNC
00187   EIGEN\_STRONG\_INLINE result\_type operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::imag(a); \}
00188 \};
00189 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00190 \textcolor{keyword}{struct }functor\_traits<scalar\_imag\_op<Scalar> >
00191 \{ \textcolor{keyword}{enum} \{ Cost = 0, PacketAccess = \textcolor{keyword}{false} \}; \};
00192 
00198 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00199 \textcolor{keyword}{struct }scalar\_real\_ref\_op \{
00200   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_real\_ref\_op)
00201   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real result\_type;
00202   EIGEN\_DEVICE\_FUNC
00203   EIGEN\_STRONG\_INLINE result\_type& operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::real\_ref(*
      const\_cast<Scalar*>(&a)); \}
00204 \};
00205 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00206 \textcolor{keyword}{struct }functor\_traits<scalar\_real\_ref\_op<Scalar> >
00207 \{ \textcolor{keyword}{enum} \{ Cost = 0, PacketAccess = \textcolor{keyword}{false} \}; \};
00208 
00214 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00215 \textcolor{keyword}{struct }scalar\_imag\_ref\_op \{
00216   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_imag\_ref\_op)
00217   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real result\_type;
00218   EIGEN\_DEVICE\_FUNC
00219   EIGEN\_STRONG\_INLINE result\_type& operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::imag\_ref(*
      const\_cast<Scalar*>(&a)); \}
00220 \};
00221 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00222 \textcolor{keyword}{struct }functor\_traits<scalar\_imag\_ref\_op<Scalar> >
00223 \{ \textcolor{keyword}{enum} \{ Cost = 0, PacketAccess = \textcolor{keyword}{false} \}; \};
00224 
00231 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_exp\_op \{
00232   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_exp\_op)
00233   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::exp(a); \}
00234   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00235   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::pexp(a); \}
00236 \};
00237 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00238 \textcolor{keyword}{struct }functor\_traits<scalar\_exp\_op<Scalar> > \{
00239   \textcolor{keyword}{enum} \{
00240     PacketAccess = packet\_traits<Scalar>::HasExp,
00241     \textcolor{comment}{// The following numbers are based on the AVX implementation.}
00242 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_FMA}
00243     \textcolor{comment}{// Haswell can issue 2 add/mul/madd per cycle.}
00244     Cost =
00245     (\textcolor{keyword}{sizeof}(Scalar) == 4
00246      \textcolor{comment}{// float: 8 pmadd, 4 pmul, 2 padd/psub, 6 other}
00247      ? (8 * NumTraits<Scalar>::AddCost + 6 * NumTraits<Scalar>::MulCost)
00248      \textcolor{comment}{// double: 7 pmadd, 5 pmul, 3 padd/psub, 1 div,  13 other}
00249      : (14 * NumTraits<Scalar>::AddCost +
00250         6 * NumTraits<Scalar>::MulCost +
00251         scalar\_div\_cost<Scalar,packet\_traits<Scalar>::HasDiv>::value))
00252 \textcolor{preprocessor}{#else}
00253     Cost =
00254     (\textcolor{keyword}{sizeof}(Scalar) == 4
00255      \textcolor{comment}{// float: 7 pmadd, 6 pmul, 4 padd/psub, 10 other}
00256      ? (21 * NumTraits<Scalar>::AddCost + 13 * NumTraits<Scalar>::MulCost)
00257      \textcolor{comment}{// double: 7 pmadd, 5 pmul, 3 padd/psub, 1 div,  13 other}
00258      : (23 * NumTraits<Scalar>::AddCost +
00259         12 * NumTraits<Scalar>::MulCost +
00260         scalar\_div\_cost<Scalar,packet\_traits<Scalar>::HasDiv>::value))
00261 \textcolor{preprocessor}{#endif}
00262   \};
00263 \};
00264 
00271 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_log\_op \{
00272   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_log\_op)
00273   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::log(a); \}
00274   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00275   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::plog(a); \}
00276 \};
00277 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00278 \textcolor{keyword}{struct }functor\_traits<scalar\_log\_op<Scalar> > \{
00279   \textcolor{keyword}{enum} \{
00280     PacketAccess = packet\_traits<Scalar>::HasLog,
00281     Cost =
00282     (PacketAccess
00283      \textcolor{comment}{// The following numbers are based on the AVX implementation.}
00284 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_FMA}
00285      \textcolor{comment}{// 8 pmadd, 6 pmul, 8 padd/psub, 16 other, can issue 2 add/mul/madd per cycle.}
00286      ? (20 * NumTraits<Scalar>::AddCost + 7 * NumTraits<Scalar>::MulCost)
00287 #\textcolor{keywordflow}{else}
00288      \textcolor{comment}{// 8 pmadd, 6 pmul, 8 padd/psub, 20 other}
00289      ? (36 * NumTraits<Scalar>::AddCost + 14 * NumTraits<Scalar>::MulCost)
00290 \textcolor{preprocessor}{#endif}
00291      \textcolor{comment}{// Measured cost of std::log.}
00292      : \textcolor{keyword}{sizeof}(Scalar)==4 ? 40 : 85)
00293   \};
00294 \};
00295 
00302 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_log1p\_op \{
00303   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_log1p\_op)
00304   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::log1p(a); \}
00305   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00306   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::plog1p(a); \}
00307 \};
00308 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00309 \textcolor{keyword}{struct }functor\_traits<scalar\_log1p\_op<Scalar> > \{
00310   \textcolor{keyword}{enum} \{
00311     PacketAccess = packet\_traits<Scalar>::HasLog1p,
00312     Cost = functor\_traits<scalar\_log\_op<Scalar> >::Cost \textcolor{comment}{// TODO measure cost of log1p}
00313   \};
00314 \};
00315 
00322 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_log10\_op \{
00323   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_log10\_op)
00324   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ EIGEN\_USING\_STD\_MATH(log10) \textcolor{keywordflow}{
      return} log10(a); \}
00325   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00326   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::plog10(a); \}
00327 \};
00328 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00329 \textcolor{keyword}{struct }functor\_traits<scalar\_log10\_op<Scalar> >
00330 \{ \textcolor{keyword}{enum} \{ Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet\_traits<Scalar>::HasLog10 \}; \};
00331 
00336 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_sqrt\_op \{
00337   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_sqrt\_op)
00338   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::sqrt(a); \}
00339   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00340   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::psqrt(a); \}
00341 \};
00342 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00343 \textcolor{keyword}{struct }functor\_traits<scalar\_sqrt\_op<Scalar> > \{
00344   \textcolor{keyword}{enum} \{
00345 \textcolor{preprocessor}{#if EIGEN\_FAST\_MATH}
00346     \textcolor{comment}{// The following numbers are based on the AVX implementation.}
00347     Cost = (\textcolor{keyword}{sizeof}(Scalar) == 8 ? 28
00348                                 \textcolor{comment}{// 4 pmul, 1 pmadd, 3 other}
00349                                 : (3 * NumTraits<Scalar>::AddCost +
00350                                    5 * NumTraits<Scalar>::MulCost)),
00351 #\textcolor{keywordflow}{else}
00352     \textcolor{comment}{// The following numbers are based on min VSQRT throughput on Haswell.}
00353     Cost = (\textcolor{keyword}{sizeof}(Scalar) == 8 ? 28 : 14),
00354 #endif
00355     PacketAccess = packet\_traits<Scalar>::HasSqrt
00356   \};
00357 \};
00358 
00363 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_rsqrt\_op \{
00364   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_rsqrt\_op)
00365   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} Scalar(1)/numext::sqrt(
      a); \}
00366   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00367   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::prsqrt(a); \}
00368 \};
00369 
00370 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00371 \textcolor{keyword}{struct }functor\_traits<scalar\_rsqrt\_op<Scalar> >
00372 \{ \textcolor{keyword}{enum} \{
00373     Cost = 5 * NumTraits<Scalar>::MulCost,
00374     PacketAccess = packet\_traits<Scalar>::HasRsqrt
00375   \};
00376 \};
00377 
00382 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_cos\_op \{
00383   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_cos\_op)
00384   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::cos(a); \}
00385   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00386   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::pcos(a); \}
00387 \};
00388 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00389 \textcolor{keyword}{struct }functor\_traits<scalar\_cos\_op<Scalar> >
00390 \{
00391   \textcolor{keyword}{enum} \{
00392     Cost = 5 * NumTraits<Scalar>::MulCost,
00393     PacketAccess = packet\_traits<Scalar>::HasCos
00394   \};
00395 \};
00396 
00401 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_sin\_op \{
00402   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_sin\_op)
00403   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::sin(a); \}
00404   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00405   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::psin(a); \}
00406 \};
00407 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00408 \textcolor{keyword}{struct }functor\_traits<scalar\_sin\_op<Scalar> >
00409 \{
00410   \textcolor{keyword}{enum} \{
00411     Cost = 5 * NumTraits<Scalar>::MulCost,
00412     PacketAccess = packet\_traits<Scalar>::HasSin
00413   \};
00414 \};
00415 
00416 
00421 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_tan\_op \{
00422   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_tan\_op)
00423   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::tan(a); \}
00424   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00425   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::ptan(a); \}
00426 \};
00427 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00428 \textcolor{keyword}{struct }functor\_traits<scalar\_tan\_op<Scalar> >
00429 \{
00430   \textcolor{keyword}{enum} \{
00431     Cost = 5 * NumTraits<Scalar>::MulCost,
00432     PacketAccess = packet\_traits<Scalar>::HasTan
00433   \};
00434 \};
00435 
00440 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_acos\_op \{
00441   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_acos\_op)
00442   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::acos(a); \}
00443   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00444   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::pacos(a); \}
00445 \};
00446 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00447 \textcolor{keyword}{struct }functor\_traits<scalar\_acos\_op<Scalar> >
00448 \{
00449   \textcolor{keyword}{enum} \{
00450     Cost = 5 * NumTraits<Scalar>::MulCost,
00451     PacketAccess = packet\_traits<Scalar>::HasACos
00452   \};
00453 \};
00454 
00459 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_asin\_op \{
00460   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_asin\_op)
00461   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::asin(a); \}
00462   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00463   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::pasin(a); \}
00464 \};
00465 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00466 \textcolor{keyword}{struct }functor\_traits<scalar\_asin\_op<Scalar> >
00467 \{
00468   \textcolor{keyword}{enum} \{
00469     Cost = 5 * NumTraits<Scalar>::MulCost,
00470     PacketAccess = packet\_traits<Scalar>::HasASin
00471   \};
00472 \};
00473 
00474 
00479 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_atan\_op \{
00480   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_atan\_op)
00481   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::atan(a); \}
00482   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00483   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::patan(a); \}
00484 \};
00485 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00486 \textcolor{keyword}{struct }functor\_traits<scalar\_atan\_op<Scalar> >
00487 \{
00488   \textcolor{keyword}{enum} \{
00489     Cost = 5 * NumTraits<Scalar>::MulCost,
00490     PacketAccess = packet\_traits<Scalar>::HasATan
00491   \};
00492 \};
00493 
00498 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00499 \textcolor{keyword}{struct }scalar\_tanh\_op \{
00500   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_tanh\_op)
00501   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator()(\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::tanh(a); \}
00502   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00503   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& x)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} ptanh(x); \}
00504 \};
00505 
00506 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00507 \textcolor{keyword}{struct }functor\_traits<scalar\_tanh\_op<Scalar> > \{
00508   \textcolor{keyword}{enum} \{
00509     PacketAccess = packet\_traits<Scalar>::HasTanh,
00510     Cost = ( (EIGEN\_FAST\_MATH && is\_same<Scalar,float>::value)
00511 \textcolor{comment}{// The following numbers are based on the AVX implementation,}
00512 #ifdef EIGEN\_VECTORIZE\_FMA
00513                 \textcolor{comment}{// Haswell can issue 2 add/mul/madd per cycle.}
00514                 \textcolor{comment}{// 9 pmadd, 2 pmul, 1 div, 2 other}
00515                 ? (2 * NumTraits<Scalar>::AddCost +
00516                    6 * NumTraits<Scalar>::MulCost +
00517                    scalar\_div\_cost<Scalar,packet\_traits<Scalar>::HasDiv>::value)
00518 \textcolor{preprocessor}{#else}
00519                 ? (11 * NumTraits<Scalar>::AddCost +
00520                    11 * NumTraits<Scalar>::MulCost +
00521                    scalar\_div\_cost<Scalar,packet\_traits<Scalar>::HasDiv>::value)
00522 #endif
00523                 \textcolor{comment}{// This number assumes a naive implementation of tanh}
00524                 : (6 * NumTraits<Scalar>::AddCost +
00525                    3 * NumTraits<Scalar>::MulCost +
00526                    2 * scalar\_div\_cost<Scalar,packet\_traits<Scalar>::HasDiv>::value +
00527                    functor\_traits<scalar\_exp\_op<Scalar> >::Cost))
00528   \};
00529 \};
00530 
00535 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_sinh\_op \{
00536   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_sinh\_op)
00537   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::sinh(a); \}
00538   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00539   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::psinh(a); \}
00540 \};
00541 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00542 \textcolor{keyword}{struct }functor\_traits<scalar\_sinh\_op<Scalar> >
00543 \{
00544   \textcolor{keyword}{enum} \{
00545     Cost = 5 * NumTraits<Scalar>::MulCost,
00546     PacketAccess = packet\_traits<Scalar>::HasSinh
00547   \};
00548 \};
00549 
00554 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_cosh\_op \{
00555   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_cosh\_op)
00556   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::cosh(a); \}
00557   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00558   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::pcosh(a); \}
00559 \};
00560 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00561 \textcolor{keyword}{struct }functor\_traits<scalar\_cosh\_op<Scalar> >
00562 \{
00563   \textcolor{keyword}{enum} \{
00564     Cost = 5 * NumTraits<Scalar>::MulCost,
00565     PacketAccess = packet\_traits<Scalar>::HasCosh
00566   \};
00567 \};
00568 
00573 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00574 \textcolor{keyword}{struct }scalar\_inverse\_op \{
00575   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_inverse\_op)
00576   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} Scalar(1)/a; \}
00577   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00578   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const}
00579 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pdiv(pset1<Packet>(Scalar(1)),a); \}
00580 \};
00581 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00582 \textcolor{keyword}{struct }functor\_traits<scalar\_inverse\_op<Scalar> >
00583 \{ \textcolor{keyword}{enum} \{ Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet\_traits<Scalar>::HasDiv \}; \};
00584 
00589 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00590 \textcolor{keyword}{struct }scalar\_square\_op \{
00591   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_square\_op)
00592   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a*a; \}
00593   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00594   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const}
00595 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pmul(a,a); \}
00596 \};
00597 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00598 \textcolor{keyword}{struct }functor\_traits<scalar\_square\_op<Scalar> >
00599 \{ \textcolor{keyword}{enum} \{ Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet\_traits<Scalar>::HasMul \}; \};
00600 
00605 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00606 \textcolor{keyword}{struct }scalar\_cube\_op \{
00607   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_cube\_op)
00608   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a*a*a; \}
00609   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00610   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const}
00611 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::pmul(a,pmul(a,a)); \}
00612 \};
00613 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00614 \textcolor{keyword}{struct }functor\_traits<scalar\_cube\_op<Scalar> >
00615 \{ \textcolor{keyword}{enum} \{ Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet\_traits<Scalar>::HasMul \}; \};
00616 
00621 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_round\_op \{
00622   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_round\_op)
00623   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 
      numext::round(a); \}
00624   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00625   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::pround(a); \}
00626 \};
00627 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00628 \textcolor{keyword}{struct }functor\_traits<scalar\_round\_op<Scalar> >
00629 \{
00630   \textcolor{keyword}{enum} \{
00631     Cost = NumTraits<Scalar>::MulCost,
00632     PacketAccess = packet\_traits<Scalar>::HasRound
00633   \};
00634 \};
00635 
00640 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_floor\_op \{
00641   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_floor\_op)
00642   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 
      numext::floor(a); \}
00643   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00644   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::pfloor(a); \}
00645 \};
00646 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00647 \textcolor{keyword}{struct }functor\_traits<scalar\_floor\_op<Scalar> >
00648 \{
00649   \textcolor{keyword}{enum} \{
00650     Cost = NumTraits<Scalar>::MulCost,
00651     PacketAccess = packet\_traits<Scalar>::HasFloor
00652   \};
00653 \};
00654 
00659 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_ceil\_op \{
00660   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_ceil\_op)
00661   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 
      numext::ceil(a); \}
00662   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00663   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet packetOp(\textcolor{keyword}{const} Packet& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::pceil(a); \}
00664 \};
00665 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00666 \textcolor{keyword}{struct }functor\_traits<scalar\_ceil\_op<Scalar> >
00667 \{
00668   \textcolor{keyword}{enum} \{
00669     Cost = NumTraits<Scalar>::MulCost,
00670     PacketAccess = packet\_traits<Scalar>::HasCeil
00671   \};
00672 \};
00673 
00678 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_isnan\_op \{
00679   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_isnan\_op)
00680   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00681   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE result\_type operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} (
      numext::isnan)(a); \}
00682 \};
00683 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00684 \textcolor{keyword}{struct }functor\_traits<scalar\_isnan\_op<Scalar> >
00685 \{
00686   \textcolor{keyword}{enum} \{
00687     Cost = NumTraits<Scalar>::MulCost,
00688     PacketAccess = \textcolor{keyword}{false}
00689   \};
00690 \};
00691 
00696 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_isinf\_op \{
00697   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_isinf\_op)
00698   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00699   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE result\_type operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} (
      numext::isinf)(a); \}
00700 \};
00701 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00702 \textcolor{keyword}{struct }functor\_traits<scalar\_isinf\_op<Scalar> >
00703 \{
00704   \textcolor{keyword}{enum} \{
00705     Cost = NumTraits<Scalar>::MulCost,
00706     PacketAccess = \textcolor{keyword}{false}
00707   \};
00708 \};
00709 
00714 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_isfinite\_op \{
00715   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_isfinite\_op)
00716   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} result\_type;
00717   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE result\_type operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} (
      numext::isfinite)(a); \}
00718 \};
00719 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00720 \textcolor{keyword}{struct }functor\_traits<scalar\_isfinite\_op<Scalar> >
00721 \{
00722   \textcolor{keyword}{enum} \{
00723     Cost = NumTraits<Scalar>::MulCost,
00724     PacketAccess = \textcolor{keyword}{false}
00725   \};
00726 \};
00727 
00733 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_boolean\_not\_op \{
00734   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_boolean\_not\_op)
00735   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} operator() (\textcolor{keyword}{const} \textcolor{keywordtype}{bool}& a)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} !a; \}
00736 \};
00737 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00738 \textcolor{keyword}{struct }functor\_traits<scalar\_boolean\_not\_op<Scalar> > \{
00739   \textcolor{keyword}{enum} \{
00740     Cost = NumTraits<bool>::AddCost,
00741     PacketAccess = \textcolor{keyword}{false}
00742   \};
00743 \};
00744 
00749 template<typename Scalar,bool iscpx=(NumTraits<Scalar>::IsComplex!=0) > \textcolor{keyword}{struct} scalar\_sign\_op;
00750 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00751 \textcolor{keyword}{struct }scalar\_sign\_op<Scalar,false> \{
00752   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_sign\_op)
00753   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const}
00754 \textcolor{keyword}{  }\{
00755       \textcolor{keywordflow}{return} Scalar( (a>Scalar(0)) - (a<Scalar(0)) );
00756   \}
00757   \textcolor{comment}{//TODO}
00758   \textcolor{comment}{//template <typename Packet>}
00759   \textcolor{comment}{//EIGEN\_DEVICE\_FUNC inline Packet packetOp(const Packet& a) const \{ return internal::psign(a); \}}
00760 \};
00761 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00762 \textcolor{keyword}{struct }scalar\_sign\_op<Scalar,true> \{
00763   EIGEN\_EMPTY\_STRUCT\_CTOR(scalar\_sign\_op)
00764   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar& a)\textcolor{keyword}{ const}
00765 \textcolor{keyword}{  }\{
00766     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real real\_type;
00767     real\_type aa = numext::abs(a);
00768     \textcolor{keywordflow}{if} (aa==real\_type(0))
00769       \textcolor{keywordflow}{return} Scalar(0);
00770     aa = real\_type(1)/aa;
00771     \textcolor{keywordflow}{return} Scalar(real(a)*aa, imag(a)*aa );
00772   \}
00773   \textcolor{comment}{//TODO}
00774   \textcolor{comment}{//template <typename Packet>}
00775   \textcolor{comment}{//EIGEN\_DEVICE\_FUNC inline Packet packetOp(const Packet& a) const \{ return internal::psign(a); \}}
00776 \};
00777 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00778 \textcolor{keyword}{struct }functor\_traits<scalar\_sign\_op<Scalar> >
00779 \{ \textcolor{keyword}{enum} \{
00780     Cost = 
00781         NumTraits<Scalar>::IsComplex
00782         ? ( 8*NumTraits<Scalar>::MulCost  ) \textcolor{comment}{// roughly}
00783         : ( 3*NumTraits<Scalar>::AddCost),
00784     PacketAccess = packet\_traits<Scalar>::HasSign
00785   \};
00786 \};
00787 
00788 \} \textcolor{comment}{// end namespace internal}
00789 
00790 \} \textcolor{comment}{// end namespace Eigen}
00791 
00792 \textcolor{preprocessor}{#endif // EIGEN\_FUNCTORS\_H}
\end{DoxyCode}
