\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_traits_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Traits.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_traits_8h_source}\index{Tensor\+Traits.\+h@{Tensor\+Traits.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_TRAITS\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_TRAITS\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00015 
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Options>
00018 \textcolor{keyword}{class }compute\_tensor\_flags
00019 \{
00020   \textcolor{keyword}{enum} \{
00021     is\_dynamic\_size\_storage = 1,
00022 
00023     is\_aligned =
00024     (
00025         ((Options&\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a40a452614141522dd313363dbbd65726}{DontAlign})==0) && (
00026 \textcolor{preprocessor}{#if EIGEN\_MAX\_STATIC\_ALIGN\_BYTES>0}
00027             (!is\_dynamic\_size\_storage)
00028 #\textcolor{keywordflow}{else}
00029             0
00030 #endif
00031             |
00032 #\textcolor{keywordflow}{if} EIGEN\_MAX\_ALIGN\_BYTES>0
00033             is\_dynamic\_size\_storage
00034 #\textcolor{keywordflow}{else}
00035             0
00036 #endif
00037       )
00038      ),
00039     packet\_access\_bit = packet\_traits<Scalar>::Vectorizable && is\_aligned ? 
      \hyperlink{group__flags_ga1a306a438e1ab074e8be59512e887b9f}{PacketAccessBit} : 0
00040   \};
00041 
00042   \textcolor{keyword}{public}:
00043     \textcolor{keyword}{enum} \{ ret = packet\_access\_bit \};
00044 \};
00045 
00046 
00047 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_, \textcolor{keywordtype}{int} NumIndices\_, \textcolor{keywordtype}{int} Options\_, \textcolor{keyword}{typename} IndexType\_>
00048 \textcolor{keyword}{struct }traits<Tensor<Scalar\_, NumIndices\_, Options\_, IndexType\_> >
00049 \{
00050   \textcolor{keyword}{typedef} Scalar\_ Scalar;
00051   \textcolor{keyword}{typedef} Dense StorageKind;
00052   \textcolor{keyword}{typedef} IndexType\_ \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00053   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = NumIndices\_;
00054   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = Options\_ & \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor};
00055   \textcolor{keyword}{enum} \{
00056     Options = Options\_,
00057     Flags = compute\_tensor\_flags<Scalar\_, Options\_>::ret | (is\_const<Scalar\_>::value ? 0 : 
      \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit})
00058   \};
00059   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }MakePointer \{
00060     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* Type;
00061   \};
00062 \};
00063 
00064 
00065 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_, \textcolor{keyword}{typename} Dimensions, \textcolor{keywordtype}{int} Options\_, \textcolor{keyword}{typename} IndexType\_>
00066 \textcolor{keyword}{struct }traits<TensorFixedSize<Scalar\_, Dimensions, Options\_, IndexType\_> >
00067 \{
00068   \textcolor{keyword}{typedef} Scalar\_ Scalar;
00069   \textcolor{keyword}{typedef} Dense StorageKind;
00070   \textcolor{keyword}{typedef} IndexType\_ \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00071   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = array\_size<Dimensions>::value;
00072   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = Options\_ & \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor};
00073   \textcolor{keyword}{enum} \{
00074     Options = Options\_,
00075     Flags = compute\_tensor\_flags<Scalar\_, Options\_>::ret | (is\_const<Scalar\_>::value ? 0: 
      \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit})
00076   \};
00077   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }MakePointer \{
00078     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* Type;
00079   \};
00080 \};
00081 
00082 
00083 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType, \textcolor{keywordtype}{int} Options\_, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
00084 \textcolor{keyword}{struct }traits<TensorMap<PlainObjectType, Options\_, MakePointer\_> >
00085   : \textcolor{keyword}{public} traits<PlainObjectType>
00086 \{
00087   \textcolor{keyword}{typedef} traits<PlainObjectType> BaseTraits;
00088   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BaseTraits::Scalar Scalar;
00089   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BaseTraits::StorageKind StorageKind;
00090   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BaseTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00091   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = BaseTraits::NumDimensions;
00092   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = BaseTraits::Layout;
00093   \textcolor{keyword}{enum} \{
00094     Options = Options\_,
00095     Flags = BaseTraits::Flags
00096   \};
00097   \textcolor{keyword}{template} <\textcolor{keyword}{class} T> \textcolor{keyword}{struct }MakePointer \{
00098     \textcolor{comment}{// Intermediate typedef to workaround MSVC issue.}
00099     \textcolor{keyword}{typedef} MakePointer\_<T> MakePointerT;
00100     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MakePointerT::Type Type;
00101   \};
00102 \};
00103 
00104 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType>
00105 \textcolor{keyword}{struct }traits<TensorRef<PlainObjectType> >
00106   : \textcolor{keyword}{public} traits<PlainObjectType>
00107 \{
00108   \textcolor{keyword}{typedef} traits<PlainObjectType> BaseTraits;
00109   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BaseTraits::Scalar Scalar;
00110   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BaseTraits::StorageKind StorageKind;
00111   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BaseTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00112   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = BaseTraits::NumDimensions;
00113   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = BaseTraits::Layout;
00114   \textcolor{keyword}{enum} \{
00115     Options = BaseTraits::Options,
00116     Flags = BaseTraits::Flags
00117   \};
00118 \};
00119 
00120 
00121 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} NumIndices\_, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{typename} IndexType\_>
00122 \textcolor{keyword}{struct }eval<Tensor<\_Scalar, NumIndices\_, Options, IndexType\_>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00123 \{
00124   \textcolor{keyword}{typedef} \textcolor{keyword}{const} Tensor<\_Scalar, NumIndices\_, Options, IndexType\_>& type;
00125 \};
00126 
00127 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} NumIndices\_, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{typename} IndexType\_>
00128 \textcolor{keyword}{struct }eval<const Tensor<\_Scalar, NumIndices\_, Options, IndexType\_>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00129 \{
00130   \textcolor{keyword}{typedef} \textcolor{keyword}{const} Tensor<\_Scalar, NumIndices\_, Options, IndexType\_>& type;
00131 \};
00132 
00133 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_, \textcolor{keyword}{typename} Dimensions, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{typename} IndexType\_>
00134 \textcolor{keyword}{struct }eval<TensorFixedSize<Scalar\_, Dimensions, Options, IndexType\_>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00135 \{
00136   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorFixedSize<Scalar\_, Dimensions, Options, IndexType\_>& type;
00137 \};
00138 
00139 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_, \textcolor{keyword}{typename} Dimensions, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{typename} IndexType\_>
00140 \textcolor{keyword}{struct }eval<const TensorFixedSize<Scalar\_, Dimensions, Options, IndexType\_>, 
      \hyperlink{namespace_eigen}{Eigen}::Dense>
00141 \{
00142   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorFixedSize<Scalar\_, Dimensions, Options, IndexType\_>& type;
00143 \};
00144 
00145 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer>
00146 \textcolor{keyword}{struct }eval<TensorMap<PlainObjectType, Options, MakePointer>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00147 \{
00148   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorMap<PlainObjectType, Options, MakePointer>& type;
00149 \};
00150 
00151 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer>
00152 \textcolor{keyword}{struct }eval<const TensorMap<PlainObjectType, Options, MakePointer>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00153 \{
00154   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorMap<PlainObjectType, Options, MakePointer>& type;
00155 \};
00156 
00157 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType>
00158 \textcolor{keyword}{struct }eval<TensorRef<PlainObjectType>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00159 \{
00160   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorRef<PlainObjectType>& type;
00161 \};
00162 
00163 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType>
00164 \textcolor{keyword}{struct }eval<const TensorRef<PlainObjectType>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00165 \{
00166   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorRef<PlainObjectType>& type;
00167 \};
00168 
00169 \textcolor{comment}{// TODO nested<> does not exist anymore in Eigen/Core, and it thus has to be removed in favor of
       ref\_selector.}
00170 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} n=1, \textcolor{keyword}{typename} PlainObject = \textcolor{keywordtype}{void}> \textcolor{keyword}{struct }nested
00171 \{
00172   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ref\_selector<T>::type type;
00173 \};
00174 
00175 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar\_, \textcolor{keywordtype}{int} NumIndices\_, \textcolor{keywordtype}{int} Options\_, \textcolor{keyword}{typename} IndexType\_>
00176 \textcolor{keyword}{struct }nested<Tensor<Scalar\_, NumIndices\_, Options\_, IndexType\_> >
00177 \{
00178   \textcolor{keyword}{typedef} \textcolor{keyword}{const} Tensor<Scalar\_, NumIndices\_, Options\_, IndexType\_>& type;
00179 \};
00180 
00181 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar\_, \textcolor{keywordtype}{int} NumIndices\_, \textcolor{keywordtype}{int} Options\_, \textcolor{keyword}{typename} IndexType\_>
00182 \textcolor{keyword}{struct }nested<const Tensor<Scalar\_, NumIndices\_, Options\_, IndexType\_> >
00183 \{
00184   \textcolor{keyword}{typedef} \textcolor{keyword}{const} Tensor<Scalar\_, NumIndices\_, Options\_, IndexType\_>& type;
00185 \};
00186 
00187 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar\_, \textcolor{keyword}{typename} Dimensions, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{typename} IndexType\_>
00188 \textcolor{keyword}{struct }nested<TensorFixedSize<Scalar\_, Dimensions, Options, IndexType\_> >
00189 \{
00190   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorFixedSize<Scalar\_, Dimensions, Options, IndexType\_>& type;
00191 \};
00192 
00193 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar\_, \textcolor{keyword}{typename} Dimensions, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{typename} IndexType\_>
00194 \textcolor{keyword}{struct }nested<const TensorFixedSize<Scalar\_, Dimensions, Options, IndexType\_> >
00195 \{
00196   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorFixedSize<Scalar\_, Dimensions, Options, IndexType\_>& type;
00197 \};
00198 
00199 
00200 \textcolor{keyword}{template} <\textcolor{keyword}{typename} PlainObjectType, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer>
00201 \textcolor{keyword}{struct }nested<TensorMap<PlainObjectType, Options, MakePointer> >
00202 \{
00203   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorMap<PlainObjectType, Options, MakePointer>& type;
00204 \};
00205 
00206 \textcolor{keyword}{template} <\textcolor{keyword}{typename} PlainObjectType, \textcolor{keywordtype}{int} Options, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer>
00207 \textcolor{keyword}{struct }nested<const TensorMap<PlainObjectType, Options, MakePointer> >
00208 \{
00209   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorMap<PlainObjectType, Options, MakePointer>& type;
00210 \};
00211 
00212 \textcolor{keyword}{template} <\textcolor{keyword}{typename} PlainObjectType>
00213 \textcolor{keyword}{struct }nested<TensorRef<PlainObjectType> >
00214 \{
00215   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorRef<PlainObjectType>& type;
00216 \};
00217 
00218 \textcolor{keyword}{template} <\textcolor{keyword}{typename} PlainObjectType>
00219 \textcolor{keyword}{struct }nested<const TensorRef<PlainObjectType> >
00220 \{
00221   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorRef<PlainObjectType>& type;
00222 \};
00223 
00224 \}  \textcolor{comment}{// end namespace internal}
00225 
00226 \textcolor{comment}{// Convolutional layers take in an input tensor of shape (D, R, C, B), or (D, C,}
00227 \textcolor{comment}{// R, B), and convolve it with a set of filters, which can also be presented as}
00228 \textcolor{comment}{// a tensor (D, K, K, M), where M is the number of filters, K is the filter}
00229 \textcolor{comment}{// size, and each 3-dimensional tensor of size (D, K, K) is a filter. For}
00230 \textcolor{comment}{// simplicity we assume that we always use square filters (which is usually the}
00231 \textcolor{comment}{// case in images), hence the two Ks in the tensor dimension.  It also takes in}
00232 \textcolor{comment}{// a few additional parameters:}
00233 \textcolor{comment}{// Stride (S): The convolution stride is the offset between locations where we}
00234 \textcolor{comment}{//             apply the filters.  A larger stride means that the output will be}
00235 \textcolor{comment}{//             spatially smaller.}
00236 \textcolor{comment}{// Padding (P): The padding we apply to the input tensor along the R and C}
00237 \textcolor{comment}{//              dimensions.  This is usually used to make sure that the spatial}
00238 \textcolor{comment}{//              dimensions of the output matches our intention.}
00239 \textcolor{comment}{//}
00240 \textcolor{comment}{// Two types of padding are often used:}
00241 \textcolor{comment}{//   SAME: The pad value is computed so that the output will have size}
00242 \textcolor{comment}{//         R/S and C/S.}
00243 \textcolor{comment}{//   VALID: no padding is carried out.}
00244 \textcolor{comment}{// When we do padding, the padded values at the padded locations are usually}
00245 \textcolor{comment}{// zero.}
00246 \textcolor{comment}{//}
00247 \textcolor{comment}{// The output dimensions for convolution, when given all the parameters above,}
00248 \textcolor{comment}{// are as follows:}
00249 \textcolor{comment}{// When Padding = SAME: the output size is (B, R', C', M), where}
00250 \textcolor{comment}{//   R' = ceil(float(R) / float(S))}
00251 \textcolor{comment}{//   C' = ceil(float(C) / float(S))}
00252 \textcolor{comment}{// where ceil is the ceiling function.  The input tensor is padded with 0 as}
00253 \textcolor{comment}{// needed.  The number of padded rows and columns are computed as:}
00254 \textcolor{comment}{//   Pr = ((R' - 1) * S + K - R) / 2}
00255 \textcolor{comment}{//   Pc = ((C' - 1) * S + K - C) / 2}
00256 \textcolor{comment}{// when the stride is 1, we have the simplified case R'=R, C'=C, Pr=Pc=(K-1)/2.}
00257 \textcolor{comment}{// This is where SAME comes from - the output has the same size as the input has.}
00258 \textcolor{comment}{// When Padding = VALID: the output size is computed as}
00259 \textcolor{comment}{//   R' = ceil(float(R - K + 1) / float(S))}
00260 \textcolor{comment}{//   C' = ceil(float(C - K + 1) / float(S))}
00261 \textcolor{comment}{// and the number of padded rows and columns are computed in the same way as in}
00262 \textcolor{comment}{// the SAME case.}
00263 \textcolor{comment}{// When the stride is 1, we have the simplified case R'=R-K+1, C'=C-K+1, Pr=0,}
00264 \textcolor{comment}{// Pc=0.}
00265 \textcolor{keyword}{typedef} \textcolor{keyword}{enum} \{
00266   PADDING\_VALID = 1,
00267   PADDING\_SAME = 2
00268 \} PaddingType;
00269 
00270 \}  \textcolor{comment}{// end namespace Eigen}
00271 
00272 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_TRAITS\_H}
\end{DoxyCode}
