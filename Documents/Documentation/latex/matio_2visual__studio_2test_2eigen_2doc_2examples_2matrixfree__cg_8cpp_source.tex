\hypertarget{matio_2visual__studio_2test_2eigen_2doc_2examples_2matrixfree__cg_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/doc/examples/matrixfree\+\_\+cg.cpp}
\label{matio_2visual__studio_2test_2eigen_2doc_2examples_2matrixfree__cg_8cpp_source}\index{matrixfree\+\_\+cg.\+cpp@{matrixfree\+\_\+cg.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#include <iostream>}
00002 \textcolor{preprocessor}{#include <Eigen/Core>}
00003 \textcolor{preprocessor}{#include <Eigen/Dense>}
00004 \textcolor{preprocessor}{#include <Eigen/IterativeLinearSolvers>}
00005 \textcolor{preprocessor}{#include <unsupported/Eigen/IterativeSolvers>}
00006 
00007 \textcolor{keyword}{class }\hyperlink{class_matrix_replacement}{MatrixReplacement};
00008 \textcolor{keyword}{using} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{Eigen::SparseMatrix};
00009 
00010 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00011 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00012   \textcolor{comment}{// MatrixReplacement looks-like a SparseMatrix, so let's inherits its traits:}
00013   \textcolor{keyword}{template}<>
00014   \textcolor{keyword}{struct }traits<\hyperlink{class_matrix_replacement}{MatrixReplacement}> :  \textcolor{keyword}{public} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits}<Eigen::SparseMatrix<double> >
00015   \{\};
00016 \}
00017 \}
00018 
00019 \textcolor{comment}{// Example of a matrix-free wrapper from a user type to Eigen's compatible type}
00020 \textcolor{comment}{// For the sake of simplicity, this example simply wrap a Eigen::SparseMatrix.}
00021 \textcolor{keyword}{class }\hyperlink{class_matrix_replacement}{MatrixReplacement} : \textcolor{keyword}{public} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{Eigen::EigenBase}<MatrixReplacement> \{
00022 \textcolor{keyword}{public}:
00023   \textcolor{comment}{// Required typedefs, constants, and method:}
00024   \textcolor{keyword}{typedef} \textcolor{keywordtype}{double} Scalar;
00025   \textcolor{keyword}{typedef} \textcolor{keywordtype}{double} RealScalar;
00026   \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} StorageIndex;
00027   \textcolor{keyword}{enum} \{
00028     ColsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Eigen::Dynamic},
00029     MaxColsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Eigen::Dynamic},
00030     IsRowMajor = \textcolor{keyword}{false}
00031   \};
00032 
00033   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} mp\_mat->rows(); \}
00034   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} mp\_mat->cols(); \}
00035 
00036   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs>
00037   \hyperlink{group___core___module_class_eigen_1_1_product}{Eigen::Product<MatrixReplacement,Rhs,Eigen::AliasFreeProduct>}
       operator*(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{Eigen::MatrixBase<Rhs>}& x)\textcolor{keyword}{ const }\{
00038     \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_product}{Eigen::Product<MatrixReplacement,Rhs,Eigen::AliasFreeProduct>}
      (*\textcolor{keyword}{this}, x.derived());
00039   \}
00040 
00041   \textcolor{comment}{// Custom API:}
00042   \hyperlink{class_matrix_replacement}{MatrixReplacement}() : mp\_mat(0) \{\}
00043 
00044   \textcolor{keywordtype}{void} attachMyMatrix(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double>} &mat) \{
00045     mp\_mat = &mat;
00046   \}
00047   \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double>} my\_matrix()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *mp\_mat; \}
00048 
00049 \textcolor{keyword}{private}:
00050   \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double>} *mp\_mat;
00051 \};
00052 
00053 
00054 \textcolor{comment}{// Implementation of MatrixReplacement * Eigen::DenseVector though a specialization of
       internal::generic\_product\_impl:}
00055 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00056 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00057 
00058   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs>
00059   \textcolor{keyword}{struct }generic\_product\_impl<\hyperlink{class_matrix_replacement}{MatrixReplacement}, Rhs, SparseShape, DenseShape, GemvProduct
      > \textcolor{comment}{// GEMV stands for matrix-vector}
00060   : generic\_product\_impl\_base<MatrixReplacement,Rhs,generic\_product\_impl<MatrixReplacement,Rhs> >
00061   \{
00062     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Product<MatrixReplacement,Rhs>::Scalar Scalar;
00063 
00064     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00065     \textcolor{keyword}{static} \textcolor{keywordtype}{void} scaleAndAddTo(Dest& dst, \textcolor{keyword}{const} \hyperlink{class_matrix_replacement}{MatrixReplacement}& lhs, \textcolor{keyword}{const} Rhs& rhs, \textcolor{keyword}{
      const} Scalar& alpha)
00066     \{
00067       \textcolor{comment}{// This method should implement "dst += alpha * lhs * rhs" inplace,}
00068       \textcolor{comment}{// however, for iterative solvers, alpha is always equal to 1, so let's not bother about it.}
00069       assert(alpha==Scalar(1) && \textcolor{stringliteral}{"scaling is not implemented"});
00070 
00071       \textcolor{comment}{// Here we could simply call dst.noalias() += lhs.my\_matrix() * rhs,}
00072       \textcolor{comment}{// but let's do something fancier (and less efficient):}
00073       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<lhs.cols(); ++i)
00074         dst += rhs(i) * lhs.my\_matrix().\hyperlink{group___sparse_core___module_a8f4eaa3c3921ef3823ffc69ebcc356af}{col}(i);
00075     \}
00076   \};
00077 
00078 \}
00079 \}
00080 
00081 \textcolor{keywordtype}{int} main()
00082 \{
00083   \textcolor{keywordtype}{int} n = 10;
00084   \hyperlink{group___sparse_core___module}{Eigen::SparseMatrix<double>} S = Eigen::MatrixXd::Random(n,n).sparseView(0.5,1)
      ;
00085   S = S.transpose()*S;
00086 
00087   \hyperlink{class_matrix_replacement}{MatrixReplacement} \hyperlink{group___core___module_class_eigen_1_1_matrix}{A};
00088   A.attachMyMatrix(S);
00089 
00090   Eigen::VectorXd b(n), x;
00091   b.setRandom();
00092 
00093   \textcolor{comment}{// Solve Ax = b using various iterative solver with matrix-free version:}
00094   \{
00095     
      \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_conjugate_gradient}{Eigen::ConjugateGradient<MatrixReplacement, Eigen::Lower|Eigen::Upper, Eigen::IdentityPreconditioner>}
       cg;
00096     cg.\hyperlink{group___iterative_linear_solvers___module_a7dfa55c55e82d697bde227696a630914}{compute}(A);
00097     x = cg.\hyperlink{group___sparse_core___module_a4a66e9498b06e3ec4ec36f06b26d4e8f}{solve}(b);
00098     std::cout << \textcolor{stringliteral}{"CG:       #iterations: "} << cg.\hyperlink{group___iterative_linear_solvers___module_ae778dd098bd5e6655625b20b1e9f15da}{iterations}() << \textcolor{stringliteral}{", estimated error: "} << cg.
      \hyperlink{group___iterative_linear_solvers___module_a117c241af3fb1141ad0916a3cf3157ec}{error}() << std::endl;
00099   \}
00100 
00101   \{
00102     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_bi_c_g_s_t_a_b}{Eigen::BiCGSTAB<MatrixReplacement, Eigen::IdentityPreconditioner>}
       bicg;
00103     bicg.\hyperlink{group___iterative_linear_solvers___module_a7dfa55c55e82d697bde227696a630914}{compute}(A);
00104     x = bicg.\hyperlink{group___sparse_core___module_a4a66e9498b06e3ec4ec36f06b26d4e8f}{solve}(b);
00105     std::cout << \textcolor{stringliteral}{"BiCGSTAB: #iterations: "} << bicg.\hyperlink{group___iterative_linear_solvers___module_ae778dd098bd5e6655625b20b1e9f15da}{iterations}() << \textcolor{stringliteral}{", estimated error: "} << bicg.
      \hyperlink{group___iterative_linear_solvers___module_a117c241af3fb1141ad0916a3cf3157ec}{error}() << std::endl;
00106   \}
00107 
00108   \{
00109     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_g_m_r_e_s}{Eigen::GMRES<MatrixReplacement, Eigen::IdentityPreconditioner>}
       \hyperlink{namespace_eigen_1_1internal_a851df31ae9133639a8eb3f6a8484bbf7}{gmres};
00110     gmres.\hyperlink{group___iterative_linear_solvers___module_a7dfa55c55e82d697bde227696a630914}{compute}(A);
00111     x = gmres.\hyperlink{group___sparse_core___module_a4a66e9498b06e3ec4ec36f06b26d4e8f}{solve}(b);
00112     std::cout << \textcolor{stringliteral}{"GMRES:    #iterations: "} << gmres.\hyperlink{group___iterative_linear_solvers___module_ae778dd098bd5e6655625b20b1e9f15da}{iterations}() << \textcolor{stringliteral}{", estimated error: "} << 
      gmres.\hyperlink{group___iterative_linear_solvers___module_a117c241af3fb1141ad0916a3cf3157ec}{error}() << std::endl;
00113   \}
00114 
00115   \{
00116     \hyperlink{class_eigen_1_1_d_g_m_r_e_s}{Eigen::DGMRES<MatrixReplacement, Eigen::IdentityPreconditioner>}
       \hyperlink{namespace_eigen_1_1internal_a851df31ae9133639a8eb3f6a8484bbf7}{gmres};
00117     gmres.\hyperlink{group___iterative_linear_solvers___module_a7dfa55c55e82d697bde227696a630914}{compute}(A);
00118     x = gmres.\hyperlink{group___sparse_core___module_a4a66e9498b06e3ec4ec36f06b26d4e8f}{solve}(b);
00119     std::cout << \textcolor{stringliteral}{"DGMRES:   #iterations: "} << gmres.\hyperlink{group___iterative_linear_solvers___module_ae778dd098bd5e6655625b20b1e9f15da}{iterations}() << \textcolor{stringliteral}{", estimated error: "} << 
      gmres.\hyperlink{group___iterative_linear_solvers___module_a117c241af3fb1141ad0916a3cf3157ec}{error}() << std::endl;
00120   \}
00121 
00122   \{
00123     
      \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_m_i_n_r_e_s}{Eigen::MINRES<MatrixReplacement, Eigen::Lower|Eigen::Upper, Eigen::IdentityPreconditioner>}
       minres;
00124     minres.\hyperlink{group___iterative_linear_solvers___module_a7dfa55c55e82d697bde227696a630914}{compute}(A);
00125     x = minres.\hyperlink{group___sparse_core___module_a4a66e9498b06e3ec4ec36f06b26d4e8f}{solve}(b);
00126     std::cout << \textcolor{stringliteral}{"MINRES:   #iterations: "} << minres.\hyperlink{group___iterative_linear_solvers___module_ae778dd098bd5e6655625b20b1e9f15da}{iterations}() << \textcolor{stringliteral}{", estimated error: "} << 
      minres.\hyperlink{group___iterative_linear_solvers___module_a117c241af3fb1141ad0916a3cf3157ec}{error}() << std::endl;
00127   \}
00128 \}
\end{DoxyCode}
