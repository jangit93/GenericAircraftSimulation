\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_assign_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Assign.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_assign_8h_source}\index{Tensor\+Assign.\+h@{Tensor\+Assign.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_ASSIGN\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_ASSIGN\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00023 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00024 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_assign_8h_source_l00025}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_assign_op_3_01_lhs_xpr_type_00_01_rhs_xpr_type_01_4_01_4}{00025} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp}<LhsXprType, RhsXprType> >
00026 \{
00027   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsXprType::Scalar Scalar;
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<LhsXprType>::StorageKind} StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1promote__index__type}{promote\_index\_type<typename traits<LhsXprType>::Index}
      ,
00030                                       \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<RhsXprType>::Index}>::type 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsXprType::Nested LhsNested;
00032   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsXprType::Nested RhsNested;
00033   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<LhsNested>::type} 
      \hyperlink{group___sparse_core___module}{\_LhsNested};
00034   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<RhsNested>::type} 
      \hyperlink{group___sparse_core___module}{\_RhsNested};
00035   \textcolor{keyword}{static} \textcolor{keyword}{const} std::size\_t NumDimensions = 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<LhsXprType>::NumDimensions};
00036   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<LhsXprType>::Layout};
00037 
00038   \textcolor{keyword}{enum} \{
00039     Flags = 0
00040   \};
00041 \};
00042 
00043 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_assign_8h_source_l00044}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_assign_op_3_01_lhs_xpr_type_00_01_rhs_xpr_type_01_4_00_01_eigen_1_1_dense_01_4}{00044} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp}<LhsXprType, RhsXprType>, \hyperlink{namespace_eigen}{Eigen}::
      \hyperlink{struct_eigen_1_1_dense}{Dense}>
00045 \{
00046   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp<LhsXprType, RhsXprType>}& 
      \hyperlink{class_eigen_1_1_tensor_assign_op}{type};
00047 \};
00048 
00049 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_assign_8h_source_l00050}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_assign_op_3_01_lhs_xpr_type_00_01_rhs_xpr_type_01d4159a152a0e6ba4b4de0b2584842bf3}{00050} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp}<LhsXprType, RhsXprType>, 1, typename 
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp}<LhsXprType, RhsXprType> >::\hyperlink{class_eigen_1_1_tensor_assign_op}{type}>
00051 \{
00052   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp<LhsXprType, RhsXprType>} 
      \hyperlink{class_eigen_1_1_tensor_assign_op}{type};
00053 \};
00054 
00055 \}  \textcolor{comment}{// end namespace internal}
00056 
00057 
00058 
00059 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_assign_8h_source_l00060}\hyperlink{class_eigen_1_1_tensor_assign_op}{00060} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorAssignOp<LhsXprType, RhsXprType> >
00061 \{
00062   \textcolor{keyword}{public}:
00063   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorAssignOp>::Scalar}
       Scalar;
00064   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} 
      \hyperlink{group___sparse_core___module}{RealScalar};
00065   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsXprType::CoeffReturnType CoeffReturnType;
00066   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorAssignOp>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Nested};
00067   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorAssignOp>::StorageKind}
       StorageKind;
00068   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorAssignOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00069 
00070   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp}(LhsXprType& lhs, \textcolor{keyword}{const} RhsXprType& rhs
      )
00071       : m\_lhs\_xpr(lhs), m\_rhs\_xpr(rhs) \{\}
00072 
00074     EIGEN\_DEVICE\_FUNC
00075     \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename LhsXprType::Nested>::type}
      &
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_assign_8h_source_l00076}\hyperlink{class_eigen_1_1_tensor_assign_op_a1a6f7336727e3f95616014883d514caa}{00076}     \hyperlink{class_eigen_1_1_tensor_assign_op_a1a6f7336727e3f95616014883d514caa}{lhsExpression}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *((\textcolor{keyword}{typename} 
      \hyperlink{group___sparse_core___module}{internal::remove\_all<typename LhsXprType::Nested>::type}
      *)&m\_lhs\_xpr); \}
00077 
00078     EIGEN\_DEVICE\_FUNC
00079     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename RhsXprType::Nested>::type}
      &
00080     rhsExpression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rhs\_xpr; \}
00081 
00082   \textcolor{keyword}{protected}:
00083     \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename LhsXprType::Nested>::type}
      & m\_lhs\_xpr;
00084     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename RhsXprType::Nested>::type}
      & m\_rhs\_xpr;
00085 \};
00086 
00087 
00088 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LeftArgType, \textcolor{keyword}{typename} RightArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_assign_8h_source_l00089}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_assign_op_3_01_left_arg_type_00_01_right_arg_type_01_4_00_01_device_01_4}{00089} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp}<LeftArgType, RightArgType>, Device
      >
00090 \{
00091   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp<LeftArgType, RightArgType>} 
      \hyperlink{class_eigen_1_1_tensor_assign_op}{XprType};
00092   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00093   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00094   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00095   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00096   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<RightArgType, Device>::Dimensions}
       Dimensions;
00097   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size};
00098 
00099   \textcolor{keyword}{enum} \{
00100     IsAligned = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::IsAligned}
       & \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<RightArgType, Device>::IsAligned},
00101     PacketAccess = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::PacketAccess}
       & \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<RightArgType, Device>::PacketAccess},
00102     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::Layout},
00103     RawAccess = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::RawAccess}
00104   \};
00105 
00106   EIGEN\_DEVICE\_FUNC \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device) :
00107       m\_leftImpl(op.\hyperlink{class_eigen_1_1_tensor_assign_op_a1a6f7336727e3f95616014883d514caa}{lhsExpression}(), device),
00108       m\_rightImpl(op.rhsExpression(), device)
00109   \{
00110     EIGEN\_STATIC\_ASSERT((static\_cast<int>(
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::Layout}) == 
      static\_cast<int>(\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<RightArgType, Device>::Layout})), 
      YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00111   \}
00112 
00113   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const}
00114 \textcolor{keyword}{  }\{
00115     \textcolor{comment}{// The dimensions of the lhs and the rhs tensors should be equal to prevent}
00116     \textcolor{comment}{// overflows and ensure the result is fully initialized.}
00117     \textcolor{comment}{// TODO: use left impl instead if right impl dimensions are known at compile time.}
00118     \textcolor{keywordflow}{return} m\_rightImpl.dimensions();
00119   \}
00120 
00121   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar*) \{
00122     eigen\_assert(dimensions\_match(m\_leftImpl.dimensions(), m\_rightImpl.dimensions()));
00123     m\_leftImpl.evalSubExprsIfNeeded(NULL);
00124     \textcolor{comment}{// If the lhs provides raw access to its storage area (i.e. if m\_leftImpl.data() returns a non}
00125     \textcolor{comment}{// null value), attempt to evaluate the rhs expression in place. Returns true iff in place}
00126     \textcolor{comment}{// evaluation isn't supported and the caller still needs to manually assign the values generated}
00127     \textcolor{comment}{// by the rhs to the lhs.}
00128     \textcolor{keywordflow}{return} m\_rightImpl.evalSubExprsIfNeeded(m\_leftImpl.data());
00129   \}
00130   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00131     m\_leftImpl.cleanup();
00132     m\_rightImpl.cleanup();
00133   \}
00134 
00135   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} evalScalar(Index i) \{
00136     m\_leftImpl.coeffRef(i) = m\_rightImpl.coeff(i);
00137   \}
00138   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} evalPacket(Index i) \{
00139     \textcolor{keyword}{const} \textcolor{keywordtype}{int} LhsStoreMode = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::IsAligned}
       ? \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned} : \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned};
00140     \textcolor{keyword}{const} \textcolor{keywordtype}{int} RhsLoadMode = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<RightArgType, Device>::IsAligned}
       ? \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned} : \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned};
00141     m\_leftImpl.template writePacket<LhsStoreMode>(i, m\_rightImpl.template packet<RhsLoadMode>(i));
00142   \}
00143   EIGEN\_DEVICE\_FUNC CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00144 \textcolor{keyword}{  }\{
00145     \textcolor{keywordflow}{return} m\_leftImpl.coeff(index);
00146   \}
00147   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00148   EIGEN\_DEVICE\_FUNC PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00149 \textcolor{keyword}{  }\{
00150     \textcolor{keywordflow}{return} m\_leftImpl.template packet<LoadMode>(index);
00151   \}
00152 
00153   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}
00154   costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00155     \textcolor{comment}{// We assume that evalPacket or evalScalar is called to perform the}
00156     \textcolor{comment}{// assignment and account for the cost of the write here, but reduce left}
00157     \textcolor{comment}{// cost by one load because we are using m\_leftImpl.coeffRef.}
00158     \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost} left = m\_leftImpl.costPerCoeff(vectorized);
00159     \textcolor{keywordflow}{return} m\_rightImpl.costPerCoeff(vectorized) +
00160            \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(
00161                numext::maxi(0.0, left.bytes\_loaded() - \textcolor{keyword}{sizeof}(CoeffReturnType)),
00162                left.bytes\_stored(), left.compute\_cycles()) +
00163            \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, \textcolor{keyword}{sizeof}(CoeffReturnType), 0, vectorized, PacketSize);
00164   \}
00165 
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_assign_8h_source_l00167}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_assign_op_3_01_left_arg_type_00_01_right_arg_type_01_4_00_01_device_01_4_a52e2b2245de4d6d78e747eaf88995d6d}{00167}   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>}& 
      \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_assign_op_3_01_left_arg_type_00_01_right_arg_type_01_4_00_01_device_01_4_a52e2b2245de4d6d78e747eaf88995d6d}{left\_impl}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_leftImpl; \}
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_assign_8h_source_l00169}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_assign_op_3_01_left_arg_type_00_01_right_arg_type_01_4_00_01_device_01_4_aeb9deae6affa88fe857daf66d83e38a0}{00169}   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<RightArgType, Device>}& 
      \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_assign_op_3_01_left_arg_type_00_01_right_arg_type_01_4_00_01_device_01_4_aeb9deae6affa88fe857daf66d83e38a0}{right\_impl}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rightImpl; \}
00170 
00171   EIGEN\_DEVICE\_FUNC CoeffReturnType* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_leftImpl.data(); \}
00172 
00173  \textcolor{keyword}{private}:
00174   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>} m\_leftImpl;
00175   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<RightArgType, Device>} m\_rightImpl;
00176 \};
00177 
00178 \}
00179 
00180 
00181 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_ASSIGN\_H}
\end{DoxyCode}
