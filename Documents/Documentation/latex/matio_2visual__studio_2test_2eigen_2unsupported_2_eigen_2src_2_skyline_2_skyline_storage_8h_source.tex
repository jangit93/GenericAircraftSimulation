\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_storage_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+Skyline/\+Skyline\+Storage.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_skyline_2_skyline_storage_8h_source}\index{Skyline\+Storage.\+h@{Skyline\+Storage.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2009 Guillaume Saupin <guillaume.saupin@cea.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SKYLINE\_STORAGE\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SKYLINE\_STORAGE\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00021 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00022 \textcolor{keyword}{class }SkylineStorage \{
00023     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar;
00024     \textcolor{keyword}{typedef} SparseIndex Index;
00025 \textcolor{keyword}{public}:
00026 
00027     SkylineStorage()
00028     : m\_diag(0),
00029     m\_lower(0),
00030     m\_upper(0),
00031     m\_lowerProfile(0),
00032     m\_upperProfile(0),
00033     m\_diagSize(0),
00034     m\_upperSize(0),
00035     m\_lowerSize(0),
00036     m\_upperProfileSize(0),
00037     m\_lowerProfileSize(0),
00038     m\_allocatedSize(0) \{
00039     \}
00040 
00041     SkylineStorage(\textcolor{keyword}{const} SkylineStorage& other)
00042     : m\_diag(0),
00043     m\_lower(0),
00044     m\_upper(0),
00045     m\_lowerProfile(0),
00046     m\_upperProfile(0),
00047     m\_diagSize(0),
00048     m\_upperSize(0),
00049     m\_lowerSize(0),
00050     m\_upperProfileSize(0),
00051     m\_lowerProfileSize(0),
00052     m\_allocatedSize(0) \{
00053         *\textcolor{keyword}{this} = other;
00054     \}
00055 
00056     SkylineStorage & operator=(\textcolor{keyword}{const} SkylineStorage& other) \{
00057         resize(other.diagSize(), other.m\_upperProfileSize, other.m\_lowerProfileSize, other.upperSize(), 
      other.lowerSize());
00058         memcpy(m\_diag, other.m\_diag, m\_diagSize * sizeof (Scalar));
00059         memcpy(m\_upper, other.m\_upper, other.upperSize() * \textcolor{keyword}{sizeof} (Scalar));
00060         memcpy(m\_lower, other.m\_lower, other.lowerSize() * \textcolor{keyword}{sizeof} (Scalar));
00061         memcpy(m\_upperProfile, other.m\_upperProfile, m\_upperProfileSize * sizeof (Index));
00062         memcpy(m\_lowerProfile, other.m\_lowerProfile, m\_lowerProfileSize * sizeof (Index));
00063         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00064     \}
00065 
00066     \textcolor{keywordtype}{void} swap(SkylineStorage& other) \{
00067         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_diag, other.m\_diag);
00068         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_upper, other.m\_upper);
00069         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_lower, other.m\_lower);
00070         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_upperProfile, other.m\_upperProfile);
00071         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_lowerProfile, other.m\_lowerProfile);
00072         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_diagSize, other.m\_diagSize);
00073         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_upperSize, other.m\_upperSize);
00074         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_lowerSize, other.m\_lowerSize);
00075         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_allocatedSize, other.m\_allocatedSize);
00076     \}
00077 
00078     ~SkylineStorage() \{
00079         \textcolor{keyword}{delete}[] m\_diag;
00080         \textcolor{keyword}{delete}[] m\_upper;
00081         \textcolor{keywordflow}{if} (m\_upper != m\_lower)
00082             \textcolor{keyword}{delete}[] m\_lower;
00083         \textcolor{keyword}{delete}[] m\_upperProfile;
00084         \textcolor{keyword}{delete}[] m\_lowerProfile;
00085     \}
00086 
00087     \textcolor{keywordtype}{void} reserve(Index size, Index upperProfileSize, Index lowerProfileSize, Index upperSize, Index 
      lowerSize) \{
00088         Index newAllocatedSize = size + upperSize + lowerSize;
00089         \textcolor{keywordflow}{if} (newAllocatedSize > m\_allocatedSize)
00090             reallocate(size, upperProfileSize, lowerProfileSize, upperSize, lowerSize);
00091     \}
00092 
00093     \textcolor{keywordtype}{void} squeeze() \{
00094         \textcolor{keywordflow}{if} (m\_allocatedSize > m\_diagSize + m\_upperSize + m\_lowerSize)
00095             reallocate(m\_diagSize, m\_upperProfileSize, m\_lowerProfileSize, m\_upperSize, m\_lowerSize);
00096     \}
00097 
00098     \textcolor{keywordtype}{void} resize(Index diagSize, Index upperProfileSize, Index lowerProfileSize, Index upperSize, Index 
      lowerSize, \textcolor{keywordtype}{float} reserveSizeFactor = 0) \{
00099         \textcolor{keywordflow}{if} (m\_allocatedSize < diagSize + upperSize + lowerSize)
00100             reallocate(diagSize, upperProfileSize, lowerProfileSize, upperSize + Index(reserveSizeFactor * 
      upperSize), lowerSize + Index(reserveSizeFactor * lowerSize));
00101         m\_diagSize = diagSize;
00102         m\_upperSize = upperSize;
00103         m\_lowerSize = lowerSize;
00104         m\_upperProfileSize = upperProfileSize;
00105         m\_lowerProfileSize = lowerProfileSize;
00106     \}
00107 
00108     \textcolor{keyword}{inline} Index diagSize()\textcolor{keyword}{ const }\{
00109         \textcolor{keywordflow}{return} m\_diagSize;
00110     \}
00111 
00112     \textcolor{keyword}{inline} Index upperSize()\textcolor{keyword}{ const }\{
00113         \textcolor{keywordflow}{return} m\_upperSize;
00114     \}
00115 
00116     \textcolor{keyword}{inline} Index lowerSize()\textcolor{keyword}{ const }\{
00117         \textcolor{keywordflow}{return} m\_lowerSize;
00118     \}
00119 
00120     \textcolor{keyword}{inline} Index upperProfileSize()\textcolor{keyword}{ const }\{
00121         \textcolor{keywordflow}{return} m\_upperProfileSize;
00122     \}
00123 
00124     \textcolor{keyword}{inline} Index lowerProfileSize()\textcolor{keyword}{ const }\{
00125         \textcolor{keywordflow}{return} m\_lowerProfileSize;
00126     \}
00127 
00128     \textcolor{keyword}{inline} Index allocatedSize()\textcolor{keyword}{ const }\{
00129         \textcolor{keywordflow}{return} m\_allocatedSize;
00130     \}
00131 
00132     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} clear() \{
00133         m\_diagSize = 0;
00134     \}
00135 
00136     \textcolor{keyword}{inline} Scalar& diag(Index i) \{
00137         \textcolor{keywordflow}{return} m\_diag[i];
00138     \}
00139 
00140     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar& diag(Index i)\textcolor{keyword}{ const }\{
00141         \textcolor{keywordflow}{return} m\_diag[i];
00142     \}
00143 
00144     \textcolor{keyword}{inline} Scalar& upper(Index i) \{
00145         \textcolor{keywordflow}{return} m\_upper[i];
00146     \}
00147 
00148     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar& upper(Index i)\textcolor{keyword}{ const }\{
00149         \textcolor{keywordflow}{return} m\_upper[i];
00150     \}
00151 
00152     \textcolor{keyword}{inline} Scalar& lower(Index i) \{
00153         \textcolor{keywordflow}{return} m\_lower[i];
00154     \}
00155 
00156     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar& lower(Index i)\textcolor{keyword}{ const }\{
00157         \textcolor{keywordflow}{return} m\_lower[i];
00158     \}
00159 
00160     \textcolor{keyword}{inline} Index& upperProfile(Index i) \{
00161         \textcolor{keywordflow}{return} m\_upperProfile[i];
00162     \}
00163 
00164     \textcolor{keyword}{inline} \textcolor{keyword}{const} Index& upperProfile(Index i)\textcolor{keyword}{ const }\{
00165         \textcolor{keywordflow}{return} m\_upperProfile[i];
00166     \}
00167 
00168     \textcolor{keyword}{inline} Index& lowerProfile(Index i) \{
00169         \textcolor{keywordflow}{return} m\_lowerProfile[i];
00170     \}
00171 
00172     \textcolor{keyword}{inline} \textcolor{keyword}{const} Index& lowerProfile(Index i)\textcolor{keyword}{ const }\{
00173         \textcolor{keywordflow}{return} m\_lowerProfile[i];
00174     \}
00175 
00176     \textcolor{keyword}{static} SkylineStorage Map(Index* upperProfile, Index* lowerProfile, Scalar* diag, Scalar* upper, Scalar
      * lower, Index size, Index upperSize, Index lowerSize) \{
00177         SkylineStorage res;
00178         res.m\_upperProfile = upperProfile;
00179         res.m\_lowerProfile = lowerProfile;
00180         res.m\_diag = diag;
00181         res.m\_upper = upper;
00182         res.m\_lower = lower;
00183         res.m\_allocatedSize = res.m\_diagSize = size;
00184         res.m\_upperSize = upperSize;
00185         res.m\_lowerSize = lowerSize;
00186         \textcolor{keywordflow}{return} res;
00187     \}
00188 
00189     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} reset() \{
00190         memset(m\_diag, 0, m\_diagSize * \textcolor{keyword}{sizeof} (Scalar));
00191         memset(m\_upper, 0, m\_upperSize * \textcolor{keyword}{sizeof} (Scalar));
00192         memset(m\_lower, 0, m\_lowerSize * \textcolor{keyword}{sizeof} (Scalar));
00193         memset(m\_upperProfile, 0, m\_diagSize * \textcolor{keyword}{sizeof} (Index));
00194         memset(m\_lowerProfile, 0, m\_diagSize * \textcolor{keyword}{sizeof} (Index));
00195     \}
00196 
00197     \textcolor{keywordtype}{void} prune(Scalar reference, RealScalar epsilon = dummy\_precision<RealScalar>()) \{
00198         \textcolor{comment}{//TODO}
00199     \}
00200 
00201 \textcolor{keyword}{protected}:
00202 
00203     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} reallocate(Index diagSize, Index upperProfileSize, Index lowerProfileSize, Index upperSize,
       Index lowerSize) \{
00204 
00205         Scalar* diag = \textcolor{keyword}{new} Scalar[diagSize];
00206         Scalar* upper = \textcolor{keyword}{new} Scalar[upperSize];
00207         Scalar* lower = \textcolor{keyword}{new} Scalar[lowerSize];
00208         Index* upperProfile = \textcolor{keyword}{new} Index[upperProfileSize];
00209         Index* lowerProfile = \textcolor{keyword}{new} Index[lowerProfileSize];
00210 
00211         Index copyDiagSize = (std::min)(diagSize, m\_diagSize);
00212         Index copyUpperSize = (std::min)(upperSize, m\_upperSize);
00213         Index copyLowerSize = (std::min)(lowerSize, m\_lowerSize);
00214         Index copyUpperProfileSize = (std::min)(upperProfileSize, m\_upperProfileSize);
00215         Index copyLowerProfileSize = (std::min)(lowerProfileSize, m\_lowerProfileSize);
00216 
00217         \textcolor{comment}{// copy}
00218         memcpy(diag, m\_diag, copyDiagSize * \textcolor{keyword}{sizeof} (Scalar));
00219         memcpy(upper, m\_upper, copyUpperSize * \textcolor{keyword}{sizeof} (Scalar));
00220         memcpy(lower, m\_lower, copyLowerSize * \textcolor{keyword}{sizeof} (Scalar));
00221         memcpy(upperProfile, m\_upperProfile, copyUpperProfileSize * \textcolor{keyword}{sizeof} (Index));
00222         memcpy(lowerProfile, m\_lowerProfile, copyLowerProfileSize * \textcolor{keyword}{sizeof} (Index));
00223 
00224 
00225 
00226         \textcolor{comment}{// delete old stuff}
00227         \textcolor{keyword}{delete}[] m\_diag;
00228         \textcolor{keyword}{delete}[] m\_upper;
00229         \textcolor{keyword}{delete}[] m\_lower;
00230         \textcolor{keyword}{delete}[] m\_upperProfile;
00231         \textcolor{keyword}{delete}[] m\_lowerProfile;
00232         m\_diag = diag;
00233         m\_upper = upper;
00234         m\_lower = lower;
00235         m\_upperProfile = upperProfile;
00236         m\_lowerProfile = lowerProfile;
00237         m\_allocatedSize = diagSize + upperSize + lowerSize;
00238         m\_upperSize = upperSize;
00239         m\_lowerSize = lowerSize;
00240     \}
00241 
00242 \textcolor{keyword}{public}:
00243     Scalar* m\_diag;
00244     Scalar* m\_upper;
00245     Scalar* m\_lower;
00246     Index* m\_upperProfile;
00247     Index* m\_lowerProfile;
00248     Index m\_diagSize;
00249     Index m\_upperSize;
00250     Index m\_lowerSize;
00251     Index m\_upperProfileSize;
00252     Index m\_lowerProfileSize;
00253     Index m\_allocatedSize;
00254 
00255 \};
00256 
00257 \} \textcolor{comment}{// end namespace Eigen}
00258 
00259 \textcolor{preprocessor}{#endif // EIGEN\_COMPRESSED\_STORAGE\_H}
\end{DoxyCode}
