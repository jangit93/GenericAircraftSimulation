\hypertarget{matio_2visual__studio_2test_2eigen_2bench_2product__threshold_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/bench/product\+\_\+threshold.cpp}
\label{matio_2visual__studio_2test_2eigen_2bench_2product__threshold_8cpp_source}\index{product\+\_\+threshold.\+cpp@{product\+\_\+threshold.\+cpp}}

\begin{DoxyCode}
00001 
00002 \textcolor{preprocessor}{#include <iostream>}
00003 \textcolor{preprocessor}{#include <Eigen/Core>}
00004 \textcolor{preprocessor}{#include <bench/BenchTimer.h>}
00005 
00006 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00007 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00008 
00009 \textcolor{preprocessor}{#define END 9}
00010 
00011 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} S> \textcolor{keyword}{struct }\hyperlink{structmap__size}{map\_size} \{ \textcolor{keyword}{enum} \{ ret = S \}; \};
00012 \textcolor{keyword}{template}<>  \textcolor{keyword}{struct }\hyperlink{structmap__size}{map\_size}<10> \{ \textcolor{keyword}{enum} \{ ret = 20 \}; \};
00013 \textcolor{keyword}{template}<>  \textcolor{keyword}{struct }\hyperlink{structmap__size}{map\_size}<11> \{ \textcolor{keyword}{enum} \{ ret = 50 \}; \};
00014 \textcolor{keyword}{template}<>  \textcolor{keyword}{struct }\hyperlink{structmap__size}{map\_size}<12> \{ \textcolor{keyword}{enum} \{ ret = 100 \}; \};
00015 \textcolor{keyword}{template}<>  \textcolor{keyword}{struct }\hyperlink{structmap__size}{map\_size}<13> \{ \textcolor{keyword}{enum} \{ ret = 300 \}; \};
00016 
00017 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} M, \textcolor{keywordtype}{int} N,\textcolor{keywordtype}{int} K> \textcolor{keyword}{struct }\hyperlink{structalt__prod}{alt\_prod}
00018 \{
00019   \textcolor{keyword}{enum} \{
00020     ret = \hyperlink{group___core___module_class_eigen_1_1_matrix}{M}==1 && N==1 ? InnerProduct
00021         : K==1 ? OuterProduct
00022         : \hyperlink{group___core___module_class_eigen_1_1_matrix}{M}==1 ? GemvProduct
00023         : N==1 ? GemvProduct
00024         : GemmProduct
00025   \};
00026 \};
00027         
00028 \textcolor{keywordtype}{void} print\_mode(\textcolor{keywordtype}{int} mode)
00029 \{
00030   \textcolor{keywordflow}{if}(mode==InnerProduct) std::cout << \textcolor{stringliteral}{"i"};
00031   \textcolor{keywordflow}{if}(mode==OuterProduct) std::cout << \textcolor{stringliteral}{"o"};
00032   \textcolor{keywordflow}{if}(mode==CoeffBasedProductMode) std::cout << \textcolor{stringliteral}{"c"};
00033   \textcolor{keywordflow}{if}(mode==LazyCoeffBasedProductMode) std::cout << \textcolor{stringliteral}{"l"};
00034   \textcolor{keywordflow}{if}(mode==GemvProduct) std::cout << \textcolor{stringliteral}{"v"};
00035   \textcolor{keywordflow}{if}(mode==GemmProduct) std::cout << \textcolor{stringliteral}{"m"};
00036 \}
00037 
00038 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Mode, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Res>
00039 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} prod(\textcolor{keyword}{const} Lhs& a, \textcolor{keyword}{const} Rhs& b, Res& c)
00040 \{
00041   c.noalias() += \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_product_return_type}{ProductReturnType<Lhs,Rhs,Mode>::Type}(a,b);
00042 \}
00043 
00044 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} M, \textcolor{keywordtype}{int} N, \textcolor{keywordtype}{int} K, \textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Mode>
00045 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} bench\_prod()
00046 \{
00047   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,M,K>} Lhs; Lhs a; a.setRandom();
00048   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,K,N>} Rhs; Rhs b; b.setRandom();
00049   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,M,N>} Res; Res c; c.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00050 
00051   \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} t;
00052   \textcolor{keywordtype}{double} n = 2.*double(\hyperlink{group___core___module_class_eigen_1_1_matrix}{M})*double(N)*double(K);
00053   \textcolor{keywordtype}{int} rep = 100000./n;
00054   rep /= 2;
00055   \textcolor{keywordflow}{if}(rep<1) rep = 1;
00056   \textcolor{keywordflow}{do} \{
00057     rep *= 2;
00058     t.reset();
00059     BENCH(t,1,rep,prod<CoeffBasedProductMode>(a,b,c));
00060   \} \textcolor{keywordflow}{while}(t.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}()<0.1);
00061   
00062   t.reset();
00063   BENCH(t,5,rep,prod<Mode>(a,b,c));
00064 
00065   print\_mode(Mode);
00066   std::cout << int(1e-6*n*rep/t.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}()) << \textcolor{stringliteral}{"\(\backslash\)t"};
00067 \}
00068 
00069 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} N> \textcolor{keyword}{struct }\hyperlink{structprint__n}{print\_n};
00070 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} M, \textcolor{keywordtype}{int} N, \textcolor{keywordtype}{int} K> \textcolor{keyword}{struct }\hyperlink{structloop__on__m}{loop\_on\_m};
00071 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} M, \textcolor{keywordtype}{int} N, \textcolor{keywordtype}{int} K, \textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Mode> \textcolor{keyword}{struct }\hyperlink{structloop__on__n}{loop\_on\_n};
00072 
00073 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} M, \textcolor{keywordtype}{int} N, \textcolor{keywordtype}{int} K>
00074 \textcolor{keyword}{struct }\hyperlink{structloop__on__k}{loop\_on\_k}
00075 \{
00076   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run()
00077   \{
00078     std::cout << \textcolor{stringliteral}{"K="} << K << \textcolor{stringliteral}{"\(\backslash\)t"};
00079     \hyperlink{structprint__n}{print\_n<N>::run}();
00080     std::cout << \textcolor{stringliteral}{"\(\backslash\)n"};
00081 
00082     \hyperlink{structloop__on__m}{loop\_on\_m<M,N,K>::run}();
00083     std::cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
00084 
00085     \hyperlink{structloop__on__k}{loop\_on\_k<M,N,K+1>::run}();
00086   \}
00087 \};
00088 
00089 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} M, \textcolor{keywordtype}{int} N>
00090 \textcolor{keyword}{struct }\hyperlink{structloop__on__k}{loop\_on\_k}<\hyperlink{group___core___module_class_eigen_1_1_matrix}{M},N,END> \{ \textcolor{keyword}{static} \textcolor{keywordtype}{void} run()\{\} \};
00091 
00092 
00093 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} M, \textcolor{keywordtype}{int} N, \textcolor{keywordtype}{int} K>
00094 \textcolor{keyword}{struct }\hyperlink{structloop__on__m}{loop\_on\_m}
00095 \{
00096   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run()
00097   \{
00098     std::cout << \hyperlink{group___core___module_class_eigen_1_1_matrix}{M} << \textcolor{stringliteral}{"f\(\backslash\)t"};
00099     \hyperlink{structloop__on__n}{loop\_on\_n<M,N,K,float,CoeffBasedProductMode>::run}();
00100     std::cout << \textcolor{stringliteral}{"\(\backslash\)n"};
00101     
00102     std::cout << M << \textcolor{stringliteral}{"f\(\backslash\)t"};
00103     \hyperlink{structloop__on__n}{loop\_on\_n<M,N,K,float,-1>::run}();
00104     std::cout << \textcolor{stringliteral}{"\(\backslash\)n"};
00105 
00106     \hyperlink{structloop__on__m}{loop\_on\_m<M+1,N,K>::run}();
00107   \}
00108 \};
00109 
00110 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} N, \textcolor{keywordtype}{int} K>
00111 \textcolor{keyword}{struct }\hyperlink{structloop__on__m}{loop\_on\_m}<END,N,K> \{ \textcolor{keyword}{static} \textcolor{keywordtype}{void} run()\{\} \};
00112 
00113 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} M, \textcolor{keywordtype}{int} N, \textcolor{keywordtype}{int} K, \textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Mode>
00114 \textcolor{keyword}{struct }\hyperlink{structloop__on__n}{loop\_on\_n}
00115 \{
00116   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run()
00117   \{
00118     bench\_prod<\hyperlink{group___core___module_class_eigen_1_1_matrix}{M},N,K,Scalar,Mode==-1? \hyperlink{structalt__prod}{alt\_prod<M,N,K>::ret} : Mode>();
00119     
00120     \hyperlink{structloop__on__n}{loop\_on\_n<M,N+1,K,Scalar,Mode>::run}();
00121   \}
00122 \};
00123 
00124 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} M, \textcolor{keywordtype}{int} K, \textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Mode>
00125 \textcolor{keyword}{struct }\hyperlink{structloop__on__n}{loop\_on\_n}<\hyperlink{group___core___module_class_eigen_1_1_matrix}{M},END,K,Scalar,Mode> \{ \textcolor{keyword}{static} \textcolor{keywordtype}{void} run()\{\} \};
00126 
00127 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} N> \textcolor{keyword}{struct }\hyperlink{structprint__n}{print\_n}
00128 \{
00129   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run()
00130   \{
00131     std::cout << map\_size<N>::ret << \textcolor{stringliteral}{"\(\backslash\)t"};
00132     \hyperlink{structprint__n}{print\_n<N+1>::run}();
00133   \}
00134 \};
00135 
00136 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{structprint__n}{print\_n}<END> \{ \textcolor{keyword}{static} \textcolor{keywordtype}{void} run()\{\} \};
00137 
00138 \textcolor{keywordtype}{int} main()
00139 \{
00140   \hyperlink{structloop__on__k}{loop\_on\_k<1,1,1>::run}();
00141   
00142   \textcolor{keywordflow}{return} 0; 
00143 \}
\end{DoxyCode}
