\hypertarget{eigen_2test_2qr_8cpp_source}{}\section{eigen/test/qr.cpp}
\label{eigen_2test_2qr_8cpp_source}\index{qr.\+cpp@{qr.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 \textcolor{preprocessor}{#include <Eigen/QR>}
00012 
00013 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} qr(\textcolor{keyword}{const} MatrixType& m)
00014 \{
00015   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00016 
00017   Index rows = m.rows();
00018   Index cols = m.cols();
00019 
00020   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00021   \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, MatrixType::RowsAtCompileTime>}
       MatrixQType;
00022 
00023   MatrixType a = MatrixType::Random(rows,cols);
00024   \hyperlink{group___q_r___module}{HouseholderQR<MatrixType>} qrOfA(a);
00025 
00026   MatrixQType q = qrOfA.householderQ();
00027   VERIFY\_IS\_UNITARY(q);
00028 
00029   MatrixType r = qrOfA.matrixQR().template triangularView<Upper>();
00030   VERIFY\_IS\_APPROX(a, qrOfA.householderQ() * r);
00031 \}
00032 
00033 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} Cols2> \textcolor{keywordtype}{void} qr\_fixedsize()
00034 \{
00035   \textcolor{keyword}{enum} \{ Rows = MatrixType::RowsAtCompileTime, Cols = MatrixType::ColsAtCompileTime \};
00036   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00037   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Rows,Cols>} m1 = 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Rows,Cols>::Random}();
00038   \hyperlink{group___q_r___module_class_eigen_1_1_householder_q_r}{HouseholderQR<Matrix<Scalar,Rows,Cols>} > qr(m1);
00039 
00040   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Rows,Cols>} r = qr.matrixQR();
00041   \textcolor{comment}{// FIXME need better way to construct trapezoid}
00042   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < Rows; i++) for(int j = 0; j < Cols; j++) if(i>j) r(i,j) = Scalar(0);
00043 
00044   VERIFY\_IS\_APPROX(m1, qr.householderQ() * r);
00045 
00046   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Cols,Cols2>} m2 = 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Cols,Cols2>::Random}(Cols,Cols2);
00047   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Rows,Cols2>} m3 = m1*m2;
00048   m2 = \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Cols,Cols2>::Random}(Cols,Cols2);
00049   m2 = qr.solve(m3);
00050   VERIFY\_IS\_APPROX(m3, m1*m2);
00051 \}
00052 
00053 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} qr\_invertible()
00054 \{
00055   \textcolor{keyword}{using} std::log;
00056   \textcolor{keyword}{using} std::abs;
00057   \textcolor{keyword}{using} std::pow;
00058   \textcolor{keyword}{using} std::max;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename MatrixType::Scalar>::Real}
       RealScalar;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00061 
00062   \textcolor{keywordtype}{int} size = internal::random<int>(10,50);
00063 
00064   MatrixType m1(size, size), m2(size, size), m3(size, size);
00065   m1 = MatrixType::Random(size,size);
00066 
00067   \textcolor{keywordflow}{if} (internal::is\_same<RealScalar,float>::value)
00068   \{
00069     \textcolor{comment}{// let's build a matrix more stable to inverse}
00070     MatrixType a = MatrixType::Random(size,size*4);
00071     m1 += a * a.adjoint();
00072   \}
00073 
00074   \hyperlink{group___q_r___module}{HouseholderQR<MatrixType>} qr(m1);
00075   m3 = MatrixType::Random(size,size);
00076   m2 = qr.solve(m3);
00077   VERIFY\_IS\_APPROX(m3, m1*m2);
00078 
00079   \textcolor{comment}{// now construct a matrix with prescribed determinant}
00080   m1.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00081   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) m1(i,i) = internal::random<Scalar>();
00082   RealScalar absdet = abs(m1.diagonal().prod());
00083   m3 = qr.householderQ(); \textcolor{comment}{// get a unitary}
00084   m1 = m3 * m1 * m3;
00085   qr.compute(m1);
00086   VERIFY\_IS\_APPROX(\hyperlink{structlog}{log}(absdet), qr.logAbsDeterminant());
00087   \textcolor{comment}{// This test is tricky if the determinant becomes too small.}
00088   \textcolor{comment}{// Since we generate random numbers with magnitude rrange [0,1], the average determinant is 0.5^size}
00089   VERIFY\_IS\_MUCH\_SMALLER\_THAN( abs(absdet-qr.absDeterminant()), numext::maxi(RealScalar(
      \hyperlink{group___core___module_ab6dc101d82e8228a19a8840e3a29c1c9}{pow}(0.5,size)),numext::maxi<RealScalar>(abs(absdet),abs(qr.absDeterminant()))) );
00090   
00091 \}
00092 
00093 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} qr\_verify\_assert()
00094 \{
00095   MatrixType tmp;
00096 
00097   \hyperlink{group___q_r___module}{HouseholderQR<MatrixType>} qr;
00098   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_ae837f2fb30099212c53b3042c7d699c9}{matrixQR}())
00099   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a3e8e56769bbaaed0616ad98c4ff99c7b}{solve}(tmp))
00100   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_affd506c10ef2d25f56e7b1f9f25ff885}{householderQ}())
00101   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_aaf4ef26c0b7affc91431ec59c92d64c3}{absDeterminant}())
00102   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_af61b6dbef34fc51c825182b16dc43ca1}{logAbsDeterminant}())
00103 \}
00104 
00105 \textcolor{keywordtype}{void} test\_qr()
00106 \{
00107   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00108    CALL\_SUBTEST\_1( qr(MatrixXf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE),internal::random<int>(1,
      EIGEN\_TEST\_MAX\_SIZE))) );
00109    CALL\_SUBTEST\_2( qr(MatrixXcd(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2),internal::random<int>(1,
      EIGEN\_TEST\_MAX\_SIZE/2))) );
00110    CALL\_SUBTEST\_3(( qr\_fixedsize<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,3,4>}, 2 >() ));
00111    CALL\_SUBTEST\_4(( qr\_fixedsize<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,6,2>}, 4 >() ));
00112    CALL\_SUBTEST\_5(( qr\_fixedsize<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,2,5>}, 7 >() ));
00113    CALL\_SUBTEST\_11( qr(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,1,1>}()) );
00114   \}
00115 
00116   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00117     CALL\_SUBTEST\_1( qr\_invertible<MatrixXf>() );
00118     CALL\_SUBTEST\_6( qr\_invertible<MatrixXd>() );
00119     CALL\_SUBTEST\_7( qr\_invertible<MatrixXcf>() );
00120     CALL\_SUBTEST\_8( qr\_invertible<MatrixXcd>() );
00121   \}
00122 
00123   CALL\_SUBTEST\_9(qr\_verify\_assert<Matrix3f>());
00124   CALL\_SUBTEST\_10(qr\_verify\_assert<Matrix3d>());
00125   CALL\_SUBTEST\_1(qr\_verify\_assert<MatrixXf>());
00126   CALL\_SUBTEST\_6(qr\_verify\_assert<MatrixXd>());
00127   CALL\_SUBTEST\_7(qr\_verify\_assert<MatrixXcf>());
00128   CALL\_SUBTEST\_8(qr\_verify\_assert<MatrixXcd>());
00129 
00130   \textcolor{comment}{// Test problem size constructors}
00131   CALL\_SUBTEST\_12(\hyperlink{group___q_r___module_class_eigen_1_1_householder_q_r}{HouseholderQR<MatrixXf>}(10, 20));
00132 \}
\end{DoxyCode}
