\hypertarget{eigen_2_eigen_2src_2_core_2products_2_triangular_solver_matrix_8h_source}{}\section{eigen/\+Eigen/src/\+Core/products/\+Triangular\+Solver\+Matrix.h}
\label{eigen_2_eigen_2src_2_core_2products_2_triangular_solver_matrix_8h_source}\index{Triangular\+Solver\+Matrix.\+h@{Triangular\+Solver\+Matrix.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_TRIANGULAR\_SOLVER\_MATRIX\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_TRIANGULAR\_SOLVER\_MATRIX\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{comment}{// if the rhs is row major, let's transpose the product}
00018 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} S\textcolor{keywordtype}{id}e, \textcolor{keywordtype}{int} Mode, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{int} TriStorageOrder>
\Hypertarget{eigen_2_eigen_2src_2_core_2products_2_triangular_solver_matrix_8h_source_l00019}\hyperlink{struct_eigen_1_1internal_1_1triangular__solve__matrix_3_01_scalar_00_01_index_00_01_side_00_01_m9c5e3cf61677ffd5b871aafbe3527bae}{00019} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1triangular__solve__matrix}{triangular\_solve\_matrix}<Scalar,\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},Side,Mode,
      \hyperlink{class_eigen_1_1_conjugate}{Conjugate},TriStorageOrder,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}>
00020 \{
00021   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(
00022     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols,
00023     \textcolor{keyword}{const} Scalar*  tri, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} triStride,
00024     Scalar* \_other, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} otherStride,
00025     \hyperlink{class_eigen_1_1internal_1_1level3__blocking}{level3\_blocking<Scalar,Scalar>}& blocking)
00026   \{
00027     \hyperlink{struct_eigen_1_1internal_1_1triangular__solve__matrix}{triangular\_solve\_matrix}<
00028       Scalar, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, Side==\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4}{OnTheLeft}?\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b}{OnTheRight}:
      \hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4}{OnTheLeft},
00029       (Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaddb72f888ac85d5a1c52333e54f9374b}{UnitDiag}) | ((Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}) ? \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} : \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}),
00030       \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsComplex} && \hyperlink{class_eigen_1_1_conjugate}{Conjugate},
00031       TriStorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}, 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}>
00032       ::run(size, cols, tri, triStride, \_other, otherStride, blocking);
00033   \}
00034 \};
00035 
00036 \textcolor{comment}{/* Optimized triangular solver with multiple right hand side and the triangular matrix on the left}
00037 \textcolor{comment}{ */}
00038 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} Mode, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{int} TriStorageOrder>
\Hypertarget{eigen_2_eigen_2src_2_core_2products_2_triangular_solver_matrix_8h_source_l00039}\hyperlink{struct_eigen_1_1internal_1_1triangular__solve__matrix_3_01_scalar_00_01_index_00_01_on_the_left_42f4ce9e44870d1944d8e65e6eb169ab}{00039} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1triangular__solve__matrix}{triangular\_solve\_matrix}<Scalar,\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
      \hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4}{OnTheLeft},Mode,\hyperlink{class_eigen_1_1_conjugate}{Conjugate},TriStorageOrder,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}>
00040 \{
00041   \textcolor{keyword}{static} EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} run(
00042     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} otherSize,
00043     \textcolor{keyword}{const} Scalar* \_tri, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} triStride,
00044     Scalar* \_other, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} otherStride,
00045     \hyperlink{class_eigen_1_1internal_1_1level3__blocking}{level3\_blocking<Scalar,Scalar>}& blocking);
00046 \};
00047 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} Mode, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{int} TriStorageOrder>
00048 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} 
      \hyperlink{struct_eigen_1_1internal_1_1triangular__solve__matrix}{triangular\_solve\_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>::run}
      (
00049     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} otherSize,
00050     \textcolor{keyword}{const} Scalar* \_tri, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} triStride,
00051     Scalar* \_other, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} otherStride,
00052     \hyperlink{class_eigen_1_1internal_1_1level3__blocking}{level3\_blocking<Scalar,Scalar>}& blocking)
00053   \{
00054     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols = otherSize;
00055 
00056     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1const__blas__data__mapper}{const\_blas\_data\_mapper<Scalar, Index, TriStorageOrder>}
       TriMapper;
00057     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1blas__data__mapper}{blas\_data\_mapper<Scalar, Index, ColMajor>} OtherMapper;
00058     TriMapper tri(\_tri, triStride);
00059     OtherMapper other(\_other, otherStride);
00060 
00061     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1gebp__traits}{gebp\_traits<Scalar,Scalar>} Traits;
00062 
00063     \textcolor{keyword}{enum} \{
00064       SmallPanelWidth   = EIGEN\_PLAIN\_ENUM\_MAX(Traits::mr,Traits::nr),
00065       IsLower = (Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) == \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}
00066     \};
00067 
00068     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} kc = blocking.kc();                   \textcolor{comment}{// cache block size along the K direction}
00069     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} mc = (std::min)(size,blocking.mc());  \textcolor{comment}{// cache block size along the M direction}
00070 
00071     std::size\_t sizeA = kc*mc;
00072     std::size\_t sizeB = kc*cols;
00073 
00074     ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, blockA, sizeA, blocking.blockA());
00075     ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, blockB, sizeB, blocking.blockB());
00076 
00077     \hyperlink{struct_eigen_1_1internal_1_1conj__if}{conj\_if<Conjugate>} conj;
00078     
      \hyperlink{struct_eigen_1_1internal_1_1gebp__kernel}{gebp\_kernel<Scalar, Scalar, Index, OtherMapper, Traits::mr, Traits::nr, Conjugate, false>}
       \hyperlink{struct_eigen_1_1internal_1_1gebp__kernel}{gebp\_kernel};
00079     
      \hyperlink{struct_eigen_1_1internal_1_1gemm__pack__lhs}{gemm\_pack\_lhs<Scalar, Index, TriMapper, Traits::mr, Traits::LhsProgress, TriStorageOrder>}
       pack\_lhs;
00080     \hyperlink{struct_eigen_1_1internal_1_1gemm__pack__rhs}{gemm\_pack\_rhs<Scalar, Index, OtherMapper, Traits::nr, ColMajor, false, true>}
       pack\_rhs;
00081 
00082     \textcolor{comment}{// the goal here is to subdivise the Rhs panels such that we keep some cache}
00083     \textcolor{comment}{// coherence when accessing the rhs elements}
00084     std::ptrdiff\_t l1, l2, l3;
00085     manage\_caching\_sizes(GetAction, &l1, &l2, &l3);
00086     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} subcols = cols>0 ? l2/(4 * \textcolor{keyword}{sizeof}(Scalar) * std::max<Index>(otherStride,size)) : 0;
00087     subcols = std::max<Index>((subcols/Traits::nr)*Traits::nr, Traits::nr);
00088 
00089     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k2=IsLower ? 0 : size;
00090         IsLower ? k2<size : k2>0;
00091         IsLower ? k2+=kc : k2-=kc)
00092     \{
00093       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_kc = (std::min)(IsLower ? size-k2 : k2, kc);
00094 
00095       \textcolor{comment}{// We have selected and packed a big horizontal panel R1 of rhs. Let B be the packed copy of this
       panel,}
00096       \textcolor{comment}{// and R2 the remaining part of rhs. The corresponding vertical panel of lhs is split into}
00097       \textcolor{comment}{// A11 (the triangular part) and A21 the remaining rectangular part.}
00098       \textcolor{comment}{// Then the high level algorithm is:}
00099       \textcolor{comment}{//  - B = R1                    => general block copy (done during the next step)}
00100       \textcolor{comment}{//  - R1 = A11^-1 B             => tricky part}
00101       \textcolor{comment}{//  - update B from the new R1  => actually this has to be performed continuously during the above
       step}
00102       \textcolor{comment}{//  - R2 -= A21 * B             => GEPP}
00103 
00104       \textcolor{comment}{// The tricky part: compute R1 = A11^-1 B while updating B from R1}
00105       \textcolor{comment}{// The idea is to split A11 into multiple small vertical panels.}
00106       \textcolor{comment}{// Each panel can be split into a small triangular part T1k which is processed without optimization,}
00107       \textcolor{comment}{// and the remaining small part T2k which is processed using gebp with appropriate block strides}
00108       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=0; j2<cols; j2+=subcols)
00109       \{
00110         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_cols = (std::min)(cols-j2,subcols);
00111         \textcolor{comment}{// for each small vertical panels [T1k^T, T2k^T]^T of lhs}
00112         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k1=0; k1<actual\_kc; k1+=SmallPanelWidth)
00113         \{
00114           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actualPanelWidth = std::min<Index>(actual\_kc-k1, SmallPanelWidth);
00115           \textcolor{comment}{// tr solve}
00116           \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<actualPanelWidth; ++k)
00117           \{
00118             \textcolor{comment}{// TODO write a small kernel handling this (can be shared with trsv)}
00119             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i  = IsLower ? k2+k1+k : k2-k1-k-1;
00120             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rs = actualPanelWidth - k - 1; \textcolor{comment}{// remaining size}
00121             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} s  = TriStorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? (IsLower ? k2+k1 : i+1)
00122                                                  :  IsLower ? i+1 : i-rs;
00123 
00124             Scalar a = (Mode & \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaddb72f888ac85d5a1c52333e54f9374b}{UnitDiag}) ? Scalar(1) : Scalar(1)/conj(tri(i,i));
00125             \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=j2; j<j2+actual\_cols; ++j)
00126             \{
00127               \textcolor{keywordflow}{if} (TriStorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor})
00128               \{
00129                 Scalar b(0);
00130                 \textcolor{keyword}{const} Scalar* l = &tri(i,s);
00131                 Scalar* r = &other(s,j);
00132                 \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i3=0; i3<k; ++i3)
00133                   b += conj(l[i3]) * r[i3];
00134 
00135                 other(i,j) = (other(i,j) - b)*a;
00136               \}
00137               \textcolor{keywordflow}{else}
00138               \{
00139                 Scalar b = (other(i,j) *= a);
00140                 Scalar* r = &other(s,j);
00141                 \textcolor{keyword}{const} Scalar* l = &tri(s,i);
00142                 \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i3=0;i3<rs;++i3)
00143                   r[i3] -= b * conj(l[i3]);
00144               \}
00145             \}
00146           \}
00147 
00148           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lengthTarget = actual\_kc-k1-actualPanelWidth;
00149           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startBlock   = IsLower ? k2+k1 : k2-k1-actualPanelWidth;
00150           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} blockBOffset = IsLower ? k1 : lengthTarget;
00151 
00152           \textcolor{comment}{// update the respective rows of B from other}
00153           pack\_rhs(blockB+actual\_kc*j2, other.getSubMapper(startBlock,j2), actualPanelWidth, actual\_cols, 
      actual\_kc, blockBOffset);
00154 
00155           \textcolor{comment}{// GEBP}
00156           \textcolor{keywordflow}{if} (lengthTarget>0)
00157           \{
00158             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startTarget  = IsLower ? k2+k1+actualPanelWidth : k2-actual\_kc;
00159 
00160             pack\_lhs(blockA, tri.getSubMapper(startTarget,startBlock), actualPanelWidth, lengthTarget);
00161 
00162             gebp\_kernel(other.getSubMapper(startTarget,j2), blockA, blockB+actual\_kc*j2, lengthTarget, 
      actualPanelWidth, actual\_cols, Scalar(-1),
00163                         actualPanelWidth, actual\_kc, 0, blockBOffset);
00164           \}
00165         \}
00166       \}
00167       
00168       \textcolor{comment}{// R2 -= A21 * B => GEPP}
00169       \{
00170         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} start = IsLower ? k2+kc : 0;
00171         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} end   = IsLower ? size : k2-kc;
00172         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i2=start; i2<end; i2+=mc)
00173         \{
00174           \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_mc = (std::min)(mc,end-i2);
00175           \textcolor{keywordflow}{if} (actual\_mc>0)
00176           \{
00177             pack\_lhs(blockA, tri.getSubMapper(i2, IsLower ? k2 : k2-kc), actual\_kc, actual\_mc);
00178 
00179             gebp\_kernel(other.getSubMapper(i2, 0), blockA, blockB, actual\_mc, actual\_kc, cols, Scalar(-1), 
      -1, -1, 0, 0);
00180           \}
00181         \}
00182       \}
00183     \}
00184   \}
00185 
00186 \textcolor{comment}{/* Optimized triangular solver with multiple left hand sides and the triangular matrix on the right}
00187 \textcolor{comment}{ */}
00188 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} Mode, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{int} TriStorageOrder>
\Hypertarget{eigen_2_eigen_2src_2_core_2products_2_triangular_solver_matrix_8h_source_l00189}\hyperlink{struct_eigen_1_1internal_1_1triangular__solve__matrix_3_01_scalar_00_01_index_00_01_on_the_rightf2d31df4e035b9aff2381cc0bac19b97}{00189} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1triangular__solve__matrix}{triangular\_solve\_matrix}<Scalar,\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
      \hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b}{OnTheRight},Mode,\hyperlink{class_eigen_1_1_conjugate}{Conjugate},TriStorageOrder,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}>
00190 \{
00191   \textcolor{keyword}{static} EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} run(
00192     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} otherSize,
00193     \textcolor{keyword}{const} Scalar* \_tri, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} triStride,
00194     Scalar* \_other, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} otherStride,
00195     \hyperlink{class_eigen_1_1internal_1_1level3__blocking}{level3\_blocking<Scalar,Scalar>}& blocking);
00196 \};
00197 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} Mode, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{int} TriStorageOrder>
00198 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} 
      \hyperlink{struct_eigen_1_1internal_1_1triangular__solve__matrix}{triangular\_solve\_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>::run}
      (
00199     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} otherSize,
00200     \textcolor{keyword}{const} Scalar* \_tri, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} triStride,
00201     Scalar* \_other, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} otherStride,
00202     \hyperlink{class_eigen_1_1internal_1_1level3__blocking}{level3\_blocking<Scalar,Scalar>}& blocking)
00203   \{
00204     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows = otherSize;
00205     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00206 
00207     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1blas__data__mapper}{blas\_data\_mapper<Scalar, Index, ColMajor>} LhsMapper;
00208     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1const__blas__data__mapper}{const\_blas\_data\_mapper<Scalar, Index, TriStorageOrder>}
       RhsMapper;
00209     LhsMapper lhs(\_other, otherStride);
00210     RhsMapper rhs(\_tri, triStride);
00211 
00212     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1gebp__traits}{gebp\_traits<Scalar,Scalar>} Traits;
00213     \textcolor{keyword}{enum} \{
00214       RhsStorageOrder   = TriStorageOrder,
00215       SmallPanelWidth   = EIGEN\_PLAIN\_ENUM\_MAX(Traits::mr,Traits::nr),
00216       IsLower = (Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) == \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}
00217     \};
00218 
00219     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} kc = blocking.kc();                   \textcolor{comment}{// cache block size along the K direction}
00220     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} mc = (std::min)(rows,blocking.mc());  \textcolor{comment}{// cache block size along the M direction}
00221 
00222     std::size\_t sizeA = kc*mc;
00223     std::size\_t sizeB = kc*size;
00224 
00225     ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, blockA, sizeA, blocking.blockA());
00226     ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, blockB, sizeB, blocking.blockB());
00227 
00228     \hyperlink{struct_eigen_1_1internal_1_1conj__if}{conj\_if<Conjugate>} conj;
00229     
      \hyperlink{struct_eigen_1_1internal_1_1gebp__kernel}{gebp\_kernel<Scalar, Scalar, Index, LhsMapper, Traits::mr, Traits::nr, false, Conjugate>}
       \hyperlink{struct_eigen_1_1internal_1_1gebp__kernel}{gebp\_kernel};
00230     \hyperlink{struct_eigen_1_1internal_1_1gemm__pack__rhs}{gemm\_pack\_rhs<Scalar, Index, RhsMapper, Traits::nr, RhsStorageOrder>}
       pack\_rhs;
00231     
      \hyperlink{struct_eigen_1_1internal_1_1gemm__pack__rhs}{gemm\_pack\_rhs<Scalar, Index, RhsMapper, Traits::nr, RhsStorageOrder,false,true>}
       pack\_rhs\_panel;
00232     
      \hyperlink{struct_eigen_1_1internal_1_1gemm__pack__lhs}{gemm\_pack\_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, ColMajor, false, true>}
       pack\_lhs\_panel;
00233 
00234     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k2=IsLower ? size : 0;
00235         IsLower ? k2>0 : k2<size;
00236         IsLower ? k2-=kc : k2+=kc)
00237     \{
00238       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_kc = (std::min)(IsLower ? k2 : size-k2, kc);
00239       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_k2 = IsLower ? k2-actual\_kc : k2 ;
00240 
00241       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} startPanel = IsLower ? 0 : k2+actual\_kc;
00242       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rs = IsLower ? actual\_k2 : size - actual\_k2 - actual\_kc;
00243       Scalar* geb = blockB+actual\_kc*actual\_kc;
00244 
00245       \textcolor{keywordflow}{if} (rs>0) pack\_rhs(geb, rhs.getSubMapper(actual\_k2,startPanel), actual\_kc, rs);
00246 
00247       \textcolor{comment}{// triangular packing (we only pack the panels off the diagonal,}
00248       \textcolor{comment}{// neglecting the blocks overlapping the diagonal}
00249       \{
00250         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=0; j2<actual\_kc; j2+=SmallPanelWidth)
00251         \{
00252           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actualPanelWidth = std::min<Index>(actual\_kc-j2, SmallPanelWidth);
00253           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_j2 = actual\_k2 + j2;
00254           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} panelOffset = IsLower ? j2+actualPanelWidth : 0;
00255           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} panelLength = IsLower ? actual\_kc-j2-actualPanelWidth : j2;
00256 
00257           \textcolor{keywordflow}{if} (panelLength>0)
00258           pack\_rhs\_panel(blockB+j2*actual\_kc,
00259                          rhs.getSubMapper(actual\_k2+panelOffset, actual\_j2),
00260                          panelLength, actualPanelWidth,
00261                          actual\_kc, panelOffset);
00262         \}
00263       \}
00264 
00265       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i2=0; i2<rows; i2+=mc)
00266       \{
00267         \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_mc = (std::min)(mc,rows-i2);
00268 
00269         \textcolor{comment}{// triangular solver kernel}
00270         \{
00271           \textcolor{comment}{// for each small block of the diagonal (=> vertical panels of rhs)}
00272           \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2 = IsLower
00273                       ? (actual\_kc - ((actual\_kc%SmallPanelWidth) ? \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(actual\_kc%SmallPanelWidth)
00274                                                                   : \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(SmallPanelWidth)))
00275                       : 0;
00276                IsLower ? j2>=0 : j2<actual\_kc;
00277                IsLower ? j2-=SmallPanelWidth : j2+=SmallPanelWidth)
00278           \{
00279             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actualPanelWidth = std::min<Index>(actual\_kc-j2, SmallPanelWidth);
00280             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} absolute\_j2 = actual\_k2 + j2;
00281             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} panelOffset = IsLower ? j2+actualPanelWidth : 0;
00282             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} panelLength = IsLower ? actual\_kc - j2 - actualPanelWidth : j2;
00283 
00284             \textcolor{comment}{// GEBP}
00285             \textcolor{keywordflow}{if}(panelLength>0)
00286             \{
00287               gebp\_kernel(lhs.getSubMapper(i2,absolute\_j2),
00288                           blockA, blockB+j2*actual\_kc,
00289                           actual\_mc, panelLength, actualPanelWidth,
00290                           Scalar(-1),
00291                           actual\_kc, actual\_kc, \textcolor{comment}{// strides}
00292                           panelOffset, panelOffset); \textcolor{comment}{// offsets}
00293             \}
00294 
00295             \textcolor{comment}{// unblocked triangular solve}
00296             \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<actualPanelWidth; ++k)
00297             \{
00298               \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = IsLower ? absolute\_j2+actualPanelWidth-k-1 : absolute\_j2+k;
00299 
00300               Scalar* r = &lhs(i2,j);
00301               \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k3=0; k3<k; ++k3)
00302               \{
00303                 Scalar b = conj(rhs(IsLower ? j+1+k3 : absolute\_j2+k3,j));
00304                 Scalar* a = &lhs(i2,IsLower ? j+1+k3 : absolute\_j2+k3);
00305                 \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<actual\_mc; ++i)
00306                   r[i] -= a[i] * b;
00307               \}
00308               \textcolor{keywordflow}{if}((Mode & \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaddb72f888ac85d5a1c52333e54f9374b}{UnitDiag})==0)
00309               \{
00310                 Scalar inv\_rjj = RealScalar(1)/conj(rhs(j,j));
00311                 \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<actual\_mc; ++i)
00312                   r[i] *= inv\_rjj;
00313               \}
00314             \}
00315 
00316             \textcolor{comment}{// pack the just computed part of lhs to A}
00317             pack\_lhs\_panel(blockA, LhsMapper(\_other+absolute\_j2*otherStride+i2, otherStride),
00318                            actualPanelWidth, actual\_mc,
00319                            actual\_kc, j2);
00320           \}
00321         \}
00322 
00323         \textcolor{keywordflow}{if} (rs>0)
00324           gebp\_kernel(lhs.getSubMapper(i2, startPanel), blockA, geb,
00325                       actual\_mc, actual\_kc, rs, Scalar(-1),
00326                       -1, -1, 0, 0);
00327       \}
00328     \}
00329   \}
00330 
00331 \} \textcolor{comment}{// end namespace internal}
00332 
00333 \} \textcolor{comment}{// end namespace Eigen}
00334 
00335 \textcolor{preprocessor}{#endif // EIGEN\_TRIANGULAR\_SOLVER\_MATRIX\_H}
\end{DoxyCode}
