\hypertarget{zlib_2examples_2enough_8c_source}{}\section{zlib/examples/enough.c}
\label{zlib_2examples_2enough_8c_source}\index{enough.\+c@{enough.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* enough.c -- determine the maximum size of inflate's Huffman code tables over}
00002 \textcolor{comment}{ * all possible valid and complete Huffman codes, subject to a length limit.}
00003 \textcolor{comment}{ * Copyright (C) 2007, 2008, 2012 Mark Adler}
00004 \textcolor{comment}{ * Version 1.4  18 August 2012  Mark Adler}
00005 \textcolor{comment}{ */}
00006 
00007 \textcolor{comment}{/* Version history:}
00008 \textcolor{comment}{   1.0   3 Jan 2007  First version (derived from codecount.c version 1.4)}
00009 \textcolor{comment}{   1.1   4 Jan 2007  Use faster incremental table usage computation}
00010 \textcolor{comment}{                     Prune examine() search on previously visited states}
00011 \textcolor{comment}{   1.2   5 Jan 2007  Comments clean up}
00012 \textcolor{comment}{                     As inflate does, decrease root for short codes}
00013 \textcolor{comment}{                     Refuse cases where inflate would increase root}
00014 \textcolor{comment}{   1.3  17 Feb 2008  Add argument for initial root table size}
00015 \textcolor{comment}{                     Fix bug for initial root table size == max - 1}
00016 \textcolor{comment}{                     Use a macro to compute the history index}
00017 \textcolor{comment}{   1.4  18 Aug 2012  Avoid shifts more than bits in type (caused endless loop!)}
00018 \textcolor{comment}{                     Clean up comparisons of different types}
00019 \textcolor{comment}{                     Clean up code indentation}
00020 \textcolor{comment}{ */}
00021 
00022 \textcolor{comment}{/*}
00023 \textcolor{comment}{   Examine all possible Huffman codes for a given number of symbols and a}
00024 \textcolor{comment}{   maximum code length in bits to determine the maximum table size for zilb's}
00025 \textcolor{comment}{   inflate.  Only complete Huffman codes are counted.}
00026 \textcolor{comment}{}
00027 \textcolor{comment}{   Two codes are considered distinct if the vectors of the number of codes per}
00028 \textcolor{comment}{   length are not identical.  So permutations of the symbol assignments result}
00029 \textcolor{comment}{   in the same code for the counting, as do permutations of the assignments of}
00030 \textcolor{comment}{   the bit values to the codes (i.e. only canonical codes are counted).}
00031 \textcolor{comment}{}
00032 \textcolor{comment}{   We build a code from shorter to longer lengths, determining how many symbols}
00033 \textcolor{comment}{   are coded at each length.  At each step, we have how many symbols remain to}
00034 \textcolor{comment}{   be coded, what the last code length used was, and how many bit patterns of}
00035 \textcolor{comment}{   that length remain unused. Then we add one to the code length and double the}
00036 \textcolor{comment}{   number of unused patterns to graduate to the next code length.  We then}
00037 \textcolor{comment}{   assign all portions of the remaining symbols to that code length that}
00038 \textcolor{comment}{   preserve the properties of a correct and eventually complete code.  Those}
00039 \textcolor{comment}{   properties are: we cannot use more bit patterns than are available; and when}
00040 \textcolor{comment}{   all the symbols are used, there are exactly zero possible bit patterns}
00041 \textcolor{comment}{   remaining.}
00042 \textcolor{comment}{}
00043 \textcolor{comment}{   The inflate Huffman decoding algorithm uses two-level lookup tables for}
00044 \textcolor{comment}{   speed.  There is a single first-level table to decode codes up to root bits}
00045 \textcolor{comment}{   in length (root == 9 in the current inflate implementation).  The table}
00046 \textcolor{comment}{   has 1 << root entries and is indexed by the next root bits of input.  Codes}
00047 \textcolor{comment}{   shorter than root bits have replicated table entries, so that the correct}
00048 \textcolor{comment}{   entry is pointed to regardless of the bits that follow the short code.  If}
00049 \textcolor{comment}{   the code is longer than root bits, then the table entry points to a second-}
00050 \textcolor{comment}{   level table.  The size of that table is determined by the longest code with}
00051 \textcolor{comment}{   that root-bit prefix.  If that longest code has length len, then the table}
00052 \textcolor{comment}{   has size 1 << (len - root), to index the remaining bits in that set of}
00053 \textcolor{comment}{   codes.  Each subsequent root-bit prefix then has its own sub-table.  The}
00054 \textcolor{comment}{   total number of table entries required by the code is calculated}
00055 \textcolor{comment}{   incrementally as the number of codes at each bit length is populated.  When}
00056 \textcolor{comment}{   all of the codes are shorter than root bits, then root is reduced to the}
00057 \textcolor{comment}{   longest code length, resulting in a single, smaller, one-level table.}
00058 \textcolor{comment}{}
00059 \textcolor{comment}{   The inflate algorithm also provides for small values of root (relative to}
00060 \textcolor{comment}{   the log2 of the number of symbols), where the shortest code has more bits}
00061 \textcolor{comment}{   than root.  In that case, root is increased to the length of the shortest}
00062 \textcolor{comment}{   code.  This program, by design, does not handle that case, so it is verified}
00063 \textcolor{comment}{   that the number of symbols is less than 2^(root + 1).}
00064 \textcolor{comment}{}
00065 \textcolor{comment}{   In order to speed up the examination (by about ten orders of magnitude for}
00066 \textcolor{comment}{   the default arguments), the intermediate states in the build-up of a code}
00067 \textcolor{comment}{   are remembered and previously visited branches are pruned.  The memory}
00068 \textcolor{comment}{   required for this will increase rapidly with the total number of symbols and}
00069 \textcolor{comment}{   the maximum code length in bits.  However this is a very small price to pay}
00070 \textcolor{comment}{   for the vast speedup.}
00071 \textcolor{comment}{}
00072 \textcolor{comment}{   First, all of the possible Huffman codes are counted, and reachable}
00073 \textcolor{comment}{   intermediate states are noted by a non-zero count in a saved-results array.}
00074 \textcolor{comment}{   Second, the intermediate states that lead to (root + 1) bit or longer codes}
00075 \textcolor{comment}{   are used to look at all sub-codes from those junctures for their inflate}
00076 \textcolor{comment}{   memory usage.  (The amount of memory used is not affected by the number of}
00077 \textcolor{comment}{   codes of root bits or less in length.)  Third, the visited states in the}
00078 \textcolor{comment}{   construction of those sub-codes and the associated calculation of the table}
00079 \textcolor{comment}{   size is recalled in order to avoid recalculating from the same juncture.}
00080 \textcolor{comment}{   Beginning the code examination at (root + 1) bit codes, which is enabled by}
00081 \textcolor{comment}{   identifying the reachable nodes, accounts for about six of the orders of}
00082 \textcolor{comment}{   magnitude of improvement for the default arguments.  About another four}
00083 \textcolor{comment}{   orders of magnitude come from not revisiting previous states.  Out of}
00084 \textcolor{comment}{   approximately 2x10^16 possible Huffman codes, only about 2x10^6 sub-codes}
00085 \textcolor{comment}{   need to be examined to cover all of the possible table memory usage cases}
00086 \textcolor{comment}{   for the default arguments of 286 symbols limited to 15-bit codes.}
00087 \textcolor{comment}{}
00088 \textcolor{comment}{   Note that an unsigned long long type is used for counting.  It is quite easy}
00089 \textcolor{comment}{   to exceed the capacity of an eight-byte integer with a large number of}
00090 \textcolor{comment}{   symbols and a large maximum code length, so multiple-precision arithmetic}
00091 \textcolor{comment}{   would need to replace the unsigned long long arithmetic in that case.  This}
00092 \textcolor{comment}{   program will abort if an overflow occurs.  The big\_t type identifies where}
00093 \textcolor{comment}{   the counting takes place.}
00094 \textcolor{comment}{}
00095 \textcolor{comment}{   An unsigned long long type is also used for calculating the number of}
00096 \textcolor{comment}{   possible codes remaining at the maximum length.  This limits the maximum}
00097 \textcolor{comment}{   code length to the number of bits in a long long minus the number of bits}
00098 \textcolor{comment}{   needed to represent the symbols in a flat code.  The code\_t type identifies}
00099 \textcolor{comment}{   where the bit pattern counting takes place.}
00100 \textcolor{comment}{ */}
00101 
00102 \textcolor{preprocessor}{#include <stdio.h>}
00103 \textcolor{preprocessor}{#include <stdlib.h>}
00104 \textcolor{preprocessor}{#include <string.h>}
00105 \textcolor{preprocessor}{#include <assert.h>}
00106 
00107 \textcolor{preprocessor}{#define local static}
00108 
00109 \textcolor{comment}{/* special data types */}
00110 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} big\_t;   \textcolor{comment}{/* type for code counting */}
00111 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} code\_t;  \textcolor{comment}{/* type for bit pattern counting */}
00112 \textcolor{keyword}{struct }\hyperlink{structtab}{tab} \{                        \textcolor{comment}{/* type for been here check */}
00113     \textcolor{keywordtype}{size\_t} len;         \textcolor{comment}{/* length of bit vector in char's */}
00114     \textcolor{keywordtype}{char} *vec;          \textcolor{comment}{/* allocated bit vector */}
00115 \};
00116 
00117 \textcolor{comment}{/* The array for saving results, num[], is indexed with this triplet:}
00118 \textcolor{comment}{}
00119 \textcolor{comment}{      syms: number of symbols remaining to code}
00120 \textcolor{comment}{      left: number of available bit patterns at length len}
00121 \textcolor{comment}{      len: number of bits in the codes currently being assigned}
00122 \textcolor{comment}{}
00123 \textcolor{comment}{   Those indices are constrained thusly when saving results:}
00124 \textcolor{comment}{}
00125 \textcolor{comment}{      syms: 3..totsym (totsym == total symbols to code)}
00126 \textcolor{comment}{      left: 2..syms - 1, but only the evens (so syms == 8 -> 2, 4, 6)}
00127 \textcolor{comment}{      len: 1..max - 1 (max == maximum code length in bits)}
00128 \textcolor{comment}{}
00129 \textcolor{comment}{   syms == 2 is not saved since that immediately leads to a single code.  left}
00130 \textcolor{comment}{   must be even, since it represents the number of available bit patterns at}
00131 \textcolor{comment}{   the current length, which is double the number at the previous length.}
00132 \textcolor{comment}{   left ends at syms-1 since left == syms immediately results in a single code.}
00133 \textcolor{comment}{   (left > sym is not allowed since that would result in an incomplete code.)}
00134 \textcolor{comment}{   len is less than max, since the code completes immediately when len == max.}
00135 \textcolor{comment}{}
00136 \textcolor{comment}{   The offset into the array is calculated for the three indices with the}
00137 \textcolor{comment}{   first one (syms) being outermost, and the last one (len) being innermost.}
00138 \textcolor{comment}{   We build the array with length max-1 lists for the len index, with syms-3}
00139 \textcolor{comment}{   of those for each symbol.  There are totsym-2 of those, with each one}
00140 \textcolor{comment}{   varying in length as a function of sym.  See the calculation of index in}
00141 \textcolor{comment}{   count() for the index, and the calculation of size in main() for the size}
00142 \textcolor{comment}{   of the array.}
00143 \textcolor{comment}{}
00144 \textcolor{comment}{   For the deflate example of 286 symbols limited to 15-bit codes, the array}
00145 \textcolor{comment}{   has 284,284 entries, taking up 2.17 MB for an 8-byte big\_t.  More than}
00146 \textcolor{comment}{   half of the space allocated for saved results is actually used -- not all}
00147 \textcolor{comment}{   possible triplets are reached in the generation of valid Huffman codes.}
00148 \textcolor{comment}{ */}
00149 
00150 \textcolor{comment}{/* The array for tracking visited states, done[], is itself indexed identically}
00151 \textcolor{comment}{   to the num[] array as described above for the (syms, left, len) triplet.}
00152 \textcolor{comment}{   Each element in the array is further indexed by the (mem, rem) doublet,}
00153 \textcolor{comment}{   where mem is the amount of inflate table space used so far, and rem is the}
00154 \textcolor{comment}{   remaining unused entries in the current inflate sub-table.  Each indexed}
00155 \textcolor{comment}{   element is simply one bit indicating whether the state has been visited or}
00156 \textcolor{comment}{   not.  Since the ranges for mem and rem are not known a priori, each bit}
00157 \textcolor{comment}{   vector is of a variable size, and grows as needed to accommodate the visited}
00158 \textcolor{comment}{   states.  mem and rem are used to calculate a single index in a triangular}
00159 \textcolor{comment}{   array.  Since the range of mem is expected in the default case to be about}
00160 \textcolor{comment}{   ten times larger than the range of rem, the array is skewed to reduce the}
00161 \textcolor{comment}{   memory usage, with eight times the range for mem than for rem.  See the}
00162 \textcolor{comment}{   calculations for offset and bit in beenhere() for the details.}
00163 \textcolor{comment}{}
00164 \textcolor{comment}{   For the deflate example of 286 symbols limited to 15-bit codes, the bit}
00165 \textcolor{comment}{   vectors grow to total approximately 21 MB, in addition to the 4.3 MB done[]}
00166 \textcolor{comment}{   array itself.}
00167 \textcolor{comment}{ */}
00168 
00169 \textcolor{comment}{/* Globals to avoid propagating constants or constant pointers recursively */}
00170 local \textcolor{keywordtype}{int} max;          \textcolor{comment}{/* maximum allowed bit length for the codes */}
00171 local \textcolor{keywordtype}{int} root;         \textcolor{comment}{/* size of base code table in bits */}
00172 local \textcolor{keywordtype}{int} large;        \textcolor{comment}{/* largest code table so far */}
00173 local \textcolor{keywordtype}{size\_t} size;      \textcolor{comment}{/* number of elements in num and done */}
00174 local \textcolor{keywordtype}{int} *\hyperlink{structcode}{code};        \textcolor{comment}{/* number of symbols assigned to each bit length */}
00175 local big\_t *num;       \textcolor{comment}{/* saved results array for code counting */}
00176 local \textcolor{keyword}{struct }\hyperlink{structtab}{tab} *done; \textcolor{comment}{/* states already evaluated array */}
00177 
00178 \textcolor{comment}{/* Index function for num[] and done[] */}
00179 \textcolor{preprocessor}{#define INDEX(i,j,k) (((size\_t)((i-1)>>1)*((i-2)>>1)+(j>>1)-1)*(max-1)+k-1)}
00180 
00181 \textcolor{comment}{/* Free allocated space.  Uses globals code, num, and done. */}
00182 local \textcolor{keywordtype}{void} cleanup(\textcolor{keywordtype}{void})
00183 \{
00184     \textcolor{keywordtype}{size\_t} n;
00185 
00186     \textcolor{keywordflow}{if} (done != NULL) \{
00187         \textcolor{keywordflow}{for} (n = 0; n < size; n++)
00188             \textcolor{keywordflow}{if} (done[n].len)
00189                 free(done[n].vec);
00190         free(done);
00191     \}
00192     \textcolor{keywordflow}{if} (num != NULL)
00193         free(num);
00194     \textcolor{keywordflow}{if} (\hyperlink{structcode}{code} != NULL)
00195         free(\hyperlink{structcode}{code});
00196 \}
00197 
00198 \textcolor{comment}{/* Return the number of possible Huffman codes using bit patterns of lengths}
00199 \textcolor{comment}{   len through max inclusive, coding syms symbols, with left bit patterns of}
00200 \textcolor{comment}{   length len unused -- return -1 if there is an overflow in the counting.}
00201 \textcolor{comment}{   Keep a record of previous results in num to prevent repeating the same}
00202 \textcolor{comment}{   calculation.  Uses the globals max and num. */}
00203 local big\_t count(\textcolor{keywordtype}{int} syms, \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{int} left)
00204 \{
00205     big\_t sum;          \textcolor{comment}{/* number of possible codes from this juncture */}
00206     big\_t got;          \textcolor{comment}{/* value returned from count() */}
00207     \textcolor{keywordtype}{int} least;          \textcolor{comment}{/* least number of syms to use at this juncture */}
00208     \textcolor{keywordtype}{int} most;           \textcolor{comment}{/* most number of syms to use at this juncture */}
00209     \textcolor{keywordtype}{int} use;            \textcolor{comment}{/* number of bit patterns to use in next call */}
00210     \textcolor{keywordtype}{size\_t} index;       \textcolor{comment}{/* index of this case in *num */}
00211 
00212     \textcolor{comment}{/* see if only one possible code */}
00213     \textcolor{keywordflow}{if} (syms == left)
00214         \textcolor{keywordflow}{return} 1;
00215 
00216     \textcolor{comment}{/* note and verify the expected state */}
00217     assert(syms > left && left > 0 && len < max);
00218 
00219     \textcolor{comment}{/* see if we've done this one already */}
00220     index = INDEX(syms, left, len);
00221     got = num[index];
00222     \textcolor{keywordflow}{if} (got)
00223         \textcolor{keywordflow}{return} got;         \textcolor{comment}{/* we have -- return the saved result */}
00224 
00225     \textcolor{comment}{/* we need to use at least this many bit patterns so that the code won't be}
00226 \textcolor{comment}{       incomplete at the next length (more bit patterns than symbols) */}
00227     least = (left << 1) - syms;
00228     \textcolor{keywordflow}{if} (least < 0)
00229         least = 0;
00230 
00231     \textcolor{comment}{/* we can use at most this many bit patterns, lest there not be enough}
00232 \textcolor{comment}{       available for the remaining symbols at the maximum length (if there were}
00233 \textcolor{comment}{       no limit to the code length, this would become: most = left - 1) */}
00234     most = (((code\_t)left << (max - len)) - syms) /
00235             (((code\_t)1 << (max - len)) - 1);
00236 
00237     \textcolor{comment}{/* count all possible codes from this juncture and add them up */}
00238     sum = 0;
00239     \textcolor{keywordflow}{for} (use = least; use <= most; use++) \{
00240         got = count(syms - use, len + 1, (left - use) << 1);
00241         sum += got;
00242         \textcolor{keywordflow}{if} (got == (big\_t)0 - 1 || sum < got)   \textcolor{comment}{/* overflow */}
00243             \textcolor{keywordflow}{return} (big\_t)0 - 1;
00244     \}
00245 
00246     \textcolor{comment}{/* verify that all recursive calls are productive */}
00247     assert(sum != 0);
00248 
00249     \textcolor{comment}{/* save the result and return it */}
00250     num[index] = sum;
00251     \textcolor{keywordflow}{return} sum;
00252 \}
00253 
00254 \textcolor{comment}{/* Return true if we've been here before, set to true if not.  Set a bit in a}
00255 \textcolor{comment}{   bit vector to indicate visiting this state.  Each (syms,len,left) state}
00256 \textcolor{comment}{   has a variable size bit vector indexed by (mem,rem).  The bit vector is}
00257 \textcolor{comment}{   lengthened if needed to allow setting the (mem,rem) bit. */}
00258 local \textcolor{keywordtype}{int} beenhere(\textcolor{keywordtype}{int} syms, \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{int} left, \textcolor{keywordtype}{int} mem, \textcolor{keywordtype}{int} rem)
00259 \{
00260     \textcolor{keywordtype}{size\_t} index;       \textcolor{comment}{/* index for this state's bit vector */}
00261     \textcolor{keywordtype}{size\_t} offset;      \textcolor{comment}{/* offset in this state's bit vector */}
00262     \textcolor{keywordtype}{int} bit;            \textcolor{comment}{/* mask for this state's bit */}
00263     \textcolor{keywordtype}{size\_t} length;      \textcolor{comment}{/* length of the bit vector in bytes */}
00264     \textcolor{keywordtype}{char} *vector;       \textcolor{comment}{/* new or enlarged bit vector */}
00265 
00266     \textcolor{comment}{/* point to vector for (syms,left,len), bit in vector for (mem,rem) */}
00267     index = INDEX(syms, left, len);
00268     mem -= 1 << root;
00269     offset = (mem >> 3) + rem;
00270     offset = ((offset * (offset + 1)) >> 1) + rem;
00271     bit = 1 << (mem & 7);
00272 
00273     \textcolor{comment}{/* see if we've been here */}
00274     length = done[index].len;
00275     \textcolor{keywordflow}{if} (offset < length && (done[index].vec[offset] & bit) != 0)
00276         \textcolor{keywordflow}{return} 1;       \textcolor{comment}{/* done this! */}
00277 
00278     \textcolor{comment}{/* we haven't been here before -- set the bit to show we have now */}
00279 
00280     \textcolor{comment}{/* see if we need to lengthen the vector in order to set the bit */}
00281     \textcolor{keywordflow}{if} (length <= offset) \{
00282         \textcolor{comment}{/* if we have one already, enlarge it, zero out the appended space */}
00283         \textcolor{keywordflow}{if} (length) \{
00284             \textcolor{keywordflow}{do} \{
00285                 length <<= 1;
00286             \} \textcolor{keywordflow}{while} (length <= offset);
00287             vector = realloc(done[index].vec, length);
00288             \textcolor{keywordflow}{if} (vector != NULL)
00289                 memset(vector + done[index].len, 0, length - done[index].len);
00290         \}
00291 
00292         \textcolor{comment}{/* otherwise we need to make a new vector and zero it out */}
00293         \textcolor{keywordflow}{else} \{
00294             length = 1 << (len - root);
00295             \textcolor{keywordflow}{while} (length <= offset)
00296                 length <<= 1;
00297             vector = calloc(length, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}));
00298         \}
00299 
00300         \textcolor{comment}{/* in either case, bail if we can't get the memory */}
00301         \textcolor{keywordflow}{if} (vector == NULL) \{
00302             fputs(\textcolor{stringliteral}{"abort: unable to allocate enough memory\(\backslash\)n"}, stderr);
00303             cleanup();
00304             exit(1);
00305         \}
00306 
00307         \textcolor{comment}{/* install the new vector */}
00308         done[index].len = length;
00309         done[index].vec = vector;
00310     \}
00311 
00312     \textcolor{comment}{/* set the bit */}
00313     done[index].vec[offset] |= bit;
00314     \textcolor{keywordflow}{return} 0;
00315 \}
00316 
00317 \textcolor{comment}{/* Examine all possible codes from the given node (syms, len, left).  Compute}
00318 \textcolor{comment}{   the amount of memory required to build inflate's decoding tables, where the}
00319 \textcolor{comment}{   number of code structures used so far is mem, and the number remaining in}
00320 \textcolor{comment}{   the current sub-table is rem.  Uses the globals max, code, root, large, and}
00321 \textcolor{comment}{   done. */}
00322 local \textcolor{keywordtype}{void} examine(\textcolor{keywordtype}{int} syms, \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{int} left, \textcolor{keywordtype}{int} mem, \textcolor{keywordtype}{int} rem)
00323 \{
00324     \textcolor{keywordtype}{int} least;          \textcolor{comment}{/* least number of syms to use at this juncture */}
00325     \textcolor{keywordtype}{int} most;           \textcolor{comment}{/* most number of syms to use at this juncture */}
00326     \textcolor{keywordtype}{int} use;            \textcolor{comment}{/* number of bit patterns to use in next call */}
00327 
00328     \textcolor{comment}{/* see if we have a complete code */}
00329     \textcolor{keywordflow}{if} (syms == left) \{
00330         \textcolor{comment}{/* set the last code entry */}
00331         \hyperlink{structcode}{code}[len] = left;
00332 
00333         \textcolor{comment}{/* complete computation of memory used by this code */}
00334         \textcolor{keywordflow}{while} (rem < left) \{
00335             left -= rem;
00336             rem = 1 << (len - root);
00337             mem += rem;
00338         \}
00339         assert(rem == left);
00340 
00341         \textcolor{comment}{/* if this is a new maximum, show the entries used and the sub-code */}
00342         \textcolor{keywordflow}{if} (mem > large) \{
00343             large = mem;
00344             printf(\textcolor{stringliteral}{"max %d: "}, mem);
00345             \textcolor{keywordflow}{for} (use = root + 1; use <= max; use++)
00346                 \textcolor{keywordflow}{if} (\hyperlink{structcode}{code}[use])
00347                     printf(\textcolor{stringliteral}{"%d[%d] "}, \hyperlink{structcode}{code}[use], use);
00348             putchar(\textcolor{charliteral}{'\(\backslash\)n'});
00349             fflush(stdout);
00350         \}
00351 
00352         \textcolor{comment}{/* remove entries as we drop back down in the recursion */}
00353         \hyperlink{structcode}{code}[len] = 0;
00354         \textcolor{keywordflow}{return};
00355     \}
00356 
00357     \textcolor{comment}{/* prune the tree if we can */}
00358     \textcolor{keywordflow}{if} (beenhere(syms, len, left, mem, rem))
00359         \textcolor{keywordflow}{return};
00360 
00361     \textcolor{comment}{/* we need to use at least this many bit patterns so that the code won't be}
00362 \textcolor{comment}{       incomplete at the next length (more bit patterns than symbols) */}
00363     least = (left << 1) - syms;
00364     \textcolor{keywordflow}{if} (least < 0)
00365         least = 0;
00366 
00367     \textcolor{comment}{/* we can use at most this many bit patterns, lest there not be enough}
00368 \textcolor{comment}{       available for the remaining symbols at the maximum length (if there were}
00369 \textcolor{comment}{       no limit to the code length, this would become: most = left - 1) */}
00370     most = (((code\_t)left << (max - len)) - syms) /
00371             (((code\_t)1 << (max - len)) - 1);
00372 
00373     \textcolor{comment}{/* occupy least table spaces, creating new sub-tables as needed */}
00374     use = least;
00375     \textcolor{keywordflow}{while} (rem < use) \{
00376         use -= rem;
00377         rem = 1 << (len - root);
00378         mem += rem;
00379     \}
00380     rem -= use;
00381 
00382     \textcolor{comment}{/* examine codes from here, updating table space as we go */}
00383     \textcolor{keywordflow}{for} (use = least; use <= most; use++) \{
00384         \hyperlink{structcode}{code}[len] = use;
00385         examine(syms - use, len + 1, (left - use) << 1,
00386                 mem + (rem ? 1 << (len - root) : 0), rem << 1);
00387         \textcolor{keywordflow}{if} (rem == 0) \{
00388             rem = 1 << (len - root);
00389             mem += rem;
00390         \}
00391         rem--;
00392     \}
00393 
00394     \textcolor{comment}{/* remove entries as we drop back down in the recursion */}
00395     \hyperlink{structcode}{code}[len] = 0;
00396 \}
00397 
00398 \textcolor{comment}{/* Look at all sub-codes starting with root + 1 bits.  Look at only the valid}
00399 \textcolor{comment}{   intermediate code states (syms, left, len).  For each completed code,}
00400 \textcolor{comment}{   calculate the amount of memory required by inflate to build the decoding}
00401 \textcolor{comment}{   tables. Find the maximum amount of memory required and show the code that}
00402 \textcolor{comment}{   requires that maximum.  Uses the globals max, root, and num. */}
00403 local \textcolor{keywordtype}{void} enough(\textcolor{keywordtype}{int} syms)
00404 \{
00405     \textcolor{keywordtype}{int} n;              \textcolor{comment}{/* number of remaing symbols for this node */}
00406     \textcolor{keywordtype}{int} left;           \textcolor{comment}{/* number of unused bit patterns at this length */}
00407     \textcolor{keywordtype}{size\_t} index;       \textcolor{comment}{/* index of this case in *num */}
00408 
00409     \textcolor{comment}{/* clear code */}
00410     \textcolor{keywordflow}{for} (n = 0; n <= max; n++)
00411         \hyperlink{structcode}{code}[n] = 0;
00412 
00413     \textcolor{comment}{/* look at all (root + 1) bit and longer codes */}
00414     large = 1 << root;              \textcolor{comment}{/* base table */}
00415     \textcolor{keywordflow}{if} (root < max)                 \textcolor{comment}{/* otherwise, there's only a base table */}
00416         \textcolor{keywordflow}{for} (n = 3; n <= syms; n++)
00417             \textcolor{keywordflow}{for} (left = 2; left < n; left += 2)
00418             \{
00419                 \textcolor{comment}{/* look at all reachable (root + 1) bit nodes, and the}
00420 \textcolor{comment}{                   resulting codes (complete at root + 2 or more) */}
00421                 index = INDEX(n, left, root + 1);
00422                 \textcolor{keywordflow}{if} (root + 1 < max && num[index])       \textcolor{comment}{/* reachable node */}
00423                     examine(n, root + 1, left, 1 << root, 0);
00424 
00425                 \textcolor{comment}{/* also look at root bit codes with completions at root + 1}
00426 \textcolor{comment}{                   bits (not saved in num, since complete), just in case */}
00427                 \textcolor{keywordflow}{if} (num[index - 1] && n <= left << 1)
00428                     examine((n - left) << 1, root + 1, (n - left) << 1,
00429                             1 << root, 0);
00430             \}
00431 
00432     \textcolor{comment}{/* done */}
00433     printf(\textcolor{stringliteral}{"done: maximum of %d table entries\(\backslash\)n"}, large);
00434 \}
00435 
00436 \textcolor{comment}{/*}
00437 \textcolor{comment}{   Examine and show the total number of possible Huffman codes for a given}
00438 \textcolor{comment}{   maximum number of symbols, initial root table size, and maximum code length}
00439 \textcolor{comment}{   in bits -- those are the command arguments in that order.  The default}
00440 \textcolor{comment}{   values are 286, 9, and 15 respectively, for the deflate literal/length code.}
00441 \textcolor{comment}{   The possible codes are counted for each number of coded symbols from two to}
00442 \textcolor{comment}{   the maximum.  The counts for each of those and the total number of codes are}
00443 \textcolor{comment}{   shown.  The maximum number of inflate table entires is then calculated}
00444 \textcolor{comment}{   across all possible codes.  Each new maximum number of table entries and the}
00445 \textcolor{comment}{   associated sub-code (starting at root + 1 == 10 bits) is shown.}
00446 \textcolor{comment}{}
00447 \textcolor{comment}{   To count and examine Huffman codes that are not length-limited, provide a}
00448 \textcolor{comment}{   maximum length equal to the number of symbols minus one.}
00449 \textcolor{comment}{}
00450 \textcolor{comment}{   For the deflate literal/length code, use "enough".  For the deflate distance}
00451 \textcolor{comment}{   code, use "enough 30 6".}
00452 \textcolor{comment}{}
00453 \textcolor{comment}{   This uses the %llu printf format to print big\_t numbers, which assumes that}
00454 \textcolor{comment}{   big\_t is an unsigned long long.  If the big\_t type is changed (for example}
00455 \textcolor{comment}{   to a multiple precision type), the method of printing will also need to be}
00456 \textcolor{comment}{   updated.}
00457 \textcolor{comment}{ */}
00458 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
00459 \{
00460     \textcolor{keywordtype}{int} syms;           \textcolor{comment}{/* total number of symbols to code */}
00461     \textcolor{keywordtype}{int} n;              \textcolor{comment}{/* number of symbols to code for this run */}
00462     big\_t got;          \textcolor{comment}{/* return value of count() */}
00463     big\_t sum;          \textcolor{comment}{/* accumulated number of codes over n */}
00464     code\_t word;        \textcolor{comment}{/* for counting bits in code\_t */}
00465 
00466     \textcolor{comment}{/* set up globals for cleanup() */}
00467     \hyperlink{structcode}{code} = NULL;
00468     num = NULL;
00469     done = NULL;
00470 
00471     \textcolor{comment}{/* get arguments -- default to the deflate literal/length code */}
00472     syms = 286;
00473     root = 9;
00474     max = 15;
00475     \textcolor{keywordflow}{if} (argc > 1) \{
00476         syms = atoi(argv[1]);
00477         \textcolor{keywordflow}{if} (argc > 2) \{
00478             root = atoi(argv[2]);
00479             \textcolor{keywordflow}{if} (argc > 3)
00480                 max = atoi(argv[3]);
00481         \}
00482     \}
00483     \textcolor{keywordflow}{if} (argc > 4 || syms < 2 || root < 1 || max < 1) \{
00484         fputs(\textcolor{stringliteral}{"invalid arguments, need: [sym >= 2 [root >= 1 [max >= 1]]]\(\backslash\)n"},
00485               stderr);
00486         \textcolor{keywordflow}{return} 1;
00487     \}
00488 
00489     \textcolor{comment}{/* if not restricting the code length, the longest is syms - 1 */}
00490     \textcolor{keywordflow}{if} (max > syms - 1)
00491         max = syms - 1;
00492 
00493     \textcolor{comment}{/* determine the number of bits in a code\_t */}
00494     \textcolor{keywordflow}{for} (n = 0, word = 1; word; n++, word <<= 1)
00495         ;
00496 
00497     \textcolor{comment}{/* make sure that the calculation of most will not overflow */}
00498     \textcolor{keywordflow}{if} (max > n || (code\_t)(syms - 2) >= (((code\_t)0 - 1) >> (max - 1))) \{
00499         fputs(\textcolor{stringliteral}{"abort: code length too long for internal types\(\backslash\)n"}, stderr);
00500         \textcolor{keywordflow}{return} 1;
00501     \}
00502 
00503     \textcolor{comment}{/* reject impossible code requests */}
00504     \textcolor{keywordflow}{if} ((code\_t)(syms - 1) > ((code\_t)1 << max) - 1) \{
00505         fprintf(stderr, \textcolor{stringliteral}{"%d symbols cannot be coded in %d bits\(\backslash\)n"},
00506                 syms, max);
00507         \textcolor{keywordflow}{return} 1;
00508     \}
00509 
00510     \textcolor{comment}{/* allocate code vector */}
00511     \hyperlink{structcode}{code} = calloc(max + 1, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
00512     \textcolor{keywordflow}{if} (\hyperlink{structcode}{code} == NULL) \{
00513         fputs(\textcolor{stringliteral}{"abort: unable to allocate enough memory\(\backslash\)n"}, stderr);
00514         \textcolor{keywordflow}{return} 1;
00515     \}
00516 
00517     \textcolor{comment}{/* determine size of saved results array, checking for overflows,}
00518 \textcolor{comment}{       allocate and clear the array (set all to zero with calloc()) */}
00519     \textcolor{keywordflow}{if} (syms == 2)              \textcolor{comment}{/* iff max == 1 */}
00520         num = NULL;             \textcolor{comment}{/* won't be saving any results */}
00521     \textcolor{keywordflow}{else} \{
00522         size = syms >> 1;
00523         \textcolor{keywordflow}{if} (size > ((\textcolor{keywordtype}{size\_t})0 - 1) / (n = (syms - 1) >> 1) ||
00524                 (size *= n, size > ((\textcolor{keywordtype}{size\_t})0 - 1) / (n = max - 1)) ||
00525                 (size *= n, size > ((\textcolor{keywordtype}{size\_t})0 - 1) / \textcolor{keyword}{sizeof}(big\_t)) ||
00526                 (num = calloc(size, \textcolor{keyword}{sizeof}(big\_t))) == NULL) \{
00527             fputs(\textcolor{stringliteral}{"abort: unable to allocate enough memory\(\backslash\)n"}, stderr);
00528             cleanup();
00529             \textcolor{keywordflow}{return} 1;
00530         \}
00531     \}
00532 
00533     \textcolor{comment}{/* count possible codes for all numbers of symbols, add up counts */}
00534     sum = 0;
00535     \textcolor{keywordflow}{for} (n = 2; n <= syms; n++) \{
00536         got = count(n, 1, 2);
00537         sum += got;
00538         \textcolor{keywordflow}{if} (got == (big\_t)0 - 1 || sum < got) \{     \textcolor{comment}{/* overflow */}
00539             fputs(\textcolor{stringliteral}{"abort: can't count that high!\(\backslash\)n"}, stderr);
00540             cleanup();
00541             \textcolor{keywordflow}{return} 1;
00542         \}
00543         printf(\textcolor{stringliteral}{"%llu %d-codes\(\backslash\)n"}, got, n);
00544     \}
00545     printf(\textcolor{stringliteral}{"%llu total codes for 2 to %d symbols"}, sum, syms);
00546     \textcolor{keywordflow}{if} (max < syms - 1)
00547         printf(\textcolor{stringliteral}{" (%d-bit length limit)\(\backslash\)n"}, max);
00548     \textcolor{keywordflow}{else}
00549         puts(\textcolor{stringliteral}{" (no length limit)"});
00550 
00551     \textcolor{comment}{/* allocate and clear done array for beenhere() */}
00552     \textcolor{keywordflow}{if} (syms == 2)
00553         done = NULL;
00554     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (size > ((\textcolor{keywordtype}{size\_t})0 - 1) / \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structtab}{tab}) ||
00555              (done = calloc(size, \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structtab}{tab}))) == NULL) \{
00556         fputs(\textcolor{stringliteral}{"abort: unable to allocate enough memory\(\backslash\)n"}, stderr);
00557         cleanup();
00558         \textcolor{keywordflow}{return} 1;
00559     \}
00560 
00561     \textcolor{comment}{/* find and show maximum inflate table usage */}
00562     \textcolor{keywordflow}{if} (root > max)                 \textcolor{comment}{/* reduce root to max length */}
00563         root = max;
00564     \textcolor{keywordflow}{if} ((code\_t)syms < ((code\_t)1 << (root + 1)))
00565         enough(syms);
00566     \textcolor{keywordflow}{else}
00567         puts(\textcolor{stringliteral}{"cannot handle minimum code lengths > root"});
00568 
00569     \textcolor{comment}{/* done */}
00570     cleanup();
00571     \textcolor{keywordflow}{return} 0;
00572 \}
\end{DoxyCode}
