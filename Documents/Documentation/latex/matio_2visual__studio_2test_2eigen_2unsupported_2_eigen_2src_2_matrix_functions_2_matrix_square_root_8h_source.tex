\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_square_root_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+Matrix\+Functions/\+Matrix\+Square\+Root.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_square_root_8h_source}\index{Matrix\+Square\+Root.\+h@{Matrix\+Square\+Root.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2011, 2013 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_MATRIX\_SQUARE\_ROOT}
00011 \textcolor{preprocessor}{#define EIGEN\_MATRIX\_SQUARE\_ROOT}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{comment}{// pre:  T.block(i,i,2,2) has complex conjugate eigenvalues}
00018 \textcolor{comment}{// post: sqrtT.block(i,i,2,2) is square root of T.block(i,i,2,2)}
00019 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ResultType>
00020 \textcolor{keywordtype}{void} matrix\_sqrt\_quasi\_triangular\_2x2\_diagonal\_block(\textcolor{keyword}{const} MatrixType& \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \textcolor{keyword}{typename} MatrixType::Index i, 
      ResultType& sqrtT)
00021 \{
00022   \textcolor{comment}{// TODO: This case (2-by-2 blocks with complex conjugate eigenvalues) is probably hidden somewhere}
00023   \textcolor{comment}{//       in EigenSolver. If we expose it, we could call it directly from here.}
00024   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<MatrixType>::Scalar Scalar;
00025   Matrix<Scalar,2,2> block = T.template block<2,2>(i,i);
00026   EigenSolver<Matrix<Scalar,2,2> > es(block);
00027   sqrtT.template block<2,2>(i,i)
00028     = (es.eigenvectors() * es.eigenvalues().cwiseSqrt().asDiagonal() * es.eigenvectors().inverse()).real();
00029 \}
00030 
00031 \textcolor{comment}{// pre:  block structure of T is such that (i,j) is a 1x1 block,}
00032 \textcolor{comment}{//       all blocks of sqrtT to left of and below (i,j) are correct}
00033 \textcolor{comment}{// post: sqrtT(i,j) has the correct value}
00034 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ResultType>
00035 \textcolor{keywordtype}{void} matrix\_sqrt\_quasi\_triangular\_1x1\_off\_diagonal\_block(\textcolor{keyword}{const} MatrixType& T, \textcolor{keyword}{typename} MatrixType::Index i,
       \textcolor{keyword}{typename} MatrixType::Index j, ResultType& sqrtT)
00036 \{
00037   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<MatrixType>::Scalar Scalar;
00038   Scalar tmp = (sqrtT.row(i).segment(i+1,j-i-1) * sqrtT.col(j).segment(i+1,j-i-1)).value();
00039   sqrtT.coeffRef(i,j) = (T.coeff(i,j) - tmp) / (sqrtT.coeff(i,i) + sqrtT.coeff(j,j));
00040 \}
00041 
00042 \textcolor{comment}{// similar to compute1x1offDiagonalBlock()}
00043 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ResultType>
00044 \textcolor{keywordtype}{void} matrix\_sqrt\_quasi\_triangular\_1x2\_off\_diagonal\_block(\textcolor{keyword}{const} MatrixType& T, \textcolor{keyword}{typename} MatrixType::Index i,
       \textcolor{keyword}{typename} MatrixType::Index j, ResultType& sqrtT)
00045 \{
00046   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<MatrixType>::Scalar Scalar;
00047   Matrix<Scalar,1,2> rhs = T.template block<1,2>(i,j);
00048   \textcolor{keywordflow}{if} (j-i > 1)
00049     rhs -= sqrtT.block(i, i+1, 1, j-i-1) * sqrtT.block(i+1, j, j-i-1, 2);
00050   Matrix<Scalar,2,2> A = sqrtT.coeff(i,i) * Matrix<Scalar,2,2>::Identity();
00051   A += sqrtT.template block<2,2>(j,j).transpose();
00052   sqrtT.template block<1,2>(i,j).transpose() = A.fullPivLu().solve(rhs.transpose());
00053 \}
00054 
00055 \textcolor{comment}{// similar to compute1x1offDiagonalBlock()}
00056 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ResultType>
00057 \textcolor{keywordtype}{void} matrix\_sqrt\_quasi\_triangular\_2x1\_off\_diagonal\_block(\textcolor{keyword}{const} MatrixType& T, \textcolor{keyword}{typename} MatrixType::Index i,
       \textcolor{keyword}{typename} MatrixType::Index j, ResultType& sqrtT)
00058 \{
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<MatrixType>::Scalar Scalar;
00060   Matrix<Scalar,2,1> rhs = T.template block<2,1>(i,j);
00061   \textcolor{keywordflow}{if} (j-i > 2)
00062     rhs -= sqrtT.block(i, i+2, 2, j-i-2) * sqrtT.block(i+2, j, j-i-2, 1);
00063   Matrix<Scalar,2,2> A = sqrtT.coeff(j,j) * Matrix<Scalar,2,2>::Identity();
00064   A += sqrtT.template block<2,2>(i,i);
00065   sqrtT.template block<2,1>(i,j) = A.fullPivLu().solve(rhs);
00066 \}
00067 
00068 \textcolor{comment}{// solves the equation A X + X B = C where all matrices are 2-by-2}
00069 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00070 \textcolor{keywordtype}{void} matrix\_sqrt\_quasi\_triangular\_solve\_auxiliary\_equation(MatrixType& X, \textcolor{keyword}{const} MatrixType& A, \textcolor{keyword}{const} 
      MatrixType& B, \textcolor{keyword}{const} MatrixType& C)
00071 \{
00072   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<MatrixType>::Scalar Scalar;
00073   Matrix<Scalar,4,4> coeffMatrix = Matrix<Scalar,4,4>::Zero();
00074   coeffMatrix.coeffRef(0,0) = A.coeff(0,0) + B.coeff(0,0);
00075   coeffMatrix.coeffRef(1,1) = A.coeff(0,0) + B.coeff(1,1);
00076   coeffMatrix.coeffRef(2,2) = A.coeff(1,1) + B.coeff(0,0);
00077   coeffMatrix.coeffRef(3,3) = A.coeff(1,1) + B.coeff(1,1);
00078   coeffMatrix.coeffRef(0,1) = B.coeff(1,0);
00079   coeffMatrix.coeffRef(0,2) = A.coeff(0,1);
00080   coeffMatrix.coeffRef(1,0) = B.coeff(0,1);
00081   coeffMatrix.coeffRef(1,3) = A.coeff(0,1);
00082   coeffMatrix.coeffRef(2,0) = A.coeff(1,0);
00083   coeffMatrix.coeffRef(2,3) = B.coeff(1,0);
00084   coeffMatrix.coeffRef(3,1) = A.coeff(1,0);
00085   coeffMatrix.coeffRef(3,2) = B.coeff(0,1);
00086 
00087   Matrix<Scalar,4,1> rhs;
00088   rhs.coeffRef(0) = C.coeff(0,0);
00089   rhs.coeffRef(1) = C.coeff(0,1);
00090   rhs.coeffRef(2) = C.coeff(1,0);
00091   rhs.coeffRef(3) = C.coeff(1,1);
00092 
00093   Matrix<Scalar,4,1> result;
00094   result = coeffMatrix.fullPivLu().solve(rhs);
00095 
00096   X.coeffRef(0,0) = result.coeff(0);
00097   X.coeffRef(0,1) = result.coeff(1);
00098   X.coeffRef(1,0) = result.coeff(2);
00099   X.coeffRef(1,1) = result.coeff(3);
00100 \}
00101 
00102 \textcolor{comment}{// similar to compute1x1offDiagonalBlock()}
00103 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ResultType>
00104 \textcolor{keywordtype}{void} matrix\_sqrt\_quasi\_triangular\_2x2\_off\_diagonal\_block(\textcolor{keyword}{const} MatrixType& T, \textcolor{keyword}{typename} MatrixType::Index i,
       \textcolor{keyword}{typename} MatrixType::Index j, ResultType& sqrtT)
00105 \{
00106   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<MatrixType>::Scalar Scalar;
00107   Matrix<Scalar,2,2> A = sqrtT.template block<2,2>(i,i);
00108   Matrix<Scalar,2,2> B = sqrtT.template block<2,2>(j,j);
00109   Matrix<Scalar,2,2> C = T.template block<2,2>(i,j);
00110   \textcolor{keywordflow}{if} (j-i > 2)
00111     C -= sqrtT.block(i, i+2, 2, j-i-2) * sqrtT.block(i+2, j, j-i-2, 2);
00112   Matrix<Scalar,2,2> X;
00113   matrix\_sqrt\_quasi\_triangular\_solve\_auxiliary\_equation(X, A, B, C);
00114   sqrtT.template block<2,2>(i,j) = X;
00115 \}
00116 
00117 \textcolor{comment}{// pre:  T is quasi-upper-triangular and sqrtT is a zero matrix of the same size}
00118 \textcolor{comment}{// post: the diagonal blocks of sqrtT are the square roots of the diagonal blocks of T}
00119 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ResultType>
00120 \textcolor{keywordtype}{void} matrix\_sqrt\_quasi\_triangular\_diagonal(\textcolor{keyword}{const} MatrixType& T, ResultType& sqrtT)
00121 \{
00122   \textcolor{keyword}{using} std::sqrt;
00123   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00124   \textcolor{keyword}{const} Index size = T.rows();
00125   \textcolor{keywordflow}{for} (Index i = 0; i < size; i++) \{
00126     \textcolor{keywordflow}{if} (i == size - 1 || T.coeff(i+1, i) == 0) \{
00127       eigen\_assert(T(i,i) >= 0);
00128       sqrtT.coeffRef(i,i) = sqrt(T.coeff(i,i));
00129     \}
00130     \textcolor{keywordflow}{else} \{
00131       matrix\_sqrt\_quasi\_triangular\_2x2\_diagonal\_block(T, i, sqrtT);
00132       ++i;
00133     \}
00134   \}
00135 \}
00136 
00137 \textcolor{comment}{// pre:  T is quasi-upper-triangular and diagonal blocks of sqrtT are square root of diagonal blocks of T.}
00138 \textcolor{comment}{// post: sqrtT is the square root of T.}
00139 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ResultType>
00140 \textcolor{keywordtype}{void} matrix\_sqrt\_quasi\_triangular\_off\_diagonal(\textcolor{keyword}{const} MatrixType& T, ResultType& sqrtT)
00141 \{
00142   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00143   \textcolor{keyword}{const} Index size = T.rows();
00144   \textcolor{keywordflow}{for} (Index j = 1; j < size; j++) \{
00145       \textcolor{keywordflow}{if} (T.coeff(j, j-1) != 0)  \textcolor{comment}{// if T(j-1:j, j-1:j) is a 2-by-2 block}
00146     \textcolor{keywordflow}{continue};
00147     \textcolor{keywordflow}{for} (Index i = j-1; i >= 0; i--) \{
00148       \textcolor{keywordflow}{if} (i > 0 && T.coeff(i, i-1) != 0)  \textcolor{comment}{// if T(i-1:i, i-1:i) is a 2-by-2 block}
00149     \textcolor{keywordflow}{continue};
00150       \textcolor{keywordtype}{bool} iBlockIs2x2 = (i < size - 1) && (T.coeff(i+1, i) != 0);
00151       \textcolor{keywordtype}{bool} jBlockIs2x2 = (j < size - 1) && (T.coeff(j+1, j) != 0);
00152       \textcolor{keywordflow}{if} (iBlockIs2x2 && jBlockIs2x2) 
00153         matrix\_sqrt\_quasi\_triangular\_2x2\_off\_diagonal\_block(T, i, j, sqrtT);
00154       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (iBlockIs2x2 && !jBlockIs2x2) 
00155         matrix\_sqrt\_quasi\_triangular\_2x1\_off\_diagonal\_block(T, i, j, sqrtT);
00156       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!iBlockIs2x2 && jBlockIs2x2) 
00157         matrix\_sqrt\_quasi\_triangular\_1x2\_off\_diagonal\_block(T, i, j, sqrtT);
00158       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!iBlockIs2x2 && !jBlockIs2x2) 
00159         matrix\_sqrt\_quasi\_triangular\_1x1\_off\_diagonal\_block(T, i, j, sqrtT);
00160     \}
00161   \}
00162 \}
00163 
00164 \} \textcolor{comment}{// end of namespace internal}
00165 
00181 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ResultType> 
00182 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_a2f490197e16df831683018e383e29346}{matrix\_sqrt\_quasi\_triangular}(\textcolor{keyword}{const} MatrixType &arg, ResultType &result)
00183 \{
00184   eigen\_assert(arg.rows() == arg.cols());
00185   result.resize(arg.rows(), arg.cols());
00186   internal::matrix\_sqrt\_quasi\_triangular\_diagonal(arg, result);
00187   internal::matrix\_sqrt\_quasi\_triangular\_off\_diagonal(arg, result);
00188 \}
00189 
00190 
00205 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ResultType> 
00206 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_ae51c91f920f6ea4a7f6f72caa1e8249f}{matrix\_sqrt\_triangular}(\textcolor{keyword}{const} MatrixType &arg, ResultType &result)
00207 \{
00208   \textcolor{keyword}{using} std::sqrt;
00209   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00210       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00211 
00212   eigen\_assert(arg.rows() == arg.cols());
00213 
00214   \textcolor{comment}{// Compute square root of arg and store it in upper triangular part of result}
00215   \textcolor{comment}{// This uses that the square root of triangular matrices can be computed directly.}
00216   result.resize(arg.rows(), arg.cols());
00217   \textcolor{keywordflow}{for} (Index i = 0; i < arg.rows(); i++) \{
00218     result.coeffRef(i,i) = sqrt(arg.coeff(i,i));
00219   \}
00220   \textcolor{keywordflow}{for} (Index j = 1; j < arg.cols(); j++) \{
00221     \textcolor{keywordflow}{for} (Index i = j-1; i >= 0; i--) \{
00222       \textcolor{comment}{// if i = j-1, then segment has length 0 so tmp = 0}
00223       Scalar tmp = (result.row(i).segment(i+1,j-i-1) * result.col(j).segment(i+1,j-i-1)).value();
00224       \textcolor{comment}{// denominator may be zero if original matrix is singular}
00225       result.coeffRef(i,j) = (arg.coeff(i,j) - tmp) / (result.coeff(i,i) + result.coeff(j,j));
00226     \}
00227   \}
00228 \}
00229 
00230 
00231 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00232 
00240 template <typename MatrixType, int IsComplex = NumTraits<typename internal::traits<MatrixType>::Scalar>
      ::IsComplex>
00241 \textcolor{keyword}{struct }matrix\_sqrt\_compute
00242 \{
00250   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ResultType> \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} MatrixType &arg, ResultType &result);    
00251 \};
00252 
00253 
00254 \textcolor{comment}{// ********** Partial specialization for real matrices **********}
00255 
00256 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00257 \textcolor{keyword}{struct }matrix\_sqrt\_compute<MatrixType, 0>
00258 \{
00259   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ResultType>
00260   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} MatrixType &arg, ResultType &result)
00261   \{
00262     eigen\_assert(arg.rows() == arg.cols());
00263 
00264     \textcolor{comment}{// Compute Schur decomposition of arg}
00265     \textcolor{keyword}{const} RealSchur<MatrixType> schurOfA(arg);  
00266     \textcolor{keyword}{const} MatrixType& T = schurOfA.matrixT();
00267     \textcolor{keyword}{const} MatrixType& U = schurOfA.matrixU();
00268     
00269     \textcolor{comment}{// Compute square root of T}
00270     MatrixType sqrtT = MatrixType::Zero(arg.rows(), arg.cols());
00271     \hyperlink{namespace_eigen_a2f490197e16df831683018e383e29346}{matrix\_sqrt\_quasi\_triangular}(T, sqrtT);
00272     
00273     \textcolor{comment}{// Compute square root of arg}
00274     result = U * sqrtT * U.adjoint();
00275   \}
00276 \};
00277 
00278 
00279 \textcolor{comment}{// ********** Partial specialization for complex matrices **********}
00280 
00281 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00282 \textcolor{keyword}{struct }matrix\_sqrt\_compute<MatrixType, 1>
00283 \{
00284   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ResultType>
00285   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} MatrixType &arg, ResultType &result)
00286   \{
00287     eigen\_assert(arg.rows() == arg.cols());
00288 
00289     \textcolor{comment}{// Compute Schur decomposition of arg}
00290     \textcolor{keyword}{const} ComplexSchur<MatrixType> schurOfA(arg);  
00291     \textcolor{keyword}{const} MatrixType& T = schurOfA.matrixT();
00292     \textcolor{keyword}{const} MatrixType& U = schurOfA.matrixU();
00293     
00294     \textcolor{comment}{// Compute square root of T}
00295     MatrixType sqrtT;
00296     \hyperlink{namespace_eigen_ae51c91f920f6ea4a7f6f72caa1e8249f}{matrix\_sqrt\_triangular}(T, sqrtT);
00297     
00298     \textcolor{comment}{// Compute square root of arg}
00299     result = U * (sqrtT.template triangularView<Upper>() * U.adjoint());
00300   \}
00301 \};
00302 
00303 \} \textcolor{comment}{// end namespace internal}
00304 
00317 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }MatrixSquareRootReturnValue
00318 : \textcolor{keyword}{public} ReturnByValue<MatrixSquareRootReturnValue<Derived> >
00319 \{
00320   \textcolor{keyword}{protected}:
00321     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00322     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::ref\_selector<Derived>::type DerivedNested;
00323 
00324   \textcolor{keyword}{public}:
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_square_root_8h_source_l00330}\hyperlink{class_eigen_1_1_matrix_square_root_return_value_aa27fd0e59ff1711a55ee8a4342c035d5}{00330}     \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1_matrix_square_root_return_value_aa27fd0e59ff1711a55ee8a4342c035d5}{MatrixSquareRootReturnValue}(\textcolor{keyword}{const} Derived& src) : m\_src(src) \{ \}
00331 
00337     \textcolor{keyword}{template} <\textcolor{keyword}{typename} ResultType>
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_square_root_8h_source_l00338}\hyperlink{class_eigen_1_1_matrix_square_root_return_value_a97577165569edcf19429c7748b670e51}{00338}     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_square_root_return_value_a97577165569edcf19429c7748b670e51}{evalTo}(ResultType& result)\textcolor{keyword}{ const}
00339 \textcolor{keyword}{    }\{
00340       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<Derived, 10>::type} 
      DerivedEvalType;
00341       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<DerivedEvalType>::type}
       DerivedEvalTypeClean;
00342       DerivedEvalType tmp(m\_src);
00343       \hyperlink{struct_eigen_1_1internal_1_1matrix__sqrt__compute_a29c137f6d7c0cbe4df034be5aed427f6}{internal::matrix\_sqrt\_compute<DerivedEvalTypeClean>::run}
      (tmp, result);
00344     \}
00345 
00346     Index rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_src.rows(); \}
00347     Index cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_src.cols(); \}
00348 
00349   \textcolor{keyword}{protected}:
00350     \textcolor{keyword}{const} DerivedNested m\_src;
00351 \};
00352 
00353 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00354 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00355 \textcolor{keyword}{struct }traits<MatrixSquareRootReturnValue<Derived> >
00356 \{
00357   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::PlainObject ReturnType;
00358 \};
00359 \}
00360 
00361 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>
00362 \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_matrix_square_root_return_value}{MatrixSquareRootReturnValue<Derived>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>::sqrt}()\textcolor{keyword}{ const}
00363 \textcolor{keyword}{}\{
00364   eigen\_assert(rows() == cols());
00365   \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_matrix_square_root_return_value}{MatrixSquareRootReturnValue<Derived>}(derived());
00366 \}
00367 
00368 \} \textcolor{comment}{// end namespace Eigen}
00369 
00370 \textcolor{preprocessor}{#endif // EIGEN\_MATRIX\_FUNCTION}
\end{DoxyCode}
