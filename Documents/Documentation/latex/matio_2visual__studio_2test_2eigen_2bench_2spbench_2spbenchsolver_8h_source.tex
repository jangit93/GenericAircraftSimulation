\hypertarget{matio_2visual__studio_2test_2eigen_2bench_2spbench_2spbenchsolver_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/bench/spbench/spbenchsolver.h}
\label{matio_2visual__studio_2test_2eigen_2bench_2spbench_2spbenchsolver_8h_source}\index{spbenchsolver.\+h@{spbenchsolver.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 
00011 \textcolor{preprocessor}{#include <iostream>}
00012 \textcolor{preprocessor}{#include <fstream>}
00013 \textcolor{preprocessor}{#include <Eigen/SparseCore>}
00014 \textcolor{preprocessor}{#include <bench/BenchTimer.h>}
00015 \textcolor{preprocessor}{#include <cstdlib>}
00016 \textcolor{preprocessor}{#include <string>}
00017 \textcolor{preprocessor}{#include <Eigen/Cholesky>}
00018 \textcolor{preprocessor}{#include <Eigen/Jacobi>}
00019 \textcolor{preprocessor}{#include <Eigen/Householder>}
00020 \textcolor{preprocessor}{#include <Eigen/IterativeLinearSolvers>}
00021 \textcolor{preprocessor}{#include <unsupported/Eigen/IterativeSolvers>}
00022 \textcolor{preprocessor}{#include <Eigen/LU>}
00023 \textcolor{preprocessor}{#include <unsupported/Eigen/SparseExtra>}
00024 \textcolor{preprocessor}{#include <Eigen/SparseLU>}
00025 
00026 \textcolor{preprocessor}{#include "spbenchstyle.h"}
00027 
00028 \textcolor{preprocessor}{#ifdef EIGEN\_METIS\_SUPPORT}
00029 \textcolor{preprocessor}{#include <Eigen/MetisSupport>}
00030 \textcolor{preprocessor}{#endif}
00031 
00032 \textcolor{preprocessor}{#ifdef EIGEN\_CHOLMOD\_SUPPORT}
00033 \textcolor{preprocessor}{#include <Eigen/CholmodSupport>}
00034 \textcolor{preprocessor}{#endif}
00035 
00036 \textcolor{preprocessor}{#ifdef EIGEN\_UMFPACK\_SUPPORT}
00037 \textcolor{preprocessor}{#include <Eigen/UmfPackSupport>}
00038 \textcolor{preprocessor}{#endif}
00039 
00040 \textcolor{preprocessor}{#ifdef EIGEN\_PARDISO\_SUPPORT}
00041 \textcolor{preprocessor}{#include <Eigen/PardisoSupport>}
00042 \textcolor{preprocessor}{#endif}
00043 
00044 \textcolor{preprocessor}{#ifdef EIGEN\_SUPERLU\_SUPPORT}
00045 \textcolor{preprocessor}{#include <Eigen/SuperLUSupport>}
00046 \textcolor{preprocessor}{#endif}
00047 
00048 \textcolor{preprocessor}{#ifdef EIGEN\_PASTIX\_SUPPORT}
00049 \textcolor{preprocessor}{#include <Eigen/PaStiXSupport>}
00050 \textcolor{preprocessor}{#endif}
00051 
00052 \textcolor{comment}{// CONSTANTS}
00053 \textcolor{preprocessor}{#define EIGEN\_UMFPACK  10}
00054 \textcolor{preprocessor}{#define EIGEN\_SUPERLU  20}
00055 \textcolor{preprocessor}{#define EIGEN\_PASTIX  30}
00056 \textcolor{preprocessor}{#define EIGEN\_PARDISO  40}
00057 \textcolor{preprocessor}{#define EIGEN\_SPARSELU\_COLAMD 50}
00058 \textcolor{preprocessor}{#define EIGEN\_SPARSELU\_METIS 51}
00059 \textcolor{preprocessor}{#define EIGEN\_BICGSTAB  60}
00060 \textcolor{preprocessor}{#define EIGEN\_BICGSTAB\_ILUT  61}
00061 \textcolor{preprocessor}{#define EIGEN\_GMRES 70}
00062 \textcolor{preprocessor}{#define EIGEN\_GMRES\_ILUT 71}
00063 \textcolor{preprocessor}{#define EIGEN\_SIMPLICIAL\_LDLT  80}
00064 \textcolor{preprocessor}{#define EIGEN\_CHOLMOD\_LDLT  90}
00065 \textcolor{preprocessor}{#define EIGEN\_PASTIX\_LDLT  100}
00066 \textcolor{preprocessor}{#define EIGEN\_PARDISO\_LDLT  110}
00067 \textcolor{preprocessor}{#define EIGEN\_SIMPLICIAL\_LLT  120}
00068 \textcolor{preprocessor}{#define EIGEN\_CHOLMOD\_SUPERNODAL\_LLT  130}
00069 \textcolor{preprocessor}{#define EIGEN\_CHOLMOD\_SIMPLICIAL\_LLT  140}
00070 \textcolor{preprocessor}{#define EIGEN\_PASTIX\_LLT  150}
00071 \textcolor{preprocessor}{#define EIGEN\_PARDISO\_LLT  160}
00072 \textcolor{preprocessor}{#define EIGEN\_CG  170}
00073 \textcolor{preprocessor}{#define EIGEN\_CG\_PRECOND  180}
00074 
00075 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00076 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std}; 
00077 
00078 
00079 \textcolor{comment}{// Global variables for input parameters}
00080 \textcolor{keywordtype}{int} MaximumIters; \textcolor{comment}{// Maximum number of iterations}
00081 \textcolor{keywordtype}{double} RelErr; \textcolor{comment}{// Relative error of the computed solution}
00082 \textcolor{keywordtype}{double} best\_time\_val; \textcolor{comment}{// Current best time overall solvers }
00083 \textcolor{keywordtype}{int} best\_time\_id; \textcolor{comment}{//  id of the best solver for the current system }
00084 
00085 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<T>::Real} test\_precision() \{ \textcolor{keywordflow}{return} 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<T>::dummy\_precision}(); \}
00086 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{float} test\_precision<float>() \{ \textcolor{keywordflow}{return} 1e-3f; \}                                          
                         
00087 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{double} test\_precision<double>() \{ \textcolor{keywordflow}{return} 1e-6; \}                                         
                         
00088 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{float} test\_precision<std::complex<float> >() \{ \textcolor{keywordflow}{return} test\_precision<float>(); \}
00089 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{double} test\_precision<std::complex<double> >() \{ \textcolor{keywordflow}{return} test\_precision<double>(); \}
00090 
00091 \textcolor{keywordtype}{void} printStatheader(std::ofstream& out)
00092 \{
00093   \textcolor{comment}{// Print XML header}
00094   \textcolor{comment}{// NOTE It would have been much easier to write these XML documents using external libraries like tinyXML
       or Xerces-C++.}
00095   
00096   out << \textcolor{stringliteral}{"<?xml version='1.0' encoding='UTF-8'?> \(\backslash\)n"};
00097   out << \textcolor{stringliteral}{"<?xml-stylesheet type='text/xsl' href='#stylesheet' ?> \(\backslash\)n"}; 
00098   out << \textcolor{stringliteral}{"<!DOCTYPE BENCH  [\(\backslash\)n<!ATTLIST xsl:stylesheet\(\backslash\)n id\(\backslash\)t ID  #REQUIRED>\(\backslash\)n]>"};
00099   out << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n<!-- Generated by the Eigen library -->\(\backslash\)n"}; 
00100   
00101   out << \textcolor{stringliteral}{"\(\backslash\)n<BENCH> \(\backslash\)n"} ; \textcolor{comment}{//root XML element }
00102   \textcolor{comment}{// Print the xsl style section}
00103   printBenchStyle(out); 
00104   \textcolor{comment}{// List all available solvers }
00105   out << \textcolor{stringliteral}{" <AVAILSOLVER> \(\backslash\)n"};
00106 \textcolor{preprocessor}{#ifdef EIGEN\_UMFPACK\_SUPPORT}
00107   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_UMFPACK << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00108   out << \textcolor{stringliteral}{"   <TYPE> LU </TYPE> \(\backslash\)n"};
00109   out << \textcolor{stringliteral}{"   <PACKAGE> UMFPACK </PACKAGE> \(\backslash\)n"}; 
00110   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00111 \textcolor{preprocessor}{#endif}
00112 \textcolor{preprocessor}{#ifdef EIGEN\_SUPERLU\_SUPPORT}
00113   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_SUPERLU << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00114   out << \textcolor{stringliteral}{"   <TYPE> LU </TYPE> \(\backslash\)n"};
00115   out << \textcolor{stringliteral}{"   <PACKAGE> SUPERLU </PACKAGE> \(\backslash\)n"}; 
00116   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00117 \textcolor{preprocessor}{#endif}
00118 \textcolor{preprocessor}{#ifdef EIGEN\_CHOLMOD\_SUPPORT}
00119   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_CHOLMOD\_SIMPLICIAL\_LLT << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00120   out << \textcolor{stringliteral}{"   <TYPE> LLT SP</TYPE> \(\backslash\)n"};
00121   out << \textcolor{stringliteral}{"   <PACKAGE> CHOLMOD </PACKAGE> \(\backslash\)n"};
00122   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00123   
00124   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_CHOLMOD\_SUPERNODAL\_LLT << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00125   out << \textcolor{stringliteral}{"   <TYPE> LLT</TYPE> \(\backslash\)n"};
00126   out << \textcolor{stringliteral}{"   <PACKAGE> CHOLMOD </PACKAGE> \(\backslash\)n"};
00127   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"};
00128   
00129   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_CHOLMOD\_LDLT << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00130   out << \textcolor{stringliteral}{"   <TYPE> LDLT </TYPE> \(\backslash\)n"};
00131   out << \textcolor{stringliteral}{"   <PACKAGE> CHOLMOD </PACKAGE> \(\backslash\)n"};  
00132   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00133 \textcolor{preprocessor}{#endif}
00134 \textcolor{preprocessor}{#ifdef EIGEN\_PARDISO\_SUPPORT}
00135   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_PARDISO << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00136   out << \textcolor{stringliteral}{"   <TYPE> LU </TYPE> \(\backslash\)n"};
00137   out << \textcolor{stringliteral}{"   <PACKAGE> PARDISO </PACKAGE> \(\backslash\)n"}; 
00138   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00139   
00140   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_PARDISO\_LLT << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00141   out << \textcolor{stringliteral}{"   <TYPE> LLT </TYPE> \(\backslash\)n"};
00142   out << \textcolor{stringliteral}{"   <PACKAGE> PARDISO </PACKAGE> \(\backslash\)n"}; 
00143   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00144   
00145   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_PARDISO\_LDLT << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00146   out << \textcolor{stringliteral}{"   <TYPE> LDLT </TYPE> \(\backslash\)n"};
00147   out << \textcolor{stringliteral}{"   <PACKAGE> PARDISO </PACKAGE> \(\backslash\)n"}; 
00148   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00149 \textcolor{preprocessor}{#endif}
00150 \textcolor{preprocessor}{#ifdef EIGEN\_PASTIX\_SUPPORT}
00151   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_PASTIX << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00152   out << \textcolor{stringliteral}{"   <TYPE> LU </TYPE> \(\backslash\)n"};
00153   out << \textcolor{stringliteral}{"   <PACKAGE> PASTIX </PACKAGE> \(\backslash\)n"}; 
00154   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00155   
00156   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_PASTIX\_LLT << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00157   out << \textcolor{stringliteral}{"   <TYPE> LLT </TYPE> \(\backslash\)n"};
00158   out << \textcolor{stringliteral}{"   <PACKAGE> PASTIX </PACKAGE> \(\backslash\)n"}; 
00159   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00160   
00161   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_PASTIX\_LDLT << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00162   out << \textcolor{stringliteral}{"   <TYPE> LDLT </TYPE> \(\backslash\)n"};
00163   out << \textcolor{stringliteral}{"   <PACKAGE> PASTIX </PACKAGE> \(\backslash\)n"}; 
00164   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00165 \textcolor{preprocessor}{#endif}
00166   
00167   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_BICGSTAB << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00168   out << \textcolor{stringliteral}{"   <TYPE> BICGSTAB </TYPE> \(\backslash\)n"};
00169   out << \textcolor{stringliteral}{"   <PACKAGE> EIGEN </PACKAGE> \(\backslash\)n"}; 
00170   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00171   
00172   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_BICGSTAB\_ILUT << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00173   out << \textcolor{stringliteral}{"   <TYPE> BICGSTAB\_ILUT </TYPE> \(\backslash\)n"};
00174   out << \textcolor{stringliteral}{"   <PACKAGE> EIGEN </PACKAGE> \(\backslash\)n"}; 
00175   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00176   
00177   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_GMRES\_ILUT << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00178   out << \textcolor{stringliteral}{"   <TYPE> GMRES\_ILUT </TYPE> \(\backslash\)n"};
00179   out << \textcolor{stringliteral}{"   <PACKAGE> EIGEN </PACKAGE> \(\backslash\)n"}; 
00180   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00181   
00182   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_SIMPLICIAL\_LDLT << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00183   out << \textcolor{stringliteral}{"   <TYPE> LDLT </TYPE> \(\backslash\)n"};
00184   out << \textcolor{stringliteral}{"   <PACKAGE> EIGEN </PACKAGE> \(\backslash\)n"}; 
00185   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00186   
00187   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_SIMPLICIAL\_LLT << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00188   out << \textcolor{stringliteral}{"   <TYPE> LLT </TYPE> \(\backslash\)n"};
00189   out << \textcolor{stringliteral}{"   <PACKAGE> EIGEN </PACKAGE> \(\backslash\)n"}; 
00190   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00191   
00192   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_CG << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00193   out << \textcolor{stringliteral}{"   <TYPE> CG </TYPE> \(\backslash\)n"};
00194   out << \textcolor{stringliteral}{"   <PACKAGE> EIGEN </PACKAGE> \(\backslash\)n"}; 
00195   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00196   
00197   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_SPARSELU\_COLAMD << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00198   out << \textcolor{stringliteral}{"   <TYPE> LU\_COLAMD </TYPE> \(\backslash\)n"};
00199   out << \textcolor{stringliteral}{"   <PACKAGE> EIGEN </PACKAGE> \(\backslash\)n"}; 
00200   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00201   
00202 \textcolor{preprocessor}{#ifdef EIGEN\_METIS\_SUPPORT}
00203   out <<\textcolor{stringliteral}{"  <SOLVER ID='"} << EIGEN\_SPARSELU\_METIS << \textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00204   out << \textcolor{stringliteral}{"   <TYPE> LU\_METIS </TYPE> \(\backslash\)n"};
00205   out << \textcolor{stringliteral}{"   <PACKAGE> EIGEN </PACKAGE> \(\backslash\)n"}; 
00206   out << \textcolor{stringliteral}{"  </SOLVER> \(\backslash\)n"}; 
00207 \textcolor{preprocessor}{#endif}
00208   out << \textcolor{stringliteral}{" </AVAILSOLVER> \(\backslash\)n"}; 
00209   
00210 \}
00211 
00212 
00213 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} Scalar>
00214 \textcolor{keywordtype}{void} call\_solver(Solver &solver, \textcolor{keyword}{const} \textcolor{keywordtype}{int} solver\_id, \textcolor{keyword}{const} \textcolor{keyword}{typename} Solver::MatrixType& 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, \textcolor{keyword}{const} \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>}& b, \textcolor{keyword}{const} 
      \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>}& refX,std::ofstream& statbuf)
00215 \{
00216   
00217   \textcolor{keywordtype}{double} total\_time;
00218   \textcolor{keywordtype}{double} compute\_time;
00219   \textcolor{keywordtype}{double} solve\_time; 
00220   \textcolor{keywordtype}{double} rel\_error;
00221   \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>} x; 
00222   \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} timer; 
00223   timer.reset();
00224   timer.start();
00225   solver.compute(A); 
00226   \textcolor{keywordflow}{if} (solver.info() != \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success})
00227   \{
00228     std::cerr << \textcolor{stringliteral}{"Solver failed ... \(\backslash\)n"};
00229     \textcolor{keywordflow}{return};
00230   \}
00231   timer.stop();
00232   compute\_time = timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}();
00233   statbuf << \textcolor{stringliteral}{"    <TIME>\(\backslash\)n"}; 
00234   statbuf << \textcolor{stringliteral}{"     <COMPUTE> "} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << \textcolor{stringliteral}{"</COMPUTE>\(\backslash\)n"};
00235   std::cout<< \textcolor{stringliteral}{"COMPUTE TIME : "} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() <<std::endl; 
00236     
00237   timer.reset();
00238   timer.start();
00239   x = solver.solve(b); 
00240   \textcolor{keywordflow}{if} (solver.info() == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue})
00241   \{
00242     std::cerr << \textcolor{stringliteral}{"Solver failed ... \(\backslash\)n"};
00243     \textcolor{keywordflow}{return};
00244   \}
00245   timer.stop();
00246   solve\_time = timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}();
00247   statbuf << \textcolor{stringliteral}{"     <SOLVE> "} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << \textcolor{stringliteral}{"</SOLVE>\(\backslash\)n"}; 
00248   std::cout<< \textcolor{stringliteral}{"SOLVE TIME : "} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() <<std::endl; 
00249   
00250   total\_time = solve\_time + compute\_time;
00251   statbuf << \textcolor{stringliteral}{"     <TOTAL> "} << total\_time << \textcolor{stringliteral}{"</TOTAL>\(\backslash\)n"}; 
00252   std::cout<< \textcolor{stringliteral}{"TOTAL TIME : "} << total\_time <<std::endl; 
00253   statbuf << \textcolor{stringliteral}{"    </TIME>\(\backslash\)n"}; 
00254   
00255   \textcolor{comment}{// Verify the relative error}
00256   \textcolor{keywordflow}{if}(refX.size() != 0)
00257     rel\_error = (refX - x).norm()/refX.norm();
00258   \textcolor{keywordflow}{else} 
00259   \{
00260     \textcolor{comment}{// Compute the relative residual norm}
00261     \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>} temp; 
00262     temp = A * x; 
00263     rel\_error = (b-temp).norm()/b.norm();
00264   \}
00265   statbuf << \textcolor{stringliteral}{"    <ERROR> "} << rel\_error << \textcolor{stringliteral}{"</ERROR>\(\backslash\)n"}; 
00266   std::cout<< \textcolor{stringliteral}{"REL. ERROR : "} << rel\_error << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"} ;
00267   \textcolor{keywordflow}{if} ( rel\_error <= RelErr )
00268   \{
00269     \textcolor{comment}{// check the best time if convergence}
00270     \textcolor{keywordflow}{if}(!best\_time\_val || (best\_time\_val > total\_time))
00271     \{
00272       best\_time\_val = total\_time;
00273       best\_time\_id = solver\_id;
00274     \}
00275   \}
00276 \}
00277 
00278 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} Scalar>
00279 \textcolor{keywordtype}{void} call\_directsolver(Solver& solver, \textcolor{keyword}{const} \textcolor{keywordtype}{int} solver\_id, \textcolor{keyword}{const} \textcolor{keyword}{typename} Solver::MatrixType& A, \textcolor{keyword}{const} 
      \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>}& b, \textcolor{keyword}{const} 
      \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>}& refX, std::string& statFile)
00280 \{
00281     std::ofstream statbuf(statFile.c\_str(), std::ios::app);
00282     statbuf << \textcolor{stringliteral}{"   <SOLVER\_STAT ID='"} << solver\_id <<\textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00283     call\_solver(solver, solver\_id, A, b, refX,statbuf);
00284     statbuf << \textcolor{stringliteral}{"   </SOLVER\_STAT>\(\backslash\)n"};
00285     statbuf.close();
00286 \}
00287 
00288 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} Scalar>
00289 \textcolor{keywordtype}{void} call\_itersolver(Solver &solver, \textcolor{keyword}{const} \textcolor{keywordtype}{int} solver\_id, \textcolor{keyword}{const} \textcolor{keyword}{typename} Solver::MatrixType& A, \textcolor{keyword}{const} 
      \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>}& b, \textcolor{keyword}{const} 
      \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>}& refX, std::string& statFile)
00290 \{
00291   solver.setTolerance(RelErr); 
00292   solver.setMaxIterations(MaximumIters);
00293   
00294   std::ofstream statbuf(statFile.c\_str(), std::ios::app);
00295   statbuf << \textcolor{stringliteral}{" <SOLVER\_STAT ID='"} << solver\_id <<\textcolor{stringliteral}{"'>\(\backslash\)n"}; 
00296   call\_solver(solver, solver\_id, A, b, refX,statbuf); 
00297   statbuf << \textcolor{stringliteral}{"   <ITER> "}<< solver.iterations() << \textcolor{stringliteral}{"</ITER>\(\backslash\)n"};
00298   statbuf << \textcolor{stringliteral}{" </SOLVER\_STAT>\(\backslash\)n"};
00299   std::cout << \textcolor{stringliteral}{"ITERATIONS : "} << solver.iterations() <<\textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)n"}; 
00300   
00301 \}
00302 
00303 
00304 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00305 \textcolor{keywordtype}{void} SelectSolvers(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar>}&A, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sym, 
      \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>}& b, \textcolor{keyword}{const} 
      \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>}& refX, std::string& statFile)
00306 \{
00307   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar, ColMajor>} \hyperlink{group___sparse_core___module}{SpMat}; 
00308   \textcolor{comment}{// First, deal with Nonsymmetric and symmetric matrices}
00309   best\_time\_id = 0; 
00310   best\_time\_val = 0.0;
00311   \textcolor{comment}{//UMFPACK}
00312 \textcolor{preprocessor}{  #ifdef EIGEN\_UMFPACK\_SUPPORT}
00313   \{
00314     cout << \textcolor{stringliteral}{"Solving with UMFPACK LU ... \(\backslash\)n"}; 
00315     \hyperlink{class_eigen_1_1_umf_pack_l_u}{UmfPackLU<SpMat>} solver; 
00316     call\_directsolver(solver, EIGEN\_UMFPACK, A, b, refX,statFile); 
00317   \}
00318 \textcolor{preprocessor}{  #endif}
00319     \textcolor{comment}{//SuperLU}
00320 \textcolor{preprocessor}{  #ifdef EIGEN\_SUPERLU\_SUPPORT}
00321   \{
00322     cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with SUPERLU ... \(\backslash\)n"}; 
00323     \hyperlink{class_eigen_1_1_super_l_u}{SuperLU<SpMat>} solver;
00324     call\_directsolver(solver, EIGEN\_SUPERLU, A, b, refX,statFile); 
00325   \}
00326 \textcolor{preprocessor}{  #endif}
00327     
00328    \textcolor{comment}{// PaStix LU}
00329 \textcolor{preprocessor}{  #ifdef EIGEN\_PASTIX\_SUPPORT}
00330   \{
00331     cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with PASTIX LU ... \(\backslash\)n"}; 
00332     \hyperlink{class_eigen_1_1_pastix_l_u}{PastixLU<SpMat>} solver; 
00333     call\_directsolver(solver, EIGEN\_PASTIX, A, b, refX,statFile) ;
00334   \}
00335 \textcolor{preprocessor}{  #endif}
00336 
00337    \textcolor{comment}{//PARDISO LU}
00338 \textcolor{preprocessor}{  #ifdef EIGEN\_PARDISO\_SUPPORT}
00339   \{
00340     cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with PARDISO LU ... \(\backslash\)n"}; 
00341     \hyperlink{class_eigen_1_1_pardiso_l_u}{PardisoLU<SpMat>}  solver; 
00342     call\_directsolver(solver, EIGEN\_PARDISO, A, b, refX,statFile);
00343   \}
00344 \textcolor{preprocessor}{  #endif}
00345   
00346   \textcolor{comment}{// Eigen SparseLU METIS}
00347   cout << \textcolor{stringliteral}{"\(\backslash\)n Solving with Sparse LU AND COLAMD ... \(\backslash\)n"};
00348   \hyperlink{group___sparse_l_u___module_class_eigen_1_1_sparse_l_u}{SparseLU<SpMat, COLAMDOrdering<int>} >   solver;
00349   call\_directsolver(solver, EIGEN\_SPARSELU\_COLAMD, A, b, refX, statFile); 
00350   \textcolor{comment}{// Eigen SparseLU METIS}
00351 \textcolor{preprocessor}{  #ifdef EIGEN\_METIS\_SUPPORT}
00352   \{
00353     cout << \textcolor{stringliteral}{"\(\backslash\)n Solving with Sparse LU AND METIS ... \(\backslash\)n"};
00354     \hyperlink{group___sparse_l_u___module_class_eigen_1_1_sparse_l_u}{SparseLU<SpMat, MetisOrdering<int>} >   solver;
00355     call\_directsolver(solver, EIGEN\_SPARSELU\_METIS, A, b, refX, statFile); 
00356   \}
00357 \textcolor{preprocessor}{  #endif}
00358   
00359   \textcolor{comment}{//BiCGSTAB}
00360   \{
00361     cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with BiCGSTAB ... \(\backslash\)n"}; 
00362     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_bi_c_g_s_t_a_b}{BiCGSTAB<SpMat>} solver; 
00363     call\_itersolver(solver, EIGEN\_BICGSTAB, A, b, refX,statFile);
00364   \}
00365   \textcolor{comment}{//BiCGSTAB+ILUT}
00366   \{
00367     cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with BiCGSTAB and ILUT ... \(\backslash\)n"}; 
00368     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_bi_c_g_s_t_a_b}{BiCGSTAB<SpMat, IncompleteLUT<Scalar>} > solver; 
00369     call\_itersolver(solver, EIGEN\_BICGSTAB\_ILUT, A, b, refX,statFile); 
00370   \}
00371   
00372    
00373   \textcolor{comment}{//GMRES}
00374 \textcolor{comment}{//   \{}
00375 \textcolor{comment}{//     cout << "\(\backslash\)nSolving with GMRES ... \(\backslash\)n"; }
00376 \textcolor{comment}{//     GMRES<SpMat> solver; }
00377 \textcolor{comment}{//     call\_itersolver(solver, EIGEN\_GMRES, A, b, refX,statFile); }
00378 \textcolor{comment}{//   \}}
00379   \textcolor{comment}{//GMRES+ILUT}
00380   \{
00381     cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with GMRES and ILUT ... \(\backslash\)n"}; 
00382     \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_g_m_r_e_s}{GMRES<SpMat, IncompleteLUT<Scalar>} > solver; 
00383     call\_itersolver(solver, EIGEN\_GMRES\_ILUT, A, b, refX,statFile);
00384   \}
00385   
00386   \textcolor{comment}{// Hermitian and not necessarily positive-definites}
00387   \textcolor{keywordflow}{if} (sym != NonSymmetric)
00388   \{
00389     \textcolor{comment}{// Internal Cholesky}
00390     \{
00391       cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with Simplicial LDLT ... \(\backslash\)n"}; 
00392       \hyperlink{group___sparse_cholesky___module_class_eigen_1_1_simplicial_l_d_l_t}{SimplicialLDLT<SpMat, Lower>} solver;
00393       call\_directsolver(solver, EIGEN\_SIMPLICIAL\_LDLT, A, b, refX,statFile); 
00394     \}
00395     
00396     \textcolor{comment}{// CHOLMOD}
00397 \textcolor{preprocessor}{    #ifdef EIGEN\_CHOLMOD\_SUPPORT}
00398     \{
00399       cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with CHOLMOD LDLT ... \(\backslash\)n"}; 
00400       \hyperlink{class_eigen_1_1_cholmod_decomposition}{CholmodDecomposition<SpMat, Lower>} solver;
00401       solver.setMode(CholmodLDLt);
00402        call\_directsolver(solver,EIGEN\_CHOLMOD\_LDLT, A, b, refX,statFile);
00403     \}
00404 \textcolor{preprocessor}{    #endif}
00405     
00406     \textcolor{comment}{//PASTIX LLT}
00407 \textcolor{preprocessor}{    #ifdef EIGEN\_PASTIX\_SUPPORT}
00408     \{
00409       cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with PASTIX LDLT ... \(\backslash\)n"}; 
00410       \hyperlink{class_eigen_1_1_pastix_l_d_l_t}{PastixLDLT<SpMat, Lower>} solver; 
00411       call\_directsolver(solver,EIGEN\_PASTIX\_LDLT, A, b, refX,statFile); 
00412     \}
00413 \textcolor{preprocessor}{    #endif}
00414     
00415     \textcolor{comment}{//PARDISO LLT}
00416 \textcolor{preprocessor}{    #ifdef EIGEN\_PARDISO\_SUPPORT}
00417     \{
00418       cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with PARDISO LDLT ... \(\backslash\)n"}; 
00419       \hyperlink{class_eigen_1_1_pardiso_l_d_l_t}{PardisoLDLT<SpMat, Lower>} solver; 
00420       call\_directsolver(solver,EIGEN\_PARDISO\_LDLT, A, b, refX,statFile); 
00421     \}
00422 \textcolor{preprocessor}{    #endif}
00423   \}
00424 
00425    \textcolor{comment}{// Now, symmetric POSITIVE DEFINITE matrices}
00426   \textcolor{keywordflow}{if} (sym == SPD)
00427   \{
00428     
00429     \textcolor{comment}{//Internal Sparse Cholesky}
00430     \{
00431       cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with SIMPLICIAL LLT ... \(\backslash\)n"}; 
00432       \hyperlink{group___sparse_cholesky___module_class_eigen_1_1_simplicial_l_l_t}{SimplicialLLT<SpMat, Lower>} solver; 
00433       call\_directsolver(solver,EIGEN\_SIMPLICIAL\_LLT, A, b, refX,statFile); 
00434     \}
00435     
00436     \textcolor{comment}{// CHOLMOD}
00437 \textcolor{preprocessor}{    #ifdef EIGEN\_CHOLMOD\_SUPPORT}
00438     \{
00439       \textcolor{comment}{// CholMOD SuperNodal LLT}
00440       cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with CHOLMOD LLT (Supernodal)... \(\backslash\)n"}; 
00441       \hyperlink{class_eigen_1_1_cholmod_decomposition}{CholmodDecomposition<SpMat, Lower>} solver;
00442       solver.setMode(CholmodSupernodalLLt);
00443        call\_directsolver(solver,EIGEN\_CHOLMOD\_SUPERNODAL\_LLT, A, b, refX,statFile);
00444       \textcolor{comment}{// CholMod Simplicial LLT}
00445       cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with CHOLMOD LLT (Simplicial) ... \(\backslash\)n"}; 
00446       solver.setMode(CholmodSimplicialLLt);
00447       call\_directsolver(solver,EIGEN\_CHOLMOD\_SIMPLICIAL\_LLT, A, b, refX,statFile);
00448     \}
00449 \textcolor{preprocessor}{    #endif}
00450     
00451     \textcolor{comment}{//PASTIX LLT}
00452 \textcolor{preprocessor}{    #ifdef EIGEN\_PASTIX\_SUPPORT}
00453     \{
00454       cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with PASTIX LLT ... \(\backslash\)n"}; 
00455       \hyperlink{class_eigen_1_1_pastix_l_l_t}{PastixLLT<SpMat, Lower>} solver; 
00456       call\_directsolver(solver,EIGEN\_PASTIX\_LLT, A, b, refX,statFile);
00457     \}
00458 \textcolor{preprocessor}{    #endif}
00459     
00460     \textcolor{comment}{//PARDISO LLT}
00461 \textcolor{preprocessor}{    #ifdef EIGEN\_PARDISO\_SUPPORT}
00462     \{
00463       cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with PARDISO LLT ... \(\backslash\)n"}; 
00464       \hyperlink{class_eigen_1_1_pardiso_l_l_t}{PardisoLLT<SpMat, Lower>} solver; 
00465       call\_directsolver(solver,EIGEN\_PARDISO\_LLT, A, b, refX,statFile); 
00466     \}
00467 \textcolor{preprocessor}{    #endif}
00468     
00469     \textcolor{comment}{// Internal CG}
00470     \{
00471       cout << \textcolor{stringliteral}{"\(\backslash\)nSolving with CG ... \(\backslash\)n"}; 
00472       \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_conjugate_gradient}{ConjugateGradient<SpMat, Lower>} solver; 
00473       call\_itersolver(solver,EIGEN\_CG, A, b, refX,statFile);
00474     \}
00475     \textcolor{comment}{//CG+IdentityPreconditioner}
00476 \textcolor{comment}{//     \{}
00477 \textcolor{comment}{//       cout << "\(\backslash\)nSolving with CG and IdentityPreconditioner ... \(\backslash\)n"; }
00478 \textcolor{comment}{//       ConjugateGradient<SpMat, Lower, IdentityPreconditioner> solver; }
00479 \textcolor{comment}{//       call\_itersolver(solver,EIGEN\_CG\_PRECOND, A, b, refX,statFile);}
00480 \textcolor{comment}{//     \}}
00481   \} \textcolor{comment}{// End SPD matrices }
00482 \}
00483 
00484 \textcolor{comment}{/* Browse all the matrices available in the specified folder }
00485 \textcolor{comment}{ * and solve the associated linear system.}
00486 \textcolor{comment}{ * The results of each solve are printed in the standard output}
00487 \textcolor{comment}{ * and optionally in the provided html file}
00488 \textcolor{comment}{ */}
00489 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00490 \textcolor{keywordtype}{void} Browse\_Matrices(\textcolor{keyword}{const} \textcolor{keywordtype}{string} folder, \textcolor{keywordtype}{bool} statFileExists, std::string& statFile, \textcolor{keywordtype}{int} maxiters, \textcolor{keywordtype}{double} 
      tol)
00491 \{
00492   MaximumIters = maxiters; \textcolor{comment}{// Maximum number of iterations, global variable }
00493   RelErr = tol;  \textcolor{comment}{//Relative residual error  as stopping criterion for iterative solvers}
00494   \hyperlink{class_eigen_1_1_matrix_market_iterator}{MatrixMarketIterator<Scalar>} it(folder);
00495   \textcolor{keywordflow}{for} ( ; it; ++it)
00496   \{
00497     \textcolor{comment}{//print the infos for this linear system }
00498     \textcolor{keywordflow}{if}(statFileExists)
00499     \{
00500       std::ofstream statbuf(statFile.c\_str(), std::ios::app);
00501       statbuf << \textcolor{stringliteral}{"<LINEARSYSTEM> \(\backslash\)n"};
00502       statbuf << \textcolor{stringliteral}{"   <MATRIX> \(\backslash\)n"};
00503       statbuf << \textcolor{stringliteral}{"     <NAME> "} << it.matname() << \textcolor{stringliteral}{" </NAME>\(\backslash\)n"}; 
00504       statbuf << \textcolor{stringliteral}{"     <SIZE> "} << it.matrix().rows() << \textcolor{stringliteral}{" </SIZE>\(\backslash\)n"}; 
00505       statbuf << \textcolor{stringliteral}{"     <ENTRIES> "} << it.matrix().nonZeros() << \textcolor{stringliteral}{"</ENTRIES>\(\backslash\)n"};
00506       \textcolor{keywordflow}{if} (it.sym()!=NonSymmetric)
00507       \{
00508         statbuf << \textcolor{stringliteral}{"     <SYMMETRY> Symmetric </SYMMETRY>\(\backslash\)n"} ; 
00509         \textcolor{keywordflow}{if} (it.sym() == SPD) 
00510           statbuf << \textcolor{stringliteral}{"     <POSDEF> YES </POSDEF>\(\backslash\)n"}; 
00511         \textcolor{keywordflow}{else} 
00512           statbuf << \textcolor{stringliteral}{"     <POSDEF> NO </POSDEF>\(\backslash\)n"}; 
00513           
00514       \}
00515       \textcolor{keywordflow}{else}
00516       \{
00517         statbuf << \textcolor{stringliteral}{"     <SYMMETRY> NonSymmetric </SYMMETRY>\(\backslash\)n"} ; 
00518         statbuf << \textcolor{stringliteral}{"     <POSDEF> NO </POSDEF>\(\backslash\)n"}; 
00519       \}
00520       statbuf << \textcolor{stringliteral}{"   </MATRIX> \(\backslash\)n"};
00521       statbuf.close();
00522     \}
00523     
00524     cout<< \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n===================================================== \(\backslash\)n"};
00525     cout<< \textcolor{stringliteral}{" ======  SOLVING WITH MATRIX "} << it.matname() << \textcolor{stringliteral}{" ====\(\backslash\)n"};
00526     cout<< \textcolor{stringliteral}{" =================================================== \(\backslash\)n\(\backslash\)n"};
00527     \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>} refX;
00528     \textcolor{keywordflow}{if}(it.hasrefX()) refX = it.refX();
00529     \textcolor{comment}{// Call all suitable solvers for this linear system }
00530     SelectSolvers<Scalar>(it.matrix(), it.sym(), it.rhs(), refX, statFile);
00531     
00532     \textcolor{keywordflow}{if}(statFileExists)
00533     \{
00534       std::ofstream statbuf(statFile.c\_str(), std::ios::app);
00535       statbuf << \textcolor{stringliteral}{"  <BEST\_SOLVER ID='"}<< best\_time\_id
00536               << \textcolor{stringliteral}{"'></BEST\_SOLVER>\(\backslash\)n"}; 
00537       statbuf << \textcolor{stringliteral}{" </LINEARSYSTEM> \(\backslash\)n"}; 
00538       statbuf.close();
00539     \}
00540   \} 
00541 \} 
00542 
00543 \textcolor{keywordtype}{bool} get\_options(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **args, \textcolor{keywordtype}{string} \hyperlink{structoption}{option}, \textcolor{keywordtype}{string}* value=0)
00544 \{
00545   \textcolor{keywordtype}{int} idx = 1, found=\textcolor{keyword}{false}; 
00546   \textcolor{keywordflow}{while} (idx<argc && !found)\{
00547     \textcolor{keywordflow}{if} (option.compare(args[idx]) == 0)\{
00548       found = \textcolor{keyword}{true}; 
00549       \textcolor{keywordflow}{if}(value) *value = args[idx+1];
00550     \}
00551     idx+=2;
00552   \}
00553   \textcolor{keywordflow}{return} found; 
00554 \}
\end{DoxyCode}
