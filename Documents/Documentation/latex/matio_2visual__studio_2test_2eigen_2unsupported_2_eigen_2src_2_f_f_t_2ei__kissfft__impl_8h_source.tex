\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_f_f_t_2ei__kissfft__impl_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+F\+F\+T/ei\+\_\+kissfft\+\_\+impl.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_f_f_t_2ei__kissfft__impl_8h_source}\index{ei\+\_\+kissfft\+\_\+impl.\+h@{ei\+\_\+kissfft\+\_\+impl.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Mark Borgerding mark a borgerding net}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00011 
00012 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00013 
00014   \textcolor{comment}{// This FFT implementation was derived from kissfft http:sourceforge.net/projects/kissfft}
00015   \textcolor{comment}{// Copyright 2003-2009 Mark Borgerding}
00016 
00017 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_Scalar>
00018 \textcolor{keyword}{struct }kiss\_cpx\_fft
00019 \{
00020   \textcolor{keyword}{typedef} \_Scalar Scalar;
00021   \textcolor{keyword}{typedef} std::complex<Scalar> Complex;
00022   std::vector<Complex> m\_twiddles;
00023   std::vector<int> m\_stageRadix;
00024   std::vector<int> m\_stageRemainder;
00025   std::vector<Complex> m\_scratchBuf;
00026   \textcolor{keywordtype}{bool} m\_inverse;
00027 
00028   \textcolor{keyword}{inline}
00029     \textcolor{keywordtype}{void} make\_twiddles(\textcolor{keywordtype}{int} nfft,\textcolor{keywordtype}{bool} inverse)
00030     \{
00031       \textcolor{keyword}{using} std::acos;
00032       m\_inverse = inverse;
00033       m\_twiddles.resize(nfft);
00034       Scalar phinc =  (inverse?2:-2)* acos( (Scalar) -1)  / nfft;
00035       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<nfft;++i)
00036         m\_twiddles[i] = exp( Complex(0,i*phinc) );
00037     \}
00038 
00039   \textcolor{keywordtype}{void} factorize(\textcolor{keywordtype}{int} nfft)
00040   \{
00041     \textcolor{comment}{//start factoring out 4's, then 2's, then 3,5,7,9,...}
00042     \textcolor{keywordtype}{int} n= nfft;
00043     \textcolor{keywordtype}{int} p=4;
00044     \textcolor{keywordflow}{do} \{
00045       \textcolor{keywordflow}{while} (n % p) \{
00046         \textcolor{keywordflow}{switch} (p) \{
00047           \textcolor{keywordflow}{case} 4: p = 2; \textcolor{keywordflow}{break};
00048           \textcolor{keywordflow}{case} 2: p = 3; \textcolor{keywordflow}{break};
00049           \textcolor{keywordflow}{default}: p += 2; \textcolor{keywordflow}{break};
00050         \}
00051         \textcolor{keywordflow}{if} (p*p>n)
00052           p=n;\textcolor{comment}{// impossible to have a factor > sqrt(n)}
00053       \}
00054       n /= p;
00055       m\_stageRadix.push\_back(p);
00056       m\_stageRemainder.push\_back(n);
00057       \textcolor{keywordflow}{if} ( p > 5 )
00058         m\_scratchBuf.resize(p); \textcolor{comment}{// scratchbuf will be needed in bfly\_generic}
00059     \}\textcolor{keywordflow}{while}(n>1);
00060   \}
00061 
00062   \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_Src>
00063     \textcolor{keyword}{inline}
00064     \textcolor{keywordtype}{void} work( \textcolor{keywordtype}{int} stage,Complex * xout, \textcolor{keyword}{const} \_Src * xin, \textcolor{keywordtype}{size\_t} fstride,\textcolor{keywordtype}{size\_t} in\_stride)
00065     \{
00066       \textcolor{keywordtype}{int} p = m\_stageRadix[stage];
00067       \textcolor{keywordtype}{int} m = m\_stageRemainder[stage];
00068       Complex * Fout\_beg = xout;
00069       Complex * Fout\_end = xout + p*m;
00070 
00071       \textcolor{keywordflow}{if} (m>1) \{
00072         \textcolor{keywordflow}{do}\{
00073           \textcolor{comment}{// recursive call:}
00074           \textcolor{comment}{// DFT of size m*p performed by doing}
00075           \textcolor{comment}{// p instances of smaller DFTs of size m, }
00076           \textcolor{comment}{// each one takes a decimated version of the input}
00077           work(stage+1, xout , xin, fstride*p,in\_stride);
00078           xin += fstride*in\_stride;
00079         \}\textcolor{keywordflow}{while}( (xout += m) != Fout\_end );
00080       \}\textcolor{keywordflow}{else}\{
00081         \textcolor{keywordflow}{do}\{
00082           *xout = *xin;
00083           xin += fstride*in\_stride;
00084         \}\textcolor{keywordflow}{while}(++xout != Fout\_end );
00085       \}
00086       xout=Fout\_beg;
00087 
00088       \textcolor{comment}{// recombine the p smaller DFTs }
00089       \textcolor{keywordflow}{switch} (p) \{
00090         \textcolor{keywordflow}{case} 2: bfly2(xout,fstride,m); \textcolor{keywordflow}{break};
00091         \textcolor{keywordflow}{case} 3: bfly3(xout,fstride,m); \textcolor{keywordflow}{break};
00092         \textcolor{keywordflow}{case} 4: bfly4(xout,fstride,m); \textcolor{keywordflow}{break};
00093         \textcolor{keywordflow}{case} 5: bfly5(xout,fstride,m); \textcolor{keywordflow}{break};
00094         \textcolor{keywordflow}{default}: bfly\_generic(xout,fstride,m,p); \textcolor{keywordflow}{break};
00095       \}
00096     \}
00097 
00098   \textcolor{keyword}{inline}
00099     \textcolor{keywordtype}{void} bfly2( Complex * Fout, \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} fstride, \textcolor{keywordtype}{int} m)
00100     \{
00101       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0;k<m;++k) \{
00102         Complex t = Fout[m+k] * m\_twiddles[k*fstride];
00103         Fout[m+k] = Fout[k] - t;
00104         Fout[k] += t;
00105       \}
00106     \}
00107 
00108   \textcolor{keyword}{inline}
00109     \textcolor{keywordtype}{void} bfly4( Complex * Fout, \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} fstride, \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} m)
00110     \{
00111       Complex scratch[6];
00112       \textcolor{keywordtype}{int} negative\_if\_inverse = m\_inverse * -2 +1;
00113       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} k=0;k<m;++k) \{
00114         scratch[0] = Fout[k+m] * m\_twiddles[k*fstride];
00115         scratch[1] = Fout[k+2*m] * m\_twiddles[k*fstride*2];
00116         scratch[2] = Fout[k+3*m] * m\_twiddles[k*fstride*3];
00117         scratch[5] = Fout[k] - scratch[1];
00118 
00119         Fout[k] += scratch[1];
00120         scratch[3] = scratch[0] + scratch[2];
00121         scratch[4] = scratch[0] - scratch[2];
00122         scratch[4] = Complex( scratch[4].imag()*negative\_if\_inverse , -scratch[4].real()* 
      negative\_if\_inverse );
00123 
00124         Fout[k+2*m]  = Fout[k] - scratch[3];
00125         Fout[k] += scratch[3];
00126         Fout[k+m] = scratch[5] + scratch[4];
00127         Fout[k+3*m] = scratch[5] - scratch[4];
00128       \}
00129     \}
00130 
00131   \textcolor{keyword}{inline}
00132     \textcolor{keywordtype}{void} bfly3( Complex * Fout, \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} fstride, \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} m)
00133     \{
00134       \textcolor{keywordtype}{size\_t} k=m;
00135       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} m2 = 2*m;
00136       Complex *tw1,*tw2;
00137       Complex scratch[5];
00138       Complex epi3;
00139       epi3 = m\_twiddles[fstride*m];
00140 
00141       tw1=tw2=&m\_twiddles[0];
00142 
00143       \textcolor{keywordflow}{do}\{
00144         scratch[1]=Fout[m] * *tw1;
00145         scratch[2]=Fout[m2] * *tw2;
00146 
00147         scratch[3]=scratch[1]+scratch[2];
00148         scratch[0]=scratch[1]-scratch[2];
00149         tw1 += fstride;
00150         tw2 += fstride*2;
00151         Fout[m] = Complex( Fout->real() - Scalar(.5)*scratch[3].real() , Fout->imag() - Scalar(.5)*scratch[
      3].imag() );
00152         scratch[0] *= epi3.imag();
00153         *Fout += scratch[3];
00154         Fout[m2] = Complex(  Fout[m].real() + scratch[0].imag() , Fout[m].imag() - scratch[0].real() );
00155         Fout[m] += Complex( -scratch[0].imag(),scratch[0].real() );
00156         ++Fout;
00157       \}\textcolor{keywordflow}{while}(--k);
00158     \}
00159 
00160   \textcolor{keyword}{inline}
00161     \textcolor{keywordtype}{void} bfly5( Complex * Fout, \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} fstride, \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} m)
00162     \{
00163       Complex *Fout0,*Fout1,*Fout2,*Fout3,*Fout4;
00164       \textcolor{keywordtype}{size\_t} u;
00165       Complex scratch[13];
00166       Complex * twiddles = &m\_twiddles[0];
00167       Complex *tw;
00168       Complex ya,yb;
00169       ya = twiddles[fstride*m];
00170       yb = twiddles[fstride*2*m];
00171 
00172       Fout0=Fout;
00173       Fout1=Fout0+m;
00174       Fout2=Fout0+2*m;
00175       Fout3=Fout0+3*m;
00176       Fout4=Fout0+4*m;
00177 
00178       tw=twiddles;
00179       \textcolor{keywordflow}{for} ( u=0; u<m; ++u ) \{
00180         scratch[0] = *Fout0;
00181 
00182         scratch[1]  = *Fout1 * tw[u*fstride];
00183         scratch[2]  = *Fout2 * tw[2*u*fstride];
00184         scratch[3]  = *Fout3 * tw[3*u*fstride];
00185         scratch[4]  = *Fout4 * tw[4*u*fstride];
00186 
00187         scratch[7] = scratch[1] + scratch[4];
00188         scratch[10] = scratch[1] - scratch[4];
00189         scratch[8] = scratch[2] + scratch[3];
00190         scratch[9] = scratch[2] - scratch[3];
00191 
00192         *Fout0 +=  scratch[7];
00193         *Fout0 +=  scratch[8];
00194 
00195         scratch[5] = scratch[0] + Complex(
00196             (scratch[7].real()*ya.real() ) + (scratch[8].real() *yb.real() ),
00197             (scratch[7].imag()*ya.real()) + (scratch[8].imag()*yb.real())
00198             );
00199 
00200         scratch[6] = Complex(
00201             (scratch[10].imag()*ya.imag()) + (scratch[9].imag()*yb.imag()),
00202             -(scratch[10].real()*ya.imag()) - (scratch[9].real()*yb.imag())
00203             );
00204 
00205         *Fout1 = scratch[5] - scratch[6];
00206         *Fout4 = scratch[5] + scratch[6];
00207 
00208         scratch[11] = scratch[0] +
00209           Complex(
00210               (scratch[7].real()*yb.real()) + (scratch[8].real()*ya.real()),
00211               (scratch[7].imag()*yb.real()) + (scratch[8].imag()*ya.real())
00212               );
00213 
00214         scratch[12] = Complex(
00215             -(scratch[10].imag()*yb.imag()) + (scratch[9].imag()*ya.imag()),
00216             (scratch[10].real()*yb.imag()) - (scratch[9].real()*ya.imag())
00217             );
00218 
00219         *Fout2=scratch[11]+scratch[12];
00220         *Fout3=scratch[11]-scratch[12];
00221 
00222         ++Fout0;++Fout1;++Fout2;++Fout3;++Fout4;
00223       \}
00224     \}
00225 
00226   \textcolor{comment}{/* perform the butterfly for one stage of a mixed radix FFT */}
00227   \textcolor{keyword}{inline}
00228     \textcolor{keywordtype}{void} bfly\_generic(
00229         Complex * Fout,
00230         \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} fstride,
00231         \textcolor{keywordtype}{int} m,
00232         \textcolor{keywordtype}{int} p
00233         )
00234     \{
00235       \textcolor{keywordtype}{int} u,k,q1,q;
00236       Complex * twiddles = &m\_twiddles[0];
00237       Complex t;
00238       \textcolor{keywordtype}{int} Norig = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(m\_twiddles.size());
00239       Complex * scratchbuf = &m\_scratchBuf[0];
00240 
00241       \textcolor{keywordflow}{for} ( u=0; u<m; ++u ) \{
00242         k=u;
00243         \textcolor{keywordflow}{for} ( q1=0 ; q1<p ; ++q1 ) \{
00244           scratchbuf[q1] = Fout[ k  ];
00245           k += m;
00246         \}
00247 
00248         k=u;
00249         \textcolor{keywordflow}{for} ( q1=0 ; q1<p ; ++q1 ) \{
00250           \textcolor{keywordtype}{int} twidx=0;
00251           Fout[ k ] = scratchbuf[0];
00252           \textcolor{keywordflow}{for} (q=1;q<p;++q ) \{
00253             twidx += \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(fstride) * k;
00254             \textcolor{keywordflow}{if} (twidx>=Norig) twidx-=Norig;
00255             t=scratchbuf[q] * twiddles[twidx];
00256             Fout[ k ] += t;
00257           \}
00258           k += m;
00259         \}
00260       \}
00261     \}
00262 \};
00263 
00264 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_Scalar>
00265 \textcolor{keyword}{struct }kissfft\_impl
00266 \{
00267   \textcolor{keyword}{typedef} \_Scalar Scalar;
00268   \textcolor{keyword}{typedef} std::complex<Scalar> Complex;
00269 
00270   \textcolor{keywordtype}{void} clear() 
00271   \{
00272     m\_plans.clear();
00273     m\_realTwiddles.clear();
00274   \}
00275 
00276   \textcolor{keyword}{inline}
00277     \textcolor{keywordtype}{void} fwd( Complex * dst,\textcolor{keyword}{const} Complex *src,\textcolor{keywordtype}{int} nfft)
00278     \{
00279       get\_plan(nfft,\textcolor{keyword}{false}).work(0, dst, src, 1,1);
00280     \}
00281 
00282   \textcolor{keyword}{inline}
00283     \textcolor{keywordtype}{void} fwd2( Complex * dst,\textcolor{keyword}{const} Complex *src,\textcolor{keywordtype}{int} n0,\textcolor{keywordtype}{int} n1)
00284     \{
00285         EIGEN\_UNUSED\_VARIABLE(dst);
00286         EIGEN\_UNUSED\_VARIABLE(src);
00287         EIGEN\_UNUSED\_VARIABLE(n0);
00288         EIGEN\_UNUSED\_VARIABLE(n1);
00289     \}
00290 
00291   \textcolor{keyword}{inline}
00292     \textcolor{keywordtype}{void} inv2( Complex * dst,\textcolor{keyword}{const} Complex *src,\textcolor{keywordtype}{int} n0,\textcolor{keywordtype}{int} n1)
00293     \{
00294         EIGEN\_UNUSED\_VARIABLE(dst);
00295         EIGEN\_UNUSED\_VARIABLE(src);
00296         EIGEN\_UNUSED\_VARIABLE(n0);
00297         EIGEN\_UNUSED\_VARIABLE(n1);
00298     \}
00299 
00300   \textcolor{comment}{// real-to-complex forward FFT}
00301   \textcolor{comment}{// perform two FFTs of src even and src odd}
00302   \textcolor{comment}{// then twiddle to recombine them into the half-spectrum format}
00303   \textcolor{comment}{// then fill in the conjugate symmetric half}
00304   \textcolor{keyword}{inline}
00305     \textcolor{keywordtype}{void} fwd( Complex * dst,\textcolor{keyword}{const} Scalar * src,\textcolor{keywordtype}{int} nfft) 
00306     \{
00307       \textcolor{keywordflow}{if} ( nfft&3  ) \{
00308         \textcolor{comment}{// use generic mode for odd}
00309         m\_tmpBuf1.resize(nfft);
00310         get\_plan(nfft,\textcolor{keyword}{false}).work(0, &m\_tmpBuf1[0], src, 1,1);
00311         std::copy(m\_tmpBuf1.begin(),m\_tmpBuf1.begin()+(nfft>>1)+1,dst );
00312       \}\textcolor{keywordflow}{else}\{
00313         \textcolor{keywordtype}{int} ncfft = nfft>>1;
00314         \textcolor{keywordtype}{int} ncfft2 = nfft>>2;
00315         Complex * rtw = real\_twiddles(ncfft2);
00316 
00317         \textcolor{comment}{// use optimized mode for even real}
00318         fwd( dst, reinterpret\_cast<const Complex*> (src), ncfft);
00319         Complex dc = dst[0].real() +  dst[0].imag();
00320         Complex nyquist = dst[0].real() -  dst[0].imag();
00321         \textcolor{keywordtype}{int} k;
00322         \textcolor{keywordflow}{for} ( k=1;k <= ncfft2 ; ++k ) \{
00323           Complex fpk = dst[k];
00324           Complex fpnk = conj(dst[ncfft-k]);
00325           Complex f1k = fpk + fpnk;
00326           Complex f2k = fpk - fpnk;
00327           Complex tw= f2k * rtw[k-1];
00328           dst[k] =  (f1k + tw) * Scalar(.5);
00329           dst[ncfft-k] =  conj(f1k -tw)*Scalar(.5);
00330         \}
00331         dst[0] = dc;
00332         dst[ncfft] = nyquist;
00333       \}
00334     \}
00335 
00336   \textcolor{comment}{// inverse complex-to-complex}
00337   \textcolor{keyword}{inline}
00338     \textcolor{keywordtype}{void} inv(Complex * dst,\textcolor{keyword}{const} Complex  *src,\textcolor{keywordtype}{int} nfft)
00339     \{
00340       get\_plan(nfft,\textcolor{keyword}{true}).work(0, dst, src, 1,1);
00341     \}
00342 
00343   \textcolor{comment}{// half-complex to scalar}
00344   \textcolor{keyword}{inline}
00345     \textcolor{keywordtype}{void} inv( Scalar * dst,\textcolor{keyword}{const} Complex * src,\textcolor{keywordtype}{int} nfft) 
00346     \{
00347       \textcolor{keywordflow}{if} (nfft&3) \{
00348         m\_tmpBuf1.resize(nfft);
00349         m\_tmpBuf2.resize(nfft);
00350         std::copy(src,src+(nfft>>1)+1,m\_tmpBuf1.begin() );
00351         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=1;k<(nfft>>1)+1;++k)
00352           m\_tmpBuf1[nfft-k] = conj(m\_tmpBuf1[k]);
00353         inv(&m\_tmpBuf2[0],&m\_tmpBuf1[0],nfft);
00354         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0;k<nfft;++k)
00355           dst[k] = m\_tmpBuf2[k].real();
00356       \}\textcolor{keywordflow}{else}\{
00357         \textcolor{comment}{// optimized version for multiple of 4}
00358         \textcolor{keywordtype}{int} ncfft = nfft>>1;
00359         \textcolor{keywordtype}{int} ncfft2 = nfft>>2;
00360         Complex * rtw = real\_twiddles(ncfft2);
00361         m\_tmpBuf1.resize(ncfft);
00362         m\_tmpBuf1[0] = Complex( src[0].real() + src[ncfft].real(), src[0].real() - src[ncfft].real() );
00363         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 1; k <= ncfft / 2; ++k) \{
00364           Complex fk = src[k];
00365           Complex fnkc = conj(src[ncfft-k]);
00366           Complex fek = fk + fnkc;
00367           Complex tmp = fk - fnkc;
00368           Complex fok = tmp * conj(rtw[k-1]);
00369           m\_tmpBuf1[k] = fek + fok;
00370           m\_tmpBuf1[ncfft-k] = conj(fek - fok);
00371         \}
00372         get\_plan(ncfft,\textcolor{keyword}{true}).work(0, reinterpret\_cast<Complex*>(dst), &m\_tmpBuf1[0], 1,1);
00373       \}
00374     \}
00375 
00376   \textcolor{keyword}{protected}:
00377   \textcolor{keyword}{typedef} kiss\_cpx\_fft<Scalar> PlanData;
00378   \textcolor{keyword}{typedef} std::map<int,PlanData> PlanMap;
00379 
00380   PlanMap m\_plans;
00381   std::map<int, std::vector<Complex> > m\_realTwiddles;
00382   std::vector<Complex> m\_tmpBuf1;
00383   std::vector<Complex> m\_tmpBuf2;
00384 
00385   \textcolor{keyword}{inline}
00386     \textcolor{keywordtype}{int} PlanKey(\textcolor{keywordtype}{int} nfft, \textcolor{keywordtype}{bool} isinverse)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} (nfft<<1) | int(isinverse); \}
00387 
00388   \textcolor{keyword}{inline}
00389     PlanData & get\_plan(\textcolor{keywordtype}{int} nfft, \textcolor{keywordtype}{bool} inverse)
00390     \{
00391       \textcolor{comment}{// TODO look for PlanKey(nfft, ! inverse) and conjugate the twiddles}
00392       PlanData & pd = m\_plans[ PlanKey(nfft,inverse) ];
00393       \textcolor{keywordflow}{if} ( pd.m\_twiddles.size() == 0 ) \{
00394         pd.make\_twiddles(nfft,inverse);
00395         pd.factorize(nfft);
00396       \}
00397       \textcolor{keywordflow}{return} pd;
00398     \}
00399 
00400   \textcolor{keyword}{inline}
00401     Complex * real\_twiddles(\textcolor{keywordtype}{int} ncfft2)
00402     \{
00403       \textcolor{keyword}{using} std::acos;
00404       std::vector<Complex> & twidref = m\_realTwiddles[ncfft2];\textcolor{comment}{// creates new if not there}
00405       \textcolor{keywordflow}{if} ( (\textcolor{keywordtype}{int})twidref.size() != ncfft2 ) \{
00406         twidref.resize(ncfft2);
00407         \textcolor{keywordtype}{int} ncfft= ncfft2<<1;
00408         Scalar pi =  acos( Scalar(-1) );
00409         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=1;k<=ncfft2;++k) 
00410           twidref[k-1] = exp( Complex(0,-pi * (Scalar(k) / ncfft + Scalar(.5)) ) );
00411       \}
00412       \textcolor{keywordflow}{return} &twidref[0];
00413     \}
00414 \};
00415 
00416 \} \textcolor{comment}{// end namespace internal}
00417 
00418 \} \textcolor{comment}{// end namespace Eigen}
00419 
00420 \textcolor{comment}{/* vim: set filetype=cpp et sw=2 ts=2 ai: */}
\end{DoxyCode}
