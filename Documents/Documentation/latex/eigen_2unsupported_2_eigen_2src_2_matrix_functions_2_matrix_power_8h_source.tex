\hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source}{}\section{eigen/unsupported/\+Eigen/src/\+Matrix\+Functions/\+Matrix\+Power.h}
\label{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source}\index{Matrix\+Power.\+h@{Matrix\+Power.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012, 2013 Chen-Pang He <jdh8@ms63.hinet.net>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_MATRIX\_POWER}
00011 \textcolor{preprocessor}{#define EIGEN\_MATRIX\_POWER}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00015}\hyperlink{class_eigen_1_1_matrix_power}{00015} \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_matrix_power}{MatrixPower};
00016 
00030 \textcolor{comment}{/* TODO This class is only used by MatrixPower, so it should be nested}
00031 \textcolor{comment}{ * into MatrixPower, like MatrixPower::ReturnValue. However, my}
00032 \textcolor{comment}{ * compiler complained about unused template parameter in the}
00033 \textcolor{comment}{ * following declaration in namespace internal.}
00034 \textcolor{comment}{ *}
00035 \textcolor{comment}{ * template<typename MatrixType>}
00036 \textcolor{comment}{ * struct traits<MatrixPower<MatrixType>::ReturnValue>;}
00037 \textcolor{comment}{ */}
00038 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00039}\hyperlink{class_eigen_1_1_matrix_power_parentheses_return_value}{00039} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_matrix_power_parentheses_return_value}{MatrixPowerParenthesesReturnValue} : \textcolor{keyword}{public} 
      \hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue}< MatrixPowerParenthesesReturnValue<MatrixType> >
00040 \{
00041   \textcolor{keyword}{public}:
00042     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00043     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index Index;
00044 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00051}\hyperlink{class_eigen_1_1_matrix_power_parentheses_return_value_ae3a02d943a31427a6dc8c1f60f3367d7}{00051}     \hyperlink{class_eigen_1_1_matrix_power_parentheses_return_value_ae3a02d943a31427a6dc8c1f60f3367d7}{MatrixPowerParenthesesReturnValue}(
      \hyperlink{class_eigen_1_1_matrix_power}{MatrixPower<MatrixType>}& pow, RealScalar p) : m\_pow(pow), m\_p(p)
00052     \{ \}
00053 
00059     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ResultType>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00060}\hyperlink{class_eigen_1_1_matrix_power_parentheses_return_value_a4022dd383b54272e53e52f4f7059579f}{00060}     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power_parentheses_return_value_a4022dd383b54272e53e52f4f7059579f}{evalTo}(ResultType& res)\textcolor{keyword}{ const}
00061 \textcolor{keyword}{    }\{ m\_pow.compute(res, m\_p); \}
00062 
00063     Index rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_pow.rows(); \}
00064     Index cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_pow.cols(); \}
00065 
00066   \textcolor{keyword}{private}:
00067     \hyperlink{class_eigen_1_1_matrix_power}{MatrixPower<MatrixType>}& m\_pow;
00068     \textcolor{keyword}{const} RealScalar m\_p;
00069 \};
00070 
00086 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00087}\hyperlink{class_eigen_1_1_matrix_power_atomic}{00087} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_matrix_power_atomic}{MatrixPowerAtomic} : \hyperlink{class_eigen_1_1internal_1_1noncopyable}{internal::noncopyable}
00088 \{
00089   \textcolor{keyword}{private}:
00090     \textcolor{keyword}{enum} \{
00091       RowsAtCompileTime = MatrixType::RowsAtCompileTime,
00092       MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime
00093     \};
00094     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00095     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00096     \textcolor{keyword}{typedef} std::complex<RealScalar> ComplexScalar;
00097     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index Index;
00098     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_block}{Block<MatrixType,Dynamic,Dynamic>} 
      \hyperlink{group___core___module_class_eigen_1_1_block}{ResultType};
00099 
00100     \textcolor{keyword}{const} MatrixType& m\_A;
00101     RealScalar m\_p;
00102 
00103     \textcolor{keywordtype}{void} computePade(\textcolor{keywordtype}{int} degree, \textcolor{keyword}{const} MatrixType& IminusT, ResultType& res) \textcolor{keyword}{const};
00104     \textcolor{keywordtype}{void} compute2x2(ResultType& res, RealScalar p) \textcolor{keyword}{const};
00105     \textcolor{keywordtype}{void} computeBig(ResultType& res) \textcolor{keyword}{const};
00106     \textcolor{keyword}{static} \textcolor{keywordtype}{int} getPadeDegree(\textcolor{keywordtype}{float} normIminusT);
00107     \textcolor{keyword}{static} \textcolor{keywordtype}{int} getPadeDegree(\textcolor{keywordtype}{double} normIminusT);
00108     \textcolor{keyword}{static} \textcolor{keywordtype}{int} getPadeDegree(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} normIminusT);
00109     \textcolor{keyword}{static} ComplexScalar computeSuperDiag(\textcolor{keyword}{const} ComplexScalar&, \textcolor{keyword}{const} ComplexScalar&, RealScalar p);
00110     \textcolor{keyword}{static} RealScalar computeSuperDiag(RealScalar, RealScalar, RealScalar p);
00111 
00112   \textcolor{keyword}{public}:
00124     \hyperlink{class_eigen_1_1_matrix_power_atomic}{MatrixPowerAtomic}(\textcolor{keyword}{const} MatrixType& \hyperlink{group___sparse_core___module}{T}, RealScalar p);
00125     
00132     \textcolor{keywordtype}{void} compute(ResultType& res) \textcolor{keyword}{const};
00133 \};
00134 
00135 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00136}\hyperlink{class_eigen_1_1_matrix_power_atomic_ac0ec5f8d6c203cd9b53e2c95e01037d4}{00136} \hyperlink{class_eigen_1_1_matrix_power_atomic_ac0ec5f8d6c203cd9b53e2c95e01037d4}{MatrixPowerAtomic<MatrixType>::MatrixPowerAtomic}(\textcolor{keyword}{const} 
      MatrixType& \hyperlink{group___sparse_core___module}{T}, RealScalar p) :
00137   m\_A(T), m\_p(p)
00138 \{
00139   eigen\_assert(T.rows() == T.cols());
00140   eigen\_assert(p > -1 && p < 1);
00141 \}
00142 
00143 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00144}\hyperlink{class_eigen_1_1_matrix_power_atomic_ac3cdfb54a5b60079d068784534cbc174}{00144} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power_atomic_ac3cdfb54a5b60079d068784534cbc174}{MatrixPowerAtomic<MatrixType>::compute}(
      \hyperlink{group___core___module_class_eigen_1_1_block}{ResultType}& res)\textcolor{keyword}{ const}
00145 \textcolor{keyword}{}\{
00146   \textcolor{keyword}{using} std::pow;
00147   \textcolor{keywordflow}{switch} (m\_A.rows()) \{
00148     \textcolor{keywordflow}{case} 0:
00149       \textcolor{keywordflow}{break};
00150     \textcolor{keywordflow}{case} 1:
00151       res(0,0) = pow(m\_A(0,0), m\_p);
00152       \textcolor{keywordflow}{break};
00153     \textcolor{keywordflow}{case} 2:
00154       compute2x2(res, m\_p);
00155       \textcolor{keywordflow}{break};
00156     \textcolor{keywordflow}{default}:
00157       computeBig(res);
00158   \}
00159 \}
00160 
00161 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00162 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power_atomic}{MatrixPowerAtomic<MatrixType>::computePade}(\textcolor{keywordtype}{int} degree, \textcolor{keyword}{const}
       MatrixType& IminusT, \hyperlink{group___core___module_class_eigen_1_1_block}{ResultType}& res)\textcolor{keyword}{ const}
00163 \textcolor{keyword}{}\{
00164   \textcolor{keywordtype}{int} i = 2*degree;
00165   res = (m\_p-degree) / (2*i-2) * IminusT;
00166 
00167   \textcolor{keywordflow}{for} (--i; i; --i) \{
00168     res = (MatrixType::Identity(IminusT.rows(), IminusT.cols()) + res).template triangularView<Upper>()
00169     .solve((i==1 ? -m\_p : i&1 ? (-m\_p-i/2)/(2*i) : (m\_p-i/2)/(2*i-2)) * IminusT).eval();
00170   \}
00171   res += MatrixType::Identity(IminusT.rows(), IminusT.cols());
00172 \}
00173 
00174 \textcolor{comment}{// This function assumes that res has the correct size (see bug 614)}
00175 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00176 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power_atomic}{MatrixPowerAtomic<MatrixType>::compute2x2}(
      \hyperlink{group___core___module_class_eigen_1_1_block}{ResultType}& res, RealScalar p)\textcolor{keyword}{ const}
00177 \textcolor{keyword}{}\{
00178   \textcolor{keyword}{using} std::abs;
00179   \textcolor{keyword}{using} std::pow;
00180   res.coeffRef(0,0) = pow(m\_A.coeff(0,0), p);
00181 
00182   \textcolor{keywordflow}{for} (Index i=1; i < m\_A.cols(); ++i) \{
00183     res.coeffRef(i,i) = pow(m\_A.coeff(i,i), p);
00184     \textcolor{keywordflow}{if} (m\_A.coeff(i-1,i-1) == m\_A.coeff(i,i))
00185       res.coeffRef(i-1,i) = p * pow(m\_A.coeff(i,i), p-1);
00186     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (2*abs(m\_A.coeff(i-1,i-1)) < abs(m\_A.coeff(i,i)) || 2*abs(m\_A.coeff(i,i)) < abs(m\_A.coeff(i-1,i
      -1)))
00187       res.coeffRef(i-1,i) = (res.coeff(i,i)-res.coeff(i-1,i-1)) / (m\_A.coeff(i,i)-m\_A.coeff(i-1,i-1));
00188     \textcolor{keywordflow}{else}
00189       res.coeffRef(i-1,i) = computeSuperDiag(m\_A.coeff(i,i), m\_A.coeff(i-1,i-1), p);
00190     res.coeffRef(i-1,i) *= m\_A.coeff(i-1,i);
00191   \}
00192 \}
00193 
00194 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00195 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power_atomic}{MatrixPowerAtomic<MatrixType>::computeBig}(
      \hyperlink{group___core___module_class_eigen_1_1_block}{ResultType}& res)\textcolor{keyword}{ const}
00196 \textcolor{keyword}{}\{
00197   \textcolor{keyword}{using} std::ldexp;
00198   \textcolor{keyword}{const} \textcolor{keywordtype}{int} digits = std::numeric\_limits<RealScalar>::digits;
00199   \textcolor{keyword}{const} RealScalar maxNormForPade = digits <=  24? 4.3386528e-1L                            \textcolor{comment}{// single
       precision}
00200                                   : digits <=  53? 2.789358995219730e-1L                    \textcolor{comment}{// double
       precision}
00201                                   : digits <=  64? 2.4471944416607995472e-1L                \textcolor{comment}{// extended
       precision}
00202                                   : digits <= 106? 1.1016843812851143391275867258512e-1L    \textcolor{comment}{//
       double-double}
00203                                   :                9.134603732914548552537150753385375e-2L; \textcolor{comment}{// quadruple
       precision}
00204   MatrixType IminusT, sqrtT, \hyperlink{group___sparse_core___module}{T} = m\_A.template triangularView<Upper>();
00205   RealScalar normIminusT;
00206   \textcolor{keywordtype}{int} degree, degree2, numberOfSquareRoots = 0;
00207   \textcolor{keywordtype}{bool} hasExtraSquareRoot = \textcolor{keyword}{false};
00208 
00209   \textcolor{keywordflow}{for} (Index i=0; i < m\_A.cols(); ++i)
00210     eigen\_assert(m\_A(i,i) != RealScalar(0));
00211 
00212   \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
00213     IminusT = MatrixType::Identity(m\_A.rows(), m\_A.cols()) - T;
00214     normIminusT = IminusT.cwiseAbs().colwise().sum().maxCoeff();
00215     \textcolor{keywordflow}{if} (normIminusT < maxNormForPade) \{
00216       degree = getPadeDegree(normIminusT);
00217       degree2 = getPadeDegree(normIminusT/2);
00218       \textcolor{keywordflow}{if} (degree - degree2 <= 1 || hasExtraSquareRoot)
00219     \textcolor{keywordflow}{break};
00220       hasExtraSquareRoot = \textcolor{keyword}{true};
00221     \}
00222     \hyperlink{namespace_eigen_ae51c91f920f6ea4a7f6f72caa1e8249f}{matrix\_sqrt\_triangular}(T, sqrtT);
00223     T = sqrtT.template triangularView<Upper>();
00224     ++numberOfSquareRoots;
00225   \}
00226   computePade(degree, IminusT, res);
00227 
00228   \textcolor{keywordflow}{for} (; numberOfSquareRoots; --numberOfSquareRoots) \{
00229     compute2x2(res, ldexp(m\_p, -numberOfSquareRoots));
00230     res = res.template triangularView<Upper>() * res;
00231   \}
00232   compute2x2(res, m\_p);
00233 \}
00234   
00235 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00236 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \hyperlink{class_eigen_1_1_matrix_power_atomic}{MatrixPowerAtomic<MatrixType>::getPadeDegree}(\textcolor{keywordtype}{float} 
      normIminusT)
00237 \{
00238   \textcolor{keyword}{const} \textcolor{keywordtype}{float} maxNormForPade[] = \{ 2.8064004e-1f \textcolor{comment}{/* degree = 3 */} , 4.3386528e-1f \};
00239   \textcolor{keywordtype}{int} degree = 3;
00240   \textcolor{keywordflow}{for} (; degree <= 4; ++degree)
00241     \textcolor{keywordflow}{if} (normIminusT <= maxNormForPade[degree - 3])
00242       \textcolor{keywordflow}{break};
00243   \textcolor{keywordflow}{return} degree;
00244 \}
00245 
00246 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00247 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \hyperlink{class_eigen_1_1_matrix_power_atomic}{MatrixPowerAtomic<MatrixType>::getPadeDegree}(\textcolor{keywordtype}{double} 
      normIminusT)
00248 \{
00249   \textcolor{keyword}{const} \textcolor{keywordtype}{double} maxNormForPade[] = \{ 1.884160592658218e-2 \textcolor{comment}{/* degree = 3 */} , 6.038881904059573e-2, 1.2399175
      16308172e-1,
00250       1.999045567181744e-1, 2.789358995219730e-1 \};
00251   \textcolor{keywordtype}{int} degree = 3;
00252   \textcolor{keywordflow}{for} (; degree <= 7; ++degree)
00253     \textcolor{keywordflow}{if} (normIminusT <= maxNormForPade[degree - 3])
00254       \textcolor{keywordflow}{break};
00255   \textcolor{keywordflow}{return} degree;
00256 \}
00257 
00258 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00259 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \hyperlink{class_eigen_1_1_matrix_power_atomic}{MatrixPowerAtomic<MatrixType>::getPadeDegree}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{
      double} normIminusT)
00260 \{
00261 \textcolor{preprocessor}{#if   LDBL\_MANT\_DIG == 53}
00262   \textcolor{keyword}{const} \textcolor{keywordtype}{int} maxPadeDegree = 7;
00263   \textcolor{keyword}{const} \textcolor{keywordtype}{double} maxNormForPade[] = \{ 1.884160592658218e-2L \textcolor{comment}{/* degree = 3 */} , 6.038881904059573e-2L, 1.23991
      7516308172e-1L,
00264       1.999045567181744e-1L, 2.789358995219730e-1L \};
00265 \textcolor{preprocessor}{#elif LDBL\_MANT\_DIG <= 64}
00266   \textcolor{keyword}{const} \textcolor{keywordtype}{int} maxPadeDegree = 8;
00267   \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} maxNormForPade[] = \{ 6.3854693117491799460e-3L \textcolor{comment}{/* degree = 3 */} , 2.6394893435456973676
      e-2L,
00268       6.4216043030404063729e-2L, 1.1701165502926694307e-1L, 1.7904284231268670284e-1L, 2.447194441660799547
      2e-1L \};
00269 \textcolor{preprocessor}{#elif LDBL\_MANT\_DIG <= 106}
00270   \textcolor{keyword}{const} \textcolor{keywordtype}{int} maxPadeDegree = 10;
00271   \textcolor{keyword}{const} \textcolor{keywordtype}{double} maxNormForPade[] = \{ 1.0007161601787493236741409687186e-4L \textcolor{comment}{/* degree = 3 */} ,
00272       1.0007161601787493236741409687186e-3L, 4.7069769360887572939882574746264e-3L, 1.322038662416915968940
      6653101695e-2L,
00273       2.8063482381631737920612944054906e-2L, 4.9625993951953473052385361085058e-2L, 7.736704070602788622455
      7538328171e-2L,
00274       1.1016843812851143391275867258512e-1L \};
00275 \textcolor{preprocessor}{#else}
00276   \textcolor{keyword}{const} \textcolor{keywordtype}{int} maxPadeDegree = 10;
00277   \textcolor{keyword}{const} \textcolor{keywordtype}{double} maxNormForPade[] = \{ 5.524506147036624377378713555116378e-5L \textcolor{comment}{/* degree = 3 */} ,
00278       6.640600568157479679823602193345995e-4L, 3.227716520106894279249709728084626e-3L,
00279       9.619593944683432960546978734646284e-3L, 2.134595382433742403911124458161147e-2L,
00280       3.908166513900489428442993794761185e-2L, 6.266780814639442865832535460550138e-2L,
00281       9.134603732914548552537150753385375e-2L \};
00282 \textcolor{preprocessor}{#endif}
00283   \textcolor{keywordtype}{int} degree = 3;
00284   \textcolor{keywordflow}{for} (; degree <= maxPadeDegree; ++degree)
00285     \textcolor{keywordflow}{if} (normIminusT <= maxNormForPade[degree - 3])
00286       \textcolor{keywordflow}{break};
00287   \textcolor{keywordflow}{return} degree;
00288 \}
00289 
00290 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00291 \textcolor{keyword}{inline} \textcolor{keyword}{typename} MatrixPowerAtomic<MatrixType>::ComplexScalar
00292 \hyperlink{class_eigen_1_1_matrix_power_atomic}{MatrixPowerAtomic<MatrixType>::computeSuperDiag}(\textcolor{keyword}{const} 
      ComplexScalar& curr, \textcolor{keyword}{const} ComplexScalar& prev, RealScalar p)
00293 \{
00294   \textcolor{keyword}{using} std::ceil;
00295   \textcolor{keyword}{using} std::exp;
00296   \textcolor{keyword}{using} std::log;
00297   \textcolor{keyword}{using} std::sinh;
00298 
00299   ComplexScalar logCurr = \hyperlink{structlog}{log}(curr);
00300   ComplexScalar logPrev = \hyperlink{structlog}{log}(prev);
00301   \textcolor{keywordtype}{int} unwindingNumber = ceil((numext::imag(logCurr - logPrev) - RealScalar(EIGEN\_PI)) / RealScalar(2*
      EIGEN\_PI));
00302   ComplexScalar w = numext::log1p((curr-prev)/prev)/RealScalar(2) + ComplexScalar(0, EIGEN\_PI*
      unwindingNumber);
00303   \textcolor{keywordflow}{return} RealScalar(2) * exp(RealScalar(0.5) * p * (logCurr + logPrev)) * sinh(p * w) / (curr - prev);
00304 \}
00305 
00306 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00307 \textcolor{keyword}{inline} \textcolor{keyword}{typename} MatrixPowerAtomic<MatrixType>::RealScalar
00308 \hyperlink{class_eigen_1_1_matrix_power_atomic}{MatrixPowerAtomic<MatrixType>::computeSuperDiag}(RealScalar 
      curr, RealScalar prev, RealScalar p)
00309 \{
00310   \textcolor{keyword}{using} std::exp;
00311   \textcolor{keyword}{using} std::log;
00312   \textcolor{keyword}{using} std::sinh;
00313 
00314   RealScalar w = numext::log1p((curr-prev)/prev)/RealScalar(2);
00315   \textcolor{keywordflow}{return} 2 * exp(p * (\hyperlink{structlog}{log}(curr) + \hyperlink{structlog}{log}(prev)) / 2) * sinh(p * w) / (curr - prev);
00316 \}
00317 
00337 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00338 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_matrix_power}{MatrixPower} : \hyperlink{class_eigen_1_1internal_1_1noncopyable}{internal::noncopyable}
00339 \{
00340   \textcolor{keyword}{private}:
00341     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00342     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00343     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index Index;
00344 
00345   \textcolor{keyword}{public}:
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00354}\hyperlink{class_eigen_1_1_matrix_power_a5eb445525601510413b53cd347c44716}{00354}     \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1_matrix_power_a5eb445525601510413b53cd347c44716}{MatrixPower}(\textcolor{keyword}{const} MatrixType& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}) :
00355       m\_A(A),
00356       m\_conditionNumber(0),
00357       m\_rank(A.cols()),
00358       m\_nulls(0)
00359     \{ eigen\_assert(A.rows() == A.cols()); \}
00360 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00368}\hyperlink{class_eigen_1_1_matrix_power_a2ad22d156b1a7ff12d6c40a093cd95eb}{00368}     \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_matrix_power_parentheses_return_value}{MatrixPowerParenthesesReturnValue<MatrixType>} 
      \hyperlink{class_eigen_1_1_matrix_power_a2ad22d156b1a7ff12d6c40a093cd95eb}{operator()}(RealScalar p)
00369     \{ \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_matrix_power_parentheses_return_value}{MatrixPowerParenthesesReturnValue<MatrixType>}(*\textcolor{keyword}{
      this}, p); \}
00370 
00378     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ResultType>
00379     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power_atomic_ac3cdfb54a5b60079d068784534cbc174}{compute}(ResultType& res, RealScalar p);
00380     
00381     Index rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_A.rows(); \}
00382     Index cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_A.cols(); \}
00383 
00384   \textcolor{keyword}{private}:
00385     \textcolor{keyword}{typedef} std::complex<RealScalar> ComplexScalar;
00386     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<ComplexScalar, \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, 0,
00387               MatrixType::RowsAtCompileTime, MatrixType::ColsAtCompileTime> 
      \hyperlink{group___core___module}{ComplexMatrix};
00388 
00390     \textcolor{keyword}{typename} MatrixType::Nested m\_A;
00391 
00393     MatrixType m\_tmp;
00394 
00396     ComplexMatrix m\_T, m\_U;
00397     
00399     ComplexMatrix m\_fT;
00400 
00407     RealScalar m\_conditionNumber;
00408 
00410     Index m\_rank;
00411     
00413     Index m\_nulls;
00414 
00424     \textcolor{keywordtype}{void} split(RealScalar& p, RealScalar& intpart);
00425 
00427     \textcolor{keywordtype}{void} initialize();
00428 
00429     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ResultType>
00430     \textcolor{keywordtype}{void} computeIntPower(ResultType& res, RealScalar p);
00431 
00432     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ResultType>
00433     \textcolor{keywordtype}{void} computeFracPower(ResultType& res, RealScalar p);
00434 
00435     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Rows, \textcolor{keywordtype}{int} Cols, \textcolor{keywordtype}{int} Options, \textcolor{keywordtype}{int} MaxRows, \textcolor{keywordtype}{int} MaxCols>
00436     \textcolor{keyword}{static} \textcolor{keywordtype}{void} revertSchur(
00437         \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<ComplexScalar, Rows, Cols, Options, MaxRows, MaxCols>}
      & res,
00438         \textcolor{keyword}{const} ComplexMatrix& \hyperlink{group___sparse_core___module}{T},
00439         \textcolor{keyword}{const} ComplexMatrix& U);
00440 
00441     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Rows, \textcolor{keywordtype}{int} Cols, \textcolor{keywordtype}{int} Options, \textcolor{keywordtype}{int} MaxRows, \textcolor{keywordtype}{int} MaxCols>
00442     \textcolor{keyword}{static} \textcolor{keywordtype}{void} revertSchur(
00443         \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<RealScalar, Rows, Cols, Options, MaxRows, MaxCols>}
      & res,
00444         \textcolor{keyword}{const} ComplexMatrix& T,
00445         \textcolor{keyword}{const} ComplexMatrix& U);
00446 \};
00447 
00448 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00449 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ResultType>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00450}\hyperlink{class_eigen_1_1_matrix_power_aa1258393dc13acd6e401e000f99b915f}{00450} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power_aa1258393dc13acd6e401e000f99b915f}{MatrixPower<MatrixType>::compute}(ResultType& res, RealScalar p)
00451 \{
00452   \textcolor{keyword}{using} std::pow;
00453   \textcolor{keywordflow}{switch} (cols()) \{
00454     \textcolor{keywordflow}{case} 0:
00455       \textcolor{keywordflow}{break};
00456     \textcolor{keywordflow}{case} 1:
00457       res(0,0) = pow(m\_A.coeff(0,0), p);
00458       \textcolor{keywordflow}{break};
00459     \textcolor{keywordflow}{default}:
00460       RealScalar intpart;
00461       split(p, intpart);
00462 
00463       res = MatrixType::Identity(rows(), cols());
00464       computeIntPower(res, intpart);
00465       \textcolor{keywordflow}{if} (p) computeFracPower(res, p);
00466   \}
00467 \}
00468 
00469 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00470 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power}{MatrixPower<MatrixType>::split}(RealScalar& p, RealScalar& intpart)
00471 \{
00472   \textcolor{keyword}{using} std::floor;
00473   \textcolor{keyword}{using} std::pow;
00474 
00475   intpart = floor(p);
00476   p -= intpart;
00477 
00478   \textcolor{comment}{// Perform Schur decomposition if it is not yet performed and the power is}
00479   \textcolor{comment}{// not an integer.}
00480   \textcolor{keywordflow}{if} (!m\_conditionNumber && p)
00481     initialize();
00482 
00483   \textcolor{comment}{// Choose the more stable of intpart = floor(p) and intpart = ceil(p).}
00484   \textcolor{keywordflow}{if} (p > RealScalar(0.5) && p > (1-p) * pow(m\_conditionNumber, p)) \{
00485     --p;
00486     ++intpart;
00487   \}
00488 \}
00489 
00490 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00491 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power}{MatrixPower<MatrixType>::initialize}()
00492 \{
00493   \textcolor{keyword}{const} \hyperlink{group___eigenvalues___module}{ComplexSchur<MatrixType>} schurOfA(m\_A);
00494   \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<ComplexScalar>} rot;
00495   ComplexScalar eigenvalue;
00496 
00497   m\_fT.resizeLike(m\_A);
00498   m\_T = schurOfA.\hyperlink{group___eigenvalues___module_add3ab5ed83f7f2f06b79fa910a2d5684}{matrixT}();
00499   m\_U = schurOfA.\hyperlink{group___eigenvalues___module_afed8177cf9836f032d42bdb6c6bc6e01}{matrixU}();
00500   m\_conditionNumber = m\_T.diagonal().array().abs().maxCoeff() / m\_T.diagonal().array().abs().minCoeff();
00501 
00502   \textcolor{comment}{// Move zero eigenvalues to the bottom right corner.}
00503   \textcolor{keywordflow}{for} (Index i = cols()-1; i>=0; --i) \{
00504     \textcolor{keywordflow}{if} (m\_rank <= 2)
00505       \textcolor{keywordflow}{return};
00506     \textcolor{keywordflow}{if} (m\_T.coeff(i,i) == RealScalar(0)) \{
00507       \textcolor{keywordflow}{for} (Index j=i+1; j < m\_rank; ++j) \{
00508         eigenvalue = m\_T.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(j,j);
00509         rot.\hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(m\_T.coeff(j-1,j), eigenvalue);
00510         m\_T.applyOnTheRight(j-1, j, rot);
00511         m\_T.applyOnTheLeft(j-1, j, rot.\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}());
00512         m\_T.coeffRef(j-1,j-1) = eigenvalue;
00513         m\_T.coeffRef(j,j) = RealScalar(0);
00514         m\_U.applyOnTheRight(j-1, j, rot);
00515       \}
00516       --m\_rank;
00517     \}
00518   \}
00519 
00520   m\_nulls = rows() - m\_rank;
00521   \textcolor{keywordflow}{if} (m\_nulls) \{
00522     eigen\_assert(m\_T.bottomRightCorner(m\_nulls, m\_nulls).isZero()
00523         && \textcolor{stringliteral}{"Base of matrix power should be invertible or with a semisimple zero eigenvalue."});
00524     m\_fT.bottomRows(m\_nulls).fill(RealScalar(0));
00525   \}
00526 \}
00527 
00528 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00529 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ResultType>
00530 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power}{MatrixPower<MatrixType>::computeIntPower}(ResultType& res, 
      RealScalar p)
00531 \{
00532   \textcolor{keyword}{using} std::abs;
00533   \textcolor{keyword}{using} std::fmod;
00534   RealScalar pp = abs(p);
00535 
00536   \textcolor{keywordflow}{if} (p<0) 
00537     m\_tmp = m\_A.inverse();
00538   \textcolor{keywordflow}{else}     
00539     m\_tmp = m\_A;
00540 
00541   \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
00542     \textcolor{keywordflow}{if} (fmod(pp, 2) >= 1)
00543       res = m\_tmp * res;
00544     pp /= 2;
00545     \textcolor{keywordflow}{if} (pp < 1)
00546       \textcolor{keywordflow}{break};
00547     m\_tmp *= m\_tmp;
00548   \}
00549 \}
00550 
00551 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00552 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ResultType>
00553 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power}{MatrixPower<MatrixType>::computeFracPower}(ResultType& res, 
      RealScalar p)
00554 \{
00555   \hyperlink{group___core___module_class_eigen_1_1_block}{Block<ComplexMatrix,Dynamic,Dynamic>} blockTp(m\_fT, 0, 0, m\_rank, 
      m\_rank);
00556   eigen\_assert(m\_conditionNumber);
00557   eigen\_assert(m\_rank + m\_nulls == rows());
00558 
00559   \hyperlink{class_eigen_1_1_matrix_power_atomic}{MatrixPowerAtomic<ComplexMatrix>}(m\_T.topLeftCorner(m\_rank, m\_rank), p).
      \hyperlink{class_eigen_1_1_matrix_power_atomic_ac3cdfb54a5b60079d068784534cbc174}{compute}(blockTp);
00560   \textcolor{keywordflow}{if} (m\_nulls) \{
00561     m\_fT.topRightCorner(m\_rank, m\_nulls) = m\_T.topLeftCorner(m\_rank, m\_rank).template triangularView<Upper>
      ()
00562         .solve(blockTp * m\_T.topRightCorner(m\_rank, m\_nulls));
00563   \}
00564   revertSchur(m\_tmp, m\_fT, m\_U);
00565   res = m\_tmp * res;
00566 \}
00567 
00568 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00569 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Rows, \textcolor{keywordtype}{int} Cols, \textcolor{keywordtype}{int} Options, \textcolor{keywordtype}{int} MaxRows, \textcolor{keywordtype}{int} MaxCols>
00570 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power}{MatrixPower<MatrixType>::revertSchur}(
00571     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<ComplexScalar, Rows, Cols, Options, MaxRows, MaxCols>}
      & res,
00572     \textcolor{keyword}{const} \hyperlink{group___core___module}{ComplexMatrix}& \hyperlink{group___sparse_core___module}{T},
00573     \textcolor{keyword}{const} \hyperlink{group___core___module}{ComplexMatrix}& U)
00574 \{ res.noalias() = U * (T.template triangularView<Upper>() * U.adjoint()); \}
00575 
00576 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00577 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Rows, \textcolor{keywordtype}{int} Cols, \textcolor{keywordtype}{int} Options, \textcolor{keywordtype}{int} MaxRows, \textcolor{keywordtype}{int} MaxCols>
00578 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power}{MatrixPower<MatrixType>::revertSchur}(
00579     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<RealScalar, Rows, Cols, Options, MaxRows, MaxCols>}
      & res,
00580     \textcolor{keyword}{const} \hyperlink{group___core___module}{ComplexMatrix}& T,
00581     \textcolor{keyword}{const} \hyperlink{group___core___module}{ComplexMatrix}& U)
00582 \{ res.noalias() = (U * (T.template triangularView<Upper>() * U.adjoint())).real(); \}
00583 
00597 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00598 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_matrix_power_return_value}{MatrixPowerReturnValue} : \textcolor{keyword}{public} \hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue}< MatrixPowerReturnVa
      lue<Derived> >
00599 \{
00600   \textcolor{keyword}{public}:
00601     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::PlainObject PlainObject;
00602     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::RealScalar RealScalar;
00603     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Index Index;
00604 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00611}\hyperlink{class_eigen_1_1_matrix_power_return_value_a3067e09b352f967a23bb2a9c50afee88}{00611}     \hyperlink{class_eigen_1_1_matrix_power_return_value_a3067e09b352f967a23bb2a9c50afee88}{MatrixPowerReturnValue}(\textcolor{keyword}{const} Derived& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, RealScalar p) : m\_A(A), m\_p(p)
00612     \{ \}
00613 
00620     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ResultType>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00621}\hyperlink{class_eigen_1_1_matrix_power_return_value_acdef58da9a4bcd2ec70260e73ce31973}{00621}     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_power_return_value_acdef58da9a4bcd2ec70260e73ce31973}{evalTo}(ResultType& res)\textcolor{keyword}{ const}
00622 \textcolor{keyword}{    }\{ \hyperlink{class_eigen_1_1_matrix_power}{MatrixPower<PlainObject>}(m\_A.eval()).\hyperlink{class_eigen_1_1_matrix_power_atomic_ac3cdfb54a5b60079d068784534cbc174}{compute}(res, m\_p); \}
00623 
00624     Index rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_A.rows(); \}
00625     Index cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_A.cols(); \}
00626 
00627   \textcolor{keyword}{private}:
00628     \textcolor{keyword}{const} Derived& m\_A;
00629     \textcolor{keyword}{const} RealScalar m\_p;
00630 \};
00631 
00645 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00646 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_matrix_complex_power_return_value}{MatrixComplexPowerReturnValue} : \textcolor{keyword}{public} 
      \hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue}< MatrixComplexPowerReturnValue<Derived> >
00647 \{
00648   \textcolor{keyword}{public}:
00649     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::PlainObject PlainObject;
00650     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<typename Derived::RealScalar> ComplexScalar;
00651     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Index Index;
00652 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00659}\hyperlink{class_eigen_1_1_matrix_complex_power_return_value_a3e5903e22f70e9deb07c3967ae52fd54}{00659}     \hyperlink{class_eigen_1_1_matrix_complex_power_return_value_a3e5903e22f70e9deb07c3967ae52fd54}{MatrixComplexPowerReturnValue}(\textcolor{keyword}{const} Derived& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, \textcolor{keyword}{const} ComplexScalar& p) :
       m\_A(A), m\_p(p)
00660     \{ \}
00661 
00671     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ResultType>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00672}\hyperlink{class_eigen_1_1_matrix_complex_power_return_value_aac9c4065d4711e62af085633a38c4416}{00672}     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_matrix_complex_power_return_value_aac9c4065d4711e62af085633a38c4416}{evalTo}(ResultType& res)\textcolor{keyword}{ const}
00673 \textcolor{keyword}{    }\{ res = (m\_p * m\_A.log()).exp(); \}
00674 
00675     Index rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_A.rows(); \}
00676     Index cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_A.cols(); \}
00677 
00678   \textcolor{keyword}{private}:
00679     \textcolor{keyword}{const} Derived& m\_A;
00680     \textcolor{keyword}{const} ComplexScalar m\_p;
00681 \};
00682 
00683 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00684 
00685 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixPowerType>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00686}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_matrix_power_parentheses_return_value_3_01_matrix_power_type_01_4_01_4}{00686} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}< \hyperlink{class_eigen_1_1_matrix_power_parentheses_return_value}{MatrixPowerParenthesesReturnValue}<MatrixPowerType> >
00687 \{ \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixPowerType::PlainObject ReturnType; \};
00688 
00689 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00690}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_matrix_power_return_value_3_01_derived_01_4_01_4}{00690} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}< \hyperlink{class_eigen_1_1_matrix_power_return_value}{MatrixPowerReturnValue}<Derived> >
00691 \{ \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::PlainObject ReturnType; \};
00692 
00693 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_power_8h_source_l00694}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_matrix_complex_power_return_value_3_01_derived_01_4_01_4}{00694} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}< \hyperlink{class_eigen_1_1_matrix_complex_power_return_value}{MatrixComplexPowerReturnValue}<Derived> >
00695 \{ \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::PlainObject ReturnType; \};
00696 
00697 \}
00698 
00699 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00700 \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_matrix_power_return_value}{MatrixPowerReturnValue<Derived>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>::pow}(\textcolor{keyword}{const} RealScalar& p)\textcolor{keyword}{ const}
00701 \textcolor{keyword}{}\{ \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_matrix_power_return_value}{MatrixPowerReturnValue<Derived>}(derived(), p); \}
00702 
00703 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00704 \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_matrix_complex_power_return_value}{MatrixComplexPowerReturnValue<Derived>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>::pow}(\textcolor{keyword}{const} std::complex<RealScalar>& p)\textcolor{keyword}{ const}
00705 \textcolor{keyword}{}\{ \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_matrix_complex_power_return_value}{MatrixComplexPowerReturnValue<Derived>}(derived(), p); \}
00706 
00707 \} \textcolor{comment}{// namespace Eigen}
00708 
00709 \textcolor{preprocessor}{#endif // EIGEN\_MATRIX\_POWER}
\end{DoxyCode}
