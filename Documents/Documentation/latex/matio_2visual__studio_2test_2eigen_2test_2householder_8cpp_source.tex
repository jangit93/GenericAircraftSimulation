\hypertarget{matio_2visual__studio_2test_2eigen_2test_2householder_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/householder.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2householder_8cpp_source}\index{householder.\+cpp@{householder.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2010 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 \textcolor{preprocessor}{#include <Eigen/QR>}
00012 
00013 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} householder(\textcolor{keyword}{const} MatrixType& m)
00014 \{
00015   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00016   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} even = \textcolor{keyword}{true};
00017   even = !even;
00018   \textcolor{comment}{/* this test covers the following files:}
00019 \textcolor{comment}{     Householder.h}
00020 \textcolor{comment}{  */}
00021   Index rows = m.rows();
00022   Index cols = m.cols();
00023 
00024   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00025   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00026   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, 1>} 
      \hyperlink{struct_vector_type}{VectorType};
00027   \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, internal::decrement\_size<MatrixType::RowsAtCompileTime>::ret}
      , 1> EssentialVectorType;
00028   \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, MatrixType::RowsAtCompileTime>}
       SquareMatrixType;
00029   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, MatrixType::ColsAtCompileTime>}
       HBlockMatrixType;
00030   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>} HCoeffsVectorType;
00031 
00032   \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::ColsAtCompileTime, MatrixType::RowsAtCompileTime>}
       TMatrixType;
00033   
00034   
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, EIGEN\_SIZE\_MAX(MatrixType::RowsAtCompileTime,MatrixType::ColsAtCompileTime), 1>}
       \_tmp((std::max)(rows,cols));
00035   Scalar* tmp = &\_tmp.coeffRef(0,0);
00036 
00037   Scalar beta;
00038   RealScalar alpha;
00039   EssentialVectorType essential;
00040 
00041   VectorType v1 = VectorType::Random(rows), v2;
00042   v2 = v1;
00043   v1.makeHouseholder(essential, beta, alpha);
00044   v1.applyHouseholderOnTheLeft(essential,beta,tmp);
00045   VERIFY\_IS\_APPROX(v1.norm(), v2.norm());
00046   \textcolor{keywordflow}{if}(rows>=2) VERIFY\_IS\_MUCH\_SMALLER\_THAN(v1.tail(rows-1).norm(), v1.norm());
00047   v1 = VectorType::Random(rows);
00048   v2 = v1;
00049   v1.applyHouseholderOnTheLeft(essential,beta,tmp);
00050   VERIFY\_IS\_APPROX(v1.norm(), v2.norm());
00051 
00052   MatrixType m1(rows, cols),
00053              m2(rows, cols);
00054 
00055   v1 = VectorType::Random(rows);
00056   \textcolor{keywordflow}{if}(even) v1.tail(rows-1).setZero();
00057   m1.colwise() = v1;
00058   m2 = m1;
00059   m1.col(0).makeHouseholder(essential, beta, alpha);
00060   m1.applyHouseholderOnTheLeft(essential,beta,tmp);
00061   VERIFY\_IS\_APPROX(m1.norm(), m2.norm());
00062   \textcolor{keywordflow}{if}(rows>=2) VERIFY\_IS\_MUCH\_SMALLER\_THAN(m1.block(1,0,rows-1,cols).norm(), m1.norm());
00063   VERIFY\_IS\_MUCH\_SMALLER\_THAN(numext::imag(m1(0,0)), numext::real(m1(0,0)));
00064   VERIFY\_IS\_APPROX(numext::real(m1(0,0)), alpha);
00065 
00066   v1 = VectorType::Random(rows);
00067   \textcolor{keywordflow}{if}(even) v1.tail(rows-1).setZero();
00068   SquareMatrixType m3(rows,rows), m4(rows,rows);
00069   m3.rowwise() = v1.transpose();
00070   m4 = m3;
00071   m3.row(0).makeHouseholder(essential, beta, alpha);
00072   m3.applyHouseholderOnTheRight(essential,beta,tmp);
00073   VERIFY\_IS\_APPROX(m3.norm(), m4.norm());
00074   \textcolor{keywordflow}{if}(rows>=2) VERIFY\_IS\_MUCH\_SMALLER\_THAN(m3.block(0,1,rows,rows-1).norm(), m3.norm());
00075   VERIFY\_IS\_MUCH\_SMALLER\_THAN(numext::imag(m3(0,0)), numext::real(m3(0,0)));
00076   VERIFY\_IS\_APPROX(numext::real(m3(0,0)), alpha);
00077 
00078   \textcolor{comment}{// test householder sequence on the left with a shift}
00079 
00080   Index shift = internal::random<Index>(0, std::max<Index>(rows-2,0));
00081   Index brows = rows - shift;
00082   m1.setRandom(rows, cols);
00083   HBlockMatrixType hbm = m1.block(shift,0,brows,cols);
00084   \hyperlink{group___q_r___module_class_eigen_1_1_householder_q_r}{HouseholderQR<HBlockMatrixType>} qr(hbm);
00085   m2 = m1;
00086   m2.block(shift,0,brows,cols) = qr.matrixQR();
00087   HCoeffsVectorType hc = qr.hCoeffs().conjugate();
00088   \hyperlink{group___householder___module_class_eigen_1_1_householder_sequence}{HouseholderSequence<MatrixType, HCoeffsVectorType>} hseq
      (m2, hc);
00089   hseq.setLength(hc.size()).setShift(shift);
00090   VERIFY(hseq.length() == hc.size());
00091   VERIFY(hseq.shift() == shift);
00092   
00093   MatrixType m5 = m2;
00094   m5.block(shift,0,brows,cols).template triangularView<StrictlyLower>().setZero();
00095   VERIFY\_IS\_APPROX(hseq * m5, m1); \textcolor{comment}{// test applying hseq directly}
00096   m3 = hseq;
00097   VERIFY\_IS\_APPROX(m3 * m5, m1); \textcolor{comment}{// test evaluating hseq to a dense matrix, then applying}
00098   
00099   SquareMatrixType hseq\_mat = hseq;
00100   SquareMatrixType hseq\_mat\_conj = hseq.conjugate();
00101   SquareMatrixType hseq\_mat\_adj = hseq.adjoint();
00102   SquareMatrixType hseq\_mat\_trans = hseq.transpose();
00103   SquareMatrixType m6 = SquareMatrixType::Random(rows, rows);
00104   VERIFY\_IS\_APPROX(hseq\_mat.adjoint(),    hseq\_mat\_adj);
00105   VERIFY\_IS\_APPROX(hseq\_mat.conjugate(),  hseq\_mat\_conj);
00106   VERIFY\_IS\_APPROX(hseq\_mat.transpose(),  hseq\_mat\_trans);
00107   VERIFY\_IS\_APPROX(hseq\_mat * m6,             hseq\_mat * m6);
00108   VERIFY\_IS\_APPROX(hseq\_mat.adjoint() * m6,   hseq\_mat\_adj * m6);
00109   VERIFY\_IS\_APPROX(hseq\_mat.conjugate() * m6, hseq\_mat\_conj * m6);
00110   VERIFY\_IS\_APPROX(hseq\_mat.transpose() * m6, hseq\_mat\_trans * m6);
00111   VERIFY\_IS\_APPROX(m6 * hseq\_mat,             m6 * hseq\_mat);
00112   VERIFY\_IS\_APPROX(m6 * hseq\_mat.adjoint(),   m6 * hseq\_mat\_adj);
00113   VERIFY\_IS\_APPROX(m6 * hseq\_mat.conjugate(), m6 * hseq\_mat\_conj);
00114   VERIFY\_IS\_APPROX(m6 * hseq\_mat.transpose(), m6 * hseq\_mat\_trans);
00115 
00116   \textcolor{comment}{// test householder sequence on the right with a shift}
00117 
00118   TMatrixType tm2 = m2.transpose();
00119   \hyperlink{group___householder___module_class_eigen_1_1_householder_sequence}{HouseholderSequence<TMatrixType, HCoeffsVectorType, OnTheRight>}
       rhseq(tm2, hc);
00120   rhseq.setLength(hc.size()).setShift(shift);
00121   VERIFY\_IS\_APPROX(rhseq * m5, m1); \textcolor{comment}{// test applying rhseq directly}
00122   m3 = rhseq;
00123   VERIFY\_IS\_APPROX(m3 * m5, m1); \textcolor{comment}{// test evaluating rhseq to a dense matrix, then applying}
00124 \}
00125 
00126 \textcolor{keywordtype}{void} test\_householder()
00127 \{
00128   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00129     CALL\_SUBTEST\_1( householder(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,2,2>}()) );
00130     CALL\_SUBTEST\_2( householder(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,2,3>}()) );
00131     CALL\_SUBTEST\_3( householder(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,3,5>}()) );
00132     CALL\_SUBTEST\_4( householder(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,4,4>}()) );
00133     CALL\_SUBTEST\_5( householder(MatrixXd(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE),internal::random<int>
      (1,EIGEN\_TEST\_MAX\_SIZE))) );
00134     CALL\_SUBTEST\_6( householder(MatrixXcf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE),
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00135     CALL\_SUBTEST\_7( householder(MatrixXf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE),internal::random<int>
      (1,EIGEN\_TEST\_MAX\_SIZE))) );
00136     CALL\_SUBTEST\_8( householder(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,1,1>}()) );
00137   \}
00138 \}
\end{DoxyCode}
