\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_exponential_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+Matrix\+Functions/\+Matrix\+Exponential.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_exponential_8h_source}\index{Matrix\+Exponential.\+h@{Matrix\+Exponential.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009, 2010, 2013 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00005 \textcolor{comment}{// Copyright (C) 2011, 2013 Chen-Pang He <jdh8@ms63.hinet.net>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_MATRIX\_EXPONENTIAL}
00012 \textcolor{preprocessor}{#define EIGEN\_MATRIX\_EXPONENTIAL}
00013 
00014 \textcolor{preprocessor}{#include "StemFunction.h"}
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00017 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00018 
00023 \textcolor{keyword}{template} <\textcolor{keyword}{typename} RealScalar>
00024 \textcolor{keyword}{struct }MatrixExponentialScalingOp
00025 \{
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_exponential_8h_source_l00030}\hyperlink{struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op_afb0f3ee7d324e315d1e1233f70110438}{00030}   \hyperlink{struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op_afb0f3ee7d324e315d1e1233f70110438}{MatrixExponentialScalingOp}(\textcolor{keywordtype}{int} squarings) : m\_squarings(squarings) \{ \}
00031 
00032 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_exponential_8h_source_l00037}\hyperlink{struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op_ad4c95fe9fcbf59981c2a5a0a4e42041d}{00037}   \textcolor{keyword}{inline} \textcolor{keyword}{const} RealScalar \hyperlink{struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op_ad4c95fe9fcbf59981c2a5a0a4e42041d}{operator() }(\textcolor{keyword}{const} RealScalar& x)\textcolor{keyword}{ const}
00038 \textcolor{keyword}{  }\{
00039     \textcolor{keyword}{using} std::ldexp;
00040     \textcolor{keywordflow}{return} ldexp(x, -m\_squarings);
00041   \}
00042 
00043   \textcolor{keyword}{typedef} std::complex<RealScalar> ComplexScalar;
00044 
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_exponential_8h_source_l00049}\hyperlink{struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op_a7c0d08f36bf3d6f8f6db34b3d3eb2b40}{00049}   \textcolor{keyword}{inline} \textcolor{keyword}{const} ComplexScalar \hyperlink{struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op_ad4c95fe9fcbf59981c2a5a0a4e42041d}{operator() }(\textcolor{keyword}{const} ComplexScalar& x)\textcolor{keyword}{ const}
00050 \textcolor{keyword}{  }\{
00051     \textcolor{keyword}{using} std::ldexp;
00052     \textcolor{keywordflow}{return} ComplexScalar(ldexp(x.real(), -m\_squarings), ldexp(x.imag(), -m\_squarings));
00053   \}
00054 
00055   \textcolor{keyword}{private}:
00056     \textcolor{keywordtype}{int} m\_squarings;
00057 \};
00058 
00064 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatA, \textcolor{keyword}{typename} MatU, \textcolor{keyword}{typename} MatV>
00065 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a7e6cf2e01b6fb376d33b9bb8183e5777}{matrix\_exp\_pade3}(\textcolor{keyword}{const} MatA& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, MatU& U, MatV& V)
00066 \{
00067   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatA::PlainObject MatrixType;
00068   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename traits<MatA>::Scalar}>::Real 
      RealScalar;
00069   \textcolor{keyword}{const} RealScalar b[] = \{120.L, 60.L, 12.L, 1.L\};
00070   \textcolor{keyword}{const} MatrixType A2 = A * A;
00071   \textcolor{keyword}{const} MatrixType tmp = b[3] * A2 + b[1] * MatrixType::Identity(A.rows(), A.cols());
00072   U.noalias() = A * tmp;
00073   V = b[2] * A2 + b[0] * MatrixType::Identity(A.rows(), A.cols());
00074 \}
00075 
00081 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatA, \textcolor{keyword}{typename} MatU, \textcolor{keyword}{typename} MatV>
00082 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_af4992d182490219270a24aaa8285e63a}{matrix\_exp\_pade5}(\textcolor{keyword}{const} MatA& A, MatU& U, MatV& V)
00083 \{
00084   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatA::PlainObject MatrixType;
00085   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename traits<MatrixType>::Scalar}
      >::Real RealScalar;
00086   \textcolor{keyword}{const} RealScalar b[] = \{30240.L, 15120.L, 3360.L, 420.L, 30.L, 1.L\};
00087   \textcolor{keyword}{const} MatrixType A2 = A * A;
00088   \textcolor{keyword}{const} MatrixType A4 = A2 * A2;
00089   \textcolor{keyword}{const} MatrixType tmp = b[5] * A4 + b[3] * A2 + b[1] * MatrixType::Identity(A.rows(), A.cols());
00090   U.noalias() = A * tmp;
00091   V = b[4] * A4 + b[2] * A2 + b[0] * MatrixType::Identity(A.rows(), A.cols());
00092 \}
00093 
00099 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatA, \textcolor{keyword}{typename} MatU, \textcolor{keyword}{typename} MatV>
00100 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a1abecb439e6cb1b5188828cdb7e0ab60}{matrix\_exp\_pade7}(\textcolor{keyword}{const} MatA& A, MatU& U, MatV& V)
00101 \{
00102   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatA::PlainObject MatrixType;
00103   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename traits<MatrixType>::Scalar}
      >::Real RealScalar;
00104   \textcolor{keyword}{const} RealScalar b[] = \{17297280.L, 8648640.L, 1995840.L, 277200.L, 25200.L, 1512.L, 56.L, 1.L\};
00105   \textcolor{keyword}{const} MatrixType A2 = A * A;
00106   \textcolor{keyword}{const} MatrixType A4 = A2 * A2;
00107   \textcolor{keyword}{const} MatrixType A6 = A4 * A2;
00108   \textcolor{keyword}{const} MatrixType tmp = b[7] * A6 + b[5] * A4 + b[3] * A2 
00109     + b[1] * MatrixType::Identity(A.rows(), A.cols());
00110   U.noalias() = A * tmp;
00111   V = b[6] * A6 + b[4] * A4 + b[2] * A2 + b[0] * MatrixType::Identity(A.rows(), A.cols());
00112 
00113 \}
00114 
00120 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatA, \textcolor{keyword}{typename} MatU, \textcolor{keyword}{typename} MatV>
00121 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a218447e97bf869bf354f92e020a7355a}{matrix\_exp\_pade9}(\textcolor{keyword}{const} MatA& A, MatU& U, MatV& V)
00122 \{
00123   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatA::PlainObject MatrixType;
00124   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename traits<MatrixType>::Scalar}
      >::Real RealScalar;
00125   \textcolor{keyword}{const} RealScalar b[] = \{17643225600.L, 8821612800.L, 2075673600.L, 302702400.L, 30270240.L,
00126                           2162160.L, 110880.L, 3960.L, 90.L, 1.L\};
00127   \textcolor{keyword}{const} MatrixType A2 = A * A;
00128   \textcolor{keyword}{const} MatrixType A4 = A2 * A2;
00129   \textcolor{keyword}{const} MatrixType A6 = A4 * A2;
00130   \textcolor{keyword}{const} MatrixType A8 = A6 * A2;
00131   \textcolor{keyword}{const} MatrixType tmp = b[9] * A8 + b[7] * A6 + b[5] * A4 + b[3] * A2 
00132     + b[1] * MatrixType::Identity(A.rows(), A.cols());
00133   U.noalias() = A * tmp;
00134   V = b[8] * A8 + b[6] * A6 + b[4] * A4 + b[2] * A2 + b[0] * MatrixType::Identity(A.rows(), A.cols());
00135 \}
00136 
00142 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatA, \textcolor{keyword}{typename} MatU, \textcolor{keyword}{typename} MatV>
00143 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_ae7d0962a143c96343984440db683905a}{matrix\_exp\_pade13}(\textcolor{keyword}{const} MatA& A, MatU& U, MatV& V)
00144 \{
00145   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatA::PlainObject MatrixType;
00146   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename traits<MatrixType>::Scalar}
      >::Real RealScalar;
00147   \textcolor{keyword}{const} RealScalar b[] = \{64764752532480000.L, 32382376266240000.L, 7771770303897600.L,
00148                           1187353796428800.L, 129060195264000.L, 10559470521600.L, 670442572800.L,
00149                           33522128640.L, 1323241920.L, 40840800.L, 960960.L, 16380.L, 182.L, 1.L\};
00150   \textcolor{keyword}{const} MatrixType A2 = A * A;
00151   \textcolor{keyword}{const} MatrixType A4 = A2 * A2;
00152   \textcolor{keyword}{const} MatrixType A6 = A4 * A2;
00153   V = b[13] * A6 + b[11] * A4 + b[9] * A2; \textcolor{comment}{// used for temporary storage}
00154   MatrixType tmp = A6 * V;
00155   tmp += b[7] * A6 + b[5] * A4 + b[3] * A2 + b[1] * MatrixType::Identity(A.rows(), A.cols());
00156   U.noalias() = A * tmp;
00157   tmp = b[12] * A6 + b[10] * A4 + b[8] * A2;
00158   V.noalias() = A6 * tmp;
00159   V += b[6] * A6 + b[4] * A4 + b[2] * A2 + b[0] * MatrixType::Identity(A.rows(), A.cols());
00160 \}
00161 
00169 \textcolor{preprocessor}{#if LDBL\_MANT\_DIG > 64}
00170 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatA, \textcolor{keyword}{typename} MatU, \textcolor{keyword}{typename} MatV>
00171 \textcolor{keywordtype}{void} matrix\_exp\_pade17(\textcolor{keyword}{const} MatA& A, MatU& U, MatV& V)
00172 \{
00173   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatA::PlainObject MatrixType;
00174   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename traits<MatrixType>::Scalar}
      >::Real RealScalar;
00175   \textcolor{keyword}{const} RealScalar b[] = \{830034394580628357120000.L, 415017197290314178560000.L,
00176                           100610229646136770560000.L, 15720348382208870400000.L,
00177                           1774878043152614400000.L, 153822763739893248000.L, 10608466464820224000.L,
00178                           595373117923584000.L, 27563570274240000.L, 1060137318240000.L,
00179                           33924394183680.L, 899510451840.L, 19554575040.L, 341863200.L, 4651200.L,
00180                           46512.L, 306.L, 1.L\};
00181   \textcolor{keyword}{const} MatrixType A2 = A * A;
00182   \textcolor{keyword}{const} MatrixType A4 = A2 * A2;
00183   \textcolor{keyword}{const} MatrixType A6 = A4 * A2;
00184   \textcolor{keyword}{const} MatrixType A8 = A4 * A4;
00185   V = b[17] * A8 + b[15] * A6 + b[13] * A4 + b[11] * A2; \textcolor{comment}{// used for temporary storage}
00186   MatrixType tmp = A8 * V;
00187   tmp += b[9] * A8 + b[7] * A6 + b[5] * A4 + b[3] * A2 
00188     + b[1] * MatrixType::Identity(A.rows(), A.cols());
00189   U.noalias() = A * tmp;
00190   tmp = b[16] * A8 + b[14] * A6 + b[12] * A4 + b[10] * A2;
00191   V.noalias() = tmp * A8;
00192   V += b[8] * A8 + b[6] * A6 + b[4] * A4 + b[2] * A2 
00193     + b[0] * MatrixType::Identity(A.rows(), A.cols());
00194 \}
00195 \textcolor{preprocessor}{#endif}
00196 
00197 template <typename MatrixType, typename RealScalar = typename NumTraits<typename traits<MatrixType>::Scalar
      >::Real>
00198 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1matrix__exp__compute_u_v}{matrix\_exp\_computeUV}
00199 \{
00207   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} MatrixType& arg, MatrixType& U, MatrixType& V, \textcolor{keywordtype}{int}& squarings);
00208 \};
00209 
00210 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00211 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1matrix__exp__compute_u_v}{matrix\_exp\_computeUV}<MatrixType, float>
00212 \{
00213   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ArgType>
00214   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} ArgType& arg, MatrixType& U, MatrixType& V, \textcolor{keywordtype}{int}& squarings)
00215   \{
00216     \textcolor{keyword}{using} std::frexp;
00217     \textcolor{keyword}{using} std::pow;
00218     \textcolor{keyword}{const} \textcolor{keywordtype}{float} l1norm = arg.cwiseAbs().colwise().sum().maxCoeff();
00219     squarings = 0;
00220     \textcolor{keywordflow}{if} (l1norm < 4.258730016922831e-001f) \{
00221       \hyperlink{namespace_eigen_1_1internal_a7e6cf2e01b6fb376d33b9bb8183e5777}{matrix\_exp\_pade3}(arg, U, V);
00222     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 1.880152677804762e+000f) \{
00223       \hyperlink{namespace_eigen_1_1internal_af4992d182490219270a24aaa8285e63a}{matrix\_exp\_pade5}(arg, U, V);
00224     \} \textcolor{keywordflow}{else} \{
00225       \textcolor{keyword}{const} \textcolor{keywordtype}{float} maxnorm = 3.925724783138660f;
00226       frexp(l1norm / maxnorm, &squarings);
00227       \textcolor{keywordflow}{if} (squarings < 0) squarings = 0;
00228       MatrixType A = arg.unaryExpr(\hyperlink{struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op}{MatrixExponentialScalingOp<float>}(
      squarings));
00229       \hyperlink{namespace_eigen_1_1internal_a1abecb439e6cb1b5188828cdb7e0ab60}{matrix\_exp\_pade7}(A, U, V);
00230     \}
00231   \}
00232 \};
00233 
00234 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00235 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1matrix__exp__compute_u_v}{matrix\_exp\_computeUV}<MatrixType, double>
00236 \{
00237   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ArgType>
00238   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} ArgType& arg, MatrixType& U, MatrixType& V, \textcolor{keywordtype}{int}& squarings)
00239   \{
00240     \textcolor{keyword}{using} std::frexp;
00241     \textcolor{keyword}{using} std::pow;
00242     \textcolor{keyword}{const} \textcolor{keywordtype}{double} l1norm = arg.cwiseAbs().colwise().sum().maxCoeff();
00243     squarings = 0;
00244     \textcolor{keywordflow}{if} (l1norm < 1.495585217958292e-002) \{
00245       \hyperlink{namespace_eigen_1_1internal_a7e6cf2e01b6fb376d33b9bb8183e5777}{matrix\_exp\_pade3}(arg, U, V);
00246     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 2.539398330063230e-001) \{
00247       \hyperlink{namespace_eigen_1_1internal_af4992d182490219270a24aaa8285e63a}{matrix\_exp\_pade5}(arg, U, V);
00248     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 9.504178996162932e-001) \{
00249       \hyperlink{namespace_eigen_1_1internal_a1abecb439e6cb1b5188828cdb7e0ab60}{matrix\_exp\_pade7}(arg, U, V);
00250     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 2.097847961257068e+000) \{
00251       \hyperlink{namespace_eigen_1_1internal_a218447e97bf869bf354f92e020a7355a}{matrix\_exp\_pade9}(arg, U, V);
00252     \} \textcolor{keywordflow}{else} \{
00253       \textcolor{keyword}{const} \textcolor{keywordtype}{double} maxnorm = 5.371920351148152;
00254       frexp(l1norm / maxnorm, &squarings);
00255       \textcolor{keywordflow}{if} (squarings < 0) squarings = 0;
00256       MatrixType A = arg.unaryExpr(\hyperlink{struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op}{MatrixExponentialScalingOp<double>}(
      squarings));
00257       \hyperlink{namespace_eigen_1_1internal_ae7d0962a143c96343984440db683905a}{matrix\_exp\_pade13}(A, U, V);
00258     \}
00259   \}
00260 \};
00261   
00262 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00263 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1matrix__exp__compute_u_v}{matrix\_exp\_computeUV}<MatrixType, long double>
00264 \{
00265   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ArgType>
00266   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} ArgType& arg, MatrixType& U, MatrixType& V, \textcolor{keywordtype}{int}& squarings)
00267   \{
00268 \textcolor{preprocessor}{#if   LDBL\_MANT\_DIG == 53   // double precision}
00269     \hyperlink{struct_eigen_1_1internal_1_1matrix__exp__compute_u_v_a7847531ae0fccc8ec7648f95846c8adb}{matrix\_exp\_computeUV<MatrixType, double>::run}(arg, U, V, 
      squarings);
00270   
00271 \textcolor{preprocessor}{#else}
00272   
00273     \textcolor{keyword}{using} std::frexp;
00274     \textcolor{keyword}{using} std::pow;
00275     \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} l1norm = arg.cwiseAbs().colwise().sum().maxCoeff();
00276     squarings = 0;
00277   
00278 \textcolor{preprocessor}{#if LDBL\_MANT\_DIG <= 64   // extended precision}
00279   
00280     \textcolor{keywordflow}{if} (l1norm < 4.1968497232266989671e-003L) \{
00281       \hyperlink{namespace_eigen_1_1internal_a7e6cf2e01b6fb376d33b9bb8183e5777}{matrix\_exp\_pade3}(arg, U, V);
00282     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 1.1848116734693823091e-001L) \{
00283       \hyperlink{namespace_eigen_1_1internal_af4992d182490219270a24aaa8285e63a}{matrix\_exp\_pade5}(arg, U, V);
00284     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 5.5170388480686700274e-001L) \{
00285       \hyperlink{namespace_eigen_1_1internal_a1abecb439e6cb1b5188828cdb7e0ab60}{matrix\_exp\_pade7}(arg, U, V);
00286     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 1.3759868875587845383e+000L) \{
00287       \hyperlink{namespace_eigen_1_1internal_a218447e97bf869bf354f92e020a7355a}{matrix\_exp\_pade9}(arg, U, V);
00288     \} \textcolor{keywordflow}{else} \{
00289       \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} maxnorm = 4.0246098906697353063L;
00290       frexp(l1norm / maxnorm, &squarings);
00291       \textcolor{keywordflow}{if} (squarings < 0) squarings = 0;
00292       MatrixType A = arg.unaryExpr(\hyperlink{struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op}{MatrixExponentialScalingOp<long double>}
      (squarings));
00293       \hyperlink{namespace_eigen_1_1internal_ae7d0962a143c96343984440db683905a}{matrix\_exp\_pade13}(A, U, V);
00294     \}
00295   
00296 \textcolor{preprocessor}{#elif LDBL\_MANT\_DIG <= 106  // double-double}
00297   
00298     \textcolor{keywordflow}{if} (l1norm < 3.2787892205607026992947488108213e-005L) \{
00299       \hyperlink{namespace_eigen_1_1internal_a7e6cf2e01b6fb376d33b9bb8183e5777}{matrix\_exp\_pade3}(arg, U, V);
00300     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 6.4467025060072760084130906076332e-003L) \{
00301       \hyperlink{namespace_eigen_1_1internal_af4992d182490219270a24aaa8285e63a}{matrix\_exp\_pade5}(arg, U, V);
00302     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 6.8988028496595374751374122881143e-002L) \{
00303       \hyperlink{namespace_eigen_1_1internal_a1abecb439e6cb1b5188828cdb7e0ab60}{matrix\_exp\_pade7}(arg, U, V);
00304     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 2.7339737518502231741495857201670e-001L) \{
00305       \hyperlink{namespace_eigen_1_1internal_a218447e97bf869bf354f92e020a7355a}{matrix\_exp\_pade9}(arg, U, V);
00306     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 1.3203382096514474905666448850278e+000L) \{
00307       \hyperlink{namespace_eigen_1_1internal_ae7d0962a143c96343984440db683905a}{matrix\_exp\_pade13}(arg, U, V);
00308     \} \textcolor{keywordflow}{else} \{
00309       \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} maxnorm = 3.2579440895405400856599663723517L;
00310       frexp(l1norm / maxnorm, &squarings);
00311       \textcolor{keywordflow}{if} (squarings < 0) squarings = 0;
00312       MatrixType A = arg.unaryExpr(\hyperlink{struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op}{MatrixExponentialScalingOp<long double>}
      (squarings));
00313       matrix\_exp\_pade17(A, U, V);
00314     \}
00315   
00316 \textcolor{preprocessor}{#elif LDBL\_MANT\_DIG <= 112  // quadruple precison}
00317   
00318     \textcolor{keywordflow}{if} (l1norm < 1.639394610288918690547467954466970e-005L) \{
00319       \hyperlink{namespace_eigen_1_1internal_a7e6cf2e01b6fb376d33b9bb8183e5777}{matrix\_exp\_pade3}(arg, U, V);
00320     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 4.253237712165275566025884344433009e-003L) \{
00321       \hyperlink{namespace_eigen_1_1internal_af4992d182490219270a24aaa8285e63a}{matrix\_exp\_pade5}(arg, U, V);
00322     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 5.125804063165764409885122032933142e-002L) \{
00323       \hyperlink{namespace_eigen_1_1internal_a1abecb439e6cb1b5188828cdb7e0ab60}{matrix\_exp\_pade7}(arg, U, V);
00324     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 2.170000765161155195453205651889853e-001L) \{
00325       \hyperlink{namespace_eigen_1_1internal_a218447e97bf869bf354f92e020a7355a}{matrix\_exp\_pade9}(arg, U, V);
00326     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l1norm < 1.125358383453143065081397882891878e+000L) \{
00327       \hyperlink{namespace_eigen_1_1internal_ae7d0962a143c96343984440db683905a}{matrix\_exp\_pade13}(arg, U, V);
00328     \} \textcolor{keywordflow}{else} \{
00329       frexp(l1norm / maxnorm, &squarings);
00330       \textcolor{keywordflow}{if} (squarings < 0) squarings = 0;
00331       MatrixType A = arg.unaryExpr(\hyperlink{struct_eigen_1_1internal_1_1_matrix_exponential_scaling_op}{MatrixExponentialScalingOp<long double>}
      (squarings));
00332       matrix\_exp\_pade17(A, U, V);
00333     \}
00334   
00335 \textcolor{preprocessor}{#else}
00336   
00337     \textcolor{comment}{// this case should be handled in compute()}
00338     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Bug in MatrixExponential"}); 
00339   
00340 \textcolor{preprocessor}{#endif}
00341 \textcolor{preprocessor}{#endif  // LDBL\_MANT\_DIG}
00342   \}
00343 \};
00344 
00345 
00346 \textcolor{comment}{/* Computes the matrix exponential}
00347 \textcolor{comment}{ *}
00348 \textcolor{comment}{ * \(\backslash\)param arg    argument of matrix exponential (should be plain object)}
00349 \textcolor{comment}{ * \(\backslash\)param result variable in which result will be stored}
00350 \textcolor{comment}{ */}
00351 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} ResultType>
00352 \textcolor{keywordtype}{void} matrix\_exp\_compute(\textcolor{keyword}{const} ArgType& arg, ResultType &result)
00353 \{
00354   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ArgType::PlainObject MatrixType;
00355 \textcolor{preprocessor}{#if LDBL\_MANT\_DIG > 112 // rarely happens}
00356   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<MatrixType>::Scalar} Scalar;
00357   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00358   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::complex<RealScalar> ComplexScalar;
00359   \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(RealScalar) > 14) \{
00360     result = arg.matrixFunction(internal::stem\_function\_exp<ComplexScalar>);
00361     \textcolor{keywordflow}{return};
00362   \}
00363 \textcolor{preprocessor}{#endif}
00364   MatrixType U, V;
00365   \textcolor{keywordtype}{int} squarings; 
00366   \hyperlink{struct_eigen_1_1internal_1_1matrix__exp__compute_u_v_a7847531ae0fccc8ec7648f95846c8adb}{matrix\_exp\_computeUV<MatrixType>::run}(arg, U, V, squarings); \textcolor{comment}{// Pade
       approximant is (U+V) / (-U+V)}
00367   MatrixType numer = U + V;
00368   MatrixType denom = -U + V;
00369   result = denom.partialPivLu().solve(numer);
00370   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<squarings; i++)
00371     result *= result;   \textcolor{comment}{// undo scaling by repeated squaring}
00372 \}
00373 
00374 \} \textcolor{comment}{// end namespace Eigen::internal}
00375 
00386 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_matrix_exponential_return_value}{MatrixExponentialReturnValue}
00387 : \textcolor{keyword}{public} \hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue}<MatrixExponentialReturnValue<Derived> >
00388 \{
00389     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00390   \textcolor{keyword}{public}:
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_exponential_8h_source_l00395}\hyperlink{struct_eigen_1_1_matrix_exponential_return_value_a4048419b1ee2befc51564703ba11acab}{00395}     \hyperlink{struct_eigen_1_1_matrix_exponential_return_value_a4048419b1ee2befc51564703ba11acab}{MatrixExponentialReturnValue}(\textcolor{keyword}{const} Derived& src) : m\_src(src) \{ \}
00396 
00401     \textcolor{keyword}{template} <\textcolor{keyword}{typename} ResultType>
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_matrix_functions_2_matrix_exponential_8h_source_l00402}\hyperlink{struct_eigen_1_1_matrix_exponential_return_value_a3dd2c65c7c6cdc41ab17415ee11899a0}{00402}     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{struct_eigen_1_1_matrix_exponential_return_value_a3dd2c65c7c6cdc41ab17415ee11899a0}{evalTo}(ResultType& result)\textcolor{keyword}{ const}
00403 \textcolor{keyword}{    }\{
00404       \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<Derived, 10>::type} tmp(
      m\_src);
00405       internal::matrix\_exp\_compute(tmp, result);
00406     \}
00407 
00408     Index rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_src.rows(); \}
00409     Index cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_src.cols(); \}
00410 
00411   \textcolor{keyword}{protected}:
00412     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::ref\_selector<Derived>::type} m\_src;
00413 \};
00414 
00415 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00416 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00417 \textcolor{keyword}{struct }traits<MatrixExponentialReturnValue<Derived> >
00418 \{
00419   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::PlainObject ReturnType;
00420 \};
00421 \}
00422 
00423 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>
00424 \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_matrix_exponential_return_value}{MatrixExponentialReturnValue<Derived>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>::exp}()\textcolor{keyword}{ const}
00425 \textcolor{keyword}{}\{
00426   eigen\_assert(rows() == cols());
00427   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_matrix_exponential_return_value}{MatrixExponentialReturnValue<Derived>}(derived());
00428 \}
00429 
00430 \} \textcolor{comment}{// end namespace Eigen}
00431 
00432 \textcolor{preprocessor}{#endif // EIGEN\_MATRIX\_EXPONENTIAL}
\end{DoxyCode}
