\hypertarget{matio_2zlib_2test_2example_8c_source}{}\section{matio/zlib/test/example.c}
\label{matio_2zlib_2test_2example_8c_source}\index{example.\+c@{example.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* example.c -- usage example of the zlib compression library}
00002 \textcolor{comment}{ * Copyright (C) 1995-2006, 2011, 2016 Jean-loup Gailly}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ */}
00005 
00006 \textcolor{comment}{/* @(#) $Id$ */}
00007 
00008 \textcolor{preprocessor}{#include "zlib.h"}
00009 \textcolor{preprocessor}{#include <stdio.h>}
00010 
00011 \textcolor{preprocessor}{#ifdef STDC}
00012 \textcolor{preprocessor}{#  include <string.h>}
00013 \textcolor{preprocessor}{#  include <stdlib.h>}
00014 \textcolor{preprocessor}{#endif}
00015 
00016 \textcolor{preprocessor}{#if defined(VMS) || defined(RISCOS)}
00017 \textcolor{preprocessor}{#  define TESTFILE "foo-gz"}
00018 \textcolor{preprocessor}{#else}
00019 \textcolor{preprocessor}{#  define TESTFILE "foo.gz"}
00020 \textcolor{preprocessor}{#endif}
00021 
00022 \textcolor{preprocessor}{#define CHECK\_ERR(err, msg) \{ \(\backslash\)}
00023 \textcolor{preprocessor}{    if (err != Z\_OK) \{ \(\backslash\)}
00024 \textcolor{preprocessor}{        fprintf(stderr, "%s error: %d\(\backslash\)n", msg, err); \(\backslash\)}
00025 \textcolor{preprocessor}{        exit(1); \(\backslash\)}
00026 \textcolor{preprocessor}{    \} \(\backslash\)}
00027 \textcolor{preprocessor}{\}}
00028 
00029 \textcolor{keyword}{static} z\_const \textcolor{keywordtype}{char} hello[] = \textcolor{stringliteral}{"hello, hello!"};
00030 \textcolor{comment}{/* "hello world" would be more standard, but the repeated "hello"}
00031 \textcolor{comment}{ * stresses the compression code better, sorry...}
00032 \textcolor{comment}{ */}
00033 
00034 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} dictionary[] = \textcolor{stringliteral}{"hello"};
00035 \textcolor{keyword}{static} uLong dictId;    \textcolor{comment}{/* Adler32 value of the dictionary */}
00036 
00037 \textcolor{keywordtype}{void} test\_deflate       OF((Byte *compr, uLong comprLen));
00038 \textcolor{keywordtype}{void} test\_inflate       OF((Byte *compr, uLong comprLen,
00039                             Byte *uncompr, uLong uncomprLen));
00040 \textcolor{keywordtype}{void} test\_large\_deflate OF((Byte *compr, uLong comprLen,
00041                             Byte *uncompr, uLong uncomprLen));
00042 \textcolor{keywordtype}{void} test\_large\_inflate OF((Byte *compr, uLong comprLen,
00043                             Byte *uncompr, uLong uncomprLen));
00044 \textcolor{keywordtype}{void} test\_flush         OF((Byte *compr, uLong *comprLen));
00045 \textcolor{keywordtype}{void} test\_sync          OF((Byte *compr, uLong comprLen,
00046                             Byte *uncompr, uLong uncomprLen));
00047 \textcolor{keywordtype}{void} test\_dict\_deflate  OF((Byte *compr, uLong comprLen));
00048 \textcolor{keywordtype}{void} test\_dict\_inflate  OF((Byte *compr, uLong comprLen,
00049                             Byte *uncompr, uLong uncomprLen));
00050 \textcolor{keywordtype}{int}  main               OF((\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[]));
00051 
00052 
00053 \textcolor{preprocessor}{#ifdef Z\_SOLO}
00054 
00055 \textcolor{keywordtype}{void} *myalloc OF((\textcolor{keywordtype}{void} *, \textcolor{keywordtype}{unsigned}, \textcolor{keywordtype}{unsigned}));
00056 \textcolor{keywordtype}{void} myfree OF((\textcolor{keywordtype}{void} *, \textcolor{keywordtype}{void} *));
00057 
00058 \textcolor{keywordtype}{void} *myalloc(q, n, m)
00059     \textcolor{keywordtype}{void} *q;
00060     \textcolor{keywordtype}{unsigned} n, m;
00061 \{
00062     (void)q;
00063     \textcolor{keywordflow}{return} calloc(n, m);
00064 \}
00065 
00066 \textcolor{keywordtype}{void} myfree(\textcolor{keywordtype}{void} *q, \textcolor{keywordtype}{void} *p)
00067 \{
00068     (void)q;
00069     free(p);
00070 \}
00071 
00072 \textcolor{keyword}{static} alloc\_func zalloc = myalloc;
00073 \textcolor{keyword}{static} free\_func zfree = myfree;
00074 
00075 \textcolor{preprocessor}{#else }\textcolor{comment}{/* !Z\_SOLO */}\textcolor{preprocessor}{}
00076 
00077 \textcolor{keyword}{static} alloc\_func zalloc = (alloc\_func)0;
00078 \textcolor{keyword}{static} free\_func zfree = (free\_func)0;
00079 
00080 \textcolor{keywordtype}{void} test\_compress      OF((Byte *compr, uLong comprLen,
00081                             Byte *uncompr, uLong uncomprLen));
00082 \textcolor{keywordtype}{void} test\_gzio          OF((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *fname,
00083                             Byte *uncompr, uLong uncomprLen));
00084 
00085 \textcolor{comment}{/* ===========================================================================}
00086 \textcolor{comment}{ * Test compress() and uncompress()}
00087 \textcolor{comment}{ */}
00088 \textcolor{keywordtype}{void} test\_compress(compr, comprLen, uncompr, uncomprLen)
00089     Byte *compr, *uncompr;
00090     uLong comprLen, uncomprLen;
00091 \{
00092     \textcolor{keywordtype}{int} err;
00093     uLong len = (uLong)strlen(hello)+1;
00094 
00095     err = compress(compr, &comprLen, (\textcolor{keyword}{const} Bytef*)hello, len);
00096     CHECK\_ERR(err, \textcolor{stringliteral}{"compress"});
00097 
00098     strcpy((\textcolor{keywordtype}{char}*)uncompr, \textcolor{stringliteral}{"garbage"});
00099 
00100     err = uncompress(uncompr, &uncomprLen, compr, comprLen);
00101     CHECK\_ERR(err, \textcolor{stringliteral}{"uncompress"});
00102 
00103     \textcolor{keywordflow}{if} (strcmp((\textcolor{keywordtype}{char}*)uncompr, hello)) \{
00104         fprintf(stderr, \textcolor{stringliteral}{"bad uncompress\(\backslash\)n"});
00105         exit(1);
00106     \} \textcolor{keywordflow}{else} \{
00107         printf(\textcolor{stringliteral}{"uncompress(): %s\(\backslash\)n"}, (\textcolor{keywordtype}{char} *)uncompr);
00108     \}
00109 \}
00110 
00111 \textcolor{comment}{/* ===========================================================================}
00112 \textcolor{comment}{ * Test read/write of .gz files}
00113 \textcolor{comment}{ */}
00114 \textcolor{keywordtype}{void} test\_gzio(fname, uncompr, uncomprLen)
00115     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fname; \textcolor{comment}{/* compressed file name */}
00116     Byte *uncompr;
00117     uLong uncomprLen;
00118 \{
00119 \textcolor{preprocessor}{#ifdef NO\_GZCOMPRESS}
00120     fprintf(stderr, \textcolor{stringliteral}{"NO\_GZCOMPRESS -- gz* functions cannot compress\(\backslash\)n"});
00121 \textcolor{preprocessor}{#else}
00122     \textcolor{keywordtype}{int} err;
00123     \textcolor{keywordtype}{int} len = (int)strlen(hello)+1;
00124     \hyperlink{structgz_file__s}{gzFile} \hyperlink{structfile}{file};
00125     z\_off\_t pos;
00126 
00127     file = gzopen(fname, \textcolor{stringliteral}{"wb"});
00128     \textcolor{keywordflow}{if} (file == NULL) \{
00129         fprintf(stderr, \textcolor{stringliteral}{"gzopen error\(\backslash\)n"});
00130         exit(1);
00131     \}
00132     gzputc(file, \textcolor{charliteral}{'h'});
00133     \textcolor{keywordflow}{if} (gzputs(file, \textcolor{stringliteral}{"ello"}) != 4) \{
00134         fprintf(stderr, \textcolor{stringliteral}{"gzputs err: %s\(\backslash\)n"}, gzerror(file, &err));
00135         exit(1);
00136     \}
00137     \textcolor{keywordflow}{if} (gzprintf(file, \textcolor{stringliteral}{", %s!"}, \textcolor{stringliteral}{"hello"}) != 8) \{
00138         fprintf(stderr, \textcolor{stringliteral}{"gzprintf err: %s\(\backslash\)n"}, gzerror(file, &err));
00139         exit(1);
00140     \}
00141     gzseek(file, 1L, SEEK\_CUR); \textcolor{comment}{/* add one zero byte */}
00142     gzclose(file);
00143 
00144     file = gzopen(fname, \textcolor{stringliteral}{"rb"});
00145     \textcolor{keywordflow}{if} (file == NULL) \{
00146         fprintf(stderr, \textcolor{stringliteral}{"gzopen error\(\backslash\)n"});
00147         exit(1);
00148     \}
00149     strcpy((\textcolor{keywordtype}{char}*)uncompr, \textcolor{stringliteral}{"garbage"});
00150 
00151     \textcolor{keywordflow}{if} (gzread(file, uncompr, (\textcolor{keywordtype}{unsigned})uncomprLen) != len) \{
00152         fprintf(stderr, \textcolor{stringliteral}{"gzread err: %s\(\backslash\)n"}, gzerror(file, &err));
00153         exit(1);
00154     \}
00155     \textcolor{keywordflow}{if} (strcmp((\textcolor{keywordtype}{char}*)uncompr, hello)) \{
00156         fprintf(stderr, \textcolor{stringliteral}{"bad gzread: %s\(\backslash\)n"}, (\textcolor{keywordtype}{char}*)uncompr);
00157         exit(1);
00158     \} \textcolor{keywordflow}{else} \{
00159         printf(\textcolor{stringliteral}{"gzread(): %s\(\backslash\)n"}, (\textcolor{keywordtype}{char}*)uncompr);
00160     \}
00161 
00162     pos = gzseek(file, -8L, SEEK\_CUR);
00163     \textcolor{keywordflow}{if} (pos != 6 || gztell(file) != pos) \{
00164         fprintf(stderr, \textcolor{stringliteral}{"gzseek error, pos=%ld, gztell=%ld\(\backslash\)n"},
00165                 (\textcolor{keywordtype}{long})pos, (\textcolor{keywordtype}{long})gztell(file));
00166         exit(1);
00167     \}
00168 
00169     \textcolor{keywordflow}{if} (gzgetc(file) != \textcolor{charliteral}{' '}) \{
00170         fprintf(stderr, \textcolor{stringliteral}{"gzgetc error\(\backslash\)n"});
00171         exit(1);
00172     \}
00173 
00174     \textcolor{keywordflow}{if} (gzungetc(\textcolor{charliteral}{' '}, file) != \textcolor{charliteral}{' '}) \{
00175         fprintf(stderr, \textcolor{stringliteral}{"gzungetc error\(\backslash\)n"});
00176         exit(1);
00177     \}
00178 
00179     gzgets(file, (\textcolor{keywordtype}{char}*)uncompr, (\textcolor{keywordtype}{int})uncomprLen);
00180     \textcolor{keywordflow}{if} (strlen((\textcolor{keywordtype}{char}*)uncompr) != 7) \{ \textcolor{comment}{/* " hello!" */}
00181         fprintf(stderr, \textcolor{stringliteral}{"gzgets err after gzseek: %s\(\backslash\)n"}, gzerror(file, &err));
00182         exit(1);
00183     \}
00184     \textcolor{keywordflow}{if} (strcmp((\textcolor{keywordtype}{char}*)uncompr, hello + 6)) \{
00185         fprintf(stderr, \textcolor{stringliteral}{"bad gzgets after gzseek\(\backslash\)n"});
00186         exit(1);
00187     \} \textcolor{keywordflow}{else} \{
00188         printf(\textcolor{stringliteral}{"gzgets() after gzseek: %s\(\backslash\)n"}, (\textcolor{keywordtype}{char}*)uncompr);
00189     \}
00190 
00191     gzclose(file);
00192 \textcolor{preprocessor}{#endif}
00193 \}
00194 
00195 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* Z\_SOLO */}\textcolor{preprocessor}{}
00196 
00197 \textcolor{comment}{/* ===========================================================================}
00198 \textcolor{comment}{ * Test deflate() with small buffers}
00199 \textcolor{comment}{ */}
00200 \textcolor{keywordtype}{void} test\_deflate(compr, comprLen)
00201     Byte *compr;
00202     uLong comprLen;
00203 \{
00204     \hyperlink{structz__stream__s}{z\_stream} c\_stream; \textcolor{comment}{/* compression stream */}
00205     \textcolor{keywordtype}{int} err;
00206     uLong len = (uLong)strlen(hello)+1;
00207 
00208     c\_stream.zalloc = zalloc;
00209     c\_stream.zfree = zfree;
00210     c\_stream.opaque = (voidpf)0;
00211 
00212     err = deflateInit(&c\_stream, Z\_DEFAULT\_COMPRESSION);
00213     CHECK\_ERR(err, \textcolor{stringliteral}{"deflateInit"});
00214 
00215     c\_stream.next\_in  = (z\_const \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)hello;
00216     c\_stream.next\_out = compr;
00217 
00218     \textcolor{keywordflow}{while} (c\_stream.total\_in != len && c\_stream.total\_out < comprLen) \{
00219         c\_stream.avail\_in = c\_stream.avail\_out = 1; \textcolor{comment}{/* force small buffers */}
00220         err = deflate(&c\_stream, Z\_NO\_FLUSH);
00221         CHECK\_ERR(err, \textcolor{stringliteral}{"deflate"});
00222     \}
00223     \textcolor{comment}{/* Finish the stream, still forcing small buffers: */}
00224     \textcolor{keywordflow}{for} (;;) \{
00225         c\_stream.avail\_out = 1;
00226         err = deflate(&c\_stream, Z\_FINISH);
00227         \textcolor{keywordflow}{if} (err == Z\_STREAM\_END) \textcolor{keywordflow}{break};
00228         CHECK\_ERR(err, \textcolor{stringliteral}{"deflate"});
00229     \}
00230 
00231     err = deflateEnd(&c\_stream);
00232     CHECK\_ERR(err, \textcolor{stringliteral}{"deflateEnd"});
00233 \}
00234 
00235 \textcolor{comment}{/* ===========================================================================}
00236 \textcolor{comment}{ * Test inflate() with small buffers}
00237 \textcolor{comment}{ */}
00238 \textcolor{keywordtype}{void} test\_inflate(compr, comprLen, uncompr, uncomprLen)
00239     Byte *compr, *uncompr;
00240     uLong comprLen, uncomprLen;
00241 \{
00242     \textcolor{keywordtype}{int} err;
00243     \hyperlink{structz__stream__s}{z\_stream} d\_stream; \textcolor{comment}{/* decompression stream */}
00244 
00245     strcpy((\textcolor{keywordtype}{char}*)uncompr, \textcolor{stringliteral}{"garbage"});
00246 
00247     d\_stream.zalloc = zalloc;
00248     d\_stream.zfree = zfree;
00249     d\_stream.opaque = (voidpf)0;
00250 
00251     d\_stream.next\_in  = compr;
00252     d\_stream.avail\_in = 0;
00253     d\_stream.next\_out = uncompr;
00254 
00255     err = inflateInit(&d\_stream);
00256     CHECK\_ERR(err, \textcolor{stringliteral}{"inflateInit"});
00257 
00258     \textcolor{keywordflow}{while} (d\_stream.total\_out < uncomprLen && d\_stream.total\_in < comprLen) \{
00259         d\_stream.avail\_in = d\_stream.avail\_out = 1; \textcolor{comment}{/* force small buffers */}
00260         err = inflate(&d\_stream, Z\_NO\_FLUSH);
00261         \textcolor{keywordflow}{if} (err == Z\_STREAM\_END) \textcolor{keywordflow}{break};
00262         CHECK\_ERR(err, \textcolor{stringliteral}{"inflate"});
00263     \}
00264 
00265     err = inflateEnd(&d\_stream);
00266     CHECK\_ERR(err, \textcolor{stringliteral}{"inflateEnd"});
00267 
00268     \textcolor{keywordflow}{if} (strcmp((\textcolor{keywordtype}{char}*)uncompr, hello)) \{
00269         fprintf(stderr, \textcolor{stringliteral}{"bad inflate\(\backslash\)n"});
00270         exit(1);
00271     \} \textcolor{keywordflow}{else} \{
00272         printf(\textcolor{stringliteral}{"inflate(): %s\(\backslash\)n"}, (\textcolor{keywordtype}{char} *)uncompr);
00273     \}
00274 \}
00275 
00276 \textcolor{comment}{/* ===========================================================================}
00277 \textcolor{comment}{ * Test deflate() with large buffers and dynamic change of compression level}
00278 \textcolor{comment}{ */}
00279 \textcolor{keywordtype}{void} test\_large\_deflate(compr, comprLen, uncompr, uncomprLen)
00280     Byte *compr, *uncompr;
00281     uLong comprLen, uncomprLen;
00282 \{
00283     \hyperlink{structz__stream__s}{z\_stream} c\_stream; \textcolor{comment}{/* compression stream */}
00284     \textcolor{keywordtype}{int} err;
00285 
00286     c\_stream.zalloc = zalloc;
00287     c\_stream.zfree = zfree;
00288     c\_stream.opaque = (voidpf)0;
00289 
00290     err = deflateInit(&c\_stream, Z\_BEST\_SPEED);
00291     CHECK\_ERR(err, \textcolor{stringliteral}{"deflateInit"});
00292 
00293     c\_stream.next\_out = compr;
00294     c\_stream.avail\_out = (uInt)comprLen;
00295 
00296     \textcolor{comment}{/* At this point, uncompr is still mostly zeroes, so it should compress}
00297 \textcolor{comment}{     * very well:}
00298 \textcolor{comment}{     */}
00299     c\_stream.next\_in = uncompr;
00300     c\_stream.avail\_in = (uInt)uncomprLen;
00301     err = deflate(&c\_stream, Z\_NO\_FLUSH);
00302     CHECK\_ERR(err, \textcolor{stringliteral}{"deflate"});
00303     \textcolor{keywordflow}{if} (c\_stream.avail\_in != 0) \{
00304         fprintf(stderr, \textcolor{stringliteral}{"deflate not greedy\(\backslash\)n"});
00305         exit(1);
00306     \}
00307 
00308     \textcolor{comment}{/* Feed in already compressed data and switch to no compression: */}
00309     deflateParams(&c\_stream, Z\_NO\_COMPRESSION, Z\_DEFAULT\_STRATEGY);
00310     c\_stream.next\_in = compr;
00311     c\_stream.avail\_in = (uInt)comprLen/2;
00312     err = deflate(&c\_stream, Z\_NO\_FLUSH);
00313     CHECK\_ERR(err, \textcolor{stringliteral}{"deflate"});
00314 
00315     \textcolor{comment}{/* Switch back to compressing mode: */}
00316     deflateParams(&c\_stream, Z\_BEST\_COMPRESSION, Z\_FILTERED);
00317     c\_stream.next\_in = uncompr;
00318     c\_stream.avail\_in = (uInt)uncomprLen;
00319     err = deflate(&c\_stream, Z\_NO\_FLUSH);
00320     CHECK\_ERR(err, \textcolor{stringliteral}{"deflate"});
00321 
00322     err = deflate(&c\_stream, Z\_FINISH);
00323     \textcolor{keywordflow}{if} (err != Z\_STREAM\_END) \{
00324         fprintf(stderr, \textcolor{stringliteral}{"deflate should report Z\_STREAM\_END\(\backslash\)n"});
00325         exit(1);
00326     \}
00327     err = deflateEnd(&c\_stream);
00328     CHECK\_ERR(err, \textcolor{stringliteral}{"deflateEnd"});
00329 \}
00330 
00331 \textcolor{comment}{/* ===========================================================================}
00332 \textcolor{comment}{ * Test inflate() with large buffers}
00333 \textcolor{comment}{ */}
00334 \textcolor{keywordtype}{void} test\_large\_inflate(compr, comprLen, uncompr, uncomprLen)
00335     Byte *compr, *uncompr;
00336     uLong comprLen, uncomprLen;
00337 \{
00338     \textcolor{keywordtype}{int} err;
00339     \hyperlink{structz__stream__s}{z\_stream} d\_stream; \textcolor{comment}{/* decompression stream */}
00340 
00341     strcpy((\textcolor{keywordtype}{char}*)uncompr, \textcolor{stringliteral}{"garbage"});
00342 
00343     d\_stream.zalloc = zalloc;
00344     d\_stream.zfree = zfree;
00345     d\_stream.opaque = (voidpf)0;
00346 
00347     d\_stream.next\_in  = compr;
00348     d\_stream.avail\_in = (uInt)comprLen;
00349 
00350     err = inflateInit(&d\_stream);
00351     CHECK\_ERR(err, \textcolor{stringliteral}{"inflateInit"});
00352 
00353     \textcolor{keywordflow}{for} (;;) \{
00354         d\_stream.next\_out = uncompr;            \textcolor{comment}{/* discard the output */}
00355         d\_stream.avail\_out = (uInt)uncomprLen;
00356         err = inflate(&d\_stream, Z\_NO\_FLUSH);
00357         \textcolor{keywordflow}{if} (err == Z\_STREAM\_END) \textcolor{keywordflow}{break};
00358         CHECK\_ERR(err, \textcolor{stringliteral}{"large inflate"});
00359     \}
00360 
00361     err = inflateEnd(&d\_stream);
00362     CHECK\_ERR(err, \textcolor{stringliteral}{"inflateEnd"});
00363 
00364     \textcolor{keywordflow}{if} (d\_stream.total\_out != 2*uncomprLen + comprLen/2) \{
00365         fprintf(stderr, \textcolor{stringliteral}{"bad large inflate: %ld\(\backslash\)n"}, d\_stream.total\_out);
00366         exit(1);
00367     \} \textcolor{keywordflow}{else} \{
00368         printf(\textcolor{stringliteral}{"large\_inflate(): OK\(\backslash\)n"});
00369     \}
00370 \}
00371 
00372 \textcolor{comment}{/* ===========================================================================}
00373 \textcolor{comment}{ * Test deflate() with full flush}
00374 \textcolor{comment}{ */}
00375 \textcolor{keywordtype}{void} test\_flush(compr, comprLen)
00376     Byte *compr;
00377     uLong *comprLen;
00378 \{
00379     \hyperlink{structz__stream__s}{z\_stream} c\_stream; \textcolor{comment}{/* compression stream */}
00380     \textcolor{keywordtype}{int} err;
00381     uInt len = (uInt)strlen(hello)+1;
00382 
00383     c\_stream.zalloc = zalloc;
00384     c\_stream.zfree = zfree;
00385     c\_stream.opaque = (voidpf)0;
00386 
00387     err = deflateInit(&c\_stream, Z\_DEFAULT\_COMPRESSION);
00388     CHECK\_ERR(err, \textcolor{stringliteral}{"deflateInit"});
00389 
00390     c\_stream.next\_in  = (z\_const \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)hello;
00391     c\_stream.next\_out = compr;
00392     c\_stream.avail\_in = 3;
00393     c\_stream.avail\_out = (uInt)*comprLen;
00394     err = deflate(&c\_stream, Z\_FULL\_FLUSH);
00395     CHECK\_ERR(err, \textcolor{stringliteral}{"deflate"});
00396 
00397     compr[3]++; \textcolor{comment}{/* force an error in first compressed block */}
00398     c\_stream.avail\_in = len - 3;
00399 
00400     err = deflate(&c\_stream, Z\_FINISH);
00401     \textcolor{keywordflow}{if} (err != Z\_STREAM\_END) \{
00402         CHECK\_ERR(err, \textcolor{stringliteral}{"deflate"});
00403     \}
00404     err = deflateEnd(&c\_stream);
00405     CHECK\_ERR(err, \textcolor{stringliteral}{"deflateEnd"});
00406 
00407     *comprLen = c\_stream.total\_out;
00408 \}
00409 
00410 \textcolor{comment}{/* ===========================================================================}
00411 \textcolor{comment}{ * Test inflateSync()}
00412 \textcolor{comment}{ */}
00413 \textcolor{keywordtype}{void} test\_sync(compr, comprLen, uncompr, uncomprLen)
00414     Byte *compr, *uncompr;
00415     uLong comprLen, uncomprLen;
00416 \{
00417     \textcolor{keywordtype}{int} err;
00418     \hyperlink{structz__stream__s}{z\_stream} d\_stream; \textcolor{comment}{/* decompression stream */}
00419 
00420     strcpy((\textcolor{keywordtype}{char}*)uncompr, \textcolor{stringliteral}{"garbage"});
00421 
00422     d\_stream.zalloc = zalloc;
00423     d\_stream.zfree = zfree;
00424     d\_stream.opaque = (voidpf)0;
00425 
00426     d\_stream.next\_in  = compr;
00427     d\_stream.avail\_in = 2; \textcolor{comment}{/* just read the zlib header */}
00428 
00429     err = inflateInit(&d\_stream);
00430     CHECK\_ERR(err, \textcolor{stringliteral}{"inflateInit"});
00431 
00432     d\_stream.next\_out = uncompr;
00433     d\_stream.avail\_out = (uInt)uncomprLen;
00434 
00435     err = inflate(&d\_stream, Z\_NO\_FLUSH);
00436     CHECK\_ERR(err, \textcolor{stringliteral}{"inflate"});
00437 
00438     d\_stream.avail\_in = (uInt)comprLen-2;   \textcolor{comment}{/* read all compressed data */}
00439     err = inflateSync(&d\_stream);           \textcolor{comment}{/* but skip the damaged part */}
00440     CHECK\_ERR(err, \textcolor{stringliteral}{"inflateSync"});
00441 
00442     err = inflate(&d\_stream, Z\_FINISH);
00443     \textcolor{keywordflow}{if} (err != Z\_DATA\_ERROR) \{
00444         fprintf(stderr, \textcolor{stringliteral}{"inflate should report DATA\_ERROR\(\backslash\)n"});
00445         \textcolor{comment}{/* Because of incorrect adler32 */}
00446         exit(1);
00447     \}
00448     err = inflateEnd(&d\_stream);
00449     CHECK\_ERR(err, \textcolor{stringliteral}{"inflateEnd"});
00450 
00451     printf(\textcolor{stringliteral}{"after inflateSync(): hel%s\(\backslash\)n"}, (\textcolor{keywordtype}{char} *)uncompr);
00452 \}
00453 
00454 \textcolor{comment}{/* ===========================================================================}
00455 \textcolor{comment}{ * Test deflate() with preset dictionary}
00456 \textcolor{comment}{ */}
00457 \textcolor{keywordtype}{void} test\_dict\_deflate(compr, comprLen)
00458     Byte *compr;
00459     uLong comprLen;
00460 \{
00461     \hyperlink{structz__stream__s}{z\_stream} c\_stream; \textcolor{comment}{/* compression stream */}
00462     \textcolor{keywordtype}{int} err;
00463 
00464     c\_stream.zalloc = zalloc;
00465     c\_stream.zfree = zfree;
00466     c\_stream.opaque = (voidpf)0;
00467 
00468     err = deflateInit(&c\_stream, Z\_BEST\_COMPRESSION);
00469     CHECK\_ERR(err, \textcolor{stringliteral}{"deflateInit"});
00470 
00471     err = deflateSetDictionary(&c\_stream,
00472                 (\textcolor{keyword}{const} Bytef*)dictionary, (\textcolor{keywordtype}{int})\textcolor{keyword}{sizeof}(dictionary));
00473     CHECK\_ERR(err, \textcolor{stringliteral}{"deflateSetDictionary"});
00474 
00475     dictId = c\_stream.adler;
00476     c\_stream.next\_out = compr;
00477     c\_stream.avail\_out = (uInt)comprLen;
00478 
00479     c\_stream.next\_in = (z\_const \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)hello;
00480     c\_stream.avail\_in = (uInt)strlen(hello)+1;
00481 
00482     err = deflate(&c\_stream, Z\_FINISH);
00483     \textcolor{keywordflow}{if} (err != Z\_STREAM\_END) \{
00484         fprintf(stderr, \textcolor{stringliteral}{"deflate should report Z\_STREAM\_END\(\backslash\)n"});
00485         exit(1);
00486     \}
00487     err = deflateEnd(&c\_stream);
00488     CHECK\_ERR(err, \textcolor{stringliteral}{"deflateEnd"});
00489 \}
00490 
00491 \textcolor{comment}{/* ===========================================================================}
00492 \textcolor{comment}{ * Test inflate() with a preset dictionary}
00493 \textcolor{comment}{ */}
00494 \textcolor{keywordtype}{void} test\_dict\_inflate(compr, comprLen, uncompr, uncomprLen)
00495     Byte *compr, *uncompr;
00496     uLong comprLen, uncomprLen;
00497 \{
00498     \textcolor{keywordtype}{int} err;
00499     \hyperlink{structz__stream__s}{z\_stream} d\_stream; \textcolor{comment}{/* decompression stream */}
00500 
00501     strcpy((\textcolor{keywordtype}{char}*)uncompr, \textcolor{stringliteral}{"garbage"});
00502 
00503     d\_stream.zalloc = zalloc;
00504     d\_stream.zfree = zfree;
00505     d\_stream.opaque = (voidpf)0;
00506 
00507     d\_stream.next\_in  = compr;
00508     d\_stream.avail\_in = (uInt)comprLen;
00509 
00510     err = inflateInit(&d\_stream);
00511     CHECK\_ERR(err, \textcolor{stringliteral}{"inflateInit"});
00512 
00513     d\_stream.next\_out = uncompr;
00514     d\_stream.avail\_out = (uInt)uncomprLen;
00515 
00516     \textcolor{keywordflow}{for} (;;) \{
00517         err = inflate(&d\_stream, Z\_NO\_FLUSH);
00518         \textcolor{keywordflow}{if} (err == Z\_STREAM\_END) \textcolor{keywordflow}{break};
00519         \textcolor{keywordflow}{if} (err == Z\_NEED\_DICT) \{
00520             \textcolor{keywordflow}{if} (d\_stream.adler != dictId) \{
00521                 fprintf(stderr, \textcolor{stringliteral}{"unexpected dictionary"});
00522                 exit(1);
00523             \}
00524             err = inflateSetDictionary(&d\_stream, (\textcolor{keyword}{const} Bytef*)dictionary,
00525                                        (\textcolor{keywordtype}{int})\textcolor{keyword}{sizeof}(dictionary));
00526         \}
00527         CHECK\_ERR(err, \textcolor{stringliteral}{"inflate with dict"});
00528     \}
00529 
00530     err = inflateEnd(&d\_stream);
00531     CHECK\_ERR(err, \textcolor{stringliteral}{"inflateEnd"});
00532 
00533     \textcolor{keywordflow}{if} (strcmp((\textcolor{keywordtype}{char}*)uncompr, hello)) \{
00534         fprintf(stderr, \textcolor{stringliteral}{"bad inflate with dict\(\backslash\)n"});
00535         exit(1);
00536     \} \textcolor{keywordflow}{else} \{
00537         printf(\textcolor{stringliteral}{"inflate with dictionary: %s\(\backslash\)n"}, (\textcolor{keywordtype}{char} *)uncompr);
00538     \}
00539 \}
00540 
00541 \textcolor{comment}{/* ===========================================================================}
00542 \textcolor{comment}{ * Usage:  example [output.gz  [input.gz]]}
00543 \textcolor{comment}{ */}
00544 
00545 \textcolor{keywordtype}{int} main(argc, argv)
00546     \textcolor{keywordtype}{int} argc;
00547     \textcolor{keywordtype}{char} *argv[];
00548 \{
00549     Byte *compr, *uncompr;
00550     uLong comprLen = 10000*\textcolor{keyword}{sizeof}(int); \textcolor{comment}{/* don't overflow on MSDOS */}
00551     uLong uncomprLen = comprLen;
00552     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* myVersion = ZLIB\_VERSION;
00553 
00554     \textcolor{keywordflow}{if} (zlibVersion()[0] != myVersion[0]) \{
00555         fprintf(stderr, \textcolor{stringliteral}{"incompatible zlib version\(\backslash\)n"});
00556         exit(1);
00557 
00558     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (strcmp(zlibVersion(), ZLIB\_VERSION) != 0) \{
00559         fprintf(stderr, \textcolor{stringliteral}{"warning: different zlib version\(\backslash\)n"});
00560     \}
00561 
00562     printf(\textcolor{stringliteral}{"zlib version %s = 0x%04x, compile flags = 0x%lx\(\backslash\)n"},
00563             ZLIB\_VERSION, ZLIB\_VERNUM, zlibCompileFlags());
00564 
00565     compr    = (Byte*)calloc((uInt)comprLen, 1);
00566     uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);
00567     \textcolor{comment}{/* compr and uncompr are cleared to avoid reading uninitialized}
00568 \textcolor{comment}{     * data and to ensure that uncompr compresses well.}
00569 \textcolor{comment}{     */}
00570     \textcolor{keywordflow}{if} (compr == Z\_NULL || uncompr == Z\_NULL) \{
00571         printf(\textcolor{stringliteral}{"out of memory\(\backslash\)n"});
00572         exit(1);
00573     \}
00574 
00575 \textcolor{preprocessor}{#ifdef Z\_SOLO}
00576     (void)argc;
00577     (void)argv;
00578 \textcolor{preprocessor}{#else}
00579     test\_compress(compr, comprLen, uncompr, uncomprLen);
00580 
00581     test\_gzio((argc > 1 ? argv[1] : TESTFILE),
00582               uncompr, uncomprLen);
00583 \textcolor{preprocessor}{#endif}
00584 
00585     test\_deflate(compr, comprLen);
00586     test\_inflate(compr, comprLen, uncompr, uncomprLen);
00587 
00588     test\_large\_deflate(compr, comprLen, uncompr, uncomprLen);
00589     test\_large\_inflate(compr, comprLen, uncompr, uncomprLen);
00590 
00591     test\_flush(compr, &comprLen);
00592     test\_sync(compr, comprLen, uncompr, uncomprLen);
00593     comprLen = uncomprLen;
00594 
00595     test\_dict\_deflate(compr, comprLen);
00596     test\_dict\_inflate(compr, comprLen, uncompr, uncomprLen);
00597 
00598     free(compr);
00599     free(uncompr);
00600 
00601     \textcolor{keywordflow}{return} 0;
00602 \}
\end{DoxyCode}
