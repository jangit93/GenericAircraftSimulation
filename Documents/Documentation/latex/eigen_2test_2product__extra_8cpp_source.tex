\hypertarget{eigen_2test_2product__extra_8cpp_source}{}\section{eigen/test/product\+\_\+extra.cpp}
\label{eigen_2test_2product__extra_8cpp_source}\index{product\+\_\+extra.\+cpp@{product\+\_\+extra.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} product\_extra(\textcolor{keyword}{const} MatrixType& m)
00013 \{
00014   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00015   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00016   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, 1, Dynamic>} RowVectorType;
00017   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>} ColVectorType;
00018   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<Scalar, \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, Dynamic,
00019                          MatrixType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}> OtherMajorMatrixType;
00020 
00021   Index rows = m.rows();
00022   Index cols = m.cols();
00023 
00024   MatrixType m1 = MatrixType::Random(rows, cols),
00025              m2 = MatrixType::Random(rows, cols),
00026              m3(rows, cols),
00027              mzero = MatrixType::Zero(rows, cols),
00028              identity = MatrixType::Identity(rows, rows),
00029              square = MatrixType::Random(rows, rows),
00030              res = MatrixType::Random(rows, rows),
00031              square2 = MatrixType::Random(cols, cols),
00032              res2 = MatrixType::Random(cols, cols);
00033   RowVectorType v1 = RowVectorType::Random(rows), vrres(rows);
00034   ColVectorType vc2 = ColVectorType::Random(cols), vcres(cols);
00035   OtherMajorMatrixType tm1 = m1;
00036 
00037   Scalar s1 = internal::random<Scalar>(),
00038          s2 = internal::random<Scalar>(),
00039          s3 = internal::random<Scalar>();
00040 
00041   VERIFY\_IS\_APPROX(m3.noalias() = m1 * m2.adjoint(),                 m1 * m2.adjoint().eval());
00042   VERIFY\_IS\_APPROX(m3.noalias() = m1.adjoint() * square.adjoint(),   m1.adjoint().eval() * square.adjoint()
      .eval());
00043   VERIFY\_IS\_APPROX(m3.noalias() = m1.adjoint() * m2,                 m1.adjoint().eval() * m2);
00044   VERIFY\_IS\_APPROX(m3.noalias() = (s1 * m1.adjoint()) * m2,          (s1 * m1.adjoint()).eval() * m2);
00045   VERIFY\_IS\_APPROX(m3.noalias() = ((s1 * m1).adjoint()) * m2,        (numext::conj(s1) * m1.adjoint()).eval
      () * m2);
00046   VERIFY\_IS\_APPROX(m3.noalias() = (- m1.adjoint() * s1) * (s3 * m2), (- m1.adjoint()  * s1).eval() * (s3 * 
      m2).eval());
00047   VERIFY\_IS\_APPROX(m3.noalias() = (s2 * m1.adjoint() * s1) * m2,     (s2 * m1.adjoint()  * s1).eval() * m2)
      ;
00048   VERIFY\_IS\_APPROX(m3.noalias() = (-m1*s2) * s1*m2.adjoint(),        (-m1*s2).eval() * (s1*m2.adjoint()).
      eval());
00049 
00050   \textcolor{comment}{// a very tricky case where a scale factor has to be automatically conjugated:}
00051   VERIFY\_IS\_APPROX( m1.adjoint() * (s1*m2).conjugate(), (m1.adjoint()).eval() * ((s1*m2).conjugate()).eval(
      ));
00052 
00053 
00054   \textcolor{comment}{// test all possible conjugate combinations for the four matrix-vector product cases:}
00055 
00056   VERIFY\_IS\_APPROX((-m1.conjugate() * s2) * (s1 * vc2),
00057                    (-m1.conjugate()*s2).eval() * (s1 * vc2).eval());
00058   VERIFY\_IS\_APPROX((-m1 * s2) * (s1 * vc2.conjugate()),
00059                    (-m1*s2).eval() * (s1 * vc2.conjugate()).eval());
00060   VERIFY\_IS\_APPROX((-m1.conjugate() * s2) * (s1 * vc2.conjugate()),
00061                    (-m1.conjugate()*s2).eval() * (s1 * vc2.conjugate()).eval());
00062 
00063   VERIFY\_IS\_APPROX((s1 * vc2.transpose()) * (-m1.adjoint() * s2),
00064                    (s1 * vc2.transpose()).eval() * (-m1.adjoint()*s2).eval());
00065   VERIFY\_IS\_APPROX((s1 * vc2.adjoint()) * (-m1.transpose() * s2),
00066                    (s1 * vc2.adjoint()).eval() * (-m1.transpose()*s2).eval());
00067   VERIFY\_IS\_APPROX((s1 * vc2.adjoint()) * (-m1.adjoint() * s2),
00068                    (s1 * vc2.adjoint()).eval() * (-m1.adjoint()*s2).eval());
00069 
00070   VERIFY\_IS\_APPROX((-m1.adjoint() * s2) * (s1 * v1.transpose()),
00071                    (-m1.adjoint()*s2).eval() * (s1 * v1.transpose()).eval());
00072   VERIFY\_IS\_APPROX((-m1.transpose() * s2) * (s1 * v1.adjoint()),
00073                    (-m1.transpose()*s2).eval() * (s1 * v1.adjoint()).eval());
00074   VERIFY\_IS\_APPROX((-m1.adjoint() * s2) * (s1 * v1.adjoint()),
00075                    (-m1.adjoint()*s2).eval() * (s1 * v1.adjoint()).eval());
00076 
00077   VERIFY\_IS\_APPROX((s1 * v1) * (-m1.conjugate() * s2),
00078                    (s1 * v1).eval() * (-m1.conjugate()*s2).eval());
00079   VERIFY\_IS\_APPROX((s1 * v1.conjugate()) * (-m1 * s2),
00080                    (s1 * v1.conjugate()).eval() * (-m1*s2).eval());
00081   VERIFY\_IS\_APPROX((s1 * v1.conjugate()) * (-m1.conjugate() * s2),
00082                    (s1 * v1.conjugate()).eval() * (-m1.conjugate()*s2).eval());
00083 
00084   VERIFY\_IS\_APPROX((-m1.adjoint() * s2) * (s1 * v1.adjoint()),
00085                    (-m1.adjoint()*s2).eval() * (s1 * v1.adjoint()).eval());
00086 
00087   \textcolor{comment}{// test the vector-matrix product with non aligned starts}
00088   Index i = internal::random<Index>(0,m1.rows()-2);
00089   Index j = internal::random<Index>(0,m1.cols()-2);
00090   Index r = internal::random<Index>(1,m1.rows()-i);
00091   Index c = internal::random<Index>(1,m1.cols()-j);
00092   Index i2 = internal::random<Index>(0,m1.rows()-1);
00093   Index j2 = internal::random<Index>(0,m1.cols()-1);
00094 
00095   VERIFY\_IS\_APPROX(m1.col(j2).adjoint() * m1.block(0,j,m1.rows(),c), m1.col(j2).adjoint().eval() * m1.block
      (0,j,m1.rows(),c).eval());
00096   VERIFY\_IS\_APPROX(m1.block(i,0,r,m1.cols()) * m1.row(i2).adjoint(), m1.block(i,0,r,m1.cols()).eval() * m1.
      row(i2).adjoint().eval());
00097   
00098   \textcolor{comment}{// regression test}
00099   MatrixType tmp = m1 * m1.adjoint() * s1;
00100   VERIFY\_IS\_APPROX(tmp, m1 * m1.adjoint() * s1);
00101 
00102   \textcolor{comment}{// regression test for bug 1343, assignment to arrays}
00103   \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,Dynamic,1>} a1 = m1 * vc2;
00104   VERIFY\_IS\_APPROX(a1.matrix(),m1*vc2);
00105   \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,Dynamic,1>} a2 = s1 * (m1 * vc2);
00106   VERIFY\_IS\_APPROX(a2.matrix(),s1*m1*vc2);
00107   \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,1,Dynamic>} a3 = v1 * m1;
00108   VERIFY\_IS\_APPROX(a3.matrix(),v1*m1);
00109   \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,Dynamic,Dynamic>} a4 = m1 * m2.adjoint();
00110   VERIFY\_IS\_APPROX(a4.matrix(),m1*m2.adjoint());
00111 \}
00112 
00113 \textcolor{comment}{// Regression test for bug reported at http://forum.kde.org/viewtopic.php?f=74&t=96947}
00114 \textcolor{keywordtype}{void} mat\_mat\_scalar\_scalar\_product()
00115 \{
00116   Eigen::Matrix2Xd dNdxy(2, 3);
00117   dNdxy << -0.5, 0.5, 0,
00118            -0.3, 0, 0.3;
00119   \textcolor{keywordtype}{double} det = 6.0, wt = 0.5;
00120   VERIFY\_IS\_APPROX(dNdxy.transpose()*dNdxy*det*wt, det*wt*dNdxy.transpose()*dNdxy);
00121 \}
00122 
00123 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType> 
00124 \textcolor{keywordtype}{void} zero\_sized\_objects(\textcolor{keyword}{const} MatrixType& m)
00125 \{
00126   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00127   \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize  = internal::packet\_traits<Scalar>::size;
00128   \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize1 = PacketSize>1 ?  PacketSize-1 : 1;
00129   Index rows = m.rows();
00130   Index cols = m.cols();
00131   
00132   \{
00133     MatrixType res, a(rows,0), b(0,cols);
00134     VERIFY\_IS\_APPROX( (res=a*b), MatrixType::Zero(rows,cols) );
00135     VERIFY\_IS\_APPROX( (res=a*a.transpose()), MatrixType::Zero(rows,rows) );
00136     VERIFY\_IS\_APPROX( (res=b.transpose()*b), MatrixType::Zero(cols,cols) );
00137     VERIFY\_IS\_APPROX( (res=b.transpose()*a.transpose()), MatrixType::Zero(cols,rows) );
00138   \}
00139   
00140   \{
00141     MatrixType res, a(rows,cols), b(cols,0);
00142     res = a*b;
00143     VERIFY(res.rows()==rows && res.cols()==0);
00144     b.resize(0,rows);
00145     res = b*a;
00146     VERIFY(res.rows()==0 && res.cols()==cols);
00147   \}
00148   
00149   \{
00150     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,PacketSize,0>} a;
00151     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,0,1>} b;
00152     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,PacketSize,1>} res;
00153     VERIFY\_IS\_APPROX( (res=a*b), MatrixType::Zero(PacketSize,1) );
00154     VERIFY\_IS\_APPROX( (res=a.lazyProduct(b)), MatrixType::Zero(PacketSize,1) );
00155   \}
00156   
00157   \{
00158     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,PacketSize1,0>} a;
00159     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,0,1>} b;
00160     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,PacketSize1,1>} res;
00161     VERIFY\_IS\_APPROX( (res=a*b), MatrixType::Zero(PacketSize1,1) );
00162     VERIFY\_IS\_APPROX( (res=a.lazyProduct(b)), MatrixType::Zero(PacketSize1,1) );
00163   \}
00164   
00165   \{
00166     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,PacketSize,Dynamic>} a(PacketSize,0);
00167     \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} b(0,1);
00168     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,PacketSize,1>} res;
00169     VERIFY\_IS\_APPROX( (res=a*b), MatrixType::Zero(PacketSize,1) );
00170     VERIFY\_IS\_APPROX( (res=a.lazyProduct(b)), MatrixType::Zero(PacketSize,1) );
00171   \}
00172   
00173   \{
00174     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,PacketSize1,Dynamic>} a(PacketSize1,0);
00175     \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} b(0,1);
00176     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,PacketSize1,1>} res;
00177     VERIFY\_IS\_APPROX( (res=a*b), MatrixType::Zero(PacketSize1,1) );
00178     VERIFY\_IS\_APPROX( (res=a.lazyProduct(b)), MatrixType::Zero(PacketSize1,1) );
00179   \}
00180 \}
00181 
00182 \textcolor{keyword}{template}<\textcolor{keywordtype}{int}>
00183 \textcolor{keywordtype}{void} bug\_127()
00184 \{
00185   \textcolor{comment}{// Bug 127}
00186   \textcolor{comment}{//}
00187   \textcolor{comment}{// a product of the form lhs*rhs with}
00188   \textcolor{comment}{//}
00189   \textcolor{comment}{// lhs:}
00190   \textcolor{comment}{// rows = 1, cols = 4}
00191   \textcolor{comment}{// RowsAtCompileTime = 1, ColsAtCompileTime = -1}
00192   \textcolor{comment}{// MaxRowsAtCompileTime = 1, MaxColsAtCompileTime = 5}
00193   \textcolor{comment}{//}
00194   \textcolor{comment}{// rhs:}
00195   \textcolor{comment}{// rows = 4, cols = 0}
00196   \textcolor{comment}{// RowsAtCompileTime = -1, ColsAtCompileTime = -1}
00197   \textcolor{comment}{// MaxRowsAtCompileTime = 5, MaxColsAtCompileTime = 1}
00198   \textcolor{comment}{//}
00199   \textcolor{comment}{// was failing on a runtime assertion, because it had been mis-compiled as a dot product because
       Product.h was using the}
00200   \textcolor{comment}{// max-sizes to detect size 1 indicating vectors, and that didn't account for 0-sized object with
       max-size 1.}
00201 
00202   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,1,Dynamic,RowMajor,1,5>} a(1,4);
00203   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,Dynamic,Dynamic,ColMajor,5,1>} b(4,0);
00204   a*b;
00205 \}
00206 
00207 \textcolor{keyword}{template}<\textcolor{keywordtype}{int}> \textcolor{keywordtype}{void} bug\_817()
00208 \{
00209   ArrayXXf \hyperlink{group___core___module_class_eigen_1_1_matrix}{B} = ArrayXXf::Random(10,10), \hyperlink{group___core___module}{C};
00210   VectorXf x = VectorXf::Random(10);
00211   \hyperlink{group___core___module}{C} = (x.transpose()*B.matrix());
00212   B = (x.transpose()*B.matrix());
00213   VERIFY\_IS\_APPROX(B,\hyperlink{group___core___module}{C});
00214 \}
00215 
00216 \textcolor{keyword}{template}<\textcolor{keywordtype}{int}>
00217 \textcolor{keywordtype}{void} unaligned\_objects()
00218 \{
00219   \textcolor{comment}{// Regression test for the bug reported here:}
00220   \textcolor{comment}{// http://forum.kde.org/viewtopic.php?f=74&t=107541}
00221   \textcolor{comment}{// Recall the matrix*vector kernel avoid unaligned loads by loading two packets and then reassemble then.}
00222   \textcolor{comment}{// There was a mistake in the computation of the valid range for fully unaligned objects: in some rare
       cases,}
00223   \textcolor{comment}{// memory was read outside the allocated matrix memory. Though the values were not used, this might raise
       segfault.}
00224   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} m=450;m<460;++m)
00225   \{
00226     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} n=8;n<12;++n)
00227     \{
00228       MatrixXf \hyperlink{group___core___module_class_eigen_1_1_matrix}{M}(m, n);
00229       VectorXf v1(n), r1(500);
00230       RowVectorXf v2(m), r2(16);
00231 
00232       \hyperlink{group___core___module_class_eigen_1_1_matrix}{M}.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00233       v1.setRandom();
00234       v2.setRandom();
00235       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} o=0; o<4; ++o)
00236       \{
00237         r1.segment(o,m).noalias() = \hyperlink{group___core___module_class_eigen_1_1_matrix}{M} * v1;
00238         VERIFY\_IS\_APPROX(r1.segment(o,m), \hyperlink{group___core___module_class_eigen_1_1_matrix}{M} * MatrixXf(v1));
00239         r2.segment(o,n).noalias() = v2 * \hyperlink{group___core___module_class_eigen_1_1_matrix}{M};
00240         VERIFY\_IS\_APPROX(r2.segment(o,n), MatrixXf(v2) * M);
00241       \}
00242     \}
00243   \}
00244 \}
00245 
00246 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00247 EIGEN\_DONT\_INLINE
00248 Index test\_compute\_block\_size(Index m, Index n, Index k)
00249 \{
00250   Index mc(m), nc(n), kc(k);
00251   internal::computeProductBlockingSizes<T,T>(kc, mc, nc);
00252   \textcolor{keywordflow}{return} kc+mc+nc;
00253 \}
00254 
00255 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00256 Index compute\_block\_size()
00257 \{
00258   Index ret = 0;
00259   ret += test\_compute\_block\_size<T>(0,1,1);
00260   ret += test\_compute\_block\_size<T>(1,0,1);
00261   ret += test\_compute\_block\_size<T>(1,1,0);
00262   ret += test\_compute\_block\_size<T>(0,0,1);
00263   ret += test\_compute\_block\_size<T>(0,1,0);
00264   ret += test\_compute\_block\_size<T>(1,0,0);
00265   ret += test\_compute\_block\_size<T>(0,0,0);
00266   \textcolor{keywordflow}{return} ret;
00267 \}
00268 
00269 \textcolor{keyword}{template}<\textcolor{keyword}{typename}>
00270 \textcolor{keywordtype}{void} aliasing\_with\_resize()
00271 \{
00272   Index m = internal::random<Index>(10,50);
00273   Index n = internal::random<Index>(10,50);
00274   MatrixXd \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, B, \hyperlink{group___core___module}{C}(m,n), D(m,m);
00275   VectorXd a, b, c(n);
00276   \hyperlink{group___core___module}{C}.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00277   D.setRandom();
00278   c.setRandom();
00279   \textcolor{keywordtype}{double} s = internal::random<double>(1,10);
00280 
00281   A = \hyperlink{group___core___module}{C};
00282   B = A * A.transpose();
00283   A = A * A.transpose();
00284   VERIFY\_IS\_APPROX(A,B);
00285 
00286   A = \hyperlink{group___core___module}{C};
00287   B = (A * A.transpose())/s;
00288   A = (A * A.transpose())/s;
00289   VERIFY\_IS\_APPROX(A,B);
00290 
00291   A = \hyperlink{group___core___module}{C};
00292   B = (A * A.transpose()) + D;
00293   A = (A * A.transpose()) + D;
00294   VERIFY\_IS\_APPROX(A,B);
00295 
00296   A = \hyperlink{group___core___module}{C};
00297   B = D + (A * A.transpose());
00298   A = D + (A * A.transpose());
00299   VERIFY\_IS\_APPROX(A,B);
00300 
00301   A = \hyperlink{group___core___module}{C};
00302   B = s * (A * A.transpose());
00303   A = s * (A * A.transpose());
00304   VERIFY\_IS\_APPROX(A,B);
00305 
00306   A = \hyperlink{group___core___module}{C};
00307   a = c;
00308   b = (A * a)/s;
00309   a = (A * a)/s;
00310   VERIFY\_IS\_APPROX(a,b);
00311 \}
00312 
00313 \textcolor{keyword}{template}<\textcolor{keywordtype}{int}>
00314 \textcolor{keywordtype}{void} bug\_1308()
00315 \{
00316   \textcolor{keywordtype}{int} n = 10;
00317   MatrixXd r(n,n);
00318   VectorXd v = VectorXd::Random(n);
00319   r = v * RowVectorXd::Ones(n);
00320   VERIFY\_IS\_APPROX(r, v.rowwise().replicate(n));
00321   r = VectorXd::Ones(n) * v.transpose();
00322   VERIFY\_IS\_APPROX(r, v.rowwise().replicate(n).transpose());
00323 
00324   Matrix4d ones44 = Matrix4d::Ones();
00325   Matrix4d m44 = Matrix4d::Ones() * Matrix4d::Ones();
00326   VERIFY\_IS\_APPROX(m44,Matrix4d::Constant(4));
00327   VERIFY\_IS\_APPROX(m44.noalias()=ones44*Matrix4d::Ones(), Matrix4d::Constant(4));
00328   VERIFY\_IS\_APPROX(m44.noalias()=ones44.transpose()*Matrix4d::Ones(), Matrix4d::Constant(4));
00329   VERIFY\_IS\_APPROX(m44.noalias()=Matrix4d::Ones()*ones44, Matrix4d::Constant(4));
00330   VERIFY\_IS\_APPROX(m44.noalias()=Matrix4d::Ones()*ones44.transpose(), Matrix4d::Constant(4));
00331 
00332   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double,4,4,RowMajor>} RMatrix4d;
00333   RMatrix4d r44 = Matrix4d::Ones() * Matrix4d::Ones();
00334   VERIFY\_IS\_APPROX(r44,Matrix4d::Constant(4));
00335   VERIFY\_IS\_APPROX(r44.noalias()=ones44*Matrix4d::Ones(), Matrix4d::Constant(4));
00336   VERIFY\_IS\_APPROX(r44.noalias()=ones44.transpose()*Matrix4d::Ones(), Matrix4d::Constant(4));
00337   VERIFY\_IS\_APPROX(r44.noalias()=Matrix4d::Ones()*ones44, Matrix4d::Constant(4));
00338   VERIFY\_IS\_APPROX(r44.noalias()=Matrix4d::Ones()*ones44.transpose(), Matrix4d::Constant(4));
00339   VERIFY\_IS\_APPROX(r44.noalias()=ones44*RMatrix4d::Ones(), Matrix4d::Constant(4));
00340   VERIFY\_IS\_APPROX(r44.noalias()=ones44.transpose()*RMatrix4d::Ones(), Matrix4d::Constant(4));
00341   VERIFY\_IS\_APPROX(r44.noalias()=RMatrix4d::Ones()*ones44, Matrix4d::Constant(4));
00342   VERIFY\_IS\_APPROX(r44.noalias()=RMatrix4d::Ones()*ones44.transpose(), Matrix4d::Constant(4));
00343 
00344 \textcolor{comment}{//   RowVector4d r4;}
00345   m44.setOnes();
00346   r44.setZero();
00347   VERIFY\_IS\_APPROX(r44.noalias() += m44.row(0).transpose() * RowVector4d::Ones(), ones44);
00348   r44.setZero();
00349   VERIFY\_IS\_APPROX(r44.noalias() += m44.col(0) * RowVector4d::Ones(), ones44);
00350   r44.setZero();
00351   VERIFY\_IS\_APPROX(r44.noalias() += Vector4d::Ones() * m44.row(0), ones44);
00352   r44.setZero();
00353   VERIFY\_IS\_APPROX(r44.noalias() += Vector4d::Ones() * m44.col(0).transpose(), ones44);
00354 \}
00355 
00356 \textcolor{keywordtype}{void} test\_product\_extra()
00357 \{
00358   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00359     CALL\_SUBTEST\_1( product\_extra(MatrixXf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00360     CALL\_SUBTEST\_2( product\_extra(MatrixXd(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00361     CALL\_SUBTEST\_2( mat\_mat\_scalar\_scalar\_product() );
00362     CALL\_SUBTEST\_3( product\_extra(MatrixXcf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2))) );
00363     CALL\_SUBTEST\_4( product\_extra(MatrixXcd(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE/2))) );
00364     CALL\_SUBTEST\_1( zero\_sized\_objects(MatrixXf(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE))) );
00365   \}
00366   CALL\_SUBTEST\_5( bug\_127<0>() );
00367   CALL\_SUBTEST\_5( bug\_817<0>() );
00368   CALL\_SUBTEST\_5( bug\_1308<0>() );
00369   CALL\_SUBTEST\_6( unaligned\_objects<0>() );
00370   CALL\_SUBTEST\_7( compute\_block\_size<float>() );
00371   CALL\_SUBTEST\_7( compute\_block\_size<double>() );
00372   CALL\_SUBTEST\_7( compute\_block\_size<std::complex<double> >() );
00373   CALL\_SUBTEST\_8( aliasing\_with\_resize<void>() );
00374 
00375 \}
\end{DoxyCode}
