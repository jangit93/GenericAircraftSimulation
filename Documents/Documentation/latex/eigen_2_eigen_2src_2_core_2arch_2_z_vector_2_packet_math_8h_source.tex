\hypertarget{eigen_2_eigen_2src_2_core_2arch_2_z_vector_2_packet_math_8h_source}{}\section{eigen/\+Eigen/src/\+Core/arch/\+Z\+Vector/\+Packet\+Math.h}
\label{eigen_2_eigen_2src_2_core_2arch_2_z_vector_2_packet_math_8h_source}\index{Packet\+Math.\+h@{Packet\+Math.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2016 Konstantinos Margaritis <markos@freevec.org>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_PACKET\_MATH\_ZVECTOR\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_PACKET\_MATH\_ZVECTOR\_H}
00012 
00013 \textcolor{preprocessor}{#include <stdint.h>}
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00016 
00017 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00018 
00019 \textcolor{preprocessor}{#ifndef EIGEN\_CACHEFRIENDLY\_PRODUCT\_THRESHOLD}
00020 \textcolor{preprocessor}{#define EIGEN\_CACHEFRIENDLY\_PRODUCT\_THRESHOLD 4}
00021 \textcolor{preprocessor}{#endif}
00022 
00023 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD}
00024 \textcolor{preprocessor}{#define EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD}
00025 \textcolor{preprocessor}{#endif}
00026 
00027 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_SINGLE\_INSTRUCTION\_CJMADD}
00028 \textcolor{preprocessor}{#define EIGEN\_HAS\_SINGLE\_INSTRUCTION\_CJMADD}
00029 \textcolor{preprocessor}{#endif}
00030 
00031 \textcolor{preprocessor}{#ifndef EIGEN\_ARCH\_DEFAULT\_NUMBER\_OF\_REGISTERS}
00032 \textcolor{preprocessor}{#define EIGEN\_ARCH\_DEFAULT\_NUMBER\_OF\_REGISTERS  16}
00033 \textcolor{preprocessor}{#endif}
00034 
00035 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{int}                 Packet4i;
00036 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}        Packet4ui;
00037 \textcolor{keyword}{typedef} \_\_vector \_\_bool \textcolor{keywordtype}{int}          Packet4bi;
00038 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{short} \textcolor{keywordtype}{int}           Packet8i;
00039 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}       Packet16uc;
00040 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{double}              Packet2d;
00041 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}  Packet2ul;
00042 \textcolor{keyword}{typedef} \_\_vector \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}           Packet2l;
00043 
\Hypertarget{eigen_2_eigen_2src_2_core_2arch_2_z_vector_2_packet_math_8h_source_l00044}\hyperlink{struct_eigen_1_1internal_1_1_packet4f}{00044} \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
00045     Packet2d  v4f[2];
00046 \} \hyperlink{struct_eigen_1_1internal_1_1_packet4f}{Packet4f};
00047 
\Hypertarget{eigen_2_eigen_2src_2_core_2arch_2_z_vector_2_packet_math_8h_source_l00048}\hyperlink{union_eigen_1_1internal_1_1_packet}{00048} \textcolor{keyword}{typedef} \textcolor{keyword}{union }\{
00049   int32\_t   i[4];
00050   uint32\_t ui[4];
00051   int64\_t   l[2];
00052   uint64\_t ul[2];
00053   \textcolor{keywordtype}{double}    d[2];
00054   Packet4i  v4i;
00055   Packet4ui v4ui;
00056   Packet2l  v2l;
00057   Packet2ul v2ul;
00058   Packet2d  v2d;
00059 \} \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet};
00060 
00061 \textcolor{comment}{// We don't want to write the same code all the time, but we need to reuse the constants}
00062 \textcolor{comment}{// and it doesn't really work to declare them global, so we define macros instead}
00063 
00064 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_FAST\_Packet4i(NAME,X) \(\backslash\)}
00065 \textcolor{preprocessor}{  Packet4i p4i\_##NAME = reinterpret\_cast<Packet4i>(vec\_splat\_s32(X))}
00066 
00067 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_FAST\_Packet2d(NAME,X) \(\backslash\)}
00068 \textcolor{preprocessor}{  Packet2d p2d\_##NAME = reinterpret\_cast<Packet2d>(vec\_splat\_s64(X))}
00069 
00070 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_FAST\_Packet2l(NAME,X) \(\backslash\)}
00071 \textcolor{preprocessor}{  Packet2l p2l\_##NAME = reinterpret\_cast<Packet2l>(vec\_splat\_s64(X))}
00072 
00073 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet4i(NAME,X) \(\backslash\)}
00074 \textcolor{preprocessor}{  Packet4i p4i\_##NAME = pset1<Packet4i>(X)}
00075 
00076 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet2d(NAME,X) \(\backslash\)}
00077 \textcolor{preprocessor}{  Packet2d p2d\_##NAME = pset1<Packet2d>(X)}
00078 
00079 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet2l(NAME,X) \(\backslash\)}
00080 \textcolor{preprocessor}{  Packet2l p2l\_##NAME = pset1<Packet2l>(X)}
00081 
00082 \textcolor{comment}{// These constants are endian-agnostic}
00083 \textcolor{comment}{//static \_EIGEN\_DECLARE\_CONST\_FAST\_Packet4i(ZERO, 0); //\{ 0, 0, 0, 0,\}}
00084 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_FAST\_Packet4i(ONE, 1); \textcolor{comment}{//\{ 1, 1, 1, 1\}}
00085 
00086 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_FAST\_Packet2d(ZERO, 0);
00087 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_FAST\_Packet2l(ZERO, 0);
00088 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_FAST\_Packet2l(ONE, 1);
00089 
00090 \textcolor{keyword}{static} Packet2d p2d\_ONE = \{ 1.0, 1.0 \}; 
00091 \textcolor{keyword}{static} Packet2d p2d\_ZERO\_ = \{ -0.0, -0.0 \};
00092 
00093 \textcolor{keyword}{static} Packet4i p4i\_COUNTDOWN = \{ 0, 1, 2, 3 \};
00094 \textcolor{keyword}{static} \hyperlink{struct_eigen_1_1internal_1_1_packet4f}{Packet4f} p4f\_COUNTDOWN = \{ 0.0, 1.0, 2.0, 3.0 \};
00095 \textcolor{keyword}{static} Packet2d p2d\_COUNTDOWN = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet16uc>(p2d\_ZERO), 
      reinterpret\_cast<Packet16uc>(p2d\_ONE), 8));
00096 
00097 \textcolor{keyword}{static} Packet16uc p16uc\_PSET64\_HI = \{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 \};
00098 \textcolor{keyword}{static} Packet16uc p16uc\_DUPLICATE32\_HI = \{ 0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7 \};
00099 
00100 \textcolor{comment}{// Mask alignment}
00101 \textcolor{preprocessor}{#define \_EIGEN\_MASK\_ALIGNMENT   0xfffffffffffffff0}
00102 
00103 \textcolor{preprocessor}{#define \_EIGEN\_ALIGNED\_PTR(x)   ((std::ptrdiff\_t)(x) & \_EIGEN\_MASK\_ALIGNMENT)}
00104 
00105 \textcolor{comment}{// Handle endianness properly while loading constants}
00106 \textcolor{comment}{// Define global static constants:}
00107 
00108 \textcolor{keyword}{static} Packet16uc p16uc\_FORWARD =   \{ 0,1,2,3, 4,5,6,7, 8,9,10,11, 12,13,14,15 \};
00109 \textcolor{keyword}{static} Packet16uc p16uc\_REVERSE32 = \{ 12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3 \};
00110 \textcolor{keyword}{static} Packet16uc p16uc\_REVERSE64 = \{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 \};
00111 
00112 \textcolor{keyword}{static} Packet16uc p16uc\_PSET32\_WODD   = vec\_sld((Packet16uc) vec\_splat((Packet4ui)p16uc\_FORWARD, 0), (
      Packet16uc) vec\_splat((Packet4ui)p16uc\_FORWARD, 2), 8);\textcolor{comment}{//\{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 \};}
00113 \textcolor{keyword}{static} Packet16uc p16uc\_PSET32\_WEVEN  = vec\_sld(p16uc\_DUPLICATE32\_HI, (Packet16uc) vec\_splat((Packet4ui)
      p16uc\_FORWARD, 3), 8);\textcolor{comment}{//\{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 \};}
00114 \textcolor{comment}{/*static Packet16uc p16uc\_HALF64\_0\_16 = vec\_sld((Packet16uc)p4i\_ZERO, vec\_splat((Packet16uc)
       vec\_abs(p4i\_MINUS16), 3), 8);      //\{ 0,0,0,0, 0,0,0,0, 16,16,16,16, 16,16,16,16\};}
00115 \textcolor{comment}{}
00116 \textcolor{comment}{static Packet16uc p16uc\_PSET64\_HI = (Packet16uc) vec\_mergeh((Packet4ui)p16uc\_PSET32\_WODD,
       (Packet4ui)p16uc\_PSET32\_WEVEN);     //\{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 \};*/}
00117 \textcolor{keyword}{static} Packet16uc p16uc\_PSET64\_LO = (Packet16uc) vec\_mergel((Packet4ui)p16uc\_PSET32\_WODD, (Packet4ui)
      p16uc\_PSET32\_WEVEN);     \textcolor{comment}{//\{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 \};}
00118 \textcolor{comment}{/*static Packet16uc p16uc\_TRANSPOSE64\_HI = vec\_add(p16uc\_PSET64\_HI, p16uc\_HALF64\_0\_16);                    
                           //\{ 0,1,2,3, 4,5,6,7, 16,17,18,19, 20,21,22,23\};}
00119 \textcolor{comment}{static Packet16uc p16uc\_TRANSPOSE64\_LO = vec\_add(p16uc\_PSET64\_LO, p16uc\_HALF64\_0\_16);                      
                         //\{ 8,9,10,11, 12,13,14,15, 24,25,26,27, 28,29,30,31\};*/}
00120 \textcolor{keyword}{static} Packet16uc p16uc\_TRANSPOSE64\_HI = \{ 0,1,2,3, 4,5,6,7, 16,17,18,19, 20,21,22,23\};
00121 \textcolor{keyword}{static} Packet16uc p16uc\_TRANSPOSE64\_LO = \{ 8,9,10,11, 12,13,14,15, 24,25,26,27, 28,29,30,31\};
00122 
00123 \textcolor{comment}{//static Packet16uc p16uc\_COMPLEX32\_REV = vec\_sld(p16uc\_REVERSE32, p16uc\_REVERSE32, 8);                    
                           //\{ 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11 \};}
00124 
00125 \textcolor{comment}{//static Packet16uc p16uc\_COMPLEX32\_REV2 = vec\_sld(p16uc\_FORWARD, p16uc\_FORWARD, 8);                       
                           //\{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 \};}
00126 
00127 
00128 \textcolor{preprocessor}{#if EIGEN\_HAS\_BUILTIN(\_\_builtin\_prefetch) || EIGEN\_COMP\_GNUC}
00129 \textcolor{preprocessor}{  #define EIGEN\_ZVECTOR\_PREFETCH(ADDR) \_\_builtin\_prefetch(ADDR);}
00130 \textcolor{preprocessor}{#else}
00131 \textcolor{preprocessor}{  #define EIGEN\_ZVECTOR\_PREFETCH(ADDR) asm( "   pfd [%[addr]]\(\backslash\)n" :: [addr] "r" (ADDR) : "cc" );}
00132 \textcolor{preprocessor}{#endif}
00133 
00134 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits}<int>    : \hyperlink{struct_eigen_1_1internal_1_1default__packet__traits}{default\_packet\_traits}
00135 \{
00136   \textcolor{keyword}{typedef} Packet4i type;
00137   \textcolor{keyword}{typedef} Packet4i \hyperlink{struct_eigen_1_1half}{half};
00138   \textcolor{keyword}{enum} \{
00139     Vectorizable = 1,
00140     AlignedOnScalar = 1,
00141     size = 4,
00142     HasHalfPacket = 0,
00143 
00144     HasAdd  = 1,
00145     HasSub  = 1,
00146     HasMul  = 1,
00147     HasDiv  = 1,
00148     HasBlend = 1
00149   \};
00150 \};
00151 
00152 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits}<float> : \hyperlink{struct_eigen_1_1internal_1_1default__packet__traits}{default\_packet\_traits}
00153 \{
00154   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1_packet4f}{Packet4f} type;
00155   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1_packet4f}{Packet4f} \hyperlink{struct_eigen_1_1half}{half};
00156   \textcolor{keyword}{enum} \{
00157     Vectorizable = 1,
00158     AlignedOnScalar = 1,
00159     size=4,
00160     HasHalfPacket = 0,
00161 
00162     HasAdd  = 1,
00163     HasSub  = 1,
00164     HasMul  = 1,
00165     HasDiv  = 1,
00166     HasMin  = 1,
00167     HasMax  = 1,
00168     HasAbs  = 1,
00169     HasSin  = 0,
00170     HasCos  = 0,
00171     HasLog  = 0,
00172     HasExp  = 1,
00173     HasSqrt = 1,
00174     HasRsqrt = 1,
00175     HasRound = 1,
00176     HasFloor = 1,
00177     HasCeil = 1,
00178     HasNegate = 1,
00179     HasBlend = 1
00180   \};
00181 \};
00182 
00183 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits}<double> : \hyperlink{struct_eigen_1_1internal_1_1default__packet__traits}{default\_packet\_traits}
00184 \{
00185   \textcolor{keyword}{typedef} Packet2d type;
00186   \textcolor{keyword}{typedef} Packet2d \hyperlink{struct_eigen_1_1half}{half};
00187   \textcolor{keyword}{enum} \{
00188     Vectorizable = 1,
00189     AlignedOnScalar = 1,
00190     size=2,
00191     HasHalfPacket = 1,
00192 
00193     HasAdd  = 1,
00194     HasSub  = 1,
00195     HasMul  = 1,
00196     HasDiv  = 1,
00197     HasMin  = 1,
00198     HasMax  = 1,
00199     HasAbs  = 1,
00200     HasSin  = 0,
00201     HasCos  = 0,
00202     HasLog  = 0,
00203     HasExp  = 1,
00204     HasSqrt = 1,
00205     HasRsqrt = 1,
00206     HasRound = 1,
00207     HasFloor = 1,
00208     HasCeil = 1,
00209     HasNegate = 1,
00210     HasBlend = 1
00211   \};
00212 \};
00213 
00214 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{unpacket\_traits}<Packet4i> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{int}    type; \textcolor{keyword}{enum} \{size=4, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet4i \hyperlink{struct_eigen_1_1half}{half}; \};
00215 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{unpacket\_traits}<Packet4f> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{float}  type; \textcolor{keyword}{enum} \{size=4, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet4f \hyperlink{struct_eigen_1_1half}{half}; \};
00216 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{unpacket\_traits}<Packet2d> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{double} type; \textcolor{keyword}{enum} \{size=2, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet2d \hyperlink{struct_eigen_1_1half}{half}; \};
00217 
00218 \textcolor{comment}{/* Forward declaration */}
00219 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} ptranspose(\hyperlink{struct_eigen_1_1internal_1_1_packet_block}{PacketBlock<Packet4f,4>}& kernel);
00220  
00221 \textcolor{keyword}{inline} std::ostream & operator <<(std::ostream & s, \textcolor{keyword}{const} Packet4i & v)
00222 \{
00223   \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} vt;
00224   vt.v4i = v;
00225   s << vt.i[0] << \textcolor{stringliteral}{", "} << vt.i[1] << \textcolor{stringliteral}{", "} << vt.i[2] << \textcolor{stringliteral}{", "} << vt.i[3];
00226   \textcolor{keywordflow}{return} s;
00227 \}
00228 
00229 \textcolor{keyword}{inline} std::ostream & operator <<(std::ostream & s, \textcolor{keyword}{const} Packet4ui & v)
00230 \{
00231   \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} vt;
00232   vt.v4ui = v;
00233   s << vt.ui[0] << \textcolor{stringliteral}{", "} << vt.ui[1] << \textcolor{stringliteral}{", "} << vt.ui[2] << \textcolor{stringliteral}{", "} << vt.ui[3];
00234   \textcolor{keywordflow}{return} s;
00235 \}
00236 
00237 \textcolor{keyword}{inline} std::ostream & operator <<(std::ostream & s, \textcolor{keyword}{const} Packet2l & v)
00238 \{
00239   \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} vt;
00240   vt.v2l = v;
00241   s << vt.l[0] << \textcolor{stringliteral}{", "} << vt.l[1];
00242   \textcolor{keywordflow}{return} s;
00243 \}
00244 
00245 \textcolor{keyword}{inline} std::ostream & operator <<(std::ostream & s, \textcolor{keyword}{const} Packet2ul & v)
00246 \{
00247   \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} vt;
00248   vt.v2ul = v;
00249   s << vt.ul[0] << \textcolor{stringliteral}{", "} << vt.ul[1] ;
00250   \textcolor{keywordflow}{return} s;
00251 \}
00252 
00253 \textcolor{keyword}{inline} std::ostream & operator <<(std::ostream & s, \textcolor{keyword}{const} Packet2d & v)
00254 \{
00255   \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} vt;
00256   vt.v2d = v;
00257   s << vt.d[0] << \textcolor{stringliteral}{", "} << vt.d[1];
00258   \textcolor{keywordflow}{return} s;
00259 \}
00260 
00261 \textcolor{comment}{/* Helper function to simulate a vec\_splat\_packet4f}
00262 \textcolor{comment}{ */}
00263 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} element> EIGEN\_STRONG\_INLINE Packet4f vec\_splat\_packet4f(\textcolor{keyword}{const} Packet4f&   from)
00264 \{
00265   Packet4f splat;
00266   \textcolor{keywordflow}{switch} (element) \{
00267   \textcolor{keywordflow}{case} 0:
00268     splat.v4f[0] = vec\_splat(from.v4f[0], 0);
00269     splat.v4f[1] = splat.v4f[0];
00270     \textcolor{keywordflow}{break};
00271   \textcolor{keywordflow}{case} 1:
00272     splat.v4f[0] = vec\_splat(from.v4f[0], 1);
00273     splat.v4f[1] = splat.v4f[0];
00274     \textcolor{keywordflow}{break};
00275   \textcolor{keywordflow}{case} 2:
00276     splat.v4f[0] = vec\_splat(from.v4f[1], 0);
00277     splat.v4f[1] = splat.v4f[0];
00278     \textcolor{keywordflow}{break};
00279   \textcolor{keywordflow}{case} 3:
00280     splat.v4f[0] = vec\_splat(from.v4f[1], 1);
00281     splat.v4f[1] = splat.v4f[0];
00282     \textcolor{keywordflow}{break};
00283   \}
00284   \textcolor{keywordflow}{return} splat;
00285 \}
00286 
00287 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00288 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1palign__impl}{palign\_impl}<Offset,Packet4i>
00289 \{
00290   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet4i& first, \textcolor{keyword}{const} Packet4i& second)
00291   \{
00292     \textcolor{keywordflow}{switch} (Offset % 4) \{
00293     \textcolor{keywordflow}{case} 1:
00294       first = vec\_sld(first, second, 4); \textcolor{keywordflow}{break};
00295     \textcolor{keywordflow}{case} 2:
00296       first = vec\_sld(first, second, 8); \textcolor{keywordflow}{break};
00297     \textcolor{keywordflow}{case} 3:
00298       first = vec\_sld(first, second, 12); \textcolor{keywordflow}{break};
00299     \}
00300   \}
00301 \};
00302 
00303 \textcolor{comment}{/* This is a tricky one, we have to translate float alignment to vector elements of sizeof double}
00304 \textcolor{comment}{ */}
00305 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00306 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1palign__impl}{palign\_impl}<Offset,Packet4f>
00307 \{
00308   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet4f& first, \textcolor{keyword}{const} Packet4f& second)
00309   \{
00310     \textcolor{keywordflow}{switch} (Offset % 4) \{
00311     \textcolor{keywordflow}{case} 1:
00312       first.v4f[0] = vec\_sld(first.v4f[0], first.v4f[1], 8);
00313       first.v4f[1] = vec\_sld(first.v4f[1], second.v4f[0], 8);
00314       \textcolor{keywordflow}{break};
00315     \textcolor{keywordflow}{case} 2:
00316       first.v4f[0] = first.v4f[1];
00317       first.v4f[1] = second.v4f[0];
00318       \textcolor{keywordflow}{break};
00319     \textcolor{keywordflow}{case} 3:
00320       first.v4f[0] = vec\_sld(first.v4f[1],  second.v4f[0], 8);
00321       first.v4f[1] = vec\_sld(second.v4f[0], second.v4f[1], 8);
00322       \textcolor{keywordflow}{break};
00323     \}
00324   \}
00325 \};
00326 
00327 
00328 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00329 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1palign__impl}{palign\_impl}<Offset,Packet2d>
00330 \{
00331   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet2d& first, \textcolor{keyword}{const} Packet2d& second)
00332   \{
00333     \textcolor{keywordflow}{if} (Offset == 1)
00334       first = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4i>(first), 
      reinterpret\_cast<Packet4i>(second), 8));
00335   \}
00336 \};
00337 
00338 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pload<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*     from)
00339 \{
00340   \textcolor{comment}{// FIXME: No intrinsic yet}
00341   EIGEN\_DEBUG\_ALIGNED\_LOAD
00342   \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} *vfrom;
00343   vfrom = (\hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} *) from;
00344   \textcolor{keywordflow}{return} vfrom->v4i;
00345 \}
00346 
00347 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pload<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}*   from)
00348 \{
00349   \textcolor{comment}{// FIXME: No intrinsic yet}
00350   EIGEN\_DEBUG\_ALIGNED\_LOAD
00351   Packet4f vfrom;
00352   vfrom.v4f[0] = vec\_ld2f(&from[0]);
00353   vfrom.v4f[1] = vec\_ld2f(&from[2]);
00354   \textcolor{keywordflow}{return} vfrom;
00355 \}
00356 
00357 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pload<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* from)
00358 \{
00359   \textcolor{comment}{// FIXME: No intrinsic yet}
00360   EIGEN\_DEBUG\_ALIGNED\_LOAD
00361   \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} *vfrom;
00362   vfrom = (\hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} *) from;
00363   \textcolor{keywordflow}{return} vfrom->v2d;
00364 \}
00365 
00366 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<int>(\textcolor{keywordtype}{int}*       to, \textcolor{keyword}{const} Packet4i& from)
00367 \{
00368   \textcolor{comment}{// FIXME: No intrinsic yet}
00369   EIGEN\_DEBUG\_ALIGNED\_STORE
00370   \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} *vto;
00371   vto = (\hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} *) to;
00372   vto->v4i = from;
00373 \}
00374 
00375 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<float>(\textcolor{keywordtype}{float}*   to, \textcolor{keyword}{const} Packet4f& from)
00376 \{
00377   \textcolor{comment}{// FIXME: No intrinsic yet}
00378   EIGEN\_DEBUG\_ALIGNED\_STORE
00379   vec\_st2f(from.v4f[0], &to[0]);
00380   vec\_st2f(from.v4f[1], &to[2]);
00381 \}
00382 
00383 
00384 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<double>(\textcolor{keywordtype}{double}*   to, \textcolor{keyword}{const} Packet2d& from)
00385 \{
00386   \textcolor{comment}{// FIXME: No intrinsic yet}
00387   EIGEN\_DEBUG\_ALIGNED\_STORE
00388   \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} *vto;
00389   vto = (\hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} *) to;
00390   vto->v2d = from;
00391 \}
00392 
00393 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pset1<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}&    from)
00394 \{
00395   \textcolor{keywordflow}{return} vec\_splats(from);
00396 \}
00397 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pset1<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& from) \{
00398   \textcolor{keywordflow}{return} vec\_splats(from);
00399 \}
00400 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pset1<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}&    from)
00401 \{
00402   Packet4f to;
00403   to.v4f[0] = pset1<Packet2d>(\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{double}&\textcolor{keyword}{>}(from));
00404   to.v4f[1] = to.v4f[0];
00405   \textcolor{keywordflow}{return} to;
00406 \}
00407 
00408 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00409 pbroadcast4<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int} *a,
00410                       Packet4i& a0, Packet4i& a1, Packet4i& a2, Packet4i& a3)
00411 \{
00412   a3 = pload<Packet4i>(a);
00413   a0 = vec\_splat(a3, 0);
00414   a1 = vec\_splat(a3, 1);
00415   a2 = vec\_splat(a3, 2);
00416   a3 = vec\_splat(a3, 3);
00417 \}
00418 
00419 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00420 pbroadcast4<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float} *a,
00421                       Packet4f& a0, Packet4f& a1, Packet4f& a2, Packet4f& a3)
00422 \{
00423   a3 = pload<Packet4f>(a);
00424   a0 = vec\_splat\_packet4f<0>(a3);
00425   a1 = vec\_splat\_packet4f<1>(a3);
00426   a2 = vec\_splat\_packet4f<2>(a3);
00427   a3 = vec\_splat\_packet4f<3>(a3);
00428 \}
00429 
00430 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00431 pbroadcast4<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double} *a,
00432                       Packet2d& a0, Packet2d& a1, Packet2d& a2, Packet2d& a3)
00433 \{
00434   a1 = pload<Packet2d>(a);
00435   a0 = vec\_splat(a1, 0);
00436   a1 = vec\_splat(a1, 1);
00437   a3 = pload<Packet2d>(a+2);
00438   a2 = vec\_splat(a3, 0);
00439   a3 = vec\_splat(a3, 1);
00440 \}
00441 
00442 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet4i pgather<int, Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}* from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00443 \{
00444   \textcolor{keywordtype}{int} EIGEN\_ALIGN16 ai[4];
00445   ai[0] = from[0*stride];
00446   ai[1] = from[1*stride];
00447   ai[2] = from[2*stride];
00448   ai[3] = from[3*stride];
00449  \textcolor{keywordflow}{return} pload<Packet4i>(ai);
00450 \}
00451 
00452 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet4f pgather<float, Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}* from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00453 \{
00454   \textcolor{keywordtype}{float} EIGEN\_ALIGN16 ai[4];
00455   ai[0] = from[0*stride];
00456   ai[1] = from[1*stride];
00457   ai[2] = from[2*stride];
00458   ai[3] = from[3*stride];
00459  \textcolor{keywordflow}{return} pload<Packet4f>(ai);
00460 \}
00461 
00462 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet2d pgather<double, Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00463 \{
00464   \textcolor{keywordtype}{double} EIGEN\_ALIGN16 af[2];
00465   af[0] = from[0*stride];
00466   af[1] = from[1*stride];
00467  \textcolor{keywordflow}{return} pload<Packet2d>(af);
00468 \}
00469 
00470 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<int, Packet4i>(\textcolor{keywordtype}{int}* to, \textcolor{keyword}{const} Packet4i& from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00471 \{
00472   \textcolor{keywordtype}{int} EIGEN\_ALIGN16 ai[4];
00473   pstore<int>((\textcolor{keywordtype}{int} *)ai, from);
00474   to[0*stride] = ai[0];
00475   to[1*stride] = ai[1];
00476   to[2*stride] = ai[2];
00477   to[3*stride] = ai[3];
00478 \}
00479 
00480 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<float, Packet4f>(\textcolor{keywordtype}{float}* to, \textcolor{keyword}{const} Packet4f& from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00481 \{
00482   \textcolor{keywordtype}{float} EIGEN\_ALIGN16 ai[4];
00483   pstore<float>((\textcolor{keywordtype}{float} *)ai, from);
00484   to[0*stride] = ai[0];
00485   to[1*stride] = ai[1];
00486   to[2*stride] = ai[2];
00487   to[3*stride] = ai[3];
00488 \}
00489 
00490 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<double, Packet2d>(\textcolor{keywordtype}{double}* to, \textcolor{keyword}{const} Packet2d& from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00491 \{
00492   \textcolor{keywordtype}{double} EIGEN\_ALIGN16 af[2];
00493   pstore<double>(af, from);
00494   to[0*stride] = af[0];
00495   to[1*stride] = af[1];
00496 \}
00497 
00498 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i padd<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} (a + 
      b); \}
00499 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f padd<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b)
00500 \{
00501   Packet4f c;
00502   c.v4f[0] = a.v4f[0] + b.v4f[0];
00503   c.v4f[1] = a.v4f[1] + b.v4f[1];
00504   \textcolor{keywordflow}{return} c;
00505 \}
00506 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d padd<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} (a + 
      b); \}
00507 
00508 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i psub<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} (a - 
      b); \}
00509 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f psub<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b)
00510 \{
00511   Packet4f c;
00512   c.v4f[0] = a.v4f[0] - b.v4f[0];
00513   c.v4f[1] = a.v4f[1] - b.v4f[1];
00514   \textcolor{keywordflow}{return} c;
00515 \}
00516 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d psub<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} (a - 
      b); \}
00517 
00518 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pmul<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} (a * 
      b); \}
00519 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pmul<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b)
00520 \{
00521   Packet4f c;
00522   c.v4f[0] = a.v4f[0] * b.v4f[0];
00523   c.v4f[1] = a.v4f[1] * b.v4f[1];
00524   \textcolor{keywordflow}{return} c;
00525 \}
00526 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pmul<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} (a * 
      b); \}
00527 
00528 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pdiv<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} (a / 
      b); \}
00529 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pdiv<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b)
00530 \{
00531   Packet4f c;
00532   c.v4f[0] = a.v4f[0] / b.v4f[0];
00533   c.v4f[1] = a.v4f[1] / b.v4f[1];
00534   \textcolor{keywordflow}{return} c;
00535 \}
00536 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pdiv<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} (a / 
      b); \}
00537 
00538 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pnegate(\textcolor{keyword}{const} Packet4i& a) \{ \textcolor{keywordflow}{return} (-a); \}
00539 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pnegate(\textcolor{keyword}{const} Packet4f& a)
00540 \{
00541   Packet4f c;
00542   c.v4f[0] = -a.v4f[0];
00543   c.v4f[1] = -a.v4f[1];
00544   \textcolor{keywordflow}{return} c;
00545 \}
00546 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pnegate(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} (-a); \}
00547 
00548 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pconj(\textcolor{keyword}{const} Packet4i& a) \{ \textcolor{keywordflow}{return} a; \}
00549 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pconj(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordflow}{return} a; \}
00550 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pconj(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} a; \}
00551 
00552 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pmadd(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b, \textcolor{keyword}{const} Packet4i& c) \{ \textcolor{keywordflow}{
      return} padd<Packet4i>(pmul<Packet4i>(a, b), c); \}
00553 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pmadd(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b, \textcolor{keyword}{const} Packet4f& c)
00554 \{
00555   Packet4f res;
00556   res.v4f[0] = vec\_madd(a.v4f[0], b.v4f[0], c.v4f[0]);
00557   res.v4f[1] = vec\_madd(a.v4f[1], b.v4f[1], c.v4f[1]);
00558   \textcolor{keywordflow}{return} res;
00559 \}
00560 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pmadd(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b, \textcolor{keyword}{const} Packet2d& c) \{ \textcolor{keywordflow}{
      return} vec\_madd(a, b, c); \}
00561 
00562 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i plset<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}& a)    \{ \textcolor{keywordflow}{return} padd<Packet4i>(
      pset1<Packet4i>(a), p4i\_COUNTDOWN); \}
00563 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f plset<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}& a)  \{ \textcolor{keywordflow}{return} padd<Packet4f>(
      pset1<Packet4f>(a), p4f\_COUNTDOWN); \}
00564 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d plset<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& a) \{ \textcolor{keywordflow}{return} padd<Packet2d>(
      pset1<Packet2d>(a), p2d\_COUNTDOWN); \}
00565 
00566 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pmin<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      vec\_min(a, b); \}
00567 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pmin<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      vec\_min(a, b); \}
00568 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pmin<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b)
00569 \{
00570   Packet4f res;
00571   res.v4f[0] = pmin(a.v4f[0], b.v4f[0]);
00572   res.v4f[1] = pmin(a.v4f[1], b.v4f[1]);
00573   \textcolor{keywordflow}{return} res;
00574 \}
00575 
00576 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pmax<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      vec\_max(a, b); \}
00577 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pmax<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      vec\_max(a, b); \}
00578 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pmax<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b)
00579 \{
00580   Packet4f res;
00581   res.v4f[0] = pmax(a.v4f[0], b.v4f[0]);
00582   res.v4f[1] = pmax(a.v4f[1], b.v4f[1]);
00583   \textcolor{keywordflow}{return} res;
00584 \}
00585 
00586 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pand<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      vec\_and(a, b); \}
00587 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pand<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      vec\_and(a, b); \}
00588 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pand<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b)
00589 \{
00590   Packet4f res;
00591   res.v4f[0] = pand(a.v4f[0], b.v4f[0]);
00592   res.v4f[1] = pand(a.v4f[1], b.v4f[1]);
00593   \textcolor{keywordflow}{return} res;
00594 \}
00595 
00596 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i por<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} vec\_or
      (a, b); \}
00597 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d por<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} vec\_or
      (a, b); \}
00598 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f por<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b)
00599 \{
00600   Packet4f res;
00601   res.v4f[0] = pand(a.v4f[0], b.v4f[0]);
00602   res.v4f[1] = pand(a.v4f[1], b.v4f[1]);
00603   \textcolor{keywordflow}{return} res;
00604 \}
00605 
00606 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pxor<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      vec\_xor(a, b); \}
00607 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pxor<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      vec\_xor(a, b); \}
00608 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pxor<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b)
00609 \{
00610   Packet4f res;
00611   res.v4f[0] = pand(a.v4f[0], b.v4f[0]);
00612   res.v4f[1] = pand(a.v4f[1], b.v4f[1]);
00613   \textcolor{keywordflow}{return} res;
00614 \}
00615 
00616 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pandnot<Packet4i>(\textcolor{keyword}{const} Packet4i& a, \textcolor{keyword}{const} Packet4i& b) \{ \textcolor{keywordflow}{return} 
      pand<Packet4i>(a, vec\_nor(b, b)); \}
00617 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pandnot<Packet2d>(\textcolor{keyword}{const} Packet2d& a, \textcolor{keyword}{const} Packet2d& b) \{ \textcolor{keywordflow}{return} 
      vec\_and(a, vec\_nor(b, b)); \}
00618 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pandnot<Packet4f>(\textcolor{keyword}{const} Packet4f& a, \textcolor{keyword}{const} Packet4f& b)
00619 \{
00620   Packet4f res;
00621   res.v4f[0] = pandnot(a.v4f[0], b.v4f[0]);
00622   res.v4f[1] = pandnot(a.v4f[1], b.v4f[1]);
00623   \textcolor{keywordflow}{return} res;
00624 \}
00625 
00626 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pround<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00627 \{
00628   Packet4f res;
00629   res.v4f[0] = vec\_round(a.v4f[0]);
00630   res.v4f[1] = vec\_round(a.v4f[1]);
00631   \textcolor{keywordflow}{return} res;
00632 \}
00633 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pround<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} vec\_round(a); \}
00634 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pceil<Packet4f>(\textcolor{keyword}{const}  Packet4f& a)
00635 \{
00636   Packet4f res;
00637   res.v4f[0] = vec\_ceil(a.v4f[0]);
00638   res.v4f[1] = vec\_ceil(a.v4f[1]);
00639   \textcolor{keywordflow}{return} res;
00640 \}
00641 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pceil<Packet2d>(\textcolor{keyword}{const}  Packet2d& a) \{ \textcolor{keywordflow}{return} vec\_ceil(a); \}
00642 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pfloor<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00643 \{
00644   Packet4f res;
00645   res.v4f[0] = vec\_floor(a.v4f[0]);
00646   res.v4f[1] = vec\_floor(a.v4f[1]);
00647   \textcolor{keywordflow}{return} res;
00648 \}
00649 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pfloor<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} vec\_floor(a); \}
00650 
00651 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i ploadu<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*       from) \{ \textcolor{keywordflow}{return} pload<Packet4i>(
      from); \}
00652 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f ploadu<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}*     from) \{ \textcolor{keywordflow}{return} pload<Packet4f>(
      from); \}
00653 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d ploadu<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}*    from) \{ \textcolor{keywordflow}{return} pload<Packet2d>(
      from); \}
00654 
00655 
00656 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i ploaddup<Packet4i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*     from)
00657 \{
00658   Packet4i p = pload<Packet4i>(from);
00659   \textcolor{keywordflow}{return} vec\_perm(p, p, p16uc\_DUPLICATE32\_HI);
00660 \}
00661 
00662 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f ploaddup<Packet4f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}*    from)
00663 \{
00664   Packet4f p = pload<Packet4f>(from);
00665   p.v4f[1] = vec\_splat(p.v4f[0], 1);
00666   p.v4f[0] = vec\_splat(p.v4f[0], 0);
00667   \textcolor{keywordflow}{return} p;
00668 \}
00669 
00670 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d ploaddup<Packet2d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}*   from)
00671 \{
00672   Packet2d p = pload<Packet2d>(from);
00673   \textcolor{keywordflow}{return} vec\_perm(p, p, p16uc\_PSET64\_HI);
00674 \}
00675 
00676 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<int>(\textcolor{keywordtype}{int}*        to, \textcolor{keyword}{const} Packet4i& from) \{ pstore<int>(to, 
      from); \}
00677 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<float>(\textcolor{keywordtype}{float}*    to, \textcolor{keyword}{const} Packet4f& from) \{ pstore<float>(to, 
      from); \}
00678 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<double>(\textcolor{keywordtype}{double}*  to, \textcolor{keyword}{const} Packet2d& from) \{ pstore<double>(to,
       from); \}
00679 
00680 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<int>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*       addr) \{ EIGEN\_ZVECTOR\_PREFETCH(addr); \}
00681 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<float>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}*   addr) \{ EIGEN\_ZVECTOR\_PREFETCH(addr); \}
00682 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<double>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* addr) \{ EIGEN\_ZVECTOR\_PREFETCH(addr); \}
00683 
00684 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int}    pfirst<Packet4i>(\textcolor{keyword}{const} Packet4i& a) \{ \textcolor{keywordtype}{int}    EIGEN\_ALIGN16 x[4]; 
      pstore(x, a); \textcolor{keywordflow}{return} x[0]; \}
00685 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float}  pfirst<Packet4f>(\textcolor{keyword}{const} Packet4f& a) \{ \textcolor{keywordtype}{float}  EIGEN\_ALIGN16 x[2]; 
      vec\_st2f(a.v4f[0], &x[0]); \textcolor{keywordflow}{return} x[0]; \}
00686 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} pfirst<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordtype}{double} EIGEN\_ALIGN16 x[2]; 
      pstore(x, a); \textcolor{keywordflow}{return} x[0]; \}
00687 
00688 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i preverse(\textcolor{keyword}{const} Packet4i& a)
00689 \{
00690   \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}Packet4i\textcolor{keyword}{>}(vec\_perm(reinterpret\_cast<Packet16uc>(a), reinterpret\_cast<Packet16uc>(
      a), p16uc\_REVERSE32));
00691 \}
00692 
00693 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d preverse(\textcolor{keyword}{const} Packet2d& a)
00694 \{
00695   \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_perm(reinterpret\_cast<Packet16uc>(a), reinterpret\_cast<Packet16uc>(
      a), p16uc\_REVERSE64));
00696 \}
00697 
00698 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f preverse(\textcolor{keyword}{const} Packet4f& a)
00699 \{
00700   Packet4f rev;
00701   rev.v4f[0] = preverse<Packet2d>(a.v4f[1]);
00702   rev.v4f[1] = preverse<Packet2d>(a.v4f[0]);
00703   \textcolor{keywordflow}{return} rev;
00704 \}
00705 
00706 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pabs<Packet4i>(\textcolor{keyword}{const} Packet4i& a) \{ \textcolor{keywordflow}{return} vec\_abs(a); \}
00707 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pabs<Packet2d>(\textcolor{keyword}{const} Packet2d& a) \{ \textcolor{keywordflow}{return} vec\_abs(a); \}
00708 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pabs<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00709 \{
00710   Packet4f res;
00711   res.v4f[0] = pabs(a.v4f[0]);
00712   res.v4f[1] = pabs(a.v4f[1]);
00713   \textcolor{keywordflow}{return} res;
00714 \}
00715 
00716 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00717 \{
00718   Packet4i b, sum;
00719   b   = vec\_sld(a, a, 8);
00720   sum = padd<Packet4i>(a, b);
00721   b   = vec\_sld(sum, sum, 4);
00722   sum = padd<Packet4i>(sum, b);
00723   \textcolor{keywordflow}{return} pfirst(sum);
00724 \}
00725 
00726 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux<Packet2d>(\textcolor{keyword}{const} Packet2d& a)
00727 \{
00728   Packet2d b, sum;
00729   b   = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4i>(a), reinterpret\_cast<Packet4i>(a), 8)
      );
00730   sum = padd<Packet2d>(a, b);
00731   \textcolor{keywordflow}{return} pfirst(sum);
00732 \}
00733 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00734 \{
00735   Packet2d sum;
00736   sum = padd<Packet2d>(a.v4f[0], a.v4f[1]);
00737   \textcolor{keywordtype}{double} first = predux<Packet2d>(sum);
00738   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(first);
00739 \}
00740 
00741 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i preduxp<Packet4i>(\textcolor{keyword}{const} Packet4i* vecs)
00742 \{
00743   Packet4i v[4], sum[4];
00744 
00745   \textcolor{comment}{// It's easier and faster to transpose then add as columns}
00746   \textcolor{comment}{// Check: http://www.freevec.org/function/matrix\_4x4\_transpose\_floats for explanation}
00747   \textcolor{comment}{// Do the transpose, first set of moves}
00748   v[0] = vec\_mergeh(vecs[0], vecs[2]);
00749   v[1] = vec\_mergel(vecs[0], vecs[2]);
00750   v[2] = vec\_mergeh(vecs[1], vecs[3]);
00751   v[3] = vec\_mergel(vecs[1], vecs[3]);
00752   \textcolor{comment}{// Get the resulting vectors}
00753   sum[0] = vec\_mergeh(v[0], v[2]);
00754   sum[1] = vec\_mergel(v[0], v[2]);
00755   sum[2] = vec\_mergeh(v[1], v[3]);
00756   sum[3] = vec\_mergel(v[1], v[3]);
00757 
00758   \textcolor{comment}{// Now do the summation:}
00759   \textcolor{comment}{// Lines 0+1}
00760   sum[0] = padd<Packet4i>(sum[0], sum[1]);
00761   \textcolor{comment}{// Lines 2+3}
00762   sum[1] = padd<Packet4i>(sum[2], sum[3]);
00763   \textcolor{comment}{// Add the results}
00764   sum[0] = padd<Packet4i>(sum[0], sum[1]);
00765 
00766   \textcolor{keywordflow}{return} sum[0];
00767 \}
00768 
00769 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d preduxp<Packet2d>(\textcolor{keyword}{const} Packet2d* vecs)
00770 \{
00771   Packet2d v[2], sum;
00772   v[0] = padd<Packet2d>(vecs[0], \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4ui>(vecs[0]), 
      reinterpret\_cast<Packet4ui>(vecs[0]), 8)));
00773   v[1] = padd<Packet2d>(vecs[1], \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4ui>(vecs[1]), 
      reinterpret\_cast<Packet4ui>(vecs[1]), 8)));
00774  
00775   sum = \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4ui>(v[0]), reinterpret\_cast<Packet4ui>(v
      [1]), 8));
00776 
00777   \textcolor{keywordflow}{return} sum;
00778 \}
00779 
00780 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f preduxp<Packet4f>(\textcolor{keyword}{const} Packet4f* vecs)
00781 \{
00782   \hyperlink{struct_eigen_1_1internal_1_1_packet_block}{PacketBlock<Packet4f,4>} transpose;
00783   transpose.packet[0] = vecs[0];
00784   transpose.packet[1] = vecs[1];
00785   transpose.packet[2] = vecs[2];
00786   transpose.packet[3] = vecs[3];
00787   ptranspose(transpose);
00788 
00789   Packet4f sum = padd(transpose.packet[0], transpose.packet[1]);
00790   sum = padd(sum, transpose.packet[2]);
00791   sum = padd(sum, transpose.packet[3]);
00792   \textcolor{keywordflow}{return} sum;
00793 \}
00794 
00795 \textcolor{comment}{// Other reduction functions:}
00796 \textcolor{comment}{// mul}
00797 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux\_mul<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00798 \{
00799   EIGEN\_ALIGN16 \textcolor{keywordtype}{int} aux[4];
00800   pstore(aux, a);
00801   \textcolor{keywordflow}{return} aux[0] * aux[1] * aux[2] * aux[3];
00802 \}
00803 
00804 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux\_mul<Packet2d>(\textcolor{keyword}{const} Packet2d& a)
00805 \{
00806   \textcolor{keywordflow}{return} pfirst(pmul(a, reinterpret\_cast<Packet2d>(vec\_sld(reinterpret\_cast<Packet4i>(a), 
      reinterpret\_cast<Packet4i>(a), 8))));
00807 \}
00808 
00809 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux\_mul<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00810 \{
00811   \textcolor{comment}{// Return predux\_mul<Packet2d> of the subvectors product}
00812   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(pfirst(predux\_mul(pmul(a.v4f[0], a.v4f[1]))));
00813 \}
00814 
00815 \textcolor{comment}{// min}
00816 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux\_min<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00817 \{
00818   Packet4i b, res;
00819   b   = pmin<Packet4i>(a, vec\_sld(a, a, 8));
00820   res = pmin<Packet4i>(b, vec\_sld(b, b, 4));
00821   \textcolor{keywordflow}{return} pfirst(res);
00822 \}
00823 
00824 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux\_min<Packet2d>(\textcolor{keyword}{const} Packet2d& a)
00825 \{
00826   \textcolor{keywordflow}{return} pfirst(pmin<Packet2d>(a, reinterpret\_cast<Packet2d>(vec\_sld(reinterpret\_cast<Packet4i>(a), 
      reinterpret\_cast<Packet4i>(a), 8))));
00827 \}
00828 
00829 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux\_min<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00830 \{
00831   Packet2d b, res;
00832   b   = pmin<Packet2d>(a.v4f[0], a.v4f[1]);
00833   res = pmin<Packet2d>(b, \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4i>(b), 
      reinterpret\_cast<Packet4i>(b), 8)));
00834   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(pfirst(res));
00835 \}
00836 
00837 \textcolor{comment}{// max}
00838 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} predux\_max<Packet4i>(\textcolor{keyword}{const} Packet4i& a)
00839 \{
00840   Packet4i b, res;
00841   b = pmax<Packet4i>(a, vec\_sld(a, a, 8));
00842   res = pmax<Packet4i>(b, vec\_sld(b, b, 4));
00843   \textcolor{keywordflow}{return} pfirst(res);
00844 \}
00845 
00846 \textcolor{comment}{// max}
00847 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux\_max<Packet2d>(\textcolor{keyword}{const} Packet2d& a)
00848 \{
00849   \textcolor{keywordflow}{return} pfirst(pmax<Packet2d>(a, reinterpret\_cast<Packet2d>(vec\_sld(reinterpret\_cast<Packet4i>(a), 
      reinterpret\_cast<Packet4i>(a), 8))));
00850 \}
00851 
00852 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux\_max<Packet4f>(\textcolor{keyword}{const} Packet4f& a)
00853 \{
00854   Packet2d b, res;
00855   b   = pmax<Packet2d>(a.v4f[0], a.v4f[1]);
00856   res = pmax<Packet2d>(b, \textcolor{keyword}{reinterpret\_cast<}Packet2d\textcolor{keyword}{>}(vec\_sld(reinterpret\_cast<Packet4i>(b), 
      reinterpret\_cast<Packet4i>(b), 8)));
00857   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(pfirst(res));
00858 \}
00859 
00860 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00861 ptranspose(\hyperlink{struct_eigen_1_1internal_1_1_packet_block}{PacketBlock<Packet4i,4>}& kernel) \{
00862   Packet4i t0 = vec\_mergeh(kernel.packet[0], kernel.packet[2]);
00863   Packet4i t1 = vec\_mergel(kernel.packet[0], kernel.packet[2]);
00864   Packet4i t2 = vec\_mergeh(kernel.packet[1], kernel.packet[3]);
00865   Packet4i t3 = vec\_mergel(kernel.packet[1], kernel.packet[3]);
00866   kernel.packet[0] = vec\_mergeh(t0, t2);
00867   kernel.packet[1] = vec\_mergel(t0, t2);
00868   kernel.packet[2] = vec\_mergeh(t1, t3);
00869   kernel.packet[3] = vec\_mergel(t1, t3);
00870 \}
00871 
00872 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00873 ptranspose(\hyperlink{struct_eigen_1_1internal_1_1_packet_block}{PacketBlock<Packet2d,2>}& kernel) \{
00874   Packet2d t0 = vec\_perm(kernel.packet[0], kernel.packet[1], p16uc\_TRANSPOSE64\_HI);
00875   Packet2d t1 = vec\_perm(kernel.packet[0], kernel.packet[1], p16uc\_TRANSPOSE64\_LO);
00876   kernel.packet[0] = t0;
00877   kernel.packet[1] = t1;
00878 \}
00879 
00880 \textcolor{comment}{/* Split the Packet4f PacketBlock into 4 Packet2d PacketBlocks and transpose each one}
00881 \textcolor{comment}{ */}
00882 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00883 ptranspose(\hyperlink{struct_eigen_1_1internal_1_1_packet_block}{PacketBlock<Packet4f,4>}& kernel) \{
00884   \hyperlink{struct_eigen_1_1internal_1_1_packet_block}{PacketBlock<Packet2d,2>} t0,t1,t2,t3;
00885   \textcolor{comment}{// copy top-left 2x2 Packet2d block}
00886   t0.packet[0] = kernel.packet[0].v4f[0];
00887   t0.packet[1] = kernel.packet[1].v4f[0];
00888 
00889   \textcolor{comment}{// copy top-right 2x2 Packet2d block}
00890   t1.packet[0] = kernel.packet[0].v4f[1];
00891   t1.packet[1] = kernel.packet[1].v4f[1];
00892 
00893   \textcolor{comment}{// copy bottom-left 2x2 Packet2d block}
00894   t2.packet[0] = kernel.packet[2].v4f[0];
00895   t2.packet[1] = kernel.packet[3].v4f[0];
00896 
00897   \textcolor{comment}{// copy bottom-right 2x2 Packet2d block}
00898   t3.packet[0] = kernel.packet[2].v4f[1];
00899   t3.packet[1] = kernel.packet[3].v4f[1];
00900 
00901   \textcolor{comment}{// Transpose all 2x2 blocks}
00902   ptranspose(t0);
00903   ptranspose(t1);
00904   ptranspose(t2);
00905   ptranspose(t3);
00906 
00907   \textcolor{comment}{// Copy back transposed blocks, but exchange t1 and t2 due to transposition}
00908   kernel.packet[0].v4f[0] = t0.packet[0];
00909   kernel.packet[0].v4f[1] = t2.packet[0];
00910   kernel.packet[1].v4f[0] = t0.packet[1];
00911   kernel.packet[1].v4f[1] = t2.packet[1];
00912   kernel.packet[2].v4f[0] = t1.packet[0];
00913   kernel.packet[2].v4f[1] = t3.packet[0];
00914   kernel.packet[3].v4f[0] = t1.packet[1];
00915   kernel.packet[3].v4f[1] = t3.packet[1];
00916 \}
00917 
00918 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4i pblend(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_selector}{Selector<4>}& ifPacket, \textcolor{keyword}{const} Packet4i& 
      thenPacket, \textcolor{keyword}{const} Packet4i& elsePacket) \{
00919   Packet4ui select = \{ ifPacket.select[0], ifPacket.select[1], ifPacket.select[2], ifPacket.select[3] \};
00920   Packet4ui mask = vec\_cmpeq(select, reinterpret\_cast<Packet4ui>(p4i\_ONE));
00921   \textcolor{keywordflow}{return} vec\_sel(elsePacket, thenPacket, mask);
00922 \}
00923 
00924 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f pblend(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_selector}{Selector<4>}& ifPacket, \textcolor{keyword}{const} Packet4f& 
      thenPacket, \textcolor{keyword}{const} Packet4f& elsePacket) \{
00925   Packet2ul select\_hi = \{ ifPacket.select[0], ifPacket.select[1] \};
00926   Packet2ul select\_lo = \{ ifPacket.select[2], ifPacket.select[3] \};
00927   Packet2ul mask\_hi = vec\_cmpeq(select\_hi, reinterpret\_cast<Packet2ul>(p2l\_ONE));
00928   Packet2ul mask\_lo = vec\_cmpeq(select\_lo, reinterpret\_cast<Packet2ul>(p2l\_ONE));
00929   Packet4f result;
00930   result.v4f[0] = vec\_sel(elsePacket.v4f[0], thenPacket.v4f[0], mask\_hi);
00931   result.v4f[1] = vec\_sel(elsePacket.v4f[1], thenPacket.v4f[1], mask\_lo);
00932   \textcolor{keywordflow}{return} result;
00933 \}
00934 
00935 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2d pblend(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_selector}{Selector<2>}& ifPacket, \textcolor{keyword}{const} Packet2d& 
      thenPacket, \textcolor{keyword}{const} Packet2d& elsePacket) \{
00936   Packet2ul select = \{ ifPacket.select[0], ifPacket.select[1] \};
00937   Packet2ul mask = vec\_cmpeq(select, reinterpret\_cast<Packet2ul>(p2l\_ONE));
00938   \textcolor{keywordflow}{return} vec\_sel(elsePacket, thenPacket, mask);
00939 \}
00940 
00941 \} \textcolor{comment}{// end namespace internal}
00942 
00943 \} \textcolor{comment}{// end namespace Eigen}
00944 
00945 \textcolor{preprocessor}{#endif // EIGEN\_PACKET\_MATH\_ZVECTOR\_H}
\end{DoxyCode}
