\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_arg_max_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Arg\+Max.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_arg_max_8h_source}\index{Tensor\+Arg\+Max.\+h@{Tensor\+Arg\+Max.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Eugene Brevdo <ebrevdo@gmail.com>}
00005 \textcolor{comment}{//                    Benoit Steiner <benoit.steiner.goog@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_ARG\_MAX\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_ARG\_MAX\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00024 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_arg_max_8h_source_l00025}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_index_tuple_op_3_01_xpr_type_01_4_01_4}{00025} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_index_tuple_op}{TensorIndexTupleOp}<XprType> > : \textcolor{keyword}{public} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<XprType>
00026 \{
00027   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>} \hyperlink{struct_eigen_1_1internal_1_1traits}{XprTraits};
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00030   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_tuple}{Tuple<Index, typename XprTraits::Scalar>} 
      \hyperlink{struct_eigen_1_1_tuple}{Scalar};
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00032   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<Nested>::type} 
      \hyperlink{group___sparse_core___module}{\_Nested};
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions;
00034   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00035 \};
00036 
00037 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_arg_max_8h_source_l00038}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_index_tuple_op_3_01_xpr_type_01_4_00_01_eigen_1_1_dense_01_4}{00038} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_index_tuple_op}{TensorIndexTupleOp}<XprType>, \hyperlink{namespace_eigen}{Eigen}::\hyperlink{struct_eigen_1_1_dense}{Dense}>
00039 \{
00040   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_index_tuple_op}{TensorIndexTupleOp<XprType>}& \hyperlink{class_eigen_1_1_tensor_index_tuple_op}{type};
00041 \};
00042 
00043 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_arg_max_8h_source_l00044}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_index_tuple_op_3_01_xpr_type_01_4_00_011_00_01typ5b5b3f337e89a8fcbdd9fda09242c5e4}{00044} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_index_tuple_op}{TensorIndexTupleOp}<XprType>, 1,
00045               typename \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_index_tuple_op}{TensorIndexTupleOp}<XprType> >::
      \hyperlink{class_eigen_1_1_tensor_index_tuple_op}{type}>
00046 \{
00047   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_index_tuple_op}{TensorIndexTupleOp<XprType>} \hyperlink{class_eigen_1_1_tensor_index_tuple_op}{type};
00048 \};
00049 
00050 \}  \textcolor{comment}{// end namespace internal}
00051 
00052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_arg_max_8h_source_l00053}\hyperlink{class_eigen_1_1_tensor_index_tuple_op}{00053} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_index_tuple_op}{TensorIndexTupleOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorIndexTupleOp<XprType>, ReadO
      nlyAccessors>
00054 \{
00055   \textcolor{keyword}{public}:
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorIndexTupleOp>::Scalar}
       Scalar;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} 
      \hyperlink{group___sparse_core___module}{RealScalar};
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorIndexTupleOp>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Nested};
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorIndexTupleOp>::StorageKind}
       StorageKind;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorIndexTupleOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00061   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_tuple}{Tuple<Index, typename XprType::CoeffReturnType>} 
      \hyperlink{struct_eigen_1_1_tuple}{CoeffReturnType};
00062 
00063   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_index_tuple_op}{TensorIndexTupleOp}(\textcolor{keyword}{const} XprType& expr)
00064       : m\_xpr(expr) \{\}
00065 
00066   EIGEN\_DEVICE\_FUNC
00067   \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename XprType::Nested>::type}
      &
00068   expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00069 
00070   \textcolor{keyword}{protected}:
00071     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00072 \};
00073 
00074 \textcolor{comment}{// Eval as rvalue}
00075 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_arg_max_8h_source_l00076}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_index_tuple_op_3_01_arg_type_01_4_00_01_device_01_4}{00076} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_index_tuple_op}{TensorIndexTupleOp}<ArgType>, Device>
00077 \{
00078   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_index_tuple_op}{TensorIndexTupleOp<ArgType>} \hyperlink{class_eigen_1_1_tensor_index_tuple_op}{XprType};
00079   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00080   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00081   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tuple}{XprType::CoeffReturnType} 
      \hyperlink{struct_eigen_1_1_tuple}{CoeffReturnType};
00082 
00083   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Dimensions}
       Dimensions;
00084   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<Dimensions>::value}
      ;
00085 
00086   \textcolor{keyword}{enum} \{
00087     IsAligned = \textcolor{comment}{/*TensorEvaluator<ArgType, Device>::IsAligned*/} \textcolor{keyword}{false},
00088     PacketAccess = \textcolor{comment}{/*TensorEvaluator<ArgType, Device>::PacketAccess*/} \textcolor{keyword}{false},
00089     BlockAccess = \textcolor{keyword}{false},
00090     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Layout},
00091     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00092     RawAccess = \textcolor{keyword}{false}
00093   \};
00094 
00095   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00096       : m\_impl(op.expression(), device) \{ \}
00097 
00098   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{
00099     \textcolor{keywordflow}{return} m\_impl.dimensions();
00100   \}
00101 
00102   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/}) \{
00103     m\_impl.evalSubExprsIfNeeded(NULL);
00104     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00105   \}
00106   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00107     m\_impl.cleanup();
00108   \}
00109 
00110   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00111 \textcolor{keyword}{  }\{
00112     \textcolor{keywordflow}{return} CoeffReturnType(index, m\_impl.coeff(index));
00113   \}
00114 
00115   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}
00116   costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00117     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) + \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, 1);
00118   \}
00119 
00120   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00121 
00122  \textcolor{keyword}{protected}:
00123   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} m\_impl;
00124 \};
00125 
00126 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00127 
00134 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReduceOp, \textcolor{keyword}{typename} Dims, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_arg_max_8h_source_l00135}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_tuple_reducer_op_3_01_reduce_op_00_01_dims_00_01_xpr_type_01_4_01_4}{00135} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{TensorTupleReducerOp}<ReduceOp, Dims, XprType> > : \textcolor{keyword}{public} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<XprType>
00136 \{
00137   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>} \hyperlink{struct_eigen_1_1internal_1_1traits}{XprTraits};
00138   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00139   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00140   \textcolor{keyword}{typedef} Index Scalar;
00141   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00142   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<Nested>::type} 
      \hyperlink{group___sparse_core___module}{\_Nested};
00143   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions - 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size<Dims>::value};
00144   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00145 \};
00146 
00147 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReduceOp, \textcolor{keyword}{typename} Dims, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_arg_max_8h_source_l00148}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_tuple_reducer_op_3_01_reduce_op_00_01_dims_00_01_xpfa3431995abe939b85159a164be4ee8a}{00148} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{TensorTupleReducerOp}<ReduceOp, Dims, XprType>, 
      \hyperlink{namespace_eigen}{Eigen}::\hyperlink{struct_eigen_1_1_dense}{Dense}>
00149 \{
00150   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{TensorTupleReducerOp<ReduceOp, Dims, XprType>}&
       \hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{type};
00151 \};
00152 
00153 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReduceOp, \textcolor{keyword}{typename} Dims, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_arg_max_8h_source_l00154}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_tuple_reducer_op_3_01_reduce_op_00_01_dims_00_01_821bbc2beef8f62325eb5ce9ac37fcf5}{00154} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{TensorTupleReducerOp}<ReduceOp, Dims, XprType>, 1,
00155               typename \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{TensorTupleReducerOp}<ReduceOp, Dims, XprType> >::
      \hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{type}>
00156 \{
00157   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{TensorTupleReducerOp<ReduceOp, Dims, XprType>} 
      \hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{type};
00158 \};
00159 
00160 \}  \textcolor{comment}{// end namespace internal}
00161 
00162 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReduceOp, \textcolor{keyword}{typename} Dims, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_arg_max_8h_source_l00163}\hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{00163} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{TensorTupleReducerOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorTupleReducerOp<ReduceOp,
       Dims, XprType>, ReadOnlyAccessors>
00164 \{
00165   \textcolor{keyword}{public}:
00166   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorTupleReducerOp>::Scalar}
       Scalar;
00167   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} 
      \hyperlink{group___sparse_core___module}{RealScalar};
00168   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorTupleReducerOp>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Nested};
00169   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorTupleReducerOp>::StorageKind}
       StorageKind;
00170   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorTupleReducerOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00171   \textcolor{keyword}{typedef} Index CoeffReturnType;
00172 
00173   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{TensorTupleReducerOp}(\textcolor{keyword}{const} XprType& expr,
00174                                                           \textcolor{keyword}{const} ReduceOp& reduce\_op,
00175                                                           \textcolor{keyword}{const} \textcolor{keywordtype}{int} return\_dim,
00176                                                           \textcolor{keyword}{const} Dims& reduce\_dims)
00177       : m\_xpr(expr), m\_reduce\_op(reduce\_op), m\_return\_dim(return\_dim), m\_reduce\_dims(reduce\_dims) \{\}
00178 
00179   EIGEN\_DEVICE\_FUNC
00180   \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename XprType::Nested>::type}
      &
00181   expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00182 
00183   EIGEN\_DEVICE\_FUNC
00184   \textcolor{keyword}{const} ReduceOp& reduce\_op()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_reduce\_op; \}
00185 
00186   EIGEN\_DEVICE\_FUNC
00187   \textcolor{keyword}{const} Dims& reduce\_dims()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_reduce\_dims; \}
00188 
00189   EIGEN\_DEVICE\_FUNC
00190   \textcolor{keywordtype}{int} return\_dim()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_return\_dim; \}
00191 
00192   \textcolor{keyword}{protected}:
00193     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00194     \textcolor{keyword}{const} ReduceOp m\_reduce\_op;
00195     \textcolor{keyword}{const} \textcolor{keywordtype}{int} m\_return\_dim;
00196     \textcolor{keyword}{const} Dims m\_reduce\_dims;
00197 \};
00198 
00199 \textcolor{comment}{// Eval as rvalue}
00200 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReduceOp, \textcolor{keyword}{typename} Dims, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_arg_max_8h_source_l00201}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_tuple_reducer_op_3_01_reduce_op_00_01_dimsa9704c68eb01932857866cfd0005279c}{00201} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{TensorTupleReducerOp}<ReduceOp, Dims, 
      ArgType>, Device>
00202 \{
00203   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{TensorTupleReducerOp<ReduceOp, Dims, ArgType>} 
      \hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{XprType};
00204   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00205   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00206   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00207   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1_tensor_index_tuple_op}{TensorIndexTupleOp<ArgType>::CoeffReturnType}
       TupleType;
00208   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<const TensorReductionOp<ReduceOp, Dims, const TensorIndexTupleOp<ArgType>}
       >, Device>::Dimensions Dimensions;
00209   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<const TensorIndexTupleOp<ArgType>}
       , Device>::Dimensions InputDimensions;
00210   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<InputDimensions>::value}
      ;
00211   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} \hyperlink{class_eigen_1_1array}{StrideDims};
00212 
00213   \textcolor{keyword}{enum} \{
00214     IsAligned = \textcolor{comment}{/*TensorEvaluator<ArgType, Device>::IsAligned*/} \textcolor{keyword}{false},
00215     PacketAccess = \textcolor{comment}{/*TensorEvaluator<ArgType, Device>::PacketAccess*/} \textcolor{keyword}{false},
00216     BlockAccess = \textcolor{keyword}{false},
00217     Layout = TensorEvaluator<const TensorReductionOp<ReduceOp, Dims, const TensorIndexTupleOp<ArgType> >, 
      Device>::Layout,
00218     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00219     RawAccess = \textcolor{keyword}{false}
00220   \};
00221 
00222   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00223       : m\_orig\_impl(op.expression(), device),
00224         m\_impl(op.expression().index\_tuples().reduce(op.reduce\_dims(), op.reduce\_op()), device),
00225         m\_return\_dim(op.return\_dim()) \{
00226 
00227     gen\_strides(m\_orig\_impl.dimensions(), m\_strides);
00228     \textcolor{keywordflow}{if} (Layout == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00229       \textcolor{keyword}{const} Index total\_size = internal::array\_prod(m\_orig\_impl.dimensions());
00230       m\_stride\_mod = (m\_return\_dim < NumDims - 1) ? m\_strides[m\_return\_dim + 1] : total\_size;
00231     \} \textcolor{keywordflow}{else} \{
00232       \textcolor{keyword}{const} Index total\_size = internal::array\_prod(m\_orig\_impl.dimensions());
00233       m\_stride\_mod = (m\_return\_dim > 0) ? m\_strides[m\_return\_dim - 1] : total\_size;
00234     \}
00235     m\_stride\_div = m\_strides[m\_return\_dim];
00236   \}
00237 
00238   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{
00239     \textcolor{keywordflow}{return} m\_impl.dimensions();
00240   \}
00241 
00242   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/}) \{
00243     m\_impl.evalSubExprsIfNeeded(NULL);
00244     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00245   \}
00246   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00247     m\_impl.cleanup();
00248   \}
00249 
00250   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const }\{
00251     \textcolor{keyword}{const} TupleType v = m\_impl.coeff(index);
00252     \textcolor{keywordflow}{return} (m\_return\_dim < 0) ? v.first : (v.first % m\_stride\_mod) / m\_stride\_div;
00253   \}
00254 
00255   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00256 
00257   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}
00258   costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00259     \textcolor{keyword}{const} \textcolor{keywordtype}{double} compute\_cost = 1.0 +
00260         (m\_return\_dim < 0 ? 0.0 : (TensorOpCost::ModCost<Index>() + TensorOpCost::DivCost<Index>()));
00261     \textcolor{keywordflow}{return} m\_orig\_impl.costPerCoeff(vectorized) +
00262            m\_impl.costPerCoeff(vectorized) + \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, compute\_cost);
00263   \}
00264 
00265  \textcolor{keyword}{private}:
00266   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} gen\_strides(\textcolor{keyword}{const} InputDimensions& dims, StrideDims& strides) \{
00267     \textcolor{keywordflow}{if} (m\_return\_dim < 0) \{
00268       \textcolor{keywordflow}{return};  \textcolor{comment}{// Won't be using the strides.}
00269     \}
00270     eigen\_assert(m\_return\_dim < NumDims &&
00271                  \textcolor{stringliteral}{"Asking to convert index to a dimension outside of the rank"});
00272 
00273     \textcolor{comment}{// Calculate m\_stride\_div and m\_stride\_mod, which are used to}
00274     \textcolor{comment}{// calculate the value of an index w.r.t. the m\_return\_dim.}
00275     \textcolor{keywordflow}{if} (Layout == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00276       strides[0] = 1;
00277       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00278         strides[i] = strides[i-1] * dims[i-1];
00279       \}
00280     \} \textcolor{keywordflow}{else} \{
00281       strides[NumDims-1] = 1;
00282       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00283         strides[i] = strides[i+1] * dims[i+1];
00284       \}
00285     \}
00286   \}
00287 
00288  \textcolor{keyword}{protected}:
00289   TensorEvaluator<const TensorIndexTupleOp<ArgType>, Device> m\_orig\_impl;
00290   TensorEvaluator<const TensorReductionOp<ReduceOp, Dims, const TensorIndexTupleOp<ArgType> >, Device> 
      m\_impl;
00291   \textcolor{keyword}{const} \textcolor{keywordtype}{int} m\_return\_dim;
00292   StrideDims m\_strides;
00293   Index m\_stride\_mod;
00294   Index m\_stride\_div;
00295 \};
00296 
00297 \} \textcolor{comment}{// end namespace Eigen}
00298 
00299 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_ARG\_MAX\_H}
\end{DoxyCode}
