\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_jacobi_2_jacobi_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Jacobi/\+Jacobi.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_jacobi_2_jacobi_8h_source}\index{Jacobi.\+h@{Jacobi.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_JACOBI\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_JACOBI\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00015 
00034 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{class }JacobiRotation
00035 \{
00036   \textcolor{keyword}{public}:
00037     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar;
00038 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_jacobi_2_jacobi_8h_source_l00040}\hyperlink{group___jacobi___module_a38fec2c4da529ef3d05ff37b848b4227}{00040}     \hyperlink{group___jacobi___module_a38fec2c4da529ef3d05ff37b848b4227}{JacobiRotation}() \{\}
00041 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_jacobi_2_jacobi_8h_source_l00043}\hyperlink{group___jacobi___module_a3e8b5dc0a56f7a2d0f788b1ccb1547cb}{00043}     \hyperlink{group___jacobi___module_a3e8b5dc0a56f7a2d0f788b1ccb1547cb}{JacobiRotation}(\textcolor{keyword}{const} Scalar& c, \textcolor{keyword}{const} Scalar& s) : m\_c(c), m\_s(s) \{\}
00044 
00045     Scalar& c() \{ \textcolor{keywordflow}{return} m\_c; \}
00046     Scalar c()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_c; \}
00047     Scalar& s() \{ \textcolor{keywordflow}{return} m\_s; \}
00048     Scalar s()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_s; \}
00049 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_jacobi_2_jacobi_8h_source_l00051}\hyperlink{group___jacobi___module_ada8389f291839964d7b481464f0e4e94}{00051}     \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation} \hyperlink{group___jacobi___module_ada8389f291839964d7b481464f0e4e94}{operator*}(\textcolor{keyword}{const} \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation}& other)
00052     \{
00053       \textcolor{keyword}{using} numext::conj;
00054       \textcolor{keywordflow}{return} \hyperlink{group___jacobi___module_a38fec2c4da529ef3d05ff37b848b4227}{JacobiRotation}(m\_c * other.m\_c - conj(m\_s) * other.m\_s,
00055                             conj(m\_c * conj(other.m\_s) + conj(m\_s) * conj(other.m\_c)));
00056     \}
00057 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_jacobi_2_jacobi_8h_source_l00059}\hyperlink{group___jacobi___module_ab40e9cdc4582593511e57ee896e055a2}{00059}     \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation} \hyperlink{group___jacobi___module_ab40e9cdc4582593511e57ee896e055a2}{transpose}()\textcolor{keyword}{ const }\{ \textcolor{keyword}{using} numext::conj; \textcolor{keywordflow}{return} 
      \hyperlink{group___jacobi___module_a38fec2c4da529ef3d05ff37b848b4227}{JacobiRotation}(m\_c, -conj(m\_s)); \}
00060 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_jacobi_2_jacobi_8h_source_l00062}\hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{00062}     \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation} \hyperlink{group___jacobi___module_a89c8ea615f8fa77ddd5810a1e5fde4da}{adjoint}()\textcolor{keyword}{ const }\{ \textcolor{keyword}{using} numext::conj; \textcolor{keywordflow}{return} 
      \hyperlink{group___jacobi___module_a38fec2c4da529ef3d05ff37b848b4227}{JacobiRotation}(conj(m\_c), -m\_s); \}
00063 
00064     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00065     \textcolor{keywordtype}{bool} \hyperlink{group___jacobi___module_a69076401f22e883dc76b6ff9074ac669}{makeJacobi}(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}&, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} q);
00066     \textcolor{keywordtype}{bool} \hyperlink{group___jacobi___module_a69076401f22e883dc76b6ff9074ac669}{makeJacobi}(\textcolor{keyword}{const} RealScalar& x, \textcolor{keyword}{const} Scalar& y, \textcolor{keyword}{const} RealScalar& z);
00067 
00068     \textcolor{keywordtype}{void} \hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(\textcolor{keyword}{const} Scalar& p, \textcolor{keyword}{const} Scalar& q, Scalar* z=0);
00069 
00070   \textcolor{keyword}{protected}:
00071     \textcolor{keywordtype}{void} \hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(\textcolor{keyword}{const} Scalar& p, \textcolor{keyword}{const} Scalar& q, Scalar* z, 
      \hyperlink{struct_eigen_1_1internal_1_1true__type}{internal::true\_type});
00072     \textcolor{keywordtype}{void} \hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(\textcolor{keyword}{const} Scalar& p, \textcolor{keyword}{const} Scalar& q, Scalar* z, 
      \hyperlink{struct_eigen_1_1internal_1_1false__type}{internal::false\_type});
00073 
00074     Scalar m\_c, m\_s;
00075 \};
00076 
00082 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00083 \textcolor{keywordtype}{bool} \hyperlink{group___jacobi___module_a69076401f22e883dc76b6ff9074ac669}{JacobiRotation<Scalar>::makeJacobi}(\textcolor{keyword}{const} RealScalar& x, \textcolor{keyword}{const} Scalar
      & y, \textcolor{keyword}{const} RealScalar& z)
00084 \{
00085   \textcolor{keyword}{using} std::sqrt;
00086   \textcolor{keyword}{using} std::abs;
00087   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00088   RealScalar deno = RealScalar(2)*abs(y);
00089   \textcolor{keywordflow}{if}(deno < (std::numeric\_limits<RealScalar>::min)())
00090   \{
00091     m\_c = Scalar(1);
00092     m\_s = Scalar(0);
00093     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00094   \}
00095   \textcolor{keywordflow}{else}
00096   \{
00097     RealScalar tau = (x-z)/deno;
00098     RealScalar w = sqrt(numext::abs2(tau) + RealScalar(1));
00099     RealScalar t;
00100     \textcolor{keywordflow}{if}(tau>RealScalar(0))
00101     \{
00102       t = RealScalar(1) / (tau + w);
00103     \}
00104     \textcolor{keywordflow}{else}
00105     \{
00106       t = RealScalar(1) / (tau - w);
00107     \}
00108     RealScalar sign\_t = t > RealScalar(0) ? RealScalar(1) : RealScalar(-1);
00109     RealScalar n = RealScalar(1) / sqrt(numext::abs2(t)+RealScalar(1));
00110     m\_s = - sign\_t * (numext::conj(y) / abs(y)) * abs(t) * n;
00111     m\_c = n;
00112     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00113   \}
00114 \}
00115 
00125 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00126 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00127 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \hyperlink{group___jacobi___module_a69076401f22e883dc76b6ff9074ac669}{JacobiRotation<Scalar>::makeJacobi}(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& m, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} q)
00128 \{
00129   \textcolor{keywordflow}{return} \hyperlink{group___jacobi___module_a69076401f22e883dc76b6ff9074ac669}{makeJacobi}(numext::real(m.coeff(p,p)), m.coeff(p,q), numext::real(m.coeff(q,q)));
00130 \}
00131 
00148 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00149 \textcolor{keywordtype}{void} \hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{JacobiRotation<Scalar>::makeGivens}(\textcolor{keyword}{const} Scalar& p, \textcolor{keyword}{const} Scalar& q,
       Scalar* z)
00150 \{
00151   \hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{makeGivens}(p, q, z, \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{internal::conditional}<
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsComplex}, \hyperlink{struct_eigen_1_1internal_1_1true__type}{internal::true\_type}, 
      \hyperlink{struct_eigen_1_1internal_1_1false__type}{internal::false\_type}>::type());
00152 \}
00153 
00154 
00155 \textcolor{comment}{// specialization for complexes}
00156 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00157 \textcolor{keywordtype}{void} \hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{JacobiRotation<Scalar>::makeGivens}(\textcolor{keyword}{const} Scalar& p, \textcolor{keyword}{const} Scalar& q,
       Scalar* r, \hyperlink{struct_eigen_1_1internal_1_1true__type}{internal::true\_type})
00158 \{
00159   \textcolor{keyword}{using} std::sqrt;
00160   \textcolor{keyword}{using} std::abs;
00161   \textcolor{keyword}{using} numext::conj;
00162   
00163   \textcolor{keywordflow}{if}(q==Scalar(0))
00164   \{
00165     m\_c = numext::real(p)<0 ? Scalar(-1) : Scalar(1);
00166     m\_s = 0;
00167     \textcolor{keywordflow}{if}(r) *r = m\_c * p;
00168   \}
00169   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(p==Scalar(0))
00170   \{
00171     m\_c = 0;
00172     m\_s = -q/abs(q);
00173     \textcolor{keywordflow}{if}(r) *r = abs(q);
00174   \}
00175   \textcolor{keywordflow}{else}
00176   \{
00177     RealScalar p1 = numext::norm1(p);
00178     RealScalar q1 = numext::norm1(q);
00179     \textcolor{keywordflow}{if}(p1>=q1)
00180     \{
00181       Scalar ps = p / p1;
00182       RealScalar p2 = numext::abs2(ps);
00183       Scalar qs = q / p1;
00184       RealScalar q2 = numext::abs2(qs);
00185 
00186       RealScalar u = sqrt(RealScalar(1) + q2/p2);
00187       \textcolor{keywordflow}{if}(numext::real(p)<RealScalar(0))
00188         u = -u;
00189 
00190       m\_c = Scalar(1)/u;
00191       m\_s = -qs*conj(ps)*(m\_c/p2);
00192       \textcolor{keywordflow}{if}(r) *r = p * u;
00193     \}
00194     \textcolor{keywordflow}{else}
00195     \{
00196       Scalar ps = p / q1;
00197       RealScalar p2 = numext::abs2(ps);
00198       Scalar qs = q / q1;
00199       RealScalar q2 = numext::abs2(qs);
00200 
00201       RealScalar u = q1 * sqrt(p2 + q2);
00202       \textcolor{keywordflow}{if}(numext::real(p)<RealScalar(0))
00203         u = -u;
00204 
00205       p1 = abs(p);
00206       ps = p/p1;
00207       m\_c = p1/u;
00208       m\_s = -conj(ps) * (q/u);
00209       \textcolor{keywordflow}{if}(r) *r = ps * u;
00210     \}
00211   \}
00212 \}
00213 
00214 \textcolor{comment}{// specialization for reals}
00215 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00216 \textcolor{keywordtype}{void} \hyperlink{group___jacobi___module_af73c81e9cc139b7e0d877ce553b02ec0}{JacobiRotation<Scalar>::makeGivens}(\textcolor{keyword}{const} Scalar& p, \textcolor{keyword}{const} Scalar& q,
       Scalar* r, \hyperlink{struct_eigen_1_1internal_1_1false__type}{internal::false\_type})
00217 \{
00218   \textcolor{keyword}{using} std::sqrt;
00219   \textcolor{keyword}{using} std::abs;
00220   \textcolor{keywordflow}{if}(q==Scalar(0))
00221   \{
00222     m\_c = p<Scalar(0) ? Scalar(-1) : Scalar(1);
00223     m\_s = Scalar(0);
00224     \textcolor{keywordflow}{if}(r) *r = abs(p);
00225   \}
00226   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(p==Scalar(0))
00227   \{
00228     m\_c = Scalar(0);
00229     m\_s = q<Scalar(0) ? Scalar(1) : Scalar(-1);
00230     \textcolor{keywordflow}{if}(r) *r = abs(q);
00231   \}
00232   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(abs(p) > abs(q))
00233   \{
00234     Scalar t = q/p;
00235     Scalar u = sqrt(Scalar(1) + numext::abs2(t));
00236     \textcolor{keywordflow}{if}(p<Scalar(0))
00237       u = -u;
00238     m\_c = Scalar(1)/u;
00239     m\_s = -t * m\_c;
00240     \textcolor{keywordflow}{if}(r) *r = p * u;
00241   \}
00242   \textcolor{keywordflow}{else}
00243   \{
00244     Scalar t = p/q;
00245     Scalar u = sqrt(Scalar(1) + numext::abs2(t));
00246     \textcolor{keywordflow}{if}(q<Scalar(0))
00247       u = -u;
00248     m\_s = -Scalar(1)/u;
00249     m\_c = -t * m\_s;
00250     \textcolor{keywordflow}{if}(r) *r = q * u;
00251   \}
00252 
00253 \}
00254 
00255 \textcolor{comment}{/****************************************************************************************}
00256 \textcolor{comment}{*   Implementation of MatrixBase methods}
00257 \textcolor{comment}{****************************************************************************************/}
00258 
00259 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00266 \textcolor{keyword}{template}<\textcolor{keyword}{typename} VectorX, \textcolor{keyword}{typename} VectorY, \textcolor{keyword}{typename} OtherScalar>
00267 \textcolor{keywordtype}{void} apply\_rotation\_in\_the\_plane(\hyperlink{group___core___module_class_eigen_1_1_dense_base}{DenseBase<VectorX>}& xpr\_x, 
      \hyperlink{group___core___module_class_eigen_1_1_dense_base}{DenseBase<VectorY>}& xpr\_y, \textcolor{keyword}{const} \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<OtherScalar>}& 
      j);
00268 \}
00269 
00276 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00277 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherScalar>
00278 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___core___module_a3a08ad41e81d8ad4a37b5d5c7490e765}{MatrixBase<Derived>::applyOnTheLeft}(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} q, \textcolor{keyword}{const} \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<OtherScalar>}& j)
00279 \{
00280   \hyperlink{group___core___module_class_eigen_1_1_block}{RowXpr} x(this->row(p));
00281   \hyperlink{group___core___module_class_eigen_1_1_block}{RowXpr} y(this->row(q));
00282   \hyperlink{namespace_eigen_1_1internal_a5f7738a5c56c9b9decf94d9728ba7906}{internal::apply\_rotation\_in\_the\_plane}(x, y, j);
00283 \}
00284 
00291 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00292 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherScalar>
00293 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___core___module_a45d91752925d2757fc8058a293b15462}{MatrixBase<Derived>::applyOnTheRight}(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} q, \textcolor{keyword}{const} \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<OtherScalar>}& j)
00294 \{
00295   ColXpr x(this->col(p));
00296   ColXpr y(this->col(q));
00297   \hyperlink{namespace_eigen_1_1internal_a5f7738a5c56c9b9decf94d9728ba7906}{internal::apply\_rotation\_in\_the\_plane}(x, y, j.transpose());
00298 \}
00299 
00300 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00301 \textcolor{keyword}{template}<\textcolor{keyword}{typename} VectorX, \textcolor{keyword}{typename} VectorY, \textcolor{keyword}{typename} OtherScalar>
00302 \textcolor{keywordtype}{void} \textcolor{comment}{/*EIGEN\_DONT\_INLINE*/} apply\_rotation\_in\_the\_plane(\hyperlink{group___core___module_class_eigen_1_1_dense_base}{DenseBase<VectorX>}& xpr\_x, 
      \hyperlink{group___core___module_class_eigen_1_1_dense_base}{DenseBase<VectorY>}& xpr\_y, \textcolor{keyword}{const} \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<OtherScalar>}& 
      j)
00303 \{
00304   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorX::Scalar Scalar;
00305   \textcolor{keyword}{enum} \{
00306     PacketSize = packet\_traits<Scalar>::size,
00307     OtherPacketSize = packet\_traits<OtherScalar>::size
00308   \};
00309   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::type \hyperlink{group___sparse_core___module}{Packet};
00310   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<OtherScalar>::type OtherPacket;
00311   eigen\_assert(xpr\_x.size() == xpr\_y.size());
00312   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = xpr\_x.size();
00313   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} incrx = xpr\_x.derived().innerStride();
00314   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} incry = xpr\_y.derived().innerStride();
00315 
00316   Scalar* EIGEN\_RESTRICT x = &xpr\_x.derived().coeffRef(0);
00317   Scalar* EIGEN\_RESTRICT y = &xpr\_y.derived().coeffRef(0);
00318   
00319   OtherScalar c = j.c();
00320   OtherScalar s = j.s();
00321   \textcolor{keywordflow}{if} (c==OtherScalar(1) && s==OtherScalar(0))
00322     \textcolor{keywordflow}{return};
00323 
00324   \textcolor{comment}{/*** dynamic-size vectorized paths ***/}
00325 
00326   \textcolor{keywordflow}{if}(VectorX::SizeAtCompileTime == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} &&
00327     (VectorX::Flags & VectorY::Flags & \hyperlink{group__flags_ga1a306a438e1ab074e8be59512e887b9f}{PacketAccessBit}) &&
00328     (PacketSize == OtherPacketSize) &&
00329     ((incrx==1 && incry==1) || PacketSize == 1))
00330   \{
00331     \textcolor{comment}{// both vectors are sequentially stored in memory => vectorization}
00332     \textcolor{keyword}{enum} \{ Peeling = 2 \};
00333 
00334     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedStart = internal::first\_default\_aligned(y, size);
00335     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedEnd = alignedStart + ((size-alignedStart)/PacketSize)*PacketSize;
00336 
00337     \textcolor{keyword}{const} OtherPacket pc = pset1<OtherPacket>(c);
00338     \textcolor{keyword}{const} OtherPacket ps = pset1<OtherPacket>(s);
00339     conj\_helper<OtherPacket,Packet,NumTraits<OtherScalar>::IsComplex,\textcolor{keyword}{false}> pcj;
00340     conj\_helper<OtherPacket,Packet,false,false> pm;
00341 
00342     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<alignedStart; ++i)
00343     \{
00344       Scalar xi = x[i];
00345       Scalar yi = y[i];
00346       x[i] =  c * xi + numext::conj(s) * yi;
00347       y[i] = -s * xi + numext::conj(c) * yi;
00348     \}
00349 
00350     Scalar* EIGEN\_RESTRICT px = x + alignedStart;
00351     Scalar* EIGEN\_RESTRICT py = y + alignedStart;
00352 
00353     \textcolor{keywordflow}{if}(internal::first\_default\_aligned(x, size)==alignedStart)
00354     \{
00355       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=alignedStart; i<alignedEnd; i+=PacketSize)
00356       \{
00357         Packet xi = pload<Packet>(px);
00358         Packet yi = pload<Packet>(py);
00359         pstore(px, padd(pm.pmul(pc,xi),pcj.pmul(ps,yi)));
00360         pstore(py, psub(pcj.pmul(pc,yi),pm.pmul(ps,xi)));
00361         px += PacketSize;
00362         py += PacketSize;
00363       \}
00364     \}
00365     \textcolor{keywordflow}{else}
00366     \{
00367       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peelingEnd = alignedStart + ((size-alignedStart)/(Peeling*PacketSize))*(Peeling*PacketSize
      );
00368       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=alignedStart; i<peelingEnd; i+=Peeling*PacketSize)
00369       \{
00370         Packet xi   = ploadu<Packet>(px);
00371         Packet xi1  = ploadu<Packet>(px+PacketSize);
00372         Packet yi   = pload <Packet>(py);
00373         Packet yi1  = pload <Packet>(py+PacketSize);
00374         pstoreu(px, padd(pm.pmul(pc,xi),pcj.pmul(ps,yi)));
00375         pstoreu(px+PacketSize, padd(pm.pmul(pc,xi1),pcj.pmul(ps,yi1)));
00376         pstore (py, psub(pcj.pmul(pc,yi),pm.pmul(ps,xi)));
00377         pstore (py+PacketSize, psub(pcj.pmul(pc,yi1),pm.pmul(ps,xi1)));
00378         px += Peeling*PacketSize;
00379         py += Peeling*PacketSize;
00380       \}
00381       \textcolor{keywordflow}{if}(alignedEnd!=peelingEnd)
00382       \{
00383         Packet xi = ploadu<Packet>(x+peelingEnd);
00384         Packet yi = pload <Packet>(y+peelingEnd);
00385         pstoreu(x+peelingEnd, padd(pm.pmul(pc,xi),pcj.pmul(ps,yi)));
00386         pstore (y+peelingEnd, psub(pcj.pmul(pc,yi),pm.pmul(ps,xi)));
00387       \}
00388     \}
00389 
00390     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=alignedEnd; i<size; ++i)
00391     \{
00392       Scalar xi = x[i];
00393       Scalar yi = y[i];
00394       x[i] =  c * xi + numext::conj(s) * yi;
00395       y[i] = -s * xi + numext::conj(c) * yi;
00396     \}
00397   \}
00398 
00399   \textcolor{comment}{/*** fixed-size vectorized path ***/}
00400   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(VectorX::SizeAtCompileTime != \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} &&
00401           (VectorX::Flags & VectorY::Flags & PacketAccessBit) &&
00402           (PacketSize == OtherPacketSize) &&
00403           (EIGEN\_PLAIN\_ENUM\_MIN(evaluator<VectorX>::Alignment, evaluator<VectorY>::Alignment)>0)) \textcolor{comment}{// FIXME
       should be compared to the required alignment}
00404   \{
00405     \textcolor{keyword}{const} OtherPacket pc = pset1<OtherPacket>(c);
00406     \textcolor{keyword}{const} OtherPacket ps = pset1<OtherPacket>(s);
00407     conj\_helper<OtherPacket,Packet,NumTraits<OtherPacket>::IsComplex,\textcolor{keyword}{false}> pcj;
00408     conj\_helper<OtherPacket,Packet,false,false> pm;
00409     Scalar* EIGEN\_RESTRICT px = x;
00410     Scalar* EIGEN\_RESTRICT py = y;
00411     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<size; i+=PacketSize)
00412     \{
00413       Packet xi = pload<Packet>(px);
00414       Packet yi = pload<Packet>(py);
00415       pstore(px, padd(pm.pmul(pc,xi),pcj.pmul(ps,yi)));
00416       pstore(py, psub(pcj.pmul(pc,yi),pm.pmul(ps,xi)));
00417       px += PacketSize;
00418       py += PacketSize;
00419     \}
00420   \}
00421 
00422   \textcolor{comment}{/*** non-vectorized path ***/}
00423   \textcolor{keywordflow}{else}
00424   \{
00425     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<size; ++i)
00426     \{
00427       Scalar xi = *x;
00428       Scalar yi = *y;
00429       *x =  c * xi + numext::conj(s) * yi;
00430       *y = -s * xi + numext::conj(c) * yi;
00431       x += incrx;
00432       y += incry;
00433     \}
00434   \}
00435 \}
00436 
00437 \} \textcolor{comment}{// end namespace internal}
00438 
00439 \} \textcolor{comment}{// end namespace Eigen}
00440 
00441 \textcolor{preprocessor}{#endif // EIGEN\_JACOBI\_H}
\end{DoxyCode}
