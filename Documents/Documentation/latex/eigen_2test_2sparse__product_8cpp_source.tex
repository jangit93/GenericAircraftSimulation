\hypertarget{eigen_2test_2sparse__product_8cpp_source}{}\section{eigen/test/sparse\+\_\+product.cpp}
\label{eigen_2test_2sparse__product_8cpp_source}\index{sparse\+\_\+product.\+cpp@{sparse\+\_\+product.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2011 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{keyword}{static} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} nb\_temporaries;
00011 
00012 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} on\_temporary\_creation() \{
00013   \textcolor{comment}{// here's a great place to set a breakpoint when debugging failures in this test!}
00014   nb\_temporaries++;
00015 \}
00016 
00017 \textcolor{preprocessor}{#define EIGEN\_SPARSE\_CREATE\_TEMPORARY\_PLUGIN \{ on\_temporary\_creation(); \}}
00018 
00019 \textcolor{preprocessor}{#include "sparse.h"}
00020 
00021 \textcolor{preprocessor}{#define VERIFY\_EVALUATION\_COUNT(XPR,N) \{\(\backslash\)}
00022 \textcolor{preprocessor}{    nb\_temporaries = 0; \(\backslash\)}
00023 \textcolor{preprocessor}{    CALL\_SUBTEST( XPR ); \(\backslash\)}
00024 \textcolor{preprocessor}{    if(nb\_temporaries!=N) std::cerr << "nb\_temporaries == " << nb\_temporaries << "\(\backslash\)n"; \(\backslash\)}
00025 \textcolor{preprocessor}{    VERIFY( (#XPR) && nb\_temporaries==N ); \(\backslash\)}
00026 \textcolor{preprocessor}{  \}}
00027 
00028 
00029 
00030 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseMatrixType> \textcolor{keywordtype}{void} sparse\_product()
00031 \{
00032   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::StorageIndex StorageIndex;
00033   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = 100;
00034   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows  = internal::random<Index>(1,n);
00035   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols  = internal::random<Index>(1,n);
00036   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth = internal::random<Index>(1,n);
00037   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::Scalar Scalar;
00038   \textcolor{keyword}{enum} \{ Flags = SparseMatrixType::Flags \};
00039 
00040   \textcolor{keywordtype}{double} density = (std::max)(8./(rows*cols), 0.2);
00041   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} 
      \hyperlink{group___core___module}{DenseMatrix};
00042   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} \hyperlink{group___core___module}{DenseVector};
00043   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,1,Dynamic>} RowDenseVector;
00044   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_vector}{SparseVector<Scalar,0,StorageIndex>} ColSpVector;
00045   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_vector}{SparseVector<Scalar,RowMajor,StorageIndex>} RowSpVector;
00046 
00047   Scalar s1 = internal::random<Scalar>();
00048   Scalar s2 = internal::random<Scalar>();
00049 
00050   \textcolor{comment}{// test matrix-matrix product}
00051   \{
00052     DenseMatrix refMat2  = DenseMatrix::Zero(rows, depth);
00053     DenseMatrix refMat2t = DenseMatrix::Zero(depth, rows);
00054     DenseMatrix refMat3  = DenseMatrix::Zero(depth, cols);
00055     DenseMatrix refMat3t = DenseMatrix::Zero(cols, depth);
00056     DenseMatrix refMat4  = DenseMatrix::Zero(rows, cols);
00057     DenseMatrix refMat4t = DenseMatrix::Zero(cols, rows);
00058     DenseMatrix refMat5  = DenseMatrix::Random(depth, cols);
00059     DenseMatrix refMat6  = DenseMatrix::Random(rows, rows);
00060     DenseMatrix dm4 = DenseMatrix::Zero(rows, rows);
00061 \textcolor{comment}{//     DenseVector dv1 = DenseVector::Random(rows);}
00062     SparseMatrixType m2 (rows, depth);
00063     SparseMatrixType m2t(depth, rows);
00064     SparseMatrixType m3 (depth, cols);
00065     SparseMatrixType m3t(cols, depth);
00066     SparseMatrixType m4 (rows, cols);
00067     SparseMatrixType m4t(cols, rows);
00068     SparseMatrixType m6(rows, rows);
00069     initSparse(density, refMat2,  m2);
00070     initSparse(density, refMat2t, m2t);
00071     initSparse(density, refMat3,  m3);
00072     initSparse(density, refMat3t, m3t);
00073     initSparse(density, refMat4,  m4);
00074     initSparse(density, refMat4t, m4t);
00075     initSparse(density, refMat6, m6);
00076 
00077 \textcolor{comment}{//     int c = internal::random<int>(0,depth-1);}
00078 
00079     \textcolor{comment}{// sparse * sparse}
00080     VERIFY\_IS\_APPROX(m4=m2*m3, refMat4=refMat2*refMat3);
00081     VERIFY\_IS\_APPROX(m4=m2t.transpose()*m3, refMat4=refMat2t.transpose()*refMat3);
00082     VERIFY\_IS\_APPROX(m4=m2t.transpose()*m3t.transpose(), refMat4=refMat2t.transpose()*refMat3t.transpose())
      ;
00083     VERIFY\_IS\_APPROX(m4=m2*m3t.transpose(), refMat4=refMat2*refMat3t.transpose());
00084 
00085     VERIFY\_IS\_APPROX(m4 = m2*m3/s1, refMat4 = refMat2*refMat3/s1);
00086     VERIFY\_IS\_APPROX(m4 = m2*m3*s1, refMat4 = refMat2*refMat3*s1);
00087     VERIFY\_IS\_APPROX(m4 = s2*m2*m3*s1, refMat4 = s2*refMat2*refMat3*s1);
00088     VERIFY\_IS\_APPROX(m4 = (m2+m2)*m3, refMat4 = (refMat2+refMat2)*refMat3);
00089     VERIFY\_IS\_APPROX(m4 = m2*m3.leftCols(cols/2), refMat4 = refMat2*refMat3.leftCols(cols/2));
00090     VERIFY\_IS\_APPROX(m4 = m2*(m3+m3).leftCols(cols/2), refMat4 = refMat2*(refMat3+refMat3).leftCols(cols/2)
      );
00091 
00092     VERIFY\_IS\_APPROX(m4=(m2*m3).pruned(0), refMat4=refMat2*refMat3);
00093     VERIFY\_IS\_APPROX(m4=(m2t.transpose()*m3).pruned(0), refMat4=refMat2t.transpose()*refMat3);
00094     VERIFY\_IS\_APPROX(m4=(m2t.transpose()*m3t.transpose()).pruned(0), refMat4=refMat2t.transpose()*refMat3t.
      transpose());
00095     VERIFY\_IS\_APPROX(m4=(m2*m3t.transpose()).pruned(0), refMat4=refMat2*refMat3t.transpose());
00096 
00097     \textcolor{comment}{// make sure the right product implementation is called:}
00098     \textcolor{keywordflow}{if}((!SparseMatrixType::IsRowMajor) && m2.rows()<=m3.cols())
00099     \{
00100       VERIFY\_EVALUATION\_COUNT(m4 = m2*m3, 3); \textcolor{comment}{// 1 temp for the result + 2 for transposing and get a sorted
       result.}
00101       VERIFY\_EVALUATION\_COUNT(m4 = (m2*m3).pruned(0), 1);
00102       VERIFY\_EVALUATION\_COUNT(m4 = (m2*m3).eval().pruned(0), 4);
00103     \}
00104 
00105     \textcolor{comment}{// and that pruning is effective:}
00106     \{
00107       DenseMatrix Ad(2,2);
00108       Ad << -1, 1, 1, 1;
00109       SparseMatrixType As(Ad.sparseView()), \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}(2,2);
00110       VERIFY\_IS\_EQUAL( (As*As.transpose()).eval().nonZeros(), 4);
00111       VERIFY\_IS\_EQUAL( (Ad*Ad.transpose()).eval().sparseView().eval().nonZeros(), 2);
00112       VERIFY\_IS\_EQUAL( (As*As.transpose()).pruned(1e-6).eval().nonZeros(), 2);
00113     \}
00114 
00115     \textcolor{comment}{// dense ?= sparse * sparse}
00116     VERIFY\_IS\_APPROX(dm4 =m2*m3, refMat4 =refMat2*refMat3);
00117     VERIFY\_IS\_APPROX(dm4+=m2*m3, refMat4+=refMat2*refMat3);
00118     VERIFY\_IS\_APPROX(dm4-=m2*m3, refMat4-=refMat2*refMat3);
00119     VERIFY\_IS\_APPROX(dm4 =m2t.transpose()*m3, refMat4 =refMat2t.transpose()*refMat3);
00120     VERIFY\_IS\_APPROX(dm4+=m2t.transpose()*m3, refMat4+=refMat2t.transpose()*refMat3);
00121     VERIFY\_IS\_APPROX(dm4-=m2t.transpose()*m3, refMat4-=refMat2t.transpose()*refMat3);
00122     VERIFY\_IS\_APPROX(dm4 =m2t.transpose()*m3t.transpose(), refMat4 =refMat2t.transpose()*refMat3t.transpose
      ());
00123     VERIFY\_IS\_APPROX(dm4+=m2t.transpose()*m3t.transpose(), refMat4+=refMat2t.transpose()*refMat3t.transpose
      ());
00124     VERIFY\_IS\_APPROX(dm4-=m2t.transpose()*m3t.transpose(), refMat4-=refMat2t.transpose()*refMat3t.transpose
      ());
00125     VERIFY\_IS\_APPROX(dm4 =m2*m3t.transpose(), refMat4 =refMat2*refMat3t.transpose());
00126     VERIFY\_IS\_APPROX(dm4+=m2*m3t.transpose(), refMat4+=refMat2*refMat3t.transpose());
00127     VERIFY\_IS\_APPROX(dm4-=m2*m3t.transpose(), refMat4-=refMat2*refMat3t.transpose());
00128     VERIFY\_IS\_APPROX(dm4 = m2*m3*s1, refMat4 = refMat2*refMat3*s1);
00129 
00130     \textcolor{comment}{// test aliasing}
00131     m4 = m2; refMat4 = refMat2;
00132     VERIFY\_IS\_APPROX(m4=m4*m3, refMat4=refMat4*refMat3);
00133 
00134     \textcolor{comment}{// sparse * dense matrix}
00135     VERIFY\_IS\_APPROX(dm4=m2*refMat3, refMat4=refMat2*refMat3);
00136     VERIFY\_IS\_APPROX(dm4=m2*refMat3t.transpose(), refMat4=refMat2*refMat3t.transpose());
00137     VERIFY\_IS\_APPROX(dm4=m2t.transpose()*refMat3, refMat4=refMat2t.transpose()*refMat3);
00138     VERIFY\_IS\_APPROX(dm4=m2t.transpose()*refMat3t.transpose(), refMat4=refMat2t.transpose()*refMat3t.
      transpose());
00139 
00140     VERIFY\_IS\_APPROX(dm4=m2*refMat3, refMat4=refMat2*refMat3);
00141     VERIFY\_IS\_APPROX(dm4=dm4+m2*refMat3, refMat4=refMat4+refMat2*refMat3);
00142     VERIFY\_IS\_APPROX(dm4+=m2*refMat3, refMat4+=refMat2*refMat3);
00143     VERIFY\_IS\_APPROX(dm4-=m2*refMat3, refMat4-=refMat2*refMat3);
00144     VERIFY\_IS\_APPROX(dm4.noalias()+=m2*refMat3, refMat4+=refMat2*refMat3);
00145     VERIFY\_IS\_APPROX(dm4.noalias()-=m2*refMat3, refMat4-=refMat2*refMat3);
00146     VERIFY\_IS\_APPROX(dm4=m2*(refMat3+refMat3), refMat4=refMat2*(refMat3+refMat3));
00147     VERIFY\_IS\_APPROX(dm4=m2t.transpose()*(refMat3+refMat5)*0.5, refMat4=refMat2t.transpose()*(refMat3+
      refMat5)*0.5);
00148     
00149     \textcolor{comment}{// sparse * dense vector}
00150     VERIFY\_IS\_APPROX(dm4.col(0)=m2*refMat3.col(0), refMat4.col(0)=refMat2*refMat3.col(0));
00151     VERIFY\_IS\_APPROX(dm4.col(0)=m2*refMat3t.transpose().col(0), refMat4.col(0)=refMat2*refMat3t.transpose()
      .col(0));
00152     VERIFY\_IS\_APPROX(dm4.col(0)=m2t.transpose()*refMat3.col(0), refMat4.col(0)=refMat2t.transpose()*refMat3
      .col(0));
00153     VERIFY\_IS\_APPROX(dm4.col(0)=m2t.transpose()*refMat3t.transpose().col(0), refMat4.col(0)=refMat2t.
      transpose()*refMat3t.transpose().col(0));
00154 
00155     \textcolor{comment}{// dense * sparse}
00156     VERIFY\_IS\_APPROX(dm4=refMat2*m3, refMat4=refMat2*refMat3);
00157     VERIFY\_IS\_APPROX(dm4=dm4+refMat2*m3, refMat4=refMat4+refMat2*refMat3);
00158     VERIFY\_IS\_APPROX(dm4+=refMat2*m3, refMat4+=refMat2*refMat3);
00159     VERIFY\_IS\_APPROX(dm4-=refMat2*m3, refMat4-=refMat2*refMat3);
00160     VERIFY\_IS\_APPROX(dm4.noalias()+=refMat2*m3, refMat4+=refMat2*refMat3);
00161     VERIFY\_IS\_APPROX(dm4.noalias()-=refMat2*m3, refMat4-=refMat2*refMat3);
00162     VERIFY\_IS\_APPROX(dm4=refMat2*m3t.transpose(), refMat4=refMat2*refMat3t.transpose());
00163     VERIFY\_IS\_APPROX(dm4=refMat2t.transpose()*m3, refMat4=refMat2t.transpose()*refMat3);
00164     VERIFY\_IS\_APPROX(dm4=refMat2t.transpose()*m3t.transpose(), refMat4=refMat2t.transpose()*refMat3t.
      transpose());
00165 
00166     \textcolor{comment}{// sparse * dense and dense * sparse outer product}
00167     \{
00168       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} c  = internal::random<Index>(0,depth-1);
00169       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} r  = internal::random<Index>(0,rows-1);
00170       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} c1 = internal::random<Index>(0,cols-1);
00171       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} r1 = internal::random<Index>(0,depth-1);
00172       DenseMatrix dm5  = DenseMatrix::Random(depth, cols);
00173 
00174       VERIFY\_IS\_APPROX( m4=m2.col(c)*dm5.col(c1).transpose(), refMat4=refMat2.col(c)*dm5.col(c1).transpose(
      ));
00175       VERIFY\_IS\_EQUAL(m4.nonZeros(), (refMat4.array()!=0).count());
00176       VERIFY\_IS\_APPROX( m4=m2.middleCols(c,1)*dm5.col(c1).transpose(), refMat4=refMat2.col(c)*dm5.col(c1).
      transpose());
00177       VERIFY\_IS\_EQUAL(m4.nonZeros(), (refMat4.array()!=0).count());
00178       VERIFY\_IS\_APPROX(dm4=m2.col(c)*dm5.col(c1).transpose(), refMat4=refMat2.col(c)*dm5.col(c1).transpose(
      ));
00179       
00180       VERIFY\_IS\_APPROX(m4=dm5.col(c1)*m2.col(c).transpose(), refMat4=dm5.col(c1)*refMat2.col(c).transpose()
      );
00181       VERIFY\_IS\_EQUAL(m4.nonZeros(), (refMat4.array()!=0).count());
00182       VERIFY\_IS\_APPROX(m4=dm5.col(c1)*m2.middleCols(c,1).transpose(), refMat4=dm5.col(c1)*refMat2.col(c).
      transpose());
00183       VERIFY\_IS\_EQUAL(m4.nonZeros(), (refMat4.array()!=0).count());
00184       VERIFY\_IS\_APPROX(dm4=dm5.col(c1)*m2.col(c).transpose(), refMat4=dm5.col(c1)*refMat2.col(c).transpose(
      ));
00185 
00186       VERIFY\_IS\_APPROX( m4=dm5.row(r1).transpose()*m2.col(c).transpose(), refMat4=dm5.row(r1).transpose()*
      refMat2.col(c).transpose());
00187       VERIFY\_IS\_EQUAL(m4.nonZeros(), (refMat4.array()!=0).count());
00188       VERIFY\_IS\_APPROX(dm4=dm5.row(r1).transpose()*m2.col(c).transpose(), refMat4=dm5.row(r1).transpose()*
      refMat2.col(c).transpose());
00189 
00190       VERIFY\_IS\_APPROX( m4=m2.row(r).transpose()*dm5.col(c1).transpose(), refMat4=refMat2.row(r).transpose(
      )*dm5.col(c1).transpose());
00191       VERIFY\_IS\_EQUAL(m4.nonZeros(), (refMat4.array()!=0).count());
00192       VERIFY\_IS\_APPROX( m4=m2.middleRows(r,1).transpose()*dm5.col(c1).transpose(), refMat4=refMat2.row(r).
      transpose()*dm5.col(c1).transpose());
00193       VERIFY\_IS\_EQUAL(m4.nonZeros(), (refMat4.array()!=0).count());
00194       VERIFY\_IS\_APPROX(dm4=m2.row(r).transpose()*dm5.col(c1).transpose(), refMat4=refMat2.row(r).transpose(
      )*dm5.col(c1).transpose());
00195 
00196       VERIFY\_IS\_APPROX( m4=dm5.col(c1)*m2.row(r), refMat4=dm5.col(c1)*refMat2.row(r));
00197       VERIFY\_IS\_EQUAL(m4.nonZeros(), (refMat4.array()!=0).count());
00198       VERIFY\_IS\_APPROX( m4=dm5.col(c1)*m2.middleRows(r,1), refMat4=dm5.col(c1)*refMat2.row(r));
00199       VERIFY\_IS\_EQUAL(m4.nonZeros(), (refMat4.array()!=0).count());
00200       VERIFY\_IS\_APPROX(dm4=dm5.col(c1)*m2.row(r), refMat4=dm5.col(c1)*refMat2.row(r));
00201 
00202       VERIFY\_IS\_APPROX( m4=dm5.row(r1).transpose()*m2.row(r), refMat4=dm5.row(r1).transpose()*refMat2.row(r
      ));
00203       VERIFY\_IS\_EQUAL(m4.nonZeros(), (refMat4.array()!=0).count());
00204       VERIFY\_IS\_APPROX(dm4=dm5.row(r1).transpose()*m2.row(r), refMat4=dm5.row(r1).transpose()*refMat2.row(r
      ));
00205     \}
00206 
00207     VERIFY\_IS\_APPROX(m6=m6*m6, refMat6=refMat6*refMat6);
00208     
00209     \textcolor{comment}{// sparse matrix * sparse vector}
00210     ColSpVector cv0(cols), cv1;
00211     DenseVector dcv0(cols), dcv1;
00212     initSparse(2*density,dcv0, cv0);
00213     
00214     RowSpVector rv0(depth), rv1;
00215     RowDenseVector drv0(depth), drv1(rv1);
00216     initSparse(2*density,drv0, rv0);
00217 
00218     VERIFY\_IS\_APPROX(cv1=m3*cv0, dcv1=refMat3*dcv0);    
00219     VERIFY\_IS\_APPROX(rv1=rv0*m3, drv1=drv0*refMat3);
00220     VERIFY\_IS\_APPROX(cv1=m3t.adjoint()*cv0, dcv1=refMat3t.adjoint()*dcv0);
00221     VERIFY\_IS\_APPROX(cv1=rv0*m3, dcv1=drv0*refMat3);
00222     VERIFY\_IS\_APPROX(rv1=m3*cv0, drv1=refMat3*dcv0);
00223   \}
00224   
00225   \textcolor{comment}{// test matrix - diagonal product}
00226   \{
00227     DenseMatrix refM2 = DenseMatrix::Zero(rows, cols);
00228     DenseMatrix refM3 = DenseMatrix::Zero(rows, cols);
00229     DenseMatrix d3 = DenseMatrix::Zero(rows, cols);
00230     \hyperlink{group___core___module_class_eigen_1_1_diagonal_matrix}{DiagonalMatrix<Scalar,Dynamic>} d1(DenseVector::Random(cols));
00231     \hyperlink{group___core___module_class_eigen_1_1_diagonal_matrix}{DiagonalMatrix<Scalar,Dynamic>} d2(DenseVector::Random(rows));
00232     SparseMatrixType m2(rows, cols);
00233     SparseMatrixType m3(rows, cols);
00234     initSparse<Scalar>(density, refM2, m2);
00235     initSparse<Scalar>(density, refM3, m3);
00236     VERIFY\_IS\_APPROX(m3=m2*d1, refM3=refM2*d1);
00237     VERIFY\_IS\_APPROX(m3=m2.transpose()*d2, refM3=refM2.transpose()*d2);
00238     VERIFY\_IS\_APPROX(m3=d2*m2, refM3=d2*refM2);
00239     VERIFY\_IS\_APPROX(m3=d1*m2.transpose(), refM3=d1*refM2.transpose());
00240     
00241     \textcolor{comment}{// also check with a SparseWrapper:}
00242     DenseVector v1 = DenseVector::Random(cols);
00243     DenseVector v2 = DenseVector::Random(rows);
00244     DenseVector v3 = DenseVector::Random(rows);
00245     VERIFY\_IS\_APPROX(m3=m2*v1.asDiagonal(), refM3=refM2*v1.asDiagonal());
00246     VERIFY\_IS\_APPROX(m3=m2.transpose()*v2.asDiagonal(), refM3=refM2.transpose()*v2.asDiagonal());
00247     VERIFY\_IS\_APPROX(m3=v2.asDiagonal()*m2, refM3=v2.asDiagonal()*refM2);
00248     VERIFY\_IS\_APPROX(m3=v1.asDiagonal()*m2.transpose(), refM3=v1.asDiagonal()*refM2.transpose());
00249     
00250     VERIFY\_IS\_APPROX(m3=v2.asDiagonal()*m2*v1.asDiagonal(), refM3=v2.asDiagonal()*refM2*v1.asDiagonal());
00251 
00252     VERIFY\_IS\_APPROX(v2=m2*v1.asDiagonal()*v1, refM2*v1.asDiagonal()*v1);
00253     VERIFY\_IS\_APPROX(v3=v2.asDiagonal()*m2*v1, v2.asDiagonal()*refM2*v1);
00254     
00255     \textcolor{comment}{// evaluate to a dense matrix to check the .row() and .col() iterator functions}
00256     VERIFY\_IS\_APPROX(d3=m2*d1, refM3=refM2*d1);
00257     VERIFY\_IS\_APPROX(d3=m2.transpose()*d2, refM3=refM2.transpose()*d2);
00258     VERIFY\_IS\_APPROX(d3=d2*m2, refM3=d2*refM2);
00259     VERIFY\_IS\_APPROX(d3=d1*m2.transpose(), refM3=d1*refM2.transpose());
00260   \}
00261 
00262   \textcolor{comment}{// test self-adjoint and triangular-view products}
00263   \{
00264     DenseMatrix b = DenseMatrix::Random(rows, rows);
00265     DenseMatrix x = DenseMatrix::Random(rows, rows);
00266     DenseMatrix refX = DenseMatrix::Random(rows, rows);
00267     DenseMatrix refUp = DenseMatrix::Zero(rows, rows);
00268     DenseMatrix refLo = DenseMatrix::Zero(rows, rows);
00269     DenseMatrix refS = DenseMatrix::Zero(rows, rows);
00270     DenseMatrix refA = DenseMatrix::Zero(rows, rows);
00271     SparseMatrixType mUp(rows, rows);
00272     SparseMatrixType mLo(rows, rows);
00273     SparseMatrixType mS(rows, rows);
00274     SparseMatrixType mA(rows, rows);
00275     initSparse<Scalar>(density, refA, mA);
00276     \textcolor{keywordflow}{do} \{
00277       initSparse<Scalar>(density, refUp, mUp, ForceRealDiag|\textcolor{comment}{/*ForceNonZeroDiag|*/}MakeUpperTriangular);
00278     \} \textcolor{keywordflow}{while} (refUp.isZero());
00279     refLo = refUp.adjoint();
00280     mLo = mUp.adjoint();
00281     refS = refUp + refLo;
00282     refS.diagonal() *= 0.5;
00283     mS = mUp + mLo;
00284     \textcolor{comment}{// TODO be able to address the diagonal....}
00285     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<mS.outerSize(); ++k)
00286       \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} SparseMatrixType::InnerIterator it(mS,k); it; ++it)
00287         \textcolor{keywordflow}{if} (it.index() == k)
00288           it.valueRef() *= Scalar(0.5);
00289 
00290     VERIFY\_IS\_APPROX(refS.adjoint(), refS);
00291     VERIFY\_IS\_APPROX(mS.adjoint(), mS);
00292     VERIFY\_IS\_APPROX(mS, refS);
00293     VERIFY\_IS\_APPROX(x=mS*b, refX=refS*b);
00294 
00295     \textcolor{comment}{// sparse selfadjointView with dense matrices}
00296     VERIFY\_IS\_APPROX(x=mUp.template selfadjointView<Upper>()*b, refX=refS*b);
00297     VERIFY\_IS\_APPROX(x=mLo.template selfadjointView<Lower>()*b, refX=refS*b);
00298     VERIFY\_IS\_APPROX(x=mS.template selfadjointView<Upper|Lower>()*b, refX=refS*b);
00299 
00300     VERIFY\_IS\_APPROX(x=b * mUp.template selfadjointView<Upper>(),       refX=b*refS);
00301     VERIFY\_IS\_APPROX(x=b * mLo.template selfadjointView<Lower>(),       refX=b*refS);
00302     VERIFY\_IS\_APPROX(x=b * mS.template selfadjointView<Upper|Lower>(),  refX=b*refS);
00303 
00304     VERIFY\_IS\_APPROX(x.noalias()+=mUp.template selfadjointView<Upper>()*b, refX+=refS*b);
00305     VERIFY\_IS\_APPROX(x.noalias()-=mLo.template selfadjointView<Lower>()*b, refX-=refS*b);
00306     VERIFY\_IS\_APPROX(x.noalias()+=mS.template selfadjointView<Upper|Lower>()*b, refX+=refS*b);
00307     
00308     \textcolor{comment}{// sparse selfadjointView with sparse matrices}
00309     SparseMatrixType mSres(rows,rows);
00310     VERIFY\_IS\_APPROX(mSres = mLo.template selfadjointView<Lower>()*mS,
00311                      refX = refLo.template selfadjointView<Lower>()*refS);
00312     VERIFY\_IS\_APPROX(mSres = mS * mLo.template selfadjointView<Lower>(),
00313                      refX = refS * refLo.template selfadjointView<Lower>());
00314     
00315     \textcolor{comment}{// sparse triangularView with dense matrices}
00316     VERIFY\_IS\_APPROX(x=mA.template triangularView<Upper>()*b, refX=refA.template triangularView<Upper>()*b)
      ;
00317     VERIFY\_IS\_APPROX(x=mA.template triangularView<Lower>()*b, refX=refA.template triangularView<Lower>()*b)
      ;
00318     VERIFY\_IS\_APPROX(x=b*mA.template triangularView<Upper>(), refX=b*refA.template triangularView<Upper>())
      ;
00319     VERIFY\_IS\_APPROX(x=b*mA.template triangularView<Lower>(), refX=b*refA.template triangularView<Lower>())
      ;
00320     
00321     \textcolor{comment}{// sparse triangularView with sparse matrices}
00322     VERIFY\_IS\_APPROX(mSres = mA.template triangularView<Lower>()*mS,   refX = refA.template 
      triangularView<Lower>()*refS);
00323     VERIFY\_IS\_APPROX(mSres = mS * mA.template triangularView<Lower>(), refX = refS * refA.template 
      triangularView<Lower>());
00324     VERIFY\_IS\_APPROX(mSres = mA.template triangularView<Upper>()*mS,   refX = refA.template 
      triangularView<Upper>()*refS);
00325     VERIFY\_IS\_APPROX(mSres = mS * mA.template triangularView<Upper>(), refX = refS * refA.template 
      triangularView<Upper>());
00326   \}
00327 \}
00328 
00329 \textcolor{comment}{// New test for Bug in SparseTimeDenseProduct}
00330 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseMatrixType, \textcolor{keyword}{typename} DenseMatrixType> \textcolor{keywordtype}{void} sparse\_product\_regression\_test()
00331 \{
00332   \textcolor{comment}{// This code does not compile with afflicted versions of the bug}
00333   SparseMatrixType sm1(3,2);
00334   DenseMatrixType m2(2,2);
00335   sm1.setZero();
00336   m2.setZero();
00337 
00338   DenseMatrixType m3 = sm1*m2;
00339 
00340 
00341   \textcolor{comment}{// This code produces a segfault with afflicted versions of another SparseTimeDenseProduct}
00342   \textcolor{comment}{// bug}
00343 
00344   SparseMatrixType sm2(20000,2);
00345   sm2.setZero();
00346   DenseMatrixType m4(sm2*m2);
00347 
00348   VERIFY\_IS\_APPROX( m4(0,0), 0.0 );
00349 \}
00350 
00351 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00352 \textcolor{keywordtype}{void} bug\_942()
00353 \{
00354   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>}     Vector;
00355   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar, ColMajor>} ColSpMat;
00356   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar, RowMajor>} RowSpMat;
00357   ColSpMat cmA(1,1);
00358   cmA.insert(0,0) = 1;
00359 
00360   RowSpMat rmA(1,1);
00361   rmA.insert(0,0) = 1;
00362 
00363   Vector d(1);
00364   d[0] = 2;
00365   
00366   \textcolor{keywordtype}{double} res = 2;
00367   
00368   VERIFY\_IS\_APPROX( ( cmA*d.asDiagonal() ).eval().coeff(0,0), res );
00369   VERIFY\_IS\_APPROX( ( d.asDiagonal()*rmA ).eval().coeff(0,0), res );
00370   VERIFY\_IS\_APPROX( ( rmA*d.asDiagonal() ).eval().coeff(0,0), res );
00371   VERIFY\_IS\_APPROX( ( d.asDiagonal()*cmA ).eval().coeff(0,0), res );
00372 \}
00373 
00374 \textcolor{keywordtype}{void} test\_sparse\_product()
00375 \{
00376   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00377     CALL\_SUBTEST\_1( (sparse\_product<\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double,ColMajor>} >()) );
00378     CALL\_SUBTEST\_1( (sparse\_product<\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double,RowMajor>} >()) );
00379     CALL\_SUBTEST\_1( (bug\_942<double>()) );
00380     CALL\_SUBTEST\_2( (sparse\_product<\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix}<std::complex<double>, 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor} > >()) );
00381     CALL\_SUBTEST\_2( (sparse\_product<\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix}<std::complex<double>, 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} > >()) );
00382     CALL\_SUBTEST\_3( (sparse\_product<\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<float,ColMajor,long int>}
       >()) );
00383     CALL\_SUBTEST\_4( (sparse\_product\_regression\_test<
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double,RowMajor>}, 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<double, Dynamic, Dynamic, RowMajor>} >()) );
00384   \}
00385 \}
\end{DoxyCode}
