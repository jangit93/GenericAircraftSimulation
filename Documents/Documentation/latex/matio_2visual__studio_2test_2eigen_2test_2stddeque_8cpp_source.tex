\hypertarget{matio_2visual__studio_2test_2eigen_2test_2stddeque_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/stddeque.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2stddeque_8cpp_source}\index{stddeque.\+cpp@{stddeque.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2010 Hauke Heibel <hauke.heibel@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#include "main.h"}
00012 \textcolor{preprocessor}{#include <Eigen/StdDeque>}
00013 \textcolor{preprocessor}{#include <Eigen/Geometry>}
00014 
00015 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00016 \textcolor{keywordtype}{void} check\_stddeque\_matrix(\textcolor{keyword}{const} MatrixType& m)
00017 \{
00018   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00019   
00020   Index rows = m.rows();
00021   Index cols = m.cols();
00022   MatrixType x = MatrixType::Random(rows,cols), y = MatrixType::Random(rows,cols);
00023   std::deque<MatrixType,Eigen::aligned\_allocator<MatrixType> > v(10, MatrixType(rows,cols)), w(20, y);
00024   v.front() = x;
00025   w.front() = w.back();
00026   VERIFY\_IS\_APPROX(w.front(), w.back());
00027   v = w;
00028 
00029   \textcolor{keyword}{typename} std::deque<MatrixType,Eigen::aligned\_allocator<MatrixType> >::iterator vi = v.begin();
00030   \textcolor{keyword}{typename} std::deque<MatrixType,Eigen::aligned\_allocator<MatrixType> >::iterator wi = w.begin();
00031   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00032   \{
00033     VERIFY\_IS\_APPROX(*vi, *wi);
00034     ++vi;
00035     ++wi;
00036   \}
00037 
00038   v.resize(21);  
00039   v.back() = x;
00040   VERIFY\_IS\_APPROX(v.back(), x);
00041   v.resize(22,y);
00042   VERIFY\_IS\_APPROX(v.back(), y);
00043   v.push\_back(x);
00044   VERIFY\_IS\_APPROX(v.back(), x);
00045 \}
00046 
00047 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TransformType>
00048 \textcolor{keywordtype}{void} check\_stddeque\_transform(\textcolor{keyword}{const} TransformType&)
00049 \{
00050   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} TransformType::MatrixType MatrixType;
00051   TransformType x(MatrixType::Random()), y(MatrixType::Random());
00052   std::deque<TransformType,Eigen::aligned\_allocator<TransformType> > v(10), w(20, y);
00053   v.front() = x;
00054   w.front() = w.back();
00055   VERIFY\_IS\_APPROX(w.front(), w.back());
00056   v = w;
00057 
00058   \textcolor{keyword}{typename} std::deque<TransformType,Eigen::aligned\_allocator<TransformType> >::iterator vi = v.begin();
00059   \textcolor{keyword}{typename} std::deque<TransformType,Eigen::aligned\_allocator<TransformType> >::iterator wi = w.begin();
00060   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00061   \{
00062     VERIFY\_IS\_APPROX(*vi, *wi);
00063     ++vi;
00064     ++wi;
00065   \}
00066 
00067   v.resize(21);
00068   v.back() = x;
00069   VERIFY\_IS\_APPROX(v.back(), x);
00070   v.resize(22,y);
00071   VERIFY\_IS\_APPROX(v.back(), y);
00072   v.push\_back(x);
00073   VERIFY\_IS\_APPROX(v.back(), x);
00074 \}
00075 
00076 \textcolor{keyword}{template}<\textcolor{keyword}{typename} QuaternionType>
00077 \textcolor{keywordtype}{void} check\_stddeque\_quaternion(\textcolor{keyword}{const} QuaternionType&)
00078 \{
00079   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} QuaternionType::Coefficients Coefficients;
00080   QuaternionType x(Coefficients::Random()), y(Coefficients::Random());
00081   std::deque<QuaternionType,Eigen::aligned\_allocator<QuaternionType> > v(10), w(20, y);
00082   v.front() = x;
00083   w.front() = w.back();
00084   VERIFY\_IS\_APPROX(w.front(), w.back());
00085   v = w;
00086 
00087   \textcolor{keyword}{typename} std::deque<QuaternionType,Eigen::aligned\_allocator<QuaternionType> >::iterator vi = v.begin();
00088   \textcolor{keyword}{typename} std::deque<QuaternionType,Eigen::aligned\_allocator<QuaternionType> >::iterator wi = w.begin();
00089   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 20; i++)
00090   \{
00091     VERIFY\_IS\_APPROX(*vi, *wi);
00092     ++vi;
00093     ++wi;
00094   \}
00095 
00096   v.resize(21);
00097   v.back() = x;
00098   VERIFY\_IS\_APPROX(v.back(), x);
00099   v.resize(22,y);
00100   VERIFY\_IS\_APPROX(v.back(), y);
00101   v.push\_back(x);
00102   VERIFY\_IS\_APPROX(v.back(), x);
00103 \}
00104 
00105 \textcolor{keywordtype}{void} test\_stddeque()
00106 \{
00107   \textcolor{comment}{// some non vectorizable fixed sizes}
00108   CALL\_SUBTEST\_1(check\_stddeque\_matrix(Vector2f()));
00109   CALL\_SUBTEST\_1(check\_stddeque\_matrix(Matrix3f()));
00110   CALL\_SUBTEST\_2(check\_stddeque\_matrix(Matrix3d()));
00111 
00112   \textcolor{comment}{// some vectorizable fixed sizes}
00113   CALL\_SUBTEST\_1(check\_stddeque\_matrix(Matrix2f()));
00114   CALL\_SUBTEST\_1(check\_stddeque\_matrix(Vector4f()));
00115   CALL\_SUBTEST\_1(check\_stddeque\_matrix(Matrix4f()));
00116   CALL\_SUBTEST\_2(check\_stddeque\_matrix(Matrix4d()));
00117 
00118   \textcolor{comment}{// some dynamic sizes}
00119   CALL\_SUBTEST\_3(check\_stddeque\_matrix(MatrixXd(1,1)));
00120   CALL\_SUBTEST\_3(check\_stddeque\_matrix(VectorXd(20)));
00121   CALL\_SUBTEST\_3(check\_stddeque\_matrix(RowVectorXf(20)));
00122   CALL\_SUBTEST\_3(check\_stddeque\_matrix(MatrixXcf(10,10)));
00123 
00124   \textcolor{comment}{// some Transform}
00125   CALL\_SUBTEST\_4(check\_stddeque\_transform(\hyperlink{group___geometry___module_ga2c1ea05a21899654ee3a2e3f91fa30e0}{Affine2f}()));
00126   CALL\_SUBTEST\_4(check\_stddeque\_transform(\hyperlink{group___geometry___module_ga17e901de8ff882aea7845c5457db6a4f}{Affine3f}()));
00127   CALL\_SUBTEST\_4(check\_stddeque\_transform(\hyperlink{group___geometry___module_gaaffa69d3143826efeb84e5d6c56a4c78}{Affine3d}()));
00128 
00129   \textcolor{comment}{// some Quaternion}
00130   CALL\_SUBTEST\_5(check\_stddeque\_quaternion(\hyperlink{group___geometry___module_ga785b13a5a87f9bf55d4eba51ead2dcf0}{Quaternionf}()));
00131   CALL\_SUBTEST\_5(check\_stddeque\_quaternion(\hyperlink{group___geometry___module_ga6e77eb8b6aae0e04be2db88107dbc642}{Quaterniond}()));
00132 \}
\end{DoxyCode}
