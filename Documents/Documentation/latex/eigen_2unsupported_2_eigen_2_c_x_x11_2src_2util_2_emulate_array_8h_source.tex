\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_emulate_array_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/util/\+Emulate\+Array.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_emulate_array_8h_source}\index{Emulate\+Array.\+h@{Emulate\+Array.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_EMULATE\_ARRAY\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_EMULATE\_ARRAY\_H}
00012 
00013 
00014 
00015 \textcolor{comment}{// The array class is only available starting with cxx11. Emulate our own here}
00016 \textcolor{comment}{// if needed. Beware, msvc still doesn't advertise itself as a c++11 compiler!}
00017 \textcolor{comment}{// Moreover, CUDA doesn't support the STL containers, so we use our own instead.}
00018 \textcolor{preprocessor}{#if (\_\_cplusplus <= 199711L && EIGEN\_COMP\_MSVC < 1900) || defined(\_\_CUDACC\_\_) ||
       defined(EIGEN\_AVOID\_STL\_ARRAY)}
00019 
00020 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_emulate_array_8h_source_l00021}\hyperlink{class_eigen_1_1array}{00021} \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} n> \textcolor{keyword}{class }\hyperlink{class_eigen_1_1array}{array} \{
00022  \textcolor{keyword}{public}:
00023   EIGEN\_DEVICE\_FUNC
00024   EIGEN\_STRONG\_INLINE \hyperlink{group___sparse_core___module}{T}& operator[] (\textcolor{keywordtype}{size\_t} index) \{ \textcolor{keywordflow}{return} values[index]; \}
00025   EIGEN\_DEVICE\_FUNC
00026   EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& operator[] (\textcolor{keywordtype}{size\_t} index)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} values[index]; \}
00027 
00028   EIGEN\_DEVICE\_FUNC
00029   EIGEN\_STRONG\_INLINE \hyperlink{group___sparse_core___module}{T}& front() \{ \textcolor{keywordflow}{return} values[0]; \}
00030   EIGEN\_DEVICE\_FUNC
00031   EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& front()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} values[0]; \}
00032 
00033   EIGEN\_DEVICE\_FUNC
00034   EIGEN\_STRONG\_INLINE \hyperlink{group___sparse_core___module}{T}& back() \{ \textcolor{keywordflow}{return} values[n-1]; \}
00035   EIGEN\_DEVICE\_FUNC
00036   EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& back()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} values[n-1]; \}
00037 
00038   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE
00039   \textcolor{keyword}{static} std::size\_t size() \{ \textcolor{keywordflow}{return} n; \}
00040 
00041   \hyperlink{group___sparse_core___module}{T} values[n];
00042 
00043   EIGEN\_DEVICE\_FUNC
00044   EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1array}{array}() \{ \}
00045   EIGEN\_DEVICE\_FUNC
00046   EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1array}{array}(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v) \{
00047     EIGEN\_STATIC\_ASSERT(n==1, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00048     values[0] = v;
00049   \}
00050   EIGEN\_DEVICE\_FUNC
00051   EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1array}{array}(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v1, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v2) \{
00052     EIGEN\_STATIC\_ASSERT(n==2, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00053     values[0] = v1;
00054     values[1] = v2;
00055   \}
00056   EIGEN\_DEVICE\_FUNC
00057   EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1array}{array}(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v1, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v2, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v3) \{
00058     EIGEN\_STATIC\_ASSERT(n==3, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00059     values[0] = v1;
00060     values[1] = v2;
00061     values[2] = v3;
00062   \}
00063   EIGEN\_DEVICE\_FUNC
00064   EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1array}{array}(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v1, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v2, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v3,
00065                             \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v4) \{
00066     EIGEN\_STATIC\_ASSERT(n==4, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00067     values[0] = v1;
00068     values[1] = v2;
00069     values[2] = v3;
00070     values[3] = v4;
00071   \}
00072   EIGEN\_DEVICE\_FUNC
00073   EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1array}{array}(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v1, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v2, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v3, \textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module}{T}& v4,
00074                             \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v5) \{
00075     EIGEN\_STATIC\_ASSERT(n==5, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00076     values[0] = v1;
00077     values[1] = v2;
00078     values[2] = v3;
00079     values[3] = v4;
00080     values[4] = v5;
00081   \}
00082   EIGEN\_DEVICE\_FUNC
00083   EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1array}{array}(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v1, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v2, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v3, \textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module}{T}& v4,
00084                             \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v5, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v6) \{
00085     EIGEN\_STATIC\_ASSERT(n==6, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00086     values[0] = v1;
00087     values[1] = v2;
00088     values[2] = v3;
00089     values[3] = v4;
00090     values[4] = v5;
00091     values[5] = v6;
00092   \}
00093   EIGEN\_DEVICE\_FUNC
00094   EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1array}{array}(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v1, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v2, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v3, \textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module}{T}& v4,
00095                             \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v5, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v6, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v7) \{
00096     EIGEN\_STATIC\_ASSERT(n==7, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00097     values[0] = v1;
00098     values[1] = v2;
00099     values[2] = v3;
00100     values[3] = v4;
00101     values[4] = v5;
00102     values[5] = v6;
00103     values[6] = v7;
00104   \}
00105   EIGEN\_DEVICE\_FUNC
00106   EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1array}{array}(
00107       \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v1, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v2, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v3, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v4,
00108       \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v5, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v6, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v7, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& v8) \{
00109     EIGEN\_STATIC\_ASSERT(n==8, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00110     values[0] = v1;
00111     values[1] = v2;
00112     values[2] = v3;
00113     values[3] = v4;
00114     values[4] = v5;
00115     values[5] = v6;
00116     values[6] = v7;
00117     values[7] = v8;
00118   \}
00119 
00120 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00121   EIGEN\_DEVICE\_FUNC
00122   EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1array}{array}(std::initializer\_list<T> l) \{
00123     eigen\_assert(l.size() == n);
00124     internal::smart\_copy(l.begin(), l.end(), values);
00125   \}
00126 \textcolor{preprocessor}{#endif}
00127 \};
00128 
00129 
00130 \textcolor{comment}{// Specialize array for zero size}
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_emulate_array_8h_source_l00131}\hyperlink{class_eigen_1_1array_3_01_t_00_010_01_4}{00131} \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }\hyperlink{class_eigen_1_1array}{array}<\hyperlink{group___sparse_core___module}{T}, 0> \{
00132  \textcolor{keyword}{public}:
00133   EIGEN\_DEVICE\_FUNC
00134   EIGEN\_STRONG\_INLINE \hyperlink{group___sparse_core___module}{T}& operator[] (\textcolor{keywordtype}{size\_t}) \{
00135     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Can't index a zero size array"});
00136     \textcolor{keywordflow}{return} dummy;
00137   \}
00138   EIGEN\_DEVICE\_FUNC
00139   EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& operator[] (\textcolor{keywordtype}{size\_t})\textcolor{keyword}{ const }\{
00140     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Can't index a zero size array"});
00141     \textcolor{keywordflow}{return} dummy;
00142   \}
00143 
00144   EIGEN\_DEVICE\_FUNC
00145   EIGEN\_STRONG\_INLINE \hyperlink{group___sparse_core___module}{T}& front() \{
00146     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Can't index a zero size array"});
00147     \textcolor{keywordflow}{return} dummy;
00148   \}
00149   EIGEN\_DEVICE\_FUNC
00150   EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& front()\textcolor{keyword}{ const }\{
00151     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Can't index a zero size array"});
00152     \textcolor{keywordflow}{return} dummy;
00153   \}
00154   EIGEN\_DEVICE\_FUNC
00155   EIGEN\_STRONG\_INLINE \hyperlink{group___sparse_core___module}{T}& back() \{
00156     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Can't index a zero size array"});
00157     \textcolor{keywordflow}{return} dummy;
00158   \}
00159   EIGEN\_DEVICE\_FUNC
00160   EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& back()\textcolor{keyword}{ const }\{
00161     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Can't index a zero size array"});
00162     \textcolor{keywordflow}{return} dummy;
00163   \}
00164 
00165   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE std::size\_t size() \{ \textcolor{keywordflow}{return} 0; \}
00166 
00167   EIGEN\_DEVICE\_FUNC
00168   EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1array}{array}() : dummy() \{ \}
00169 
00170 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00171   EIGEN\_DEVICE\_FUNC array(std::initializer\_list<T> l) : dummy() \{
00172     eigen\_assert(l.size() == 0);
00173   \}
00174 \textcolor{preprocessor}{#endif}
00175 
00176  \textcolor{keyword}{private}:
00177   \hyperlink{group___sparse_core___module}{T} dummy;
00178 \};
00179 
00180 \textcolor{comment}{// Comparison operator}
00181 \textcolor{comment}{// Todo: implement !=, <, <=, >,  and >=}
00182 \textcolor{keyword}{template}<\textcolor{keyword}{class} T, std::\textcolor{keywordtype}{size\_t} N>
00183 EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1array}{array<T,N>}& lhs, \textcolor{keyword}{const} 
      \hyperlink{class_eigen_1_1array}{array<T,N>}& rhs) \{
00184   \textcolor{keywordflow}{for} (std::size\_t i = 0; i < N; ++i) \{
00185     \textcolor{keywordflow}{if} (lhs[i] != rhs[i]) \{
00186       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00187     \}
00188   \}
00189   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00190 \}
00191 
00192 
00193 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00194 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} I, \textcolor{keyword}{class} T, std::\textcolor{keywordtype}{size\_t} N>
00195 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{group___sparse_core___module}{T}& array\_get(\hyperlink{class_eigen_1_1array}{array<T,N>}& a) \{
00196   \textcolor{keywordflow}{return} a[I];
00197 \}
00198 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} I, \textcolor{keyword}{class} T, std::\textcolor{keywordtype}{size\_t} N>
00199 EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& array\_get(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1array}{array<T,N>}& a) \{
00200   \textcolor{keywordflow}{return} a[I];
00201 \}
00202 
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_emulate_array_8h_source_l00203}\hyperlink{struct_eigen_1_1internal_1_1array__size}{00203} \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size};
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_emulate_array_8h_source_l00204}\hyperlink{struct_eigen_1_1internal_1_1array__size_3_01array_3_01_t_00_01_n_01_4_01_4}{00204} \textcolor{keyword}{template}<\textcolor{keyword}{class} T, std::\textcolor{keywordtype}{size\_t} N> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size}<\hyperlink{class_eigen_1_1array}{array}<\hyperlink{group___sparse_core___module}{T},N> > \{
00205   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} value = N;
00206 \};
00207 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size};
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_emulate_array_8h_source_l00208}\hyperlink{struct_eigen_1_1internal_1_1array__size_3_01array_3_01_t_00_01_n_01_4_01_6_4}{00208} \textcolor{keyword}{template}<\textcolor{keyword}{class} T, std::\textcolor{keywordtype}{size\_t} N> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size}<\hyperlink{class_eigen_1_1array}{array}<\hyperlink{group___sparse_core___module}{T},N>& > \{
00209   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} value = N;
00210 \};
00211 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size};
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_emulate_array_8h_source_l00212}\hyperlink{struct_eigen_1_1internal_1_1array__size_3_01const_01array_3_01_t_00_01_n_01_4_01_4}{00212} \textcolor{keyword}{template}<\textcolor{keyword}{class} T, std::\textcolor{keywordtype}{size\_t} N> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size}<const \hyperlink{class_eigen_1_1array}{array}<\hyperlink{group___sparse_core___module}{T},N> > \{
00213   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} value = N;
00214 \};
00215 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size};
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2util_2_emulate_array_8h_source_l00216}\hyperlink{struct_eigen_1_1internal_1_1array__size_3_01const_01array_3_01_t_00_01_n_01_4_01_6_4}{00216} \textcolor{keyword}{template}<\textcolor{keyword}{class} T, std::\textcolor{keywordtype}{size\_t} N> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size}<const \hyperlink{class_eigen_1_1array}{array}<\hyperlink{group___sparse_core___module}{T},N>& > \{
00217   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} value = N;
00218 \};
00219 
00220 \}  \textcolor{comment}{// end namespace internal}
00221 \}  \textcolor{comment}{// end namespace Eigen}
00222 
00223 \textcolor{preprocessor}{#else}
00224 
00225 \textcolor{comment}{// The compiler supports c++11, and we're not targetting cuda: use std::array as Eigen::array}
00226 \textcolor{preprocessor}{#include <array>}
00227 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00228 
00229 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N> \textcolor{keyword}{using} \hyperlink{class_eigen_1_1array}{array} = std::array<T, N>;
00230 
00231 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00232 \textcolor{comment}{/* std::get is only constexpr in C++14, not yet in C++11}
00233 \textcolor{comment}{ *     - libstdc++ from version 4.7 onwards has it nevertheless,}
00234 \textcolor{comment}{ *                                          so use that}
00235 \textcolor{comment}{ *     - libstdc++ older versions: use \_M\_instance directly}
00236 \textcolor{comment}{ *     - libc++ all versions so far: use \_\_elems\_ directly}
00237 \textcolor{comment}{ *     - all other libs: use std::get to be portable, but}
00238 \textcolor{comment}{ *                       this may not be constexpr}
00239 \textcolor{comment}{ */}
00240 \textcolor{preprocessor}{#if defined(\_\_GLIBCXX\_\_) && \_\_GLIBCXX\_\_ < 20120322}
00241 \textcolor{preprocessor}{#define STD\_GET\_ARR\_HACK             a.\_M\_instance[I]}
00242 \textcolor{preprocessor}{#elif defined(\_LIBCPP\_VERSION)}
00243 \textcolor{preprocessor}{#define STD\_GET\_ARR\_HACK             a.\_\_elems\_[I]}
00244 \textcolor{preprocessor}{#else}
00245 \textcolor{preprocessor}{#define STD\_GET\_ARR\_HACK             std::template get<I, T, N>(a)}
00246 \textcolor{preprocessor}{#endif}
00247 
00248 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} I, \textcolor{keyword}{class} T, std::\textcolor{keywordtype}{size\_t} N> constexpr \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module}{T}&       array\_get(std::array<T,N>&      
       a) \{ \textcolor{keywordflow}{return} (\hyperlink{group___sparse_core___module}{T}&)       STD\_GET\_ARR\_HACK; \}
00249 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} I, \textcolor{keyword}{class} T, std::\textcolor{keywordtype}{size\_t} N> constexpr \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module}{T}&&      array\_get(std::array<T,N>&&     
       a) \{ \textcolor{keywordflow}{return} (\hyperlink{group___sparse_core___module}{T}&&)      STD\_GET\_ARR\_HACK; \}
00250 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} I, \textcolor{keyword}{class} T, std::\textcolor{keywordtype}{size\_t} N> constexpr \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module}{T} \textcolor{keyword}{const}& array\_get(std::array<T,N> \textcolor{keyword}{const}&
       a) \{ \textcolor{keywordflow}{return} (\hyperlink{group___sparse_core___module}{T} \textcolor{keyword}{const}&) STD\_GET\_ARR\_HACK; \}
00251 
00252 \textcolor{preprocessor}{#undef STD\_GET\_ARR\_HACK}
00253 
00254 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size};
00255 \textcolor{keyword}{template}<\textcolor{keyword}{class} T, std::\textcolor{keywordtype}{size\_t} N> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size}<const std::array<T,N> > \{
00256   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} value = N;
00257 \};
00258 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size};
00259 \textcolor{keyword}{template}<\textcolor{keyword}{class} T, std::\textcolor{keywordtype}{size\_t} N> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size}<std::array<T,N> > \{
00260   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} value = N;
00261 \};
00262 \}  \textcolor{comment}{// end namespace internal}
00263 \}  \textcolor{comment}{// end namespace Eigen}
00264 
00265 \textcolor{preprocessor}{#endif}
00266 
00267 \textcolor{preprocessor}{#endif  // EIGEN\_EMULATE\_ARRAY\_H}
\end{DoxyCode}
