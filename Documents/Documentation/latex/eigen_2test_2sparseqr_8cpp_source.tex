\hypertarget{eigen_2test_2sparseqr_8cpp_source}{}\section{eigen/test/sparseqr.cpp}
\label{eigen_2test_2sparseqr_8cpp_source}\index{sparseqr.\+cpp@{sparseqr.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Desire Nuentsa Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{preprocessor}{#include "sparse.h"}
00010 \textcolor{preprocessor}{#include <Eigen/SparseQR>}
00011 
00012 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType,\textcolor{keyword}{typename} DenseMat>
00013 \textcolor{keywordtype}{int} generate\_sparse\_rectangular\_problem(MatrixType& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, DenseMat& dA, \textcolor{keywordtype}{int} maxRows = 300, \textcolor{keywordtype}{int} maxCols = 150)
00014 \{
00015   eigen\_assert(maxRows >= maxCols);
00016   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00017   \textcolor{keywordtype}{int} rows = internal::random<int>(1,maxRows);
00018   \textcolor{keywordtype}{int} cols = internal::random<int>(1,maxCols);
00019   \textcolor{keywordtype}{double} density = (std::max)(8./(rows*cols), 0.01);
00020   
00021   A.resize(rows,cols);
00022   dA.resize(rows,cols);
00023   initSparse<Scalar>(density, dA, A,ForceNonZeroDiag);
00024   A.makeCompressed();
00025   \textcolor{keywordtype}{int} nop = internal::random<int>(0, internal::random<double>(0,1) > 0.5 ? cols/2 : 0);
00026   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<nop; ++k)
00027   \{
00028     \textcolor{keywordtype}{int} j0 = internal::random<int>(0,cols-1);
00029     \textcolor{keywordtype}{int} j1 = internal::random<int>(0,cols-1);
00030     Scalar s = internal::random<Scalar>();
00031     A.col(j0)  = s * A.col(j1);
00032     dA.col(j0) = s * dA.col(j1);
00033   \}
00034   
00035 \textcolor{comment}{//   if(rows<cols) \{}
00036 \textcolor{comment}{//     A.conservativeResize(cols,cols);}
00037 \textcolor{comment}{//     dA.conservativeResize(cols,cols);}
00038 \textcolor{comment}{//     dA.bottomRows(cols-rows).setZero();}
00039 \textcolor{comment}{//   \}}
00040   
00041   \textcolor{keywordflow}{return} rows;
00042 \}
00043 
00044 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} test\_sparseqr\_scalar()
00045 \{
00046   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar,ColMajor>} MatrixType; 
00047   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} DenseMat;
00048   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} \hyperlink{group___core___module}{DenseVector};
00049   MatrixType A;
00050   DenseMat dA;
00051   DenseVector refX,x,b; 
00052   \hyperlink{group___sparse_q_r___module_class_eigen_1_1_sparse_q_r}{SparseQR<MatrixType, COLAMDOrdering<int>} > solver; 
00053   generate\_sparse\_rectangular\_problem(A,dA);
00054   
00055   b = dA * DenseVector::Random(A.cols());
00056   solver.\hyperlink{group___sparse_q_r___module_aedaf52b7543de4d55c58c8f830c2aeb7}{compute}(A);
00057   \textcolor{keywordflow}{if}(internal::random<float>(0,1)>0.5f)
00058     solver.\hyperlink{group___sparse_q_r___module_a55a34bacf05bd30a1dacbccad9f03c6d}{factorize}(A);  \textcolor{comment}{// this checks that calling analyzePattern is not needed if the pattern
       do not change.}
00059   \textcolor{keywordflow}{if} (solver.\hyperlink{group___sparse_q_r___module_a234b0580aaf57237393f2e73a3d38690}{info}() != \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success})
00060   \{
00061     std::cerr << \textcolor{stringliteral}{"sparse QR factorization failed\(\backslash\)n"};
00062     exit(0);
00063     \textcolor{keywordflow}{return};
00064   \}
00065   x = solver.\hyperlink{group___sparse_q_r___module_aea13a2c6823cd8408ba49afde9b3d4e4}{solve}(b);
00066   \textcolor{keywordflow}{if} (solver.\hyperlink{group___sparse_q_r___module_a234b0580aaf57237393f2e73a3d38690}{info}() != \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success})
00067   \{
00068     std::cerr << \textcolor{stringliteral}{"sparse QR factorization failed\(\backslash\)n"};
00069     exit(0);
00070     \textcolor{keywordflow}{return};
00071   \}
00072   
00073   VERIFY\_IS\_APPROX(A * x, b);
00074   
00075   \textcolor{comment}{//Compare with a dense QR solver}
00076   \hyperlink{group___q_r___module_class_eigen_1_1_col_piv_householder_q_r}{ColPivHouseholderQR<DenseMat>} dqr(dA);
00077   refX = dqr.solve(b);
00078   
00079   VERIFY\_IS\_EQUAL(dqr.rank(), solver.\hyperlink{group___sparse_q_r___module_a70ec2b9e5cb62a41dc1ee2adfb54e9b0}{rank}());
00080   \textcolor{keywordflow}{if}(solver.\hyperlink{group___sparse_q_r___module_a70ec2b9e5cb62a41dc1ee2adfb54e9b0}{rank}()==A.cols()) \textcolor{comment}{// full rank}
00081     VERIFY\_IS\_APPROX(x, refX);
00082 \textcolor{comment}{//   else}
00083 \textcolor{comment}{//     VERIFY((dA * refX - b).norm() * 2 > (A * x - b).norm() );}
00084 
00085   \textcolor{comment}{// Compute explicitly the matrix Q}
00086   MatrixType Q, QtQ, idM;
00087   Q = solver.\hyperlink{group___sparse_q_r___module_ae1cc0a836c177d4f42600f8639354be1}{matrixQ}();
00088   \textcolor{comment}{//Check  ||Q' * Q - I ||}
00089   QtQ = Q * Q.adjoint();
00090   idM.resize(Q.rows(), Q.rows()); idM.setIdentity();
00091   VERIFY(idM.isApprox(QtQ));
00092   
00093   \textcolor{comment}{// Q to dense}
00094   DenseMat dQ;
00095   dQ = solver.\hyperlink{group___sparse_q_r___module_ae1cc0a836c177d4f42600f8639354be1}{matrixQ}();
00096   VERIFY\_IS\_APPROX(Q, dQ);
00097 \}
00098 \textcolor{keywordtype}{void} test\_sparseqr()
00099 \{
00100   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<g\_repeat; ++i)
00101   \{
00102     CALL\_SUBTEST\_1(test\_sparseqr\_scalar<double>());
00103     CALL\_SUBTEST\_2(test\_sparseqr\_scalar<std::complex<double> >());
00104   \}
00105 \}
00106 
\end{DoxyCode}
