\hypertarget{eigen_2unsupported_2test_2cxx11__tensor__uint128_8cpp_source}{}\section{eigen/unsupported/test/cxx11\+\_\+tensor\+\_\+uint128.cpp}
\label{eigen_2unsupported_2test_2cxx11__tensor__uint128_8cpp_source}\index{cxx11\+\_\+tensor\+\_\+uint128.\+cpp@{cxx11\+\_\+tensor\+\_\+uint128.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{preprocessor}{#include <Eigen/CXX11/Tensor>}
00013 
00014 
00015 \textcolor{preprocessor}{#if EIGEN\_COMP\_MSVC}
00016 \textcolor{preprocessor}{#define EIGEN\_NO\_INT128}
00017 \textcolor{preprocessor}{#else}
00018 \textcolor{keyword}{typedef} \_\_uint128\_t uint128\_t;
00019 \textcolor{preprocessor}{#endif}
00020 
00021 \textcolor{comment}{// Only run the test on compilers that support 128bit integers natively}
00022 \textcolor{preprocessor}{#ifndef EIGEN\_NO\_INT128}
00023 
00024 \textcolor{keyword}{using} \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{Eigen::internal::TensorUInt128};
00025 \textcolor{keyword}{using} \hyperlink{struct_eigen_1_1internal_1_1static__val}{Eigen::internal::static\_val};
00026 
00027 \textcolor{keywordtype}{void} VERIFY\_EQUAL(\hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} actual, uint128\_t 
      expected) \{
00028   \textcolor{keywordtype}{bool} matchl = actual.lower() == \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(expected);
00029   \textcolor{keywordtype}{bool} matchh = actual.upper() == \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(expected >> 64);
00030   \textcolor{keywordflow}{if} (!matchl || !matchh) \{
00031     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* testname = g\_test\_stack.back().c\_str();
00032     std::cerr << \textcolor{stringliteral}{"Test "} << testname << \textcolor{stringliteral}{" failed in "} << \_\_FILE\_\_
00033               << \textcolor{stringliteral}{" ("} << \_\_LINE\_\_ << \textcolor{stringliteral}{")"}
00034               << std::endl;
00035     abort();
00036   \}
00037 \}
00038 
00039 
00040 \textcolor{keywordtype}{void} test\_add() \{
00041   uint64\_t incr = internal::random<uint64\_t>(1, 9999999999);
00042   \textcolor{keywordflow}{for} (uint64\_t i1 = 0; i1 < 100; ++i1) \{
00043     \textcolor{keywordflow}{for} (uint64\_t i2 = 1; i2 < 100 * incr; i2 += incr) \{
00044       \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} i(i1, i2);
00045       uint128\_t a = (\textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(i1) << 64) + \textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(i2);
00046       \textcolor{keywordflow}{for} (uint64\_t j1 = 0; j1 < 100; ++j1) \{
00047         \textcolor{keywordflow}{for} (uint64\_t j2 = 1; j2 < 100 * incr; j2 += incr) \{
00048           \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} j(j1, j2);
00049           uint128\_t b = (\textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(j1) << 64) + \textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(j2);
00050           \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} actual = i + j;
00051           uint128\_t expected = a + b;
00052           VERIFY\_EQUAL(actual, expected);
00053         \}
00054       \}
00055     \}
00056   \}
00057 \}
00058 
00059 \textcolor{keywordtype}{void} test\_sub() \{
00060   uint64\_t incr = internal::random<uint64\_t>(1, 9999999999);
00061   \textcolor{keywordflow}{for} (uint64\_t i1 = 0; i1 < 100; ++i1) \{
00062     \textcolor{keywordflow}{for} (uint64\_t i2 = 1; i2 < 100 * incr; i2 += incr) \{
00063       \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} i(i1, i2);
00064       uint128\_t a = (\textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(i1) << 64) + \textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(i2);
00065       \textcolor{keywordflow}{for} (uint64\_t j1 = 0; j1 < 100; ++j1) \{
00066         \textcolor{keywordflow}{for} (uint64\_t j2 = 1; j2 < 100 * incr; j2 += incr) \{
00067           \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} j(j1, j2);
00068           uint128\_t b = (\textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(j1) << 64) + \textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(j2);
00069           \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} actual = i - j;
00070           uint128\_t expected = a - b;
00071           VERIFY\_EQUAL(actual, expected);
00072         \}
00073       \}
00074     \}
00075   \}
00076 \}
00077 
00078 \textcolor{keywordtype}{void} test\_mul() \{
00079   uint64\_t incr = internal::random<uint64\_t>(1, 9999999999);
00080   \textcolor{keywordflow}{for} (uint64\_t i1 = 0; i1 < 100; ++i1) \{
00081     \textcolor{keywordflow}{for} (uint64\_t i2 = 1; i2 < 100 * incr; i2 += incr) \{
00082       \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} i(i1, i2);
00083       uint128\_t a = (\textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(i1) << 64) + \textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(i2);
00084       \textcolor{keywordflow}{for} (uint64\_t j1 = 0; j1 < 100; ++j1) \{
00085         \textcolor{keywordflow}{for} (uint64\_t j2 = 1; j2 < 100 * incr; j2 += incr) \{
00086           \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} j(j1, j2);
00087           uint128\_t b = (\textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(j1) << 64) + \textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(j2);
00088           \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} actual = i * j;
00089           uint128\_t expected = a * b;
00090           VERIFY\_EQUAL(actual, expected);
00091         \}
00092       \}
00093     \}
00094   \}
00095 \}
00096 
00097 \textcolor{keywordtype}{void} test\_div() \{
00098   uint64\_t incr = internal::random<uint64\_t>(1, 9999999999);
00099   \textcolor{keywordflow}{for} (uint64\_t i1 = 0; i1 < 100; ++i1) \{
00100     \textcolor{keywordflow}{for} (uint64\_t i2 = 1; i2 < 100 * incr; i2 += incr) \{
00101       \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} i(i1, i2);
00102       uint128\_t a = (\textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(i1) << 64) + \textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(i2);
00103       \textcolor{keywordflow}{for} (uint64\_t j1 = 0; j1 < 100; ++j1) \{
00104         \textcolor{keywordflow}{for} (uint64\_t j2 = 1; j2 < 100 * incr; j2 += incr) \{
00105           \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} j(j1, j2);
00106           uint128\_t b = (\textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(j1) << 64) + \textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(j2);
00107           \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} actual = i / j;
00108           uint128\_t expected = a / b;
00109           VERIFY\_EQUAL(actual, expected);
00110         \}
00111       \}
00112     \}
00113   \}
00114 \}
00115 
00116 \textcolor{keywordtype}{void} test\_misc1() \{
00117   uint64\_t incr = internal::random<uint64\_t>(1, 9999999999);
00118   \textcolor{keywordflow}{for} (uint64\_t i2 = 1; i2 < 100 * incr; i2 += incr) \{
00119     \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<static\_val<0>}, uint64\_t> i(0, i2);
00120     uint128\_t a = \textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(i2);
00121     \textcolor{keywordflow}{for} (uint64\_t j2 = 1; j2 < 100 * incr; j2 += incr) \{
00122       \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<static\_val<0>}, uint64\_t> j(0, j2);
00123       uint128\_t b = \textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(j2);
00124       uint64\_t actual = (i * j).upper();
00125       uint64\_t expected = (a * b) >> 64;
00126       VERIFY\_IS\_EQUAL(actual, expected);
00127     \}
00128   \}
00129 \}
00130 
00131 \textcolor{keywordtype}{void} test\_misc2() \{
00132   int64\_t incr = internal::random<int64\_t>(1, 100);
00133   \textcolor{keywordflow}{for} (int64\_t log\_div = 0; log\_div < 63; ++log\_div) \{
00134     \textcolor{keywordflow}{for} (int64\_t divider = 1; divider <= 1000000 * incr; divider += incr) \{
00135       uint64\_t expected = (\textcolor{keyword}{static\_cast<}uint128\_t\textcolor{keyword}{>}(1) << (64+log\_div)) / static\_cast<uint128\_t>(divider) - (\textcolor{keyword}{
      static\_cast<}uint128\_t\textcolor{keyword}{>}(1) << 64) + 1;
00136       uint64\_t shift = 1ULL << log\_div;
00137 
00138       \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, uint64\_t>} result = (
      \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<uint64\_t, static\_val<0>} >(shift, 0) / 
      \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128}<\hyperlink{struct_eigen_1_1internal_1_1static__val}{static\_val<0>}, uint64\_t>(divider) - 
      \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128<static\_val<1>}, \hyperlink{struct_eigen_1_1internal_1_1static__val}{static\_val<0>} >(1, 0) + 
      \hyperlink{struct_eigen_1_1internal_1_1_tensor_u_int128}{TensorUInt128}<static\_val<0>, \hyperlink{struct_eigen_1_1internal_1_1static__val}{static\_val<1>} >(1));
00139       uint64\_t actual = \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(result);
00140       VERIFY\_IS\_EQUAL(actual, expected);
00141     \}
00142   \}
00143 \}
00144 \textcolor{preprocessor}{#endif}
00145 
00146 
00147 \textcolor{keywordtype}{void} test\_cxx11\_tensor\_uint128()
00148 \{
00149 \textcolor{preprocessor}{#ifdef EIGEN\_NO\_INT128}
00150   \textcolor{comment}{// Skip the test on compilers that don't support 128bit integers natively}
00151   \textcolor{keywordflow}{return};
00152 \textcolor{preprocessor}{#else}
00153   CALL\_SUBTEST\_1(test\_add());
00154   CALL\_SUBTEST\_2(test\_sub());
00155   CALL\_SUBTEST\_3(test\_mul());
00156   CALL\_SUBTEST\_4(test\_div());
00157   CALL\_SUBTEST\_5(test\_misc1());
00158   CALL\_SUBTEST\_6(test\_misc2());
00159 \textcolor{preprocessor}{#endif}
00160 \}
\end{DoxyCode}
