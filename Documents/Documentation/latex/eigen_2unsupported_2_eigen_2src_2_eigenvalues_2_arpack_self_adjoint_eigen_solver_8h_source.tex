\hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source}{}\section{eigen/unsupported/\+Eigen/src/\+Eigenvalues/\+Arpack\+Self\+Adjoint\+Eigen\+Solver.h}
\label{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source}\index{Arpack\+Self\+Adjoint\+Eigen\+Solver.\+h@{Arpack\+Self\+Adjoint\+Eigen\+Solver.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 David Harmon <dharmon@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// Eigen is free software; you can redistribute it and/or}
00007 \textcolor{comment}{// modify it under the terms of the GNU Lesser General Public}
00008 \textcolor{comment}{// License as published by the Free Software Foundation; either}
00009 \textcolor{comment}{// version 3 of the License, or (at your option) any later version.}
00010 \textcolor{comment}{//}
00011 \textcolor{comment}{// Alternatively, you can redistribute it and/or}
00012 \textcolor{comment}{// modify it under the terms of the GNU General Public License as}
00013 \textcolor{comment}{// published by the Free Software Foundation; either version 2 of}
00014 \textcolor{comment}{// the License, or (at your option) any later version.}
00015 \textcolor{comment}{//}
00016 \textcolor{comment}{// Eigen is distributed in the hope that it will be useful, but WITHOUT ANY}
00017 \textcolor{comment}{// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS}
00018 \textcolor{comment}{// FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License or the}
00019 \textcolor{comment}{// GNU General Public License for more details.}
00020 \textcolor{comment}{//}
00021 \textcolor{comment}{// You should have received a copy of the GNU Lesser General Public}
00022 \textcolor{comment}{// License and a copy of the GNU General Public License along with}
00023 \textcolor{comment}{// Eigen. If not, see <http://www.gnu.org/licenses/>.}
00024 
00025 \textcolor{preprocessor}{#ifndef EIGEN\_ARPACKGENERALIZEDSELFADJOINTEIGENSOLVER\_H}
00026 \textcolor{preprocessor}{#define EIGEN\_ARPACKGENERALIZEDSELFADJOINTEIGENSOLVER\_H}
00027 
00028 \textcolor{preprocessor}{#include <Eigen/Dense>}
00029 
00030 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00031 
00032 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00033}\hyperlink{struct_eigen_1_1internal_1_1arpack__wrapper}{00033}   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} RealScalar> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1arpack__wrapper}{arpack\_wrapper};
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00034}\hyperlink{struct_eigen_1_1internal_1_1_o_p}{00034}   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixSolver, \textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{bool} BisSPD> \textcolor{keyword}{struct }
      \hyperlink{struct_eigen_1_1internal_1_1_o_p}{OP};
00035 \}
00036 
00037 
00038 
00039 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} MatrixSolver=SimplicialLLT<MatrixType>, \textcolor{keywordtype}{bool} BisSPD=false>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00040}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver}{00040} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver}{ArpackGeneralizedSelfAdjointEigenSolver}
00041 \{
00042 \textcolor{keyword}{public}:
00043   \textcolor{comment}{//typedef typename MatrixSolver::MatrixType MatrixType;}
00044 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00046}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{00046}   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar};
00047   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00048 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00055}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a2555af55e53bf9de894a49e639be2e1e}{00055}   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a2555af55e53bf9de894a49e639be2e1e}{RealScalar};
00056 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00062}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a47a5becb6dda25dbd90a1704a8247dd8}{00062}   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::plain\_col\_type<MatrixType, RealScalar>::type}
       \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a47a5becb6dda25dbd90a1704a8247dd8}{RealVectorType};
00063 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00070}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_aab45c05af4937baddb38e26bffe80a42}{00070}   \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_aab45c05af4937baddb38e26bffe80a42}{ArpackGeneralizedSelfAdjointEigenSolver}()
00071    : m\_eivec(),
00072      m\_eivalues(),
00073      m\_isInitialized(false),
00074      m\_eigenvectorsOk(false),
00075      m\_nbrConverged(0),
00076      m\_nbrIterations(0)
00077   \{ \}
00078 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00101}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab67d6c5218fd84e74fc03d55acd0c89e}{00101}   \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab67d6c5218fd84e74fc03d55acd0c89e}{ArpackGeneralizedSelfAdjointEigenSolver}(\textcolor{keyword}{const} MatrixType& A, \textcolor{keyword}{const}
       MatrixType& B,
00102                                           Index nbrEigenvalues, std::string eigs\_sigma=\textcolor{stringliteral}{"LM"},
00103                                \textcolor{keywordtype}{int} options=\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors}, RealScalar tol=0.0)
00104     : m\_eivec(),
00105       m\_eivalues(),
00106       m\_isInitialized(false),
00107       m\_eigenvectorsOk(false),
00108       m\_nbrConverged(0),
00109       m\_nbrIterations(0)
00110   \{
00111     compute(A, B, nbrEigenvalues, eigs\_sigma, options, tol);
00112   \}
00113 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00136}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a896d444b17b59c3b061800f579317a73}{00136}   \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a896d444b17b59c3b061800f579317a73}{ArpackGeneralizedSelfAdjointEigenSolver}(\textcolor{keyword}{const} MatrixType& A,
00137                                           Index nbrEigenvalues, std::string eigs\_sigma=\textcolor{stringliteral}{"LM"},
00138                                \textcolor{keywordtype}{int} options=\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors}, RealScalar tol=0.0)
00139     : m\_eivec(),
00140       m\_eivalues(),
00141       m\_isInitialized(false),
00142       m\_eigenvectorsOk(false),
00143       m\_nbrConverged(0),
00144       m\_nbrIterations(0)
00145   \{
00146     compute(A, nbrEigenvalues, eigs\_sigma, options, tol);
00147   \}
00148 
00149 
00173   \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver}{ArpackGeneralizedSelfAdjointEigenSolver}& compute(\textcolor{keyword}{const} MatrixType&
       A, \textcolor{keyword}{const} MatrixType& B,
00174                                                    Index nbrEigenvalues, std::string eigs\_sigma=\textcolor{stringliteral}{"LM"},
00175                                         \textcolor{keywordtype}{int} options=\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors}, RealScalar tol=
      0.0);
00176   
00199   \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver}{ArpackGeneralizedSelfAdjointEigenSolver}& compute(\textcolor{keyword}{const} MatrixType&
       A,
00200                                                    Index nbrEigenvalues, std::string eigs\_sigma=\textcolor{stringliteral}{"LM"},
00201                                         \textcolor{keywordtype}{int} options=\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors}, RealScalar tol=
      0.0);
00202 
00203 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00223}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a183825135568364792a955efc55a0773}{00223}   \textcolor{keyword}{const} \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, Dynamic>}& 
      \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a183825135568364792a955efc55a0773}{eigenvectors}()\textcolor{keyword}{ const}
00224 \textcolor{keyword}{  }\{
00225     eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"ArpackGeneralizedSelfAdjointEigenSolver is not initialized."});
00226     eigen\_assert(m\_eigenvectorsOk && \textcolor{stringliteral}{"The eigenvectors have not been computed together with the
       eigenvalues."});
00227     \textcolor{keywordflow}{return} m\_eivec;
00228   \}
00229 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00245}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab46900dafdd11a8ac05a662c6b41480d}{00245}   \textcolor{keyword}{const} \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>}& \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab46900dafdd11a8ac05a662c6b41480d}{eigenvalues}()\textcolor{keyword}{ const}
00246 \textcolor{keyword}{  }\{
00247     eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"ArpackGeneralizedSelfAdjointEigenSolver is not initialized."});
00248     \textcolor{keywordflow}{return} m\_eivalues;
00249   \}
00250 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00269}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a7522aad061ebccc065b254c0bc67d3b0}{00269}   \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, Dynamic>} \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a7522aad061ebccc065b254c0bc67d3b0}{operatorSqrt}()\textcolor{keyword}{ const}
00270 \textcolor{keyword}{  }\{
00271     eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"SelfAdjointEigenSolver is not initialized."});
00272     eigen\_assert(m\_eigenvectorsOk && \textcolor{stringliteral}{"The eigenvectors have not been computed together with the
       eigenvalues."});
00273     \textcolor{keywordflow}{return} m\_eivec * m\_eivalues.cwiseSqrt().asDiagonal() * m\_eivec.adjoint();
00274   \}
00275 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00294}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ad55f052b675f1deaea220d0cc225622a}{00294}   \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, Dynamic>} 
      \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ad55f052b675f1deaea220d0cc225622a}{operatorInverseSqrt}()\textcolor{keyword}{ const}
00295 \textcolor{keyword}{  }\{
00296     eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"SelfAdjointEigenSolver is not initialized."});
00297     eigen\_assert(m\_eigenvectorsOk && \textcolor{stringliteral}{"The eigenvectors have not been computed together with the
       eigenvalues."});
00298     \textcolor{keywordflow}{return} m\_eivec * m\_eivalues.cwiseInverse().cwiseSqrt().asDiagonal() * m\_eivec.adjoint();
00299   \}
00300 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00305}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a6f952eed50efe01b8cb91726e6a93b68}{00305}   \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a6f952eed50efe01b8cb91726e6a93b68}{info}()\textcolor{keyword}{ const}
00306 \textcolor{keyword}{  }\{
00307     eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"ArpackGeneralizedSelfAdjointEigenSolver is not initialized."});
00308     \textcolor{keywordflow}{return} m\_info;
00309   \}
00310 
00311   \textcolor{keywordtype}{size\_t} getNbrConvergedEigenValues()\textcolor{keyword}{ const}
00312 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} m\_nbrConverged; \}
00313 
00314   \textcolor{keywordtype}{size\_t} getNbrIterations()\textcolor{keyword}{ const}
00315 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} m\_nbrIterations; \}
00316 
00317 \textcolor{keyword}{protected}:
00318   \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, Dynamic>} m\_eivec;
00319   \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>} m\_eivalues;
00320   \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} m\_info;
00321   \textcolor{keywordtype}{bool} m\_isInitialized;
00322   \textcolor{keywordtype}{bool} m\_eigenvectorsOk;
00323 
00324   \textcolor{keywordtype}{size\_t} m\_nbrConverged;
00325   \textcolor{keywordtype}{size\_t} m\_nbrIterations;
00326 \};
00327 
00328 
00329 
00330 
00331 
00332 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} MatrixSolver, \textcolor{keywordtype}{bool} BisSPD>
00333 \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver}{ArpackGeneralizedSelfAdjointEigenSolver<MatrixType, MatrixSolver, BisSPD>}
      &
00334     \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a1a905e5e65e82e559a2cc394a9f42385}{ArpackGeneralizedSelfAdjointEigenSolver<MatrixType, MatrixSolver, BisSPD>}
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00335}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a781369cb32c8e4623894da79909612c4}{00335} \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a1a905e5e65e82e559a2cc394a9f42385}{::compute}(\textcolor{keyword}{const} MatrixType& A, Index nbrEigenvalues,
00336           std::string eigs\_sigma, \textcolor{keywordtype}{int} options, \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a2555af55e53bf9de894a49e639be2e1e}{RealScalar} tol)
00337 \{
00338     MatrixType B(0,0);
00339     compute(A, B, nbrEigenvalues, eigs\_sigma, options, tol);
00340     
00341     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00342 \}
00343 
00344 
00345 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} MatrixSolver, \textcolor{keywordtype}{bool} BisSPD>
00346 \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver}{ArpackGeneralizedSelfAdjointEigenSolver<MatrixType, MatrixSolver, BisSPD>}
      &
00347     \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a1a905e5e65e82e559a2cc394a9f42385}{ArpackGeneralizedSelfAdjointEigenSolver<MatrixType, MatrixSolver, BisSPD>}
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00348}\hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a1a905e5e65e82e559a2cc394a9f42385}{00348} \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a1a905e5e65e82e559a2cc394a9f42385}{::compute}(\textcolor{keyword}{const} MatrixType& A, \textcolor{keyword}{const} MatrixType& B, Index nbrEigenvalues,
00349           std::string eigs\_sigma, \textcolor{keywordtype}{int} options, \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a2555af55e53bf9de894a49e639be2e1e}{RealScalar} tol)
00350 \{
00351   eigen\_assert(A.cols() == A.rows());
00352   eigen\_assert(B.cols() == B.rows());
00353   eigen\_assert(B.rows() == 0 || A.cols() == B.rows());
00354   eigen\_assert((options &~ (EigVecMask | GenEigMask)) == 0
00355             && (options & EigVecMask) != EigVecMask
00356             && \textcolor{stringliteral}{"invalid option parameter"});
00357 
00358   \textcolor{keywordtype}{bool} isBempty = (B.rows() == 0) || (B.cols() == 0);
00359 
00360   \textcolor{comment}{// For clarity, all parameters match their ARPACK name}
00361   \textcolor{comment}{//}
00362   \textcolor{comment}{// Always 0 on the first call}
00363   \textcolor{comment}{//}
00364   \textcolor{keywordtype}{int} ido = 0;
00365 
00366   \textcolor{keywordtype}{int} n = (int)A.cols();
00367 
00368   \textcolor{comment}{// User options: "LA", "SA", "SM", "LM", "BE"}
00369   \textcolor{comment}{//}
00370   \textcolor{keywordtype}{char} whch[3] = \textcolor{stringliteral}{"LM"};
00371     
00372   \textcolor{comment}{// Specifies the shift if iparam[6] = \{ 3, 4, 5 \}, not used if iparam[6] = \{ 1, 2 \}}
00373   \textcolor{comment}{//}
00374   \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a2555af55e53bf9de894a49e639be2e1e}{RealScalar} sigma = 0.0;
00375 
00376   \textcolor{keywordflow}{if} (eigs\_sigma.length() >= 2 && isalpha(eigs\_sigma[0]) && isalpha(eigs\_sigma[1]))
00377   \{
00378       eigs\_sigma[0] = toupper(eigs\_sigma[0]);
00379       eigs\_sigma[1] = toupper(eigs\_sigma[1]);
00380 
00381       \textcolor{comment}{// In the following special case we're going to invert the problem, since solving}
00382       \textcolor{comment}{// for larger magnitude is much much faster}
00383       \textcolor{comment}{// i.e., if 'SM' is specified, we're going to really use 'LM', the default}
00384       \textcolor{comment}{//}
00385       \textcolor{keywordflow}{if} (eigs\_sigma.substr(0,2) != \textcolor{stringliteral}{"SM"})
00386       \{
00387           whch[0] = eigs\_sigma[0];
00388           whch[1] = eigs\_sigma[1];
00389       \}
00390   \}
00391   \textcolor{keywordflow}{else}
00392   \{
00393       eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Specifying clustered eigenvalues is not yet supported!"});
00394 
00395       \textcolor{comment}{// If it's not scalar values, then the user may be explicitly}
00396       \textcolor{comment}{// specifying the sigma value to cluster the evs around}
00397       \textcolor{comment}{//}
00398       sigma = atof(eigs\_sigma.c\_str());
00399 
00400       \textcolor{comment}{// If atof fails, it returns 0.0, which is a fine default}
00401       \textcolor{comment}{//}
00402   \}
00403 
00404   \textcolor{comment}{// "I" means normal eigenvalue problem, "G" means generalized}
00405   \textcolor{comment}{//}
00406   \textcolor{keywordtype}{char} bmat[2] = \textcolor{stringliteral}{"I"};
00407   \textcolor{keywordflow}{if} (eigs\_sigma.substr(0,2) == \textcolor{stringliteral}{"SM"} || !(isalpha(eigs\_sigma[0]) && isalpha(eigs\_sigma[1])) || (!isBempty 
      && !BisSPD))
00408       bmat[0] = \textcolor{charliteral}{'G'};
00409 
00410   \textcolor{comment}{// Now we determine the mode to use}
00411   \textcolor{comment}{//}
00412   \textcolor{keywordtype}{int} mode = (bmat[0] == \textcolor{charliteral}{'G'}) + 1;
00413   \textcolor{keywordflow}{if} (eigs\_sigma.substr(0,2) == \textcolor{stringliteral}{"SM"} || !(isalpha(eigs\_sigma[0]) && isalpha(eigs\_sigma[1])))
00414   \{
00415       \textcolor{comment}{// We're going to use shift-and-invert mode, and basically find}
00416       \textcolor{comment}{// the largest eigenvalues of the inverse operator}
00417       \textcolor{comment}{//}
00418       mode = 3;
00419   \}
00420 
00421   \textcolor{comment}{// The user-specified number of eigenvalues/vectors to compute}
00422   \textcolor{comment}{//}
00423   \textcolor{keywordtype}{int} nev = (int)nbrEigenvalues;
00424 
00425   \textcolor{comment}{// Allocate space for ARPACK to store the residual}
00426   \textcolor{comment}{//}
00427   \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *resid = \textcolor{keyword}{new} \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar}[n];
00428 
00429   \textcolor{comment}{// Number of Lanczos vectors, must satisfy nev < ncv <= n}
00430   \textcolor{comment}{// Note that this indicates that nev != n, and we cannot compute}
00431   \textcolor{comment}{// all eigenvalues of a mtrix}
00432   \textcolor{comment}{//}
00433   \textcolor{keywordtype}{int} ncv = std::min(std::max(2*nev, 20), n);
00434 
00435   \textcolor{comment}{// The working n x ncv matrix, also store the final eigenvectors (if computed)}
00436   \textcolor{comment}{//}
00437   \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *v = \textcolor{keyword}{new} \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar}[n*ncv];
00438   \textcolor{keywordtype}{int} ldv = n;
00439 
00440   \textcolor{comment}{// Working space}
00441   \textcolor{comment}{//}
00442   \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *workd = \textcolor{keyword}{new} \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar}[3*n];
00443   \textcolor{keywordtype}{int} lworkl = ncv*ncv+8*ncv; \textcolor{comment}{// Must be at least this length}
00444   \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *workl = \textcolor{keyword}{new} \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar}[lworkl];
00445 
00446   \textcolor{keywordtype}{int} *iparam= \textcolor{keyword}{new} \textcolor{keywordtype}{int}[11];
00447   iparam[0] = 1; \textcolor{comment}{// 1 means we let ARPACK perform the shifts, 0 means we'd have to do it}
00448   iparam[2] = std::max(300, (\textcolor{keywordtype}{int})std::ceil(2*n/std::max(ncv,1)));
00449   iparam[6] = mode; \textcolor{comment}{// The mode, 1 is standard ev problem, 2 for generalized ev, 3 for shift-and-invert}
00450 
00451   \textcolor{comment}{// Used during reverse communicate to notify where arrays start}
00452   \textcolor{comment}{//}
00453   \textcolor{keywordtype}{int} *ipntr = \textcolor{keyword}{new} \textcolor{keywordtype}{int}[11]; 
00454 
00455   \textcolor{comment}{// Error codes are returned in here, initial value of 0 indicates a random initial}
00456   \textcolor{comment}{// residual vector is used, any other values means resid contains the initial residual}
00457   \textcolor{comment}{// vector, possibly from a previous run}
00458   \textcolor{comment}{//}
00459   \textcolor{keywordtype}{int} info = 0;
00460 
00461   \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} scale = 1.0;
00462   \textcolor{comment}{//if (!isBempty)}
00463   \textcolor{comment}{//\{}
00464   \textcolor{comment}{//Scalar scale = B.norm() / std::sqrt(n);}
00465   \textcolor{comment}{//scale = std::pow(2, std::floor(std::log(scale+1)));}
00467 \textcolor{comment}{}  \textcolor{comment}{//for (size\_t i=0; i<(size\_t)B.outerSize(); i++)}
00468   \textcolor{comment}{//    for (typename MatrixType::InnerIterator it(B, i); it; ++it)}
00469   \textcolor{comment}{//        it.valueRef() /= scale;}
00470   \textcolor{comment}{//\}}
00471 
00472   MatrixSolver OP;
00473   \textcolor{keywordflow}{if} (mode == 1 || mode == 2)
00474   \{
00475       \textcolor{keywordflow}{if} (!isBempty)
00476           OP.compute(B);
00477   \}
00478   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (mode == 3)
00479   \{
00480       \textcolor{keywordflow}{if} (sigma == 0.0)
00481       \{
00482           OP.compute(A);
00483       \}
00484       \textcolor{keywordflow}{else}
00485       \{
00486           \textcolor{comment}{// Note: We will never enter here because sigma must be 0.0}
00487           \textcolor{comment}{//}
00488           \textcolor{keywordflow}{if} (isBempty)
00489           \{
00490             MatrixType AminusSigmaB(A);
00491             \textcolor{keywordflow}{for} (Index i=0; i<A.rows(); ++i)
00492                 AminusSigmaB.coeffRef(i,i) -= sigma;
00493             
00494             OP.compute(AminusSigmaB);
00495           \}
00496           \textcolor{keywordflow}{else}
00497           \{
00498               MatrixType AminusSigmaB = A - sigma * B;
00499               OP.compute(AminusSigmaB);
00500           \}
00501       \}
00502   \}
00503  
00504   \textcolor{keywordflow}{if} (!(mode == 1 && isBempty) && !(mode == 2 && isBempty) && OP.info() != 
      \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success})
00505       std::cout << \textcolor{stringliteral}{"Error factoring matrix"} << std::endl;
00506 
00507   \textcolor{keywordflow}{do}
00508   \{
00509     \hyperlink{struct_eigen_1_1internal_1_1arpack__wrapper}{internal::arpack\_wrapper<Scalar, RealScalar>::saupd}(
      &ido, bmat, &n, whch, &nev, &tol, resid, 
00510                                                         &ncv, v, &ldv, iparam, ipntr, workd, workl,
00511                                                         &lworkl, &info);
00512 
00513     \textcolor{keywordflow}{if} (ido == -1 || ido == 1)
00514     \{
00515       \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *in  = workd + ipntr[0] - 1;
00516       \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *out = workd + ipntr[1] - 1;
00517 
00518       \textcolor{keywordflow}{if} (ido == 1 && mode != 2)
00519       \{
00520           \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *out2 = workd + ipntr[2] - 1;
00521           \textcolor{keywordflow}{if} (isBempty || mode == 1)
00522             \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(out2, n) = 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(in, n);
00523           \textcolor{keywordflow}{else}
00524             \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(out2, n) = B * 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(in, n);
00525           
00526           in = workd + ipntr[2] - 1;
00527       \}
00528 
00529       \textcolor{keywordflow}{if} (mode == 1)
00530       \{
00531         \textcolor{keywordflow}{if} (isBempty)
00532         \{
00533           \textcolor{comment}{// OP = A}
00534           \textcolor{comment}{//}
00535           \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(out, n) = A * 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(in, n);
00536         \}
00537         \textcolor{keywordflow}{else}
00538         \{
00539           \textcolor{comment}{// OP = L^\{-1\}AL^\{-T\}}
00540           \textcolor{comment}{//}
00541           \hyperlink{struct_eigen_1_1internal_1_1_o_p}{internal::OP<MatrixSolver, MatrixType, Scalar, BisSPD>::applyOP}
      (OP, A, n, in, out);
00542         \}
00543       \}
00544       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (mode == 2)
00545       \{
00546         \textcolor{keywordflow}{if} (ido == 1)
00547           \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(in, n)  = A * 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(in, n);
00548         
00549         \textcolor{comment}{// OP = B^\{-1\} A}
00550         \textcolor{comment}{//}
00551         Matrix<Scalar, Dynamic, 1>::Map(out, n) = OP.solve(Matrix<Scalar, Dynamic, 1>::Map(in, n));
00552       \}
00553       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (mode == 3)
00554       \{
00555         \textcolor{comment}{// OP = (A-\(\backslash\)sigmaB)B (\(\backslash\)sigma could be 0, and B could be I)}
00556         \textcolor{comment}{// The B * in is already computed and stored at in if ido == 1}
00557         \textcolor{comment}{//}
00558         \textcolor{keywordflow}{if} (ido == 1 || isBempty)
00559           \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(out, n) = OP.solve(
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(in, n));
00560         \textcolor{keywordflow}{else}
00561           \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(out, n) = OP.solve(B * 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(in, n));
00562       \}
00563     \}
00564     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ido == 2)
00565     \{
00566       \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *in  = workd + ipntr[0] - 1;
00567       \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *out = workd + ipntr[1] - 1;
00568 
00569       \textcolor{keywordflow}{if} (isBempty || mode == 1)
00570         \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(out, n) = 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(in, n);
00571       \textcolor{keywordflow}{else}
00572         \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(out, n) = B * 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(in, n);
00573     \}
00574   \} \textcolor{keywordflow}{while} (ido != 99);
00575 
00576   \textcolor{keywordflow}{if} (info == 1)
00577     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence};
00578   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (info == 3)
00579     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00580   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (info < 0)
00581     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434}{InvalidInput};
00582   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (info != 0)
00583     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Unknown ARPACK return value!"});
00584   \textcolor{keywordflow}{else}
00585   \{
00586     \textcolor{comment}{// Do we compute eigenvectors or not?}
00587     \textcolor{comment}{//}
00588     \textcolor{keywordtype}{int} rvec = (options & \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors}) == 
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc}{ComputeEigenvectors};
00589 
00590     \textcolor{comment}{// "A" means "All", use "S" to choose specific eigenvalues (not yet supported in ARPACK))}
00591     \textcolor{comment}{//}
00592     \textcolor{keywordtype}{char} howmny[2] = \textcolor{stringliteral}{"A"}; 
00593 
00594     \textcolor{comment}{// if howmny == "S", specifies the eigenvalues to compute (not implemented in ARPACK)}
00595     \textcolor{comment}{//}
00596     \textcolor{keywordtype}{int} *select = \textcolor{keyword}{new} \textcolor{keywordtype}{int}[ncv];
00597 
00598     \textcolor{comment}{// Final eigenvalues}
00599     \textcolor{comment}{//}
00600     m\_eivalues.resize(nev, 1);
00601 
00602     \hyperlink{struct_eigen_1_1internal_1_1arpack__wrapper}{internal::arpack\_wrapper<Scalar, RealScalar>::seupd}(
      &rvec, howmny, select, m\_eivalues.data(), v, &ldv,
00603                                                         &sigma, bmat, &n, whch, &nev, &tol, resid, &ncv,
00604                                                         v, &ldv, iparam, ipntr, workd, workl, &lworkl, &
      info);
00605 
00606     \textcolor{keywordflow}{if} (info == -14)
00607       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence};
00608     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (info != 0)
00609       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434}{InvalidInput};
00610     \textcolor{keywordflow}{else}
00611     \{
00612       \textcolor{keywordflow}{if} (rvec)
00613       \{
00614         m\_eivec.resize(A.rows(), nev);
00615         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<nev; i++)
00616           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<n; j++)
00617             m\_eivec(j,i) = v[i*n+j] / scale;
00618       
00619         \textcolor{keywordflow}{if} (mode == 1 && !isBempty && BisSPD)
00620           \hyperlink{struct_eigen_1_1internal_1_1_o_p}{internal::OP<MatrixSolver, MatrixType, Scalar, BisSPD>::project}
      (OP, n, nev, m\_eivec.data());
00621 
00622         m\_eigenvectorsOk = \textcolor{keyword}{true};
00623       \}
00624 
00625       m\_nbrIterations = iparam[2];
00626       m\_nbrConverged  = iparam[4];
00627 
00628       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00629     \}
00630 
00631     \textcolor{keyword}{delete}[] select;
00632   \}
00633 
00634   \textcolor{keyword}{delete}[] v;
00635   \textcolor{keyword}{delete}[] iparam;
00636   \textcolor{keyword}{delete}[] ipntr;
00637   \textcolor{keyword}{delete}[] workd;
00638   \textcolor{keyword}{delete}[] workl;
00639   \textcolor{keyword}{delete}[] resid;
00640 
00641   m\_isInitialized = \textcolor{keyword}{true};
00642 
00643   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00644 \}
00645 
00646 
00647 \textcolor{comment}{// Single precision}
00648 \textcolor{comment}{//}
00649 \textcolor{keyword}{extern} \textcolor{stringliteral}{"C"} \textcolor{keywordtype}{void} ssaupd\_(\textcolor{keywordtype}{int} *ido, \textcolor{keywordtype}{char} *bmat, \textcolor{keywordtype}{int} *n, \textcolor{keywordtype}{char} *which,
00650     \textcolor{keywordtype}{int} *nev, \textcolor{keywordtype}{float} *tol, \textcolor{keywordtype}{float} *resid, \textcolor{keywordtype}{int} *ncv,
00651     \textcolor{keywordtype}{float} *v, \textcolor{keywordtype}{int} *ldv, \textcolor{keywordtype}{int} *iparam, \textcolor{keywordtype}{int} *ipntr,
00652     \textcolor{keywordtype}{float} *workd, \textcolor{keywordtype}{float} *workl, \textcolor{keywordtype}{int} *lworkl,
00653     \textcolor{keywordtype}{int} *info);
00654 
00655 \textcolor{keyword}{extern} \textcolor{stringliteral}{"C"} \textcolor{keywordtype}{void} sseupd\_(\textcolor{keywordtype}{int} *rvec, \textcolor{keywordtype}{char} *All, \textcolor{keywordtype}{int} *select, \textcolor{keywordtype}{float} *d,
00656     \textcolor{keywordtype}{float} *z, \textcolor{keywordtype}{int} *ldz, \textcolor{keywordtype}{float} *sigma, 
00657     \textcolor{keywordtype}{char} *bmat, \textcolor{keywordtype}{int} *n, \textcolor{keywordtype}{char} *which, \textcolor{keywordtype}{int} *nev,
00658     \textcolor{keywordtype}{float} *tol, \textcolor{keywordtype}{float} *resid, \textcolor{keywordtype}{int} *ncv, \textcolor{keywordtype}{float} *v,
00659     \textcolor{keywordtype}{int} *ldv, \textcolor{keywordtype}{int} *iparam, \textcolor{keywordtype}{int} *ipntr, \textcolor{keywordtype}{float} *workd,
00660     \textcolor{keywordtype}{float} *workl, \textcolor{keywordtype}{int} *lworkl, \textcolor{keywordtype}{int} *ierr);
00661 
00662 \textcolor{comment}{// Double precision}
00663 \textcolor{comment}{//}
00664 \textcolor{keyword}{extern} \textcolor{stringliteral}{"C"} \textcolor{keywordtype}{void} dsaupd\_(\textcolor{keywordtype}{int} *ido, \textcolor{keywordtype}{char} *bmat, \textcolor{keywordtype}{int} *n, \textcolor{keywordtype}{char} *which,
00665     \textcolor{keywordtype}{int} *nev, \textcolor{keywordtype}{double} *tol, \textcolor{keywordtype}{double} *resid, \textcolor{keywordtype}{int} *ncv,
00666     \textcolor{keywordtype}{double} *v, \textcolor{keywordtype}{int} *ldv, \textcolor{keywordtype}{int} *iparam, \textcolor{keywordtype}{int} *ipntr,
00667     \textcolor{keywordtype}{double} *workd, \textcolor{keywordtype}{double} *workl, \textcolor{keywordtype}{int} *lworkl,
00668     \textcolor{keywordtype}{int} *info);
00669 
00670 \textcolor{keyword}{extern} \textcolor{stringliteral}{"C"} \textcolor{keywordtype}{void} dseupd\_(\textcolor{keywordtype}{int} *rvec, \textcolor{keywordtype}{char} *All, \textcolor{keywordtype}{int} *select, \textcolor{keywordtype}{double} *d,
00671     \textcolor{keywordtype}{double} *z, \textcolor{keywordtype}{int} *ldz, \textcolor{keywordtype}{double} *sigma, 
00672     \textcolor{keywordtype}{char} *bmat, \textcolor{keywordtype}{int} *n, \textcolor{keywordtype}{char} *which, \textcolor{keywordtype}{int} *nev,
00673     \textcolor{keywordtype}{double} *tol, \textcolor{keywordtype}{double} *resid, \textcolor{keywordtype}{int} *ncv, \textcolor{keywordtype}{double} *v,
00674     \textcolor{keywordtype}{int} *ldv, \textcolor{keywordtype}{int} *iparam, \textcolor{keywordtype}{int} *ipntr, \textcolor{keywordtype}{double} *workd,
00675     \textcolor{keywordtype}{double} *workl, \textcolor{keywordtype}{int} *lworkl, \textcolor{keywordtype}{int} *ierr);
00676 
00677 
00678 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00679 
00680 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} RealScalar> \textcolor{keyword}{struct }arpack\_wrapper
00681 \{
00682   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} saupd(\textcolor{keywordtype}{int} *ido, \textcolor{keywordtype}{char} *bmat, \textcolor{keywordtype}{int} *n, \textcolor{keywordtype}{char} *which,
00683       \textcolor{keywordtype}{int} *nev, \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a2555af55e53bf9de894a49e639be2e1e}{RealScalar} *tol, \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *resid, \textcolor{keywordtype}{int} *ncv,
00684       \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *v, \textcolor{keywordtype}{int} *ldv, \textcolor{keywordtype}{int} *iparam, \textcolor{keywordtype}{int} *ipntr,
00685       \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *workd, \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *workl, \textcolor{keywordtype}{int} *lworkl, \textcolor{keywordtype}{int} *info)
00686   \{ 
00687     EIGEN\_STATIC\_ASSERT(!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsComplex}, 
      NUMERIC\_TYPE\_MUST\_BE\_REAL)
00688   \}
00689 
00690   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} seupd(\textcolor{keywordtype}{int} *rvec, \textcolor{keywordtype}{char} *All, \textcolor{keywordtype}{int} *select, \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *d,
00691       \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *z, \textcolor{keywordtype}{int} *ldz, \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a2555af55e53bf9de894a49e639be2e1e}{RealScalar} *sigma,
00692       \textcolor{keywordtype}{char} *bmat, \textcolor{keywordtype}{int} *n, \textcolor{keywordtype}{char} *which, \textcolor{keywordtype}{int} *nev,
00693       \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_a2555af55e53bf9de894a49e639be2e1e}{RealScalar} *tol, \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *resid, \textcolor{keywordtype}{int} *ncv, \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *v,
00694       \textcolor{keywordtype}{int} *ldv, \textcolor{keywordtype}{int} *iparam, \textcolor{keywordtype}{int} *ipntr, \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *workd,
00695       \hyperlink{class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver_ab1182405bfe87a505d4b7a8311c661ec}{Scalar} *workl, \textcolor{keywordtype}{int} *lworkl, \textcolor{keywordtype}{int} *ierr)
00696   \{
00697     EIGEN\_STATIC\_ASSERT(!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsComplex}, 
      NUMERIC\_TYPE\_MUST\_BE\_REAL)
00698   \}
00699 \};
00700 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00701}\hyperlink{struct_eigen_1_1internal_1_1arpack__wrapper_3_01float_00_01float_01_4}{00701} \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1arpack__wrapper}{arpack\_wrapper}<float, float>
00702 \{
00703   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} saupd(\textcolor{keywordtype}{int} *ido, \textcolor{keywordtype}{char} *bmat, \textcolor{keywordtype}{int} *n, \textcolor{keywordtype}{char} *which,
00704       \textcolor{keywordtype}{int} *nev, \textcolor{keywordtype}{float} *tol, \textcolor{keywordtype}{float} *resid, \textcolor{keywordtype}{int} *ncv,
00705       \textcolor{keywordtype}{float} *v, \textcolor{keywordtype}{int} *ldv, \textcolor{keywordtype}{int} *iparam, \textcolor{keywordtype}{int} *ipntr,
00706       \textcolor{keywordtype}{float} *workd, \textcolor{keywordtype}{float} *workl, \textcolor{keywordtype}{int} *lworkl, \textcolor{keywordtype}{int} *info)
00707   \{
00708     ssaupd\_(ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
00709   \}
00710 
00711   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} seupd(\textcolor{keywordtype}{int} *rvec, \textcolor{keywordtype}{char} *All, \textcolor{keywordtype}{int} *select, \textcolor{keywordtype}{float} *d,
00712       \textcolor{keywordtype}{float} *z, \textcolor{keywordtype}{int} *ldz, \textcolor{keywordtype}{float} *sigma,
00713       \textcolor{keywordtype}{char} *bmat, \textcolor{keywordtype}{int} *n, \textcolor{keywordtype}{char} *which, \textcolor{keywordtype}{int} *nev,
00714       \textcolor{keywordtype}{float} *tol, \textcolor{keywordtype}{float} *resid, \textcolor{keywordtype}{int} *ncv, \textcolor{keywordtype}{float} *v,
00715       \textcolor{keywordtype}{int} *ldv, \textcolor{keywordtype}{int} *iparam, \textcolor{keywordtype}{int} *ipntr, \textcolor{keywordtype}{float} *workd,
00716       \textcolor{keywordtype}{float} *workl, \textcolor{keywordtype}{int} *lworkl, \textcolor{keywordtype}{int} *ierr)
00717   \{
00718     sseupd\_(rvec, All, select, d, z, ldz, sigma, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, 
      ipntr,
00719         workd, workl, lworkl, ierr);
00720   \}
00721 \};
00722 
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00723}\hyperlink{struct_eigen_1_1internal_1_1arpack__wrapper_3_01double_00_01double_01_4}{00723} \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1arpack__wrapper}{arpack\_wrapper}<double, double>
00724 \{
00725   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} saupd(\textcolor{keywordtype}{int} *ido, \textcolor{keywordtype}{char} *bmat, \textcolor{keywordtype}{int} *n, \textcolor{keywordtype}{char} *which,
00726       \textcolor{keywordtype}{int} *nev, \textcolor{keywordtype}{double} *tol, \textcolor{keywordtype}{double} *resid, \textcolor{keywordtype}{int} *ncv,
00727       \textcolor{keywordtype}{double} *v, \textcolor{keywordtype}{int} *ldv, \textcolor{keywordtype}{int} *iparam, \textcolor{keywordtype}{int} *ipntr,
00728       \textcolor{keywordtype}{double} *workd, \textcolor{keywordtype}{double} *workl, \textcolor{keywordtype}{int} *lworkl, \textcolor{keywordtype}{int} *info)
00729   \{
00730     dsaupd\_(ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, ipntr, workd, workl, lworkl, info);
00731   \}
00732 
00733   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} seupd(\textcolor{keywordtype}{int} *rvec, \textcolor{keywordtype}{char} *All, \textcolor{keywordtype}{int} *select, \textcolor{keywordtype}{double} *d,
00734       \textcolor{keywordtype}{double} *z, \textcolor{keywordtype}{int} *ldz, \textcolor{keywordtype}{double} *sigma,
00735       \textcolor{keywordtype}{char} *bmat, \textcolor{keywordtype}{int} *n, \textcolor{keywordtype}{char} *which, \textcolor{keywordtype}{int} *nev,
00736       \textcolor{keywordtype}{double} *tol, \textcolor{keywordtype}{double} *resid, \textcolor{keywordtype}{int} *ncv, \textcolor{keywordtype}{double} *v,
00737       \textcolor{keywordtype}{int} *ldv, \textcolor{keywordtype}{int} *iparam, \textcolor{keywordtype}{int} *ipntr, \textcolor{keywordtype}{double} *workd,
00738       \textcolor{keywordtype}{double} *workl, \textcolor{keywordtype}{int} *lworkl, \textcolor{keywordtype}{int} *ierr)
00739   \{
00740     dseupd\_(rvec, All, select, d, v, ldv, sigma, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam, 
      ipntr,
00741         workd, workl, lworkl, ierr);
00742   \}
00743 \};
00744 
00745 
00746 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixSolver, \textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{bool} BisSPD>
00747 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_o_p}{OP}
00748 \{
00749     \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} applyOP(MatrixSolver &\hyperlink{struct_eigen_1_1internal_1_1_o_p}{OP}, \textcolor{keyword}{const} MatrixType &A, \textcolor{keywordtype}{int} n, Scalar *in, Scalar *out);
00750     \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} project(MatrixSolver &OP, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} k, Scalar *vecs);
00751 \};
00752 
00753 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixSolver, \textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00754}\hyperlink{struct_eigen_1_1internal_1_1_o_p_3_01_matrix_solver_00_01_matrix_type_00_01_scalar_00_01true_01_4}{00754} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_o_p}{OP}<MatrixSolver, MatrixType, Scalar, true>
00755 \{
00756   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} applyOP(MatrixSolver &\hyperlink{struct_eigen_1_1internal_1_1_o_p}{OP}, \textcolor{keyword}{const} MatrixType &A, \textcolor{keywordtype}{int} n, Scalar *in, Scalar *out)
00757 \{
00758     \textcolor{comment}{// OP = L^\{-1\} A L^\{-T\}  (B = LL^T)}
00759     \textcolor{comment}{//}
00760     \textcolor{comment}{// First solve L^T out = in}
00761     \textcolor{comment}{//}
00762     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(out, n) = OP.matrixU().solve(
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(in, n));
00763     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(out, n) = OP.permutationPinv() * 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(out, n);
00764 
00765     \textcolor{comment}{// Then compute out = A out}
00766     \textcolor{comment}{//}
00767     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(out, n) = A * 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, 1>::Map}(out, n);
00768 
00769     \textcolor{comment}{// Then solve L out = out}
00770     \textcolor{comment}{//}
00771     Matrix<Scalar, Dynamic, 1>::Map(out, n) = OP.permutationP() * Matrix<Scalar, Dynamic, 1>::Map(out, n);
00772     Matrix<Scalar, Dynamic, 1>::Map(out, n) = OP.matrixL().solve(Matrix<Scalar, Dynamic, 1>::Map(out, n));
00773 \}
00774 
00775   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} project(MatrixSolver &OP, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} k, Scalar *vecs)
00776 \{
00777     \textcolor{comment}{// Solve L^T out = in}
00778     \textcolor{comment}{//}
00779     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, Dynamic>::Map}(vecs, n, k) = OP.matrixU().
      solve(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, Dynamic>::Map}(vecs, n, k));
00780     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, Dynamic>::Map}(vecs, n, k) = OP.
      permutationPinv() * \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Dynamic, Dynamic>::Map}(vecs, n, k);
00781 \}
00782 
00783 \};
00784 
00785 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixSolver, \textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2unsupported_2_eigen_2src_2_eigenvalues_2_arpack_self_adjoint_eigen_solver_8h_source_l00786}\hyperlink{struct_eigen_1_1internal_1_1_o_p_3_01_matrix_solver_00_01_matrix_type_00_01_scalar_00_01false_01_4}{00786} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_o_p}{OP}<MatrixSolver, MatrixType, Scalar, false>
00787 \{
00788   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} applyOP(MatrixSolver &\hyperlink{struct_eigen_1_1internal_1_1_o_p}{OP}, \textcolor{keyword}{const} MatrixType &A, \textcolor{keywordtype}{int} n, Scalar *in, Scalar *out)
00789 \{
00790     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Should never be in here..."});
00791 \}
00792 
00793   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} project(MatrixSolver &OP, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} k, Scalar *vecs)
00794 \{
00795     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Should never be in here..."});
00796 \}
00797 
00798 \};
00799 
00800 \} \textcolor{comment}{// end namespace internal}
00801 
00802 \} \textcolor{comment}{// end namespace Eigen}
00803 
00804 \textcolor{preprocessor}{#endif // EIGEN\_ARPACKSELFADJOINTEIGENSOLVER\_H}
00805 
\end{DoxyCode}
