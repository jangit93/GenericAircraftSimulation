\hypertarget{visual__studio_2zlib_2infback_8c_source}{}\section{visual\+\_\+studio/zlib/infback.c}
\label{visual__studio_2zlib_2infback_8c_source}\index{infback.\+c@{infback.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* infback.c -- inflate using a call-back interface}
00002 \textcolor{comment}{ * Copyright (C) 1995-2016 Mark Adler}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ */}
00005 
00006 \textcolor{comment}{/*}
00007 \textcolor{comment}{   This code is largely copied from inflate.c.  Normally either infback.o or}
00008 \textcolor{comment}{   inflate.o would be linked into an application--not both.  The interface}
00009 \textcolor{comment}{   with inffast.c is retained so that optimized assembler-coded versions of}
00010 \textcolor{comment}{   inflate\_fast() can be used with either inflate.c or infback.c.}
00011 \textcolor{comment}{ */}
00012 
00013 \textcolor{preprocessor}{#include "zutil.h"}
00014 \textcolor{preprocessor}{#include "inftrees.h"}
00015 \textcolor{preprocessor}{#include "inflate.h"}
00016 \textcolor{preprocessor}{#include "inffast.h"}
00017 
00018 \textcolor{comment}{/* function prototypes */}
00019 local \textcolor{keywordtype}{void} fixedtables OF((\textcolor{keyword}{struct} \hyperlink{structinflate__state}{inflate\_state} FAR *\hyperlink{structstate}{state}));
00020 
00021 \textcolor{comment}{/*}
00022 \textcolor{comment}{   strm provides memory allocation functions in zalloc and zfree, or}
00023 \textcolor{comment}{   Z\_NULL to use the library memory allocation functions.}
00024 \textcolor{comment}{}
00025 \textcolor{comment}{   windowBits is in the range 8..15, and window is a user-supplied}
00026 \textcolor{comment}{   window and output buffer that is 2**windowBits bytes.}
00027 \textcolor{comment}{ */}
00028 \textcolor{keywordtype}{int} ZEXPORT inflateBackInit\_(strm, windowBits, window, version, stream\_size)
00029 z\_streamp strm;
00030 \textcolor{keywordtype}{int} windowBits;
00031 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *window;
00032 \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version;
00033 \textcolor{keywordtype}{int} stream\_size;
00034 \{
00035     \textcolor{keyword}{struct }\hyperlink{structinflate__state}{inflate\_state} FAR *\hyperlink{structstate}{state};
00036 
00037     \textcolor{keywordflow}{if} (version == Z\_NULL || version[0] != ZLIB\_VERSION[0] ||
00038         stream\_size != (\textcolor{keywordtype}{int})(\textcolor{keyword}{sizeof}(\hyperlink{structz__stream__s}{z\_stream})))
00039         \textcolor{keywordflow}{return} Z\_VERSION\_ERROR;
00040     \textcolor{keywordflow}{if} (strm == Z\_NULL || window == Z\_NULL ||
00041         windowBits < 8 || windowBits > 15)
00042         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00043     strm->msg = Z\_NULL;                 \textcolor{comment}{/* in case we return an error */}
00044     \textcolor{keywordflow}{if} (strm->zalloc == (alloc\_func)0) \{
00045 \textcolor{preprocessor}{#ifdef Z\_SOLO}
00046         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00047 \textcolor{preprocessor}{#else}
00048         strm->zalloc = zcalloc;
00049         strm->opaque = (voidpf)0;
00050 \textcolor{preprocessor}{#endif}
00051     \}
00052     \textcolor{keywordflow}{if} (strm->zfree == (free\_func)0)
00053 #ifdef Z\_SOLO
00054         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00055 \textcolor{preprocessor}{#else}
00056     strm->zfree = zcfree;
00057 \textcolor{preprocessor}{#endif}
00058     state = (\textcolor{keyword}{struct }\hyperlink{structinflate__state}{inflate\_state} FAR *)ZALLOC(strm, 1,
00059                                                \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structinflate__state}{inflate\_state}));
00060     \textcolor{keywordflow}{if} (state == Z\_NULL) \textcolor{keywordflow}{return} Z\_MEM\_ERROR;
00061     Tracev((stderr, \textcolor{stringliteral}{"inflate: allocated\(\backslash\)n"}));
00062     strm->state = (\textcolor{keyword}{struct }\hyperlink{structinternal__state}{internal\_state} FAR *)state;
00063     state->dmax = 32768U;
00064     state->wbits = (uInt)windowBits;
00065     state->wsize = 1U << windowBits;
00066     state->window = window;
00067     state->wnext = 0;
00068     state->whave = 0;
00069     \textcolor{keywordflow}{return} Z\_OK;
00070 \}
00071 
00072 \textcolor{comment}{/*}
00073 \textcolor{comment}{   Return state with length and distance decoding tables and index sizes set to}
00074 \textcolor{comment}{   fixed code decoding.  Normally this returns fixed tables from inffixed.h.}
00075 \textcolor{comment}{   If BUILDFIXED is defined, then instead this routine builds the tables the}
00076 \textcolor{comment}{   first time it's called, and returns those tables the first time and}
00077 \textcolor{comment}{   thereafter.  This reduces the size of the code by about 2K bytes, in}
00078 \textcolor{comment}{   exchange for a little execution time.  However, BUILDFIXED should not be}
00079 \textcolor{comment}{   used for threaded applications, since the rewriting of the tables and virgin}
00080 \textcolor{comment}{   may not be thread-safe.}
00081 \textcolor{comment}{ */}
00082 local \textcolor{keywordtype}{void} fixedtables(state)
00083 \textcolor{keyword}{struct }\hyperlink{structinflate__state}{inflate\_state} FAR *state;
00084 \{
00085 \textcolor{preprocessor}{#ifdef BUILDFIXED}
00086     \textcolor{keyword}{static} \textcolor{keywordtype}{int} virgin = 1;
00087     \textcolor{keyword}{static} \hyperlink{structcode}{code} *lenfix, *distfix;
00088     \textcolor{keyword}{static} \hyperlink{structcode}{code} fixed[544];
00089 
00090     \textcolor{comment}{/* build fixed huffman tables if first call (may not be thread safe) */}
00091     \textcolor{keywordflow}{if} (virgin) \{
00092         \textcolor{keywordtype}{unsigned} sym, bits;
00093         \textcolor{keyword}{static} \hyperlink{structcode}{code} *next;
00094 
00095         \textcolor{comment}{/* literal/length table */}
00096         sym = 0;
00097         \textcolor{keywordflow}{while} (sym < 144) state->lens[sym++] = 8;
00098         \textcolor{keywordflow}{while} (sym < 256) state->lens[sym++] = 9;
00099         \textcolor{keywordflow}{while} (sym < 280) state->lens[sym++] = 7;
00100         \textcolor{keywordflow}{while} (sym < 288) state->lens[sym++] = 8;
00101         next = fixed;
00102         lenfix = next;
00103         bits = 9;
00104         inflate\_table(LENS, state->lens, 288, &(next), &(bits), state->work);
00105 
00106         \textcolor{comment}{/* distance table */}
00107         sym = 0;
00108         \textcolor{keywordflow}{while} (sym < 32) state->lens[sym++] = 5;
00109         distfix = next;
00110         bits = 5;
00111         inflate\_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
00112 
00113         \textcolor{comment}{/* do this just once */}
00114         virgin = 0;
00115     \}
00116 \textcolor{preprocessor}{#else }\textcolor{comment}{/* !BUILDFIXED */}\textcolor{preprocessor}{}
00117 \textcolor{preprocessor}{#   include "inffixed.h"}
00118 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* BUILDFIXED */}\textcolor{preprocessor}{}
00119     state->lencode = lenfix;
00120     state->lenbits = 9;
00121     state->distcode = distfix;
00122     state->distbits = 5;
00123 \}
00124 
00125 \textcolor{comment}{/* Macros for inflateBack(): */}
00126 
00127 \textcolor{comment}{/* Load returned state from inflate\_fast() */}
00128 \textcolor{preprocessor}{#define LOAD() \(\backslash\)}
00129 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00130 \textcolor{preprocessor}{        put = strm->next\_out; \(\backslash\)}
00131 \textcolor{preprocessor}{        left = strm->avail\_out; \(\backslash\)}
00132 \textcolor{preprocessor}{        next = strm->next\_in; \(\backslash\)}
00133 \textcolor{preprocessor}{        have = strm->avail\_in; \(\backslash\)}
00134 \textcolor{preprocessor}{        hold = state->hold; \(\backslash\)}
00135 \textcolor{preprocessor}{        bits = state->bits; \(\backslash\)}
00136 \textcolor{preprocessor}{    \} while (0)}
00137 
00138 \textcolor{comment}{/* Set state from registers for inflate\_fast() */}
00139 \textcolor{preprocessor}{#define RESTORE() \(\backslash\)}
00140 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00141 \textcolor{preprocessor}{        strm->next\_out = put; \(\backslash\)}
00142 \textcolor{preprocessor}{        strm->avail\_out = left; \(\backslash\)}
00143 \textcolor{preprocessor}{        strm->next\_in = next; \(\backslash\)}
00144 \textcolor{preprocessor}{        strm->avail\_in = have; \(\backslash\)}
00145 \textcolor{preprocessor}{        state->hold = hold; \(\backslash\)}
00146 \textcolor{preprocessor}{        state->bits = bits; \(\backslash\)}
00147 \textcolor{preprocessor}{    \} while (0)}
00148 
00149 \textcolor{comment}{/* Clear the input bit accumulator */}
00150 \textcolor{preprocessor}{#define INITBITS() \(\backslash\)}
00151 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00152 \textcolor{preprocessor}{        hold = 0; \(\backslash\)}
00153 \textcolor{preprocessor}{        bits = 0; \(\backslash\)}
00154 \textcolor{preprocessor}{    \} while (0)}
00155 
00156 \textcolor{comment}{/* Assure that some input is available.  If input is requested, but denied,}
00157 \textcolor{comment}{   then return a Z\_BUF\_ERROR from inflateBack(). */}
00158 \textcolor{preprocessor}{#define PULL() \(\backslash\)}
00159 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00160 \textcolor{preprocessor}{        if (have == 0) \{ \(\backslash\)}
00161 \textcolor{preprocessor}{            have = in(in\_desc, &next); \(\backslash\)}
00162 \textcolor{preprocessor}{            if (have == 0) \{ \(\backslash\)}
00163 \textcolor{preprocessor}{                next = Z\_NULL; \(\backslash\)}
00164 \textcolor{preprocessor}{                ret = Z\_BUF\_ERROR; \(\backslash\)}
00165 \textcolor{preprocessor}{                goto inf\_leave; \(\backslash\)}
00166 \textcolor{preprocessor}{            \} \(\backslash\)}
00167 \textcolor{preprocessor}{        \} \(\backslash\)}
00168 \textcolor{preprocessor}{    \} while (0)}
00169 
00170 \textcolor{comment}{/* Get a byte of input into the bit accumulator, or return from inflateBack()}
00171 \textcolor{comment}{   with an error if there is no input available. */}
00172 \textcolor{preprocessor}{#define PULLBYTE() \(\backslash\)}
00173 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00174 \textcolor{preprocessor}{        PULL(); \(\backslash\)}
00175 \textcolor{preprocessor}{        have--; \(\backslash\)}
00176 \textcolor{preprocessor}{        hold += (unsigned long)(*next++) << bits; \(\backslash\)}
00177 \textcolor{preprocessor}{        bits += 8; \(\backslash\)}
00178 \textcolor{preprocessor}{    \} while (0)}
00179 
00180 \textcolor{comment}{/* Assure that there are at least n bits in the bit accumulator.  If there is}
00181 \textcolor{comment}{   not enough available input to do that, then return from inflateBack() with}
00182 \textcolor{comment}{   an error. */}
00183 \textcolor{preprocessor}{#define NEEDBITS(n) \(\backslash\)}
00184 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00185 \textcolor{preprocessor}{        while (bits < (unsigned)(n)) \(\backslash\)}
00186 \textcolor{preprocessor}{            PULLBYTE(); \(\backslash\)}
00187 \textcolor{preprocessor}{    \} while (0)}
00188 
00189 \textcolor{comment}{/* Return the low n bits of the bit accumulator (n < 16) */}
00190 \textcolor{preprocessor}{#define BITS(n) \(\backslash\)}
00191 \textcolor{preprocessor}{    ((unsigned)hold & ((1U << (n)) - 1))}
00192 
00193 \textcolor{comment}{/* Remove n bits from the bit accumulator */}
00194 \textcolor{preprocessor}{#define DROPBITS(n) \(\backslash\)}
00195 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00196 \textcolor{preprocessor}{        hold >>= (n); \(\backslash\)}
00197 \textcolor{preprocessor}{        bits -= (unsigned)(n); \(\backslash\)}
00198 \textcolor{preprocessor}{    \} while (0)}
00199 
00200 \textcolor{comment}{/* Remove zero to seven bits as needed to go to a byte boundary */}
00201 \textcolor{preprocessor}{#define BYTEBITS() \(\backslash\)}
00202 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00203 \textcolor{preprocessor}{        hold >>= bits & 7; \(\backslash\)}
00204 \textcolor{preprocessor}{        bits -= bits & 7; \(\backslash\)}
00205 \textcolor{preprocessor}{    \} while (0)}
00206 
00207 \textcolor{comment}{/* Assure that some output space is available, by writing out the window}
00208 \textcolor{comment}{   if it's full.  If the write fails, return from inflateBack() with a}
00209 \textcolor{comment}{   Z\_BUF\_ERROR. */}
00210 \textcolor{preprocessor}{#define ROOM() \(\backslash\)}
00211 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00212 \textcolor{preprocessor}{        if (left == 0) \{ \(\backslash\)}
00213 \textcolor{preprocessor}{            put = state->window; \(\backslash\)}
00214 \textcolor{preprocessor}{            left = state->wsize; \(\backslash\)}
00215 \textcolor{preprocessor}{            state->whave = left; \(\backslash\)}
00216 \textcolor{preprocessor}{            if (out(out\_desc, put, left)) \{ \(\backslash\)}
00217 \textcolor{preprocessor}{                ret = Z\_BUF\_ERROR; \(\backslash\)}
00218 \textcolor{preprocessor}{                goto inf\_leave; \(\backslash\)}
00219 \textcolor{preprocessor}{            \} \(\backslash\)}
00220 \textcolor{preprocessor}{        \} \(\backslash\)}
00221 \textcolor{preprocessor}{    \} while (0)}
00222 
00223 \textcolor{comment}{/*}
00224 \textcolor{comment}{   strm provides the memory allocation functions and window buffer on input,}
00225 \textcolor{comment}{   and provides information on the unused input on return.  For Z\_DATA\_ERROR}
00226 \textcolor{comment}{   returns, strm will also provide an error message.}
00227 \textcolor{comment}{}
00228 \textcolor{comment}{   in() and out() are the call-back input and output functions.  When}
00229 \textcolor{comment}{   inflateBack() needs more input, it calls in().  When inflateBack() has}
00230 \textcolor{comment}{   filled the window with output, or when it completes with data in the}
00231 \textcolor{comment}{   window, it calls out() to write out the data.  The application must not}
00232 \textcolor{comment}{   change the provided input until in() is called again or inflateBack()}
00233 \textcolor{comment}{   returns.  The application must not change the window/output buffer until}
00234 \textcolor{comment}{   inflateBack() returns.}
00235 \textcolor{comment}{}
00236 \textcolor{comment}{   in() and out() are called with a descriptor parameter provided in the}
00237 \textcolor{comment}{   inflateBack() call.  This parameter can be a structure that provides the}
00238 \textcolor{comment}{   information required to do the read or write, as well as accumulated}
00239 \textcolor{comment}{   information on the input and output such as totals and check values.}
00240 \textcolor{comment}{}
00241 \textcolor{comment}{   in() should return zero on failure.  out() should return non-zero on}
00242 \textcolor{comment}{   failure.  If either in() or out() fails, than inflateBack() returns a}
00243 \textcolor{comment}{   Z\_BUF\_ERROR.  strm->next\_in can be checked for Z\_NULL to see whether it}
00244 \textcolor{comment}{   was in() or out() that caused in the error.  Otherwise,  inflateBack()}
00245 \textcolor{comment}{   returns Z\_STREAM\_END on success, Z\_DATA\_ERROR for an deflate format}
00246 \textcolor{comment}{   error, or Z\_MEM\_ERROR if it could not allocate memory for the state.}
00247 \textcolor{comment}{   inflateBack() can also return Z\_STREAM\_ERROR if the input parameters}
00248 \textcolor{comment}{   are not correct, i.e. strm is Z\_NULL or the state was not initialized.}
00249 \textcolor{comment}{ */}
00250 \textcolor{keywordtype}{int} ZEXPORT inflateBack(strm, in, in\_desc, out, out\_desc)
00251 z\_streamp strm;
00252 in\_func in;
00253 \textcolor{keywordtype}{void} FAR *in\_desc;
00254 out\_func out;
00255 \textcolor{keywordtype}{void} FAR *out\_desc;
00256 \{
00257     \textcolor{keyword}{struct }\hyperlink{structinflate__state}{inflate\_state} FAR *state;
00258     z\_const \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *next;    \textcolor{comment}{/* next input */}
00259     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *put;     \textcolor{comment}{/* next output */}
00260     \textcolor{keywordtype}{unsigned} have, left;        \textcolor{comment}{/* available input and output */}
00261     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} hold;         \textcolor{comment}{/* bit buffer */}
00262     \textcolor{keywordtype}{unsigned} bits;              \textcolor{comment}{/* bits in bit buffer */}
00263     \textcolor{keywordtype}{unsigned} copy;              \textcolor{comment}{/* number of stored or match bytes to copy */}
00264     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *from;    \textcolor{comment}{/* where to copy match bytes from */}
00265     \hyperlink{structcode}{code} here;                  \textcolor{comment}{/* current decoding table entry */}
00266     \hyperlink{structcode}{code} last;                  \textcolor{comment}{/* parent table entry */}
00267     \textcolor{keywordtype}{unsigned} len;               \textcolor{comment}{/* length to copy for repeats, bits to drop */}
00268     \textcolor{keywordtype}{int} ret;                    \textcolor{comment}{/* return code */}
00269     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} order[19] = \textcolor{comment}{/* permutation of code lengths */}
00270         \{16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15\};
00271 
00272     \textcolor{comment}{/* Check that the strm exists and that the state was initialized */}
00273     \textcolor{keywordflow}{if} (strm == Z\_NULL || strm->state == Z\_NULL)
00274         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00275     state = (\textcolor{keyword}{struct }\hyperlink{structinflate__state}{inflate\_state} FAR *)strm->state;
00276 
00277     \textcolor{comment}{/* Reset the state */}
00278     strm->msg = Z\_NULL;
00279     state->mode = TYPE;
00280     state->last = 0;
00281     state->whave = 0;
00282     next = strm->next\_in;
00283     have = next != Z\_NULL ? strm->avail\_in : 0;
00284     hold = 0;
00285     bits = 0;
00286     put = state->window;
00287     left = state->wsize;
00288 
00289     \textcolor{comment}{/* Inflate until end of block marked as last */}
00290     for (;;)
00291         \textcolor{keywordflow}{switch} (state->mode) \{
00292         \textcolor{keywordflow}{case} TYPE:
00293             \textcolor{comment}{/* determine and dispatch block type */}
00294             \textcolor{keywordflow}{if} (state->last) \{
00295                 BYTEBITS();
00296                 state->mode = DONE;
00297                 \textcolor{keywordflow}{break};
00298             \}
00299             NEEDBITS(3);
00300             state->last = BITS(1);
00301             DROPBITS(1);
00302             \textcolor{keywordflow}{switch} (BITS(2)) \{
00303             \textcolor{keywordflow}{case} 0:                             \textcolor{comment}{/* stored block */}
00304                 Tracev((stderr, \textcolor{stringliteral}{"inflate:     stored block%s\(\backslash\)n"},
00305                         state->last ? \textcolor{stringliteral}{" (last)"} : \textcolor{stringliteral}{""}));
00306                 state->mode = STORED;
00307                 \textcolor{keywordflow}{break};
00308             \textcolor{keywordflow}{case} 1:                             \textcolor{comment}{/* fixed block */}
00309                 fixedtables(state);
00310                 Tracev((stderr, \textcolor{stringliteral}{"inflate:     fixed codes block%s\(\backslash\)n"},
00311                         state->last ? \textcolor{stringliteral}{" (last)"} : \textcolor{stringliteral}{""}));
00312                 state->mode = LEN;              \textcolor{comment}{/* decode codes */}
00313                 \textcolor{keywordflow}{break};
00314             \textcolor{keywordflow}{case} 2:                             \textcolor{comment}{/* dynamic block */}
00315                 Tracev((stderr, \textcolor{stringliteral}{"inflate:     dynamic codes block%s\(\backslash\)n"},
00316                         state->last ? \textcolor{stringliteral}{" (last)"} : \textcolor{stringliteral}{""}));
00317                 state->mode = TABLE;
00318                 \textcolor{keywordflow}{break};
00319             \textcolor{keywordflow}{case} 3:
00320                 strm->msg = (\textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"invalid block type"};
00321                 state->mode = BAD;
00322             \}
00323             DROPBITS(2);
00324             \textcolor{keywordflow}{break};
00325 
00326         \textcolor{keywordflow}{case} STORED:
00327             \textcolor{comment}{/* get and verify stored block length */}
00328             BYTEBITS();                         \textcolor{comment}{/* go to byte boundary */}
00329             NEEDBITS(32);
00330             \textcolor{keywordflow}{if} ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) \{
00331                 strm->msg = (\textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"invalid stored block lengths"};
00332                 state->mode = BAD;
00333                 \textcolor{keywordflow}{break};
00334             \}
00335             state->length = (unsigned)hold & 0xffff;
00336             Tracev((stderr, \textcolor{stringliteral}{"inflate:       stored length %u\(\backslash\)n"},
00337                     state->length));
00338             INITBITS();
00339 
00340             \textcolor{comment}{/* copy stored block from input to output */}
00341             \textcolor{keywordflow}{while} (state->length != 0) \{
00342                 copy = state->length;
00343                 PULL();
00344                 ROOM();
00345                 \textcolor{keywordflow}{if} (copy > have) copy = have;
00346                 \textcolor{keywordflow}{if} (copy > left) copy = left;
00347                 zmemcpy(put, next, copy);
00348                 have -= copy;
00349                 next += copy;
00350                 left -= copy;
00351                 put += copy;
00352                 state->length -= copy;
00353             \}
00354             Tracev((stderr, \textcolor{stringliteral}{"inflate:       stored end\(\backslash\)n"}));
00355             state->mode = TYPE;
00356             \textcolor{keywordflow}{break};
00357 
00358         \textcolor{keywordflow}{case} TABLE:
00359             \textcolor{comment}{/* get dynamic table entries descriptor */}
00360             NEEDBITS(14);
00361             state->nlen = BITS(5) + 257;
00362             DROPBITS(5);
00363             state->ndist = BITS(5) + 1;
00364             DROPBITS(5);
00365             state->ncode = BITS(4) + 4;
00366             DROPBITS(4);
00367 \textcolor{preprocessor}{#ifndef PKZIP\_BUG\_WORKAROUND}
00368             \textcolor{keywordflow}{if} (state->nlen > 286 || state->ndist > 30) \{
00369                 strm->msg = (\textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"too many length or distance symbols"};
00370                 state->mode = BAD;
00371                 \textcolor{keywordflow}{break};
00372             \}
00373 \textcolor{preprocessor}{#endif}
00374             Tracev((stderr, \textcolor{stringliteral}{"inflate:       table sizes ok\(\backslash\)n"}));
00375 
00376             \textcolor{comment}{/* get code length code lengths (not a typo) */}
00377             state->have = 0;
00378             \textcolor{keywordflow}{while} (state->have < state->ncode) \{
00379                 NEEDBITS(3);
00380                 state->lens[order[state->have++]] = (\textcolor{keywordtype}{unsigned} short)BITS(3);
00381                 DROPBITS(3);
00382             \}
00383             \textcolor{keywordflow}{while} (state->have < 19)
00384                 state->lens[order[state->have++]] = 0;
00385             state->next = state->codes;
00386             state->lencode = (\hyperlink{structcode}{code} \textcolor{keyword}{const} FAR *)(state->next);
00387             state->lenbits = 7;
00388             ret = inflate\_table(CODES, state->lens, 19, &(state->next),
00389                                 &(state->lenbits), state->work);
00390             \textcolor{keywordflow}{if} (ret) \{
00391                 strm->msg = (\textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"invalid code lengths set"};
00392                 state->mode = BAD;
00393                 \textcolor{keywordflow}{break};
00394             \}
00395             Tracev((stderr, \textcolor{stringliteral}{"inflate:       code lengths ok\(\backslash\)n"}));
00396 
00397             \textcolor{comment}{/* get length and distance code code lengths */}
00398             state->have = 0;
00399             \textcolor{keywordflow}{while} (state->have < state->nlen + state->ndist) \{
00400                 \textcolor{keywordflow}{for} (;;) \{
00401                     here = state->lencode[BITS(state->lenbits)];
00402                     \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned})(here.bits) <= bits) \textcolor{keywordflow}{break};
00403                     PULLBYTE();
00404                 \}
00405                 \textcolor{keywordflow}{if} (here.val < 16) \{
00406                     DROPBITS(here.bits);
00407                     state->lens[state->have++] = here.val;
00408                 \}
00409                 \textcolor{keywordflow}{else} \{
00410                     \textcolor{keywordflow}{if} (here.val == 16) \{
00411                         NEEDBITS(here.bits + 2);
00412                         DROPBITS(here.bits);
00413                         \textcolor{keywordflow}{if} (state->have == 0) \{
00414                             strm->msg = (\textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"invalid bit length repeat"};
00415                             state->mode = BAD;
00416                             \textcolor{keywordflow}{break};
00417                         \}
00418                         len = (unsigned)(state->lens[state->have - 1]);
00419                         copy = 3 + BITS(2);
00420                         DROPBITS(2);
00421                     \}
00422                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (here.val == 17) \{
00423                         NEEDBITS(here.bits + 3);
00424                         DROPBITS(here.bits);
00425                         len = 0;
00426                         copy = 3 + BITS(3);
00427                         DROPBITS(3);
00428                     \}
00429                     \textcolor{keywordflow}{else} \{
00430                         NEEDBITS(here.bits + 7);
00431                         DROPBITS(here.bits);
00432                         len = 0;
00433                         copy = 11 + BITS(7);
00434                         DROPBITS(7);
00435                     \}
00436                     \textcolor{keywordflow}{if} (state->have + copy > state->nlen + state->ndist) \{
00437                         strm->msg = (\textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"invalid bit length repeat"};
00438                         state->mode = BAD;
00439                         \textcolor{keywordflow}{break};
00440                     \}
00441                     \textcolor{keywordflow}{while} (copy--)
00442                         state->lens[state->have++] = (\textcolor{keywordtype}{unsigned} short)len;
00443                 \}
00444             \}
00445 
00446             \textcolor{comment}{/* handle error breaks in while */}
00447             \textcolor{keywordflow}{if} (state->mode == BAD) \textcolor{keywordflow}{break};
00448 
00449             \textcolor{comment}{/* check for end-of-block code (better have one) */}
00450             \textcolor{keywordflow}{if} (state->lens[256] == 0) \{
00451                 strm->msg = (\textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"invalid code -- missing end-of-block"};
00452                 state->mode = BAD;
00453                 \textcolor{keywordflow}{break};
00454             \}
00455 
00456             \textcolor{comment}{/* build code tables -- note: do not change the lenbits or distbits}
00457 \textcolor{comment}{               values here (9 and 6) without reading the comments in inftrees.h}
00458 \textcolor{comment}{               concerning the ENOUGH constants, which depend on those values */}
00459             state->next = state->codes;
00460             state->lencode = (\hyperlink{structcode}{code} \textcolor{keyword}{const} FAR *)(state->next);
00461             state->lenbits = 9;
00462             ret = inflate\_table(LENS, state->lens, state->nlen, &(state->next),
00463                                 &(state->lenbits), state->work);
00464             \textcolor{keywordflow}{if} (ret) \{
00465                 strm->msg = (\textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"invalid literal/lengths set"};
00466                 state->mode = BAD;
00467                 \textcolor{keywordflow}{break};
00468             \}
00469             state->distcode = (\hyperlink{structcode}{code} \textcolor{keyword}{const} FAR *)(state->next);
00470             state->distbits = 6;
00471             ret = inflate\_table(DISTS, state->lens + state->nlen, state->ndist,
00472                             &(state->next), &(state->distbits), state->work);
00473             \textcolor{keywordflow}{if} (ret) \{
00474                 strm->msg = (\textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"invalid distances set"};
00475                 state->mode = BAD;
00476                 \textcolor{keywordflow}{break};
00477             \}
00478             Tracev((stderr, \textcolor{stringliteral}{"inflate:       codes ok\(\backslash\)n"}));
00479             state->mode = LEN;
00480 
00481         \textcolor{keywordflow}{case} LEN:
00482             \textcolor{comment}{/* use inflate\_fast() if we have enough input and output */}
00483             \textcolor{keywordflow}{if} (have >= 6 && left >= 258) \{
00484                 RESTORE();
00485                 \textcolor{keywordflow}{if} (state->whave < state->wsize)
00486                     state->whave = state->wsize - left;
00487                 inflate\_fast(strm, state->wsize);
00488                 LOAD();
00489                 \textcolor{keywordflow}{break};
00490             \}
00491 
00492             \textcolor{comment}{/* get a literal, length, or end-of-block code */}
00493             \textcolor{keywordflow}{for} (;;) \{
00494                 here = state->lencode[BITS(state->lenbits)];
00495                 \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned})(here.bits) <= bits) \textcolor{keywordflow}{break};
00496                 PULLBYTE();
00497             \}
00498             \textcolor{keywordflow}{if} (here.op && (here.op & 0xf0) == 0) \{
00499                 last = here;
00500                 \textcolor{keywordflow}{for} (;;) \{
00501                     here = state->lencode[last.val +
00502                             (BITS(last.bits + last.op) >> last.bits)];
00503                     \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned})(last.bits + here.bits) <= bits) \textcolor{keywordflow}{break};
00504                     PULLBYTE();
00505                 \}
00506                 DROPBITS(last.bits);
00507             \}
00508             DROPBITS(here.bits);
00509             state->length = (unsigned)here.val;
00510 
00511             \textcolor{comment}{/* process literal */}
00512             if (here.op == 0) \{
00513                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
00514                         \textcolor{stringliteral}{"inflate:         literal '%c'\(\backslash\)n"} :
00515                         \textcolor{stringliteral}{"inflate:         literal 0x%02x\(\backslash\)n"}, here.val));
00516                 ROOM();
00517                 *put++ = (\textcolor{keywordtype}{unsigned} char)(state->length);
00518                 left--;
00519                 state->mode = LEN;
00520                 \textcolor{keywordflow}{break};
00521             \}
00522 
00523             \textcolor{comment}{/* process end of block */}
00524             \textcolor{keywordflow}{if} (here.op & 32) \{
00525                 Tracevv((stderr, \textcolor{stringliteral}{"inflate:         end of block\(\backslash\)n"}));
00526                 state->mode = TYPE;
00527                 \textcolor{keywordflow}{break};
00528             \}
00529 
00530             \textcolor{comment}{/* invalid code */}
00531             \textcolor{keywordflow}{if} (here.op & 64) \{
00532                 strm->msg = (\textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"invalid literal/length code"};
00533                 state->mode = BAD;
00534                 \textcolor{keywordflow}{break};
00535             \}
00536 
00537             \textcolor{comment}{/* length code -- get extra bits, if any */}
00538             state->extra = (unsigned)(here.op) & 15;
00539             \textcolor{keywordflow}{if} (state->extra != 0) \{
00540                 NEEDBITS(state->extra);
00541                 state->length += BITS(state->extra);
00542                 DROPBITS(state->extra);
00543             \}
00544             Tracevv((stderr, \textcolor{stringliteral}{"inflate:         length %u\(\backslash\)n"}, state->length));
00545 
00546             \textcolor{comment}{/* get distance code */}
00547             \textcolor{keywordflow}{for} (;;) \{
00548                 here = state->distcode[BITS(state->distbits)];
00549                 \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned})(here.bits) <= bits) \textcolor{keywordflow}{break};
00550                 PULLBYTE();
00551             \}
00552             \textcolor{keywordflow}{if} ((here.op & 0xf0) == 0) \{
00553                 last = here;
00554                 \textcolor{keywordflow}{for} (;;) \{
00555                     here = state->distcode[last.val +
00556                             (BITS(last.bits + last.op) >> last.bits)];
00557                     \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned})(last.bits + here.bits) <= bits) \textcolor{keywordflow}{break};
00558                     PULLBYTE();
00559                 \}
00560                 DROPBITS(last.bits);
00561             \}
00562             DROPBITS(here.bits);
00563             \textcolor{keywordflow}{if} (here.op & 64) \{
00564                 strm->msg = (\textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"invalid distance code"};
00565                 state->mode = BAD;
00566                 \textcolor{keywordflow}{break};
00567             \}
00568             state->offset = (unsigned)here.val;
00569 
00570             \textcolor{comment}{/* get distance extra bits, if any */}
00571             state->extra = (\textcolor{keywordtype}{unsigned})(here.op) & 15;
00572             \textcolor{keywordflow}{if} (state->extra != 0) \{
00573                 NEEDBITS(state->extra);
00574                 state->offset += BITS(state->extra);
00575                 DROPBITS(state->extra);
00576             \}
00577             \textcolor{keywordflow}{if} (state->offset > state->wsize - (state->whave < state->wsize ?
00578                                                 left : 0)) \{
00579                 strm->msg = (\textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"invalid distance too far back"};
00580                 state->mode = BAD;
00581                 \textcolor{keywordflow}{break};
00582             \}
00583             Tracevv((stderr, \textcolor{stringliteral}{"inflate:         distance %u\(\backslash\)n"}, state->offset));
00584 
00585             \textcolor{comment}{/* copy match from window to output */}
00586             \textcolor{keywordflow}{do} \{
00587                 ROOM();
00588                 copy = state->wsize - state->offset;
00589                 \textcolor{keywordflow}{if} (copy < left) \{
00590                     from = put + copy;
00591                     copy = left - copy;
00592                 \}
00593                 \textcolor{keywordflow}{else} \{
00594                     from = put - state->offset;
00595                     copy = left;
00596                 \}
00597                 \textcolor{keywordflow}{if} (copy > state->length) copy = state->length;
00598                 state->length -= copy;
00599                 left -= copy;
00600                 \textcolor{keywordflow}{do} \{
00601                     *put++ = *from++;
00602                 \} \textcolor{keywordflow}{while} (--copy);
00603             \} \textcolor{keywordflow}{while} (state->length != 0);
00604             \textcolor{keywordflow}{break};
00605 
00606         \textcolor{keywordflow}{case} DONE:
00607             \textcolor{comment}{/* inflate stream terminated properly -- write leftover output */}
00608             ret = Z\_STREAM\_END;
00609             \textcolor{keywordflow}{if} (left < state->wsize) \{
00610                 \textcolor{keywordflow}{if} (out(out\_desc, state->window, state->wsize - left))
00611                     ret = Z\_BUF\_ERROR;
00612             \}
00613             \textcolor{keywordflow}{goto} inf\_leave;
00614 
00615         \textcolor{keywordflow}{case} BAD:
00616             ret = Z\_DATA\_ERROR;
00617             \textcolor{keywordflow}{goto} inf\_leave;
00618 
00619         \textcolor{keywordflow}{default}:                \textcolor{comment}{/* can't happen, but makes compilers happy */}
00620             ret = Z\_STREAM\_ERROR;
00621             \textcolor{keywordflow}{goto} inf\_leave;
00622         \}
00623 
00624     \textcolor{comment}{/* Return unused input */}
00625   inf\_leave:
00626     strm->next\_in = next;
00627     strm->avail\_in = have;
00628     \textcolor{keywordflow}{return} ret;
00629 \}
00630 
00631 \textcolor{keywordtype}{int} ZEXPORT inflateBackEnd(strm)
00632 z\_streamp strm;
00633 \{
00634     \textcolor{keywordflow}{if} (strm == Z\_NULL || strm->state == Z\_NULL || strm->zfree == (free\_func)0)
00635         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00636     ZFREE(strm, strm->state);
00637     strm->state = Z\_NULL;
00638     Tracev((stderr, \textcolor{stringliteral}{"inflate: end\(\backslash\)n"}));
00639     \textcolor{keywordflow}{return} Z\_OK;
00640 \}
\end{DoxyCode}
