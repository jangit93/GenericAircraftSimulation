\hypertarget{visual__studio_2zlib_2zutil_8c_source}{}\section{visual\+\_\+studio/zlib/zutil.c}
\label{visual__studio_2zlib_2zutil_8c_source}\index{zutil.\+c@{zutil.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* zutil.c -- target dependent utility functions for the compression library}
00002 \textcolor{comment}{ * Copyright (C) 1995-2017 Jean-loup Gailly}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ */}
00005 
00006 \textcolor{comment}{/* @(#) $Id$ */}
00007 
00008 \textcolor{preprocessor}{#include "zutil.h"}
00009 \textcolor{preprocessor}{#ifndef Z\_SOLO}
00010 \textcolor{preprocessor}{#  include "gzguts.h"}
00011 \textcolor{preprocessor}{#endif}
00012 
00013 z\_const \textcolor{keywordtype}{char} * \textcolor{keyword}{const} z\_errmsg[10] = \{
00014     (z\_const \textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"need dictionary"},     \textcolor{comment}{/* Z\_NEED\_DICT       2  */}
00015     (z\_const \textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"stream end"},          \textcolor{comment}{/* Z\_STREAM\_END      1  */}
00016     (z\_const \textcolor{keywordtype}{char} *)\textcolor{stringliteral}{""},                    \textcolor{comment}{/* Z\_OK              0  */}
00017     (z\_const \textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"file error"},          \textcolor{comment}{/* Z\_ERRNO         (-1) */}
00018     (z\_const \textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"stream error"},        \textcolor{comment}{/* Z\_STREAM\_ERROR  (-2) */}
00019     (z\_const \textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"data error"},          \textcolor{comment}{/* Z\_DATA\_ERROR    (-3) */}
00020     (z\_const \textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"insufficient memory"}, \textcolor{comment}{/* Z\_MEM\_ERROR     (-4) */}
00021     (z\_const \textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"buffer error"},        \textcolor{comment}{/* Z\_BUF\_ERROR     (-5) */}
00022     (z\_const \textcolor{keywordtype}{char} *)\textcolor{stringliteral}{"incompatible version"},\textcolor{comment}{/* Z\_VERSION\_ERROR (-6) */}
00023     (z\_const \textcolor{keywordtype}{char} *)\textcolor{stringliteral}{""}
00024 \};
00025 
00026 
00027 \textcolor{keyword}{const} \textcolor{keywordtype}{char} * ZEXPORT zlibVersion()
00028 \{
00029     \textcolor{keywordflow}{return} ZLIB\_VERSION;
00030 \}
00031 
00032 uLong ZEXPORT zlibCompileFlags()
00033 \{
00034     uLong flags;
00035 
00036     flags = 0;
00037     \textcolor{keywordflow}{switch} ((\textcolor{keywordtype}{int})(\textcolor{keyword}{sizeof}(uInt))) \{
00038     \textcolor{keywordflow}{case} 2:     \textcolor{keywordflow}{break};
00039     \textcolor{keywordflow}{case} 4:     flags += 1;     \textcolor{keywordflow}{break};
00040     \textcolor{keywordflow}{case} 8:     flags += 2;     \textcolor{keywordflow}{break};
00041     \textcolor{keywordflow}{default}:    flags += 3;
00042     \}
00043     \textcolor{keywordflow}{switch} ((\textcolor{keywordtype}{int})(\textcolor{keyword}{sizeof}(uLong))) \{
00044     \textcolor{keywordflow}{case} 2:     \textcolor{keywordflow}{break};
00045     \textcolor{keywordflow}{case} 4:     flags += 1 << 2;        \textcolor{keywordflow}{break};
00046     \textcolor{keywordflow}{case} 8:     flags += 2 << 2;        \textcolor{keywordflow}{break};
00047     \textcolor{keywordflow}{default}:    flags += 3 << 2;
00048     \}
00049     \textcolor{keywordflow}{switch} ((\textcolor{keywordtype}{int})(\textcolor{keyword}{sizeof}(voidpf))) \{
00050     \textcolor{keywordflow}{case} 2:     \textcolor{keywordflow}{break};
00051     \textcolor{keywordflow}{case} 4:     flags += 1 << 4;        \textcolor{keywordflow}{break};
00052     \textcolor{keywordflow}{case} 8:     flags += 2 << 4;        \textcolor{keywordflow}{break};
00053     \textcolor{keywordflow}{default}:    flags += 3 << 4;
00054     \}
00055     \textcolor{keywordflow}{switch} ((\textcolor{keywordtype}{int})(\textcolor{keyword}{sizeof}(z\_off\_t))) \{
00056     \textcolor{keywordflow}{case} 2:     \textcolor{keywordflow}{break};
00057     \textcolor{keywordflow}{case} 4:     flags += 1 << 6;        \textcolor{keywordflow}{break};
00058     \textcolor{keywordflow}{case} 8:     flags += 2 << 6;        \textcolor{keywordflow}{break};
00059     \textcolor{keywordflow}{default}:    flags += 3 << 6;
00060     \}
00061 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
00062     flags += 1 << 8;
00063 \textcolor{preprocessor}{#endif}
00064 \textcolor{preprocessor}{#if defined(ASMV) || defined(ASMINF)}
00065     flags += 1 << 9;
00066 \textcolor{preprocessor}{#endif}
00067 \textcolor{preprocessor}{#ifdef ZLIB\_WINAPI}
00068     flags += 1 << 10;
00069 \textcolor{preprocessor}{#endif}
00070 \textcolor{preprocessor}{#ifdef BUILDFIXED}
00071     flags += 1 << 12;
00072 \textcolor{preprocessor}{#endif}
00073 \textcolor{preprocessor}{#ifdef DYNAMIC\_CRC\_TABLE}
00074     flags += 1 << 13;
00075 \textcolor{preprocessor}{#endif}
00076 \textcolor{preprocessor}{#ifdef NO\_GZCOMPRESS}
00077     flags += 1L << 16;
00078 \textcolor{preprocessor}{#endif}
00079 \textcolor{preprocessor}{#ifdef NO\_GZIP}
00080     flags += 1L << 17;
00081 \textcolor{preprocessor}{#endif}
00082 \textcolor{preprocessor}{#ifdef PKZIP\_BUG\_WORKAROUND}
00083     flags += 1L << 20;
00084 \textcolor{preprocessor}{#endif}
00085 \textcolor{preprocessor}{#ifdef FASTEST}
00086     flags += 1L << 21;
00087 \textcolor{preprocessor}{#endif}
00088 \textcolor{preprocessor}{#if defined(STDC) || defined(Z\_HAVE\_STDARG\_H)}
00089 \textcolor{preprocessor}{#  ifdef NO\_vsnprintf}
00090     flags += 1L << 25;
00091 \textcolor{preprocessor}{#    ifdef HAS\_vsprintf\_void}
00092     flags += 1L << 26;
00093 \textcolor{preprocessor}{#    endif}
00094 \textcolor{preprocessor}{#  else}
00095 \textcolor{preprocessor}{#    ifdef HAS\_vsnprintf\_void}
00096     flags += 1L << 26;
00097 \textcolor{preprocessor}{#    endif}
00098 \textcolor{preprocessor}{#  endif}
00099 \textcolor{preprocessor}{#else}
00100     flags += 1L << 24;
00101 \textcolor{preprocessor}{#  ifdef NO\_snprintf}
00102     flags += 1L << 25;
00103 \textcolor{preprocessor}{#    ifdef HAS\_sprintf\_void}
00104     flags += 1L << 26;
00105 \textcolor{preprocessor}{#    endif}
00106 \textcolor{preprocessor}{#  else}
00107 \textcolor{preprocessor}{#    ifdef HAS\_snprintf\_void}
00108     flags += 1L << 26;
00109 \textcolor{preprocessor}{#    endif}
00110 \textcolor{preprocessor}{#  endif}
00111 \textcolor{preprocessor}{#endif}
00112     \textcolor{keywordflow}{return} flags;
00113 \}
00114 
00115 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
00116 \textcolor{preprocessor}{#include <stdlib.h>}
00117 \textcolor{preprocessor}{#  ifndef verbose}
00118 \textcolor{preprocessor}{#    define verbose 0}
00119 \textcolor{preprocessor}{#  endif}
00120 \textcolor{keywordtype}{int} ZLIB\_INTERNAL z\_verbose = verbose;
00121 
00122 \textcolor{keywordtype}{void} ZLIB\_INTERNAL z\_error (m)
00123     \textcolor{keywordtype}{char} *m;
00124 \{
00125     fprintf(stderr, \textcolor{stringliteral}{"%s\(\backslash\)n"}, m);
00126     exit(1);
00127 \}
00128 \textcolor{preprocessor}{#endif}
00129 
00130 \textcolor{comment}{/* exported to allow conversion of error code to string for compress() and}
00131 \textcolor{comment}{ * uncompress()}
00132 \textcolor{comment}{ */}
00133 \textcolor{keyword}{const} \textcolor{keywordtype}{char} * ZEXPORT zError(err)
00134     \textcolor{keywordtype}{int} err;
00135 \{
00136     \textcolor{keywordflow}{return} ERR\_MSG(err);
00137 \}
00138 
00139 \textcolor{preprocessor}{#if defined(\_WIN32\_WCE)}
00140     \textcolor{comment}{/* The Microsoft C Run-Time Library for Windows CE doesn't have}
00141 \textcolor{comment}{     * errno.  We define it as a global variable to simplify porting.}
00142 \textcolor{comment}{     * Its value is always 0 and should not be used.}
00143 \textcolor{comment}{     */}
00144     \textcolor{keywordtype}{int} errno = 0;
00145 \textcolor{preprocessor}{#endif}
00146 
00147 \textcolor{preprocessor}{#ifndef HAVE\_MEMCPY}
00148 
00149 \textcolor{keywordtype}{void} ZLIB\_INTERNAL zmemcpy(dest, source, len)
00150     Bytef* dest;
00151     \textcolor{keyword}{const} Bytef* source;
00152     uInt  len;
00153 \{
00154     \textcolor{keywordflow}{if} (len == 0) \textcolor{keywordflow}{return};
00155     \textcolor{keywordflow}{do} \{
00156         *dest++ = *source++; \textcolor{comment}{/* ??? to be unrolled */}
00157     \} \textcolor{keywordflow}{while} (--len != 0);
00158 \}
00159 
00160 \textcolor{keywordtype}{int} ZLIB\_INTERNAL zmemcmp(s1, s2, len)
00161     \textcolor{keyword}{const} Bytef* s1;
00162     \textcolor{keyword}{const} Bytef* s2;
00163     uInt  len;
00164 \{
00165     uInt j;
00166 
00167     \textcolor{keywordflow}{for} (j = 0; j < len; j++) \{
00168         \textcolor{keywordflow}{if} (s1[j] != s2[j]) \textcolor{keywordflow}{return} 2*(s1[j] > s2[j])-1;
00169     \}
00170     \textcolor{keywordflow}{return} 0;
00171 \}
00172 
00173 \textcolor{keywordtype}{void} ZLIB\_INTERNAL zmemzero(dest, len)
00174     Bytef* dest;
00175     uInt  len;
00176 \{
00177     \textcolor{keywordflow}{if} (len == 0) \textcolor{keywordflow}{return};
00178     \textcolor{keywordflow}{do} \{
00179         *dest++ = 0;  \textcolor{comment}{/* ??? to be unrolled */}
00180     \} \textcolor{keywordflow}{while} (--len != 0);
00181 \}
00182 \textcolor{preprocessor}{#endif}
00183 
00184 \textcolor{preprocessor}{#ifndef Z\_SOLO}
00185 
00186 \textcolor{preprocessor}{#ifdef SYS16BIT}
00187 
00188 \textcolor{preprocessor}{#ifdef \_\_TURBOC\_\_}
00189 \textcolor{comment}{/* Turbo C in 16-bit mode */}
00190 
00191 \textcolor{preprocessor}{#  define MY\_ZCALLOC}
00192 
00193 \textcolor{comment}{/* Turbo C malloc() does not allow dynamic allocation of 64K bytes}
00194 \textcolor{comment}{ * and farmalloc(64K) returns a pointer with an offset of 8, so we}
00195 \textcolor{comment}{ * must fix the pointer. Warning: the pointer must be put back to its}
00196 \textcolor{comment}{ * original form in order to free it, use zcfree().}
00197 \textcolor{comment}{ */}
00198 
00199 \textcolor{preprocessor}{#define MAX\_PTR 10}
00200 \textcolor{comment}{/* 10*64K = 640K */}
00201 
00202 local \textcolor{keywordtype}{int} next\_ptr = 0;
00203 
00204 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }ptr\_table\_s \{
00205     voidpf org\_ptr;
00206     voidpf new\_ptr;
00207 \} ptr\_table;
00208 
00209 local ptr\_table table[MAX\_PTR];
00210 \textcolor{comment}{/* This table is used to remember the original form of pointers}
00211 \textcolor{comment}{ * to large buffers (64K). Such pointers are normalized with a zero offset.}
00212 \textcolor{comment}{ * Since MSDOS is not a preemptive multitasking OS, this table is not}
00213 \textcolor{comment}{ * protected from concurrent access. This hack doesn't work anyway on}
00214 \textcolor{comment}{ * a protected system like OS/2. Use Microsoft C instead.}
00215 \textcolor{comment}{ */}
00216 
00217 voidpf ZLIB\_INTERNAL zcalloc (voidpf opaque, \textcolor{keywordtype}{unsigned} items, \textcolor{keywordtype}{unsigned} size)
00218 \{
00219     voidpf buf;
00220     ulg bsize = (ulg)items*size;
00221 
00222     (void)opaque;
00223 
00224     \textcolor{comment}{/* If we allocate less than 65520 bytes, we assume that farmalloc}
00225 \textcolor{comment}{     * will return a usable pointer which doesn't have to be normalized.}
00226 \textcolor{comment}{     */}
00227     \textcolor{keywordflow}{if} (bsize < 65520L) \{
00228         buf = farmalloc(bsize);
00229         \textcolor{keywordflow}{if} (*(ush*)&buf != 0) \textcolor{keywordflow}{return} buf;
00230     \} \textcolor{keywordflow}{else} \{
00231         buf = farmalloc(bsize + 16L);
00232     \}
00233     \textcolor{keywordflow}{if} (buf == NULL || next\_ptr >= MAX\_PTR) \textcolor{keywordflow}{return} NULL;
00234     table[next\_ptr].org\_ptr = buf;
00235 
00236     \textcolor{comment}{/* Normalize the pointer to seg:0 */}
00237     *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
00238     *(ush*)&buf = 0;
00239     table[next\_ptr++].new\_ptr = buf;
00240     \textcolor{keywordflow}{return} buf;
00241 \}
00242 
00243 \textcolor{keywordtype}{void} ZLIB\_INTERNAL zcfree (voidpf opaque, voidpf ptr)
00244 \{
00245     \textcolor{keywordtype}{int} n;
00246 
00247     (void)opaque;
00248 
00249     \textcolor{keywordflow}{if} (*(ush*)&ptr != 0) \{ \textcolor{comment}{/* object < 64K */}
00250         farfree(ptr);
00251         \textcolor{keywordflow}{return};
00252     \}
00253     \textcolor{comment}{/* Find the original pointer */}
00254     \textcolor{keywordflow}{for} (n = 0; n < next\_ptr; n++) \{
00255         \textcolor{keywordflow}{if} (ptr != table[n].new\_ptr) \textcolor{keywordflow}{continue};
00256 
00257         farfree(table[n].org\_ptr);
00258         \textcolor{keywordflow}{while} (++n < next\_ptr) \{
00259             table[n-1] = table[n];
00260         \}
00261         next\_ptr--;
00262         \textcolor{keywordflow}{return};
00263     \}
00264     Assert(0, \textcolor{stringliteral}{"zcfree: ptr not found"});
00265 \}
00266 
00267 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* \_\_TURBOC\_\_ */}\textcolor{preprocessor}{}
00268 
00269 
00270 \textcolor{preprocessor}{#ifdef M\_I86}
00271 \textcolor{comment}{/* Microsoft C in 16-bit mode */}
00272 
00273 \textcolor{preprocessor}{#  define MY\_ZCALLOC}
00274 
00275 \textcolor{preprocessor}{#if (!defined(\_MSC\_VER) || (\_MSC\_VER <= 600))}
00276 \textcolor{preprocessor}{#  define \_halloc  halloc}
00277 \textcolor{preprocessor}{#  define \_hfree   hfree}
00278 \textcolor{preprocessor}{#endif}
00279 
00280 voidpf ZLIB\_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)
00281 \{
00282     (void)opaque;
00283     \textcolor{keywordflow}{return} \_halloc((\textcolor{keywordtype}{long})items, size);
00284 \}
00285 
00286 \textcolor{keywordtype}{void} ZLIB\_INTERNAL zcfree (voidpf opaque, voidpf ptr)
00287 \{
00288     (void)opaque;
00289     \_hfree(ptr);
00290 \}
00291 
00292 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* M\_I86 */}\textcolor{preprocessor}{}
00293 
00294 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* SYS16BIT */}\textcolor{preprocessor}{}
00295 
00296 
00297 \textcolor{preprocessor}{#ifndef MY\_ZCALLOC }\textcolor{comment}{/* Any system without a special alloc function */}\textcolor{preprocessor}{}
00298 
00299 \textcolor{preprocessor}{#ifndef STDC}
00300 \textcolor{keyword}{extern} voidp  malloc OF((uInt size));
00301 \textcolor{keyword}{extern} voidp  calloc OF((uInt items, uInt size));
00302 \textcolor{keyword}{extern} \textcolor{keywordtype}{void}   free   OF((voidpf ptr));
00303 \textcolor{preprocessor}{#endif}
00304 
00305 voidpf ZLIB\_INTERNAL zcalloc (opaque, items, size)
00306     voidpf opaque;
00307     \textcolor{keywordtype}{unsigned} items;
00308     \textcolor{keywordtype}{unsigned} size;
00309 \{
00310     (void)opaque;
00311     \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(uInt) > 2 ? (voidpf)malloc(items * size) :
00312                               (voidpf)calloc(items, size);
00313 \}
00314 
00315 \textcolor{keywordtype}{void} ZLIB\_INTERNAL zcfree (opaque, ptr)
00316     voidpf opaque;
00317     voidpf ptr;
00318 \{
00319     (void)opaque;
00320     free(ptr);
00321 \}
00322 
00323 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* MY\_ZCALLOC */}\textcolor{preprocessor}{}
00324 
00325 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !Z\_SOLO */}\textcolor{preprocessor}{}
\end{DoxyCode}
