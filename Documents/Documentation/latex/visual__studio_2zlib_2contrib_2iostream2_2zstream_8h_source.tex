\hypertarget{visual__studio_2zlib_2contrib_2iostream2_2zstream_8h_source}{}\section{visual\+\_\+studio/zlib/contrib/iostream2/zstream.h}
\label{visual__studio_2zlib_2contrib_2iostream2_2zstream_8h_source}\index{zstream.\+h@{zstream.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ *}
00003 \textcolor{comment}{ * Copyright (c) 1997}
00004 \textcolor{comment}{ * Christian Michelsen Research AS}
00005 \textcolor{comment}{ * Advanced Computing}
00006 \textcolor{comment}{ * Fantoftvegen 38, 5036 BERGEN, Norway}
00007 \textcolor{comment}{ * http://www.cmr.no}
00008 \textcolor{comment}{ *}
00009 \textcolor{comment}{ * Permission to use, copy, modify, distribute and sell this software}
00010 \textcolor{comment}{ * and its documentation for any purpose is hereby granted without fee,}
00011 \textcolor{comment}{ * provided that the above copyright notice appear in all copies and}
00012 \textcolor{comment}{ * that both that copyright notice and this permission notice appear}
00013 \textcolor{comment}{ * in supporting documentation.  Christian Michelsen Research AS makes no}
00014 \textcolor{comment}{ * representations about the suitability of this software for any}
00015 \textcolor{comment}{ * purpose.  It is provided "as is" without express or implied warranty.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ */}
00018 
00019 \textcolor{preprocessor}{#ifndef ZSTREAM\_\_H}
00020 \textcolor{preprocessor}{#define ZSTREAM\_\_H}
00021 
00022 \textcolor{comment}{/*}
00023 \textcolor{comment}{ * zstream.h - C++ interface to the 'zlib' general purpose compression library}
00024 \textcolor{comment}{ * $Id: zstream.h 1.1 1997-06-25 12:00:56+02 tyge Exp tyge $}
00025 \textcolor{comment}{ */}
00026 
00027 \textcolor{preprocessor}{#include <strstream.h>}
00028 \textcolor{preprocessor}{#include <string.h>}
00029 \textcolor{preprocessor}{#include <stdio.h>}
00030 \textcolor{preprocessor}{#include "zlib.h"}
00031 
00032 \textcolor{preprocessor}{#if defined(\_WIN32)}
00033 \textcolor{preprocessor}{#   include <fcntl.h>}
00034 \textcolor{preprocessor}{#   include <io.h>}
00035 \textcolor{preprocessor}{#   define SET\_BINARY\_MODE(file) setmode(fileno(file), O\_BINARY)}
00036 \textcolor{preprocessor}{#else}
00037 \textcolor{preprocessor}{#   define SET\_BINARY\_MODE(file)}
00038 \textcolor{preprocessor}{#endif}
00039 
\Hypertarget{visual__studio_2zlib_2contrib_2iostream2_2zstream_8h_source_l00040}\hyperlink{classzstringlen}{00040} \textcolor{keyword}{class }\hyperlink{classzstringlen}{zstringlen} \{
00041 \textcolor{keyword}{public}:
00042     \hyperlink{classzstringlen}{zstringlen}(\textcolor{keyword}{class} \hyperlink{classizstream}{izstream}&);
00043     \hyperlink{classzstringlen}{zstringlen}(\textcolor{keyword}{class} \hyperlink{classozstream}{ozstream}&, \textcolor{keyword}{const} \textcolor{keywordtype}{char}*);
00044     \textcolor{keywordtype}{size\_t} value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} val.word; \}
00045 \textcolor{keyword}{private}:
00046     \textcolor{keyword}{struct }Val \{ \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} byte; \textcolor{keywordtype}{size\_t} word; \} val;
00047 \};
00048 
00049 \textcolor{comment}{//  ----------------------------- izstream -----------------------------}
00050 
\Hypertarget{visual__studio_2zlib_2contrib_2iostream2_2zstream_8h_source_l00051}\hyperlink{classizstream}{00051} \textcolor{keyword}{class }\hyperlink{classizstream}{izstream}
00052 \{
00053     \textcolor{keyword}{public}:
00054         \hyperlink{classizstream}{izstream}() : m\_fp(0) \{\}
00055         \hyperlink{classizstream}{izstream}(FILE* fp) : m\_fp(0) \{ open(fp); \}
00056         \hyperlink{classizstream}{izstream}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* name) : m\_fp(0) \{ open(name); \}
00057         ~\hyperlink{classizstream}{izstream}() \{ close(); \}
00058 
00059         \textcolor{comment}{/* Opens a gzip (.gz) file for reading.}
00060 \textcolor{comment}{         * open() can be used to read a file which is not in gzip format;}
00061 \textcolor{comment}{         * in this case read() will directly read from the file without}
00062 \textcolor{comment}{         * decompression. errno can be checked to distinguish two error}
00063 \textcolor{comment}{         * cases (if errno is zero, the zlib error is Z\_MEM\_ERROR).}
00064 \textcolor{comment}{         */}
00065         \textcolor{keywordtype}{void} open(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* name) \{
00066             \textcolor{keywordflow}{if} (m\_fp) close();
00067             m\_fp = ::gzopen(name, \textcolor{stringliteral}{"rb"});
00068         \}
00069 
00070         \textcolor{keywordtype}{void} open(FILE* fp) \{
00071             SET\_BINARY\_MODE(fp);
00072             \textcolor{keywordflow}{if} (m\_fp) close();
00073             m\_fp = ::gzdopen(fileno(fp), \textcolor{stringliteral}{"rb"});
00074         \}
00075 
00076         \textcolor{comment}{/* Flushes all pending input if necessary, closes the compressed file}
00077 \textcolor{comment}{         * and deallocates all the (de)compression state. The return value is}
00078 \textcolor{comment}{         * the zlib error number (see function error() below).}
00079 \textcolor{comment}{         */}
00080         \textcolor{keywordtype}{int} close() \{
00081             \textcolor{keywordtype}{int} r = ::gzclose(m\_fp);
00082             m\_fp = 0; \textcolor{keywordflow}{return} r;
00083         \}
00084 
00085         \textcolor{comment}{/* Binary read the given number of bytes from the compressed file.}
00086 \textcolor{comment}{         */}
00087         \textcolor{keywordtype}{int} read(\textcolor{keywordtype}{void}* buf, \textcolor{keywordtype}{size\_t} len) \{
00088             return ::gzread(m\_fp, buf, len);
00089         \}
00090 
00091         \textcolor{comment}{/* Returns the error message for the last error which occurred on the}
00092 \textcolor{comment}{         * given compressed file. errnum is set to zlib error number. If an}
00093 \textcolor{comment}{         * error occurred in the file system and not in the compression library,}
00094 \textcolor{comment}{         * errnum is set to Z\_ERRNO and the application may consult errno}
00095 \textcolor{comment}{         * to get the exact error code.}
00096 \textcolor{comment}{         */}
00097         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* error(\textcolor{keywordtype}{int}* errnum) \{
00098             return ::gzerror(m\_fp, errnum);
00099         \}
00100 
00101         \hyperlink{structgz_file__s}{gzFile} fp() \{ \textcolor{keywordflow}{return} m\_fp; \}
00102 
00103     \textcolor{keyword}{private}:
00104         \hyperlink{structgz_file__s}{gzFile} m\_fp;
00105 \};
00106 
00107 \textcolor{comment}{/*}
00108 \textcolor{comment}{ * Binary read the given (array of) object(s) from the compressed file.}
00109 \textcolor{comment}{ * If the input file was not in gzip format, read() copies the objects number}
00110 \textcolor{comment}{ * of bytes into the buffer.}
00111 \textcolor{comment}{ * returns the number of uncompressed bytes actually read}
00112 \textcolor{comment}{ * (0 for end of file, -1 for error).}
00113 \textcolor{comment}{ */}
00114 \textcolor{keyword}{template} <\textcolor{keyword}{class} T, \textcolor{keyword}{class} Items>
00115 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} read(\hyperlink{classizstream}{izstream}& zs, \hyperlink{group___sparse_core___module}{T}* x, Items items) \{
00116     return ::gzread(zs.fp(), x, items*\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module}{T}));
00117 \}
00118 
00119 \textcolor{comment}{/*}
00120 \textcolor{comment}{ * Binary input with the '>' operator.}
00121 \textcolor{comment}{ */}
00122 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>
00123 \textcolor{keyword}{inline} \hyperlink{classizstream}{izstream}& operator>(\hyperlink{classizstream}{izstream}& zs, \hyperlink{group___sparse_core___module}{T}& x) \{
00124     ::gzread(zs.fp(), &x, \textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module}{T}));
00125     \textcolor{keywordflow}{return} zs;
00126 \}
00127 
00128 
00129 \textcolor{keyword}{inline} zstringlen::zstringlen(\hyperlink{classizstream}{izstream}& zs) \{
00130     zs > val.byte;
00131     \textcolor{keywordflow}{if} (val.byte == 255) zs > val.word;
00132     \textcolor{keywordflow}{else} val.word = val.byte;
00133 \}
00134 
00135 \textcolor{comment}{/*}
00136 \textcolor{comment}{ * Read length of string + the string with the '>' operator.}
00137 \textcolor{comment}{ */}
00138 \textcolor{keyword}{inline} \hyperlink{classizstream}{izstream}& operator>(\hyperlink{classizstream}{izstream}& zs, \textcolor{keywordtype}{char}* x) \{
00139     \hyperlink{classzstringlen}{zstringlen} len(zs);
00140     ::gzread(zs.fp(), x, len.value());
00141     x[len.value()] = \textcolor{charliteral}{'\(\backslash\)0'};
00142     \textcolor{keywordflow}{return} zs;
00143 \}
00144 
00145 \textcolor{keyword}{inline} \textcolor{keywordtype}{char}* read\_string(\hyperlink{classizstream}{izstream}& zs) \{
00146     \hyperlink{classzstringlen}{zstringlen} len(zs);
00147     \textcolor{keywordtype}{char}* x = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[len.value()+1];
00148     ::gzread(zs.fp(), x, len.value());
00149     x[len.value()] = \textcolor{charliteral}{'\(\backslash\)0'};
00150     \textcolor{keywordflow}{return} x;
00151 \}
00152 
00153 \textcolor{comment}{// ----------------------------- ozstream -----------------------------}
00154 
\Hypertarget{visual__studio_2zlib_2contrib_2iostream2_2zstream_8h_source_l00155}\hyperlink{classozstream}{00155} \textcolor{keyword}{class }\hyperlink{classozstream}{ozstream}
00156 \{
00157     \textcolor{keyword}{public}:
00158         \hyperlink{classozstream}{ozstream}() : m\_fp(0), m\_os(0) \{
00159         \}
00160         \hyperlink{classozstream}{ozstream}(FILE* fp, \textcolor{keywordtype}{int} level = Z\_DEFAULT\_COMPRESSION)
00161             : m\_fp(0), m\_os(0) \{
00162             open(fp, level);
00163         \}
00164         \hyperlink{classozstream}{ozstream}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* name, \textcolor{keywordtype}{int} level = Z\_DEFAULT\_COMPRESSION)
00165             : m\_fp(0), m\_os(0) \{
00166             open(name, level);
00167         \}
00168         ~\hyperlink{classozstream}{ozstream}() \{
00169             close();
00170         \}
00171 
00172         \textcolor{comment}{/* Opens a gzip (.gz) file for writing.}
00173 \textcolor{comment}{         * The compression level parameter should be in 0..9}
00174 \textcolor{comment}{         * errno can be checked to distinguish two error cases}
00175 \textcolor{comment}{         * (if errno is zero, the zlib error is Z\_MEM\_ERROR).}
00176 \textcolor{comment}{         */}
00177         \textcolor{keywordtype}{void} open(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* name, \textcolor{keywordtype}{int} level = Z\_DEFAULT\_COMPRESSION) \{
00178             \textcolor{keywordtype}{char} mode[4] = \textcolor{stringliteral}{"wb\(\backslash\)0"};
00179             \textcolor{keywordflow}{if} (level != Z\_DEFAULT\_COMPRESSION) mode[2] = \textcolor{charliteral}{'0'}+level;
00180             \textcolor{keywordflow}{if} (m\_fp) close();
00181             m\_fp = ::gzopen(name, mode);
00182         \}
00183 
00184         \textcolor{comment}{/* open from a FILE pointer.}
00185 \textcolor{comment}{         */}
00186         \textcolor{keywordtype}{void} open(FILE* fp, \textcolor{keywordtype}{int} level = Z\_DEFAULT\_COMPRESSION) \{
00187             SET\_BINARY\_MODE(fp);
00188             \textcolor{keywordtype}{char} mode[4] = \textcolor{stringliteral}{"wb\(\backslash\)0"};
00189             \textcolor{keywordflow}{if} (level != Z\_DEFAULT\_COMPRESSION) mode[2] = \textcolor{charliteral}{'0'}+level;
00190             \textcolor{keywordflow}{if} (m\_fp) close();
00191             m\_fp = ::gzdopen(fileno(fp), mode);
00192         \}
00193 
00194         \textcolor{comment}{/* Flushes all pending output if necessary, closes the compressed file}
00195 \textcolor{comment}{         * and deallocates all the (de)compression state. The return value is}
00196 \textcolor{comment}{         * the zlib error number (see function error() below).}
00197 \textcolor{comment}{         */}
00198         \textcolor{keywordtype}{int} close() \{
00199             \textcolor{keywordflow}{if} (m\_os) \{
00200                 ::gzwrite(m\_fp, m\_os->str(), m\_os->pcount());
00201                 \textcolor{keyword}{delete}[] m\_os->str(); \textcolor{keyword}{delete} m\_os; m\_os = 0;
00202             \}
00203             \textcolor{keywordtype}{int} r = ::gzclose(m\_fp); m\_fp = 0; \textcolor{keywordflow}{return} r;
00204         \}
00205 
00206         \textcolor{comment}{/* Binary write the given number of bytes into the compressed file.}
00207 \textcolor{comment}{         */}
00208         \textcolor{keywordtype}{int} write(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* buf, \textcolor{keywordtype}{size\_t} len) \{
00209             return ::gzwrite(m\_fp, (voidp) buf, len);
00210         \}
00211 
00212         \textcolor{comment}{/* Flushes all pending output into the compressed file. The parameter}
00213 \textcolor{comment}{         * \_flush is as in the deflate() function. The return value is the zlib}
00214 \textcolor{comment}{         * error number (see function gzerror below). flush() returns Z\_OK if}
00215 \textcolor{comment}{         * the flush\_ parameter is Z\_FINISH and all output could be flushed.}
00216 \textcolor{comment}{         * flush() should be called only when strictly necessary because it can}
00217 \textcolor{comment}{         * degrade compression.}
00218 \textcolor{comment}{         */}
00219         \textcolor{keywordtype}{int} flush(\textcolor{keywordtype}{int} \_flush) \{
00220             os\_flush();
00221             return ::gzflush(m\_fp, \_flush);
00222         \}
00223 
00224         \textcolor{comment}{/* Returns the error message for the last error which occurred on the}
00225 \textcolor{comment}{         * given compressed file. errnum is set to zlib error number. If an}
00226 \textcolor{comment}{         * error occurred in the file system and not in the compression library,}
00227 \textcolor{comment}{         * errnum is set to Z\_ERRNO and the application may consult errno}
00228 \textcolor{comment}{         * to get the exact error code.}
00229 \textcolor{comment}{         */}
00230         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* error(\textcolor{keywordtype}{int}* errnum) \{
00231             return ::gzerror(m\_fp, errnum);
00232         \}
00233 
00234         \hyperlink{structgz_file__s}{gzFile} fp() \{ \textcolor{keywordflow}{return} m\_fp; \}
00235 
00236         ostream& os() \{
00237             \textcolor{keywordflow}{if} (m\_os == 0) m\_os = \textcolor{keyword}{new} ostrstream;
00238             \textcolor{keywordflow}{return} *m\_os;
00239         \}
00240 
00241         \textcolor{keywordtype}{void} os\_flush() \{
00242             \textcolor{keywordflow}{if} (m\_os && m\_os->pcount()>0) \{
00243                 ostrstream* oss = \textcolor{keyword}{new} ostrstream;
00244                 oss->fill(m\_os->fill());
00245                 oss->flags(m\_os->flags());
00246                 oss->precision(m\_os->precision());
00247                 oss->width(m\_os->width());
00248                 ::gzwrite(m\_fp, m\_os->str(), m\_os->pcount());
00249                 \textcolor{keyword}{delete}[] m\_os->str(); \textcolor{keyword}{delete} m\_os; m\_os = oss;
00250             \}
00251         \}
00252 
00253     \textcolor{keyword}{private}:
00254         \hyperlink{structgz_file__s}{gzFile} m\_fp;
00255         ostrstream* m\_os;
00256 \};
00257 
00258 \textcolor{comment}{/*}
00259 \textcolor{comment}{ * Binary write the given (array of) object(s) into the compressed file.}
00260 \textcolor{comment}{ * returns the number of uncompressed bytes actually written}
00261 \textcolor{comment}{ * (0 in case of error).}
00262 \textcolor{comment}{ */}
00263 \textcolor{keyword}{template} <\textcolor{keyword}{class} T, \textcolor{keyword}{class} Items>
00264 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} write(\hyperlink{classozstream}{ozstream}& zs, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}* x, Items items) \{
00265     return ::gzwrite(zs.fp(), (voidp) x, items*\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module}{T}));
00266 \}
00267 
00268 \textcolor{comment}{/*}
00269 \textcolor{comment}{ * Binary output with the '<' operator.}
00270 \textcolor{comment}{ */}
00271 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>
00272 \textcolor{keyword}{inline} \hyperlink{classozstream}{ozstream}& operator<(\hyperlink{classozstream}{ozstream}& zs, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& x) \{
00273     ::gzwrite(zs.fp(), (voidp) &x, \textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module}{T}));
00274     \textcolor{keywordflow}{return} zs;
00275 \}
00276 
00277 \textcolor{keyword}{inline} zstringlen::zstringlen(\hyperlink{classozstream}{ozstream}& zs, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* x) \{
00278     val.byte = 255;  val.word = ::strlen(x);
00279     \textcolor{keywordflow}{if} (val.word < 255) zs < (val.byte = val.word);
00280     \textcolor{keywordflow}{else} zs < val;
00281 \}
00282 
00283 \textcolor{comment}{/*}
00284 \textcolor{comment}{ * Write length of string + the string with the '<' operator.}
00285 \textcolor{comment}{ */}
00286 \textcolor{keyword}{inline} \hyperlink{classozstream}{ozstream}& operator<(\hyperlink{classozstream}{ozstream}& zs, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* x) \{
00287     \hyperlink{classzstringlen}{zstringlen} len(zs, x);
00288     ::gzwrite(zs.fp(), (voidp) x, len.value());
00289     \textcolor{keywordflow}{return} zs;
00290 \}
00291 
00292 \textcolor{preprocessor}{#ifdef \_MSC\_VER}
00293 \textcolor{keyword}{inline} \hyperlink{classozstream}{ozstream}& operator<(\hyperlink{classozstream}{ozstream}& zs, \textcolor{keywordtype}{char}* \textcolor{keyword}{const}& x) \{
00294     \textcolor{keywordflow}{return} zs < (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*) x;
00295 \}
00296 \textcolor{preprocessor}{#endif}
00297 
00298 \textcolor{comment}{/*}
00299 \textcolor{comment}{ * Ascii write with the << operator;}
00300 \textcolor{comment}{ */}
00301 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>
00302 \textcolor{keyword}{inline} ostream& operator<<(\hyperlink{classozstream}{ozstream}& zs, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& x) \{
00303     zs.os\_flush();
00304     \textcolor{keywordflow}{return} zs.os() << x;
00305 \}
00306 
00307 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
