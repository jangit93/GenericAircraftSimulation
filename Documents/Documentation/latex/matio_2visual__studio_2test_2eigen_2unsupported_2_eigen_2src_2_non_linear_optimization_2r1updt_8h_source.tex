\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_non_linear_optimization_2r1updt_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+Non\+Linear\+Optimization/r1updt.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_non_linear_optimization_2r1updt_8h_source}\index{r1updt.\+h@{r1updt.\+h}}

\begin{DoxyCode}
00001 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00002 
00003 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00004 
00005 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00006 \textcolor{keywordtype}{void} r1updt(
00007         \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, Dynamic >} &s,
00008         \textcolor{keyword}{const} Matrix< Scalar, Dynamic, 1> &u,
00009         std::vector<JacobiRotation<Scalar> > &v\_givens,
00010         std::vector<JacobiRotation<Scalar> > &w\_givens,
00011         Matrix< Scalar, Dynamic, 1> &v,
00012         Matrix< Scalar, Dynamic, 1> &w,
00013         \textcolor{keywordtype}{bool} *sing)
00014 \{
00015     \textcolor{keyword}{typedef} DenseIndex \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00016     \textcolor{keyword}{const} JacobiRotation<Scalar> IdentityRotation = JacobiRotation<Scalar>(1,0);
00017 
00018     \textcolor{comment}{/* Local variables */}
00019     \textcolor{keyword}{const} Index m = s.rows();
00020     \textcolor{keyword}{const} Index n = s.cols();
00021     Index i, j=1;
00022     Scalar temp;
00023     JacobiRotation<Scalar> givens;
00024 
00025     \textcolor{comment}{// r1updt had a broader usecase, but we dont use it here. And, more}
00026     \textcolor{comment}{// importantly, we can not test it.}
00027     eigen\_assert(m==n);
00028     eigen\_assert(u.size()==m);
00029     eigen\_assert(v.size()==n);
00030     eigen\_assert(w.size()==n);
00031 
00032     \textcolor{comment}{/* move the nontrivial part of the last column of s into w. */}
00033     w[n-1] = s(n-1,n-1);
00034 
00035     \textcolor{comment}{/* rotate the vector v into a multiple of the n-th unit vector */}
00036     \textcolor{comment}{/* in such a way that a spike is introduced into w. */}
00037     \textcolor{keywordflow}{for} (j=n-2; j>=0; --j) \{
00038         w[j] = 0.;
00039         \textcolor{keywordflow}{if} (v[j] != 0.) \{
00040             \textcolor{comment}{/* determine a givens rotation which eliminates the */}
00041             \textcolor{comment}{/* j-th element of v. */}
00042             givens.makeGivens(-v[n-1], v[j]);
00043 
00044             \textcolor{comment}{/* apply the transformation to v and store the information */}
00045             \textcolor{comment}{/* necessary to recover the givens rotation. */}
00046             v[n-1] = givens.s() * v[j] + givens.c() * v[n-1];
00047             v\_givens[j] = givens;
00048 
00049             \textcolor{comment}{/* apply the transformation to s and extend the spike in w. */}
00050             \textcolor{keywordflow}{for} (i = j; i < m; ++i) \{
00051                 temp = givens.c() * s(j,i) - givens.s() * w[i];
00052                 w[i] = givens.s() * s(j,i) + givens.c() * w[i];
00053                 s(j,i) = temp;
00054             \}
00055         \} \textcolor{keywordflow}{else}
00056             v\_givens[j] = IdentityRotation;
00057     \}
00058 
00059     \textcolor{comment}{/* add the spike from the rank 1 update to w. */}
00060     w += v[n-1] * u;
00061 
00062     \textcolor{comment}{/* eliminate the spike. */}
00063     *sing = \textcolor{keyword}{false};
00064     \textcolor{keywordflow}{for} (j = 0; j < n-1; ++j) \{
00065         \textcolor{keywordflow}{if} (w[j] != 0.) \{
00066             \textcolor{comment}{/* determine a givens rotation which eliminates the */}
00067             \textcolor{comment}{/* j-th element of the spike. */}
00068             givens.makeGivens(-s(j,j), w[j]);
00069 
00070             \textcolor{comment}{/* apply the transformation to s and reduce the spike in w. */}
00071             \textcolor{keywordflow}{for} (i = j; i < m; ++i) \{
00072                 temp = givens.c() * s(j,i) + givens.s() * w[i];
00073                 w[i] = -givens.s() * s(j,i) + givens.c() * w[i];
00074                 s(j,i) = temp;
00075             \}
00076 
00077             \textcolor{comment}{/* store the information necessary to recover the */}
00078             \textcolor{comment}{/* givens rotation. */}
00079             w\_givens[j] = givens;
00080         \} \textcolor{keywordflow}{else}
00081             v\_givens[j] = IdentityRotation;
00082 
00083         \textcolor{comment}{/* test for zero diagonal elements in the output s. */}
00084         \textcolor{keywordflow}{if} (s(j,j) == 0.) \{
00085             *sing = \textcolor{keyword}{true};
00086         \}
00087     \}
00088     \textcolor{comment}{/* move w back into the last column of the output s. */}
00089     s(n-1,n-1) = w[n-1];
00090 
00091     \textcolor{keywordflow}{if} (s(j,j) == 0.) \{
00092         *sing = \textcolor{keyword}{true};
00093     \}
00094     \textcolor{keywordflow}{return};
00095 \}
00096 
00097 \} \textcolor{comment}{// end namespace internal}
00098 
00099 \} \textcolor{comment}{// end namespace Eigen}
\end{DoxyCode}
