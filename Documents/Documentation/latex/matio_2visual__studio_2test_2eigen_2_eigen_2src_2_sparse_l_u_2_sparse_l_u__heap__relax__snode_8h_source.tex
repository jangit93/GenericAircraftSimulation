\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u__heap__relax__snode_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+L\+U/\+Sparse\+L\+U\+\_\+heap\+\_\+relax\+\_\+snode.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u__heap__relax__snode_8h_source}\index{Sparse\+L\+U\+\_\+heap\+\_\+relax\+\_\+snode.\+h@{Sparse\+L\+U\+\_\+heap\+\_\+relax\+\_\+snode.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{comment}{/* This file is a modified version of heap\_relax\_snode.c file in SuperLU}
00011 \textcolor{comment}{ * -- SuperLU routine (version 3.0) --}
00012 \textcolor{comment}{ * Univ. of California Berkeley, Xerox Palo Alto Research Center,}
00013 \textcolor{comment}{ * and Lawrence Berkeley National Lab.}
00014 \textcolor{comment}{ * October 15, 2003}
00015 \textcolor{comment}{ *}
00016 \textcolor{comment}{ * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.}
00017 \textcolor{comment}{ *}
00018 \textcolor{comment}{ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY}
00019 \textcolor{comment}{ * EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.}
00020 \textcolor{comment}{ *}
00021 \textcolor{comment}{ * Permission is hereby granted to use or copy this program for any}
00022 \textcolor{comment}{ * purpose, provided the above notices are retained on all copies.}
00023 \textcolor{comment}{ * Permission to modify the code and to distribute modified code is}
00024 \textcolor{comment}{ * granted, provided the above notices are retained, and a notice that}
00025 \textcolor{comment}{ * the code was modified is included with the above copyright notice.}
00026 \textcolor{comment}{ */}
00027 
00028 \textcolor{preprocessor}{#ifndef SPARSELU\_HEAP\_RELAX\_SNODE\_H}
00029 \textcolor{preprocessor}{#define SPARSELU\_HEAP\_RELAX\_SNODE\_H}
00030 
00031 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00032 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00033 
00045 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} StorageIndex>
00046 \textcolor{keywordtype}{void} \hyperlink{group___sparse_l_u___module_a88952ce33c968374b149e31d0539178d}{SparseLUImpl<Scalar,StorageIndex>::heap\_relax\_snode}
       (\textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n, IndexVector& et, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} relax\_columns, IndexVector& descendants, IndexVector
      & relax\_end)
00047 \{
00048   
00049   \textcolor{comment}{// The etree may not be postordered, but its heap ordered  }
00050   IndexVector post;
00051   \hyperlink{namespace_eigen_1_1internal_ab414b5990bd6c865958a9231ff418d20}{internal::treePostorder}(StorageIndex(n), et, post); \textcolor{comment}{// Post order etree}
00052   IndexVector inv\_post(n+1); 
00053   \textcolor{keywordflow}{for} (StorageIndex i = 0; i < n+1; ++i) inv\_post(post(i)) = i; \textcolor{comment}{// inv\_post = post.inverse()???}
00054   
00055   \textcolor{comment}{// Renumber etree in postorder }
00056   IndexVector iwork(n);
00057   IndexVector et\_save(n+1);
00058   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < n; ++i)
00059   \{
00060     iwork(post(i)) = post(et(i));
00061   \}
00062   et\_save = et; \textcolor{comment}{// Save the original etree}
00063   et = iwork; 
00064   
00065   \textcolor{comment}{// compute the number of descendants of each node in the etree}
00066   relax\_end.setConstant(emptyIdxLU);
00067   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j, parent; 
00068   descendants.setZero();
00069   \textcolor{keywordflow}{for} (j = 0; j < n; j++) 
00070   \{
00071     parent = et(j);
00072     \textcolor{keywordflow}{if} (parent != n) \textcolor{comment}{// not the dummy root}
00073       descendants(parent) += descendants(j) + 1;
00074   \}
00075   \textcolor{comment}{// Identify the relaxed supernodes by postorder traversal of the etree}
00076   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} snode\_start; \textcolor{comment}{// beginning of a snode }
00077   StorageIndex k;
00078   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nsuper\_et\_post = 0; \textcolor{comment}{// Number of relaxed snodes in postordered etree }
00079   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nsuper\_et = 0; \textcolor{comment}{// Number of relaxed snodes in the original etree }
00080   StorageIndex l; 
00081   \textcolor{keywordflow}{for} (j = 0; j < n; )
00082   \{
00083     parent = et(j);
00084     snode\_start = j; 
00085     \textcolor{keywordflow}{while} ( parent != n && descendants(parent) < relax\_columns ) 
00086     \{
00087       j = parent; 
00088       parent = et(j);
00089     \}
00090     \textcolor{comment}{// Found a supernode in postordered etree, j is the last column }
00091     ++nsuper\_et\_post;
00092     k = StorageIndex(n);
00093     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = snode\_start; i <= j; ++i)
00094       k = (std::min)(k, inv\_post(i));
00095     l = inv\_post(j);
00096     \textcolor{keywordflow}{if} ( (l - k) == (j - snode\_start) )  \textcolor{comment}{// Same number of columns in the snode}
00097     \{
00098       \textcolor{comment}{// This is also a supernode in the original etree}
00099       relax\_end(k) = l; \textcolor{comment}{// Record last column }
00100       ++nsuper\_et; 
00101     \}
00102     \textcolor{keywordflow}{else} 
00103     \{
00104       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = snode\_start; i <= j; ++i) 
00105       \{
00106         l = inv\_post(i);
00107         \textcolor{keywordflow}{if} (descendants(i) == 0) 
00108         \{
00109           relax\_end(l) = l;
00110           ++nsuper\_et;
00111         \}
00112       \}
00113     \}
00114     j++;
00115     \textcolor{comment}{// Search for a new leaf}
00116     \textcolor{keywordflow}{while} (descendants(j) != 0 && j < n) j++;
00117   \} \textcolor{comment}{// End postorder traversal of the etree}
00118   
00119   \textcolor{comment}{// Recover the original etree}
00120   et = et\_save; 
00121 \}
00122 
00123 \} \textcolor{comment}{// end namespace internal}
00124 
00125 \} \textcolor{comment}{// end namespace Eigen}
00126 \textcolor{preprocessor}{#endif // SPARSELU\_HEAP\_RELAX\_SNODE\_H}
\end{DoxyCode}
