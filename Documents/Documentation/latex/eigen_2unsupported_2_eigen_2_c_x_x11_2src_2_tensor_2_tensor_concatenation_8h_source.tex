\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_concatenation_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Concatenation.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_concatenation_8h_source}\index{Tensor\+Concatenation.\+h@{Tensor\+Concatenation.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_CONCATENATION\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_CONCATENATION\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Axis, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_concatenation_8h_source_l00024}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_concatenation_op_3_01_axis_00_01_lhs_xpr_type_00_01_rhs_xpr_type_01_4_01_4}{00024} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_concatenation_op}{TensorConcatenationOp}<Axis, LhsXprType, RhsXprType> >
00025 \{
00026   \textcolor{comment}{// Type promotion to handle the case where the types of the lhs and the rhs are different.}
00027   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1promote__storage__type}{promote\_storage\_type}<\textcolor{keyword}{typename} LhsXprType::Scalar,
00028                                         \textcolor{keyword}{typename} RhsXprType::Scalar>::ret Scalar;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1promote__storage__type}{promote\_storage\_type<typename traits<LhsXprType>::StorageKind}
      ,
00030                                         \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<RhsXprType>::StorageKind}
      >::ret StorageKind;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1promote__index__type}{promote\_index\_type<typename traits<LhsXprType>::Index}
      ,
00032                                       \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<RhsXprType>::Index}>::type 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00033   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsXprType::Nested LhsNested;
00034   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsXprType::Nested RhsNested;
00035   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<LhsNested>::type} 
      \hyperlink{group___sparse_core___module}{\_LhsNested};
00036   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<RhsNested>::type} 
      \hyperlink{group___sparse_core___module}{\_RhsNested};
00037   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<LhsXprType>::NumDimensions};
00038   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<LhsXprType>::Layout};
00039   \textcolor{keyword}{enum} \{ Flags = 0 \};
00040 \};
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Axis, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_concatenation_8h_source_l00043}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_concatenation_op_3_01_axis_00_01_lhs_xpr_type_00_014584aefce4bd43d98989ef5eac495878}{00043} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_concatenation_op}{TensorConcatenationOp}<Axis, LhsXprType, RhsXprType>, 
      \hyperlink{namespace_eigen}{Eigen}::\hyperlink{struct_eigen_1_1_dense}{Dense}>
00044 \{
00045   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_concatenation_op}{TensorConcatenationOp<Axis, LhsXprType, RhsXprType>}
      & \hyperlink{class_eigen_1_1_tensor_concatenation_op}{type};
00046 \};
00047 
00048 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Axis, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_concatenation_8h_source_l00049}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_concatenation_op_3_01_axis_00_01_lhs_xpr_type_00_387f0c29001361c8d2e2fed7054a319e}{00049} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_concatenation_op}{TensorConcatenationOp}<Axis, LhsXprType, RhsXprType>, 1, typename 
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_concatenation_op}{TensorConcatenationOp}<Axis, LhsXprType, RhsXprType> >::
      \hyperlink{class_eigen_1_1_tensor_concatenation_op}{type}>
00050 \{
00051   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_concatenation_op}{TensorConcatenationOp<Axis, LhsXprType, RhsXprType>}
       \hyperlink{class_eigen_1_1_tensor_concatenation_op}{type};
00052 \};
00053 
00054 \}  \textcolor{comment}{// end namespace internal}
00055 
00056 
00057 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Axis, \textcolor{keyword}{typename} LhsXprType, \textcolor{keyword}{typename} RhsXprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_concatenation_8h_source_l00058}\hyperlink{class_eigen_1_1_tensor_concatenation_op}{00058} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_concatenation_op}{TensorConcatenationOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorConcatenationOp<Axis, 
      LhsXprType, RhsXprType>, WriteAccessors>
00059 \{
00060   \textcolor{keyword}{public}:
00061     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<TensorConcatenationOp>::Scalar}
       Scalar;
00062     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<TensorConcatenationOp>::StorageKind}
       StorageKind;
00063     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<TensorConcatenationOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00064     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested<TensorConcatenationOp>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Nested};
00065     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1promote__storage__type}{internal::promote\_storage\_type}<\textcolor{keyword}{typename} 
      LhsXprType::CoeffReturnType,
00066                                                     \textcolor{keyword}{typename} RhsXprType::CoeffReturnType>::ret 
      CoeffReturnType;
00067     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00068 
00069     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_concatenation_op}{TensorConcatenationOp}(\textcolor{keyword}{const} LhsXprType& lhs,
       \textcolor{keyword}{const} RhsXprType& rhs, Axis axis)
00070         : m\_lhs\_xpr(lhs), m\_rhs\_xpr(rhs), m\_axis(axis) \{\}
00071 
00072     EIGEN\_DEVICE\_FUNC
00073     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename LhsXprType::Nested>::type}
      &
00074     lhsExpression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhs\_xpr; \}
00075 
00076     EIGEN\_DEVICE\_FUNC
00077     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename RhsXprType::Nested>::type}
      &
00078     rhsExpression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rhs\_xpr; \}
00079 
00080     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} Axis& axis()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_axis; \}
00081 
00082     EIGEN\_DEVICE\_FUNC
00083     EIGEN\_STRONG\_INLINE TensorConcatenationOp& operator = (\textcolor{keyword}{const} TensorConcatenationOp& other)
00084     \{
00085       \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp<TensorConcatenationOp, const TensorConcatenationOp>}
       Assign;
00086       Assign assign(*\textcolor{keyword}{this}, other);
00087       \hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{internal::TensorExecutor<const Assign, DefaultDevice>::run}
      (assign, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}());
00088       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00089     \}
00090 
00091     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00092     EIGEN\_DEVICE\_FUNC
00093     EIGEN\_STRONG\_INLINE TensorConcatenationOp& operator = (\textcolor{keyword}{const} OtherDerived& other)
00094     \{
00095       \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp<TensorConcatenationOp, const OtherDerived>}
       Assign;
00096       Assign assign(*\textcolor{keyword}{this}, other);
00097       \hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{internal::TensorExecutor<const Assign, DefaultDevice>::run}
      (assign, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}());
00098       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00099     \}
00100 
00101   \textcolor{keyword}{protected}:
00102     \textcolor{keyword}{typename} LhsXprType::Nested m\_lhs\_xpr;
00103     \textcolor{keyword}{typename} RhsXprType::Nested m\_rhs\_xpr;
00104     \textcolor{keyword}{const} Axis m\_axis;
00105 \};
00106 
00107 
00108 \textcolor{comment}{// Eval as rvalue}
00109 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Axis, \textcolor{keyword}{typename} LeftArgType, \textcolor{keyword}{typename} RightArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_concatenation_8h_source_l00110}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_concatenation_op_3_01_axis_00_01_left_arg_e37e1b61d31098a96aab7c22793b325c}{00110} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_concatenation_op}{TensorConcatenationOp}<Axis, LeftArgType, 
      RightArgType>, Device>
00111 \{
00112   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_concatenation_op}{TensorConcatenationOp<Axis, LeftArgType, RightArgType>}
       \hyperlink{class_eigen_1_1_tensor_concatenation_op}{XprType};
00113   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00114   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<LeftArgType, Device>::Dimensions}
      >::value;
00115   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} RightNumDims = 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<RightArgType, Device>::Dimensions}
      >::value;
00116   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumDims>} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00117   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00118   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00119   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00120   \textcolor{keyword}{enum} \{
00121     IsAligned = \textcolor{keyword}{false},
00122     PacketAccess = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::PacketAccess}
       & \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<RightArgType, Device>::PacketAccess},
00123     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::Layout},
00124     RawAccess = \textcolor{keyword}{false}
00125   \};
00126 
00127   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00128     : m\_leftImpl(op.lhsExpression(), device), m\_rightImpl(op.rhsExpression(), device), m\_axis(op.axis())
00129   \{
00130     EIGEN\_STATIC\_ASSERT((static\_cast<int>(
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::Layout}) == 
      static\_cast<int>(\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<RightArgType, Device>::Layout}) || NumDims ==
       1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00131     EIGEN\_STATIC\_ASSERT((NumDims == RightNumDims), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00132     EIGEN\_STATIC\_ASSERT((NumDims > 0), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00133 
00134     eigen\_assert(0 <= m\_axis && m\_axis < NumDims);
00135     \textcolor{keyword}{const} Dimensions& lhs\_dims = m\_leftImpl.dimensions();
00136     \textcolor{keyword}{const} Dimensions& rhs\_dims = m\_rightImpl.dimensions();
00137     \{
00138       \textcolor{keywordtype}{int} i = 0;
00139       \textcolor{keywordflow}{for} (; i < m\_axis; ++i) \{
00140         eigen\_assert(lhs\_dims[i] > 0);
00141         eigen\_assert(lhs\_dims[i] == rhs\_dims[i]);
00142         m\_dimensions[i] = lhs\_dims[i];
00143       \}
00144       eigen\_assert(lhs\_dims[i] > 0);  \textcolor{comment}{// Now i == m\_axis.}
00145       eigen\_assert(rhs\_dims[i] > 0);
00146       m\_dimensions[i] = lhs\_dims[i] + rhs\_dims[i];
00147       \textcolor{keywordflow}{for} (++i; i < NumDims; ++i) \{
00148         eigen\_assert(lhs\_dims[i] > 0);
00149         eigen\_assert(lhs\_dims[i] == rhs\_dims[i]);
00150         m\_dimensions[i] = lhs\_dims[i];
00151       \}
00152     \}
00153 
00154     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00155       m\_leftStrides[0] = 1;
00156       m\_rightStrides[0] = 1;
00157       m\_outputStrides[0] = 1;
00158 
00159       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 1; j < NumDims; ++j) \{
00160         m\_leftStrides[j] = m\_leftStrides[j-1] * lhs\_dims[j-1];
00161         m\_rightStrides[j] = m\_rightStrides[j-1] * rhs\_dims[j-1];
00162         m\_outputStrides[j] = m\_outputStrides[j-1] * m\_dimensions[j-1];
00163       \}
00164     \} \textcolor{keywordflow}{else} \{
00165       m\_leftStrides[NumDims - 1] = 1;
00166       m\_rightStrides[NumDims - 1] = 1;
00167       m\_outputStrides[NumDims - 1] = 1;
00168 
00169       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = NumDims - 2; j >= 0; --j) \{
00170         m\_leftStrides[j] = m\_leftStrides[j+1] * lhs\_dims[j+1];
00171         m\_rightStrides[j] = m\_rightStrides[j+1] * rhs\_dims[j+1];
00172         m\_outputStrides[j] = m\_outputStrides[j+1] * m\_dimensions[j+1];
00173       \}
00174     \}
00175   \}
00176 
00177   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00178 
00179   \textcolor{comment}{// TODO(phli): Add short-circuit memcpy evaluation if underlying data are linear?}
00180   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/})
00181   \{
00182     m\_leftImpl.evalSubExprsIfNeeded(NULL);
00183     m\_rightImpl.evalSubExprsIfNeeded(NULL);
00184     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00185   \}
00186 
00187   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup()
00188   \{
00189     m\_leftImpl.cleanup();
00190     m\_rightImpl.cleanup();
00191   \}
00192 
00193   \textcolor{comment}{// TODO(phli): attempt to speed this up. The integer divisions and modulo are slow.}
00194   \textcolor{comment}{// See CL/76180724 comments for more ideas.}
00195   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00196 \textcolor{keyword}{  }\{
00197     \textcolor{comment}{// Collect dimension-wise indices (subs).}
00198     \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} subs;
00199     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00200       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00201         subs[i] = index / m\_outputStrides[i];
00202         index -= subs[i] * m\_outputStrides[i];
00203       \}
00204       subs[0] = index;
00205     \} \textcolor{keywordflow}{else} \{
00206       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00207         subs[i] = index / m\_outputStrides[i];
00208         index -= subs[i] * m\_outputStrides[i];
00209       \}
00210       subs[NumDims - 1] = index;
00211     \}
00212 
00213     \textcolor{keyword}{const} Dimensions& left\_dims = m\_leftImpl.dimensions();
00214     \textcolor{keywordflow}{if} (subs[m\_axis] < left\_dims[m\_axis]) \{
00215       Index left\_index;
00216       \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00217         left\_index = subs[0];
00218         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00219           left\_index += (subs[i] % left\_dims[i]) * m\_leftStrides[i];
00220         \}
00221       \} \textcolor{keywordflow}{else} \{
00222         left\_index = subs[NumDims - 1];
00223         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00224           left\_index += (subs[i] % left\_dims[i]) * m\_leftStrides[i];
00225         \}
00226       \}
00227       \textcolor{keywordflow}{return} m\_leftImpl.coeff(left\_index);
00228     \} \textcolor{keywordflow}{else} \{
00229       subs[m\_axis] -= left\_dims[m\_axis];
00230       \textcolor{keyword}{const} Dimensions& right\_dims = m\_rightImpl.dimensions();
00231       Index right\_index;
00232       \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00233         right\_index = subs[0];
00234         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00235           right\_index += (subs[i] % right\_dims[i]) * m\_rightStrides[i];
00236         \}
00237       \} \textcolor{keywordflow}{else} \{
00238         right\_index = subs[NumDims - 1];
00239         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00240           right\_index += (subs[i] % right\_dims[i]) * m\_rightStrides[i];
00241         \}
00242       \}
00243       \textcolor{keywordflow}{return} m\_rightImpl.coeff(right\_index);
00244     \}
00245   \}
00246 
00247   \textcolor{comment}{// TODO(phli): Add a real vectorization.}
00248   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00249   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00250 \textcolor{keyword}{  }\{
00251     \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetSize = \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size}
      ;
00252     EIGEN\_STATIC\_ASSERT((packetSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00253     eigen\_assert(index + packetSize - 1 < dimensions().TotalSize());
00254 
00255     EIGEN\_ALIGN\_MAX CoeffReturnType values[packetSize];
00256     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < packetSize; ++i) \{
00257       values[i] = coeff(index+i);
00258     \}
00259     PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00260     \textcolor{keywordflow}{return} rslt;
00261   \}
00262 
00263   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}
00264   costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00265     \textcolor{keyword}{const} \textcolor{keywordtype}{double} compute\_cost = NumDims * (2 * TensorOpCost::AddCost<Index>() +
00266                                            2 * TensorOpCost::MulCost<Index>() +
00267                                            TensorOpCost::DivCost<Index>() +
00268                                            TensorOpCost::ModCost<Index>());
00269     \textcolor{keyword}{const} \textcolor{keywordtype}{double} lhs\_size = m\_leftImpl.dimensions().TotalSize();
00270     \textcolor{keyword}{const} \textcolor{keywordtype}{double} rhs\_size = m\_rightImpl.dimensions().TotalSize();
00271     \textcolor{keywordflow}{return} (lhs\_size / (lhs\_size + rhs\_size)) *
00272                m\_leftImpl.costPerCoeff(vectorized) +
00273            (rhs\_size / (lhs\_size + rhs\_size)) *
00274                m\_rightImpl.costPerCoeff(vectorized) +
00275            \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, compute\_cost);
00276   \}
00277 
00278   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00279 
00280   \textcolor{keyword}{protected}:
00281     Dimensions m\_dimensions;
00282     \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} m\_outputStrides;
00283     \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} m\_leftStrides;
00284     \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} m\_rightStrides;
00285     \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>} m\_leftImpl;
00286     \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<RightArgType, Device>} m\_rightImpl;
00287     \textcolor{keyword}{const} Axis m\_axis;
00288 \};
00289 
00290 \textcolor{comment}{// Eval as lvalue}
00291 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Axis, \textcolor{keyword}{typename} LeftArgType, \textcolor{keyword}{typename} RightArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_concatenation_8h_source_l00292}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01_tensor_concatenation_op_3_01_axis_00_01_left_arg_type_00_7f27325ca3102a6730769e76427d2ca7}{00292}   \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<\hyperlink{class_eigen_1_1_tensor_concatenation_op}{TensorConcatenationOp}<Axis, LeftArgType, 
      RightArgType>, Device>
00293   : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const TensorConcatenationOp<Axis, LeftArgType, RightArgType>, Dev
      ice>
00294 \{
00295   \textcolor{keyword}{typedef} 
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<const TensorConcatenationOp<Axis, LeftArgType, RightArgType>}
      , Device> \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_concatenation_op_3_01_axis_00_01_left_arg_e37e1b61d31098a96aab7c22793b325c}{Base};
00296   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_concatenation_op}{TensorConcatenationOp<Axis, LeftArgType, RightArgType>}
       \hyperlink{class_eigen_1_1_tensor_concatenation_op}{XprType};
00297   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_d_sizes}{Base::Dimensions} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00298   \textcolor{keyword}{enum} \{
00299     IsAligned = \textcolor{keyword}{false},
00300     PacketAccess = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::PacketAccess}
       & \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<RightArgType, Device>::PacketAccess},
00301     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<LeftArgType, Device>::Layout},
00302     RawAccess = \textcolor{keyword}{false}
00303   \};
00304 
00305   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(XprType& op, \textcolor{keyword}{const} Device& device)
00306     : Base(op, device)
00307   \{
00308     EIGEN\_STATIC\_ASSERT((static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})), 
      YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00309   \}
00310 
00311   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00312   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00313   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00314   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00315 
00316   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType& coeffRef(Index index)
00317   \{
00318     \textcolor{comment}{// Collect dimension-wise indices (subs).}
00319     \hyperlink{class_eigen_1_1array}{array<Index, Base::NumDims>} subs;
00320     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = Base::NumDims - 1; i > 0; --i) \{
00321       subs[i] = index / this->m\_outputStrides[i];
00322       index -= subs[i] * this->m\_outputStrides[i];
00323     \}
00324     subs[0] = index;
00325 
00326     \textcolor{keyword}{const} Dimensions& left\_dims = this->m\_leftImpl.dimensions();
00327     \textcolor{keywordflow}{if} (subs[this->m\_axis] < left\_dims[this->m\_axis]) \{
00328       Index left\_index = subs[0];
00329       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < Base::NumDims; ++i) \{
00330         left\_index += (subs[i] % left\_dims[i]) * this->m\_leftStrides[i];
00331       \}
00332       \textcolor{keywordflow}{return} this->m\_leftImpl.coeffRef(left\_index);
00333     \} \textcolor{keywordflow}{else} \{
00334       subs[this->m\_axis] -= left\_dims[this->m\_axis];
00335       \textcolor{keyword}{const} Dimensions& right\_dims = this->m\_rightImpl.dimensions();
00336       Index right\_index = subs[0];
00337       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < Base::NumDims; ++i) \{
00338         right\_index += (subs[i] % right\_dims[i]) * this->m\_rightStrides[i];
00339       \}
00340       \textcolor{keywordflow}{return} this->m\_rightImpl.coeffRef(right\_index);
00341     \}
00342   \}
00343 
00344   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} StoreMode> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00345   \textcolor{keywordtype}{void} writePacket(Index index, \textcolor{keyword}{const} PacketReturnType& x)
00346   \{
00347     \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetSize = \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size}
      ;
00348     EIGEN\_STATIC\_ASSERT((packetSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00349     eigen\_assert(index + packetSize - 1 < this->dimensions().TotalSize());
00350 
00351     EIGEN\_ALIGN\_MAX CoeffReturnType values[packetSize];
00352     internal::pstore<CoeffReturnType, PacketReturnType>(values, x);
00353     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < packetSize; ++i) \{
00354       coeffRef(index+i) = values[i];
00355     \}
00356   \}
00357 \};
00358 
00359 \} \textcolor{comment}{// end namespace Eigen}
00360 
00361 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_CONCATENATION\_H}
\end{DoxyCode}
