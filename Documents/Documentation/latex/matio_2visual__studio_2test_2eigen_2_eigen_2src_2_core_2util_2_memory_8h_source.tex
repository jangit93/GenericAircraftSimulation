\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2util_2_memory_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/util/\+Memory.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2util_2_memory_8h_source}\index{Memory.\+h@{Memory.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2008-2009 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{// Copyright (C) 2009 Kenneth Riddile <kfriddile@yahoo.com>}
00007 \textcolor{comment}{// Copyright (C) 2010 Hauke Heibel <hauke.heibel@gmail.com>}
00008 \textcolor{comment}{// Copyright (C) 2010 Thomas Capricelli <orzel@freehackers.org>}
00009 \textcolor{comment}{// Copyright (C) 2013 Pavel Holoborodko <pavel@holoborodko.com>}
00010 \textcolor{comment}{//}
00011 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00012 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00013 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00014 
00015 
00016 \textcolor{comment}{/*****************************************************************************}
00017 \textcolor{comment}{*** Platform checks for aligned malloc functions                           ***}
00018 \textcolor{comment}{*****************************************************************************/}
00019 
00020 \textcolor{preprocessor}{#ifndef EIGEN\_MEMORY\_H}
00021 \textcolor{preprocessor}{#define EIGEN\_MEMORY\_H}
00022 
00023 \textcolor{preprocessor}{#ifndef EIGEN\_MALLOC\_ALREADY\_ALIGNED}
00024 
00025 \textcolor{comment}{// Try to determine automatically if malloc is already aligned.}
00026 
00027 \textcolor{comment}{// On 64-bit systems, glibc's malloc returns 16-byte-aligned pointers, see:}
00028 \textcolor{comment}{//   http://www.gnu.org/s/libc/manual/html\_node/Aligned-Memory-Blocks.html}
00029 \textcolor{comment}{// This is true at least since glibc 2.8.}
00030 \textcolor{comment}{// This leaves the question how to detect 64-bit. According to this document,}
00031 \textcolor{comment}{//   http://gcc.fyxm.net/summit/2003/Porting%20to%2064%20bit.pdf}
00032 \textcolor{comment}{// page 114, "[The] LP64 model [...] is used by all 64-bit UNIX ports" so it's indeed}
00033 \textcolor{comment}{// quite safe, at least within the context of glibc, to equate 64-bit with LP64.}
00034 \textcolor{preprocessor}{#if defined(\_\_GLIBC\_\_) && ((\_\_GLIBC\_\_>=2 && \_\_GLIBC\_MINOR\_\_ >= 8) || \_\_GLIBC\_\_>2) \(\backslash\)}
00035 \textcolor{preprocessor}{ && defined(\_\_LP64\_\_) && ! defined( \_\_SANITIZE\_ADDRESS\_\_ ) && (EIGEN\_DEFAULT\_ALIGN\_BYTES == 16)}
00036 \textcolor{preprocessor}{  #define EIGEN\_GLIBC\_MALLOC\_ALREADY\_ALIGNED 1}
00037 \textcolor{preprocessor}{#else}
00038 \textcolor{preprocessor}{  #define EIGEN\_GLIBC\_MALLOC\_ALREADY\_ALIGNED 0}
00039 \textcolor{preprocessor}{#endif}
00040 
00041 \textcolor{comment}{// FreeBSD 6 seems to have 16-byte aligned malloc}
00042 \textcolor{comment}{//   See http://svn.freebsd.org/viewvc/base/stable/6/lib/libc/stdlib/malloc.c?view=markup}
00043 \textcolor{comment}{// FreeBSD 7 seems to have 16-byte aligned malloc except on ARM and MIPS architectures}
00044 \textcolor{comment}{//   See http://svn.freebsd.org/viewvc/base/stable/7/lib/libc/stdlib/malloc.c?view=markup}
00045 \textcolor{preprocessor}{#if defined(\_\_FreeBSD\_\_) && !(EIGEN\_ARCH\_ARM || EIGEN\_ARCH\_MIPS) && (EIGEN\_DEFAULT\_ALIGN\_BYTES == 16)}
00046 \textcolor{preprocessor}{  #define EIGEN\_FREEBSD\_MALLOC\_ALREADY\_ALIGNED 1}
00047 \textcolor{preprocessor}{#else}
00048 \textcolor{preprocessor}{  #define EIGEN\_FREEBSD\_MALLOC\_ALREADY\_ALIGNED 0}
00049 \textcolor{preprocessor}{#endif}
00050 
00051 \textcolor{preprocessor}{#if (EIGEN\_OS\_MAC && (EIGEN\_DEFAULT\_ALIGN\_BYTES == 16))     \(\backslash\)}
00052 \textcolor{preprocessor}{ || (EIGEN\_OS\_WIN64 && (EIGEN\_DEFAULT\_ALIGN\_BYTES == 16))   \(\backslash\)}
00053 \textcolor{preprocessor}{ || EIGEN\_GLIBC\_MALLOC\_ALREADY\_ALIGNED              \(\backslash\)}
00054 \textcolor{preprocessor}{ || EIGEN\_FREEBSD\_MALLOC\_ALREADY\_ALIGNED}
00055 \textcolor{preprocessor}{  #define EIGEN\_MALLOC\_ALREADY\_ALIGNED 1}
00056 \textcolor{preprocessor}{#else}
00057 \textcolor{preprocessor}{  #define EIGEN\_MALLOC\_ALREADY\_ALIGNED 0}
00058 \textcolor{preprocessor}{#endif}
00059 
00060 \textcolor{preprocessor}{#endif}
00061 
00062 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00063 
00064 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00065 
00066 EIGEN\_DEVICE\_FUNC 
00067 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} throw\_std\_bad\_alloc()
00068 \{
00069 \textcolor{preprocessor}{  #ifdef EIGEN\_EXCEPTIONS}
00070     \textcolor{keywordflow}{throw} std::bad\_alloc();
00071 \textcolor{preprocessor}{  #else}
00072     std::size\_t huge = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-1);
00073     \textcolor{keyword}{new} \textcolor{keywordtype}{int}[huge];
00074 \textcolor{preprocessor}{  #endif}
00075 \}
00076 
00077 \textcolor{comment}{/*****************************************************************************}
00078 \textcolor{comment}{*** Implementation of handmade aligned functions                           ***}
00079 \textcolor{comment}{*****************************************************************************/}
00080 
00081 \textcolor{comment}{/* ----- Hand made implementations of aligned malloc/free and realloc ----- */}
00082 
00086 \textcolor{keyword}{inline} \textcolor{keywordtype}{void}* handmade\_aligned\_malloc(std::size\_t size)
00087 \{
00088   \textcolor{keywordtype}{void} *original = std::malloc(size+EIGEN\_DEFAULT\_ALIGN\_BYTES);
00089   \textcolor{keywordflow}{if} (original == 0) \textcolor{keywordflow}{return} 0;
00090   \textcolor{keywordtype}{void} *aligned = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}((\textcolor{keyword}{reinterpret\_cast<}std::size\_t\textcolor{keyword}{>}(original) & ~(std::size\_t(
      EIGEN\_DEFAULT\_ALIGN\_BYTES-1))) + EIGEN\_DEFAULT\_ALIGN\_BYTES);
00091   *(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}**\textcolor{keyword}{>}(aligned) - 1) = original;
00092   \textcolor{keywordflow}{return} aligned;
00093 \}
00094 
00096 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} handmade\_aligned\_free(\textcolor{keywordtype}{void} *ptr)
00097 \{
00098   \textcolor{keywordflow}{if} (ptr) std::free(*(reinterpret\_cast<void**>(ptr) - 1));
00099 \}
00100 
00106 \textcolor{keyword}{inline} \textcolor{keywordtype}{void}* handmade\_aligned\_realloc(\textcolor{keywordtype}{void}* ptr, std::size\_t size, std::size\_t = 0)
00107 \{
00108   \textcolor{keywordflow}{if} (ptr == 0) \textcolor{keywordflow}{return} handmade\_aligned\_malloc(size);
00109   \textcolor{keywordtype}{void} *original = *(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}**\textcolor{keyword}{>}(ptr) - 1);
00110   std::ptrdiff\_t previous\_offset = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(ptr)-static\_cast<char *>(original);
00111   original = std::realloc(original,size+EIGEN\_DEFAULT\_ALIGN\_BYTES);
00112   \textcolor{keywordflow}{if} (original == 0) \textcolor{keywordflow}{return} 0;
00113   \textcolor{keywordtype}{void} *aligned = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}((\textcolor{keyword}{reinterpret\_cast<}std::size\_t\textcolor{keyword}{>}(original) & ~(std::size\_t(
      EIGEN\_DEFAULT\_ALIGN\_BYTES-1))) + EIGEN\_DEFAULT\_ALIGN\_BYTES);
00114   \textcolor{keywordtype}{void} *previous\_aligned = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(original)+previous\_offset;
00115   \textcolor{keywordflow}{if}(aligned!=previous\_aligned)
00116     std::memmove(aligned, previous\_aligned, size);
00117   
00118   *(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}**\textcolor{keyword}{>}(aligned) - 1) = original;
00119   \textcolor{keywordflow}{return} aligned;
00120 \}
00121 
00122 \textcolor{comment}{/*****************************************************************************}
00123 \textcolor{comment}{*** Implementation of portable aligned versions of malloc/free/realloc     ***}
00124 \textcolor{comment}{*****************************************************************************/}
00125 
00126 \textcolor{preprocessor}{#ifdef EIGEN\_NO\_MALLOC}
00127 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} check\_that\_malloc\_is\_allowed()
00128 \{
00129   eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"heap allocation is forbidden (EIGEN\_NO\_MALLOC is defined)"});
00130 \}
00131 \textcolor{preprocessor}{#elif defined EIGEN\_RUNTIME\_NO\_MALLOC}
00132 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} is\_malloc\_allowed\_impl(\textcolor{keywordtype}{bool} update, \textcolor{keywordtype}{bool} new\_value = \textcolor{keyword}{false})
00133 \{
00134   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{true};
00135   \textcolor{keywordflow}{if} (update == 1)
00136     value = new\_value;
00137   \textcolor{keywordflow}{return} value;
00138 \}
00139 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} is\_malloc\_allowed() \{ \textcolor{keywordflow}{return} is\_malloc\_allowed\_impl(\textcolor{keyword}{false}); \}
00140 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} set\_is\_malloc\_allowed(\textcolor{keywordtype}{bool} new\_value) \{ \textcolor{keywordflow}{return} is\_malloc\_allowed\_impl(\textcolor{keyword}{true}, 
      new\_value); \}
00141 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} check\_that\_malloc\_is\_allowed()
00142 \{
00143   eigen\_assert(is\_malloc\_allowed() && \textcolor{stringliteral}{"heap allocation is forbidden (EIGEN\_RUNTIME\_NO\_MALLOC is defined and
       g\_is\_malloc\_allowed is false)"});
00144 \}
00145 \textcolor{preprocessor}{#else }
00146 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} check\_that\_malloc\_is\_allowed()
00147 \{\}
00148 \textcolor{preprocessor}{#endif}
00149 
00153 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}* aligned\_malloc(std::size\_t size)
00154 \{
00155   check\_that\_malloc\_is\_allowed();
00156 
00157   \textcolor{keywordtype}{void} *result;
00158 \textcolor{preprocessor}{  #if (EIGEN\_DEFAULT\_ALIGN\_BYTES==0) || EIGEN\_MALLOC\_ALREADY\_ALIGNED}
00159     result = std::malloc(size);
00160 \textcolor{preprocessor}{    #if EIGEN\_DEFAULT\_ALIGN\_BYTES==16}
00161     eigen\_assert((size<16 || (std::size\_t(result)%16)==0) && \textcolor{stringliteral}{"System's malloc returned an unaligned
       pointer. Compile with EIGEN\_MALLOC\_ALREADY\_ALIGNED=0 to fallback to handmade alignd memory allocator."});
00162 \textcolor{preprocessor}{    #endif}
00163 \textcolor{preprocessor}{  #else}
00164     result = handmade\_aligned\_malloc(size);
00165 \textcolor{preprocessor}{  #endif}
00166 
00167   \textcolor{keywordflow}{if}(!result && size)
00168     throw\_std\_bad\_alloc();
00169 
00170   \textcolor{keywordflow}{return} result;
00171 \}
00172 
00174 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} aligned\_free(\textcolor{keywordtype}{void} *ptr)
00175 \{
00176 \textcolor{preprocessor}{  #if (EIGEN\_DEFAULT\_ALIGN\_BYTES==0) || EIGEN\_MALLOC\_ALREADY\_ALIGNED}
00177     std::free(ptr);
00178 \textcolor{preprocessor}{  #else}
00179     handmade\_aligned\_free(ptr);
00180 \textcolor{preprocessor}{  #endif}
00181 \}
00182 
00188 \textcolor{keyword}{inline} \textcolor{keywordtype}{void}* aligned\_realloc(\textcolor{keywordtype}{void} *ptr, std::size\_t new\_size, std::size\_t old\_size)
00189 \{
00190   EIGEN\_UNUSED\_VARIABLE(old\_size);
00191 
00192   \textcolor{keywordtype}{void} *result;
00193 \textcolor{preprocessor}{#if (EIGEN\_DEFAULT\_ALIGN\_BYTES==0) || EIGEN\_MALLOC\_ALREADY\_ALIGNED}
00194   result = std::realloc(ptr,new\_size);
00195 \textcolor{preprocessor}{#else}
00196   result = handmade\_aligned\_realloc(ptr,new\_size,old\_size);
00197 \textcolor{preprocessor}{#endif}
00198 
00199   \textcolor{keywordflow}{if} (!result && new\_size)
00200     throw\_std\_bad\_alloc();
00201 
00202   \textcolor{keywordflow}{return} result;
00203 \}
00204 
00205 \textcolor{comment}{/*****************************************************************************}
00206 \textcolor{comment}{*** Implementation of conditionally aligned functions                      ***}
00207 \textcolor{comment}{*****************************************************************************/}
00208 
00212 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Align> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}* conditional\_aligned\_malloc(std::size\_t size)
00213 \{
00214   \textcolor{keywordflow}{return} aligned\_malloc(size);
00215 \}
00216 
00217 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}* conditional\_aligned\_malloc<false>(std::size\_t size)
00218 \{
00219   check\_that\_malloc\_is\_allowed();
00220 
00221   \textcolor{keywordtype}{void} *result = std::malloc(size);
00222   \textcolor{keywordflow}{if}(!result && size)
00223     throw\_std\_bad\_alloc();
00224   \textcolor{keywordflow}{return} result;
00225 \}
00226 
00228 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Align> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} conditional\_aligned\_free(\textcolor{keywordtype}{void} *ptr)
00229 \{
00230   aligned\_free(ptr);
00231 \}
00232 
00233 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} conditional\_aligned\_free<false>(\textcolor{keywordtype}{void} *ptr)
00234 \{
00235   std::free(ptr);
00236 \}
00237 
00238 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Align> \textcolor{keyword}{inline} \textcolor{keywordtype}{void}* conditional\_aligned\_realloc(\textcolor{keywordtype}{void}* ptr, std::size\_t new\_size, std::size\_t 
      old\_size)
00239 \{
00240   \textcolor{keywordflow}{return} aligned\_realloc(ptr, new\_size, old\_size);
00241 \}
00242 
00243 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{void}* conditional\_aligned\_realloc<false>(\textcolor{keywordtype}{void}* ptr, std::size\_t new\_size, std::size\_t)
00244 \{
00245   \textcolor{keywordflow}{return} std::realloc(ptr, new\_size);
00246 \}
00247 
00248 \textcolor{comment}{/*****************************************************************************}
00249 \textcolor{comment}{*** Construction/destruction of array elements                             ***}
00250 \textcolor{comment}{*****************************************************************************/}
00251 
00255 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} destruct\_elements\_of\_array(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *ptr, std::size\_t size)
00256 \{
00257   \textcolor{comment}{// always destruct an array starting from the end.}
00258   \textcolor{keywordflow}{if}(ptr)
00259     \textcolor{keywordflow}{while}(size) ptr[--size].~T();
00260 \}
00261 
00265 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* construct\_elements\_of\_array(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *ptr, std::size\_t size)
00266 \{
00267   std::size\_t i;
00268   EIGEN\_TRY
00269   \{
00270       \textcolor{keywordflow}{for} (i = 0; i < size; ++i) ::\textcolor{keyword}{new} (ptr + i) \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T};
00271       \textcolor{keywordflow}{return} ptr;
00272   \}
00273   EIGEN\_CATCH(...)
00274   \{
00275     destruct\_elements\_of\_array(ptr, i);
00276     EIGEN\_THROW;
00277   \}
00278   \textcolor{keywordflow}{return} NULL;
00279 \}
00280 
00281 \textcolor{comment}{/*****************************************************************************}
00282 \textcolor{comment}{*** Implementation of aligned new/delete-like functions                    ***}
00283 \textcolor{comment}{*****************************************************************************/}
00284 
00285 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00286 EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \textcolor{keywordtype}{void} check\_size\_for\_overflow(std::size\_t size)
00287 \{
00288   \textcolor{keywordflow}{if}(size > std::size\_t(-1) / \textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}))
00289     throw\_std\_bad\_alloc();
00290 \}
00291 
00296 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* aligned\_new(std::size\_t size)
00297 \{
00298   check\_size\_for\_overflow<T>(size);
00299   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *result = \textcolor{keyword}{reinterpret\_cast<}\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*\textcolor{keyword}{>}(aligned\_malloc(\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})*size));
00300   EIGEN\_TRY
00301   \{
00302     \textcolor{keywordflow}{return} construct\_elements\_of\_array(result, size);
00303   \}
00304   EIGEN\_CATCH(...)
00305   \{
00306     aligned\_free(result);
00307     EIGEN\_THROW;
00308   \}
00309   \textcolor{keywordflow}{return} result;
00310 \}
00311 
00312 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} Align> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* conditional\_aligned\_new(std::size\_t size)
00313 \{
00314   check\_size\_for\_overflow<T>(size);
00315   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *result = \textcolor{keyword}{reinterpret\_cast<}\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*\textcolor{keyword}{>}(conditional\_aligned\_malloc<Align>(\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})*size));
00316   EIGEN\_TRY
00317   \{
00318     \textcolor{keywordflow}{return} construct\_elements\_of\_array(result, size);
00319   \}
00320   EIGEN\_CATCH(...)
00321   \{
00322     conditional\_aligned\_free<Align>(result);
00323     EIGEN\_THROW;
00324   \}
00325   \textcolor{keywordflow}{return} result;
00326 \}
00327 
00331 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} aligned\_delete(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *ptr, std::size\_t size)
00332 \{
00333   destruct\_elements\_of\_array<T>(ptr, size);
00334   aligned\_free(ptr);
00335 \}
00336 
00340 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} Align> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} conditional\_aligned\_delete(
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *ptr, std::size\_t size)
00341 \{
00342   destruct\_elements\_of\_array<T>(ptr, size);
00343   conditional\_aligned\_free<Align>(ptr);
00344 \}
00345 
00346 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} Align> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* conditional\_aligned\_realloc\_new(
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* pts, std::size\_t new\_size, std::size\_t old\_size)
00347 \{
00348   check\_size\_for\_overflow<T>(new\_size);
00349   check\_size\_for\_overflow<T>(old\_size);
00350   \textcolor{keywordflow}{if}(new\_size < old\_size)
00351     destruct\_elements\_of\_array(pts+new\_size, old\_size-new\_size);
00352   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *result = \textcolor{keyword}{reinterpret\_cast<}\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*\textcolor{keyword}{>}(conditional\_aligned\_realloc<Align>(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(pts), \textcolor{keyword}{
      sizeof}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})*new\_size, \textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})*old\_size));
00353   \textcolor{keywordflow}{if}(new\_size > old\_size)
00354   \{
00355     EIGEN\_TRY
00356     \{
00357       construct\_elements\_of\_array(result+old\_size, new\_size-old\_size);
00358     \}
00359     EIGEN\_CATCH(...)
00360     \{
00361       conditional\_aligned\_free<Align>(result);
00362       EIGEN\_THROW;
00363     \}
00364   \}
00365   \textcolor{keywordflow}{return} result;
00366 \}
00367 
00368 
00369 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} Align> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* conditional\_aligned\_new\_auto(std::size\_t size
      )
00370 \{
00371   \textcolor{keywordflow}{if}(size==0)
00372     \textcolor{keywordflow}{return} 0; \textcolor{comment}{// short-cut. Also fixes Bug 884}
00373   check\_size\_for\_overflow<T>(size);
00374   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *result = \textcolor{keyword}{reinterpret\_cast<}\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*\textcolor{keyword}{>}(conditional\_aligned\_malloc<Align>(\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})*size));
00375   \textcolor{keywordflow}{if}(NumTraits<T>::RequireInitialization)
00376   \{
00377     EIGEN\_TRY
00378     \{
00379       construct\_elements\_of\_array(result, size);
00380     \}
00381     EIGEN\_CATCH(...)
00382     \{
00383       conditional\_aligned\_free<Align>(result);
00384       EIGEN\_THROW;
00385     \}
00386   \}
00387   \textcolor{keywordflow}{return} result;
00388 \}
00389 
00390 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} Align> \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* conditional\_aligned\_realloc\_new\_auto(
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* pts, std::size\_t new\_size, std::size\_t old\_size)
00391 \{
00392   check\_size\_for\_overflow<T>(new\_size);
00393   check\_size\_for\_overflow<T>(old\_size);
00394   \textcolor{keywordflow}{if}(NumTraits<T>::RequireInitialization && (new\_size < old\_size))
00395     destruct\_elements\_of\_array(pts+new\_size, old\_size-new\_size);
00396   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *result = \textcolor{keyword}{reinterpret\_cast<}\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*\textcolor{keyword}{>}(conditional\_aligned\_realloc<Align>(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(pts), \textcolor{keyword}{
      sizeof}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})*new\_size, \textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})*old\_size));
00397   \textcolor{keywordflow}{if}(NumTraits<T>::RequireInitialization && (new\_size > old\_size))
00398   \{
00399     EIGEN\_TRY
00400     \{
00401       construct\_elements\_of\_array(result+old\_size, new\_size-old\_size);
00402     \}
00403     EIGEN\_CATCH(...)
00404     \{
00405       conditional\_aligned\_free<Align>(result);
00406       EIGEN\_THROW;
00407     \}
00408   \}
00409   \textcolor{keywordflow}{return} result;
00410 \}
00411 
00412 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} Align> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} conditional\_aligned\_delete\_auto(
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *ptr, std::size\_t size)
00413 \{
00414   \textcolor{keywordflow}{if}(NumTraits<T>::RequireInitialization)
00415     destruct\_elements\_of\_array<T>(ptr, size);
00416   conditional\_aligned\_free<Align>(ptr);
00417 \}
00418 
00419 \textcolor{comment}{/****************************************************************************/}
00420 
00438 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Alignment, \textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index>
00439 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} first\_aligned(\textcolor{keyword}{const} Scalar* array, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size)
00440 \{
00441   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} ScalarSize = \textcolor{keyword}{sizeof}(Scalar);
00442   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} AlignmentSize = Alignment / ScalarSize;
00443   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} AlignmentMask = AlignmentSize-1;
00444 
00445   \textcolor{keywordflow}{if}(AlignmentSize<=1)
00446   \{
00447     \textcolor{comment}{// Either the requested alignment if smaller than a scalar, or it exactly match a 1 scalar}
00448     \textcolor{comment}{// so that all elements of the array have the same alignment.}
00449     \textcolor{keywordflow}{return} 0;
00450   \}
00451   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( (UIntPtr(array) & (\textcolor{keyword}{sizeof}(Scalar)-1)) || (Alignment%ScalarSize)!=0)
00452   \{
00453     \textcolor{comment}{// The array is not aligned to the size of a single scalar, or the requested alignment is not a
       multiple of the scalar size.}
00454     \textcolor{comment}{// Consequently, no element of the array is well aligned.}
00455     \textcolor{keywordflow}{return} size;
00456   \}
00457   \textcolor{keywordflow}{else}
00458   \{
00459     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} first = (AlignmentSize - (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}((UIntPtr(array)/\textcolor{keyword}{sizeof}(Scalar))) & AlignmentMask)) & 
      AlignmentMask;
00460     \textcolor{keywordflow}{return} (first < size) ? first : size;
00461   \}
00462 \}
00463 
00466 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index>
00467 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} first\_default\_aligned(\textcolor{keyword}{const} Scalar* array, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size)
00468 \{
00469   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::type DefaultPacketType;
00470   \textcolor{keywordflow}{return} first\_aligned<unpacket\_traits<DefaultPacketType>::alignment>(array, size);
00471 \}
00472 
00475 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Index> 
00476 \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} first\_multiple(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} base)
00477 \{
00478   \textcolor{keywordflow}{return} ((size+base-1)/base)*base;
00479 \}
00480 
00481 \textcolor{comment}{// std::copy is much slower than memcpy, so let's introduce a smart\_copy which}
00482 \textcolor{comment}{// use memcpy on trivial types, i.e., on types that does not require an initialization ctor.}
00483 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} UseMemcpy> \textcolor{keyword}{struct }smart\_copy\_helper;
00484 
00485 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} smart\_copy(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* start, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* end, 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* target)
00486 \{
00487   smart\_copy\_helper<T,!NumTraits<T>::RequireInitialization>::run(start, end, target);
00488 \}
00489 
00490 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }smart\_copy\_helper<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T},true> \{
00491   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* start, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* end, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* target)
00492   \{
00493     IntPtr size = IntPtr(end)-IntPtr(start);
00494     \textcolor{keywordflow}{if}(size==0) \textcolor{keywordflow}{return};
00495     eigen\_internal\_assert(start!=0 && end!=0 && target!=0);
00496     memcpy(target, start, size);
00497   \}
00498 \};
00499 
00500 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }smart\_copy\_helper<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T},false> \{
00501   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* start, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* end, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* target)
00502   \{ std::copy(start, end, target); \}
00503 \};
00504 
00505 \textcolor{comment}{// intelligent memmove. falls back to std::memmove for POD types, uses std::copy otherwise. }
00506 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} UseMemmove> \textcolor{keyword}{struct }smart\_memmove\_helper;
00507 
00508 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keywordtype}{void} smart\_memmove(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* start, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* end, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* target)
00509 \{
00510   smart\_memmove\_helper<T,!NumTraits<T>::RequireInitialization>::run(start, end, target);
00511 \}
00512 
00513 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }smart\_memmove\_helper<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T},true> \{
00514   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* start, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* end, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* target)
00515   \{
00516     IntPtr size = IntPtr(end)-IntPtr(start);
00517     \textcolor{keywordflow}{if}(size==0) \textcolor{keywordflow}{return};
00518     eigen\_internal\_assert(start!=0 && end!=0 && target!=0);
00519     std::memmove(target, start, size);
00520   \}
00521 \};
00522 
00523 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }smart\_memmove\_helper<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T},false> \{
00524   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* start, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* end, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* target)
00525   \{ 
00526     \textcolor{keywordflow}{if} (UIntPtr(target) < UIntPtr(start))
00527     \{
00528       std::copy(start, end, target);
00529     \}
00530     \textcolor{keywordflow}{else}                                 
00531     \{
00532       std::ptrdiff\_t count = (std::ptrdiff\_t(end)-std::ptrdiff\_t(start)) / \textcolor{keyword}{sizeof}(
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T});
00533       std::copy\_backward(start, end, target + count); 
00534     \}
00535   \}
00536 \};
00537 
00538 
00539 \textcolor{comment}{/*****************************************************************************}
00540 \textcolor{comment}{*** Implementation of runtime stack allocation (falling back to malloc)    ***}
00541 \textcolor{comment}{*****************************************************************************/}
00542 
00543 \textcolor{comment}{// you can overwrite Eigen's default behavior regarding alloca by defining EIGEN\_ALLOCA}
00544 \textcolor{comment}{// to the appropriate stack allocation function}
00545 \textcolor{preprocessor}{#ifndef EIGEN\_ALLOCA}
00546 \textcolor{preprocessor}{  #if EIGEN\_OS\_LINUX || EIGEN\_OS\_MAC || (defined alloca)}
00547 \textcolor{preprocessor}{    #define EIGEN\_ALLOCA alloca}
00548 \textcolor{preprocessor}{  #elif EIGEN\_COMP\_MSVC}
00549 \textcolor{preprocessor}{    #define EIGEN\_ALLOCA \_alloca}
00550 \textcolor{preprocessor}{  #endif}
00551 \textcolor{preprocessor}{#endif}
00552 
00553 \textcolor{comment}{// This helper class construct the allocated memory, and takes care of destructing and freeing the handled
       data}
00554 \textcolor{comment}{// at destruction time. In practice this helper class is mainly useful to avoid memory leak in case of
       exceptions.}
00555 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{class }aligned\_stack\_memory\_handler : noncopyable
00556 \{
00557   \textcolor{keyword}{public}:
00558     \textcolor{comment}{/* Creates a stack\_memory\_handler responsible for the buffer \(\backslash\)a ptr of size \(\backslash\)a size.}
00559 \textcolor{comment}{     * Note that \(\backslash\)a ptr can be 0 regardless of the other parameters.}
00560 \textcolor{comment}{     * This constructor takes care of constructing/initializing the elements of the buffer if required by
       the scalar type T (see NumTraits<T>::RequireInitialization).}
00561 \textcolor{comment}{     * In this case, the buffer elements will also be destructed when this handler will be destructed.}
00562 \textcolor{comment}{     * Finally, if \(\backslash\)a dealloc is true, then the pointer \(\backslash\)a ptr is freed.}
00563 \textcolor{comment}{     **/}
00564     aligned\_stack\_memory\_handler(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* ptr, std::size\_t size, \textcolor{keywordtype}{bool} dealloc)
00565       : m\_ptr(ptr), m\_size(size), m\_deallocate(dealloc)
00566     \{
00567       \textcolor{keywordflow}{if}(NumTraits<T>::RequireInitialization && m\_ptr)
00568         Eigen::internal::construct\_elements\_of\_array(m\_ptr, size);
00569     \}
00570     ~aligned\_stack\_memory\_handler()
00571     \{
00572       \textcolor{keywordflow}{if}(NumTraits<T>::RequireInitialization && m\_ptr)
00573         Eigen::internal::destruct\_elements\_of\_array<T>(m\_ptr, m\_size);
00574       \textcolor{keywordflow}{if}(m\_deallocate)
00575         Eigen::internal::aligned\_free(m\_ptr);
00576     \}
00577   \textcolor{keyword}{protected}:
00578     \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* m\_ptr;
00579     std::size\_t m\_size;
00580     \textcolor{keywordtype}{bool} m\_deallocate;
00581 \};
00582 
00583 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{class }scoped\_array : noncopyable
00584 \{
00585   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* m\_ptr;
00586 \textcolor{keyword}{public}:
00587   \textcolor{keyword}{explicit} scoped\_array(std::ptrdiff\_t size)
00588   \{
00589     m\_ptr = \textcolor{keyword}{new} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}[size];
00590   \}
00591   ~scoped\_array()
00592   \{
00593     \textcolor{keyword}{delete}[] m\_ptr;
00594   \}
00595   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& operator[](std::ptrdiff\_t i) \{ \textcolor{keywordflow}{return} m\_ptr[i]; \}
00596   \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& operator[](std::ptrdiff\_t i)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_ptr[i]; \}
00597   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* &ptr() \{ \textcolor{keywordflow}{return} m\_ptr; \}
00598   \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}* ptr()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_ptr; \}
00599   \textcolor{keyword}{operator} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*() \textcolor{keyword}{const} \{ \textcolor{keywordflow}{return} m\_ptr; \}
00600 \};
00601 
00602 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keywordtype}{void} \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(scoped\_array<T> &a,scoped\_array<T> &b)
00603 \{
00604   \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(a.ptr(),b.ptr());
00605 \}
00606     
00607 \} \textcolor{comment}{// end namespace internal}
00608 
00624 \textcolor{preprocessor}{#ifdef EIGEN\_ALLOCA}
00625   
00626 \textcolor{preprocessor}{  #if EIGEN\_DEFAULT\_ALIGN\_BYTES>0}
00627     \textcolor{comment}{// We always manually re-align the result of EIGEN\_ALLOCA.}
00628     \textcolor{comment}{// If alloca is already aligned, the compiler should be smart enough to optimize away the re-alignment.}
00629 \textcolor{preprocessor}{    #define EIGEN\_ALIGNED\_ALLOCA(SIZE)
       reinterpret\_cast<void*>((internal::UIntPtr(EIGEN\_ALLOCA(SIZE+EIGEN\_DEFAULT\_ALIGN\_BYTES-1)) + EIGEN\_DEFAULT\_ALIGN\_BYTES-1) & ~(std::size\_t(EIGEN\_DEFAULT\_ALIGN\_BYTES-1)))}
00630 \textcolor{preprocessor}{  #else}
00631 \textcolor{preprocessor}{    #define EIGEN\_ALIGNED\_ALLOCA(SIZE) EIGEN\_ALLOCA(SIZE)}
00632 \textcolor{preprocessor}{  #endif}
00633 
00634 \textcolor{preprocessor}{  #define ei\_declare\_aligned\_stack\_constructed\_variable(TYPE,NAME,SIZE,BUFFER) \(\backslash\)}
00635 \textcolor{preprocessor}{    Eigen::internal::check\_size\_for\_overflow<TYPE>(SIZE); \(\backslash\)}
00636 \textcolor{preprocessor}{    TYPE* NAME = (BUFFER)!=0 ? (BUFFER) \(\backslash\)}
00637 \textcolor{preprocessor}{               : reinterpret\_cast<TYPE*>( \(\backslash\)}
00638 \textcolor{preprocessor}{                      (sizeof(TYPE)*SIZE<=EIGEN\_STACK\_ALLOCATION\_LIMIT) ?
       EIGEN\_ALIGNED\_ALLOCA(sizeof(TYPE)*SIZE) \(\backslash\)}
00639 \textcolor{preprocessor}{                    : Eigen::internal::aligned\_malloc(sizeof(TYPE)*SIZE) );  \(\backslash\)}
00640 \textcolor{preprocessor}{    Eigen::internal::aligned\_stack\_memory\_handler<TYPE>
       EIGEN\_CAT(NAME,\_stack\_memory\_destructor)((BUFFER)==0 ? NAME : 0,SIZE,sizeof(TYPE)*SIZE>EIGEN\_STACK\_ALLOCATION\_LIMIT)}
00641 
00642 \textcolor{preprocessor}{#else}
00643 
00644 \textcolor{preprocessor}{  #define ei\_declare\_aligned\_stack\_constructed\_variable(TYPE,NAME,SIZE,BUFFER) \(\backslash\)}
00645 \textcolor{preprocessor}{    Eigen::internal::check\_size\_for\_overflow<TYPE>(SIZE); \(\backslash\)}
00646 \textcolor{preprocessor}{    TYPE* NAME = (BUFFER)!=0 ? BUFFER :
       reinterpret\_cast<TYPE*>(Eigen::internal::aligned\_malloc(sizeof(TYPE)*SIZE));    \(\backslash\)}
00647 \textcolor{preprocessor}{    Eigen::internal::aligned\_stack\_memory\_handler<TYPE>
       EIGEN\_CAT(NAME,\_stack\_memory\_destructor)((BUFFER)==0 ? NAME : 0,SIZE,true)}
00648     
00649 \textcolor{preprocessor}{#endif}
00650 
00651 
00652 \textcolor{comment}{/*****************************************************************************}
00653 \textcolor{comment}{*** Implementation of EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW [\_IF]                ***}
00654 \textcolor{comment}{*****************************************************************************/}
00655 
00656 \textcolor{preprocessor}{#if EIGEN\_MAX\_ALIGN\_BYTES!=0}
00657 \textcolor{preprocessor}{  #define EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_NOTHROW(NeedsToAlign) \(\backslash\)}
00658 \textcolor{preprocessor}{      void* operator new(std::size\_t size, const std::nothrow\_t&) EIGEN\_NO\_THROW \{ \(\backslash\)}
00659 \textcolor{preprocessor}{        EIGEN\_TRY \{ return Eigen::internal::conditional\_aligned\_malloc<NeedsToAlign>(size); \} \(\backslash\)}
00660 \textcolor{preprocessor}{        EIGEN\_CATCH (...) \{ return 0; \} \(\backslash\)}
00661 \textcolor{preprocessor}{      \}}
00662 \textcolor{preprocessor}{  #define EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF(NeedsToAlign) \(\backslash\)}
00663 \textcolor{preprocessor}{      void *operator new(std::size\_t size) \{ \(\backslash\)}
00664 \textcolor{preprocessor}{        return Eigen::internal::conditional\_aligned\_malloc<NeedsToAlign>(size); \(\backslash\)}
00665 \textcolor{preprocessor}{      \} \(\backslash\)}
00666 \textcolor{preprocessor}{      void *operator new[](std::size\_t size) \{ \(\backslash\)}
00667 \textcolor{preprocessor}{        return Eigen::internal::conditional\_aligned\_malloc<NeedsToAlign>(size); \(\backslash\)}
00668 \textcolor{preprocessor}{      \} \(\backslash\)}
00669 \textcolor{preprocessor}{      void operator delete(void * ptr) EIGEN\_NO\_THROW \{
       Eigen::internal::conditional\_aligned\_free<NeedsToAlign>(ptr); \} \(\backslash\)}
00670 \textcolor{preprocessor}{      void operator delete[](void * ptr) EIGEN\_NO\_THROW \{
       Eigen::internal::conditional\_aligned\_free<NeedsToAlign>(ptr); \} \(\backslash\)}
00671 \textcolor{preprocessor}{      void operator delete(void * ptr, std::size\_t }\textcolor{comment}{/* sz */}\textcolor{preprocessor}{) EIGEN\_NO\_THROW \{
       Eigen::internal::conditional\_aligned\_free<NeedsToAlign>(ptr); \} \(\backslash\)}
00672 \textcolor{preprocessor}{      void operator delete[](void * ptr, std::size\_t }\textcolor{comment}{/* sz */}\textcolor{preprocessor}{) EIGEN\_NO\_THROW \{
       Eigen::internal::conditional\_aligned\_free<NeedsToAlign>(ptr); \} \(\backslash\)}
00673 \textcolor{preprocessor}{      }\textcolor{comment}{/* in-place new and delete. since (at least afaik) there is no actual   */}\textcolor{preprocessor}{ \(\backslash\)}
00674 \textcolor{preprocessor}{      }\textcolor{comment}{/* memory allocated we can safely let the default implementation handle */}\textcolor{preprocessor}{ \(\backslash\)}
00675 \textcolor{preprocessor}{      }\textcolor{comment}{/* this particular case. */}\textcolor{preprocessor}{ \(\backslash\)}
00676 \textcolor{preprocessor}{      static void *operator new(std::size\_t size, void *ptr) \{ return ::operator new(size,ptr); \} \(\backslash\)}
00677 \textcolor{preprocessor}{      static void *operator new[](std::size\_t size, void* ptr) \{ return ::operator new[](size,ptr); \} \(\backslash\)}
00678 \textcolor{preprocessor}{      void operator delete(void * memory, void *ptr) EIGEN\_NO\_THROW \{ return ::operator delete(memory,ptr);
       \} \(\backslash\)}
00679 \textcolor{preprocessor}{      void operator delete[](void * memory, void *ptr) EIGEN\_NO\_THROW \{ return ::operator
       delete[](memory,ptr); \} \(\backslash\)}
00680 \textcolor{preprocessor}{      }\textcolor{comment}{/* nothrow-new (returns zero instead of std::bad\_alloc) */}\textcolor{preprocessor}{ \(\backslash\)}
00681 \textcolor{preprocessor}{      EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_NOTHROW(NeedsToAlign) \(\backslash\)}
00682 \textcolor{preprocessor}{      void operator delete(void *ptr, const std::nothrow\_t&) EIGEN\_NO\_THROW \{ \(\backslash\)}
00683 \textcolor{preprocessor}{        Eigen::internal::conditional\_aligned\_free<NeedsToAlign>(ptr); \(\backslash\)}
00684 \textcolor{preprocessor}{      \} \(\backslash\)}
00685 \textcolor{preprocessor}{      typedef void eigen\_aligned\_operator\_new\_marker\_type;}
00686 \textcolor{preprocessor}{#else}
00687 \textcolor{preprocessor}{  #define EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF(NeedsToAlign)}
00688 \textcolor{preprocessor}{#endif}
00689 
00690 \textcolor{preprocessor}{#define EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF(true)}
00691 \textcolor{preprocessor}{#define EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF\_VECTORIZABLE\_FIXED\_SIZE(Scalar,Size) \(\backslash\)}
00692 \textcolor{preprocessor}{  EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF(bool(((Size)!=Eigen::Dynamic) &&
       ((sizeof(Scalar)*(Size))%EIGEN\_MAX\_ALIGN\_BYTES==0)))}
00693 
00694 \textcolor{comment}{/****************************************************************************/}
00695 
00712 \textcolor{keyword}{template}<\textcolor{keyword}{class} T>
00713 \textcolor{keyword}{class }aligned\_allocator : \textcolor{keyword}{public} std::allocator<T>
00714 \{
00715 \textcolor{keyword}{public}:
00716   \textcolor{keyword}{typedef} std::size\_t     size\_type;
00717   \textcolor{keyword}{typedef} std::ptrdiff\_t  difference\_type;
00718   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*              pointer;
00719   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}*        const\_pointer;
00720   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&              reference;
00721   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&        const\_reference;
00722   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}               value\_type;
00723 
00724   \textcolor{keyword}{template}<\textcolor{keyword}{class} U>
00725   \textcolor{keyword}{struct }rebind
00726   \{
00727     \textcolor{keyword}{typedef} aligned\_allocator<U> other;
00728   \};
00729 
00730   aligned\_allocator() : \hyperlink{namespacestd}{std}::allocator<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}>() \{\}
00731 
00732   aligned\_allocator(\textcolor{keyword}{const} aligned\_allocator& other) : \hyperlink{namespacestd}{std}::allocator<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}>(other) \{\}
00733 
00734   \textcolor{keyword}{template}<\textcolor{keyword}{class} U>
00735   aligned\_allocator(\textcolor{keyword}{const} aligned\_allocator<U>& other) : \hyperlink{namespacestd}{std}::allocator<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}>(other) \{\}
00736 
00737   ~aligned\_allocator() \{\}
00738 
00739   pointer allocate(size\_type num, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \textcolor{comment}{/*hint*/} = 0)
00740   \{
00741     internal::check\_size\_for\_overflow<T>(num);
00742     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}pointer\textcolor{keyword}{>}( internal::aligned\_malloc(num * \textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T})) );
00743   \}
00744 
00745   \textcolor{keywordtype}{void} deallocate(pointer p, size\_type \textcolor{comment}{/*num*/})
00746   \{
00747     internal::aligned\_free(p);
00748   \}
00749 \};
00750 
00751 \textcolor{comment}{//---------- Cache sizes ----------}
00752 
00753 \textcolor{preprocessor}{#if !defined(EIGEN\_NO\_CPUID)}
00754 \textcolor{preprocessor}{#  if EIGEN\_COMP\_GNUC && EIGEN\_ARCH\_i386\_OR\_x86\_64}
00755 \textcolor{preprocessor}{#    if defined(\_\_PIC\_\_) && EIGEN\_ARCH\_i386}
00756        \textcolor{comment}{// Case for x86 with PIC}
00757 \textcolor{preprocessor}{#      define EIGEN\_CPUID(abcd,func,id) \(\backslash\)}
00758 \textcolor{preprocessor}{         \_\_asm\_\_ \_\_volatile\_\_ ("xchgl %%ebx, %k1;cpuid; xchgl %%ebx,%k1": "=a" (abcd[0]), "=&r" (abcd[1]),
       "=c" (abcd[2]), "=d" (abcd[3]) : "a" (func), "c" (id));}
00759 \textcolor{preprocessor}{#    elif defined(\_\_PIC\_\_) && EIGEN\_ARCH\_x86\_64}
00760        \textcolor{comment}{// Case for x64 with PIC. In theory this is only a problem with recent gcc and with medium or large
       code model, not with the default small code model.}
00761        \textcolor{comment}{// However, we cannot detect which code model is used, and the xchg overhead is negligible anyway.}
00762 \textcolor{preprocessor}{#      define EIGEN\_CPUID(abcd,func,id) \(\backslash\)}
00763 \textcolor{preprocessor}{        \_\_asm\_\_ \_\_volatile\_\_ ("xchg\{q\}\(\backslash\)t\{%%\}rbx, %q1; cpuid; xchg\{q\}\(\backslash\)t\{%%\}rbx, %q1": "=a" (abcd[0]), "=&r"
       (abcd[1]), "=c" (abcd[2]), "=d" (abcd[3]) : "0" (func), "2" (id));}
00764 \textcolor{preprocessor}{#    else}
00765        \textcolor{comment}{// Case for x86\_64 or x86 w/o PIC}
00766 \textcolor{preprocessor}{#      define EIGEN\_CPUID(abcd,func,id) \(\backslash\)}
00767 \textcolor{preprocessor}{         \_\_asm\_\_ \_\_volatile\_\_ ("cpuid": "=a" (abcd[0]), "=b" (abcd[1]), "=c" (abcd[2]), "=d" (abcd[3]) :
       "0" (func), "2" (id) );}
00768 \textcolor{preprocessor}{#    endif}
00769 \textcolor{preprocessor}{#  elif EIGEN\_COMP\_MSVC}
00770 \textcolor{preprocessor}{#    if (EIGEN\_COMP\_MSVC > 1500) && EIGEN\_ARCH\_i386\_OR\_x86\_64}
00771 \textcolor{preprocessor}{#      define EIGEN\_CPUID(abcd,func,id) \_\_cpuidex((int*)abcd,func,id)}
00772 \textcolor{preprocessor}{#    endif}
00773 \textcolor{preprocessor}{#  endif}
00774 \textcolor{preprocessor}{#endif}
00775 
00776 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00777 
00778 \textcolor{preprocessor}{#ifdef EIGEN\_CPUID}
00779 
00780 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} cpuid\_is\_vendor(\textcolor{keywordtype}{int} abcd[4], \textcolor{keyword}{const} \textcolor{keywordtype}{int} vendor[3])
00781 \{
00782   \textcolor{keywordflow}{return} abcd[1]==vendor[0] && abcd[3]==vendor[1] && abcd[2]==vendor[2];
00783 \}
00784 
00785 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} queryCacheSizes\_intel\_direct(\textcolor{keywordtype}{int}& l1, \textcolor{keywordtype}{int}& l2, \textcolor{keywordtype}{int}& l3)
00786 \{
00787   \textcolor{keywordtype}{int} abcd[4];
00788   l1 = l2 = l3 = 0;
00789   \textcolor{keywordtype}{int} cache\_id = 0;
00790   \textcolor{keywordtype}{int} cache\_type = 0;
00791   \textcolor{keywordflow}{do} \{
00792     abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;
00793     EIGEN\_CPUID(abcd,0x4,cache\_id);
00794     cache\_type  = (abcd[0] & 0x0F) >> 0;
00795     \textcolor{keywordflow}{if}(cache\_type==1||cache\_type==3) \textcolor{comment}{// data or unified cache}
00796     \{
00797       \textcolor{keywordtype}{int} cache\_level = (abcd[0] & 0xE0) >> 5;  \textcolor{comment}{// A[7:5]}
00798       \textcolor{keywordtype}{int} ways        = (abcd[1] & 0xFFC00000) >> 22; \textcolor{comment}{// B[31:22]}
00799       \textcolor{keywordtype}{int} partitions  = (abcd[1] & 0x003FF000) >> 12; \textcolor{comment}{// B[21:12]}
00800       \textcolor{keywordtype}{int} line\_size   = (abcd[1] & 0x00000FFF) >>  0; \textcolor{comment}{// B[11:0]}
00801       \textcolor{keywordtype}{int} sets        = (abcd[2]);                    \textcolor{comment}{// C[31:0]}
00802 
00803       \textcolor{keywordtype}{int} cache\_size = (ways+1) * (partitions+1) * (line\_size+1) * (sets+1);
00804 
00805       \textcolor{keywordflow}{switch}(cache\_level)
00806       \{
00807         \textcolor{keywordflow}{case} 1: l1 = cache\_size; \textcolor{keywordflow}{break};
00808         \textcolor{keywordflow}{case} 2: l2 = cache\_size; \textcolor{keywordflow}{break};
00809         \textcolor{keywordflow}{case} 3: l3 = cache\_size; \textcolor{keywordflow}{break};
00810         \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
00811       \}
00812     \}
00813     cache\_id++;
00814   \} \textcolor{keywordflow}{while}(cache\_type>0 && cache\_id<16);
00815 \}
00816 
00817 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} queryCacheSizes\_intel\_codes(\textcolor{keywordtype}{int}& l1, \textcolor{keywordtype}{int}& l2, \textcolor{keywordtype}{int}& l3)
00818 \{
00819   \textcolor{keywordtype}{int} abcd[4];
00820   abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;
00821   l1 = l2 = l3 = 0;
00822   EIGEN\_CPUID(abcd,0x00000002,0);
00823   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} * bytes = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *\textcolor{keyword}{>}(abcd)+2;
00824   \textcolor{keywordtype}{bool} check\_for\_p2\_core2 = \textcolor{keyword}{false};
00825   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<14; ++i)
00826   \{
00827     \textcolor{keywordflow}{switch}(bytes[i])
00828     \{
00829       \textcolor{keywordflow}{case} 0x0A: l1 = 8; \textcolor{keywordflow}{break};   \textcolor{comment}{// 0Ah   data L1 cache, 8 KB, 2 ways, 32 byte lines}
00830       \textcolor{keywordflow}{case} 0x0C: l1 = 16; \textcolor{keywordflow}{break};  \textcolor{comment}{// 0Ch   data L1 cache, 16 KB, 4 ways, 32 byte lines}
00831       \textcolor{keywordflow}{case} 0x0E: l1 = 24; \textcolor{keywordflow}{break};  \textcolor{comment}{// 0Eh   data L1 cache, 24 KB, 6 ways, 64 byte lines}
00832       \textcolor{keywordflow}{case} 0x10: l1 = 16; \textcolor{keywordflow}{break};  \textcolor{comment}{// 10h   data L1 cache, 16 KB, 4 ways, 32 byte lines (IA-64)}
00833       \textcolor{keywordflow}{case} 0x15: l1 = 16; \textcolor{keywordflow}{break};  \textcolor{comment}{// 15h   code L1 cache, 16 KB, 4 ways, 32 byte lines (IA-64)}
00834       \textcolor{keywordflow}{case} 0x2C: l1 = 32; \textcolor{keywordflow}{break};  \textcolor{comment}{// 2Ch   data L1 cache, 32 KB, 8 ways, 64 byte lines}
00835       \textcolor{keywordflow}{case} 0x30: l1 = 32; \textcolor{keywordflow}{break};  \textcolor{comment}{// 30h   code L1 cache, 32 KB, 8 ways, 64 byte lines}
00836       \textcolor{keywordflow}{case} 0x60: l1 = 16; \textcolor{keywordflow}{break};  \textcolor{comment}{// 60h   data L1 cache, 16 KB, 8 ways, 64 byte lines, sectored}
00837       \textcolor{keywordflow}{case} 0x66: l1 = 8; \textcolor{keywordflow}{break};   \textcolor{comment}{// 66h   data L1 cache, 8 KB, 4 ways, 64 byte lines, sectored}
00838       \textcolor{keywordflow}{case} 0x67: l1 = 16; \textcolor{keywordflow}{break};  \textcolor{comment}{// 67h   data L1 cache, 16 KB, 4 ways, 64 byte lines, sectored}
00839       \textcolor{keywordflow}{case} 0x68: l1 = 32; \textcolor{keywordflow}{break};  \textcolor{comment}{// 68h   data L1 cache, 32 KB, 4 ways, 64 byte lines, sectored}
00840       \textcolor{keywordflow}{case} 0x1A: l2 = 96; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 96 KB, 6 ways, 64 byte lines (IA-64)}
00841       \textcolor{keywordflow}{case} 0x22: l3 = 512; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 512 KB, 4 ways (!), 64 byte lines,
       dual-sectored}
00842       \textcolor{keywordflow}{case} 0x23: l3 = 1024; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 1024 KB, 8 ways, 64 byte lines,
       dual-sectored}
00843       \textcolor{keywordflow}{case} 0x25: l3 = 2048; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 2048 KB, 8 ways, 64 byte lines,
       dual-sectored}
00844       \textcolor{keywordflow}{case} 0x29: l3 = 4096; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 4096 KB, 8 ways, 64 byte lines,
       dual-sectored}
00845       \textcolor{keywordflow}{case} 0x39: l2 = 128; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 128 KB, 4 ways, 64 byte lines, sectored}
00846       \textcolor{keywordflow}{case} 0x3A: l2 = 192; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 192 KB, 6 ways, 64 byte lines, sectored}
00847       \textcolor{keywordflow}{case} 0x3B: l2 = 128; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 128 KB, 2 ways, 64 byte lines, sectored}
00848       \textcolor{keywordflow}{case} 0x3C: l2 = 256; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 256 KB, 4 ways, 64 byte lines, sectored}
00849       \textcolor{keywordflow}{case} 0x3D: l2 = 384; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 384 KB, 6 ways, 64 byte lines, sectored}
00850       \textcolor{keywordflow}{case} 0x3E: l2 = 512; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 512 KB, 4 ways, 64 byte lines, sectored}
00851       \textcolor{keywordflow}{case} 0x40: l2 = 0; \textcolor{keywordflow}{break};   \textcolor{comment}{// no integrated L2 cache (P6 core) or L3 cache (P4 core)}
00852       \textcolor{keywordflow}{case} 0x41: l2 = 128; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 128 KB, 4 ways, 32 byte lines}
00853       \textcolor{keywordflow}{case} 0x42: l2 = 256; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 256 KB, 4 ways, 32 byte lines}
00854       \textcolor{keywordflow}{case} 0x43: l2 = 512; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 512 KB, 4 ways, 32 byte lines}
00855       \textcolor{keywordflow}{case} 0x44: l2 = 1024; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 1024 KB, 4 ways, 32 byte lines}
00856       \textcolor{keywordflow}{case} 0x45: l2 = 2048; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 2048 KB, 4 ways, 32 byte lines}
00857       \textcolor{keywordflow}{case} 0x46: l3 = 4096; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 4096 KB, 4 ways, 64 byte lines}
00858       \textcolor{keywordflow}{case} 0x47: l3 = 8192; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 8192 KB, 8 ways, 64 byte lines}
00859       \textcolor{keywordflow}{case} 0x48: l2 = 3072; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 3072 KB, 12 ways, 64 byte lines}
00860       \textcolor{keywordflow}{case} 0x49: \textcolor{keywordflow}{if}(l2!=0) l3 = 4096; \textcolor{keywordflow}{else} \{check\_for\_p2\_core2=\textcolor{keyword}{true}; l3 = l2 = 4096;\} \textcolor{keywordflow}{break};\textcolor{comment}{// code and
       data L3 cache, 4096 KB, 16 ways, 64 byte lines (P4) or L2 for core2}
00861       \textcolor{keywordflow}{case} 0x4A: l3 = 6144; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 6144 KB, 12 ways, 64 byte lines}
00862       \textcolor{keywordflow}{case} 0x4B: l3 = 8192; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 8192 KB, 16 ways, 64 byte lines}
00863       \textcolor{keywordflow}{case} 0x4C: l3 = 12288; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 12288 KB, 12 ways, 64 byte lines}
00864       \textcolor{keywordflow}{case} 0x4D: l3 = 16384; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 16384 KB, 16 ways, 64 byte lines}
00865       \textcolor{keywordflow}{case} 0x4E: l2 = 6144; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 6144 KB, 24 ways, 64 byte lines}
00866       \textcolor{keywordflow}{case} 0x78: l2 = 1024; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 1024 KB, 4 ways, 64 byte lines}
00867       \textcolor{keywordflow}{case} 0x79: l2 = 128; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 128 KB, 8 ways, 64 byte lines, dual-sectored}
00868       \textcolor{keywordflow}{case} 0x7A: l2 = 256; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 256 KB, 8 ways, 64 byte lines, dual-sectored}
00869       \textcolor{keywordflow}{case} 0x7B: l2 = 512; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 512 KB, 8 ways, 64 byte lines, dual-sectored}
00870       \textcolor{keywordflow}{case} 0x7C: l2 = 1024; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 1024 KB, 8 ways, 64 byte lines,
       dual-sectored}
00871       \textcolor{keywordflow}{case} 0x7D: l2 = 2048; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 2048 KB, 8 ways, 64 byte lines}
00872       \textcolor{keywordflow}{case} 0x7E: l2 = 256; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 256 KB, 8 ways, 128 byte lines, sect.
       (IA-64)}
00873       \textcolor{keywordflow}{case} 0x7F: l2 = 512; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 512 KB, 2 ways, 64 byte lines}
00874       \textcolor{keywordflow}{case} 0x80: l2 = 512; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 512 KB, 8 ways, 64 byte lines}
00875       \textcolor{keywordflow}{case} 0x81: l2 = 128; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 128 KB, 8 ways, 32 byte lines}
00876       \textcolor{keywordflow}{case} 0x82: l2 = 256; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 256 KB, 8 ways, 32 byte lines}
00877       \textcolor{keywordflow}{case} 0x83: l2 = 512; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 512 KB, 8 ways, 32 byte lines}
00878       \textcolor{keywordflow}{case} 0x84: l2 = 1024; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 1024 KB, 8 ways, 32 byte lines}
00879       \textcolor{keywordflow}{case} 0x85: l2 = 2048; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 2048 KB, 8 ways, 32 byte lines}
00880       \textcolor{keywordflow}{case} 0x86: l2 = 512; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 512 KB, 4 ways, 64 byte lines}
00881       \textcolor{keywordflow}{case} 0x87: l2 = 1024; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L2 cache, 1024 KB, 8 ways, 64 byte lines}
00882       \textcolor{keywordflow}{case} 0x88: l3 = 2048; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 2048 KB, 4 ways, 64 byte lines (IA-64)}
00883       \textcolor{keywordflow}{case} 0x89: l3 = 4096; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 4096 KB, 4 ways, 64 byte lines (IA-64)}
00884       \textcolor{keywordflow}{case} 0x8A: l3 = 8192; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 8192 KB, 4 ways, 64 byte lines (IA-64)}
00885       \textcolor{keywordflow}{case} 0x8D: l3 = 3072; \textcolor{keywordflow}{break};   \textcolor{comment}{// code and data L3 cache, 3072 KB, 12 ways, 128 byte lines (IA-64)}
00886 
00887       \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
00888     \}
00889   \}
00890   \textcolor{keywordflow}{if}(check\_for\_p2\_core2 && l2 == l3)
00891     l3 = 0;
00892   l1 *= 1024;
00893   l2 *= 1024;
00894   l3 *= 1024;
00895 \}
00896 
00897 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} queryCacheSizes\_intel(\textcolor{keywordtype}{int}& l1, \textcolor{keywordtype}{int}& l2, \textcolor{keywordtype}{int}& l3, \textcolor{keywordtype}{int} max\_std\_funcs)
00898 \{
00899   \textcolor{keywordflow}{if}(max\_std\_funcs>=4)
00900     queryCacheSizes\_intel\_direct(l1,l2,l3);
00901   \textcolor{keywordflow}{else}
00902     queryCacheSizes\_intel\_codes(l1,l2,l3);
00903 \}
00904 
00905 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} queryCacheSizes\_amd(\textcolor{keywordtype}{int}& l1, \textcolor{keywordtype}{int}& l2, \textcolor{keywordtype}{int}& l3)
00906 \{
00907   \textcolor{keywordtype}{int} abcd[4];
00908   abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;
00909   EIGEN\_CPUID(abcd,0x80000005,0);
00910   l1 = (abcd[2] >> 24) * 1024; \textcolor{comment}{// C[31:24] = L1 size in KB}
00911   abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;
00912   EIGEN\_CPUID(abcd,0x80000006,0);
00913   l2 = (abcd[2] >> 16) * 1024; \textcolor{comment}{// C[31;16] = l2 cache size in KB}
00914   l3 = ((abcd[3] & 0xFFFC000) >> 18) * 512 * 1024; \textcolor{comment}{// D[31;18] = l3 cache size in 512KB}
00915 \}
00916 \textcolor{preprocessor}{#endif}
00917 
00920 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} queryCacheSizes(\textcolor{keywordtype}{int}& l1, \textcolor{keywordtype}{int}& l2, \textcolor{keywordtype}{int}& l3)
00921 \{
00922 \textcolor{preprocessor}{  #ifdef EIGEN\_CPUID}
00923   \textcolor{keywordtype}{int} abcd[4];
00924   \textcolor{keyword}{const} \textcolor{keywordtype}{int} GenuineIntel[] = \{0x756e6547, 0x49656e69, 0x6c65746e\};
00925   \textcolor{keyword}{const} \textcolor{keywordtype}{int} AuthenticAMD[] = \{0x68747541, 0x69746e65, 0x444d4163\};
00926   \textcolor{keyword}{const} \textcolor{keywordtype}{int} AMDisbetter\_[] = \{0x69444d41, 0x74656273, 0x21726574\}; \textcolor{comment}{// "AMDisbetter!"}
00927 
00928   \textcolor{comment}{// identify the CPU vendor}
00929   EIGEN\_CPUID(abcd,0x0,0);
00930   \textcolor{keywordtype}{int} max\_std\_funcs = abcd[1];
00931   \textcolor{keywordflow}{if}(cpuid\_is\_vendor(abcd,GenuineIntel))
00932     queryCacheSizes\_intel(l1,l2,l3,max\_std\_funcs);
00933   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(cpuid\_is\_vendor(abcd,AuthenticAMD) || cpuid\_is\_vendor(abcd,AMDisbetter\_))
00934     queryCacheSizes\_amd(l1,l2,l3);
00935   \textcolor{keywordflow}{else}
00936     \textcolor{comment}{// by default let's use Intel's API}
00937     queryCacheSizes\_intel(l1,l2,l3,max\_std\_funcs);
00938 
00939   \textcolor{comment}{// here is the list of other vendors:}
00940 \textcolor{comment}{//   ||cpuid\_is\_vendor(abcd,"VIA VIA VIA ")}
00941 \textcolor{comment}{//   ||cpuid\_is\_vendor(abcd,"CyrixInstead")}
00942 \textcolor{comment}{//   ||cpuid\_is\_vendor(abcd,"CentaurHauls")}
00943 \textcolor{comment}{//   ||cpuid\_is\_vendor(abcd,"GenuineTMx86")}
00944 \textcolor{comment}{//   ||cpuid\_is\_vendor(abcd,"TransmetaCPU")}
00945 \textcolor{comment}{//   ||cpuid\_is\_vendor(abcd,"RiseRiseRise")}
00946 \textcolor{comment}{//   ||cpuid\_is\_vendor(abcd,"Geode by NSC")}
00947 \textcolor{comment}{//   ||cpuid\_is\_vendor(abcd,"SiS SiS SiS ")}
00948 \textcolor{comment}{//   ||cpuid\_is\_vendor(abcd,"UMC UMC UMC ")}
00949 \textcolor{comment}{//   ||cpuid\_is\_vendor(abcd,"NexGenDriven")}
00950 \textcolor{preprocessor}{  #else}
00951   l1 = l2 = l3 = -1;
00952 \textcolor{preprocessor}{  #endif}
00953 \}
00954 
00957 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} queryL1CacheSize()
00958 \{
00959   \textcolor{keywordtype}{int} l1(-1), l2, l3;
00960   queryCacheSizes(l1,l2,l3);
00961   \textcolor{keywordflow}{return} l1;
00962 \}
00963 
00966 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} queryTopLevelCacheSize()
00967 \{
00968   \textcolor{keywordtype}{int} l1, l2(-1), l3(-1);
00969   queryCacheSizes(l1,l2,l3);
00970   \textcolor{keywordflow}{return} (std::max)(l2,l3);
00971 \}
00972 
00973 \} \textcolor{comment}{// end namespace internal}
00974 
00975 \} \textcolor{comment}{// end namespace Eigen}
00976 
00977 \textcolor{preprocessor}{#endif // EIGEN\_MEMORY\_H}
\end{DoxyCode}
