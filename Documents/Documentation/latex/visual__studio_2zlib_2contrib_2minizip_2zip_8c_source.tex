\hypertarget{visual__studio_2zlib_2contrib_2minizip_2zip_8c_source}{}\section{visual\+\_\+studio/zlib/contrib/minizip/zip.c}
\label{visual__studio_2zlib_2contrib_2minizip_2zip_8c_source}\index{zip.\+c@{zip.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* zip.c -- IO on .zip files using zlib}
00002 \textcolor{comment}{   Version 1.1, February 14h, 2010}
00003 \textcolor{comment}{   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )}
00004 \textcolor{comment}{}
00005 \textcolor{comment}{         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )}
00006 \textcolor{comment}{}
00007 \textcolor{comment}{         Modifications for Zip64 support}
00008 \textcolor{comment}{         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )}
00009 \textcolor{comment}{}
00010 \textcolor{comment}{         For more info read MiniZip\_info.txt}
00011 \textcolor{comment}{}
00012 \textcolor{comment}{         Changes}
00013 \textcolor{comment}{   Oct-2009 - Mathias Svensson - Remove old C style function prototypes}
00014 \textcolor{comment}{   Oct-2009 - Mathias Svensson - Added Zip64 Support when creating new file archives}
00015 \textcolor{comment}{   Oct-2009 - Mathias Svensson - Did some code cleanup and refactoring to get better overview of some
       functions.}
00016 \textcolor{comment}{   Oct-2009 - Mathias Svensson - Added zipRemoveExtraInfoBlock to strip extra field data from its ZIP64
       data}
00017 \textcolor{comment}{                                 It is used when recreting zip archive with RAW when deleting items from a
       zip.}
00018 \textcolor{comment}{                                 ZIP64 data is automatically added to items that needs it, and existing
       ZIP64 data need to be removed.}
00019 \textcolor{comment}{   Oct-2009 - Mathias Svensson - Added support for BZIP2 as compression mode (bzip2 lib is required)}
00020 \textcolor{comment}{   Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{*/}
00023 
00024 
00025 \textcolor{preprocessor}{#include <stdio.h>}
00026 \textcolor{preprocessor}{#include <stdlib.h>}
00027 \textcolor{preprocessor}{#include <string.h>}
00028 \textcolor{preprocessor}{#include <time.h>}
00029 \textcolor{preprocessor}{#include "zlib.h"}
00030 \textcolor{preprocessor}{#include "zip.h"}
00031 
00032 \textcolor{preprocessor}{#ifdef STDC}
00033 \textcolor{preprocessor}{#  include <stddef.h>}
00034 \textcolor{preprocessor}{#  include <string.h>}
00035 \textcolor{preprocessor}{#  include <stdlib.h>}
00036 \textcolor{preprocessor}{#endif}
00037 \textcolor{preprocessor}{#ifdef NO\_ERRNO\_H}
00038     \textcolor{keyword}{extern} \textcolor{keywordtype}{int} errno;
00039 \textcolor{preprocessor}{#else}
00040 \textcolor{preprocessor}{#   include <errno.h>}
00041 \textcolor{preprocessor}{#endif}
00042 
00043 
00044 \textcolor{preprocessor}{#ifndef local}
00045 \textcolor{preprocessor}{#  define local static}
00046 \textcolor{preprocessor}{#endif}
00047 \textcolor{comment}{/* compile with -Dlocal if your debugger can't find static symbols */}
00048 
00049 \textcolor{preprocessor}{#ifndef VERSIONMADEBY}
00050 \textcolor{preprocessor}{# define VERSIONMADEBY   (0x0) }\textcolor{comment}{/* platform depedent */}\textcolor{preprocessor}{}
00051 \textcolor{preprocessor}{#endif}
00052 
00053 \textcolor{preprocessor}{#ifndef Z\_BUFSIZE}
00054 \textcolor{preprocessor}{#define Z\_BUFSIZE (64*1024) //(16384)}
00055 \textcolor{preprocessor}{#endif}
00056 
00057 \textcolor{preprocessor}{#ifndef Z\_MAXFILENAMEINZIP}
00058 \textcolor{preprocessor}{#define Z\_MAXFILENAMEINZIP (256)}
00059 \textcolor{preprocessor}{#endif}
00060 
00061 \textcolor{preprocessor}{#ifndef ALLOC}
00062 \textcolor{preprocessor}{# define ALLOC(size) (malloc(size))}
00063 \textcolor{preprocessor}{#endif}
00064 \textcolor{preprocessor}{#ifndef TRYFREE}
00065 \textcolor{preprocessor}{# define TRYFREE(p) \{if (p) free(p);\}}
00066 \textcolor{preprocessor}{#endif}
00067 
00068 \textcolor{comment}{/*}
00069 \textcolor{comment}{#define SIZECENTRALDIRITEM (0x2e)}
00070 \textcolor{comment}{#define SIZEZIPLOCALHEADER (0x1e)}
00071 \textcolor{comment}{*/}
00072 
00073 \textcolor{comment}{/* I've found an old Unix (a SunOS 4.1.3\_U1) without all SEEK\_* defined.... */}
00074 
00075 
00076 \textcolor{comment}{// NOT sure that this work on ALL platform}
00077 \textcolor{preprocessor}{#define MAKEULONG64(a, b) ((ZPOS64\_T)(((unsigned long)(a)) | ((ZPOS64\_T)((unsigned long)(b))) << 32))}
00078 
00079 \textcolor{preprocessor}{#ifndef SEEK\_CUR}
00080 \textcolor{preprocessor}{#define SEEK\_CUR    1}
00081 \textcolor{preprocessor}{#endif}
00082 
00083 \textcolor{preprocessor}{#ifndef SEEK\_END}
00084 \textcolor{preprocessor}{#define SEEK\_END    2}
00085 \textcolor{preprocessor}{#endif}
00086 
00087 \textcolor{preprocessor}{#ifndef SEEK\_SET}
00088 \textcolor{preprocessor}{#define SEEK\_SET    0}
00089 \textcolor{preprocessor}{#endif}
00090 
00091 \textcolor{preprocessor}{#ifndef DEF\_MEM\_LEVEL}
00092 \textcolor{preprocessor}{#if MAX\_MEM\_LEVEL >= 8}
00093 \textcolor{preprocessor}{#  define DEF\_MEM\_LEVEL 8}
00094 \textcolor{preprocessor}{#else}
00095 \textcolor{preprocessor}{#  define DEF\_MEM\_LEVEL  MAX\_MEM\_LEVEL}
00096 \textcolor{preprocessor}{#endif}
00097 \textcolor{preprocessor}{#endif}
00098 \textcolor{keyword}{const} \textcolor{keywordtype}{char} zip\_copyright[] =\textcolor{stringliteral}{" zip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll
      "};
00099 
00100 
00101 \textcolor{preprocessor}{#define SIZEDATA\_INDATABLOCK (4096-(4*4))}
00102 
00103 \textcolor{preprocessor}{#define LOCALHEADERMAGIC    (0x04034b50)}
00104 \textcolor{preprocessor}{#define CENTRALHEADERMAGIC  (0x02014b50)}
00105 \textcolor{preprocessor}{#define ENDHEADERMAGIC      (0x06054b50)}
00106 \textcolor{preprocessor}{#define ZIP64ENDHEADERMAGIC      (0x6064b50)}
00107 \textcolor{preprocessor}{#define ZIP64ENDLOCHEADERMAGIC   (0x7064b50)}
00108 
00109 \textcolor{preprocessor}{#define FLAG\_LOCALHEADER\_OFFSET (0x06)}
00110 \textcolor{preprocessor}{#define CRC\_LOCALHEADER\_OFFSET  (0x0e)}
00111 
00112 \textcolor{preprocessor}{#define SIZECENTRALHEADER (0x2e) }\textcolor{comment}{/* 46 */}\textcolor{preprocessor}{}
00113 
\Hypertarget{visual__studio_2zlib_2contrib_2minizip_2zip_8c_source_l00114}\hyperlink{structlinkedlist__datablock__internal__s}{00114} \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal\_s}
00115 \{
00116   \textcolor{keyword}{struct }\hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal\_s}* next\_datablock;
00117   uLong  avail\_in\_this\_block;
00118   uLong  filled\_in\_this\_block;
00119   uLong  unused; \textcolor{comment}{/* for future use and alignment */}
00120   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} data[SIZEDATA\_INDATABLOCK];
00121 \} \hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal};
00122 
\Hypertarget{visual__studio_2zlib_2contrib_2minizip_2zip_8c_source_l00123}\hyperlink{structlinkedlist__data__s}{00123} \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structlinkedlist__data__s}{linkedlist\_data\_s}
00124 \{
00125     \hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal}* first\_block;
00126     \hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal}* last\_block;
00127 \} \hyperlink{structlinkedlist__data__s}{linkedlist\_data};
00128 
00129 
\Hypertarget{visual__studio_2zlib_2contrib_2minizip_2zip_8c_source_l00130}\hyperlink{structcurfile64__info}{00130} \textcolor{keyword}{typedef} \textcolor{keyword}{struct}
00131 \{
00132     \hyperlink{structz__stream__s}{z\_stream} stream;            \textcolor{comment}{/* zLib stream structure for inflate */}
00133 \textcolor{preprocessor}{#ifdef HAVE\_BZIP2}
00134     bz\_stream bstream;          \textcolor{comment}{/* bzLib stream structure for bziped */}
00135 \textcolor{preprocessor}{#endif}
00136 
00137     \textcolor{keywordtype}{int}  stream\_initialised;    \textcolor{comment}{/* 1 is stream is initialised */}
00138     uInt pos\_in\_buffered\_data;  \textcolor{comment}{/* last written byte in buffered\_data */}
00139 
00140     ZPOS64\_T pos\_local\_header;     \textcolor{comment}{/* offset of the local header of the file}
00141 \textcolor{comment}{                                     currenty writing */}
00142     \textcolor{keywordtype}{char}* central\_header;       \textcolor{comment}{/* central header data for the current file */}
00143     uLong size\_centralExtra;
00144     uLong size\_centralheader;   \textcolor{comment}{/* size of the central header for cur file */}
00145     uLong size\_centralExtraFree; \textcolor{comment}{/* Extra bytes allocated to the centralheader but that are not used */}
00146     uLong flag;                 \textcolor{comment}{/* flag of the file currently writing */}
00147 
00148     \textcolor{keywordtype}{int}  method;                \textcolor{comment}{/* compression method of file currenty wr.*/}
00149     \textcolor{keywordtype}{int}  raw;                   \textcolor{comment}{/* 1 for directly writing raw data */}
00150     Byte buffered\_data[Z\_BUFSIZE];\textcolor{comment}{/* buffer contain compressed data to be writ*/}
00151     uLong dosDate;
00152     uLong crc32;
00153     \textcolor{keywordtype}{int}  encrypt;
00154     \textcolor{keywordtype}{int}  zip64;               \textcolor{comment}{/* Add ZIP64 extened information in the extra field */}
00155     ZPOS64\_T pos\_zip64extrainfo;
00156     ZPOS64\_T totalCompressedData;
00157     ZPOS64\_T totalUncompressedData;
00158 \textcolor{preprocessor}{#ifndef NOCRYPT}
00159     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} keys[3];     \textcolor{comment}{/* keys defining the pseudo-random sequence */}
00160     \textcolor{keyword}{const} z\_crc\_t* pcrc\_32\_tab;
00161     \textcolor{keywordtype}{int} crypt\_header\_size;
00162 \textcolor{preprocessor}{#endif}
00163 \} \hyperlink{structcurfile64__info}{curfile64\_info};
00164 
\Hypertarget{visual__studio_2zlib_2contrib_2minizip_2zip_8c_source_l00165}\hyperlink{structzip64__internal}{00165} \textcolor{keyword}{typedef} \textcolor{keyword}{struct}
00166 \{
00167     \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def} z\_filefunc;
00168     voidpf filestream;        \textcolor{comment}{/* io structore of the zipfile */}
00169     \hyperlink{structlinkedlist__data__s}{linkedlist\_data} central\_dir;\textcolor{comment}{/* datablock with central dir in construction*/}
00170     \textcolor{keywordtype}{int}  in\_opened\_file\_inzip;  \textcolor{comment}{/* 1 if a file in the zip is currently writ.*/}
00171     \hyperlink{structcurfile64__info}{curfile64\_info} ci;            \textcolor{comment}{/* info on the file curretly writing */}
00172 
00173     ZPOS64\_T begin\_pos;            \textcolor{comment}{/* position of the beginning of the zipfile */}
00174     ZPOS64\_T add\_position\_when\_writing\_offset;
00175     ZPOS64\_T number\_entry;
00176 
00177 \textcolor{preprocessor}{#ifndef NO\_ADDFILEINEXISTINGZIP}
00178     \textcolor{keywordtype}{char} *globalcomment;
00179 \textcolor{preprocessor}{#endif}
00180 
00181 \} \hyperlink{structzip64__internal}{zip64\_internal};
00182 
00183 
00184 \textcolor{preprocessor}{#ifndef NOCRYPT}
00185 \textcolor{preprocessor}{#define INCLUDECRYPTINGCODE\_IFCRYPTALLOWED}
00186 \textcolor{preprocessor}{#include "crypt.h"}
00187 \textcolor{preprocessor}{#endif}
00188 
00189 local \hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal}* allocate\_new\_datablock()
00190 \{
00191     \hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal}* ldi;
00192     ldi = (\hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal}*)
00193                  ALLOC(\textcolor{keyword}{sizeof}(\hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal}));
00194     \textcolor{keywordflow}{if} (ldi!=NULL)
00195     \{
00196         ldi->next\_datablock = NULL ;
00197         ldi->filled\_in\_this\_block = 0 ;
00198         ldi->avail\_in\_this\_block = SIZEDATA\_INDATABLOCK ;
00199     \}
00200     \textcolor{keywordflow}{return} ldi;
00201 \}
00202 
00203 local \textcolor{keywordtype}{void} free\_datablock(\hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal}* ldi)
00204 \{
00205     \textcolor{keywordflow}{while} (ldi!=NULL)
00206     \{
00207         \hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal}* ldinext = ldi->next\_datablock;
00208         TRYFREE(ldi);
00209         ldi = ldinext;
00210     \}
00211 \}
00212 
00213 local \textcolor{keywordtype}{void} init\_linkedlist(\hyperlink{structlinkedlist__data__s}{linkedlist\_data}* ll)
00214 \{
00215     ll->first\_block = ll->last\_block = NULL;
00216 \}
00217 
00218 local \textcolor{keywordtype}{void} free\_linkedlist(\hyperlink{structlinkedlist__data__s}{linkedlist\_data}* ll)
00219 \{
00220     free\_datablock(ll->first\_block);
00221     ll->first\_block = ll->last\_block = NULL;
00222 \}
00223 
00224 
00225 local \textcolor{keywordtype}{int} add\_data\_in\_datablock(\hyperlink{structlinkedlist__data__s}{linkedlist\_data}* ll, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* buf, uLong len)
00226 \{
00227     \hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal}* ldi;
00228     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* from\_copy;
00229 
00230     \textcolor{keywordflow}{if} (ll==NULL)
00231         \textcolor{keywordflow}{return} ZIP\_INTERNALERROR;
00232 
00233     \textcolor{keywordflow}{if} (ll->last\_block == NULL)
00234     \{
00235         ll->first\_block = ll->last\_block = allocate\_new\_datablock();
00236         \textcolor{keywordflow}{if} (ll->first\_block == NULL)
00237             \textcolor{keywordflow}{return} ZIP\_INTERNALERROR;
00238     \}
00239 
00240     ldi = ll->last\_block;
00241     from\_copy = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)buf;
00242 
00243     \textcolor{keywordflow}{while} (len>0)
00244     \{
00245         uInt copy\_this;
00246         uInt i;
00247         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* to\_copy;
00248 
00249         \textcolor{keywordflow}{if} (ldi->avail\_in\_this\_block==0)
00250         \{
00251             ldi->next\_datablock = allocate\_new\_datablock();
00252             \textcolor{keywordflow}{if} (ldi->next\_datablock == NULL)
00253                 \textcolor{keywordflow}{return} ZIP\_INTERNALERROR;
00254             ldi = ldi->next\_datablock ;
00255             ll->last\_block = ldi;
00256         \}
00257 
00258         \textcolor{keywordflow}{if} (ldi->avail\_in\_this\_block < len)
00259             copy\_this = (uInt)ldi->avail\_in\_this\_block;
00260         \textcolor{keywordflow}{else}
00261             copy\_this = (uInt)len;
00262 
00263         to\_copy = &(ldi->data[ldi->filled\_in\_this\_block]);
00264 
00265         \textcolor{keywordflow}{for} (i=0;i<copy\_this;i++)
00266             *(to\_copy+i)=*(from\_copy+i);
00267 
00268         ldi->filled\_in\_this\_block += copy\_this;
00269         ldi->avail\_in\_this\_block -= copy\_this;
00270         from\_copy += copy\_this ;
00271         len -= copy\_this;
00272     \}
00273     \textcolor{keywordflow}{return} ZIP\_OK;
00274 \}
00275 
00276 
00277 
00278 \textcolor{comment}{/****************************************************************************/}
00279 
00280 \textcolor{preprocessor}{#ifndef NO\_ADDFILEINEXISTINGZIP}
00281 \textcolor{comment}{/* ===========================================================================}
00282 \textcolor{comment}{   Inputs a long in LSB order to the given file}
00283 \textcolor{comment}{   nbByte == 1, 2 ,4 or 8 (byte, short or long, ZPOS64\_T)}
00284 \textcolor{comment}{*/}
00285 
00286 local \textcolor{keywordtype}{int} zip64local\_putValue OF((\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* pzlib\_filefunc\_def, 
      voidpf filestream, ZPOS64\_T x, \textcolor{keywordtype}{int} nbByte));
00287 local \textcolor{keywordtype}{int} zip64local\_putValue (\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* pzlib\_filefunc\_def, 
      voidpf filestream, ZPOS64\_T x, \textcolor{keywordtype}{int} nbByte)
00288 \{
00289     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[8];
00290     \textcolor{keywordtype}{int} n;
00291     \textcolor{keywordflow}{for} (n = 0; n < nbByte; n++)
00292     \{
00293         buf[n] = (\textcolor{keywordtype}{unsigned} char)(x & 0xff);
00294         x >>= 8;
00295     \}
00296     \textcolor{keywordflow}{if} (x != 0)
00297       \{     \textcolor{comment}{/* data overflow - hack for ZIP64 (X Roche) */}
00298       \textcolor{keywordflow}{for} (n = 0; n < nbByte; n++)
00299         \{
00300           buf[n] = 0xff;
00301         \}
00302       \}
00303 
00304     \textcolor{keywordflow}{if} (ZWRITE64(*pzlib\_filefunc\_def,filestream,buf,nbByte)!=(uLong)nbByte)
00305         \textcolor{keywordflow}{return} ZIP\_ERRNO;
00306     \textcolor{keywordflow}{else}
00307         \textcolor{keywordflow}{return} ZIP\_OK;
00308 \}
00309 
00310 local \textcolor{keywordtype}{void} zip64local\_putValue\_inmemory OF((\textcolor{keywordtype}{void}* dest, ZPOS64\_T x, \textcolor{keywordtype}{int} nbByte));
00311 local \textcolor{keywordtype}{void} zip64local\_putValue\_inmemory (\textcolor{keywordtype}{void}* dest, ZPOS64\_T x, \textcolor{keywordtype}{int} nbByte)
00312 \{
00313     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* buf=(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)dest;
00314     \textcolor{keywordtype}{int} n;
00315     \textcolor{keywordflow}{for} (n = 0; n < nbByte; n++) \{
00316         buf[n] = (\textcolor{keywordtype}{unsigned} char)(x & 0xff);
00317         x >>= 8;
00318     \}
00319 
00320     \textcolor{keywordflow}{if} (x != 0)
00321     \{     \textcolor{comment}{/* data overflow - hack for ZIP64 */}
00322        \textcolor{keywordflow}{for} (n = 0; n < nbByte; n++)
00323        \{
00324           buf[n] = 0xff;
00325        \}
00326     \}
00327 \}
00328 
00329 \textcolor{comment}{/****************************************************************************/}
00330 
00331 
00332 local uLong zip64local\_TmzDateToDosDate(\textcolor{keyword}{const} \hyperlink{structtm__zip__s}{tm\_zip}* ptm)
00333 \{
00334     uLong year = (uLong)ptm->tm\_year;
00335     if (year>=1980)
00336         year-=1980;
00337     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (year>=80)
00338         year-=80;
00339     \textcolor{keywordflow}{return}
00340       (uLong) (((ptm->tm\_mday) + (32 * (ptm->tm\_mon+1)) + (512 * year)) << 16) |
00341         ((ptm->tm\_sec/2) + (32* ptm->tm\_min) + (2048 * (uLong)ptm->tm\_hour));
00342 \}
00343 
00344 
00345 \textcolor{comment}{/****************************************************************************/}
00346 
00347 local \textcolor{keywordtype}{int} zip64local\_getByte OF((\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* pzlib\_filefunc\_def, 
      voidpf filestream, \textcolor{keywordtype}{int} *pi));
00348 
00349 local \textcolor{keywordtype}{int} zip64local\_getByte(\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* pzlib\_filefunc\_def,voidpf 
      filestream,\textcolor{keywordtype}{int}* pi)
00350 \{
00351     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c;
00352     \textcolor{keywordtype}{int} err = (int)ZREAD64(*pzlib\_filefunc\_def,filestream,&c,1);
00353     \textcolor{keywordflow}{if} (err==1)
00354     \{
00355         *pi = (int)c;
00356         \textcolor{keywordflow}{return} ZIP\_OK;
00357     \}
00358     \textcolor{keywordflow}{else}
00359     \{
00360         \textcolor{keywordflow}{if} (ZERROR64(*pzlib\_filefunc\_def,filestream))
00361             \textcolor{keywordflow}{return} ZIP\_ERRNO;
00362         \textcolor{keywordflow}{else}
00363             \textcolor{keywordflow}{return} ZIP\_EOF;
00364     \}
00365 \}
00366 
00367 
00368 \textcolor{comment}{/* ===========================================================================}
00369 \textcolor{comment}{   Reads a long in LSB order from the given gz\_stream. Sets}
00370 \textcolor{comment}{*/}
00371 local \textcolor{keywordtype}{int} zip64local\_getShort OF((\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* pzlib\_filefunc\_def, 
      voidpf filestream, uLong *pX));
00372 
00373 local \textcolor{keywordtype}{int} zip64local\_getShort (\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* pzlib\_filefunc\_def, 
      voidpf filestream, uLong* pX)
00374 \{
00375     uLong x ;
00376     \textcolor{keywordtype}{int} i = 0;
00377     \textcolor{keywordtype}{int} err;
00378 
00379     err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00380     x = (uLong)i;
00381 
00382     \textcolor{keywordflow}{if} (err==ZIP\_OK)
00383         err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00384     x += ((uLong)i)<<8;
00385 
00386     \textcolor{keywordflow}{if} (err==ZIP\_OK)
00387         *pX = x;
00388     \textcolor{keywordflow}{else}
00389         *pX = 0;
00390     \textcolor{keywordflow}{return} err;
00391 \}
00392 
00393 local \textcolor{keywordtype}{int} zip64local\_getLong OF((\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* pzlib\_filefunc\_def, 
      voidpf filestream, uLong *pX));
00394 
00395 local \textcolor{keywordtype}{int} zip64local\_getLong (\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* pzlib\_filefunc\_def, 
      voidpf filestream, uLong* pX)
00396 \{
00397     uLong x ;
00398     \textcolor{keywordtype}{int} i = 0;
00399     \textcolor{keywordtype}{int} err;
00400 
00401     err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00402     x = (uLong)i;
00403 
00404     \textcolor{keywordflow}{if} (err==ZIP\_OK)
00405         err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00406     x += ((uLong)i)<<8;
00407 
00408     \textcolor{keywordflow}{if} (err==ZIP\_OK)
00409         err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00410     x += ((uLong)i)<<16;
00411 
00412     \textcolor{keywordflow}{if} (err==ZIP\_OK)
00413         err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00414     x += ((uLong)i)<<24;
00415 
00416     \textcolor{keywordflow}{if} (err==ZIP\_OK)
00417         *pX = x;
00418     \textcolor{keywordflow}{else}
00419         *pX = 0;
00420     \textcolor{keywordflow}{return} err;
00421 \}
00422 
00423 local \textcolor{keywordtype}{int} zip64local\_getLong64 OF((\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* pzlib\_filefunc\_def, 
      voidpf filestream, ZPOS64\_T *pX));
00424 
00425 
00426 local \textcolor{keywordtype}{int} zip64local\_getLong64 (\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* pzlib\_filefunc\_def, 
      voidpf filestream, ZPOS64\_T *pX)
00427 \{
00428   ZPOS64\_T x;
00429   \textcolor{keywordtype}{int} i = 0;
00430   \textcolor{keywordtype}{int} err;
00431 
00432   err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00433   x = (ZPOS64\_T)i;
00434 
00435   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00436     err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00437   x += ((ZPOS64\_T)i)<<8;
00438 
00439   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00440     err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00441   x += ((ZPOS64\_T)i)<<16;
00442 
00443   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00444     err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00445   x += ((ZPOS64\_T)i)<<24;
00446 
00447   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00448     err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00449   x += ((ZPOS64\_T)i)<<32;
00450 
00451   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00452     err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00453   x += ((ZPOS64\_T)i)<<40;
00454 
00455   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00456     err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00457   x += ((ZPOS64\_T)i)<<48;
00458 
00459   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00460     err = zip64local\_getByte(pzlib\_filefunc\_def,filestream,&i);
00461   x += ((ZPOS64\_T)i)<<56;
00462 
00463   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00464     *pX = x;
00465   \textcolor{keywordflow}{else}
00466     *pX = 0;
00467 
00468   \textcolor{keywordflow}{return} err;
00469 \}
00470 
00471 \textcolor{preprocessor}{#ifndef BUFREADCOMMENT}
00472 \textcolor{preprocessor}{#define BUFREADCOMMENT (0x400)}
00473 \textcolor{preprocessor}{#endif}
00474 \textcolor{comment}{/*}
00475 \textcolor{comment}{  Locate the Central directory of a zipfile (at the end, just before}
00476 \textcolor{comment}{    the global comment)}
00477 \textcolor{comment}{*/}
00478 local ZPOS64\_T zip64local\_SearchCentralDir OF((\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* 
      pzlib\_filefunc\_def, voidpf filestream));
00479 
00480 local ZPOS64\_T zip64local\_SearchCentralDir(\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* 
      pzlib\_filefunc\_def, voidpf filestream)
00481 \{
00482   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* buf;
00483   ZPOS64\_T uSizeFile;
00484   ZPOS64\_T uBackRead;
00485   ZPOS64\_T uMaxBack=0xffff; \textcolor{comment}{/* maximum size of global comment */}
00486   ZPOS64\_T uPosFound=0;
00487 
00488   \textcolor{keywordflow}{if} (ZSEEK64(*pzlib\_filefunc\_def,filestream,0,ZLIB\_FILEFUNC\_SEEK\_END) != 0)
00489     \textcolor{keywordflow}{return} 0;
00490 
00491 
00492   uSizeFile = ZTELL64(*pzlib\_filefunc\_def,filestream);
00493 
00494   \textcolor{keywordflow}{if} (uMaxBack>uSizeFile)
00495     uMaxBack = uSizeFile;
00496 
00497   buf = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)ALLOC(BUFREADCOMMENT+4);
00498   \textcolor{keywordflow}{if} (buf==NULL)
00499     \textcolor{keywordflow}{return} 0;
00500 
00501   uBackRead = 4;
00502   \textcolor{keywordflow}{while} (uBackRead<uMaxBack)
00503   \{
00504     uLong uReadSize;
00505     ZPOS64\_T uReadPos ;
00506     \textcolor{keywordtype}{int} i;
00507     \textcolor{keywordflow}{if} (uBackRead+BUFREADCOMMENT>uMaxBack)
00508       uBackRead = uMaxBack;
00509     \textcolor{keywordflow}{else}
00510       uBackRead+=BUFREADCOMMENT;
00511     uReadPos = uSizeFile-uBackRead ;
00512 
00513     uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
00514       (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
00515     \textcolor{keywordflow}{if} (ZSEEK64(*pzlib\_filefunc\_def,filestream,uReadPos,ZLIB\_FILEFUNC\_SEEK\_SET)!=0)
00516       \textcolor{keywordflow}{break};
00517 
00518     \textcolor{keywordflow}{if} (ZREAD64(*pzlib\_filefunc\_def,filestream,buf,uReadSize)!=uReadSize)
00519       \textcolor{keywordflow}{break};
00520 
00521     \textcolor{keywordflow}{for} (i=(\textcolor{keywordtype}{int})uReadSize-3; (i--)>0;)
00522       \textcolor{keywordflow}{if} (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
00523         ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
00524       \{
00525         uPosFound = uReadPos+i;
00526         \textcolor{keywordflow}{break};
00527       \}
00528 
00529       \textcolor{keywordflow}{if} (uPosFound!=0)
00530         \textcolor{keywordflow}{break};
00531   \}
00532   TRYFREE(buf);
00533   \textcolor{keywordflow}{return} uPosFound;
00534 \}
00535 
00536 \textcolor{comment}{/*}
00537 \textcolor{comment}{Locate the End of Zip64 Central directory locator and from there find the CD of a zipfile (at the end, just
       before}
00538 \textcolor{comment}{the global comment)}
00539 \textcolor{comment}{*/}
00540 local ZPOS64\_T zip64local\_SearchCentralDir64 OF((\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* 
      pzlib\_filefunc\_def, voidpf filestream));
00541 
00542 local ZPOS64\_T zip64local\_SearchCentralDir64(\textcolor{keyword}{const} \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* 
      pzlib\_filefunc\_def, voidpf filestream)
00543 \{
00544   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* buf;
00545   ZPOS64\_T uSizeFile;
00546   ZPOS64\_T uBackRead;
00547   ZPOS64\_T uMaxBack=0xffff; \textcolor{comment}{/* maximum size of global comment */}
00548   ZPOS64\_T uPosFound=0;
00549   uLong uL;
00550   ZPOS64\_T relativeOffset;
00551 
00552   \textcolor{keywordflow}{if} (ZSEEK64(*pzlib\_filefunc\_def,filestream,0,ZLIB\_FILEFUNC\_SEEK\_END) != 0)
00553     \textcolor{keywordflow}{return} 0;
00554 
00555   uSizeFile = ZTELL64(*pzlib\_filefunc\_def,filestream);
00556 
00557   \textcolor{keywordflow}{if} (uMaxBack>uSizeFile)
00558     uMaxBack = uSizeFile;
00559 
00560   buf = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)ALLOC(BUFREADCOMMENT+4);
00561   \textcolor{keywordflow}{if} (buf==NULL)
00562     \textcolor{keywordflow}{return} 0;
00563 
00564   uBackRead = 4;
00565   \textcolor{keywordflow}{while} (uBackRead<uMaxBack)
00566   \{
00567     uLong uReadSize;
00568     ZPOS64\_T uReadPos;
00569     \textcolor{keywordtype}{int} i;
00570     \textcolor{keywordflow}{if} (uBackRead+BUFREADCOMMENT>uMaxBack)
00571       uBackRead = uMaxBack;
00572     \textcolor{keywordflow}{else}
00573       uBackRead+=BUFREADCOMMENT;
00574     uReadPos = uSizeFile-uBackRead ;
00575 
00576     uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
00577       (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
00578     \textcolor{keywordflow}{if} (ZSEEK64(*pzlib\_filefunc\_def,filestream,uReadPos,ZLIB\_FILEFUNC\_SEEK\_SET)!=0)
00579       \textcolor{keywordflow}{break};
00580 
00581     \textcolor{keywordflow}{if} (ZREAD64(*pzlib\_filefunc\_def,filestream,buf,uReadSize)!=uReadSize)
00582       \textcolor{keywordflow}{break};
00583 
00584     \textcolor{keywordflow}{for} (i=(\textcolor{keywordtype}{int})uReadSize-3; (i--)>0;)
00585     \{
00586       \textcolor{comment}{// Signature "0x07064b50" Zip64 end of central directory locater}
00587       \textcolor{keywordflow}{if} (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))
00588       \{
00589         uPosFound = uReadPos+i;
00590         \textcolor{keywordflow}{break};
00591       \}
00592     \}
00593 
00594       \textcolor{keywordflow}{if} (uPosFound!=0)
00595         \textcolor{keywordflow}{break};
00596   \}
00597 
00598   TRYFREE(buf);
00599   \textcolor{keywordflow}{if} (uPosFound == 0)
00600     \textcolor{keywordflow}{return} 0;
00601 
00602   \textcolor{comment}{/* Zip64 end of central directory locator */}
00603   \textcolor{keywordflow}{if} (ZSEEK64(*pzlib\_filefunc\_def,filestream, uPosFound,ZLIB\_FILEFUNC\_SEEK\_SET)!=0)
00604     \textcolor{keywordflow}{return} 0;
00605 
00606   \textcolor{comment}{/* the signature, already checked */}
00607   \textcolor{keywordflow}{if} (zip64local\_getLong(pzlib\_filefunc\_def,filestream,&uL)!=ZIP\_OK)
00608     \textcolor{keywordflow}{return} 0;
00609 
00610   \textcolor{comment}{/* number of the disk with the start of the zip64 end of  central directory */}
00611   \textcolor{keywordflow}{if} (zip64local\_getLong(pzlib\_filefunc\_def,filestream,&uL)!=ZIP\_OK)
00612     \textcolor{keywordflow}{return} 0;
00613   \textcolor{keywordflow}{if} (uL != 0)
00614     \textcolor{keywordflow}{return} 0;
00615 
00616   \textcolor{comment}{/* relative offset of the zip64 end of central directory record */}
00617   \textcolor{keywordflow}{if} (zip64local\_getLong64(pzlib\_filefunc\_def,filestream,&relativeOffset)!=ZIP\_OK)
00618     \textcolor{keywordflow}{return} 0;
00619 
00620   \textcolor{comment}{/* total number of disks */}
00621   \textcolor{keywordflow}{if} (zip64local\_getLong(pzlib\_filefunc\_def,filestream,&uL)!=ZIP\_OK)
00622     \textcolor{keywordflow}{return} 0;
00623   \textcolor{keywordflow}{if} (uL != 1)
00624     \textcolor{keywordflow}{return} 0;
00625 
00626   \textcolor{comment}{/* Goto Zip64 end of central directory record */}
00627   \textcolor{keywordflow}{if} (ZSEEK64(*pzlib\_filefunc\_def,filestream, relativeOffset,ZLIB\_FILEFUNC\_SEEK\_SET)!=0)
00628     \textcolor{keywordflow}{return} 0;
00629 
00630   \textcolor{comment}{/* the signature */}
00631   \textcolor{keywordflow}{if} (zip64local\_getLong(pzlib\_filefunc\_def,filestream,&uL)!=ZIP\_OK)
00632     \textcolor{keywordflow}{return} 0;
00633 
00634   \textcolor{keywordflow}{if} (uL != 0x06064b50) \textcolor{comment}{// signature of 'Zip64 end of central directory'}
00635     \textcolor{keywordflow}{return} 0;
00636 
00637   \textcolor{keywordflow}{return} relativeOffset;
00638 \}
00639 
00640 \textcolor{keywordtype}{int} LoadCentralDirectoryRecord(\hyperlink{structzip64__internal}{zip64\_internal}* pziinit)
00641 \{
00642   \textcolor{keywordtype}{int} err=ZIP\_OK;
00643   ZPOS64\_T byte\_before\_the\_zipfile;\textcolor{comment}{/* byte before the zipfile, (>0 for sfx)*/}
00644 
00645   ZPOS64\_T size\_central\_dir;     \textcolor{comment}{/* size of the central directory  */}
00646   ZPOS64\_T offset\_central\_dir;   \textcolor{comment}{/* offset of start of central directory */}
00647   ZPOS64\_T central\_pos;
00648   uLong uL;
00649 
00650   uLong number\_disk;          \textcolor{comment}{/* number of the current dist, used for}
00651 \textcolor{comment}{                              spaning ZIP, unsupported, always 0*/}
00652   uLong number\_disk\_with\_CD;  \textcolor{comment}{/* number the the disk with central dir, used}
00653 \textcolor{comment}{                              for spaning ZIP, unsupported, always 0*/}
00654   ZPOS64\_T number\_entry;
00655   ZPOS64\_T number\_entry\_CD;      \textcolor{comment}{/* total number of entries in}
00656 \textcolor{comment}{                                the central dir}
00657 \textcolor{comment}{                                (same than number\_entry on nospan) */}
00658   uLong VersionMadeBy;
00659   uLong VersionNeeded;
00660   uLong size\_comment;
00661 
00662   \textcolor{keywordtype}{int} hasZIP64Record = 0;
00663 
00664   \textcolor{comment}{// check first if we find a ZIP64 record}
00665   central\_pos = zip64local\_SearchCentralDir64(&pziinit->z\_filefunc,pziinit->filestream);
00666   \textcolor{keywordflow}{if}(central\_pos > 0)
00667   \{
00668     hasZIP64Record = 1;
00669   \}
00670   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(central\_pos == 0)
00671   \{
00672     central\_pos = zip64local\_SearchCentralDir(&pziinit->z\_filefunc,pziinit->filestream);
00673   \}
00674 
00675 \textcolor{comment}{/* disable to allow appending to empty ZIP archive}
00676 \textcolor{comment}{        if (central\_pos==0)}
00677 \textcolor{comment}{            err=ZIP\_ERRNO;}
00678 \textcolor{comment}{*/}
00679 
00680   \textcolor{keywordflow}{if}(hasZIP64Record)
00681   \{
00682     ZPOS64\_T sizeEndOfCentralDirectory;
00683     \textcolor{keywordflow}{if} (ZSEEK64(pziinit->z\_filefunc, pziinit->filestream, central\_pos, ZLIB\_FILEFUNC\_SEEK\_SET) != 0)
00684       err=ZIP\_ERRNO;
00685 
00686     \textcolor{comment}{/* the signature, already checked */}
00687     \textcolor{keywordflow}{if} (zip64local\_getLong(&pziinit->z\_filefunc, pziinit->filestream,&uL)!=ZIP\_OK)
00688       err=ZIP\_ERRNO;
00689 
00690     \textcolor{comment}{/* size of zip64 end of central directory record */}
00691     \textcolor{keywordflow}{if} (zip64local\_getLong64(&pziinit->z\_filefunc, pziinit->filestream, &sizeEndOfCentralDirectory)!=ZIP\_OK
      )
00692       err=ZIP\_ERRNO;
00693 
00694     \textcolor{comment}{/* version made by */}
00695     \textcolor{keywordflow}{if} (zip64local\_getShort(&pziinit->z\_filefunc, pziinit->filestream, &VersionMadeBy)!=ZIP\_OK)
00696       err=ZIP\_ERRNO;
00697 
00698     \textcolor{comment}{/* version needed to extract */}
00699     \textcolor{keywordflow}{if} (zip64local\_getShort(&pziinit->z\_filefunc, pziinit->filestream, &VersionNeeded)!=ZIP\_OK)
00700       err=ZIP\_ERRNO;
00701 
00702     \textcolor{comment}{/* number of this disk */}
00703     \textcolor{keywordflow}{if} (zip64local\_getLong(&pziinit->z\_filefunc, pziinit->filestream,&number\_disk)!=ZIP\_OK)
00704       err=ZIP\_ERRNO;
00705 
00706     \textcolor{comment}{/* number of the disk with the start of the central directory */}
00707     \textcolor{keywordflow}{if} (zip64local\_getLong(&pziinit->z\_filefunc, pziinit->filestream,&number\_disk\_with\_CD)!=ZIP\_OK)
00708       err=ZIP\_ERRNO;
00709 
00710     \textcolor{comment}{/* total number of entries in the central directory on this disk */}
00711     \textcolor{keywordflow}{if} (zip64local\_getLong64(&pziinit->z\_filefunc, pziinit->filestream, &number\_entry)!=ZIP\_OK)
00712       err=ZIP\_ERRNO;
00713 
00714     \textcolor{comment}{/* total number of entries in the central directory */}
00715     \textcolor{keywordflow}{if} (zip64local\_getLong64(&pziinit->z\_filefunc, pziinit->filestream,&number\_entry\_CD)!=ZIP\_OK)
00716       err=ZIP\_ERRNO;
00717 
00718     \textcolor{keywordflow}{if} ((number\_entry\_CD!=number\_entry) || (number\_disk\_with\_CD!=0) || (number\_disk!=0))
00719       err=ZIP\_BADZIPFILE;
00720 
00721     \textcolor{comment}{/* size of the central directory */}
00722     \textcolor{keywordflow}{if} (zip64local\_getLong64(&pziinit->z\_filefunc, pziinit->filestream,&size\_central\_dir)!=ZIP\_OK)
00723       err=ZIP\_ERRNO;
00724 
00725     \textcolor{comment}{/* offset of start of central directory with respect to the}
00726 \textcolor{comment}{    starting disk number */}
00727     \textcolor{keywordflow}{if} (zip64local\_getLong64(&pziinit->z\_filefunc, pziinit->filestream,&offset\_central\_dir)!=ZIP\_OK)
00728       err=ZIP\_ERRNO;
00729 
00730     \textcolor{comment}{// TODO..}
00731     \textcolor{comment}{// read the comment from the standard central header.}
00732     size\_comment = 0;
00733   \}
00734   \textcolor{keywordflow}{else}
00735   \{
00736     \textcolor{comment}{// Read End of central Directory info}
00737     \textcolor{keywordflow}{if} (ZSEEK64(pziinit->z\_filefunc, pziinit->filestream, central\_pos,ZLIB\_FILEFUNC\_SEEK\_SET)!=0)
00738       err=ZIP\_ERRNO;
00739 
00740     \textcolor{comment}{/* the signature, already checked */}
00741     \textcolor{keywordflow}{if} (zip64local\_getLong(&pziinit->z\_filefunc, pziinit->filestream,&uL)!=ZIP\_OK)
00742       err=ZIP\_ERRNO;
00743 
00744     \textcolor{comment}{/* number of this disk */}
00745     \textcolor{keywordflow}{if} (zip64local\_getShort(&pziinit->z\_filefunc, pziinit->filestream,&number\_disk)!=ZIP\_OK)
00746       err=ZIP\_ERRNO;
00747 
00748     \textcolor{comment}{/* number of the disk with the start of the central directory */}
00749     \textcolor{keywordflow}{if} (zip64local\_getShort(&pziinit->z\_filefunc, pziinit->filestream,&number\_disk\_with\_CD)!=ZIP\_OK)
00750       err=ZIP\_ERRNO;
00751 
00752     \textcolor{comment}{/* total number of entries in the central dir on this disk */}
00753     number\_entry = 0;
00754     \textcolor{keywordflow}{if} (zip64local\_getShort(&pziinit->z\_filefunc, pziinit->filestream, &uL)!=ZIP\_OK)
00755       err=ZIP\_ERRNO;
00756     \textcolor{keywordflow}{else}
00757       number\_entry = uL;
00758 
00759     \textcolor{comment}{/* total number of entries in the central dir */}
00760     number\_entry\_CD = 0;
00761     \textcolor{keywordflow}{if} (zip64local\_getShort(&pziinit->z\_filefunc, pziinit->filestream, &uL)!=ZIP\_OK)
00762       err=ZIP\_ERRNO;
00763     \textcolor{keywordflow}{else}
00764       number\_entry\_CD = uL;
00765 
00766     \textcolor{keywordflow}{if} ((number\_entry\_CD!=number\_entry) || (number\_disk\_with\_CD!=0) || (number\_disk!=0))
00767       err=ZIP\_BADZIPFILE;
00768 
00769     \textcolor{comment}{/* size of the central directory */}
00770     size\_central\_dir = 0;
00771     \textcolor{keywordflow}{if} (zip64local\_getLong(&pziinit->z\_filefunc, pziinit->filestream, &uL)!=ZIP\_OK)
00772       err=ZIP\_ERRNO;
00773     \textcolor{keywordflow}{else}
00774       size\_central\_dir = uL;
00775 
00776     \textcolor{comment}{/* offset of start of central directory with respect to the starting disk number */}
00777     offset\_central\_dir = 0;
00778     \textcolor{keywordflow}{if} (zip64local\_getLong(&pziinit->z\_filefunc, pziinit->filestream, &uL)!=ZIP\_OK)
00779       err=ZIP\_ERRNO;
00780     \textcolor{keywordflow}{else}
00781       offset\_central\_dir = uL;
00782 
00783 
00784     \textcolor{comment}{/* zipfile global comment length */}
00785     \textcolor{keywordflow}{if} (zip64local\_getShort(&pziinit->z\_filefunc, pziinit->filestream, &size\_comment)!=ZIP\_OK)
00786       err=ZIP\_ERRNO;
00787   \}
00788 
00789   \textcolor{keywordflow}{if} ((central\_pos<offset\_central\_dir+size\_central\_dir) &&
00790     (err==ZIP\_OK))
00791     err=ZIP\_BADZIPFILE;
00792 
00793   \textcolor{keywordflow}{if} (err!=ZIP\_OK)
00794   \{
00795     ZCLOSE64(pziinit->z\_filefunc, pziinit->filestream);
00796     \textcolor{keywordflow}{return} ZIP\_ERRNO;
00797   \}
00798 
00799   \textcolor{keywordflow}{if} (size\_comment>0)
00800   \{
00801     pziinit->globalcomment = (\textcolor{keywordtype}{char}*)ALLOC(size\_comment+1);
00802     \textcolor{keywordflow}{if} (pziinit->globalcomment)
00803     \{
00804       size\_comment = ZREAD64(pziinit->z\_filefunc, pziinit->filestream, pziinit->globalcomment,size\_comment)
      ;
00805       pziinit->globalcomment[size\_comment]=0;
00806     \}
00807   \}
00808 
00809   byte\_before\_the\_zipfile = central\_pos - (offset\_central\_dir+size\_central\_dir);
00810   pziinit->add\_position\_when\_writing\_offset = byte\_before\_the\_zipfile;
00811 
00812   \{
00813     ZPOS64\_T size\_central\_dir\_to\_read = size\_central\_dir;
00814     \textcolor{keywordtype}{size\_t} buf\_size = SIZEDATA\_INDATABLOCK;
00815     \textcolor{keywordtype}{void}* buf\_read = (\textcolor{keywordtype}{void}*)ALLOC(buf\_size);
00816     \textcolor{keywordflow}{if} (ZSEEK64(pziinit->z\_filefunc, pziinit->filestream, offset\_central\_dir + byte\_before\_the\_zipfile, 
      ZLIB\_FILEFUNC\_SEEK\_SET) != 0)
00817       err=ZIP\_ERRNO;
00818 
00819     \textcolor{keywordflow}{while} ((size\_central\_dir\_to\_read>0) && (err==ZIP\_OK))
00820     \{
00821       ZPOS64\_T read\_this = SIZEDATA\_INDATABLOCK;
00822       \textcolor{keywordflow}{if} (read\_this > size\_central\_dir\_to\_read)
00823         read\_this = size\_central\_dir\_to\_read;
00824 
00825       \textcolor{keywordflow}{if} (ZREAD64(pziinit->z\_filefunc, pziinit->filestream,buf\_read,(uLong)read\_this) != read\_this)
00826         err=ZIP\_ERRNO;
00827 
00828       \textcolor{keywordflow}{if} (err==ZIP\_OK)
00829         err = add\_data\_in\_datablock(&pziinit->central\_dir,buf\_read, (uLong)read\_this);
00830 
00831       size\_central\_dir\_to\_read-=read\_this;
00832     \}
00833     TRYFREE(buf\_read);
00834   \}
00835   pziinit->begin\_pos = byte\_before\_the\_zipfile;
00836   pziinit->number\_entry = number\_entry\_CD;
00837 
00838   \textcolor{keywordflow}{if} (ZSEEK64(pziinit->z\_filefunc, pziinit->filestream, offset\_central\_dir+byte\_before\_the\_zipfile,
      ZLIB\_FILEFUNC\_SEEK\_SET) != 0)
00839     err=ZIP\_ERRNO;
00840 
00841   \textcolor{keywordflow}{return} err;
00842 \}
00843 
00844 
00845 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !NO\_ADDFILEINEXISTINGZIP*/}\textcolor{preprocessor}{}
00846 
00847 
00848 \textcolor{comment}{/************************************************************/}
00849 \textcolor{keyword}{extern} zipFile ZEXPORT zipOpen3 (\textcolor{keyword}{const} \textcolor{keywordtype}{void} *pathname, \textcolor{keywordtype}{int} append, zipcharpc* globalcomment, 
      \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def}* pzlib\_filefunc64\_32\_def)
00850 \{
00851     \hyperlink{structzip64__internal}{zip64\_internal} ziinit;
00852     \hyperlink{structzip64__internal}{zip64\_internal}* zi;
00853     \textcolor{keywordtype}{int} err=ZIP\_OK;
00854 
00855     ziinit.z\_filefunc.zseek32\_file = NULL;
00856     ziinit.z\_filefunc.ztell32\_file = NULL;
00857     \textcolor{keywordflow}{if} (pzlib\_filefunc64\_32\_def==NULL)
00858         fill\_fopen64\_filefunc(&ziinit.z\_filefunc.zfile\_func64);
00859     \textcolor{keywordflow}{else}
00860         ziinit.z\_filefunc = *pzlib\_filefunc64\_32\_def;
00861 
00862     ziinit.filestream = ZOPEN64(ziinit.z\_filefunc,
00863                   pathname,
00864                   (append == APPEND\_STATUS\_CREATE) ?
00865                   (ZLIB\_FILEFUNC\_MODE\_READ | ZLIB\_FILEFUNC\_MODE\_WRITE | ZLIB\_FILEFUNC\_MODE\_CREATE) :
00866                     (ZLIB\_FILEFUNC\_MODE\_READ | ZLIB\_FILEFUNC\_MODE\_WRITE | ZLIB\_FILEFUNC\_MODE\_EXISTING));
00867 
00868     \textcolor{keywordflow}{if} (ziinit.filestream == NULL)
00869         \textcolor{keywordflow}{return} NULL;
00870 
00871     \textcolor{keywordflow}{if} (append == APPEND\_STATUS\_CREATEAFTER)
00872         ZSEEK64(ziinit.z\_filefunc,ziinit.filestream,0,SEEK\_END);
00873 
00874     ziinit.begin\_pos = ZTELL64(ziinit.z\_filefunc,ziinit.filestream);
00875     ziinit.in\_opened\_file\_inzip = 0;
00876     ziinit.ci.stream\_initialised = 0;
00877     ziinit.number\_entry = 0;
00878     ziinit.add\_position\_when\_writing\_offset = 0;
00879     init\_linkedlist(&(ziinit.central\_dir));
00880 
00881 
00882 
00883     zi = (\hyperlink{structzip64__internal}{zip64\_internal}*)ALLOC(\textcolor{keyword}{sizeof}(\hyperlink{structzip64__internal}{zip64\_internal}));
00884     \textcolor{keywordflow}{if} (zi==NULL)
00885     \{
00886         ZCLOSE64(ziinit.z\_filefunc,ziinit.filestream);
00887         \textcolor{keywordflow}{return} NULL;
00888     \}
00889 
00890     \textcolor{comment}{/* now we add file in a zipfile */}
00891 \textcolor{preprocessor}{#    ifndef NO\_ADDFILEINEXISTINGZIP}
00892     ziinit.globalcomment = NULL;
00893     \textcolor{keywordflow}{if} (append == APPEND\_STATUS\_ADDINZIP)
00894     \{
00895       \textcolor{comment}{// Read and Cache Central Directory Records}
00896       err = LoadCentralDirectoryRecord(&ziinit);
00897     \}
00898 
00899     \textcolor{keywordflow}{if} (globalcomment)
00900     \{
00901       *globalcomment = ziinit.globalcomment;
00902     \}
00903 \textcolor{preprocessor}{#    endif }\textcolor{comment}{/* !NO\_ADDFILEINEXISTINGZIP*/}\textcolor{preprocessor}{}
00904 
00905     \textcolor{keywordflow}{if} (err != ZIP\_OK)
00906     \{
00907 \textcolor{preprocessor}{#    ifndef NO\_ADDFILEINEXISTINGZIP}
00908         TRYFREE(ziinit.globalcomment);
00909 \textcolor{preprocessor}{#    endif }\textcolor{comment}{/* !NO\_ADDFILEINEXISTINGZIP*/}\textcolor{preprocessor}{}
00910         TRYFREE(zi);
00911         \textcolor{keywordflow}{return} NULL;
00912     \}
00913     \textcolor{keywordflow}{else}
00914     \{
00915         *zi = ziinit;
00916         \textcolor{keywordflow}{return} (zipFile)zi;
00917     \}
00918 \}
00919 
00920 \textcolor{keyword}{extern} zipFile ZEXPORT zipOpen2 (\textcolor{keyword}{const} \textcolor{keywordtype}{char} *pathname, \textcolor{keywordtype}{int} append, zipcharpc* globalcomment, 
      \hyperlink{structzlib__filefunc__def__s}{zlib\_filefunc\_def}* pzlib\_filefunc32\_def)
00921 \{
00922     \textcolor{keywordflow}{if} (pzlib\_filefunc32\_def != NULL)
00923     \{
00924         \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def} zlib\_filefunc64\_32\_def\_fill;
00925         fill\_zlib\_filefunc64\_32\_def\_from\_filefunc32(&zlib\_filefunc64\_32\_def\_fill,pzlib\_filefunc32\_def);
00926         \textcolor{keywordflow}{return} zipOpen3(pathname, append, globalcomment, &zlib\_filefunc64\_32\_def\_fill);
00927     \}
00928     \textcolor{keywordflow}{else}
00929         \textcolor{keywordflow}{return} zipOpen3(pathname, append, globalcomment, NULL);
00930 \}
00931 
00932 \textcolor{keyword}{extern} zipFile ZEXPORT zipOpen2\_64 (\textcolor{keyword}{const} \textcolor{keywordtype}{void} *pathname, \textcolor{keywordtype}{int} append, zipcharpc* globalcomment, 
      \hyperlink{structzlib__filefunc64__def__s}{zlib\_filefunc64\_def}* pzlib\_filefunc\_def)
00933 \{
00934     \textcolor{keywordflow}{if} (pzlib\_filefunc\_def != NULL)
00935     \{
00936         \hyperlink{structzlib__filefunc64__32__def__s}{zlib\_filefunc64\_32\_def} zlib\_filefunc64\_32\_def\_fill;
00937         zlib\_filefunc64\_32\_def\_fill.zfile\_func64 = *pzlib\_filefunc\_def;
00938         zlib\_filefunc64\_32\_def\_fill.ztell32\_file = NULL;
00939         zlib\_filefunc64\_32\_def\_fill.zseek32\_file = NULL;
00940         \textcolor{keywordflow}{return} zipOpen3(pathname, append, globalcomment, &zlib\_filefunc64\_32\_def\_fill);
00941     \}
00942     \textcolor{keywordflow}{else}
00943         \textcolor{keywordflow}{return} zipOpen3(pathname, append, globalcomment, NULL);
00944 \}
00945 
00946 
00947 
00948 \textcolor{keyword}{extern} zipFile ZEXPORT zipOpen (\textcolor{keyword}{const} \textcolor{keywordtype}{char}* pathname, \textcolor{keywordtype}{int} append)
00949 \{
00950     \textcolor{keywordflow}{return} zipOpen3((\textcolor{keyword}{const} \textcolor{keywordtype}{void}*)pathname,append,NULL,NULL);
00951 \}
00952 
00953 \textcolor{keyword}{extern} zipFile ZEXPORT zipOpen64 (\textcolor{keyword}{const} \textcolor{keywordtype}{void}* pathname, \textcolor{keywordtype}{int} append)
00954 \{
00955     \textcolor{keywordflow}{return} zipOpen3(pathname,append,NULL,NULL);
00956 \}
00957 
00958 \textcolor{keywordtype}{int} Write\_LocalFileHeader(\hyperlink{structzip64__internal}{zip64\_internal}* zi, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, uInt 
      size\_extrafield\_local, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_local)
00959 \{
00960   \textcolor{comment}{/* write the local header */}
00961   \textcolor{keywordtype}{int} err;
00962   uInt size\_filename = (uInt)strlen(filename);
00963   uInt size\_extrafield = size\_extrafield\_local;
00964 
00965   err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)LOCALHEADERMAGIC, 4);
00966 
00967   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00968   \{
00969     \textcolor{keywordflow}{if}(zi->ci.zip64)
00970       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)45,2);\textcolor{comment}{/* version needed to extract */}
00971     \textcolor{keywordflow}{else}
00972       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)20,2);\textcolor{comment}{/* version needed to extract */}
00973   \}
00974 
00975   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00976     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)zi->ci.flag,2);
00977 
00978   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00979     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)zi->ci.method,2);
00980 
00981   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00982     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)zi->ci.dosDate,4);
00983 
00984   \textcolor{comment}{// CRC / Compressed size / Uncompressed size will be filled in later and rewritten later}
00985   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00986     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)0,4); \textcolor{comment}{/* crc 32, unknown */}
00987   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00988   \{
00989     \textcolor{keywordflow}{if}(zi->ci.zip64)
00990       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); \textcolor{comment}{/* compressed size,
       unknown */}
00991     \textcolor{keywordflow}{else}
00992       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)0,4); \textcolor{comment}{/* compressed size, unknown */}
00993   \}
00994   \textcolor{keywordflow}{if} (err==ZIP\_OK)
00995   \{
00996     \textcolor{keywordflow}{if}(zi->ci.zip64)
00997       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); \textcolor{comment}{/* uncompressed size,
       unknown */}
00998     \textcolor{keywordflow}{else}
00999       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)0,4); \textcolor{comment}{/* uncompressed size, unknown 
      */}
01000   \}
01001 
01002   \textcolor{keywordflow}{if} (err==ZIP\_OK)
01003     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)size\_filename,2);
01004 
01005   \textcolor{keywordflow}{if}(zi->ci.zip64)
01006   \{
01007     size\_extrafield += 20;
01008   \}
01009 
01010   \textcolor{keywordflow}{if} (err==ZIP\_OK)
01011     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)size\_extrafield,2);
01012 
01013   \textcolor{keywordflow}{if} ((err==ZIP\_OK) && (size\_filename > 0))
01014   \{
01015     \textcolor{keywordflow}{if} (ZWRITE64(zi->z\_filefunc,zi->filestream,filename,size\_filename)!=size\_filename)
01016       err = ZIP\_ERRNO;
01017   \}
01018 
01019   \textcolor{keywordflow}{if} ((err==ZIP\_OK) && (size\_extrafield\_local > 0))
01020   \{
01021     \textcolor{keywordflow}{if} (ZWRITE64(zi->z\_filefunc, zi->filestream, extrafield\_local, size\_extrafield\_local) != 
      size\_extrafield\_local)
01022       err = ZIP\_ERRNO;
01023   \}
01024 
01025 
01026   \textcolor{keywordflow}{if} ((err==ZIP\_OK) && (zi->ci.zip64))
01027   \{
01028       \textcolor{comment}{// write the Zip64 extended info}
01029       \textcolor{keywordtype}{short} HeaderID = 1;
01030       \textcolor{keywordtype}{short} DataSize = 16;
01031       ZPOS64\_T CompressedSize = 0;
01032       ZPOS64\_T UncompressedSize = 0;
01033 
01034       \textcolor{comment}{// Remember position of Zip64 extended info for the local file header. (needed when we update size
       after done with file)}
01035       zi->ci.pos\_zip64extrainfo = ZTELL64(zi->z\_filefunc,zi->filestream);
01036 
01037       err = zip64local\_putValue(&zi->z\_filefunc, zi->filestream, (\textcolor{keywordtype}{short})HeaderID,2);
01038       err = zip64local\_putValue(&zi->z\_filefunc, zi->filestream, (\textcolor{keywordtype}{short})DataSize,2);
01039 
01040       err = zip64local\_putValue(&zi->z\_filefunc, zi->filestream, (ZPOS64\_T)UncompressedSize,8);
01041       err = zip64local\_putValue(&zi->z\_filefunc, zi->filestream, (ZPOS64\_T)CompressedSize,8);
01042   \}
01043 
01044   \textcolor{keywordflow}{return} err;
01045 \}
01046 
01047 \textcolor{comment}{/*}
01048 \textcolor{comment}{ NOTE.}
01049 \textcolor{comment}{ When writing RAW the ZIP64 extended information in extrafield\_local and extrafield\_global needs to be
       stripped}
01050 \textcolor{comment}{ before calling this function it can be done with zipRemoveExtraInfoBlock}
01051 \textcolor{comment}{}
01052 \textcolor{comment}{ It is not done here because then we need to realloc a new buffer since parameters are 'const' and I want
       to minimize}
01053 \textcolor{comment}{ unnecessary allocations.}
01054 \textcolor{comment}{ */}
01055 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipOpenNewFileInZip4\_64 (zipFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} 
      \hyperlink{structzip__fileinfo}{zip\_fileinfo}* zipfi,
01056                                          \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_local, uInt size\_extrafield\_local,
01057                                          \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_global, uInt size\_extrafield\_global,
01058                                          \textcolor{keyword}{const} \textcolor{keywordtype}{char}* comment, \textcolor{keywordtype}{int} method, \textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} raw,
01059                                          \textcolor{keywordtype}{int} windowBits,\textcolor{keywordtype}{int} memLevel, \textcolor{keywordtype}{int} strategy,
01060                                          \textcolor{keyword}{const} \textcolor{keywordtype}{char}* password, uLong crcForCrypting,
01061                                          uLong versionMadeBy, uLong flagBase, \textcolor{keywordtype}{int} zip64)
01062 \{
01063     \hyperlink{structzip64__internal}{zip64\_internal}* zi;
01064     uInt size\_filename;
01065     uInt size\_comment;
01066     uInt i;
01067     \textcolor{keywordtype}{int} err = ZIP\_OK;
01068 
01069 \textcolor{preprocessor}{#    ifdef NOCRYPT}
01070     (crcForCrypting);
01071     \textcolor{keywordflow}{if} (password != NULL)
01072         \textcolor{keywordflow}{return} ZIP\_PARAMERROR;
01073 \textcolor{preprocessor}{#    endif}
01074 
01075     \textcolor{keywordflow}{if} (\hyperlink{structfile}{file} == NULL)
01076         \textcolor{keywordflow}{return} ZIP\_PARAMERROR;
01077 
01078 \textcolor{preprocessor}{#ifdef HAVE\_BZIP2}
01079     \textcolor{keywordflow}{if} ((method!=0) && (method!=Z\_DEFLATED) && (method!=Z\_BZIP2ED))
01080       \textcolor{keywordflow}{return} ZIP\_PARAMERROR;
01081 \textcolor{preprocessor}{#else}
01082     \textcolor{keywordflow}{if} ((method!=0) && (method!=Z\_DEFLATED))
01083       \textcolor{keywordflow}{return} ZIP\_PARAMERROR;
01084 \textcolor{preprocessor}{#endif}
01085 
01086     zi = (\hyperlink{structzip64__internal}{zip64\_internal}*)\hyperlink{structfile}{file};
01087 
01088     \textcolor{keywordflow}{if} (zi->in\_opened\_file\_inzip == 1)
01089     \{
01090         err = zipCloseFileInZip (\hyperlink{structfile}{file});
01091         \textcolor{keywordflow}{if} (err != ZIP\_OK)
01092             \textcolor{keywordflow}{return} err;
01093     \}
01094 
01095     \textcolor{keywordflow}{if} (filename==NULL)
01096         filename=\textcolor{stringliteral}{"-"};
01097 
01098     \textcolor{keywordflow}{if} (comment==NULL)
01099         size\_comment = 0;
01100     \textcolor{keywordflow}{else}
01101         size\_comment = (uInt)strlen(comment);
01102 
01103     size\_filename = (uInt)strlen(filename);
01104 
01105     \textcolor{keywordflow}{if} (zipfi == NULL)
01106         zi->ci.dosDate = 0;
01107     \textcolor{keywordflow}{else}
01108     \{
01109         \textcolor{keywordflow}{if} (zipfi->dosDate != 0)
01110             zi->ci.dosDate = zipfi->dosDate;
01111         \textcolor{keywordflow}{else}
01112           zi->ci.dosDate = zip64local\_TmzDateToDosDate(&zipfi->tmz\_date);
01113     \}
01114 
01115     zi->ci.flag = flagBase;
01116     \textcolor{keywordflow}{if} ((level==8) || (level==9))
01117       zi->ci.flag |= 2;
01118     \textcolor{keywordflow}{if} (level==2)
01119       zi->ci.flag |= 4;
01120     \textcolor{keywordflow}{if} (level==1)
01121       zi->ci.flag |= 6;
01122     \textcolor{keywordflow}{if} (password != NULL)
01123       zi->ci.flag |= 1;
01124 
01125     zi->ci.crc32 = 0;
01126     zi->ci.method = method;
01127     zi->ci.encrypt = 0;
01128     zi->ci.stream\_initialised = 0;
01129     zi->ci.pos\_in\_buffered\_data = 0;
01130     zi->ci.raw = raw;
01131     zi->ci.pos\_local\_header = ZTELL64(zi->z\_filefunc,zi->filestream);
01132 
01133     zi->ci.size\_centralheader = SIZECENTRALHEADER + size\_filename + size\_extrafield\_global + size\_comment;
01134     zi->ci.size\_centralExtraFree = 32; \textcolor{comment}{// Extra space we have reserved in case we need to add ZIP64 extra
       info data}
01135 
01136     zi->ci.central\_header = (\textcolor{keywordtype}{char}*)ALLOC((uInt)zi->ci.size\_centralheader + zi->ci.size\_centralExtraFree);
01137 
01138     zi->ci.size\_centralExtra = size\_extrafield\_global;
01139     zip64local\_putValue\_inmemory(zi->ci.central\_header,(uLong)CENTRALHEADERMAGIC,4);
01140     \textcolor{comment}{/* version info */}
01141     zip64local\_putValue\_inmemory(zi->ci.central\_header+4,(uLong)versionMadeBy,2);
01142     zip64local\_putValue\_inmemory(zi->ci.central\_header+6,(uLong)20,2);
01143     zip64local\_putValue\_inmemory(zi->ci.central\_header+8,(uLong)zi->ci.flag,2);
01144     zip64local\_putValue\_inmemory(zi->ci.central\_header+10,(uLong)zi->ci.method,2);
01145     zip64local\_putValue\_inmemory(zi->ci.central\_header+12,(uLong)zi->ci.dosDate,4);
01146     zip64local\_putValue\_inmemory(zi->ci.central\_header+16,(uLong)0,4); \textcolor{comment}{/*crc*/}
01147     zip64local\_putValue\_inmemory(zi->ci.central\_header+20,(uLong)0,4); \textcolor{comment}{/*compr size*/}
01148     zip64local\_putValue\_inmemory(zi->ci.central\_header+24,(uLong)0,4); \textcolor{comment}{/*uncompr size*/}
01149     zip64local\_putValue\_inmemory(zi->ci.central\_header+28,(uLong)size\_filename,2);
01150     zip64local\_putValue\_inmemory(zi->ci.central\_header+30,(uLong)size\_extrafield\_global,2);
01151     zip64local\_putValue\_inmemory(zi->ci.central\_header+32,(uLong)size\_comment,2);
01152     zip64local\_putValue\_inmemory(zi->ci.central\_header+34,(uLong)0,2); \textcolor{comment}{/*disk nm start*/}
01153 
01154     \textcolor{keywordflow}{if} (zipfi==NULL)
01155         zip64local\_putValue\_inmemory(zi->ci.central\_header+36,(uLong)0,2);
01156     \textcolor{keywordflow}{else}
01157         zip64local\_putValue\_inmemory(zi->ci.central\_header+36,(uLong)zipfi->internal\_fa,2);
01158 
01159     \textcolor{keywordflow}{if} (zipfi==NULL)
01160         zip64local\_putValue\_inmemory(zi->ci.central\_header+38,(uLong)0,4);
01161     \textcolor{keywordflow}{else}
01162         zip64local\_putValue\_inmemory(zi->ci.central\_header+38,(uLong)zipfi->external\_fa,4);
01163 
01164     \textcolor{keywordflow}{if}(zi->ci.pos\_local\_header >= 0xffffffff)
01165       zip64local\_putValue\_inmemory(zi->ci.central\_header+42,(uLong)0xffffffff,4);
01166     \textcolor{keywordflow}{else}
01167       zip64local\_putValue\_inmemory(zi->ci.central\_header+42,(uLong)zi->ci.pos\_local\_header - zi->
      add\_position\_when\_writing\_offset,4);
01168 
01169     \textcolor{keywordflow}{for} (i=0;i<size\_filename;i++)
01170         *(zi->ci.central\_header+SIZECENTRALHEADER+i) = *(filename+i);
01171 
01172     \textcolor{keywordflow}{for} (i=0;i<size\_extrafield\_global;i++)
01173         *(zi->ci.central\_header+SIZECENTRALHEADER+size\_filename+i) =
01174               *(((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)extrafield\_global)+i);
01175 
01176     \textcolor{keywordflow}{for} (i=0;i<size\_comment;i++)
01177         *(zi->ci.central\_header+SIZECENTRALHEADER+size\_filename+
01178               size\_extrafield\_global+i) = *(comment+i);
01179     \textcolor{keywordflow}{if} (zi->ci.central\_header == NULL)
01180         \textcolor{keywordflow}{return} ZIP\_INTERNALERROR;
01181 
01182     zi->ci.zip64 = zip64;
01183     zi->ci.totalCompressedData = 0;
01184     zi->ci.totalUncompressedData = 0;
01185     zi->ci.pos\_zip64extrainfo = 0;
01186 
01187     err = Write\_LocalFileHeader(zi, filename, size\_extrafield\_local, extrafield\_local);
01188 
01189 \textcolor{preprocessor}{#ifdef HAVE\_BZIP2}
01190     zi->ci.bstream.avail\_in = (uInt)0;
01191     zi->ci.bstream.avail\_out = (uInt)Z\_BUFSIZE;
01192     zi->ci.bstream.next\_out = (\textcolor{keywordtype}{char}*)zi->ci.buffered\_data;
01193     zi->ci.bstream.total\_in\_hi32 = 0;
01194     zi->ci.bstream.total\_in\_lo32 = 0;
01195     zi->ci.bstream.total\_out\_hi32 = 0;
01196     zi->ci.bstream.total\_out\_lo32 = 0;
01197 #endif
01198 
01199     zi->ci.stream.avail\_in = (uInt)0;
01200     zi->ci.stream.avail\_out = (uInt)Z\_BUFSIZE;
01201     zi->ci.stream.next\_out = zi->ci.buffered\_data;
01202     zi->ci.stream.total\_in = 0;
01203     zi->ci.stream.total\_out = 0;
01204     zi->ci.stream.data\_type = Z\_BINARY;
01205 
01206 \textcolor{preprocessor}{#ifdef HAVE\_BZIP2}
01207     \textcolor{keywordflow}{if} ((err==ZIP\_OK) && (zi->ci.method == Z\_DEFLATED || zi->ci.method == Z\_BZIP2ED) && (!zi->ci.raw))
01208 #\textcolor{keywordflow}{else}
01209     \textcolor{keywordflow}{if} ((err==ZIP\_OK) && (zi->ci.method == Z\_DEFLATED) && (!zi->ci.raw))
01210 #endif
01211     \{
01212         \textcolor{keywordflow}{if}(zi->ci.method == Z\_DEFLATED)
01213         \{
01214           zi->ci.stream.zalloc = (alloc\_func)0;
01215           zi->ci.stream.zfree = (free\_func)0;
01216           zi->ci.stream.opaque = (voidpf)0;
01217 
01218           \textcolor{keywordflow}{if} (windowBits>0)
01219               windowBits = -windowBits;
01220 
01221           err = deflateInit2(&zi->ci.stream, level, Z\_DEFLATED, windowBits, memLevel, strategy);
01222 
01223           \textcolor{keywordflow}{if} (err==Z\_OK)
01224               zi->ci.stream\_initialised = Z\_DEFLATED;
01225         \}
01226         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(zi->ci.method == Z\_BZIP2ED)
01227         \{
01228 \textcolor{preprocessor}{#ifdef HAVE\_BZIP2}
01229             \textcolor{comment}{// Init BZip stuff here}
01230           zi->ci.bstream.bzalloc = 0;
01231           zi->ci.bstream.bzfree = 0;
01232           zi->ci.bstream.opaque = (voidpf)0;
01233 
01234           err = BZ2\_bzCompressInit(&zi->ci.bstream, level, 0,35);
01235           \textcolor{keywordflow}{if}(err == BZ\_OK)
01236             zi->ci.stream\_initialised = Z\_BZIP2ED;
01237 \textcolor{preprocessor}{#endif}
01238         \}
01239 
01240     \}
01241 
01242 \textcolor{preprocessor}{#    ifndef NOCRYPT}
01243     zi->ci.crypt\_header\_size = 0;
01244     \textcolor{keywordflow}{if} ((err==Z\_OK) && (password != NULL))
01245     \{
01246         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} bufHead[RAND\_HEAD\_LEN];
01247         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sizeHead;
01248         zi->ci.encrypt = 1;
01249         zi->ci.pcrc\_32\_tab = get\_crc\_table();
01250         \textcolor{comment}{/*init\_keys(password,zi->ci.keys,zi->ci.pcrc\_32\_tab);*/}
01251 
01252         sizeHead=crypthead(password,bufHead,RAND\_HEAD\_LEN,zi->ci.keys,zi->ci.pcrc\_32\_tab,crcForCrypting);
01253         zi->ci.crypt\_header\_size = sizeHead;
01254 
01255         \textcolor{keywordflow}{if} (ZWRITE64(zi->z\_filefunc,zi->filestream,bufHead,sizeHead) != sizeHead)
01256                 err = ZIP\_ERRNO;
01257     \}
01258 \textcolor{preprocessor}{#    endif}
01259 
01260     \textcolor{keywordflow}{if} (err==Z\_OK)
01261         zi->in\_opened\_file\_inzip = 1;
01262     \textcolor{keywordflow}{return} err;
01263 \}
01264 
01265 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipOpenNewFileInZip4 (zipFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} 
      \hyperlink{structzip__fileinfo}{zip\_fileinfo}* zipfi,
01266                                          \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_local, uInt size\_extrafield\_local,
01267                                          \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_global, uInt size\_extrafield\_global,
01268                                          \textcolor{keyword}{const} \textcolor{keywordtype}{char}* comment, \textcolor{keywordtype}{int} method, \textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} raw,
01269                                          \textcolor{keywordtype}{int} windowBits,\textcolor{keywordtype}{int} memLevel, \textcolor{keywordtype}{int} strategy,
01270                                          \textcolor{keyword}{const} \textcolor{keywordtype}{char}* password, uLong crcForCrypting,
01271                                          uLong versionMadeBy, uLong flagBase)
01272 \{
01273     \textcolor{keywordflow}{return} zipOpenNewFileInZip4\_64 (\hyperlink{structfile}{file}, filename, zipfi,
01274                                  extrafield\_local, size\_extrafield\_local,
01275                                  extrafield\_global, size\_extrafield\_global,
01276                                  comment, method, level, raw,
01277                                  windowBits, memLevel, strategy,
01278                                  password, crcForCrypting, versionMadeBy, flagBase, 0);
01279 \}
01280 
01281 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipOpenNewFileInZip3 (zipFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} 
      \hyperlink{structzip__fileinfo}{zip\_fileinfo}* zipfi,
01282                                          \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_local, uInt size\_extrafield\_local,
01283                                          \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_global, uInt size\_extrafield\_global,
01284                                          \textcolor{keyword}{const} \textcolor{keywordtype}{char}* comment, \textcolor{keywordtype}{int} method, \textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} raw,
01285                                          \textcolor{keywordtype}{int} windowBits,\textcolor{keywordtype}{int} memLevel, \textcolor{keywordtype}{int} strategy,
01286                                          \textcolor{keyword}{const} \textcolor{keywordtype}{char}* password, uLong crcForCrypting)
01287 \{
01288     \textcolor{keywordflow}{return} zipOpenNewFileInZip4\_64 (\hyperlink{structfile}{file}, filename, zipfi,
01289                                  extrafield\_local, size\_extrafield\_local,
01290                                  extrafield\_global, size\_extrafield\_global,
01291                                  comment, method, level, raw,
01292                                  windowBits, memLevel, strategy,
01293                                  password, crcForCrypting, VERSIONMADEBY, 0, 0);
01294 \}
01295 
01296 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipOpenNewFileInZip3\_64(zipFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} 
      \hyperlink{structzip__fileinfo}{zip\_fileinfo}* zipfi,
01297                                          \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_local, uInt size\_extrafield\_local,
01298                                          \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_global, uInt size\_extrafield\_global,
01299                                          \textcolor{keyword}{const} \textcolor{keywordtype}{char}* comment, \textcolor{keywordtype}{int} method, \textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} raw,
01300                                          \textcolor{keywordtype}{int} windowBits,\textcolor{keywordtype}{int} memLevel, \textcolor{keywordtype}{int} strategy,
01301                                          \textcolor{keyword}{const} \textcolor{keywordtype}{char}* password, uLong crcForCrypting, \textcolor{keywordtype}{int} zip64)
01302 \{
01303     \textcolor{keywordflow}{return} zipOpenNewFileInZip4\_64 (\hyperlink{structfile}{file}, filename, zipfi,
01304                                  extrafield\_local, size\_extrafield\_local,
01305                                  extrafield\_global, size\_extrafield\_global,
01306                                  comment, method, level, raw,
01307                                  windowBits, memLevel, strategy,
01308                                  password, crcForCrypting, VERSIONMADEBY, 0, zip64);
01309 \}
01310 
01311 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipOpenNewFileInZip2(zipFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} 
      \hyperlink{structzip__fileinfo}{zip\_fileinfo}* zipfi,
01312                                         \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_local, uInt size\_extrafield\_local,
01313                                         \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_global, uInt size\_extrafield\_global,
01314                                         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* comment, \textcolor{keywordtype}{int} method, \textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} raw)
01315 \{
01316     \textcolor{keywordflow}{return} zipOpenNewFileInZip4\_64 (\hyperlink{structfile}{file}, filename, zipfi,
01317                                  extrafield\_local, size\_extrafield\_local,
01318                                  extrafield\_global, size\_extrafield\_global,
01319                                  comment, method, level, raw,
01320                                  -MAX\_WBITS, DEF\_MEM\_LEVEL, Z\_DEFAULT\_STRATEGY,
01321                                  NULL, 0, VERSIONMADEBY, 0, 0);
01322 \}
01323 
01324 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipOpenNewFileInZip2\_64(zipFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} 
      \hyperlink{structzip__fileinfo}{zip\_fileinfo}* zipfi,
01325                                         \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_local, uInt size\_extrafield\_local,
01326                                         \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_global, uInt size\_extrafield\_global,
01327                                         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* comment, \textcolor{keywordtype}{int} method, \textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} raw, \textcolor{keywordtype}{int} zip64)
01328 \{
01329     \textcolor{keywordflow}{return} zipOpenNewFileInZip4\_64 (\hyperlink{structfile}{file}, filename, zipfi,
01330                                  extrafield\_local, size\_extrafield\_local,
01331                                  extrafield\_global, size\_extrafield\_global,
01332                                  comment, method, level, raw,
01333                                  -MAX\_WBITS, DEF\_MEM\_LEVEL, Z\_DEFAULT\_STRATEGY,
01334                                  NULL, 0, VERSIONMADEBY, 0, zip64);
01335 \}
01336 
01337 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipOpenNewFileInZip64 (zipFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} 
      \hyperlink{structzip__fileinfo}{zip\_fileinfo}* zipfi,
01338                                         \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_local, uInt size\_extrafield\_local,
01339                                         \textcolor{keyword}{const} \textcolor{keywordtype}{void}*extrafield\_global, uInt size\_extrafield\_global,
01340                                         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* comment, \textcolor{keywordtype}{int} method, \textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} zip64)
01341 \{
01342     \textcolor{keywordflow}{return} zipOpenNewFileInZip4\_64 (\hyperlink{structfile}{file}, filename, zipfi,
01343                                  extrafield\_local, size\_extrafield\_local,
01344                                  extrafield\_global, size\_extrafield\_global,
01345                                  comment, method, level, 0,
01346                                  -MAX\_WBITS, DEF\_MEM\_LEVEL, Z\_DEFAULT\_STRATEGY,
01347                                  NULL, 0, VERSIONMADEBY, 0, zip64);
01348 \}
01349 
01350 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipOpenNewFileInZip (zipFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} 
      \hyperlink{structzip__fileinfo}{zip\_fileinfo}* zipfi,
01351                                         \textcolor{keyword}{const} \textcolor{keywordtype}{void}* extrafield\_local, uInt size\_extrafield\_local,
01352                                         \textcolor{keyword}{const} \textcolor{keywordtype}{void}*extrafield\_global, uInt size\_extrafield\_global,
01353                                         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* comment, \textcolor{keywordtype}{int} method, \textcolor{keywordtype}{int} level)
01354 \{
01355     \textcolor{keywordflow}{return} zipOpenNewFileInZip4\_64 (\hyperlink{structfile}{file}, filename, zipfi,
01356                                  extrafield\_local, size\_extrafield\_local,
01357                                  extrafield\_global, size\_extrafield\_global,
01358                                  comment, method, level, 0,
01359                                  -MAX\_WBITS, DEF\_MEM\_LEVEL, Z\_DEFAULT\_STRATEGY,
01360                                  NULL, 0, VERSIONMADEBY, 0, 0);
01361 \}
01362 
01363 local \textcolor{keywordtype}{int} zip64FlushWriteBuffer(\hyperlink{structzip64__internal}{zip64\_internal}* zi)
01364 \{
01365     \textcolor{keywordtype}{int} err=ZIP\_OK;
01366 
01367     \textcolor{keywordflow}{if} (zi->ci.encrypt != 0)
01368     \{
01369 \textcolor{preprocessor}{#ifndef NOCRYPT}
01370         uInt i;
01371         \textcolor{keywordtype}{int} t;
01372         \textcolor{keywordflow}{for} (i=0;i<zi->ci.pos\_in\_buffered\_data;i++)
01373             zi->ci.buffered\_data[i] = zencode(zi->ci.keys, zi->ci.pcrc\_32\_tab, zi->ci.buffered\_data[i],t);
01374 \textcolor{preprocessor}{#endif}
01375     \}
01376 
01377     \textcolor{keywordflow}{if} (ZWRITE64(zi->z\_filefunc,zi->filestream,zi->ci.buffered\_data,zi->ci.pos\_in\_buffered\_data) != zi->ci.
      pos\_in\_buffered\_data)
01378       err = ZIP\_ERRNO;
01379 
01380     zi->ci.totalCompressedData += zi->ci.pos\_in\_buffered\_data;
01381 
01382 \textcolor{preprocessor}{#ifdef HAVE\_BZIP2}
01383     \textcolor{keywordflow}{if}(zi->ci.method == Z\_BZIP2ED)
01384     \{
01385       zi->ci.totalUncompressedData += zi->ci.bstream.total\_in\_lo32;
01386       zi->ci.bstream.total\_in\_lo32 = 0;
01387       zi->ci.bstream.total\_in\_hi32 = 0;
01388     \}
01389     \textcolor{keywordflow}{else}
01390 \textcolor{preprocessor}{#endif}
01391     \{
01392       zi->ci.totalUncompressedData += zi->ci.stream.total\_in;
01393       zi->ci.stream.total\_in = 0;
01394     \}
01395 
01396 
01397     zi->ci.pos\_in\_buffered\_data = 0;
01398 
01399     \textcolor{keywordflow}{return} err;
01400 \}
01401 
01402 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipWriteInFileInZip (zipFile \hyperlink{structfile}{file},\textcolor{keyword}{const} \textcolor{keywordtype}{void}* buf,\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len)
01403 \{
01404     \hyperlink{structzip64__internal}{zip64\_internal}* zi;
01405     \textcolor{keywordtype}{int} err=ZIP\_OK;
01406 
01407     \textcolor{keywordflow}{if} (\hyperlink{structfile}{file} == NULL)
01408         \textcolor{keywordflow}{return} ZIP\_PARAMERROR;
01409     zi = (\hyperlink{structzip64__internal}{zip64\_internal}*)\hyperlink{structfile}{file};
01410 
01411     \textcolor{keywordflow}{if} (zi->in\_opened\_file\_inzip == 0)
01412         \textcolor{keywordflow}{return} ZIP\_PARAMERROR;
01413 
01414     zi->ci.crc32 = crc32(zi->ci.crc32,buf,(uInt)len);
01415 
01416 \textcolor{preprocessor}{#ifdef HAVE\_BZIP2}
01417     \textcolor{keywordflow}{if}(zi->ci.method == Z\_BZIP2ED && (!zi->ci.raw))
01418     \{
01419       zi->ci.bstream.next\_in = (\textcolor{keywordtype}{void}*)buf;
01420       zi->ci.bstream.avail\_in = len;
01421       err = BZ\_RUN\_OK;
01422 
01423       \textcolor{keywordflow}{while} ((err==BZ\_RUN\_OK) && (zi->ci.bstream.avail\_in>0))
01424       \{
01425         \textcolor{keywordflow}{if} (zi->ci.bstream.avail\_out == 0)
01426         \{
01427           \textcolor{keywordflow}{if} (zip64FlushWriteBuffer(zi) == ZIP\_ERRNO)
01428             err = ZIP\_ERRNO;
01429           zi->ci.bstream.avail\_out = (uInt)Z\_BUFSIZE;
01430           zi->ci.bstream.next\_out = (\textcolor{keywordtype}{char}*)zi->ci.buffered\_data;
01431         \}
01432 
01433 
01434         \textcolor{keywordflow}{if}(err != BZ\_RUN\_OK)
01435           \textcolor{keywordflow}{break};
01436 
01437         \textcolor{keywordflow}{if} ((zi->ci.method == Z\_BZIP2ED) && (!zi->ci.raw))
01438         \{
01439           uLong uTotalOutBefore\_lo = zi->ci.bstream.total\_out\_lo32;
01440 \textcolor{comment}{//          uLong uTotalOutBefore\_hi = zi->ci.bstream.total\_out\_hi32;}
01441           err=BZ2\_bzCompress(&zi->ci.bstream,  BZ\_RUN);
01442 
01443           zi->ci.pos\_in\_buffered\_data += (uInt)(zi->ci.bstream.total\_out\_lo32 - uTotalOutBefore\_lo) ;
01444         \}
01445       \}
01446 
01447       \textcolor{keywordflow}{if}(err == BZ\_RUN\_OK)
01448         err = ZIP\_OK;
01449     \}
01450     \textcolor{keywordflow}{else}
01451 \textcolor{preprocessor}{#endif}
01452     \{
01453       zi->ci.stream.next\_in = (Bytef*)buf;
01454       zi->ci.stream.avail\_in = len;
01455 
01456       \textcolor{keywordflow}{while} ((err==ZIP\_OK) && (zi->ci.stream.avail\_in>0))
01457       \{
01458           \textcolor{keywordflow}{if} (zi->ci.stream.avail\_out == 0)
01459           \{
01460               \textcolor{keywordflow}{if} (zip64FlushWriteBuffer(zi) == ZIP\_ERRNO)
01461                   err = ZIP\_ERRNO;
01462               zi->ci.stream.avail\_out = (uInt)Z\_BUFSIZE;
01463               zi->ci.stream.next\_out = zi->ci.buffered\_data;
01464           \}
01465 
01466 
01467           \textcolor{keywordflow}{if}(err != ZIP\_OK)
01468               \textcolor{keywordflow}{break};
01469 
01470           \textcolor{keywordflow}{if} ((zi->ci.method == Z\_DEFLATED) && (!zi->ci.raw))
01471           \{
01472               uLong uTotalOutBefore = zi->ci.stream.total\_out;
01473               err=deflate(&zi->ci.stream,  Z\_NO\_FLUSH);
01474               \textcolor{keywordflow}{if}(uTotalOutBefore > zi->ci.stream.total\_out)
01475               \{
01476                 \textcolor{keywordtype}{int} bBreak = 0;
01477                 bBreak++;
01478               \}
01479 
01480               zi->ci.pos\_in\_buffered\_data += (uInt)(zi->ci.stream.total\_out - uTotalOutBefore) ;
01481           \}
01482           \textcolor{keywordflow}{else}
01483           \{
01484               uInt copy\_this,i;
01485               \textcolor{keywordflow}{if} (zi->ci.stream.avail\_in < zi->ci.stream.avail\_out)
01486                   copy\_this = zi->ci.stream.avail\_in;
01487               \textcolor{keywordflow}{else}
01488                   copy\_this = zi->ci.stream.avail\_out;
01489 
01490               \textcolor{keywordflow}{for} (i = 0; i < copy\_this; i++)
01491                   *(((\textcolor{keywordtype}{char}*)zi->ci.stream.next\_out)+i) =
01492                       *(((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)zi->ci.stream.next\_in)+i);
01493               \{
01494                   zi->ci.stream.avail\_in -= copy\_this;
01495                   zi->ci.stream.avail\_out-= copy\_this;
01496                   zi->ci.stream.next\_in+= copy\_this;
01497                   zi->ci.stream.next\_out+= copy\_this;
01498                   zi->ci.stream.total\_in+= copy\_this;
01499                   zi->ci.stream.total\_out+= copy\_this;
01500                   zi->ci.pos\_in\_buffered\_data += copy\_this;
01501               \}
01502           \}
01503       \}\textcolor{comment}{// while(...)}
01504     \}
01505 
01506     \textcolor{keywordflow}{return} err;
01507 \}
01508 
01509 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipCloseFileInZipRaw (zipFile \hyperlink{structfile}{file}, uLong uncompressed\_size, uLong crc32)
01510 \{
01511     \textcolor{keywordflow}{return} zipCloseFileInZipRaw64 (\hyperlink{structfile}{file}, uncompressed\_size, crc32);
01512 \}
01513 
01514 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipCloseFileInZipRaw64 (zipFile \hyperlink{structfile}{file}, ZPOS64\_T uncompressed\_size, uLong crc32)
01515 \{
01516     \hyperlink{structzip64__internal}{zip64\_internal}* zi;
01517     ZPOS64\_T compressed\_size;
01518     uLong invalidValue = 0xffffffff;
01519     \textcolor{keywordtype}{short} datasize = 0;
01520     \textcolor{keywordtype}{int} err=ZIP\_OK;
01521 
01522     \textcolor{keywordflow}{if} (\hyperlink{structfile}{file} == NULL)
01523         \textcolor{keywordflow}{return} ZIP\_PARAMERROR;
01524     zi = (\hyperlink{structzip64__internal}{zip64\_internal}*)\hyperlink{structfile}{file};
01525 
01526     \textcolor{keywordflow}{if} (zi->in\_opened\_file\_inzip == 0)
01527         \textcolor{keywordflow}{return} ZIP\_PARAMERROR;
01528     zi->ci.stream.avail\_in = 0;
01529 
01530     \textcolor{keywordflow}{if} ((zi->ci.method == Z\_DEFLATED) && (!zi->ci.raw))
01531                 \{
01532                         \textcolor{keywordflow}{while} (err==ZIP\_OK)
01533                         \{
01534                                 uLong uTotalOutBefore;
01535                                 \textcolor{keywordflow}{if} (zi->ci.stream.avail\_out == 0)
01536                                 \{
01537                                         \textcolor{keywordflow}{if} (zip64FlushWriteBuffer(zi) == ZIP\_ERRNO)
01538                                                 err = ZIP\_ERRNO;
01539                                         zi->ci.stream.avail\_out = (uInt)Z\_BUFSIZE;
01540                                         zi->ci.stream.next\_out = zi->ci.buffered\_data;
01541                                 \}
01542                                 uTotalOutBefore = zi->ci.stream.total\_out;
01543                                 err=deflate(&zi->ci.stream,  Z\_FINISH);
01544                                 zi->ci.pos\_in\_buffered\_data += (uInt)(zi->ci.stream.total\_out - 
      uTotalOutBefore) ;
01545                         \}
01546                 \}
01547     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((zi->ci.method == Z\_BZIP2ED) && (!zi->ci.raw))
01548     \{
01549 \textcolor{preprocessor}{#ifdef HAVE\_BZIP2}
01550       err = BZ\_FINISH\_OK;
01551       \textcolor{keywordflow}{while} (err==BZ\_FINISH\_OK)
01552       \{
01553         uLong uTotalOutBefore;
01554         \textcolor{keywordflow}{if} (zi->ci.bstream.avail\_out == 0)
01555         \{
01556           \textcolor{keywordflow}{if} (zip64FlushWriteBuffer(zi) == ZIP\_ERRNO)
01557             err = ZIP\_ERRNO;
01558           zi->ci.bstream.avail\_out = (uInt)Z\_BUFSIZE;
01559           zi->ci.bstream.next\_out = (\textcolor{keywordtype}{char}*)zi->ci.buffered\_data;
01560         \}
01561         uTotalOutBefore = zi->ci.bstream.total\_out\_lo32;
01562         err=BZ2\_bzCompress(&zi->ci.bstream,  BZ\_FINISH);
01563         \textcolor{keywordflow}{if}(err == BZ\_STREAM\_END)
01564           err = Z\_STREAM\_END;
01565 
01566         zi->ci.pos\_in\_buffered\_data += (uInt)(zi->ci.bstream.total\_out\_lo32 - uTotalOutBefore);
01567       \}
01568 
01569       \textcolor{keywordflow}{if}(err == BZ\_FINISH\_OK)
01570         err = ZIP\_OK;
01571 \textcolor{preprocessor}{#endif}
01572     \}
01573 
01574     \textcolor{keywordflow}{if} (err==Z\_STREAM\_END)
01575         err=ZIP\_OK; \textcolor{comment}{/* this is normal */}
01576 
01577     \textcolor{keywordflow}{if} ((zi->ci.pos\_in\_buffered\_data>0) && (err==ZIP\_OK))
01578                 \{
01579         \textcolor{keywordflow}{if} (zip64FlushWriteBuffer(zi)==ZIP\_ERRNO)
01580             err = ZIP\_ERRNO;
01581                 \}
01582 
01583     \textcolor{keywordflow}{if} ((zi->ci.method == Z\_DEFLATED) && (!zi->ci.raw))
01584     \{
01585         \textcolor{keywordtype}{int} tmp\_err = deflateEnd(&zi->ci.stream);
01586         \textcolor{keywordflow}{if} (err == ZIP\_OK)
01587             err = tmp\_err;
01588         zi->ci.stream\_initialised = 0;
01589     \}
01590 \textcolor{preprocessor}{#ifdef HAVE\_BZIP2}
01591     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((zi->ci.method == Z\_BZIP2ED) && (!zi->ci.raw))
01592     \{
01593       \textcolor{keywordtype}{int} tmperr = BZ2\_bzCompressEnd(&zi->ci.bstream);
01594                         \textcolor{keywordflow}{if} (err==ZIP\_OK)
01595                                 err = tmperr;
01596                         zi->ci.stream\_initialised = 0;
01597     \}
01598 \textcolor{preprocessor}{#endif}
01599 
01600     \textcolor{keywordflow}{if} (!zi->ci.raw)
01601     \{
01602         crc32 = (uLong)zi->ci.crc32;
01603         uncompressed\_size = zi->ci.totalUncompressedData;
01604     \}
01605     compressed\_size = zi->ci.totalCompressedData;
01606 
01607 \textcolor{preprocessor}{#    ifndef NOCRYPT}
01608     compressed\_size += zi->ci.crypt\_header\_size;
01609 \textcolor{preprocessor}{#    endif}
01610 
01611     \textcolor{comment}{// update Current Item crc and sizes,}
01612     \textcolor{keywordflow}{if}(compressed\_size >= 0xffffffff || uncompressed\_size >= 0xffffffff || zi->ci.pos\_local\_header >= 0
      xffffffff)
01613     \{
01614       \textcolor{comment}{/*version Made by*/}
01615       zip64local\_putValue\_inmemory(zi->ci.central\_header+4,(uLong)45,2);
01616       \textcolor{comment}{/*version needed*/}
01617       zip64local\_putValue\_inmemory(zi->ci.central\_header+6,(uLong)45,2);
01618 
01619     \}
01620 
01621     zip64local\_putValue\_inmemory(zi->ci.central\_header+16,crc32,4); \textcolor{comment}{/*crc*/}
01622 
01623 
01624     \textcolor{keywordflow}{if}(compressed\_size >= 0xffffffff)
01625       zip64local\_putValue\_inmemory(zi->ci.central\_header+20, invalidValue,4); \textcolor{comment}{/*compr size*/}
01626     \textcolor{keywordflow}{else}
01627       zip64local\_putValue\_inmemory(zi->ci.central\_header+20, compressed\_size,4); \textcolor{comment}{/*compr size*/}
01628 
01630     \textcolor{keywordflow}{if} (zi->ci.stream.data\_type == Z\_ASCII)
01631         zip64local\_putValue\_inmemory(zi->ci.central\_header+36,(uLong)Z\_ASCII,2);
01632 
01633     \textcolor{keywordflow}{if}(uncompressed\_size >= 0xffffffff)
01634       zip64local\_putValue\_inmemory(zi->ci.central\_header+24, invalidValue,4); \textcolor{comment}{/*uncompr size*/}
01635     \textcolor{keywordflow}{else}
01636       zip64local\_putValue\_inmemory(zi->ci.central\_header+24, uncompressed\_size,4); \textcolor{comment}{/*uncompr size*/}
01637 
01638     \textcolor{comment}{// Add ZIP64 extra info field for uncompressed size}
01639     \textcolor{keywordflow}{if}(uncompressed\_size >= 0xffffffff)
01640       datasize += 8;
01641 
01642     \textcolor{comment}{// Add ZIP64 extra info field for compressed size}
01643     \textcolor{keywordflow}{if}(compressed\_size >= 0xffffffff)
01644       datasize += 8;
01645 
01646     \textcolor{comment}{// Add ZIP64 extra info field for relative offset to local file header of current file}
01647     \textcolor{keywordflow}{if}(zi->ci.pos\_local\_header >= 0xffffffff)
01648       datasize += 8;
01649 
01650     \textcolor{keywordflow}{if}(datasize > 0)
01651     \{
01652       \textcolor{keywordtype}{char}* p = NULL;
01653 
01654       \textcolor{keywordflow}{if}((uLong)(datasize + 4) > zi->ci.size\_centralExtraFree)
01655       \{
01656         \textcolor{comment}{// we can not write more data to the buffer that we have room for.}
01657         \textcolor{keywordflow}{return} ZIP\_BADZIPFILE;
01658       \}
01659 
01660       p = zi->ci.central\_header + zi->ci.size\_centralheader;
01661 
01662       \textcolor{comment}{// Add Extra Information Header for 'ZIP64 information'}
01663       zip64local\_putValue\_inmemory(p, 0x0001, 2); \textcolor{comment}{// HeaderID}
01664       p += 2;
01665       zip64local\_putValue\_inmemory(p, datasize, 2); \textcolor{comment}{// DataSize}
01666       p += 2;
01667 
01668       \textcolor{keywordflow}{if}(uncompressed\_size >= 0xffffffff)
01669       \{
01670         zip64local\_putValue\_inmemory(p, uncompressed\_size, 8);
01671         p += 8;
01672       \}
01673 
01674       \textcolor{keywordflow}{if}(compressed\_size >= 0xffffffff)
01675       \{
01676         zip64local\_putValue\_inmemory(p, compressed\_size, 8);
01677         p += 8;
01678       \}
01679 
01680       \textcolor{keywordflow}{if}(zi->ci.pos\_local\_header >= 0xffffffff)
01681       \{
01682         zip64local\_putValue\_inmemory(p, zi->ci.pos\_local\_header, 8);
01683         p += 8;
01684       \}
01685 
01686       \textcolor{comment}{// Update how much extra free space we got in the memory buffer}
01687       \textcolor{comment}{// and increase the centralheader size so the new ZIP64 fields are included}
01688       \textcolor{comment}{// ( 4 below is the size of HeaderID and DataSize field )}
01689       zi->ci.size\_centralExtraFree -= datasize + 4;
01690       zi->ci.size\_centralheader += datasize + 4;
01691 
01692       \textcolor{comment}{// Update the extra info size field}
01693       zi->ci.size\_centralExtra += datasize + 4;
01694       zip64local\_putValue\_inmemory(zi->ci.central\_header+30,(uLong)zi->ci.size\_centralExtra,2);
01695     \}
01696 
01697     \textcolor{keywordflow}{if} (err==ZIP\_OK)
01698         err = add\_data\_in\_datablock(&zi->central\_dir, zi->ci.central\_header, (uLong)zi->ci.
      size\_centralheader);
01699 
01700     free(zi->ci.central\_header);
01701 
01702     \textcolor{keywordflow}{if} (err==ZIP\_OK)
01703     \{
01704         \textcolor{comment}{// Update the LocalFileHeader with the new values.}
01705 
01706         ZPOS64\_T cur\_pos\_inzip = ZTELL64(zi->z\_filefunc,zi->filestream);
01707 
01708         \textcolor{keywordflow}{if} (ZSEEK64(zi->z\_filefunc,zi->filestream, zi->ci.pos\_local\_header + 14,ZLIB\_FILEFUNC\_SEEK\_SET)!=0)
01709             err = ZIP\_ERRNO;
01710 
01711         \textcolor{keywordflow}{if} (err==ZIP\_OK)
01712             err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,crc32,4); \textcolor{comment}{/* crc 32, unknown */}
01713 
01714         \textcolor{keywordflow}{if}(uncompressed\_size >= 0xffffffff || compressed\_size >= 0xffffffff )
01715         \{
01716           \textcolor{keywordflow}{if}(zi->ci.pos\_zip64extrainfo > 0)
01717           \{
01718             \textcolor{comment}{// Update the size in the ZIP64 extended field.}
01719             \textcolor{keywordflow}{if} (ZSEEK64(zi->z\_filefunc,zi->filestream, zi->ci.pos\_zip64extrainfo + 4,ZLIB\_FILEFUNC\_SEEK\_SET
      )!=0)
01720               err = ZIP\_ERRNO;
01721 
01722             \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* compressed size, unknown */}
01723               err = zip64local\_putValue(&zi->z\_filefunc, zi->filestream, uncompressed\_size, 8);
01724 
01725             \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* uncompressed size, unknown */}
01726               err = zip64local\_putValue(&zi->z\_filefunc, zi->filestream, compressed\_size, 8);
01727           \}
01728           \textcolor{keywordflow}{else}
01729               err = ZIP\_BADZIPFILE; \textcolor{comment}{// Caller passed zip64 = 0, so no room for zip64 info -> fatal}
01730         \}
01731         \textcolor{keywordflow}{else}
01732         \{
01733           \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* compressed size, unknown */}
01734               err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,compressed\_size,4);
01735 
01736           \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* uncompressed size, unknown */}
01737               err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,uncompressed\_size,4);
01738         \}
01739 
01740         \textcolor{keywordflow}{if} (ZSEEK64(zi->z\_filefunc,zi->filestream, cur\_pos\_inzip,ZLIB\_FILEFUNC\_SEEK\_SET)!=0)
01741             err = ZIP\_ERRNO;
01742     \}
01743 
01744     zi->number\_entry ++;
01745     zi->in\_opened\_file\_inzip = 0;
01746 
01747     \textcolor{keywordflow}{return} err;
01748 \}
01749 
01750 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipCloseFileInZip (zipFile \hyperlink{structfile}{file})
01751 \{
01752     \textcolor{keywordflow}{return} zipCloseFileInZipRaw (file,0,0);
01753 \}
01754 
01755 \textcolor{keywordtype}{int} Write\_Zip64EndOfCentralDirectoryLocator(\hyperlink{structzip64__internal}{zip64\_internal}* zi, ZPOS64\_T zip64eocd\_pos\_inzip)
01756 \{
01757   \textcolor{keywordtype}{int} err = ZIP\_OK;
01758   ZPOS64\_T pos = zip64eocd\_pos\_inzip - zi->add\_position\_when\_writing\_offset;
01759 
01760   err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)ZIP64ENDLOCHEADERMAGIC,4);
01761 
01762   \textcolor{comment}{/*num disks*/}
01763     \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* number of the disk with the start of the central directory */}
01764       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)0,4);
01765 
01766   \textcolor{comment}{/*relative offset*/}
01767     \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* Relative offset to the Zip64EndOfCentralDirectory */}
01768       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream, pos,8);
01769 
01770   \textcolor{comment}{/*total disks*/} \textcolor{comment}{/* Do not support spawning of disk so always say 1 here*/}
01771     \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* number of the disk with the start of the central directory */}
01772       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)1,4);
01773 
01774     \textcolor{keywordflow}{return} err;
01775 \}
01776 
01777 \textcolor{keywordtype}{int} Write\_Zip64EndOfCentralDirectoryRecord(\hyperlink{structzip64__internal}{zip64\_internal}* zi, uLong size\_centraldir, 
      ZPOS64\_T centraldir\_pos\_inzip)
01778 \{
01779   \textcolor{keywordtype}{int} err = ZIP\_OK;
01780 
01781   uLong Zip64DataSize = 44;
01782 
01783   err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)ZIP64ENDHEADERMAGIC,4);
01784 
01785   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* size of this 'zip64 end of central directory' */}
01786     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(ZPOS64\_T)Zip64DataSize,8); \textcolor{comment}{// why ZPOS64\_T of
       this ?}
01787 
01788   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* version made by */}
01789     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)45,2);
01790 
01791   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* version needed */}
01792     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)45,2);
01793 
01794   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* number of this disk */}
01795     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)0,4);
01796 
01797   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* number of the disk with the start of the central directory */}
01798     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)0,4);
01799 
01800   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* total number of entries in the central dir on this disk */}
01801     err = zip64local\_putValue(&zi->z\_filefunc, zi->filestream, zi->number\_entry, 8);
01802 
01803   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* total number of entries in the central dir */}
01804     err = zip64local\_putValue(&zi->z\_filefunc, zi->filestream, zi->number\_entry, 8);
01805 
01806   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* size of the central directory */}
01807     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(ZPOS64\_T)size\_centraldir,8);
01808 
01809   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* offset of start of central directory with respect to the starting disk number */}
01810   \{
01811     ZPOS64\_T pos = centraldir\_pos\_inzip - zi->add\_position\_when\_writing\_offset;
01812     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream, (ZPOS64\_T)pos,8);
01813   \}
01814   \textcolor{keywordflow}{return} err;
01815 \}
01816 \textcolor{keywordtype}{int} Write\_EndOfCentralDirectoryRecord(\hyperlink{structzip64__internal}{zip64\_internal}* zi, uLong size\_centraldir, ZPOS64\_T 
      centraldir\_pos\_inzip)
01817 \{
01818   \textcolor{keywordtype}{int} err = ZIP\_OK;
01819 
01820   \textcolor{comment}{/*signature*/}
01821   err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);
01822 
01823   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* number of this disk */}
01824     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)0,2);
01825 
01826   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* number of the disk with the start of the central directory */}
01827     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)0,2);
01828 
01829   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* total number of entries in the central dir on this disk */}
01830   \{
01831     \{
01832       \textcolor{keywordflow}{if}(zi->number\_entry >= 0xFFFF)
01833         err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)0xffff,2); \textcolor{comment}{// use value in ZIP64
       record}
01834       \textcolor{keywordflow}{else}
01835         err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)zi->number\_entry,2);
01836     \}
01837   \}
01838 
01839   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* total number of entries in the central dir */}
01840   \{
01841     \textcolor{keywordflow}{if}(zi->number\_entry >= 0xFFFF)
01842       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)0xffff,2); \textcolor{comment}{// use value in ZIP64
       record}
01843     \textcolor{keywordflow}{else}
01844       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)zi->number\_entry,2);
01845   \}
01846 
01847   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* size of the central directory */}
01848     err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)size\_centraldir,4);
01849 
01850   \textcolor{keywordflow}{if} (err==ZIP\_OK) \textcolor{comment}{/* offset of start of central directory with respect to the starting disk number */}
01851   \{
01852     ZPOS64\_T pos = centraldir\_pos\_inzip - zi->add\_position\_when\_writing\_offset;
01853     \textcolor{keywordflow}{if}(pos >= 0xffffffff)
01854     \{
01855       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream, (uLong)0xffffffff,4);
01856     \}
01857     \textcolor{keywordflow}{else}
01858       err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream, (uLong)(centraldir\_pos\_inzip - zi->
      add\_position\_when\_writing\_offset),4);
01859   \}
01860 
01861    \textcolor{keywordflow}{return} err;
01862 \}
01863 
01864 \textcolor{keywordtype}{int} Write\_GlobalComment(\hyperlink{structzip64__internal}{zip64\_internal}* zi, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* global\_comment)
01865 \{
01866   \textcolor{keywordtype}{int} err = ZIP\_OK;
01867   uInt size\_global\_comment = 0;
01868 
01869   \textcolor{keywordflow}{if}(global\_comment != NULL)
01870     size\_global\_comment = (uInt)strlen(global\_comment);
01871 
01872   err = zip64local\_putValue(&zi->z\_filefunc,zi->filestream,(uLong)size\_global\_comment,2);
01873 
01874   \textcolor{keywordflow}{if} (err == ZIP\_OK && size\_global\_comment > 0)
01875   \{
01876     \textcolor{keywordflow}{if} (ZWRITE64(zi->z\_filefunc,zi->filestream, global\_comment, size\_global\_comment) != size\_global\_comment
      )
01877       err = ZIP\_ERRNO;
01878   \}
01879   \textcolor{keywordflow}{return} err;
01880 \}
01881 
01882 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipClose (zipFile \hyperlink{structfile}{file}, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* global\_comment)
01883 \{
01884     \hyperlink{structzip64__internal}{zip64\_internal}* zi;
01885     \textcolor{keywordtype}{int} err = 0;
01886     uLong size\_centraldir = 0;
01887     ZPOS64\_T centraldir\_pos\_inzip;
01888     ZPOS64\_T pos;
01889 
01890     \textcolor{keywordflow}{if} (\hyperlink{structfile}{file} == NULL)
01891         \textcolor{keywordflow}{return} ZIP\_PARAMERROR;
01892 
01893     zi = (\hyperlink{structzip64__internal}{zip64\_internal}*)\hyperlink{structfile}{file};
01894 
01895     \textcolor{keywordflow}{if} (zi->in\_opened\_file\_inzip == 1)
01896     \{
01897         err = zipCloseFileInZip (\hyperlink{structfile}{file});
01898     \}
01899 
01900 \textcolor{preprocessor}{#ifndef NO\_ADDFILEINEXISTINGZIP}
01901     \textcolor{keywordflow}{if} (global\_comment==NULL)
01902         global\_comment = zi->globalcomment;
01903 \textcolor{preprocessor}{#endif}
01904 
01905     centraldir\_pos\_inzip = ZTELL64(zi->z\_filefunc,zi->filestream);
01906 
01907     \textcolor{keywordflow}{if} (err==ZIP\_OK)
01908     \{
01909         \hyperlink{structlinkedlist__datablock__internal__s}{linkedlist\_datablock\_internal}* ldi = zi->central\_dir.first\_block;
01910         \textcolor{keywordflow}{while} (ldi!=NULL)
01911         \{
01912             \textcolor{keywordflow}{if} ((err==ZIP\_OK) && (ldi->filled\_in\_this\_block>0))
01913             \{
01914                 \textcolor{keywordflow}{if} (ZWRITE64(zi->z\_filefunc,zi->filestream, ldi->data, ldi->filled\_in\_this\_block) != ldi->
      filled\_in\_this\_block)
01915                     err = ZIP\_ERRNO;
01916             \}
01917 
01918             size\_centraldir += ldi->filled\_in\_this\_block;
01919             ldi = ldi->next\_datablock;
01920         \}
01921     \}
01922     free\_linkedlist(&(zi->central\_dir));
01923 
01924     pos = centraldir\_pos\_inzip - zi->add\_position\_when\_writing\_offset;
01925     \textcolor{keywordflow}{if}(pos >= 0xffffffff || zi->number\_entry > 0xFFFF)
01926     \{
01927       ZPOS64\_T Zip64EOCDpos = ZTELL64(zi->z\_filefunc,zi->filestream);
01928       Write\_Zip64EndOfCentralDirectoryRecord(zi, size\_centraldir, centraldir\_pos\_inzip);
01929 
01930       Write\_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);
01931     \}
01932 
01933     \textcolor{keywordflow}{if} (err==ZIP\_OK)
01934       err = Write\_EndOfCentralDirectoryRecord(zi, size\_centraldir, centraldir\_pos\_inzip);
01935 
01936     \textcolor{keywordflow}{if}(err == ZIP\_OK)
01937       err = Write\_GlobalComment(zi, global\_comment);
01938 
01939     \textcolor{keywordflow}{if} (ZCLOSE64(zi->z\_filefunc,zi->filestream) != 0)
01940         \textcolor{keywordflow}{if} (err == ZIP\_OK)
01941             err = ZIP\_ERRNO;
01942 
01943 \textcolor{preprocessor}{#ifndef NO\_ADDFILEINEXISTINGZIP}
01944     TRYFREE(zi->globalcomment);
01945 \textcolor{preprocessor}{#endif}
01946     TRYFREE(zi);
01947 
01948     \textcolor{keywordflow}{return} err;
01949 \}
01950 
01951 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} ZEXPORT zipRemoveExtraInfoBlock (\textcolor{keywordtype}{char}* pData, \textcolor{keywordtype}{int}* dataLen, \textcolor{keywordtype}{short} sHeader)
01952 \{
01953   \textcolor{keywordtype}{char}* p = pData;
01954   \textcolor{keywordtype}{int} size = 0;
01955   \textcolor{keywordtype}{char}* pNewHeader;
01956   \textcolor{keywordtype}{char}* pTmp;
01957   \textcolor{keywordtype}{short} header;
01958   \textcolor{keywordtype}{short} dataSize;
01959 
01960   \textcolor{keywordtype}{int} retVal = ZIP\_OK;
01961 
01962   \textcolor{keywordflow}{if}(pData == NULL || *dataLen < 4)
01963     \textcolor{keywordflow}{return} ZIP\_PARAMERROR;
01964 
01965   pNewHeader = (\textcolor{keywordtype}{char}*)ALLOC(*dataLen);
01966   pTmp = pNewHeader;
01967 
01968   \textcolor{keywordflow}{while}(p < (pData + *dataLen))
01969   \{
01970     header = *(\textcolor{keywordtype}{short}*)p;
01971     dataSize = *(((\textcolor{keywordtype}{short}*)p)+1);
01972 
01973     \textcolor{keywordflow}{if}( header == sHeader ) \textcolor{comment}{// Header found.}
01974     \{
01975       p += dataSize + 4; \textcolor{comment}{// skip it. do not copy to temp buffer}
01976     \}
01977     \textcolor{keywordflow}{else}
01978     \{
01979       \textcolor{comment}{// Extra Info block should not be removed, So copy it to the temp buffer.}
01980       memcpy(pTmp, p, dataSize + 4);
01981       p += dataSize + 4;
01982       size += dataSize + 4;
01983     \}
01984 
01985   \}
01986 
01987   \textcolor{keywordflow}{if}(size < *dataLen)
01988   \{
01989     \textcolor{comment}{// clean old extra info block.}
01990     memset(pData,0, *dataLen);
01991 
01992     \textcolor{comment}{// copy the new extra info block over the old}
01993     \textcolor{keywordflow}{if}(size > 0)
01994       memcpy(pData, pNewHeader, size);
01995 
01996     \textcolor{comment}{// set the new extra info size}
01997     *dataLen = size;
01998 
01999     retVal = ZIP\_OK;
02000   \}
02001   \textcolor{keywordflow}{else}
02002     retVal = ZIP\_ERRNO;
02003 
02004   TRYFREE(pNewHeader);
02005 
02006   \textcolor{keywordflow}{return} retVal;
02007 \}
\end{DoxyCode}
