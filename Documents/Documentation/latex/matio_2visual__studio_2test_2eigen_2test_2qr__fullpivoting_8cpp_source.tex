\hypertarget{matio_2visual__studio_2test_2eigen_2test_2qr__fullpivoting_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/qr\+\_\+fullpivoting.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2qr__fullpivoting_8cpp_source}\index{qr\+\_\+fullpivoting.\+cpp@{qr\+\_\+fullpivoting.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#include "main.h"}
00012 \textcolor{preprocessor}{#include <Eigen/QR>}
00013 
00014 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} qr()
00015 \{
00016   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00017 
00018   Index max\_size = EIGEN\_TEST\_MAX\_SIZE;
00019   Index min\_size = numext::maxi(1,EIGEN\_TEST\_MAX\_SIZE/10);
00020   Index rows  = internal::random<Index>(min\_size,max\_size),
00021         cols  = internal::random<Index>(min\_size,max\_size),
00022         cols2 = internal::random<Index>(min\_size,max\_size),
00023         rank  = internal::random<Index>(1, (std::min)(rows, cols)-1);
00024 
00025   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00026   \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, MatrixType::RowsAtCompileTime>}
       MatrixQType;
00027   MatrixType m1;
00028   \hyperlink{namespace_eigen_a0d9a7ddcee5c7c8defaba3628455efb2}{createRandomPIMatrixOfRank}(rank,rows,cols,m1);
00029   \hyperlink{group___q_r___module}{FullPivHouseholderQR<MatrixType>} qr(m1);
00030   VERIFY\_IS\_EQUAL(rank, qr.rank());
00031   VERIFY\_IS\_EQUAL(cols - qr.rank(), qr.dimensionOfKernel());
00032   VERIFY(!qr.isInjective());
00033   VERIFY(!qr.isInvertible());
00034   VERIFY(!qr.isSurjective());
00035 
00036   MatrixType r = qr.matrixQR();
00037   
00038   MatrixQType q = qr.matrixQ();
00039   VERIFY\_IS\_UNITARY(q);
00040   
00041   \textcolor{comment}{// FIXME need better way to construct trapezoid}
00042   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < rows; i++) for(int j = 0; j < cols; j++) if(i>j) r(i,j) = Scalar(0);
00043 
00044   MatrixType c = qr.matrixQ() * r * qr.colsPermutation().inverse();
00045 
00046   VERIFY\_IS\_APPROX(m1, c);
00047   
00048   \textcolor{comment}{// stress the ReturnByValue mechanism}
00049   MatrixType tmp;
00050   VERIFY\_IS\_APPROX(tmp.noalias() = qr.matrixQ() * r, (qr.matrixQ() * r).eval());
00051   
00052   MatrixType m2 = MatrixType::Random(cols,cols2);
00053   MatrixType m3 = m1*m2;
00054   m2 = MatrixType::Random(cols,cols2);
00055   m2 = qr.solve(m3);
00056   VERIFY\_IS\_APPROX(m3, m1*m2);
00057 
00058   \{
00059     Index size = rows;
00060     \textcolor{keywordflow}{do} \{
00061       m1 = MatrixType::Random(size,size);
00062       qr.compute(m1);
00063     \} \textcolor{keywordflow}{while}(!qr.isInvertible());
00064     MatrixType m1\_inv = qr.inverse();
00065     m3 = m1 * MatrixType::Random(size,cols2);
00066     m2 = qr.solve(m3);
00067     VERIFY\_IS\_APPROX(m2, m1\_inv*m3);
00068   \}
00069 \}
00070 
00071 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} qr\_invertible()
00072 \{
00073   \textcolor{keyword}{using} std::log;
00074   \textcolor{keyword}{using} std::abs;
00075   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename MatrixType::Scalar>::Real}
       RealScalar;
00076   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00077 
00078   Index max\_size = numext::mini(50,EIGEN\_TEST\_MAX\_SIZE);
00079   Index min\_size = numext::maxi(1,EIGEN\_TEST\_MAX\_SIZE/10);
00080   Index size = internal::random<Index>(min\_size,max\_size);
00081 
00082   MatrixType m1(size, size), m2(size, size), m3(size, size);
00083   m1 = MatrixType::Random(size,size);
00084 
00085   \textcolor{keywordflow}{if} (internal::is\_same<RealScalar,float>::value)
00086   \{
00087     \textcolor{comment}{// let's build a matrix more stable to inverse}
00088     MatrixType a = MatrixType::Random(size,size*2);
00089     m1 += a * a.adjoint();
00090   \}
00091 
00092   \hyperlink{group___q_r___module}{FullPivHouseholderQR<MatrixType>} qr(m1);
00093   VERIFY(qr.isInjective());
00094   VERIFY(qr.isInvertible());
00095   VERIFY(qr.isSurjective());
00096 
00097   m3 = MatrixType::Random(size,size);
00098   m2 = qr.solve(m3);
00099   VERIFY\_IS\_APPROX(m3, m1*m2);
00100 
00101   \textcolor{comment}{// now construct a matrix with prescribed determinant}
00102   m1.setZero();
00103   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) m1(i,i) = internal::random<Scalar>();
00104   RealScalar absdet = abs(m1.diagonal().prod());
00105   m3 = qr.matrixQ(); \textcolor{comment}{// get a unitary}
00106   m1 = m3 * m1 * m3;
00107   qr.compute(m1);
00108   VERIFY\_IS\_APPROX(absdet, qr.absDeterminant());
00109   VERIFY\_IS\_APPROX(\hyperlink{structlog}{log}(absdet), qr.logAbsDeterminant());
00110 \}
00111 
00112 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keywordtype}{void} qr\_verify\_assert()
00113 \{
00114   MatrixType tmp;
00115 
00116   \hyperlink{group___q_r___module}{FullPivHouseholderQR<MatrixType>} qr;
00117   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a9c16411e5d8f1fc634a5797018d5aa3e}{matrixQR}())
00118   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a6f1b0a116c78e642e3d2a100a29d1a4a}{solve}(tmp))
00119   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_ad26dd2d3c002939771d2375e4e051c28}{matrixQ}())
00120   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a3b5fe5edc66acc01c45b16e728470aa0}{dimensionOfKernel}())
00121   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a6776788011026b0f63192485a59deaed}{isInjective}())
00122   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_aa3593db4708ce9079b0bdf219b99f57e}{isSurjective}())
00123   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_aeb1d779ec22ec68a5a28d4235db02ec1}{isInvertible}())
00124   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a352ce66397af06da214ddde343cec6f5}{inverse}())
00125   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_a1029e1ccc70bb8669043c5775e7f3b75}{absDeterminant}())
00126   VERIFY\_RAISES\_ASSERT(qr.\hyperlink{group___q_r___module_aafde38918912c9b562f44b0fc3b22589}{logAbsDeterminant}())
00127 \}
00128 
00129 \textcolor{keywordtype}{void} test\_qr\_fullpivoting()
00130 \{
00131  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 1; i++) \{
00132     \textcolor{comment}{// FIXME : very weird bug here}
00133 \textcolor{comment}{//     CALL\_SUBTEST(qr(Matrix2f()) );}
00134     CALL\_SUBTEST\_1( qr<MatrixXf>() );
00135     CALL\_SUBTEST\_2( qr<MatrixXd>() );
00136     CALL\_SUBTEST\_3( qr<MatrixXcd>() );
00137   \}
00138 
00139   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00140     CALL\_SUBTEST\_1( qr\_invertible<MatrixXf>() );
00141     CALL\_SUBTEST\_2( qr\_invertible<MatrixXd>() );
00142     CALL\_SUBTEST\_4( qr\_invertible<MatrixXcf>() );
00143     CALL\_SUBTEST\_3( qr\_invertible<MatrixXcd>() );
00144   \}
00145 
00146   CALL\_SUBTEST\_5(qr\_verify\_assert<Matrix3f>());
00147   CALL\_SUBTEST\_6(qr\_verify\_assert<Matrix3d>());
00148   CALL\_SUBTEST\_1(qr\_verify\_assert<MatrixXf>());
00149   CALL\_SUBTEST\_2(qr\_verify\_assert<MatrixXd>());
00150   CALL\_SUBTEST\_4(qr\_verify\_assert<MatrixXcf>());
00151   CALL\_SUBTEST\_3(qr\_verify\_assert<MatrixXcd>());
00152 
00153   \textcolor{comment}{// Test problem size constructors}
00154   CALL\_SUBTEST\_7(\hyperlink{group___q_r___module_class_eigen_1_1_full_piv_householder_q_r}{FullPivHouseholderQR<MatrixXf>}(10, 20));
00155   CALL\_SUBTEST\_7((\hyperlink{group___q_r___module_class_eigen_1_1_full_piv_householder_q_r}{FullPivHouseholderQR}<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,10,20>} >(10,20))
      );
00156   CALL\_SUBTEST\_7((\hyperlink{group___q_r___module_class_eigen_1_1_full_piv_householder_q_r}{FullPivHouseholderQR}<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,10,20>} >(
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,10,20>::Random}())));
00157   CALL\_SUBTEST\_7((\hyperlink{group___q_r___module_class_eigen_1_1_full_piv_householder_q_r}{FullPivHouseholderQR}<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,20,10>} >(20,10))
      );
00158   CALL\_SUBTEST\_7((\hyperlink{group___q_r___module_class_eigen_1_1_full_piv_householder_q_r}{FullPivHouseholderQR}<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,20,10>} >(
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<float,20,10>::Random}())));
00159 \}
\end{DoxyCode}
