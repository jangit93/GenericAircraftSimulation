\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2products_2_general_matrix_vector___b_l_a_s_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/products/\+General\+Matrix\+Vector\+\_\+\+B\+L\+AS.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2products_2_general_matrix_vector___b_l_a_s_8h_source}\index{General\+Matrix\+Vector\+\_\+\+B\+L\+A\+S.\+h@{General\+Matrix\+Vector\+\_\+\+B\+L\+A\+S.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ Copyright (c) 2011, Intel Corporation. All rights reserved.}
00003 \textcolor{comment}{}
00004 \textcolor{comment}{ Redistribution and use in source and binary forms, with or without modification,}
00005 \textcolor{comment}{ are permitted provided that the following conditions are met:}
00006 \textcolor{comment}{}
00007 \textcolor{comment}{ * Redistributions of source code must retain the above copyright notice, this}
00008 \textcolor{comment}{   list of conditions and the following disclaimer.}
00009 \textcolor{comment}{ * Redistributions in binary form must reproduce the above copyright notice,}
00010 \textcolor{comment}{   this list of conditions and the following disclaimer in the documentation}
00011 \textcolor{comment}{   and/or other materials provided with the distribution.}
00012 \textcolor{comment}{ * Neither the name of Intel Corporation nor the names of its contributors may}
00013 \textcolor{comment}{   be used to endorse or promote products derived from this software without}
00014 \textcolor{comment}{   specific prior written permission.}
00015 \textcolor{comment}{}
00016 \textcolor{comment}{ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND}
00017 \textcolor{comment}{ ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED}
00018 \textcolor{comment}{ WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE}
00019 \textcolor{comment}{ DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR}
00020 \textcolor{comment}{ ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES}
00021 \textcolor{comment}{ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;}
00022 \textcolor{comment}{ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON}
00023 \textcolor{comment}{ ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}
00024 \textcolor{comment}{ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS}
00025 \textcolor{comment}{ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}
00026 \textcolor{comment}{}
00027 \textcolor{comment}{ ********************************************************************************}
00028 \textcolor{comment}{ *   Content : Eigen bindings to BLAS F77}
00029 \textcolor{comment}{ *   General matrix-vector product functionality based on ?GEMV.}
00030 \textcolor{comment}{ ********************************************************************************}
00031 \textcolor{comment}{*/}
00032 
00033 \textcolor{preprocessor}{#ifndef EIGEN\_GENERAL\_MATRIX\_VECTOR\_BLAS\_H}
00034 \textcolor{preprocessor}{#define EIGEN\_GENERAL\_MATRIX\_VECTOR\_BLAS\_H}
00035 
00036 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00037 
00038 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00039 
00040 \textcolor{comment}{/**********************************************************************}
00041 \textcolor{comment}{* This file implements general matrix-vector multiplication using BLAS}
00042 \textcolor{comment}{* gemv function via partial specialization of}
00043 \textcolor{comment}{* general\_matrix\_vector\_product::run(..) method for float, double,}
00044 \textcolor{comment}{* std::complex<float> and std::complex<double> types}
00045 \textcolor{comment}{**********************************************************************/}
00046 
00047 \textcolor{comment}{// gemv specialization}
00048 
00049 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} LhsScalar, \textcolor{keywordtype}{int} StorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs, \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{bool} 
      ConjugateRhs>
00050 \textcolor{keyword}{struct }general\_matrix\_vector\_product\_gemv;
00051 
00052 \textcolor{preprocessor}{#define EIGEN\_BLAS\_GEMV\_SPECIALIZE(Scalar) \(\backslash\)}
00053 \textcolor{preprocessor}{template<typename Index, bool ConjugateLhs, bool ConjugateRhs> \(\backslash\)}
00054 \textcolor{preprocessor}{struct
       general\_matrix\_vector\_product<Index,Scalar,const\_blas\_data\_mapper<Scalar,Index,ColMajor>,ColMajor,ConjugateLhs,Scalar,const\_blas\_data\_mapper<Scalar,Index,RowMajor>,ConjugateRhs,Specialized> \{ \(\backslash\)}
00055 \textcolor{preprocessor}{static void run( \(\backslash\)}
00056 \textcolor{preprocessor}{  Index rows, Index cols, \(\backslash\)}
00057 \textcolor{preprocessor}{  const const\_blas\_data\_mapper<Scalar,Index,ColMajor> &lhs, \(\backslash\)}
00058 \textcolor{preprocessor}{  const const\_blas\_data\_mapper<Scalar,Index,RowMajor> &rhs, \(\backslash\)}
00059 \textcolor{preprocessor}{  Scalar* res, Index resIncr, Scalar alpha) \(\backslash\)}
00060 \textcolor{preprocessor}{\{ \(\backslash\)}
00061 \textcolor{preprocessor}{  if (ConjugateLhs) \{ \(\backslash\)}
00062 \textcolor{preprocessor}{   
       general\_matrix\_vector\_product<Index,Scalar,const\_blas\_data\_mapper<Scalar,Index,ColMajor>,ColMajor,ConjugateLhs,Scalar,const\_blas\_data\_mapper<Scalar,Index,RowMajor>,ConjugateRhs,BuiltIn>::run( \(\backslash\)}
00063 \textcolor{preprocessor}{      rows, cols, lhs, rhs, res, resIncr, alpha); \(\backslash\)}
00064 \textcolor{preprocessor}{  \} else \{ \(\backslash\)}
00065 \textcolor{preprocessor}{    general\_matrix\_vector\_product\_gemv<Index,Scalar,ColMajor,ConjugateLhs,Scalar,ConjugateRhs>::run( \(\backslash\)}
00066 \textcolor{preprocessor}{      rows, cols, lhs.data(), lhs.stride(), rhs.data(), rhs.stride(), res, resIncr, alpha); \(\backslash\)}
00067 \textcolor{preprocessor}{  \} \(\backslash\)}
00068 \textcolor{preprocessor}{\} \(\backslash\)}
00069 \textcolor{preprocessor}{\}; \(\backslash\)}
00070 \textcolor{preprocessor}{template<typename Index, bool ConjugateLhs, bool ConjugateRhs> \(\backslash\)}
00071 \textcolor{preprocessor}{struct
       general\_matrix\_vector\_product<Index,Scalar,const\_blas\_data\_mapper<Scalar,Index,RowMajor>,RowMajor,ConjugateLhs,Scalar,const\_blas\_data\_mapper<Scalar,Index,ColMajor>,ConjugateRhs,Specialized> \{ \(\backslash\)}
00072 \textcolor{preprocessor}{static void run( \(\backslash\)}
00073 \textcolor{preprocessor}{  Index rows, Index cols, \(\backslash\)}
00074 \textcolor{preprocessor}{  const const\_blas\_data\_mapper<Scalar,Index,RowMajor> &lhs, \(\backslash\)}
00075 \textcolor{preprocessor}{  const const\_blas\_data\_mapper<Scalar,Index,ColMajor> &rhs, \(\backslash\)}
00076 \textcolor{preprocessor}{  Scalar* res, Index resIncr, Scalar alpha) \(\backslash\)}
00077 \textcolor{preprocessor}{\{ \(\backslash\)}
00078 \textcolor{preprocessor}{    general\_matrix\_vector\_product\_gemv<Index,Scalar,RowMajor,ConjugateLhs,Scalar,ConjugateRhs>::run( \(\backslash\)}
00079 \textcolor{preprocessor}{      rows, cols, lhs.data(), lhs.stride(), rhs.data(), rhs.stride(), res, resIncr, alpha); \(\backslash\)}
00080 \textcolor{preprocessor}{\} \(\backslash\)}
00081 \textcolor{preprocessor}{\}; \(\backslash\)}
00082 \textcolor{preprocessor}{}
00083 EIGEN\_BLAS\_GEMV\_SPECIALIZE(\textcolor{keywordtype}{double})
00084 EIGEN\_BLAS\_GEMV\_SPECIALIZE(\textcolor{keywordtype}{float})
00085 EIGEN\_BLAS\_GEMV\_SPECIALIZE(dcomplex)
00086 EIGEN\_BLAS\_GEMV\_SPECIALIZE(scomplex)
00087 
00088 \textcolor{preprocessor}{#define EIGEN\_BLAS\_GEMV\_SPECIALIZATION(EIGTYPE,BLASTYPE,BLASPREFIX) \(\backslash\)}
00089 \textcolor{preprocessor}{template<typename Index, int LhsStorageOrder, bool ConjugateLhs, bool ConjugateRhs> \(\backslash\)}
00090 \textcolor{preprocessor}{struct general\_matrix\_vector\_product\_gemv<Index,EIGTYPE,LhsStorageOrder,ConjugateLhs,EIGTYPE,ConjugateRhs> 
      \(\backslash\)}
00091 \textcolor{preprocessor}{\{ \(\backslash\)}
00092 \textcolor{preprocessor}{typedef Matrix<EIGTYPE,Dynamic,1,ColMajor> GEMVVector;\(\backslash\)}
00093 \textcolor{preprocessor}{\(\backslash\)}
00094 \textcolor{preprocessor}{static void run( \(\backslash\)}
00095 \textcolor{preprocessor}{  Index rows, Index cols, \(\backslash\)}
00096 \textcolor{preprocessor}{  const EIGTYPE* lhs, Index lhsStride, \(\backslash\)}
00097 \textcolor{preprocessor}{  const EIGTYPE* rhs, Index rhsIncr, \(\backslash\)}
00098 \textcolor{preprocessor}{  EIGTYPE* res, Index resIncr, EIGTYPE alpha) \(\backslash\)}
00099 \textcolor{preprocessor}{\{ \(\backslash\)}
00100 \textcolor{preprocessor}{  BlasIndex m=convert\_index<BlasIndex>(rows), n=convert\_index<BlasIndex>(cols), \(\backslash\)}
00101 \textcolor{preprocessor}{            lda=convert\_index<BlasIndex>(lhsStride), incx=convert\_index<BlasIndex>(rhsIncr),
       incy=convert\_index<BlasIndex>(resIncr); \(\backslash\)}
00102 \textcolor{preprocessor}{  const EIGTYPE beta(1); \(\backslash\)}
00103 \textcolor{preprocessor}{  const EIGTYPE *x\_ptr; \(\backslash\)}
00104 \textcolor{preprocessor}{  char trans=(LhsStorageOrder==ColMajor) ? 'N' : (ConjugateLhs) ? 'C' : 'T'; \(\backslash\)}
00105 \textcolor{preprocessor}{  if (LhsStorageOrder==RowMajor) \{ \(\backslash\)}
00106 \textcolor{preprocessor}{    m = convert\_index<BlasIndex>(cols); \(\backslash\)}
00107 \textcolor{preprocessor}{    n = convert\_index<BlasIndex>(rows); \(\backslash\)}
00108 \textcolor{preprocessor}{  \}\(\backslash\)}
00109 \textcolor{preprocessor}{  GEMVVector x\_tmp; \(\backslash\)}
00110 \textcolor{preprocessor}{  if (ConjugateRhs) \{ \(\backslash\)}
00111 \textcolor{preprocessor}{    Map<const GEMVVector, 0, InnerStride<> > map\_x(rhs,cols,1,InnerStride<>(incx)); \(\backslash\)}
00112 \textcolor{preprocessor}{    x\_tmp=map\_x.conjugate(); \(\backslash\)}
00113 \textcolor{preprocessor}{    x\_ptr=x\_tmp.data(); \(\backslash\)}
00114 \textcolor{preprocessor}{    incx=1; \(\backslash\)}
00115 \textcolor{preprocessor}{  \} else x\_ptr=rhs; \(\backslash\)}
00116 \textcolor{preprocessor}{  BLASPREFIX##gemv\_(&trans, &m, &n, &numext::real\_ref(alpha), (const BLASTYPE*)lhs, &lda, (const
       BLASTYPE*)x\_ptr, &incx, &numext::real\_ref(beta), (BLASTYPE*)res, &incy); \(\backslash\)}
00117 \textcolor{preprocessor}{\}\(\backslash\)}
00118 \textcolor{preprocessor}{\};}
00119 
00120 EIGEN\_BLAS\_GEMV\_SPECIALIZATION(\textcolor{keywordtype}{double},   \textcolor{keywordtype}{double}, d)
00121 EIGEN\_BLAS\_GEMV\_SPECIALIZATION(\textcolor{keywordtype}{float},    \textcolor{keywordtype}{float},  s)
00122 EIGEN\_BLAS\_GEMV\_SPECIALIZATION(dcomplex, \textcolor{keywordtype}{double}, z)
00123 EIGEN\_BLAS\_GEMV\_SPECIALIZATION(scomplex, \textcolor{keywordtype}{float},  c)
00124 
00125 \} \textcolor{comment}{// end namespase internal}
00126 
00127 \} \textcolor{comment}{// end namespace Eigen}
00128 
00129 \textcolor{preprocessor}{#endif // EIGEN\_GENERAL\_MATRIX\_VECTOR\_BLAS\_H}
\end{DoxyCode}
