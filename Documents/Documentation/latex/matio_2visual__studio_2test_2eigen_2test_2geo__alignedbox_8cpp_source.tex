\hypertarget{matio_2visual__studio_2test_2eigen_2test_2geo__alignedbox_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/geo\+\_\+alignedbox.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2geo__alignedbox_8cpp_source}\index{geo\+\_\+alignedbox.\+cpp@{geo\+\_\+alignedbox.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 \textcolor{preprocessor}{#include <Eigen/Geometry>}
00012 \textcolor{preprocessor}{#include <Eigen/LU>}
00013 \textcolor{preprocessor}{#include <Eigen/QR>}
00014 
00015 \textcolor{preprocessor}{#include<iostream>}
00016 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00017 
00018 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> EIGEN\_DONT\_INLINE
00019 \textcolor{keywordtype}{void} kill\_extra\_precision(\hyperlink{group___sparse_core___module}{T}& x) \{ eigen\_assert((\textcolor{keywordtype}{void}*)(&x) != (\textcolor{keywordtype}{void}*)0); \}
00020 
00021 
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BoxType> \textcolor{keywordtype}{void} alignedbox(\textcolor{keyword}{const} BoxType& \_box)
00023 \{
00024   \textcolor{comment}{/* this test covers the following files:}
00025 \textcolor{comment}{     AlignedBox.h}
00026 \textcolor{comment}{  */}
00027   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BoxType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};  
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BoxType::Scalar Scalar;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00030   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, BoxType::AmbientDimAtCompileTime, 1>}
       \hyperlink{struct_vector_type}{VectorType};
00031 
00032   \textcolor{keyword}{const} Index dim = \_box.dim();
00033 
00034   VectorType p0 = VectorType::Random(dim);
00035   VectorType p1 = VectorType::Random(dim);
00036   \textcolor{keywordflow}{while}( p1 == p0 )\{
00037       p1 =  VectorType::Random(dim); \}
00038   RealScalar s1 = internal::random<RealScalar>(0,1);
00039 
00040   BoxType b0(dim);
00041   BoxType b1(VectorType::Random(dim),VectorType::Random(dim));
00042   BoxType b2;
00043   
00044   kill\_extra\_precision(b1);
00045   kill\_extra\_precision(p0);
00046   kill\_extra\_precision(p1);
00047 
00048   b0.extend(p0);
00049   b0.extend(p1);
00050   VERIFY(b0.contains(p0*s1+(Scalar(1)-s1)*p1));
00051   VERIFY(b0.contains(b0.center()));
00052   VERIFY\_IS\_APPROX(b0.center(),(p0+p1)/Scalar(2));
00053 
00054   (b2 = b0).extend(b1);
00055   VERIFY(b2.contains(b0));
00056   VERIFY(b2.contains(b1));
00057   VERIFY\_IS\_APPROX(b2.clamp(b0), b0);
00058 
00059   \textcolor{comment}{// intersection}
00060   BoxType box1(VectorType::Random(dim));
00061   box1.extend(VectorType::Random(dim));
00062   BoxType box2(VectorType::Random(dim));
00063   box2.extend(VectorType::Random(dim));
00064 
00065   VERIFY(box1.intersects(box2) == !box1.intersection(box2).isEmpty()); 
00066 
00067   \textcolor{comment}{// alignment -- make sure there is no memory alignment assertion}
00068   BoxType *bp0 = \textcolor{keyword}{new} BoxType(dim);
00069   BoxType *bp1 = \textcolor{keyword}{new} BoxType(dim);
00070   bp0->extend(*bp1);
00071   \textcolor{keyword}{delete} bp0;
00072   \textcolor{keyword}{delete} bp1;
00073 
00074   \textcolor{comment}{// sampling}
00075   \textcolor{keywordflow}{for}( \textcolor{keywordtype}{int} i=0; i<10; ++i )
00076   \{
00077       VectorType r = b0.sample();
00078       VERIFY(b0.contains(r));
00079   \}
00080 
00081 \}
00082 
00083 
00084 
00085 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BoxType>
00086 \textcolor{keywordtype}{void} alignedboxCastTests(\textcolor{keyword}{const} BoxType& \_box)
00087 \{
00088   \textcolor{comment}{// casting  }
00089   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BoxType::Index Index;
00090   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} BoxType::Scalar Scalar;
00091   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, BoxType::AmbientDimAtCompileTime, 1>}
       VectorType;
00092 
00093   \textcolor{keyword}{const} Index dim = \_box.dim();
00094 
00095   VectorType p0 = VectorType::Random(dim);
00096   VectorType p1 = VectorType::Random(dim);
00097 
00098   BoxType b0(dim);
00099 
00100   b0.extend(p0);
00101   b0.extend(p1);
00102 
00103   \textcolor{keyword}{const} \textcolor{keywordtype}{int} Dim = BoxType::AmbientDimAtCompileTime;
00104   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_get_different_type}{GetDifferentType<Scalar>::type} OtherScalar;
00105   \hyperlink{group___geometry___module_class_eigen_1_1_aligned_box}{AlignedBox<OtherScalar,Dim>} hp1f = b0.template cast<OtherScalar>();
00106   VERIFY\_IS\_APPROX(hp1f.template cast<Scalar>(),b0);
00107   \hyperlink{group___geometry___module_class_eigen_1_1_aligned_box}{AlignedBox<Scalar,Dim>} hp1d = b0.template cast<Scalar>();
00108   VERIFY\_IS\_APPROX(hp1d.template cast<Scalar>(),b0);
00109 \}
00110 
00111 
00112 \textcolor{keywordtype}{void} specificTest1()
00113 \{
00114     Vector2f m; m << -1.0f, -2.0f;
00115     Vector2f \hyperlink{group___core___module_class_eigen_1_1_matrix}{M}; M <<  1.0f,  5.0f;
00116 
00117     \textcolor{keyword}{typedef} AlignedBox2f  BoxType;
00118     BoxType box( m, M );
00119 
00120     Vector2f sides = M-m;
00121     VERIFY\_IS\_APPROX(sides, box.sizes() );
00122     VERIFY\_IS\_APPROX(sides[1], box.sizes()[1] );
00123     VERIFY\_IS\_APPROX(sides[1], box.sizes().maxCoeff() );
00124     VERIFY\_IS\_APPROX(sides[0], box.sizes().minCoeff() );
00125 
00126     VERIFY\_IS\_APPROX( 14.0f, box.volume() );
00127     VERIFY\_IS\_APPROX( 53.0f, box.diagonal().squaredNorm() );
00128     VERIFY\_IS\_APPROX( std::sqrt( 53.0f ), box.diagonal().norm() );
00129 
00130     VERIFY\_IS\_APPROX( m, box.corner( BoxType::BottomLeft ) );
00131     VERIFY\_IS\_APPROX( M, box.corner( BoxType::TopRight ) );
00132     Vector2f bottomRight; bottomRight << M[0], m[1];
00133     Vector2f topLeft; topLeft << m[0], M[1];
00134     VERIFY\_IS\_APPROX( bottomRight, box.corner( BoxType::BottomRight ) );
00135     VERIFY\_IS\_APPROX( topLeft, box.corner( BoxType::TopLeft ) );
00136 \}
00137 
00138 
00139 \textcolor{keywordtype}{void} specificTest2()
00140 \{
00141     Vector3i m; m << -1, -2, 0;
00142     Vector3i M; M <<  1,  5, 3;
00143 
00144     \textcolor{keyword}{typedef} AlignedBox3i  BoxType;
00145     BoxType box( m, M );
00146 
00147     Vector3i sides = M-m;
00148     VERIFY\_IS\_APPROX(sides, box.sizes() );
00149     VERIFY\_IS\_APPROX(sides[1], box.sizes()[1] );
00150     VERIFY\_IS\_APPROX(sides[1], box.sizes().maxCoeff() );
00151     VERIFY\_IS\_APPROX(sides[0], box.sizes().minCoeff() );
00152 
00153     VERIFY\_IS\_APPROX( 42, box.volume() );
00154     VERIFY\_IS\_APPROX( 62, box.diagonal().squaredNorm() );
00155 
00156     VERIFY\_IS\_APPROX( m, box.corner( BoxType::BottomLeftFloor ) );
00157     VERIFY\_IS\_APPROX( M, box.corner( BoxType::TopRightCeil ) );
00158     Vector3i bottomRightFloor; bottomRightFloor << M[0], m[1], m[2];
00159     Vector3i topLeftFloor; topLeftFloor << m[0], M[1], m[2];
00160     VERIFY\_IS\_APPROX( bottomRightFloor, box.corner( BoxType::BottomRightFloor ) );
00161     VERIFY\_IS\_APPROX( topLeftFloor, box.corner( BoxType::TopLeftFloor ) );
00162 \}
00163 
00164 
00165 \textcolor{keywordtype}{void} test\_geo\_alignedbox()
00166 \{
00167   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++)
00168   \{
00169     CALL\_SUBTEST\_1( alignedbox(AlignedBox2f()) );
00170     CALL\_SUBTEST\_2( alignedboxCastTests(AlignedBox2f()) );
00171 
00172     CALL\_SUBTEST\_3( alignedbox(AlignedBox3f()) );
00173     CALL\_SUBTEST\_4( alignedboxCastTests(AlignedBox3f()) );
00174 
00175     CALL\_SUBTEST\_5( alignedbox(AlignedBox4d()) );
00176     CALL\_SUBTEST\_6( alignedboxCastTests(AlignedBox4d()) );
00177 
00178     CALL\_SUBTEST\_7( alignedbox(AlignedBox1d()) );
00179     CALL\_SUBTEST\_8( alignedboxCastTests(AlignedBox1d()) );
00180 
00181     CALL\_SUBTEST\_9( alignedbox(AlignedBox1i()) );
00182     CALL\_SUBTEST\_10( alignedbox(AlignedBox2i()) );
00183     CALL\_SUBTEST\_11( alignedbox(AlignedBox3i()) );
00184 
00185     CALL\_SUBTEST\_14( alignedbox(\hyperlink{group___geometry___module_class_eigen_1_1_aligned_box}{AlignedBox<double,Dynamic>}(4)) );
00186   \}
00187   CALL\_SUBTEST\_12( specificTest1() );
00188   CALL\_SUBTEST\_13( specificTest2() );
00189 \}
\end{DoxyCode}
