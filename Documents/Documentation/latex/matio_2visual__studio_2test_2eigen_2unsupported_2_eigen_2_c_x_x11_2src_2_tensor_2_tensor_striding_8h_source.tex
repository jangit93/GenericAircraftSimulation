\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_striding_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Striding.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_striding_8h_source}\index{Tensor\+Striding.\+h@{Tensor\+Striding.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_STRIDING\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_STRIDING\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} XprType>
00024 \textcolor{keyword}{struct }traits<TensorStridingOp<Strides, XprType> > : \textcolor{keyword}{public} traits<XprType>
00025 \{
00026   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00027   \textcolor{keyword}{typedef} traits<XprType> XprTraits;
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<Nested>::type \_Nested;
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00034 \};
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} XprType>
00037 \textcolor{keyword}{struct }eval<TensorStridingOp<Strides, XprType>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00038 \{
00039   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorStridingOp<Strides, XprType>& type;
00040 \};
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} XprType>
00043 \textcolor{keyword}{struct }nested<TensorStridingOp<Strides, XprType>, 1, typename eval<TensorStridingOp<Strides, XprType> >::
      type>
00044 \{
00045   \textcolor{keyword}{typedef} TensorStridingOp<Strides, XprType> type;
00046 \};
00047 
00048 \}  \textcolor{comment}{// end namespace internal}
00049 
00050 
00051 
00052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} XprType>
00053 \textcolor{keyword}{class }TensorStridingOp : \textcolor{keyword}{public} TensorBase<TensorStridingOp<Strides, XprType> >
00054 \{
00055   \textcolor{keyword}{public}:
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorStridingOp>::Scalar}
       Scalar;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorStridingOp>::type}
       Nested;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorStridingOp>::StorageKind}
       StorageKind;
00061   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorStridingOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00062 
00063   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorStridingOp(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} Strides& dims)
00064       : m\_xpr(expr), m\_dims(dims) \{\}
00065 
00066     EIGEN\_DEVICE\_FUNC
00067     \textcolor{keyword}{const} Strides& strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dims; \}
00068 
00069     EIGEN\_DEVICE\_FUNC
00070     \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type&
00071     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00072 
00073     EIGEN\_DEVICE\_FUNC
00074     EIGEN\_STRONG\_INLINE TensorStridingOp& operator = (\textcolor{keyword}{const} TensorStridingOp& other)
00075     \{
00076       \textcolor{keyword}{typedef} TensorAssignOp<TensorStridingOp, const TensorStridingOp> Assign;
00077       Assign assign(*\textcolor{keyword}{this}, other);
00078       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00079       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00080     \}
00081 
00082     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00083     EIGEN\_DEVICE\_FUNC
00084     EIGEN\_STRONG\_INLINE TensorStridingOp& operator = (\textcolor{keyword}{const} OtherDerived& other)
00085     \{
00086       \textcolor{keyword}{typedef} TensorAssignOp<TensorStridingOp, const OtherDerived> Assign;
00087       Assign assign(*\textcolor{keyword}{this}, other);
00088       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00089       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00090     \}
00091 
00092   \textcolor{keyword}{protected}:
00093     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00094     \textcolor{keyword}{const} Strides m\_dims;
00095 \};
00096 
00097 
00098 \textcolor{comment}{// Eval as rvalue}
00099 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00100 \textcolor{keyword}{struct }TensorEvaluator<const TensorStridingOp<Strides, ArgType>, Device>
00101 \{
00102   \textcolor{keyword}{typedef} TensorStridingOp<Strides, ArgType> XprType;
00103   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00104   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::array\_size<typename TensorEvaluator<ArgType, Device>::Dimensions>
      ::value;
00105   \textcolor{keyword}{typedef} DSizes<Index, NumDims> Dimensions;
00106   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00107   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00108   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00109   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = internal::unpacket\_traits<PacketReturnType>::size;
00110 
00111   \textcolor{keyword}{enum} \{
00112     IsAligned = \textcolor{comment}{/*TensorEvaluator<ArgType, Device>::IsAligned*/}\textcolor{keyword}{false},
00113     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00114     Layout = TensorEvaluator<ArgType, Device>::Layout,
00115     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00116     RawAccess = \textcolor{keyword}{false}
00117   \};
00118 
00119   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00120       : m\_impl(op.expression(), device)
00121   \{
00122     m\_dimensions = m\_impl.dimensions();
00123     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i) \{
00124       m\_dimensions[i] = ceilf(static\_cast<float>(m\_dimensions[i]) / op.strides()[i]);
00125     \}
00126 
00127     \textcolor{keyword}{const} \textcolor{keyword}{typename} TensorEvaluator<ArgType, Device>::Dimensions& input\_dims = m\_impl.dimensions();
00128     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00129       m\_outputStrides[0] = 1;
00130       m\_inputStrides[0] = 1;
00131       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00132         m\_outputStrides[i] = m\_outputStrides[i-1] * m\_dimensions[i-1];
00133         m\_inputStrides[i] = m\_inputStrides[i-1] * input\_dims[i-1];
00134         m\_inputStrides[i-1] *= op.strides()[i-1];
00135       \}
00136       m\_inputStrides[NumDims-1] *= op.strides()[NumDims-1];
00137     \} \textcolor{keywordflow}{else} \{  \textcolor{comment}{// RowMajor}
00138       m\_outputStrides[NumDims-1] = 1;
00139       m\_inputStrides[NumDims-1] = 1;
00140       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00141         m\_outputStrides[i] = m\_outputStrides[i+1] * m\_dimensions[i+1];
00142         m\_inputStrides[i] = m\_inputStrides[i+1] * input\_dims[i+1];
00143         m\_inputStrides[i+1] *= op.strides()[i+1];
00144       \}
00145       m\_inputStrides[0] *= op.strides()[0];
00146     \}
00147   \}
00148 
00149   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00150 
00151   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/}) \{
00152     m\_impl.evalSubExprsIfNeeded(NULL);
00153     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00154   \}
00155   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00156     m\_impl.cleanup();
00157   \}
00158 
00159   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00160 \textcolor{keyword}{  }\{
00161     \textcolor{keywordflow}{return} m\_impl.coeff(srcCoeff(index));
00162   \}
00163 
00164   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00165   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00166 \textcolor{keyword}{  }\{
00167     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00168     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00169 
00170     Index inputIndices[] = \{0, 0\};
00171     Index indices[] = \{index, index + PacketSize - 1\};
00172     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00173       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00174         \textcolor{keyword}{const} Index idx0 = indices[0] / m\_outputStrides[i];
00175         \textcolor{keyword}{const} Index idx1 = indices[1] / m\_outputStrides[i];
00176         inputIndices[0] += idx0 * m\_inputStrides[i];
00177         inputIndices[1] += idx1 * m\_inputStrides[i];
00178         indices[0] -= idx0 * m\_outputStrides[i];
00179         indices[1] -= idx1 * m\_outputStrides[i];
00180       \}
00181       inputIndices[0] += indices[0] * m\_inputStrides[0];
00182       inputIndices[1] += indices[1] * m\_inputStrides[0];
00183     \} \textcolor{keywordflow}{else} \{  \textcolor{comment}{// RowMajor}
00184       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00185         \textcolor{keyword}{const} Index idx0 = indices[0] / m\_outputStrides[i];
00186         \textcolor{keyword}{const} Index idx1 = indices[1] / m\_outputStrides[i];
00187         inputIndices[0] += idx0 * m\_inputStrides[i];
00188         inputIndices[1] += idx1 * m\_inputStrides[i];
00189         indices[0] -= idx0 * m\_outputStrides[i];
00190         indices[1] -= idx1 * m\_outputStrides[i];
00191       \}
00192       inputIndices[0] += indices[0] * m\_inputStrides[NumDims-1];
00193       inputIndices[1] += indices[1] * m\_inputStrides[NumDims-1];
00194     \}
00195     \textcolor{keywordflow}{if} (inputIndices[1] - inputIndices[0] == PacketSize - 1) \{
00196       PacketReturnType rslt = m\_impl.template packet<Unaligned>(inputIndices[0]);
00197       \textcolor{keywordflow}{return} rslt;
00198     \}
00199     \textcolor{keywordflow}{else} \{
00200       EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} internal::remove\_const<CoeffReturnType>::type values[PacketSize];
00201       values[0] = m\_impl.coeff(inputIndices[0]);
00202       values[PacketSize-1] = m\_impl.coeff(inputIndices[1]);
00203       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < PacketSize-1; ++i) \{
00204         values[i] = coeff(index+i);
00205       \}
00206       PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00207       \textcolor{keywordflow}{return} rslt;
00208     \}
00209   \}
00210 
00211   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorOpCost costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00212     \textcolor{keywordtype}{double} compute\_cost = (NumDims - 1) * (TensorOpCost::AddCost<Index>() +
00213                                            TensorOpCost::MulCost<Index>() +
00214                                            TensorOpCost::DivCost<Index>()) +
00215         TensorOpCost::MulCost<Index>();
00216     \textcolor{keywordflow}{if} (vectorized) \{
00217       compute\_cost *= 2;  \textcolor{comment}{// packet() computes two indices}
00218     \}
00219     \textcolor{keyword}{const} \textcolor{keywordtype}{int} innerDim = (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) ? 0 : (NumDims - 
      1);
00220     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized && m\_inputStrides[innerDim] == 1) +
00221         \textcolor{comment}{// Computation is not vectorized per se, but it is done once per packet.}
00222         TensorOpCost(0, 0, compute\_cost, vectorized, PacketSize);
00223   \}
00224 
00225   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00226 
00227  \textcolor{keyword}{protected}:
00228   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index srcCoeff(Index index)\textcolor{keyword}{ const}
00229 \textcolor{keyword}{  }\{
00230     Index inputIndex = 0;
00231     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00232       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00233         \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00234         inputIndex += idx * m\_inputStrides[i];
00235         index -= idx * m\_outputStrides[i];
00236       \}
00237       inputIndex += index * m\_inputStrides[0];
00238     \} \textcolor{keywordflow}{else} \{  \textcolor{comment}{// RowMajor}
00239       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00240         \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00241         inputIndex += idx * m\_inputStrides[i];
00242         index -= idx * m\_outputStrides[i];
00243       \}
00244       inputIndex += index * m\_inputStrides[NumDims-1];
00245     \}
00246     \textcolor{keywordflow}{return} inputIndex;
00247   \}
00248 
00249   Dimensions m\_dimensions;
00250   array<Index, NumDims> m\_outputStrides;
00251   array<Index, NumDims> m\_inputStrides;
00252   TensorEvaluator<ArgType, Device> m\_impl;
00253 \};
00254 
00255 
00256 \textcolor{comment}{// Eval as lvalue}
00257 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}es, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00258 \textcolor{keyword}{struct }TensorEvaluator<TensorStridingOp<Strides, ArgType>, Device>
00259     : \textcolor{keyword}{public} TensorEvaluator<const TensorStridingOp<Strides, ArgType>, Device>
00260 \{
00261   \textcolor{keyword}{typedef} TensorStridingOp<Strides, ArgType> XprType;
00262   \textcolor{keyword}{typedef} TensorEvaluator<const XprType, Device> Base;
00263   \textcolor{comment}{//  typedef typename XprType::Index Index;}
00264   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::array\_size<typename TensorEvaluator<ArgType, Device>::Dimensions>
      ::value;
00265   \textcolor{comment}{//  typedef DSizes<Index, NumDims> Dimensions;}
00266 
00267   \textcolor{keyword}{enum} \{
00268     IsAligned = \textcolor{comment}{/*TensorEvaluator<ArgType, Device>::IsAligned*/}\textcolor{keyword}{false},
00269     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00270     Layout = TensorEvaluator<ArgType, Device>::Layout,
00271     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00272     RawAccess = \textcolor{keyword}{false}
00273   \};
00274 
00275   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00276       : Base(op, device) \{ \}
00277 
00278   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00279   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00280   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00281   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00282   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = internal::unpacket\_traits<PacketReturnType>::size;
00283 
00284   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& coeffRef(Index index)
00285   \{
00286     \textcolor{keywordflow}{return} this->m\_impl.coeffRef(this->srcCoeff(index));
00287   \}
00288 
00289   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} StoreMode> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00290   \textcolor{keywordtype}{void} writePacket(Index index, \textcolor{keyword}{const} PacketReturnType& x)
00291   \{
00292     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00293     eigen\_assert(index+PacketSize-1 < this->dimensions().TotalSize());
00294 
00295     Index inputIndices[] = \{0, 0\};
00296     Index indices[] = \{index, index + PacketSize - 1\};
00297     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00298       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00299         \textcolor{keyword}{const} Index idx0 = indices[0] / this->m\_outputStrides[i];
00300         \textcolor{keyword}{const} Index idx1 = indices[1] / this->m\_outputStrides[i];
00301         inputIndices[0] += idx0 * this->m\_inputStrides[i];
00302         inputIndices[1] += idx1 * this->m\_inputStrides[i];
00303         indices[0] -= idx0 * this->m\_outputStrides[i];
00304         indices[1] -= idx1 * this->m\_outputStrides[i];
00305       \}
00306       inputIndices[0] += indices[0] * this->m\_inputStrides[0];
00307       inputIndices[1] += indices[1] * this->m\_inputStrides[0];
00308     \} \textcolor{keywordflow}{else} \{  \textcolor{comment}{// RowMajor}
00309       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00310         \textcolor{keyword}{const} Index idx0 = indices[0] / this->m\_outputStrides[i];
00311         \textcolor{keyword}{const} Index idx1 = indices[1] / this->m\_outputStrides[i];
00312         inputIndices[0] += idx0 * this->m\_inputStrides[i];
00313         inputIndices[1] += idx1 * this->m\_inputStrides[i];
00314         indices[0] -= idx0 * this->m\_outputStrides[i];
00315         indices[1] -= idx1 * this->m\_outputStrides[i];
00316       \}
00317       inputIndices[0] += indices[0] * this->m\_inputStrides[NumDims-1];
00318       inputIndices[1] += indices[1] * this->m\_inputStrides[NumDims-1];
00319     \}
00320     \textcolor{keywordflow}{if} (inputIndices[1] - inputIndices[0] == PacketSize - 1) \{
00321       this->m\_impl.template writePacket<Unaligned>(inputIndices[0], x);
00322     \}
00323     \textcolor{keywordflow}{else} \{
00324       EIGEN\_ALIGN\_MAX Scalar values[PacketSize];
00325       internal::pstore<Scalar, PacketReturnType>(values, x);
00326       this->m\_impl.coeffRef(inputIndices[0]) = values[0];
00327       this->m\_impl.coeffRef(inputIndices[1]) = values[PacketSize-1];
00328       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < PacketSize-1; ++i) \{
00329         this->coeffRef(index+i) = values[i];
00330       \}
00331     \}
00332   \}
00333 \};
00334 
00335 
00336 \} \textcolor{comment}{// end namespace Eigen}
00337 
00338 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_STRIDING\_H}
\end{DoxyCode}
