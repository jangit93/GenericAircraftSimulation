\hypertarget{eigen_2bench_2analyze-blocking-sizes_8cpp_source}{}\section{eigen/bench/analyze-\/blocking-\/sizes.cpp}
\label{eigen_2bench_2analyze-blocking-sizes_8cpp_source}\index{analyze-\/blocking-\/sizes.\+cpp@{analyze-\/blocking-\/sizes.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Benoit Jacob <benoitjacob@google.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include <iostream>}
00011 \textcolor{preprocessor}{#include <cstdint>}
00012 \textcolor{preprocessor}{#include <cstdlib>}
00013 \textcolor{preprocessor}{#include <vector>}
00014 \textcolor{preprocessor}{#include <algorithm>}
00015 \textcolor{preprocessor}{#include <fstream>}
00016 \textcolor{preprocessor}{#include <string>}
00017 \textcolor{preprocessor}{#include <cmath>}
00018 \textcolor{preprocessor}{#include <cassert>}
00019 \textcolor{preprocessor}{#include <cstring>}
00020 \textcolor{preprocessor}{#include <memory>}
00021 
00022 \textcolor{preprocessor}{#include <Eigen/Core>}
00023 
00024 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00025 
00026 \textcolor{keyword}{const} \textcolor{keywordtype}{int} default\_precision = 4;
00027 
00028 \textcolor{comment}{// see --only-cubic-sizes}
00029 \textcolor{keywordtype}{bool} only\_cubic\_sizes = \textcolor{keyword}{false};
00030 
00031 \textcolor{comment}{// see --dump-tables}
00032 \textcolor{keywordtype}{bool} dump\_tables = \textcolor{keyword}{false};
00033 
00034 uint8\_t log2\_pot(\textcolor{keywordtype}{size\_t} x) \{
00035   \textcolor{keywordtype}{size\_t} l = 0;
00036   \textcolor{keywordflow}{while} (x >>= 1) l++;
00037   \textcolor{keywordflow}{return} l;
00038 \}
00039 
00040 uint16\_t compact\_size\_triple(\textcolor{keywordtype}{size\_t} k, \textcolor{keywordtype}{size\_t} m, \textcolor{keywordtype}{size\_t} n)
00041 \{
00042   \textcolor{keywordflow}{return} (log2\_pot(k) << 8) | (log2\_pot(m) << 4) | log2\_pot(n);
00043 \}
00044 
00045 \textcolor{comment}{// just a helper to store a triple of K,M,N sizes for matrix product}
\Hypertarget{eigen_2bench_2analyze-blocking-sizes_8cpp_source_l00046}\hyperlink{structsize__triple__t}{00046} \textcolor{keyword}{struct }\hyperlink{structsize__triple__t}{size\_triple\_t}
00047 \{
00048   uint16\_t k, m, n;
00049   \hyperlink{structsize__triple__t}{size\_triple\_t}() : k(0), m(0), n(0) \{\}
00050   \hyperlink{structsize__triple__t}{size\_triple\_t}(\textcolor{keywordtype}{size\_t} \_k, \textcolor{keywordtype}{size\_t} \_m, \textcolor{keywordtype}{size\_t} \_n) : k(\_k), m(\_m), n(\_n) \{\}
00051   \hyperlink{structsize__triple__t}{size\_triple\_t}(\textcolor{keyword}{const} \hyperlink{structsize__triple__t}{size\_triple\_t}& o) : k(o.k), m(o.m), n(o.n) \{\}
00052   \hyperlink{structsize__triple__t}{size\_triple\_t}(uint16\_t compact)
00053   \{
00054     k = 1 << ((compact & 0xf00) >> 8);
00055     m = 1 << ((compact & 0x0f0) >> 4);
00056     n = 1 << ((compact & 0x00f) >> 0);
00057   \}
00058   \textcolor{keywordtype}{bool} is\_cubic()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} k == m && m == n; \}
00059 \};
00060 
00061 ostream& operator<<(ostream& s, \textcolor{keyword}{const} \hyperlink{structsize__triple__t}{size\_triple\_t}& t)
00062 \{
00063   \textcolor{keywordflow}{return} s << \textcolor{stringliteral}{"("} << t.k << \textcolor{stringliteral}{", "} << t.m << \textcolor{stringliteral}{", "} << t.n << \textcolor{stringliteral}{")"};
00064 \}
00065 
\Hypertarget{eigen_2bench_2analyze-blocking-sizes_8cpp_source_l00066}\hyperlink{structinputfile__entry__t}{00066} \textcolor{keyword}{struct }\hyperlink{structinputfile__entry__t}{inputfile\_entry\_t}
00067 \{
00068   uint16\_t product\_size;
00069   uint16\_t pot\_block\_size;
00070   \hyperlink{structsize__triple__t}{size\_triple\_t} nonpot\_block\_size;
00071   \textcolor{keywordtype}{float} gflops;
00072 \};
00073 
\Hypertarget{eigen_2bench_2analyze-blocking-sizes_8cpp_source_l00074}\hyperlink{structinputfile__t}{00074} \textcolor{keyword}{struct }\hyperlink{structinputfile__t}{inputfile\_t}
00075 \{
00076   \textcolor{keyword}{enum class} type\_t \{
00077     unknown,
00078     all\_pot\_sizes,
00079     default\_sizes
00080   \};
00081 
00082   \textcolor{keywordtype}{string} filename;
00083   vector<inputfile\_entry\_t> entries;
00084   type\_t type;
00085 
00086   \hyperlink{structinputfile__t}{inputfile\_t}(\textcolor{keyword}{const} \textcolor{keywordtype}{string}& fname)
00087     : filename(fname)
00088     , type(type\_t::unknown)
00089   \{
00090     ifstream stream(filename);
00091     \textcolor{keywordflow}{if} (!stream.is\_open()) \{
00092       cerr << \textcolor{stringliteral}{"couldn't open input file: "} << filename << endl;
00093       exit(1);
00094     \}
00095     \textcolor{keywordtype}{string} line;
00096     \textcolor{keywordflow}{while} (getline(stream, line)) \{
00097       \textcolor{keywordflow}{if} (line.empty()) \textcolor{keywordflow}{continue};
00098       \textcolor{keywordflow}{if} (line.find(\textcolor{stringliteral}{"BEGIN MEASUREMENTS ALL POT SIZES"}) == 0) \{
00099         \textcolor{keywordflow}{if} (type != type\_t::unknown) \{
00100           cerr << \textcolor{stringliteral}{"Input file "} << filename << \textcolor{stringliteral}{" contains redundant BEGIN MEASUREMENTS lines"};
00101           exit(1);
00102         \}
00103         type = type\_t::all\_pot\_sizes;
00104         \textcolor{keywordflow}{continue};
00105       \}
00106       \textcolor{keywordflow}{if} (line.find(\textcolor{stringliteral}{"BEGIN MEASUREMENTS DEFAULT SIZES"}) == 0) \{
00107         \textcolor{keywordflow}{if} (type != type\_t::unknown) \{
00108           cerr << \textcolor{stringliteral}{"Input file "} << filename << \textcolor{stringliteral}{" contains redundant BEGIN MEASUREMENTS lines"};
00109           exit(1);
00110         \}
00111         type = type\_t::default\_sizes;
00112         \textcolor{keywordflow}{continue};
00113       \}
00114       
00115 
00116       \textcolor{keywordflow}{if} (type == type\_t::unknown) \{
00117         \textcolor{keywordflow}{continue};
00118       \}
00119       \textcolor{keywordflow}{switch}(type) \{
00120         \textcolor{keywordflow}{case} type\_t::all\_pot\_sizes: \{
00121           \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} product\_size, block\_size;
00122           \textcolor{keywordtype}{float} gflops;
00123           \textcolor{keywordtype}{int} sscanf\_result =
00124             sscanf(line.c\_str(), \textcolor{stringliteral}{"%x %x %f"},
00125                    &product\_size,
00126                    &block\_size,
00127                    &gflops);
00128           \textcolor{keywordflow}{if} (3 != sscanf\_result ||
00129               !product\_size ||
00130               product\_size > 0xfff ||
00131               !block\_size ||
00132               block\_size > 0xfff ||
00133               !isfinite(gflops))
00134           \{
00135             cerr << \textcolor{stringliteral}{"ill-formed input file: "} << filename << endl;
00136             cerr << \textcolor{stringliteral}{"offending line:"} << endl << line << endl;
00137             exit(1);
00138           \}
00139           \textcolor{keywordflow}{if} (only\_cubic\_sizes && !\hyperlink{structsize__triple__t}{size\_triple\_t}(product\_size).is\_cubic()) \{
00140             \textcolor{keywordflow}{continue};
00141           \}
00142           \hyperlink{structinputfile__entry__t}{inputfile\_entry\_t} entry;
00143           entry.product\_size = uint16\_t(product\_size);
00144           entry.pot\_block\_size = uint16\_t(block\_size);
00145           entry.gflops = gflops;
00146           entries.push\_back(entry);
00147           \textcolor{keywordflow}{break};
00148         \}
00149         \textcolor{keywordflow}{case} type\_t::default\_sizes: \{
00150           \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} product\_size;
00151           \textcolor{keywordtype}{float} gflops;
00152           \textcolor{keywordtype}{int} bk, bm, bn;
00153           \textcolor{keywordtype}{int} sscanf\_result =
00154             sscanf(line.c\_str(), \textcolor{stringliteral}{"%x default(%d, %d, %d) %f"},
00155                    &product\_size,
00156                    &bk, &bm, &bn,
00157                    &gflops);
00158           \textcolor{keywordflow}{if} (5 != sscanf\_result ||
00159               !product\_size ||
00160               product\_size > 0xfff ||
00161               !isfinite(gflops))
00162           \{
00163             cerr << \textcolor{stringliteral}{"ill-formed input file: "} << filename << endl;
00164             cerr << \textcolor{stringliteral}{"offending line:"} << endl << line << endl;
00165             exit(1);
00166           \}
00167           \textcolor{keywordflow}{if} (only\_cubic\_sizes && !\hyperlink{structsize__triple__t}{size\_triple\_t}(product\_size).is\_cubic()) \{
00168             \textcolor{keywordflow}{continue};
00169           \}
00170           \hyperlink{structinputfile__entry__t}{inputfile\_entry\_t} entry;
00171           entry.product\_size = uint16\_t(product\_size);
00172           entry.pot\_block\_size = 0;
00173           entry.nonpot\_block\_size = \hyperlink{structsize__triple__t}{size\_triple\_t}(bk, bm, bn);
00174           entry.gflops = gflops;
00175           entries.push\_back(entry);
00176           \textcolor{keywordflow}{break};
00177         \}
00178         
00179         \textcolor{keywordflow}{default}:
00180           \textcolor{keywordflow}{break};
00181       \}
00182     \}
00183     stream.close();
00184     \textcolor{keywordflow}{if} (type == type\_t::unknown) \{
00185       cerr << \textcolor{stringliteral}{"Unrecognized input file "} << filename << endl;
00186       exit(1);
00187     \}
00188     \textcolor{keywordflow}{if} (entries.empty()) \{
00189       cerr << \textcolor{stringliteral}{"didn't find any measurements in input file: "} << filename << endl;
00190       exit(1);
00191     \}
00192   \}
00193 \};
00194 
\Hypertarget{eigen_2bench_2analyze-blocking-sizes_8cpp_source_l00195}\hyperlink{structpreprocessed__inputfile__entry__t}{00195} \textcolor{keyword}{struct }\hyperlink{structpreprocessed__inputfile__entry__t}{preprocessed\_inputfile\_entry\_t}
00196 \{
00197   uint16\_t product\_size;
00198   uint16\_t block\_size;
00199 
00200   \textcolor{keywordtype}{float} efficiency;
00201 \};
00202 
00203 \textcolor{keywordtype}{bool} lower\_efficiency(\textcolor{keyword}{const} \hyperlink{structpreprocessed__inputfile__entry__t}{preprocessed\_inputfile\_entry\_t}& e1, \textcolor{keyword}{const} 
      \hyperlink{structpreprocessed__inputfile__entry__t}{preprocessed\_inputfile\_entry\_t}& e2)
00204 \{
00205   \textcolor{keywordflow}{return} e1.efficiency < e2.efficiency;
00206 \}
00207 
\Hypertarget{eigen_2bench_2analyze-blocking-sizes_8cpp_source_l00208}\hyperlink{structpreprocessed__inputfile__t}{00208} \textcolor{keyword}{struct }\hyperlink{structpreprocessed__inputfile__t}{preprocessed\_inputfile\_t}
00209 \{
00210   \textcolor{keywordtype}{string} filename;
00211   vector<preprocessed\_inputfile\_entry\_t> entries;
00212 
00213   \hyperlink{structpreprocessed__inputfile__t}{preprocessed\_inputfile\_t}(\textcolor{keyword}{const} \hyperlink{structinputfile__t}{inputfile\_t}& inputfile)
00214     : filename(inputfile.filename)
00215   \{
00216     \textcolor{keywordflow}{if} (inputfile.type != inputfile\_t::type\_t::all\_pot\_sizes) \{
00217       abort();
00218     \}
00219     \textcolor{keyword}{auto} it = inputfile.entries.begin();
00220     \textcolor{keyword}{auto} it\_first\_with\_given\_product\_size = it;
00221     \textcolor{keywordflow}{while} (it != inputfile.entries.end()) \{
00222       ++it;
00223       \textcolor{keywordflow}{if} (it == inputfile.entries.end() ||
00224         it->product\_size != it\_first\_with\_given\_product\_size->product\_size)
00225       \{
00226         import\_input\_file\_range\_one\_product\_size(it\_first\_with\_given\_product\_size, it);
00227         it\_first\_with\_given\_product\_size = it;
00228       \}
00229     \}
00230   \}
00231 
00232 \textcolor{keyword}{private}:
00233   \textcolor{keywordtype}{void} import\_input\_file\_range\_one\_product\_size(
00234     \textcolor{keyword}{const} vector<inputfile\_entry\_t>::const\_iterator& begin,
00235     \textcolor{keyword}{const} vector<inputfile\_entry\_t>::const\_iterator& end)
00236   \{
00237     uint16\_t product\_size = begin->product\_size;
00238     \textcolor{keywordtype}{float} max\_gflops = 0.0f;
00239     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = begin; it != end; ++it) \{
00240       \textcolor{keywordflow}{if} (it->product\_size != product\_size) \{
00241         cerr << \textcolor{stringliteral}{"Unexpected ordering of entries in "} << filename << endl;
00242         cerr << \textcolor{stringliteral}{"(Expected all entries for product size "} << hex << product\_size << dec << \textcolor{stringliteral}{" to be grouped)
      "} << endl;
00243         exit(1);
00244       \}
00245       max\_gflops = max(max\_gflops, it->gflops);
00246     \}
00247     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = begin; it != end; ++it) \{
00248       \hyperlink{structpreprocessed__inputfile__entry__t}{preprocessed\_inputfile\_entry\_t} entry;
00249       entry.product\_size = it->product\_size;
00250       entry.block\_size = it->pot\_block\_size;
00251       entry.efficiency = it->gflops / max\_gflops;
00252       entries.push\_back(entry);
00253     \}
00254   \}
00255 \};
00256 
00257 \textcolor{keywordtype}{void} check\_all\_files\_in\_same\_exact\_order(
00258        \textcolor{keyword}{const} vector<preprocessed\_inputfile\_t>& preprocessed\_inputfiles)
00259 \{
00260   \textcolor{keywordflow}{if} (preprocessed\_inputfiles.empty()) \{
00261     \textcolor{keywordflow}{return};
00262   \}
00263 
00264   \textcolor{keyword}{const} \hyperlink{structpreprocessed__inputfile__t}{preprocessed\_inputfile\_t}& first\_file = preprocessed\_inputfiles[0];
00265   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} num\_entries = first\_file.entries.size();
00266 
00267   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < preprocessed\_inputfiles.size(); i++) \{
00268     \textcolor{keywordflow}{if} (preprocessed\_inputfiles[i].entries.size() != num\_entries) \{
00269       cerr << \textcolor{stringliteral}{"these files have different number of entries: "}
00270            << preprocessed\_inputfiles[i].filename
00271            << \textcolor{stringliteral}{" and "}
00272            << first\_file.filename
00273            << endl;
00274       exit(1);
00275     \}
00276   \}
00277 
00278   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} entry\_index = 0; entry\_index < num\_entries; entry\_index++) \{
00279     \textcolor{keyword}{const} uint16\_t entry\_product\_size = first\_file.entries[entry\_index].product\_size;
00280     \textcolor{keyword}{const} uint16\_t entry\_block\_size = first\_file.entries[entry\_index].block\_size;
00281     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} file\_index = 0; file\_index < preprocessed\_inputfiles.size(); file\_index++) \{
00282       \textcolor{keyword}{const} \hyperlink{structpreprocessed__inputfile__t}{preprocessed\_inputfile\_t}& cur\_file = preprocessed\_inputfiles[file\_index
      ];
00283       \textcolor{keywordflow}{if} (cur\_file.entries[entry\_index].product\_size != entry\_product\_size ||
00284           cur\_file.entries[entry\_index].block\_size != entry\_block\_size)
00285       \{
00286         cerr << \textcolor{stringliteral}{"entries not in same order between these files: "}
00287              << first\_file.filename
00288              << \textcolor{stringliteral}{" and "}
00289              << cur\_file.filename
00290              << endl;
00291         exit(1);
00292       \}
00293     \}
00294   \}
00295 \}
00296 
00297 \textcolor{keywordtype}{float} efficiency\_of\_subset(
00298         \textcolor{keyword}{const} vector<preprocessed\_inputfile\_t>& preprocessed\_inputfiles,
00299         \textcolor{keyword}{const} vector<size\_t>& subset)
00300 \{
00301   \textcolor{keywordflow}{if} (subset.size() <= 1) \{
00302     \textcolor{keywordflow}{return} 1.0f;
00303   \}
00304   \textcolor{keyword}{const} \hyperlink{structpreprocessed__inputfile__t}{preprocessed\_inputfile\_t}& first\_file = preprocessed\_inputfiles[subset[0]];
00305   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} num\_entries = first\_file.entries.size();
00306   \textcolor{keywordtype}{float} efficiency = 1.0f;
00307   \textcolor{keywordtype}{size\_t} entry\_index = 0;
00308   \textcolor{keywordtype}{size\_t} first\_entry\_index\_with\_this\_product\_size = 0;
00309   uint16\_t product\_size = first\_file.entries[0].product\_size;
00310   \textcolor{keywordflow}{while} (entry\_index < num\_entries) \{
00311     ++entry\_index;
00312     \textcolor{keywordflow}{if} (entry\_index == num\_entries ||
00313         first\_file.entries[entry\_index].product\_size != product\_size)
00314     \{
00315       \textcolor{keywordtype}{float} efficiency\_this\_product\_size = 0.0f;
00316       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} e = first\_entry\_index\_with\_this\_product\_size; e < entry\_index; e++) \{
00317         \textcolor{keywordtype}{float} efficiency\_this\_entry = 1.0f;
00318         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = subset.begin(); i != subset.end(); ++i) \{
00319           efficiency\_this\_entry = min(efficiency\_this\_entry, preprocessed\_inputfiles[*i].entries[e].
      efficiency);
00320         \}
00321         efficiency\_this\_product\_size = max(efficiency\_this\_product\_size, efficiency\_this\_entry);
00322       \}
00323       efficiency = min(efficiency, efficiency\_this\_product\_size);
00324       \textcolor{keywordflow}{if} (entry\_index < num\_entries) \{
00325         first\_entry\_index\_with\_this\_product\_size = entry\_index;
00326         product\_size = first\_file.entries[entry\_index].product\_size;
00327       \}
00328     \}
00329   \}
00330 
00331   \textcolor{keywordflow}{return} efficiency;
00332 \}
00333 
00334 \textcolor{keywordtype}{void} dump\_table\_for\_subset(
00335         \textcolor{keyword}{const} vector<preprocessed\_inputfile\_t>& preprocessed\_inputfiles,
00336         \textcolor{keyword}{const} vector<size\_t>& subset)
00337 \{
00338   \textcolor{keyword}{const} \hyperlink{structpreprocessed__inputfile__t}{preprocessed\_inputfile\_t}& first\_file = preprocessed\_inputfiles[subset[0]];
00339   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} num\_entries = first\_file.entries.size();
00340   \textcolor{keywordtype}{size\_t} entry\_index = 0;
00341   \textcolor{keywordtype}{size\_t} first\_entry\_index\_with\_this\_product\_size = 0;
00342   uint16\_t product\_size = first\_file.entries[0].product\_size;
00343   \textcolor{keywordtype}{size\_t} i = 0;
00344   \hyperlink{structsize__triple__t}{size\_triple\_t} min\_product\_size(first\_file.entries.front().product\_size);
00345   \hyperlink{structsize__triple__t}{size\_triple\_t} max\_product\_size(first\_file.entries.back().product\_size);
00346   \textcolor{keywordflow}{if} (!min\_product\_size.is\_cubic() || !max\_product\_size.is\_cubic()) \{
00347     abort();
00348   \}
00349   \textcolor{keywordflow}{if} (only\_cubic\_sizes) \{
00350     cerr << \textcolor{stringliteral}{"Can't generate tables with --only-cubic-sizes."} << endl;
00351     abort();
00352   \}
00353   cout << \textcolor{stringliteral}{"struct LookupTable \{"} << endl;
00354   cout << \textcolor{stringliteral}{"  static const size\_t BaseSize = "} << min\_product\_size.k << \textcolor{stringliteral}{";"} << endl;
00355   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NumSizes = log2\_pot(max\_product\_size.k / min\_product\_size.k) + 1;
00356   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} TableSize = NumSizes * NumSizes * NumSizes;
00357   cout << \textcolor{stringliteral}{"  static const size\_t NumSizes = "} << NumSizes << \textcolor{stringliteral}{";"} << endl;
00358   cout << \textcolor{stringliteral}{"  static const unsigned short* Data() \{"} << endl;
00359   cout << \textcolor{stringliteral}{"    static const unsigned short data["} << TableSize << \textcolor{stringliteral}{"] = \{"};
00360   \textcolor{keywordflow}{while} (entry\_index < num\_entries) \{
00361     ++entry\_index;
00362     \textcolor{keywordflow}{if} (entry\_index == num\_entries ||
00363         first\_file.entries[entry\_index].product\_size != product\_size)
00364     \{
00365       \textcolor{keywordtype}{float} best\_efficiency\_this\_product\_size = 0.0f;
00366       uint16\_t best\_block\_size\_this\_product\_size = 0;
00367       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} e = first\_entry\_index\_with\_this\_product\_size; e < entry\_index; e++) \{
00368         \textcolor{keywordtype}{float} efficiency\_this\_entry = 1.0f;
00369         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = subset.begin(); i != subset.end(); ++i) \{
00370           efficiency\_this\_entry = min(efficiency\_this\_entry, preprocessed\_inputfiles[*i].entries[e].
      efficiency);
00371         \}
00372         \textcolor{keywordflow}{if} (efficiency\_this\_entry > best\_efficiency\_this\_product\_size) \{
00373           best\_efficiency\_this\_product\_size = efficiency\_this\_entry;
00374           best\_block\_size\_this\_product\_size = first\_file.entries[e].block\_size;
00375         \}
00376       \}
00377       \textcolor{keywordflow}{if} ((i++) % NumSizes) \{
00378         cout << \textcolor{stringliteral}{" "};
00379       \} \textcolor{keywordflow}{else} \{
00380         cout << endl << \textcolor{stringliteral}{"      "};
00381       \}
00382       cout << \textcolor{stringliteral}{"0x"} << hex << best\_block\_size\_this\_product\_size << dec;
00383       \textcolor{keywordflow}{if} (entry\_index < num\_entries) \{
00384         cout << \textcolor{stringliteral}{","};
00385         first\_entry\_index\_with\_this\_product\_size = entry\_index;
00386         product\_size = first\_file.entries[entry\_index].product\_size;
00387       \}
00388     \}
00389   \}
00390   \textcolor{keywordflow}{if} (i != TableSize) \{
00391     cerr << endl << \textcolor{stringliteral}{"Wrote "} << i << \textcolor{stringliteral}{" table entries, expected "} << TableSize << endl;
00392     abort();
00393   \}
00394   cout << endl << \textcolor{stringliteral}{"    \};"} << endl;
00395   cout << \textcolor{stringliteral}{"    return data;"} << endl;
00396   cout << \textcolor{stringliteral}{"  \}"} << endl;
00397   cout << \textcolor{stringliteral}{"\};"} << endl;
00398 \}
00399 
00400 \textcolor{keywordtype}{float} efficiency\_of\_partition(
00401         \textcolor{keyword}{const} vector<preprocessed\_inputfile\_t>& preprocessed\_inputfiles,
00402         \textcolor{keyword}{const} vector<vector<size\_t>>& partition)
00403 \{
00404   \textcolor{keywordtype}{float} efficiency = 1.0f;
00405   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} s = partition.begin(); s != partition.end(); ++s) \{
00406     efficiency = min(efficiency, efficiency\_of\_subset(preprocessed\_inputfiles, *s));
00407   \}
00408   \textcolor{keywordflow}{return} efficiency;
00409 \}
00410 
00411 \textcolor{keywordtype}{void} make\_first\_subset(\textcolor{keywordtype}{size\_t} subset\_size, vector<size\_t>& out\_subset, \textcolor{keywordtype}{size\_t} set\_size)
00412 \{
00413   assert(subset\_size >= 1 && subset\_size <= set\_size);
00414   out\_subset.resize(subset\_size);
00415   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < subset\_size; i++) \{
00416     out\_subset[i] = i;
00417   \}
00418 \}
00419 
00420 \textcolor{keywordtype}{bool} is\_last\_subset(\textcolor{keyword}{const} vector<size\_t>& subset, \textcolor{keywordtype}{size\_t} set\_size)
00421 \{
00422   \textcolor{keywordflow}{return} subset[0] == set\_size - subset.size();
00423 \}
00424 
00425 \textcolor{keywordtype}{void} next\_subset(vector<size\_t>& inout\_subset, \textcolor{keywordtype}{size\_t} set\_size)
00426 \{
00427   \textcolor{keywordflow}{if} (is\_last\_subset(inout\_subset, set\_size)) \{
00428     cerr << \textcolor{stringliteral}{"iterating past the last subset"} << endl;
00429     abort();
00430   \}
00431   \textcolor{keywordtype}{size\_t} i = 1;
00432   \textcolor{keywordflow}{while} (inout\_subset[inout\_subset.size() - i] == set\_size - i) \{
00433     i++;
00434     assert(i <= inout\_subset.size());
00435   \}
00436   \textcolor{keywordtype}{size\_t} first\_index\_to\_change = inout\_subset.size() - i;
00437   inout\_subset[first\_index\_to\_change]++;
00438   \textcolor{keywordtype}{size\_t} p = inout\_subset[first\_index\_to\_change];
00439   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} j = first\_index\_to\_change + 1; j < inout\_subset.size(); j++) \{
00440     inout\_subset[j] = ++p;
00441   \}
00442 \}
00443 
00444 \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} number\_of\_subsets\_limit = 100;
00445 \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} always\_search\_subsets\_of\_size\_at\_least = 2;
00446 
00447 \textcolor{keywordtype}{bool} is\_number\_of\_subsets\_feasible(\textcolor{keywordtype}{size\_t} n, \textcolor{keywordtype}{size\_t} p)
00448 \{ 
00449   assert(n>0 && p>0 && p<=n);
00450   uint64\_t numerator = 1, denominator = 1;
00451   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < p; i++) \{
00452     numerator *= n - i;
00453     denominator *= i + 1;
00454     \textcolor{keywordflow}{if} (numerator > denominator * number\_of\_subsets\_limit) \{
00455       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00456     \}
00457   \}
00458   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00459 \}
00460 
00461 \textcolor{keywordtype}{size\_t} max\_feasible\_subset\_size(\textcolor{keywordtype}{size\_t} n)
00462 \{
00463   assert(n > 0);
00464   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} minresult = min<size\_t>(n-1, always\_search\_subsets\_of\_size\_at\_least);
00465   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} p = 1; p <= n - 1; p++) \{
00466     \textcolor{keywordflow}{if} (!is\_number\_of\_subsets\_feasible(n, p+1)) \{
00467       \textcolor{keywordflow}{return} max(p, minresult);
00468     \}
00469   \}
00470   \textcolor{keywordflow}{return} n - 1;
00471 \}
00472 
00473 \textcolor{keywordtype}{void} find\_subset\_with\_efficiency\_higher\_than(
00474        \textcolor{keyword}{const} vector<preprocessed\_inputfile\_t>& preprocessed\_inputfiles,
00475        \textcolor{keywordtype}{float} required\_efficiency\_to\_beat,
00476        vector<size\_t>& inout\_remainder,
00477        vector<size\_t>& out\_subset)
00478 \{
00479   out\_subset.resize(0);
00480 
00481   \textcolor{keywordflow}{if} (required\_efficiency\_to\_beat >= 1.0f) \{
00482     cerr << \textcolor{stringliteral}{"can't beat efficiency 1."} << endl;
00483     abort();
00484   \}
00485 
00486   \textcolor{keywordflow}{while} (!inout\_remainder.empty()) \{
00487 
00488     vector<size\_t> candidate\_indices(inout\_remainder.size());
00489     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < candidate\_indices.size(); i++) \{
00490       candidate\_indices[i] = i;
00491     \}
00492 
00493     \textcolor{keywordtype}{size\_t} candidate\_indices\_subset\_size = max\_feasible\_subset\_size(candidate\_indices.size());
00494     \textcolor{keywordflow}{while} (candidate\_indices\_subset\_size >= 1) \{
00495       vector<size\_t> candidate\_indices\_subset;
00496       make\_first\_subset(candidate\_indices\_subset\_size,
00497                         candidate\_indices\_subset,
00498                         candidate\_indices.size());
00499 
00500       vector<size\_t> best\_candidate\_indices\_subset;
00501       \textcolor{keywordtype}{float} best\_efficiency = 0.0f;
00502       vector<size\_t> trial\_subset = out\_subset;
00503       trial\_subset.resize(out\_subset.size() + candidate\_indices\_subset\_size);
00504       \textcolor{keywordflow}{while} (\textcolor{keyword}{true})
00505       \{
00506         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < candidate\_indices\_subset\_size; i++) \{
00507           trial\_subset[out\_subset.size() + i] = inout\_remainder[candidate\_indices\_subset[i]];
00508         \}
00509         
00510         \textcolor{keywordtype}{float} trial\_efficiency = efficiency\_of\_subset(preprocessed\_inputfiles, trial\_subset);
00511         \textcolor{keywordflow}{if} (trial\_efficiency > best\_efficiency) \{
00512           best\_efficiency = trial\_efficiency;
00513           best\_candidate\_indices\_subset = candidate\_indices\_subset;
00514         \}
00515         \textcolor{keywordflow}{if} (is\_last\_subset(candidate\_indices\_subset, candidate\_indices.size())) \{
00516           \textcolor{keywordflow}{break};
00517         \}
00518         next\_subset(candidate\_indices\_subset, candidate\_indices.size());
00519       \}
00520        
00521       \textcolor{keywordflow}{if} (best\_efficiency > required\_efficiency\_to\_beat) \{
00522         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < best\_candidate\_indices\_subset.size(); i++) \{
00523           candidate\_indices[i] = candidate\_indices[best\_candidate\_indices\_subset[i]];
00524         \}
00525         candidate\_indices.resize(best\_candidate\_indices\_subset.size());
00526       \}
00527       candidate\_indices\_subset\_size--;
00528     \}
00529       
00530     \textcolor{keywordtype}{size\_t} candidate\_index = candidate\_indices[0];
00531     \textcolor{keyword}{auto} candidate\_iterator = inout\_remainder.begin() + candidate\_index;
00532     vector<size\_t> trial\_subset = out\_subset;
00533 
00534     trial\_subset.push\_back(*candidate\_iterator);
00535     \textcolor{keywordtype}{float} trial\_efficiency = efficiency\_of\_subset(preprocessed\_inputfiles, trial\_subset);
00536     \textcolor{keywordflow}{if} (trial\_efficiency > required\_efficiency\_to\_beat) \{
00537       out\_subset.push\_back(*candidate\_iterator);
00538       inout\_remainder.erase(candidate\_iterator);
00539     \} \textcolor{keywordflow}{else} \{
00540       \textcolor{keywordflow}{break};
00541     \}
00542   \}
00543 \}
00544 
00545 \textcolor{keywordtype}{void} find\_partition\_with\_efficiency\_higher\_than(
00546        \textcolor{keyword}{const} vector<preprocessed\_inputfile\_t>& preprocessed\_inputfiles,
00547        \textcolor{keywordtype}{float} required\_efficiency\_to\_beat,
00548        vector<vector<size\_t>>& out\_partition)
00549 \{
00550   out\_partition.resize(0);
00551 
00552   vector<size\_t> remainder;
00553   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < preprocessed\_inputfiles.size(); i++) \{
00554     remainder.push\_back(i);
00555   \}
00556 
00557   \textcolor{keywordflow}{while} (!remainder.empty()) \{
00558     vector<size\_t> new\_subset;
00559     find\_subset\_with\_efficiency\_higher\_than(
00560       preprocessed\_inputfiles,
00561       required\_efficiency\_to\_beat,
00562       remainder,
00563       new\_subset);
00564     out\_partition.push\_back(new\_subset);
00565   \}
00566 \}
00567 
00568 \textcolor{keywordtype}{void} print\_partition(
00569        \textcolor{keyword}{const} vector<preprocessed\_inputfile\_t>& preprocessed\_inputfiles,
00570        \textcolor{keyword}{const} vector<vector<size\_t>>& partition)
00571 \{
00572   \textcolor{keywordtype}{float} efficiency = efficiency\_of\_partition(preprocessed\_inputfiles, partition);
00573   cout << \textcolor{stringliteral}{"Partition into "} << partition.size() << \textcolor{stringliteral}{" subsets for "} << efficiency * 100.0f << \textcolor{stringliteral}{"% efficiency"}
        << endl;
00574   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} subset = partition.begin(); subset != partition.end(); ++subset) \{
00575     cout << \textcolor{stringliteral}{"  Subset "} << (subset - partition.begin())
00576          << \textcolor{stringliteral}{", efficiency "} << efficiency\_of\_subset(preprocessed\_inputfiles, *subset) * 100.0f << \textcolor{stringliteral}{"%:"}
00577          << endl;
00578     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \hyperlink{structfile}{file} = subset->begin(); \hyperlink{structfile}{file} != subset->end(); ++\hyperlink{structfile}{file}) \{
00579       cout << \textcolor{stringliteral}{"    "} << preprocessed\_inputfiles[*\hyperlink{structfile}{file}].filename << endl;
00580     \}
00581     \textcolor{keywordflow}{if} (dump\_tables) \{
00582       cout << \textcolor{stringliteral}{"  Table:"} << endl;
00583       dump\_table\_for\_subset(preprocessed\_inputfiles, *subset);
00584     \}
00585   \}
00586   cout << endl;
00587 \}
00588 
\Hypertarget{eigen_2bench_2analyze-blocking-sizes_8cpp_source_l00589}\hyperlink{structaction__t}{00589} \textcolor{keyword}{struct }\hyperlink{structaction__t}{action\_t}
00590 \{
00591   \textcolor{keyword}{virtual} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* invokation\_name()\textcolor{keyword}{ const }\{ abort(); \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr}; \}
00592   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} vector<string>&)\textcolor{keyword}{ const }\{ abort(); \}
00593   \textcolor{keyword}{virtual} ~\hyperlink{structaction__t}{action\_t}() \{\}
00594 \};
00595 
\Hypertarget{eigen_2bench_2analyze-blocking-sizes_8cpp_source_l00596}\hyperlink{structpartition__action__t}{00596} \textcolor{keyword}{struct }\hyperlink{structpartition__action__t}{partition\_action\_t} : \hyperlink{structaction__t}{action\_t}
00597 \{
00598   \textcolor{keyword}{virtual} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* invokation\_name()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"partition"}; \}
00599   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} vector<string>& input\_filenames)\textcolor{keyword}{ const override}
00600 \textcolor{keyword}{  }\{
00601     vector<preprocessed\_inputfile\_t> preprocessed\_inputfiles;
00602 
00603     \textcolor{keywordflow}{if} (input\_filenames.empty()) \{
00604       cerr << \textcolor{stringliteral}{"The "} << invokation\_name() << \textcolor{stringliteral}{" action needs a list of input files."} << endl;
00605       exit(1);
00606     \}
00607 
00608     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = input\_filenames.begin(); it != input\_filenames.end(); ++it) \{
00609       \hyperlink{structinputfile__t}{inputfile\_t} inputfile(*it);
00610       \textcolor{keywordflow}{switch} (inputfile.type) \{
00611         \textcolor{keywordflow}{case} inputfile\_t::type\_t::all\_pot\_sizes:
00612           preprocessed\_inputfiles.emplace\_back(inputfile);
00613           \textcolor{keywordflow}{break};
00614         \textcolor{keywordflow}{case} inputfile\_t::type\_t::default\_sizes:
00615           cerr << \textcolor{stringliteral}{"The "} << invokation\_name() << \textcolor{stringliteral}{" action only uses measurements for all pot sizes, and "}
00616                << \textcolor{stringliteral}{"has no use for "} << *it << \textcolor{stringliteral}{" which contains measurements for default sizes."} << endl;
00617           exit(1);
00618           \textcolor{keywordflow}{break};
00619         \textcolor{keywordflow}{default}:
00620           cerr << \textcolor{stringliteral}{"Unrecognized input file: "} << *it << endl;
00621           exit(1);
00622       \}
00623     \}
00624 
00625     check\_all\_files\_in\_same\_exact\_order(preprocessed\_inputfiles);
00626 
00627     \textcolor{keywordtype}{float} required\_efficiency\_to\_beat = 0.0f;
00628     vector<vector<vector<size\_t>>> partitions;
00629     cerr << \textcolor{stringliteral}{"searching for partitions...\(\backslash\)r"} << flush;
00630     \textcolor{keywordflow}{while} (\textcolor{keyword}{true})
00631     \{
00632       vector<vector<size\_t>> partition;
00633       find\_partition\_with\_efficiency\_higher\_than(
00634         preprocessed\_inputfiles,
00635         required\_efficiency\_to\_beat,
00636         partition);
00637       \textcolor{keywordtype}{float} actual\_efficiency = efficiency\_of\_partition(preprocessed\_inputfiles, partition);
00638       cerr << \textcolor{stringliteral}{"partition "} << preprocessed\_inputfiles.size() << \textcolor{stringliteral}{" files into "} << partition.size()
00639            << \textcolor{stringliteral}{" subsets for "} << 100.0f * actual\_efficiency
00640            << \textcolor{stringliteral}{" % efficiency"}
00641            << \textcolor{stringliteral}{"                  \(\backslash\)r"} << flush;
00642       partitions.push\_back(partition);
00643       \textcolor{keywordflow}{if} (partition.size() == preprocessed\_inputfiles.size() || actual\_efficiency == 1.0f) \{
00644         \textcolor{keywordflow}{break};
00645       \}
00646       required\_efficiency\_to\_beat = actual\_efficiency;
00647     \}
00648     cerr << \textcolor{stringliteral}{"                                                                  "} << endl;
00649     \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
00650       \textcolor{keywordtype}{bool} repeat = \textcolor{keyword}{false};
00651       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < partitions.size() - 1; i++) \{
00652         \textcolor{keywordflow}{if} (partitions[i].size() >= partitions[i+1].size()) \{
00653           partitions.erase(partitions.begin() + i);
00654           repeat = \textcolor{keyword}{true};
00655           \textcolor{keywordflow}{break};
00656         \}
00657       \}
00658       \textcolor{keywordflow}{if} (!repeat) \{
00659         \textcolor{keywordflow}{break};
00660       \}
00661     \}
00662     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = partitions.begin(); it != partitions.end(); ++it) \{
00663       print\_partition(preprocessed\_inputfiles, *it);
00664     \}
00665   \}
00666 \};
00667 
\Hypertarget{eigen_2bench_2analyze-blocking-sizes_8cpp_source_l00668}\hyperlink{structevaluate__defaults__action__t}{00668} \textcolor{keyword}{struct }\hyperlink{structevaluate__defaults__action__t}{evaluate\_defaults\_action\_t} : \hyperlink{structaction__t}{action\_t}
00669 \{
\Hypertarget{eigen_2bench_2analyze-blocking-sizes_8cpp_source_l00670}\hyperlink{structevaluate__defaults__action__t_1_1results__entry__t}{00670}   \textcolor{keyword}{struct }\hyperlink{structevaluate__defaults__action__t_1_1results__entry__t}{results\_entry\_t} \{
00671     uint16\_t product\_size;
00672     \hyperlink{structsize__triple__t}{size\_triple\_t} default\_block\_size;
00673     uint16\_t best\_pot\_block\_size;
00674     \textcolor{keywordtype}{float} default\_gflops;
00675     \textcolor{keywordtype}{float} best\_pot\_gflops;
00676     \textcolor{keywordtype}{float} default\_efficiency;
00677   \};
00678   \textcolor{keyword}{friend} ostream& operator<<(ostream& s, \textcolor{keyword}{const} \hyperlink{structevaluate__defaults__action__t_1_1results__entry__t}{results\_entry\_t}& entry)
00679   \{
00680     \textcolor{keywordflow}{return} s
00681       << \textcolor{stringliteral}{"Product size "} << \hyperlink{structsize__triple__t}{size\_triple\_t}(entry.product\_size)
00682       << \textcolor{stringliteral}{": default block size "} << entry.default\_block\_size
00683       << \textcolor{stringliteral}{" -> "} << entry.default\_gflops
00684       << \textcolor{stringliteral}{" GFlop/s = "} << entry.default\_efficiency * 100.0f << \textcolor{stringliteral}{" %"}
00685       << \textcolor{stringliteral}{" of best POT block size "} << \hyperlink{structsize__triple__t}{size\_triple\_t}(entry.best\_pot\_block\_size)
00686       << \textcolor{stringliteral}{" -> "} << entry.best\_pot\_gflops
00687       << \textcolor{stringliteral}{" GFlop/s"} << dec;
00688   \}
00689   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} lower\_efficiency(\textcolor{keyword}{const} \hyperlink{structevaluate__defaults__action__t_1_1results__entry__t}{results\_entry\_t}& e1, \textcolor{keyword}{const} 
      \hyperlink{structevaluate__defaults__action__t_1_1results__entry__t}{results\_entry\_t}& e2) \{
00690     \textcolor{keywordflow}{return} e1.default\_efficiency < e2.default\_efficiency;
00691   \}
00692   \textcolor{keyword}{virtual} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* invokation\_name()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"evaluate-defaults"}; \}
00693   \textcolor{keywordtype}{void} show\_usage\_and\_exit()\textcolor{keyword}{ const}
00694 \textcolor{keyword}{  }\{
00695     cerr << \textcolor{stringliteral}{"usage: "} << invokation\_name() << \textcolor{stringliteral}{" default-sizes-data all-pot-sizes-data"} << endl;
00696     cerr << \textcolor{stringliteral}{"checks how well the performance with default sizes compares to the best "}
00697          << \textcolor{stringliteral}{"performance measured over all POT sizes."} << endl;
00698     exit(1);
00699   \}
00700   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} vector<string>& input\_filenames)\textcolor{keyword}{ const override}
00701 \textcolor{keyword}{  }\{
00702     \textcolor{keywordflow}{if} (input\_filenames.size() != 2) \{
00703       show\_usage\_and\_exit();
00704     \}
00705     \hyperlink{structinputfile__t}{inputfile\_t} inputfile\_default\_sizes(input\_filenames[0]);
00706     \hyperlink{structinputfile__t}{inputfile\_t} inputfile\_all\_pot\_sizes(input\_filenames[1]);
00707     \textcolor{keywordflow}{if} (inputfile\_default\_sizes.type != inputfile\_t::type\_t::default\_sizes) \{
00708       cerr << inputfile\_default\_sizes.filename << \textcolor{stringliteral}{" is not an input file with default sizes."} << endl;
00709       show\_usage\_and\_exit();
00710     \}
00711     \textcolor{keywordflow}{if} (inputfile\_all\_pot\_sizes.type != inputfile\_t::type\_t::all\_pot\_sizes) \{
00712       cerr << inputfile\_all\_pot\_sizes.filename << \textcolor{stringliteral}{" is not an input file with all POT sizes."} << endl;
00713       show\_usage\_and\_exit();
00714     \}
00715     vector<results\_entry\_t> results;
00716     vector<results\_entry\_t> cubic\_results;
00717     
00718     uint16\_t product\_size = 0;
00719     \textcolor{keyword}{auto} it\_all\_pot\_sizes = inputfile\_all\_pot\_sizes.entries.begin();
00720     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it\_default\_sizes = inputfile\_default\_sizes.entries.begin();
00721          it\_default\_sizes != inputfile\_default\_sizes.entries.end();
00722          ++it\_default\_sizes)
00723     \{
00724       \textcolor{keywordflow}{if} (it\_default\_sizes->product\_size == product\_size) \{
00725         \textcolor{keywordflow}{continue};
00726       \}
00727       product\_size = it\_default\_sizes->product\_size;
00728       \textcolor{keywordflow}{while} (it\_all\_pot\_sizes != inputfile\_all\_pot\_sizes.entries.end() &&
00729              it\_all\_pot\_sizes->product\_size != product\_size)
00730       \{
00731         ++it\_all\_pot\_sizes;
00732       \}
00733       \textcolor{keywordflow}{if} (it\_all\_pot\_sizes == inputfile\_all\_pot\_sizes.entries.end()) \{
00734         \textcolor{keywordflow}{break};
00735       \}
00736       uint16\_t best\_pot\_block\_size = 0;
00737       \textcolor{keywordtype}{float} best\_pot\_gflops = 0;
00738       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = it\_all\_pot\_sizes;
00739            it != inputfile\_all\_pot\_sizes.entries.end() && it->product\_size == product\_size;
00740            ++it)
00741       \{
00742         \textcolor{keywordflow}{if} (it->gflops > best\_pot\_gflops) \{
00743           best\_pot\_gflops = it->gflops;
00744           best\_pot\_block\_size = it->pot\_block\_size;
00745         \}
00746       \}
00747       \hyperlink{structevaluate__defaults__action__t_1_1results__entry__t}{results\_entry\_t} entry;
00748       entry.product\_size = product\_size;
00749       entry.default\_block\_size = it\_default\_sizes->nonpot\_block\_size;
00750       entry.best\_pot\_block\_size = best\_pot\_block\_size;
00751       entry.default\_gflops = it\_default\_sizes->gflops;
00752       entry.best\_pot\_gflops = best\_pot\_gflops;
00753       entry.default\_efficiency = entry.default\_gflops / entry.best\_pot\_gflops;
00754       results.push\_back(entry);
00755 
00756       \hyperlink{structsize__triple__t}{size\_triple\_t} t(product\_size);
00757       \textcolor{keywordflow}{if} (t.k == t.m && t.m == t.n) \{
00758         cubic\_results.push\_back(entry);
00759       \}
00760     \}
00761 
00762     cout << \textcolor{stringliteral}{"All results:"} << endl;
00763     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = results.begin(); it != results.end(); ++it) \{
00764       cout << *it << endl;
00765     \}
00766     cout << endl;
00767 
00768     sort(results.begin(), results.end(), lower\_efficiency);
00769     
00770     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} n = min<size\_t>(20, results.size());
00771     cout << n << \textcolor{stringliteral}{" worst results:"} << endl;
00772     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < n; i++) \{
00773       cout << results[i] << endl;
00774     \}
00775     cout << endl;
00776 
00777     cout << \textcolor{stringliteral}{"cubic results:"} << endl;
00778     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = cubic\_results.begin(); it != cubic\_results.end(); ++it) \{
00779       cout << *it << endl;
00780     \}
00781     cout << endl;
00782 
00783     sort(cubic\_results.begin(), cubic\_results.end(), lower\_efficiency);
00784     
00785     cout.precision(2);
00786     vector<float> a = \{0.5f, 0.20f, 0.10f, 0.05f, 0.02f, 0.01f\};
00787     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = a.begin(); it != a.end(); ++it) \{
00788       \textcolor{keywordtype}{size\_t} n = min(results.size() - 1, size\_t(*it * results.size()));
00789       cout << (100.0f * n / (results.size() - 1))
00790            << \textcolor{stringliteral}{" % of product sizes have default efficiency <= "}
00791            << 100.0f * results[n].default\_efficiency << \textcolor{stringliteral}{" %"} << endl;
00792     \}
00793     cout.precision(default\_precision);
00794   \}
00795 \};
00796 
00797 
00798 \textcolor{keywordtype}{void} show\_usage\_and\_exit(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[],
00799                          \textcolor{keyword}{const} vector<unique\_ptr<action\_t>>& available\_actions)
00800 \{
00801   cerr << \textcolor{stringliteral}{"usage: "} << argv[0] << \textcolor{stringliteral}{" <action> [options...] <input files...>"} << endl;
00802   cerr << \textcolor{stringliteral}{"available actions:"} << endl;
00803   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = available\_actions.begin(); it != available\_actions.end(); ++it) \{
00804     cerr << \textcolor{stringliteral}{"  "} << (*it)->invokation\_name() << endl;
00805   \} 
00806   cerr << \textcolor{stringliteral}{"the input files should each contain an output of benchmark-blocking-sizes"} << endl;
00807   exit(1);
00808 \}
00809 
00810 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
00811 \{
00812   cout.precision(default\_precision);
00813   cerr.precision(default\_precision);
00814 
00815   vector<unique\_ptr<action\_t>> available\_actions;
00816   available\_actions.emplace\_back(\textcolor{keyword}{new} \hyperlink{structpartition__action__t}{partition\_action\_t});
00817   available\_actions.emplace\_back(\textcolor{keyword}{new} \hyperlink{structevaluate__defaults__action__t}{evaluate\_defaults\_action\_t});
00818 
00819   vector<string> input\_filenames;
00820 
00821   \hyperlink{structaction__t}{action\_t}* action = \textcolor{keyword}{nullptr};
00822 
00823   \textcolor{keywordflow}{if} (argc < 2) \{
00824     show\_usage\_and\_exit(argc, argv, available\_actions);
00825   \}
00826   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < argc; i++) \{
00827     \textcolor{keywordtype}{bool} arg\_handled = \textcolor{keyword}{false};
00828     \textcolor{comment}{// Step 1. Try to match action invokation names.}
00829     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = available\_actions.begin(); it != available\_actions.end(); ++it) \{
00830       \textcolor{keywordflow}{if} (!strcmp(argv[i], (*it)->invokation\_name())) \{
00831         \textcolor{keywordflow}{if} (!action) \{
00832           action = it->get();
00833           arg\_handled = \textcolor{keyword}{true};
00834           \textcolor{keywordflow}{break};
00835         \} \textcolor{keywordflow}{else} \{
00836           cerr << \textcolor{stringliteral}{"can't specify more than one action!"} << endl;
00837           show\_usage\_and\_exit(argc, argv, available\_actions);
00838         \}
00839       \}
00840     \}
00841     \textcolor{keywordflow}{if} (arg\_handled) \{
00842       \textcolor{keywordflow}{continue};
00843     \}
00844     \textcolor{comment}{// Step 2. Try to match option names.}
00845     \textcolor{keywordflow}{if} (argv[i][0] == \textcolor{charliteral}{'-'}) \{
00846       \textcolor{keywordflow}{if} (!strcmp(argv[i], \textcolor{stringliteral}{"--only-cubic-sizes"})) \{
00847         only\_cubic\_sizes = \textcolor{keyword}{true};
00848         arg\_handled = \textcolor{keyword}{true};
00849       \}
00850       \textcolor{keywordflow}{if} (!strcmp(argv[i], \textcolor{stringliteral}{"--dump-tables"})) \{
00851         dump\_tables = \textcolor{keyword}{true};
00852         arg\_handled = \textcolor{keyword}{true};
00853       \}
00854       \textcolor{keywordflow}{if} (!arg\_handled) \{
00855         cerr << \textcolor{stringliteral}{"Unrecognized option: "} << argv[i] << endl;
00856         show\_usage\_and\_exit(argc, argv, available\_actions);
00857       \}
00858     \}
00859     \textcolor{keywordflow}{if} (arg\_handled) \{
00860       \textcolor{keywordflow}{continue};
00861     \}
00862     \textcolor{comment}{// Step 3. Default to interpreting args as input filenames.}
00863     input\_filenames.emplace\_back(argv[i]);
00864   \}
00865 
00866   \textcolor{keywordflow}{if} (dump\_tables && only\_cubic\_sizes) \{
00867     cerr << \textcolor{stringliteral}{"Incompatible options: --only-cubic-sizes and --dump-tables."} << endl;
00868     show\_usage\_and\_exit(argc, argv, available\_actions);
00869   \}
00870 
00871   \textcolor{keywordflow}{if} (!action) \{
00872     show\_usage\_and\_exit(argc, argv, available\_actions);
00873   \}
00874 
00875   action->run(input\_filenames);
00876 \}
\end{DoxyCode}
