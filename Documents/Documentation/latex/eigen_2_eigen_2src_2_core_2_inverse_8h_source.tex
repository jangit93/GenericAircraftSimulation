\hypertarget{eigen_2_eigen_2src_2_core_2_inverse_8h_source}{}\section{eigen/\+Eigen/src/\+Core/\+Inverse.h}
\label{eigen_2_eigen_2src_2_core_2_inverse_8h_source}\index{Inverse.\+h@{Inverse.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_INVERSE\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_INVERSE\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
\Hypertarget{eigen_2_eigen_2src_2_core_2_inverse_8h_source_l00015}\hyperlink{class_eigen_1_1_inverse_impl}{00015} \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType,\textcolor{keyword}{typename} StorageKind> \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_inverse_impl}{InverseImpl};
00016 
00017 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00018 
00019 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2_eigen_2src_2_core_2_inverse_8h_source_l00020}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_inverse_3_01_xpr_type_01_4_01_4}{00020} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_inverse}{Inverse}<XprType> >
00021   : \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<typename XprType::PlainObject>
00022 \{
00023   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::PlainObject PlainObject;
00024   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<PlainObject>} \hyperlink{struct_eigen_1_1internal_1_1traits}{BaseTraits};
00025   \textcolor{keyword}{enum} \{
00026     Flags = BaseTraits::Flags & \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}
00027   \};
00028 \};
00029 
00030 \} \textcolor{comment}{// end namespace internal}
00031 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2_eigen_2src_2_core_2_inverse_8h_source_l00043}\hyperlink{class_eigen_1_1_inverse}{00043} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_inverse}{Inverse} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_inverse_impl}{InverseImpl}<XprType,typename internal::traits<XprType>::StorageKin
      d>
00044 \{
00045 \textcolor{keyword}{public}:
00046   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::StorageIndex StorageIndex;
00047   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::PlainObject                       PlainObject;
00048   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar                            Scalar;
00049   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::ref\_selector<XprType>::type}      
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{XprTypeNested};
00050   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<XprTypeNested>::type}  
      \hyperlink{group___sparse_core___module}{XprTypeNestedCleaned};
00051   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::ref\_selector<Inverse>::type} 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Nested};
00052   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<XprType>::type} 
      \hyperlink{group___sparse_core___module}{NestedExpression};
00053   
00054   \textcolor{keyword}{explicit} EIGEN\_DEVICE\_FUNC \hyperlink{class_eigen_1_1_inverse}{Inverse}(\textcolor{keyword}{const} XprType &xpr)
00055     : m\_xpr(xpr)
00056   \{\}
00057 
00058   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr.rows(); \}
00059   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr.cols(); \}
00060 
00061   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} XprTypeNestedCleaned& nestedExpression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00062 
00063 \textcolor{keyword}{protected}:
00064   XprTypeNested m\_xpr;
00065 \};
00066 
00067 \textcolor{comment}{// Generic API dispatcher}
00068 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keyword}{typename} StorageKind>
00069 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_inverse_impl}{InverseImpl}
00070   : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1internal_1_1generic__xpr__base}{internal::generic\_xpr\_base}<Inverse<XprType> >::type
00071 \{
00072 \textcolor{keyword}{public}:
00073   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1generic__xpr__base}{internal::generic\_xpr\_base<Inverse<XprType>} >
      ::type Base;
00074   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00075 \textcolor{keyword}{private}:
00076 
00077   Scalar coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col) \textcolor{keyword}{const};
00078   Scalar coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i) \textcolor{keyword}{const};
00079 \};
00080 
00081 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00082 
00093 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType>
\Hypertarget{eigen_2_eigen_2src_2_core_2_inverse_8h_source_l00094}\hyperlink{struct_eigen_1_1internal_1_1unary__evaluator_3_01_inverse_3_01_arg_type_01_4_01_4}{00094} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1unary__evaluator}{unary\_evaluator}<\hyperlink{class_eigen_1_1_inverse}{Inverse}<ArgType> >
00095   : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator}<typename Inverse<ArgType>::PlainObject>
00096 \{
00097   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_inverse}{Inverse<ArgType>} \hyperlink{class_eigen_1_1_inverse}{InverseType};
00098   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} InverseType::PlainObject PlainObject;
00099   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<PlainObject>} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{Base};
00100   
00101   \textcolor{keyword}{enum} \{ Flags = Base::Flags | \hyperlink{group__flags_gaa34e83bae46a8eeae4e69ebe3aaecbed}{EvalBeforeNestingBit} \};
00102 
00103   \hyperlink{struct_eigen_1_1internal_1_1unary__evaluator}{unary\_evaluator}(\textcolor{keyword}{const} InverseType& inv\_xpr)
00104     : m\_result(inv\_xpr.rows(), inv\_xpr.cols())
00105   \{
00106     ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(m\_result);
00107     internal::call\_assignment\_no\_alias(m\_result, inv\_xpr);
00108   \}
00109   
00110 \textcolor{keyword}{protected}:
00111   PlainObject m\_result;
00112 \};
00113   
00114 \} \textcolor{comment}{// end namespace internal}
00115 
00116 \} \textcolor{comment}{// end namespace Eigen}
00117 
00118 \textcolor{preprocessor}{#endif // EIGEN\_INVERSE\_H}
\end{DoxyCode}
