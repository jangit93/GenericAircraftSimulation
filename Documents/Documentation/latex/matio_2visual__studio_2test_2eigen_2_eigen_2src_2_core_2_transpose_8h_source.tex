\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_transpose_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/\+Transpose.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_transpose_8h_source}\index{Transpose.\+h@{Transpose.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2009-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_TRANSPOSE\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_TRANSPOSE\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00018 \textcolor{keyword}{struct }traits<Transpose<MatrixType> > : \textcolor{keyword}{public} traits<MatrixType>
00019 \{
00020   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ref\_selector<MatrixType>::type MatrixTypeNested;
00021   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<MatrixTypeNested>::type MatrixTypeNestedPlain;
00022   \textcolor{keyword}{enum} \{
00023     RowsAtCompileTime = MatrixType::ColsAtCompileTime,
00024     ColsAtCompileTime = MatrixType::RowsAtCompileTime,
00025     MaxRowsAtCompileTime = MatrixType::MaxColsAtCompileTime,
00026     MaxColsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
00027     FlagsLvalueBit = is\_lvalue<MatrixType>::value ? \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit} : 0,
00028     Flags0 = traits<MatrixTypeNestedPlain>::Flags & ~(\hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit} | NestByRefBit),
00029     Flags1 = Flags0 | FlagsLvalueBit,
00030     Flags = Flags1 ^ \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit},
00031     InnerStrideAtCompileTime = inner\_stride\_at\_compile\_time<MatrixType>::ret,
00032     OuterStrideAtCompileTime = outer\_stride\_at\_compile\_time<MatrixType>::ret
00033   \};
00034 \};
00035 \}
00036 
00037 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} StorageKind> \textcolor{keyword}{class }TransposeImpl;
00038 
00052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }Transpose
00053   : \textcolor{keyword}{public} TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>
00054 \{
00055   \textcolor{keyword}{public}:
00056 
00057     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::ref\_selector<MatrixType>::non\_const\_type MatrixTypeNested;
00058 
00059     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base 
      Base;
00060     EIGEN\_GENERIC\_PUBLIC\_INTERFACE(Transpose)
00061     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<MatrixType>::type NestedExpression;
00062 
00063     EIGEN\_DEVICE\_FUNC
00064     \textcolor{keyword}{explicit} \textcolor{keyword}{inline} Transpose(MatrixType& matrix) : m\_matrix(matrix) \{\}
00065 
00066     EIGEN\_INHERIT\_ASSIGNMENT\_OPERATORS(Transpose)
00067 
00068     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix.cols(); \}
00069     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix.rows(); \}
00070 
00072     EIGEN\_DEVICE\_FUNC
00073     \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<MatrixTypeNested>::type&
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_transpose_8h_source_l00074}\hyperlink{group___core___module_a72aefbf67f5e3caf62a99f73409b4a63}{00074}     \hyperlink{group___core___module_a72aefbf67f5e3caf62a99f73409b4a63}{nestedExpression}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix; \}
00075 
00077     EIGEN\_DEVICE\_FUNC
00078     \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_reference<MatrixTypeNested>::type}
      &
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2_transpose_8h_source_l00079}\hyperlink{group___core___module_a3265292cf912f401a32eea99975e47ea}{00079}     \hyperlink{group___core___module_a3265292cf912f401a32eea99975e47ea}{nestedExpression}() \{ \textcolor{keywordflow}{return} m\_matrix; \}
00080 
00082     \textcolor{keywordtype}{void} resize(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nrows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} ncols) \{
00083       m\_matrix.resize(ncols,nrows);
00084     \}
00085 
00086   \textcolor{keyword}{protected}:
00087     \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::ref\_selector<MatrixType>::non\_const\_type}
       m\_matrix;
00088 \};
00089 
00090 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00091 
00092 template<typename MatrixType, bool HasDirectAccess = has\_direct\_access<MatrixType>::ret>
00093 \textcolor{keyword}{struct }TransposeImpl\_base
00094 \{
00095   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} dense\_xpr\_base<Transpose<MatrixType> >::type type;
00096 \};
00097 
00098 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00099 \textcolor{keyword}{struct }TransposeImpl\_base<MatrixType, false>
00100 \{
00101   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} dense\_xpr\_base<Transpose<MatrixType> >::type type;
00102 \};
00103 
00104 \} \textcolor{comment}{// end namespace internal}
00105 
00106 \textcolor{comment}{// Generic API dispatcher}
00107 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keyword}{typename} StorageKind>
00108 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_transpose_impl}{TransposeImpl}
00109   : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1internal_1_1generic__xpr__base}{internal::generic\_xpr\_base}<Transpose<XprType> >::type
00110 \{
00111 \textcolor{keyword}{public}:
00112   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1generic__xpr__base}{internal::generic\_xpr\_base<Transpose<XprType>}
       >::type Base;
00113 \};
00114 
00115 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_transpose_impl}{TransposeImpl}<MatrixType,Dense>
00116   : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1internal_1_1_transpose_impl__base}{internal::TransposeImpl\_base}<MatrixType>::type
00117 \{
00118   \textcolor{keyword}{public}:
00119 
00120     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::TransposeImpl\_base<MatrixType>::type Base;
00121     \textcolor{keyword}{using} Base::coeffRef;
00122     EIGEN\_DENSE\_PUBLIC\_INTERFACE(\hyperlink{group___core___module_class_eigen_1_1_transpose}{Transpose<MatrixType>})
00123     EIGEN\_INHERIT\_ASSIGNMENT\_OPERATORS(\hyperlink{class_eigen_1_1_transpose_impl}{TransposeImpl})
00124 
00125     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} innerStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} derived().nestedExpression().
      innerStride(); \}
00126     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outerStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} derived().nestedExpression().
      outerStride(); \}
00127 
00128     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{internal::conditional}<
00129                        \hyperlink{struct_eigen_1_1internal_1_1is__lvalue}{internal::is\_lvalue<MatrixType>::value},
00130                        Scalar,
00131                        \textcolor{keyword}{const} Scalar
00132                      >::type ScalarWithConstIfNotLvalue;
00133 
00134     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} ScalarWithConstIfNotLvalue* data() \{ \textcolor{keywordflow}{return} derived().nestedExpression().data(
      ); \}
00135     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} derived().nestedExpression().data(); \}
00136 
00137     \textcolor{comment}{// FIXME: shall we keep the const version of coeffRef?}
00138     EIGEN\_DEVICE\_FUNC
00139     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rowId, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} colId)\textcolor{keyword}{ const}
00140 \textcolor{keyword}{    }\{
00141       \textcolor{keywordflow}{return} derived().nestedExpression().coeffRef(colId, rowId);
00142     \}
00143 
00144     EIGEN\_DEVICE\_FUNC
00145     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const}
00146 \textcolor{keyword}{    }\{
00147       \textcolor{keywordflow}{return} derived().nestedExpression().coeffRef(index);
00148     \}
00149 \};
00150 
00170 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00171 \textcolor{keyword}{inline} \hyperlink{group___core___module_class_eigen_1_1_transpose}{Transpose<Derived>}
00172 \hyperlink{group___core___module_ac8952c19644a4ac7e41bea45c19b909c}{DenseBase<Derived>::transpose}()
00173 \{
00174   \textcolor{keywordflow}{return} TransposeReturnType(derived());
00175 \}
00176 
00182 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00183 \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___core___module_class_eigen_1_1_transpose}{DenseBase<Derived>::ConstTransposeReturnType}
00184 \hyperlink{group___core___module_ac8952c19644a4ac7e41bea45c19b909c}{DenseBase<Derived>::transpose}()\textcolor{keyword}{ const}
00185 \textcolor{keyword}{}\{
00186   \textcolor{keywordflow}{return} ConstTransposeReturnType(derived());
00187 \}
00188 
00208 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00209 \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{MatrixBase<Derived>::AdjointReturnType}
00210 \hyperlink{group___core___module_afacca1f88da57e5cd87dd07c8ff926bb}{MatrixBase<Derived>::adjoint}()\textcolor{keyword}{ const}
00211 \textcolor{keyword}{}\{
00212   \textcolor{keywordflow}{return} AdjointReturnType(this->transpose());
00213 \}
00214 
00215 \textcolor{comment}{/***************************************************************************}
00216 \textcolor{comment}{* "in place" transpose implementation}
00217 \textcolor{comment}{***************************************************************************/}
00218 
00219 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00220 
00221 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType,
00222   \textcolor{keywordtype}{bool} IsSquare = (MatrixType::RowsAtCompileTime == MatrixType::ColsAtCompileTime) && 
      MatrixType::RowsAtCompileTime!=\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00223   \textcolor{keywordtype}{bool} MatchPacketSize =
00224         (\textcolor{keywordtype}{int}(MatrixType::RowsAtCompileTime) == int(
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{internal::packet\_traits<typename MatrixType::Scalar>::size}
      ))
00225     &&  (\hyperlink{struct_eigen_1_1internal_1_1evaluator}{internal::evaluator<MatrixType>::Flags}&
      \hyperlink{group__flags_ga1a306a438e1ab074e8be59512e887b9f}{PacketAccessBit}) >
00226 \textcolor{keyword}{struct }inplace\_transpose\_selector;
00227 
00228 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00229 \textcolor{keyword}{struct }inplace\_transpose\_selector<MatrixType,true,false> \{ \textcolor{comment}{// square matrix}
00230   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType& m) \{
00231     m.matrix().template triangularView<StrictlyUpper>().\hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(m.matrix().transpose());
00232   \}
00233 \};
00234 
00235 \textcolor{comment}{// TODO: vectorized path is currently limited to LargestPacketSize x LargestPacketSize cases only.}
00236 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00237 \textcolor{keyword}{struct }inplace\_transpose\_selector<MatrixType,true,true> \{ \textcolor{comment}{// PacketSize x PacketSize}
00238   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType& m) \{
00239     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00240     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::packet\_traits<typename MatrixType::Scalar>::type}
       \hyperlink{group___sparse_core___module}{Packet};
00241     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} PacketSize = \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{internal::packet\_traits<Scalar>::size}
      ;
00242     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} Alignment = \hyperlink{struct_eigen_1_1internal_1_1evaluator}{internal::evaluator<MatrixType>::Alignment}
      ;
00243     PacketBlock<Packet> \hyperlink{group___core___module_class_eigen_1_1_matrix}{A};
00244     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<PacketSize; ++i)
00245       A.packet[i] = m.template packetByOuterInner<Alignment>(i,0);
00246     internal::ptranspose(A);
00247     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<PacketSize; ++i)
00248       m.template writePacket<Alignment>(m.rowIndexByOuterInner(i,0), m.colIndexByOuterInner(i,0), A.packet[
      i]);
00249   \}
00250 \};
00251 
00252 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType,\textcolor{keywordtype}{bool} MatchPacketSize>
00253 \textcolor{keyword}{struct }inplace\_transpose\_selector<MatrixType,false,MatchPacketSize> \{ \textcolor{comment}{// non square matrix}
00254   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType& m) \{
00255     \textcolor{keywordflow}{if} (m.rows()==m.cols())
00256       m.matrix().template triangularView<StrictlyUpper>().\hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(m.matrix().transpose());
00257     \textcolor{keywordflow}{else}
00258       m = m.transpose().eval();
00259   \}
00260 \};
00261 
00262 \} \textcolor{comment}{// end namespace internal}
00263 
00283 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00284 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___core___module_ac501bd942994af7a95d95bee7a16ad2a}{DenseBase<Derived>::transposeInPlace}()
00285 \{
00286   eigen\_assert((rows() == cols() || (RowsAtCompileTime == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} && ColsAtCompileTime == 
      \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}))
00287                && \textcolor{stringliteral}{"transposeInPlace() called on a non-square non-resizable matrix"});
00288   \hyperlink{struct_eigen_1_1internal_1_1inplace__transpose__selector}{internal::inplace\_transpose\_selector<Derived>::run}(
      derived());
00289 \}
00290 
00291 \textcolor{comment}{/***************************************************************************}
00292 \textcolor{comment}{* "in place" adjoint implementation}
00293 \textcolor{comment}{***************************************************************************/}
00294 
00314 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00315 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___core___module_a51c5982c1f64e45a939515b701fa6f4a}{MatrixBase<Derived>::adjointInPlace}()
00316 \{
00317   derived() = adjoint().eval();
00318 \}
00319 
00320 \textcolor{preprocessor}{#ifndef EIGEN\_NO\_DEBUG}
00321 
00322 \textcolor{comment}{// The following is to detect aliasing problems in most common cases.}
00323 
00324 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00325 
00326 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} DestIsTransposed, \textcolor{keyword}{typename} OtherDerived>
00327 \textcolor{keyword}{struct }check\_transpose\_aliasing\_compile\_time\_selector
00328 \{
00329   \textcolor{keyword}{enum} \{ ret = bool(blas\_traits<OtherDerived>::IsTransposed) != DestIsTransposed \};
00330 \};
00331 
00332 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} DestIsTransposed, \textcolor{keyword}{typename} BinOp, \textcolor{keyword}{typename} DerivedA, \textcolor{keyword}{typename} DerivedB>
00333 \textcolor{keyword}{struct }check\_transpose\_aliasing\_compile\_time\_selector<DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,
      DerivedB> >
00334 \{
00335   \textcolor{keyword}{enum} \{ ret =    bool(blas\_traits<DerivedA>::IsTransposed) != DestIsTransposed
00336                || bool(blas\_traits<DerivedB>::IsTransposed) != DestIsTransposed
00337   \};
00338 \};
00339 
00340 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{bool} DestIsTransposed, \textcolor{keyword}{typename} OtherDerived>
00341 \textcolor{keyword}{struct }check\_transpose\_aliasing\_run\_time\_selector
00342 \{
00343   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} run(\textcolor{keyword}{const} Scalar* dest, \textcolor{keyword}{const} OtherDerived& src)
00344   \{
00345     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{bool}(blas\_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(\textcolor{keyword}{const} 
      Scalar*)extract\_data(src));
00346   \}
00347 \};
00348 
00349 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{bool} DestIsTransposed, \textcolor{keyword}{typename} BinOp, \textcolor{keyword}{typename} DerivedA, \textcolor{keyword}{typename} DerivedB>
00350 \textcolor{keyword}{struct }check\_transpose\_aliasing\_run\_time\_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,
      DerivedB> >
00351 \{
00352   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} run(\textcolor{keyword}{const} Scalar* dest, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_cwise_binary_op}{CwiseBinaryOp<BinOp,DerivedA,DerivedB>}& src)
00353   \{
00354     \textcolor{keywordflow}{return} ((blas\_traits<DerivedA>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(\textcolor{keyword}{const} Scalar*)
      extract\_data(src.\hyperlink{group___core___module_a0f73e7585dfb54d41c1983e1e6a4b269}{lhs}())))
00355         || ((blas\_traits<DerivedB>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(\textcolor{keyword}{const} Scalar*)
      extract\_data(src.\hyperlink{group___core___module_a3a61cbdf6d1adaa62f012045b04b6d09}{rhs}())));
00356   \}
00357 \};
00358 
00359 \textcolor{comment}{// the following selector, checkTransposeAliasing\_impl, based on MightHaveTransposeAliasing,}
00360 \textcolor{comment}{// is because when the condition controlling the assert is known at compile time, ICC emits a warning.}
00361 \textcolor{comment}{// This is actually a good warning: in expressions that don't have any transposing, the condition is}
00362 \textcolor{comment}{// known at compile time to be false, and using that, we can avoid generating the code of the assert again}
00363 \textcolor{comment}{// and again for all these expressions that don't need it.}
00364 
00365 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived,
00366          \textcolor{keywordtype}{bool} MightHaveTransposeAliasing
00367                  = check\_transpose\_aliasing\_compile\_time\_selector
00368                      <blas\_traits<Derived>::IsTransposed,OtherDerived>::ret
00369         >
00370 \textcolor{keyword}{struct }checkTransposeAliasing\_impl
00371 \{
00372     \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Derived& dst, \textcolor{keyword}{const} OtherDerived& other)
00373     \{
00374         eigen\_assert((!check\_transpose\_aliasing\_run\_time\_selector
00375                       <\textcolor{keyword}{typename} Derived::Scalar,blas\_traits<Derived>::IsTransposed,OtherDerived>
00376                       ::run(extract\_data(dst), other))
00377           && \textcolor{stringliteral}{"aliasing detected during transposition, use transposeInPlace() "}
00378              \textcolor{stringliteral}{"or evaluate the rhs into a temporary using .eval()"});
00379 
00380     \}
00381 \};
00382 
00383 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>
00384 \textcolor{keyword}{struct }checkTransposeAliasing\_impl<Derived, OtherDerived, false>
00385 \{
00386     \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Derived&, \textcolor{keyword}{const} OtherDerived&)
00387     \{
00388     \}
00389 \};
00390 
00391 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{typename} Src>
00392 \textcolor{keywordtype}{void} check\_for\_aliasing(\textcolor{keyword}{const} Dst &dst, \textcolor{keyword}{const} Src &src)
00393 \{
00394   \hyperlink{struct_eigen_1_1internal_1_1check_transpose_aliasing__impl}{internal::checkTransposeAliasing\_impl<Dst, Src>::run}(
      dst, src);
00395 \}
00396 
00397 \} \textcolor{comment}{// end namespace internal}
00398 
00399 \textcolor{preprocessor}{#endif // EIGEN\_NO\_DEBUG}
00400 
00401 \} \textcolor{comment}{// end namespace Eigen}
00402 
00403 \textcolor{preprocessor}{#endif // EIGEN\_TRANSPOSE\_H}
\end{DoxyCode}
