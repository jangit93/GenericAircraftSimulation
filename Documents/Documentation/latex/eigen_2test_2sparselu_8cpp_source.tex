\hypertarget{eigen_2test_2sparselu_8cpp_source}{}\section{eigen/test/sparselu.cpp}
\label{eigen_2test_2sparselu_8cpp_source}\index{sparselu.\+cpp@{sparselu.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{comment}{// SparseLU solve does not accept column major matrices for the destination.}
00011 \textcolor{comment}{// However, as expected, the generic check\_sparse\_square\_solving routines produces row-major}
00012 \textcolor{comment}{// rhs and destination matrices when compiled with EIGEN\_DEFAULT\_TO\_ROW\_MAJOR}
00013 
00014 \textcolor{preprocessor}{#ifdef EIGEN\_DEFAULT\_TO\_ROW\_MAJOR}
00015 \textcolor{preprocessor}{#undef EIGEN\_DEFAULT\_TO\_ROW\_MAJOR}
00016 \textcolor{preprocessor}{#endif}
00017 
00018 \textcolor{preprocessor}{#include "sparse\_solver.h"}
00019 \textcolor{preprocessor}{#include <Eigen/SparseLU>}
00020 \textcolor{preprocessor}{#include <unsupported/Eigen/SparseExtra>}
00021 
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keywordtype}{void} test\_sparselu\_T()
00023 \{
00024   \hyperlink{group___sparse_l_u___module_class_eigen_1_1_sparse_l_u}{SparseLU<SparseMatrix<T, ColMajor>} \textcolor{comment}{/*, COLAMDOrdering<int>*/} > 
      sparselu\_colamd; \textcolor{comment}{// COLAMDOrdering is the default}
00025   \hyperlink{group___sparse_l_u___module_class_eigen_1_1_sparse_l_u}{SparseLU<SparseMatrix<T, ColMajor>}, 
      \hyperlink{group___ordering_methods___module_class_eigen_1_1_a_m_d_ordering}{AMDOrdering<int>} > sparselu\_amd; 
00026   \hyperlink{group___sparse_l_u___module_class_eigen_1_1_sparse_l_u}{SparseLU<SparseMatrix<T, ColMajor, long int>}, 
      \hyperlink{group___ordering_methods___module_class_eigen_1_1_natural_ordering}{NaturalOrdering<long int>} > sparselu\_natural;
00027   
00028   check\_sparse\_square\_solving(sparselu\_colamd,  300, 100000, \textcolor{keyword}{true}); 
00029   check\_sparse\_square\_solving(sparselu\_amd,     300,  10000, \textcolor{keyword}{true});
00030   check\_sparse\_square\_solving(sparselu\_natural, 300,   2000, \textcolor{keyword}{true});
00031   
00032   check\_sparse\_square\_abs\_determinant(sparselu\_colamd);
00033   check\_sparse\_square\_abs\_determinant(sparselu\_amd);
00034   
00035   check\_sparse\_square\_determinant(sparselu\_colamd);
00036   check\_sparse\_square\_determinant(sparselu\_amd);
00037 \}
00038 
00039 \textcolor{keywordtype}{void} test\_sparselu()
00040 \{
00041   CALL\_SUBTEST\_1(test\_sparselu\_T<float>()); 
00042   CALL\_SUBTEST\_2(test\_sparselu\_T<double>());
00043   CALL\_SUBTEST\_3(test\_sparselu\_T<std::complex<float> >()); 
00044   CALL\_SUBTEST\_4(test\_sparselu\_T<std::complex<double> >());
00045 \}
\end{DoxyCode}
