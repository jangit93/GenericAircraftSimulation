\hypertarget{matio_2visual__studio_2test_2eigen_2test_2sparse__permutations_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/sparse\+\_\+permutations.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2sparse__permutations_8cpp_source}\index{sparse\+\_\+permutations.\+cpp@{sparse\+\_\+permutations.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2011-2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 
00011 \textcolor{keyword}{static} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} nb\_transposed\_copies;
00012 \textcolor{preprocessor}{#define EIGEN\_SPARSE\_TRANSPOSED\_COPY\_PLUGIN \{nb\_transposed\_copies++;\}}
00013 \textcolor{preprocessor}{#define VERIFY\_TRANSPOSITION\_COUNT(XPR,N) \{\(\backslash\)}
00014 \textcolor{preprocessor}{    nb\_transposed\_copies = 0; \(\backslash\)}
00015 \textcolor{preprocessor}{    XPR; \(\backslash\)}
00016 \textcolor{preprocessor}{    if(nb\_transposed\_copies!=N) std::cerr << "nb\_transposed\_copies == " << nb\_transposed\_copies << "\(\backslash\)n"; \(\backslash\)}
00017 \textcolor{preprocessor}{    VERIFY( (#XPR) && nb\_transposed\_copies==N ); \(\backslash\)}
00018 \textcolor{preprocessor}{  \}}
00019 
00020 \textcolor{preprocessor}{#include "sparse.h"}
00021 
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00023 \textcolor{keywordtype}{bool} is\_sorted(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& mat) \{
00024   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = 0; k<mat.outerSize(); ++k)
00025   \{
00026     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} prev = -1;
00027     \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} T::InnerIterator it(mat,k); it; ++it)
00028     \{
00029       \textcolor{keywordflow}{if}(prev>=it.index())
00030         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00031       prev = it.index();
00032     \}
00033   \}
00034   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00035 \}
00036 
00037 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00038 \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<T,1>::type} eval(\textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module}{T} &xpr)
00039 \{
00040   VERIFY( \textcolor{keywordtype}{int}(internal::nested\_eval<T,1>::type::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) == \textcolor{keywordtype}{int}(
      internal::evaluator<T>::Flags&RowMajorBit) );
00041   \textcolor{keywordflow}{return} xpr;
00042 \}
00043 
00044 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} OtherStorage, \textcolor{keyword}{typename} SparseMatrixType> \textcolor{keywordtype}{void} sparse\_permutations(\textcolor{keyword}{const} SparseMatrixType& ref)
00045 \{
00046   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows = ref.rows();
00047   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols = ref.cols();
00048   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::Scalar Scalar;
00049   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::StorageIndex StorageIndex;
00050   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar, OtherStorage, StorageIndex>} 
      OtherSparseMatrixType;
00051   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} 
      \hyperlink{group___core___module}{DenseMatrix};
00052   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<StorageIndex,Dynamic,1>} VectorI;
00053 \textcolor{comment}{//   bool IsRowMajor1 = SparseMatrixType::IsRowMajor;}
00054 \textcolor{comment}{//   bool IsRowMajor2 = OtherSparseMatrixType::IsRowMajor;}
00055   
00056   \textcolor{keywordtype}{double} density = (std::max)(8./(rows*cols), 0.01);
00057   
00058   SparseMatrixType mat(rows, cols), up(rows,cols), lo(rows,cols);
00059   OtherSparseMatrixType res;
00060   DenseMatrix mat\_d = DenseMatrix::Zero(rows, cols), up\_sym\_d, lo\_sym\_d, res\_d;
00061   
00062   initSparse<Scalar>(density, mat\_d, mat, 0);
00063 
00064   up = mat.template triangularView<Upper>();
00065   lo = mat.template triangularView<Lower>();
00066   
00067   up\_sym\_d = mat\_d.template selfadjointView<Upper>();
00068   lo\_sym\_d = mat\_d.template selfadjointView<Lower>();
00069   
00070   VERIFY\_IS\_APPROX(mat, mat\_d);
00071   VERIFY\_IS\_APPROX(up, DenseMatrix(mat\_d.template triangularView<Upper>()));
00072   VERIFY\_IS\_APPROX(lo, DenseMatrix(mat\_d.template triangularView<Lower>()));
00073   
00074   \hyperlink{group___core___module_class_eigen_1_1_permutation_matrix}{PermutationMatrix<Dynamic>} p, p\_null;
00075   VectorI pi;
00076   randomPermutationVector(pi, cols);
00077   p.\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}() = pi;
00078 
00079   VERIFY( is\_sorted( ::eval(mat*p) ));
00080   VERIFY( is\_sorted( res = mat*p ));
00081   VERIFY\_TRANSPOSITION\_COUNT( ::eval(mat*p), 0);
00082   \textcolor{comment}{//VERIFY\_TRANSPOSITION\_COUNT( res = mat*p, IsRowMajor ? 1 : 0 );}
00083   res\_d = mat\_d*p;
00084   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"mat*p"});
00085 
00086   VERIFY( is\_sorted( ::eval(p*mat) ));
00087   VERIFY( is\_sorted( res = p*mat ));
00088   VERIFY\_TRANSPOSITION\_COUNT( ::eval(p*mat), 0);
00089   res\_d = p*mat\_d;
00090   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"p*mat"});
00091 
00092   VERIFY( is\_sorted( (mat*p).eval() ));
00093   VERIFY( is\_sorted( res = mat*p.inverse() ));
00094   VERIFY\_TRANSPOSITION\_COUNT( ::eval(mat*p.inverse()), 0);
00095   res\_d = mat*p.inverse();
00096   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"mat*inv(p)"});
00097 
00098   VERIFY( is\_sorted( (p*mat+p*mat).eval() ));
00099   VERIFY( is\_sorted( res = p.inverse()*mat ));
00100   VERIFY\_TRANSPOSITION\_COUNT( ::eval(p.inverse()*mat), 0);
00101   res\_d = p.inverse()*mat\_d;
00102   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"inv(p)*mat"});
00103 
00104   VERIFY( is\_sorted( (p * mat * p.inverse()).eval() ));
00105   VERIFY( is\_sorted( res = mat.twistedBy(p) ));
00106   VERIFY\_TRANSPOSITION\_COUNT( ::eval(p * mat * p.inverse()), 0);
00107   res\_d = (p * mat\_d) * p.inverse();
00108   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"p*mat*inv(p)"});
00109 
00110   
00111   VERIFY( is\_sorted( res = mat.template selfadjointView<Upper>().twistedBy(p\_null) ));
00112   res\_d = up\_sym\_d;
00113   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint upper to full"});
00114   
00115   VERIFY( is\_sorted( res = mat.template selfadjointView<Lower>().twistedBy(p\_null) ));
00116   res\_d = lo\_sym\_d;
00117   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint lower to full"});
00118   
00119   
00120   VERIFY( is\_sorted( res = up.template selfadjointView<Upper>().twistedBy(p\_null) ));
00121   res\_d = up\_sym\_d;
00122   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"upper selfadjoint to full"});
00123   
00124   VERIFY( is\_sorted( res = lo.template selfadjointView<Lower>().twistedBy(p\_null) ));
00125   res\_d = lo\_sym\_d;
00126   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"lower selfadjoint full"});
00127 
00128 
00129   VERIFY( is\_sorted( res = mat.template selfadjointView<Upper>() ));
00130   res\_d = up\_sym\_d;
00131   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint upper to full"});
00132 
00133   VERIFY( is\_sorted( res = mat.template selfadjointView<Lower>() ));
00134   res\_d = lo\_sym\_d;
00135   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint lower to full"});
00136 
00137   VERIFY( is\_sorted( res = up.template selfadjointView<Upper>() ));
00138   res\_d = up\_sym\_d;
00139   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"upper selfadjoint to full"});
00140 
00141   VERIFY( is\_sorted( res = lo.template selfadjointView<Lower>() ));
00142   res\_d = lo\_sym\_d;
00143   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"lower selfadjoint full"});
00144 
00145 
00146   res.template selfadjointView<Upper>() = mat.template selfadjointView<Upper>();
00147   res\_d = up\_sym\_d.template triangularView<Upper>();
00148   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint upper to upper"});
00149 
00150   res.template selfadjointView<Lower>() = mat.template selfadjointView<Upper>();
00151   res\_d = up\_sym\_d.template triangularView<Lower>();
00152   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint upper to lower"});
00153 
00154   res.template selfadjointView<Upper>() = mat.template selfadjointView<Lower>();
00155   res\_d = lo\_sym\_d.template triangularView<Upper>();
00156   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint lower to upper"});
00157 
00158   res.template selfadjointView<Lower>() = mat.template selfadjointView<Lower>();
00159   res\_d = lo\_sym\_d.template triangularView<Lower>();
00160   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint lower to lower"});
00161 
00162   
00163   
00164   res.template selfadjointView<Upper>() = mat.template selfadjointView<Upper>().twistedBy(p);
00165   res\_d = ((p * up\_sym\_d) * p.inverse()).eval().template triangularView<Upper>();
00166   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint upper twisted to upper"});
00167   
00168   res.template selfadjointView<Upper>() = mat.template selfadjointView<Lower>().twistedBy(p);
00169   res\_d = ((p * lo\_sym\_d) * p.inverse()).eval().template triangularView<Upper>();
00170   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint lower twisted to upper"});
00171   
00172   res.template selfadjointView<Lower>() = mat.template selfadjointView<Lower>().twistedBy(p);
00173   res\_d = ((p * lo\_sym\_d) * p.inverse()).eval().template triangularView<Lower>();
00174   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint lower twisted to lower"});
00175   
00176   res.template selfadjointView<Lower>() = mat.template selfadjointView<Upper>().twistedBy(p);
00177   res\_d = ((p * up\_sym\_d) * p.inverse()).eval().template triangularView<Lower>();
00178   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint upper twisted to lower"});
00179   
00180   
00181   res.template selfadjointView<Upper>() = up.template selfadjointView<Upper>().twistedBy(p);
00182   res\_d = ((p * up\_sym\_d) * p.inverse()).eval().template triangularView<Upper>();
00183   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"upper selfadjoint twisted to upper"});
00184   
00185   res.template selfadjointView<Upper>() = lo.template selfadjointView<Lower>().twistedBy(p);
00186   res\_d = ((p * lo\_sym\_d) * p.inverse()).eval().template triangularView<Upper>();
00187   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"lower selfadjoint twisted to upper"});
00188   
00189   res.template selfadjointView<Lower>() = lo.template selfadjointView<Lower>().twistedBy(p);
00190   res\_d = ((p * lo\_sym\_d) * p.inverse()).eval().template triangularView<Lower>();
00191   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"lower selfadjoint twisted to lower"});
00192   
00193   res.template selfadjointView<Lower>() = up.template selfadjointView<Upper>().twistedBy(p);
00194   res\_d = ((p * up\_sym\_d) * p.inverse()).eval().template triangularView<Lower>();
00195   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"upper selfadjoint twisted to lower"});
00196 
00197   
00198   VERIFY( is\_sorted( res = mat.template selfadjointView<Upper>().twistedBy(p) ));
00199   res\_d = (p * up\_sym\_d) * p.inverse();
00200   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint upper twisted to full"});
00201   
00202   VERIFY( is\_sorted( res = mat.template selfadjointView<Lower>().twistedBy(p) ));
00203   res\_d = (p * lo\_sym\_d) * p.inverse();
00204   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"full selfadjoint lower twisted to full"});
00205   
00206   VERIFY( is\_sorted( res = up.template selfadjointView<Upper>().twistedBy(p) ));
00207   res\_d = (p * up\_sym\_d) * p.inverse();
00208   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"upper selfadjoint twisted to full"});
00209   
00210   VERIFY( is\_sorted( res = lo.template selfadjointView<Lower>().twistedBy(p) ));
00211   res\_d = (p * lo\_sym\_d) * p.inverse();
00212   VERIFY(res.isApprox(res\_d) && \textcolor{stringliteral}{"lower selfadjoint twisted to full"});
00213 \}
00214 
00215 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} sparse\_permutations\_all(\textcolor{keywordtype}{int} size)
00216 \{
00217   CALL\_SUBTEST(( sparse\_permutations<ColMajor>(\hyperlink{group___sparse_core___module}{SparseMatrix<Scalar, ColMajor>}
      (size,size)) ));
00218   CALL\_SUBTEST(( sparse\_permutations<ColMajor>(\hyperlink{group___sparse_core___module}{SparseMatrix<Scalar, RowMajor>}
      (size,size)) ));
00219   CALL\_SUBTEST(( sparse\_permutations<RowMajor>(\hyperlink{group___sparse_core___module}{SparseMatrix<Scalar, ColMajor>}
      (size,size)) ));
00220   CALL\_SUBTEST(( sparse\_permutations<RowMajor>(\hyperlink{group___sparse_core___module}{SparseMatrix<Scalar, RowMajor>}
      (size,size)) ));
00221 \}
00222 
00223 \textcolor{keywordtype}{void} test\_sparse\_permutations()
00224 \{
00225   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00226     \textcolor{keywordtype}{int} s = Eigen::internal::random<int>(1,50);
00227     CALL\_SUBTEST\_1((  sparse\_permutations\_all<double>(s) ));
00228     CALL\_SUBTEST\_2((  sparse\_permutations\_all<std::complex<double> >(s) ));
00229   \}
00230 
00231   VERIFY((internal::is\_same<internal::permutation\_matrix\_product<
      \hyperlink{group___sparse_core___module}{SparseMatrix<double>},\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b}{OnTheRight},\textcolor{keyword}{false},\hyperlink{struct_eigen_1_1_sparse_shape}{SparseShape}>::ReturnType,
00232                             internal::nested\_eval<\hyperlink{group___core___module_class_eigen_1_1_product}{Product}<
      \hyperlink{group___sparse_core___module}{SparseMatrix<double>},\hyperlink{group___core___module}{PermutationMatrix<Dynamic,Dynamic>}
      ,AliasFreeProduct>,1>::type>::value));
00233 
00234   VERIFY((internal::is\_same<internal::permutation\_matrix\_product<
      \hyperlink{group___sparse_core___module}{SparseMatrix<double>},\hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4}{OnTheLeft},\textcolor{keyword}{false},\hyperlink{struct_eigen_1_1_sparse_shape}{SparseShape}>::ReturnType,
00235                             internal::nested\_eval<\hyperlink{group___core___module_class_eigen_1_1_product}{Product}<
      \hyperlink{group___core___module}{PermutationMatrix<Dynamic,Dynamic>},
      \hyperlink{group___sparse_core___module}{SparseMatrix<double>},AliasFreeProduct>,1>::type>::value));
00236 \}
\end{DoxyCode}
