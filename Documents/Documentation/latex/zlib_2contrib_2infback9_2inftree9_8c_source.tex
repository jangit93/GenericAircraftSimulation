\hypertarget{zlib_2contrib_2infback9_2inftree9_8c_source}{}\section{zlib/contrib/infback9/inftree9.c}
\label{zlib_2contrib_2infback9_2inftree9_8c_source}\index{inftree9.\+c@{inftree9.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* inftree9.c -- generate Huffman trees for efficient decoding}
00002 \textcolor{comment}{ * Copyright (C) 1995-2017 Mark Adler}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ */}
00005 
00006 \textcolor{preprocessor}{#include "zutil.h"}
00007 \textcolor{preprocessor}{#include "inftree9.h"}
00008 
00009 \textcolor{preprocessor}{#define MAXBITS 15}
00010 
00011 \textcolor{keyword}{const} \textcolor{keywordtype}{char} inflate9\_copyright[] =
00012    \textcolor{stringliteral}{" inflate9 1.2.11 Copyright 1995-2017 Mark Adler "};
00013 \textcolor{comment}{/*}
00014 \textcolor{comment}{  If you use the zlib library in a product, an acknowledgment is welcome}
00015 \textcolor{comment}{  in the documentation of your product. If for some reason you cannot}
00016 \textcolor{comment}{  include such an acknowledgment, I would appreciate that you keep this}
00017 \textcolor{comment}{  copyright string in the executable of your product.}
00018 \textcolor{comment}{ */}
00019 
00020 \textcolor{comment}{/*}
00021 \textcolor{comment}{   Build a set of tables to decode the provided canonical Huffman code.}
00022 \textcolor{comment}{   The code lengths are lens[0..codes-1].  The result starts at *table,}
00023 \textcolor{comment}{   whose indices are 0..2^bits-1.  work is a writable array of at least}
00024 \textcolor{comment}{   lens shorts, which is used as a work area.  type is the type of code}
00025 \textcolor{comment}{   to be generated, CODES, LENS, or DISTS.  On return, zero is success,}
00026 \textcolor{comment}{   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table}
00027 \textcolor{comment}{   on return points to the next available entry's address.  bits is the}
00028 \textcolor{comment}{   requested root table index bits, and on return it is the actual root}
00029 \textcolor{comment}{   table index bits.  It will differ if the request is greater than the}
00030 \textcolor{comment}{   longest code or if it is less than the shortest code.}
00031 \textcolor{comment}{ */}
00032 \textcolor{keywordtype}{int} inflate\_table9(type, lens, codes, table, bits, work)
00033 codetype type;
00034 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} FAR *lens;
00035 \textcolor{keywordtype}{unsigned} codes;
00036 \hyperlink{structcode}{code} FAR * FAR *table;
00037 \textcolor{keywordtype}{unsigned} FAR *bits;
00038 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} FAR *work;
00039 \{
00040     \textcolor{keywordtype}{unsigned} len;               \textcolor{comment}{/* a code's length in bits */}
00041     \textcolor{keywordtype}{unsigned} sym;               \textcolor{comment}{/* index of code symbols */}
00042     \textcolor{keywordtype}{unsigned} min, max;          \textcolor{comment}{/* minimum and maximum code lengths */}
00043     \textcolor{keywordtype}{unsigned} root;              \textcolor{comment}{/* number of index bits for root table */}
00044     \textcolor{keywordtype}{unsigned} curr;              \textcolor{comment}{/* number of index bits for current table */}
00045     \textcolor{keywordtype}{unsigned} drop;              \textcolor{comment}{/* code bits to drop for sub-table */}
00046     \textcolor{keywordtype}{int} left;                   \textcolor{comment}{/* number of prefix codes available */}
00047     \textcolor{keywordtype}{unsigned} used;              \textcolor{comment}{/* code entries in table used */}
00048     \textcolor{keywordtype}{unsigned} huff;              \textcolor{comment}{/* Huffman code */}
00049     \textcolor{keywordtype}{unsigned} incr;              \textcolor{comment}{/* for incrementing code, index */}
00050     \textcolor{keywordtype}{unsigned} fill;              \textcolor{comment}{/* index for replicating entries */}
00051     \textcolor{keywordtype}{unsigned} low;               \textcolor{comment}{/* low bits for current root entry */}
00052     \textcolor{keywordtype}{unsigned} mask;              \textcolor{comment}{/* mask for low root bits */}
00053     \hyperlink{structcode}{code} \textcolor{keyword}{this};                  \textcolor{comment}{/* table entry for duplication */}
00054     \hyperlink{structcode}{code} FAR *next;             \textcolor{comment}{/* next available space in table */}
00055     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} FAR *base;     \textcolor{comment}{/* base value table to use */}
00056     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} FAR *extra;    \textcolor{comment}{/* extra bits table to use */}
00057     \textcolor{keywordtype}{int} end;                    \textcolor{comment}{/* use base and extra for symbol > end */}
00058     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} count[MAXBITS+1];    \textcolor{comment}{/* number of codes of each length */}
00059     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} offs[MAXBITS+1];     \textcolor{comment}{/* offsets in table for each length */}
00060     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} lbase[31] = \{ \textcolor{comment}{/* Length codes 257..285 base */}
00061         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17,
00062         19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115,
00063         131, 163, 195, 227, 3, 0, 0\};
00064     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} lext[31] = \{ \textcolor{comment}{/* Length codes 257..285 extra */}
00065         128, 128, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129,
00066         130, 130, 130, 130, 131, 131, 131, 131, 132, 132, 132, 132,
00067         133, 133, 133, 133, 144, 77, 202\};
00068     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} dbase[32] = \{ \textcolor{comment}{/* Distance codes 0..31 base */}
00069         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49,
00070         65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073,
00071         4097, 6145, 8193, 12289, 16385, 24577, 32769, 49153\};
00072     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} dext[32] = \{ \textcolor{comment}{/* Distance codes 0..31 extra */}
00073         128, 128, 128, 128, 129, 129, 130, 130, 131, 131, 132, 132,
00074         133, 133, 134, 134, 135, 135, 136, 136, 137, 137, 138, 138,
00075         139, 139, 140, 140, 141, 141, 142, 142\};
00076 
00077     \textcolor{comment}{/*}
00078 \textcolor{comment}{       Process a set of code lengths to create a canonical Huffman code.  The}
00079 \textcolor{comment}{       code lengths are lens[0..codes-1].  Each length corresponds to the}
00080 \textcolor{comment}{       symbols 0..codes-1.  The Huffman code is generated by first sorting the}
00081 \textcolor{comment}{       symbols by length from short to long, and retaining the symbol order}
00082 \textcolor{comment}{       for codes with equal lengths.  Then the code starts with all zero bits}
00083 \textcolor{comment}{       for the first code of the shortest length, and the codes are integer}
00084 \textcolor{comment}{       increments for the same length, and zeros are appended as the length}
00085 \textcolor{comment}{       increases.  For the deflate format, these bits are stored backwards}
00086 \textcolor{comment}{       from their more natural integer increment ordering, and so when the}
00087 \textcolor{comment}{       decoding tables are built in the large loop below, the integer codes}
00088 \textcolor{comment}{       are incremented backwards.}
00089 \textcolor{comment}{}
00090 \textcolor{comment}{       This routine assumes, but does not check, that all of the entries in}
00091 \textcolor{comment}{       lens[] are in the range 0..MAXBITS.  The caller must assure this.}
00092 \textcolor{comment}{       1..MAXBITS is interpreted as that code length.  zero means that that}
00093 \textcolor{comment}{       symbol does not occur in this code.}
00094 \textcolor{comment}{}
00095 \textcolor{comment}{       The codes are sorted by computing a count of codes for each length,}
00096 \textcolor{comment}{       creating from that a table of starting indices for each length in the}
00097 \textcolor{comment}{       sorted table, and then entering the symbols in order in the sorted}
00098 \textcolor{comment}{       table.  The sorted table is work[], with that space being provided by}
00099 \textcolor{comment}{       the caller.}
00100 \textcolor{comment}{}
00101 \textcolor{comment}{       The length counts are used for other purposes as well, i.e. finding}
00102 \textcolor{comment}{       the minimum and maximum length codes, determining if there are any}
00103 \textcolor{comment}{       codes at all, checking for a valid set of lengths, and looking ahead}
00104 \textcolor{comment}{       at length counts to determine sub-table sizes when building the}
00105 \textcolor{comment}{       decoding tables.}
00106 \textcolor{comment}{     */}
00107 
00108     \textcolor{comment}{/* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */}
00109     \textcolor{keywordflow}{for} (len = 0; len <= MAXBITS; len++)
00110         count[len] = 0;
00111     \textcolor{keywordflow}{for} (sym = 0; sym < codes; sym++)
00112         count[lens[sym]]++;
00113 
00114     \textcolor{comment}{/* bound code lengths, force root to be within code lengths */}
00115     root = *bits;
00116     \textcolor{keywordflow}{for} (max = MAXBITS; max >= 1; max--)
00117         \textcolor{keywordflow}{if} (count[max] != 0) \textcolor{keywordflow}{break};
00118     \textcolor{keywordflow}{if} (root > max) root = max;
00119     \textcolor{keywordflow}{if} (max == 0) \textcolor{keywordflow}{return} -1;            \textcolor{comment}{/* no codes! */}
00120     \textcolor{keywordflow}{for} (min = 1; min <= MAXBITS; min++)
00121         \textcolor{keywordflow}{if} (count[min] != 0) \textcolor{keywordflow}{break};
00122     \textcolor{keywordflow}{if} (root < min) root = min;
00123 
00124     \textcolor{comment}{/* check for an over-subscribed or incomplete set of lengths */}
00125     left = 1;
00126     \textcolor{keywordflow}{for} (len = 1; len <= MAXBITS; len++) \{
00127         left <<= 1;
00128         left -= count[len];
00129         \textcolor{keywordflow}{if} (left < 0) \textcolor{keywordflow}{return} -1;        \textcolor{comment}{/* over-subscribed */}
00130     \}
00131     \textcolor{keywordflow}{if} (left > 0 && (type == CODES || max != 1))
00132         \textcolor{keywordflow}{return} -1;                      \textcolor{comment}{/* incomplete set */}
00133 
00134     \textcolor{comment}{/* generate offsets into symbol table for each length for sorting */}
00135     offs[1] = 0;
00136     \textcolor{keywordflow}{for} (len = 1; len < MAXBITS; len++)
00137         offs[len + 1] = offs[len] + count[len];
00138 
00139     \textcolor{comment}{/* sort symbols by length, by symbol order within each length */}
00140     \textcolor{keywordflow}{for} (sym = 0; sym < codes; sym++)
00141         \textcolor{keywordflow}{if} (lens[sym] != 0) work[offs[lens[sym]]++] = (\textcolor{keywordtype}{unsigned} short)sym;
00142 
00143     \textcolor{comment}{/*}
00144 \textcolor{comment}{       Create and fill in decoding tables.  In this loop, the table being}
00145 \textcolor{comment}{       filled is at next and has curr index bits.  The code being used is huff}
00146 \textcolor{comment}{       with length len.  That code is converted to an index by dropping drop}
00147 \textcolor{comment}{       bits off of the bottom.  For codes where len is less than drop + curr,}
00148 \textcolor{comment}{       those top drop + curr - len bits are incremented through all values to}
00149 \textcolor{comment}{       fill the table with replicated entries.}
00150 \textcolor{comment}{}
00151 \textcolor{comment}{       root is the number of index bits for the root table.  When len exceeds}
00152 \textcolor{comment}{       root, sub-tables are created pointed to by the root entry with an index}
00153 \textcolor{comment}{       of the low root bits of huff.  This is saved in low to check for when a}
00154 \textcolor{comment}{       new sub-table should be started.  drop is zero when the root table is}
00155 \textcolor{comment}{       being filled, and drop is root when sub-tables are being filled.}
00156 \textcolor{comment}{}
00157 \textcolor{comment}{       When a new sub-table is needed, it is necessary to look ahead in the}
00158 \textcolor{comment}{       code lengths to determine what size sub-table is needed.  The length}
00159 \textcolor{comment}{       counts are used for this, and so count[] is decremented as codes are}
00160 \textcolor{comment}{       entered in the tables.}
00161 \textcolor{comment}{}
00162 \textcolor{comment}{       used keeps track of how many table entries have been allocated from the}
00163 \textcolor{comment}{       provided *table space.  It is checked for LENS and DIST tables against}
00164 \textcolor{comment}{       the constants ENOUGH\_LENS and ENOUGH\_DISTS to guard against changes in}
00165 \textcolor{comment}{       the initial root table size constants.  See the comments in inftree9.h}
00166 \textcolor{comment}{       for more information.}
00167 \textcolor{comment}{}
00168 \textcolor{comment}{       sym increments through all symbols, and the loop terminates when}
00169 \textcolor{comment}{       all codes of length max, i.e. all codes, have been processed.  This}
00170 \textcolor{comment}{       routine permits incomplete codes, so another loop after this one fills}
00171 \textcolor{comment}{       in the rest of the decoding tables with invalid code markers.}
00172 \textcolor{comment}{     */}
00173 
00174     \textcolor{comment}{/* set up for code type */}
00175     \textcolor{keywordflow}{switch} (type) \{
00176     \textcolor{keywordflow}{case} CODES:
00177         base = extra = work;    \textcolor{comment}{/* dummy value--not used */}
00178         end = 19;
00179         \textcolor{keywordflow}{break};
00180     \textcolor{keywordflow}{case} LENS:
00181         base = lbase;
00182         base -= 257;
00183         extra = lext;
00184         extra -= 257;
00185         end = 256;
00186         \textcolor{keywordflow}{break};
00187     \textcolor{keywordflow}{default}:            \textcolor{comment}{/* DISTS */}
00188         base = dbase;
00189         extra = dext;
00190         end = -1;
00191     \}
00192 
00193     \textcolor{comment}{/* initialize state for loop */}
00194     huff = 0;                   \textcolor{comment}{/* starting code */}
00195     sym = 0;                    \textcolor{comment}{/* starting code symbol */}
00196     len = min;                  \textcolor{comment}{/* starting code length */}
00197     next = *table;              \textcolor{comment}{/* current table to fill in */}
00198     curr = root;                \textcolor{comment}{/* current table index bits */}
00199     drop = 0;                   \textcolor{comment}{/* current bits to drop from code for index */}
00200     low = (unsigned)(-1);       \textcolor{comment}{/* trigger new sub-table when len > root */}
00201     used = 1U << root;          \textcolor{comment}{/* use root table entries */}
00202     mask = used - 1;            \textcolor{comment}{/* mask for comparing low */}
00203 
00204     \textcolor{comment}{/* check available table space */}
00205     \textcolor{keywordflow}{if} ((type == LENS && used >= ENOUGH\_LENS) ||
00206         (type == DISTS && used >= ENOUGH\_DISTS))
00207         \textcolor{keywordflow}{return} 1;
00208 
00209     \textcolor{comment}{/* process all codes and make table entries */}
00210     \textcolor{keywordflow}{for} (;;) \{
00211         \textcolor{comment}{/* create table entry */}
00212         this.bits = (\textcolor{keywordtype}{unsigned} char)(len - drop);
00213         \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{int})(work[sym]) < end) \{
00214             this.op = (\textcolor{keywordtype}{unsigned} char)0;
00215             this.val = work[sym];
00216         \}
00217         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{int})(work[sym]) > end) \{
00218             this.op = (\textcolor{keywordtype}{unsigned} char)(extra[work[sym]]);
00219             this.val = base[work[sym]];
00220         \}
00221         \textcolor{keywordflow}{else} \{
00222             this.op = (\textcolor{keywordtype}{unsigned} char)(32 + 64);         \textcolor{comment}{/* end of block */}
00223             this.val = 0;
00224         \}
00225 
00226         \textcolor{comment}{/* replicate for those indices with low len bits equal to huff */}
00227         incr = 1U << (len - drop);
00228         fill = 1U << curr;
00229         \textcolor{keywordflow}{do} \{
00230             fill -= incr;
00231             next[(huff >> drop) + fill] = \textcolor{keyword}{this};
00232         \} \textcolor{keywordflow}{while} (fill != 0);
00233 
00234         \textcolor{comment}{/* backwards increment the len-bit code huff */}
00235         incr = 1U << (len - 1);
00236         \textcolor{keywordflow}{while} (huff & incr)
00237             incr >>= 1;
00238         \textcolor{keywordflow}{if} (incr != 0) \{
00239             huff &= incr - 1;
00240             huff += incr;
00241         \}
00242         \textcolor{keywordflow}{else}
00243             huff = 0;
00244 
00245         \textcolor{comment}{/* go to next symbol, update count, len */}
00246         sym++;
00247         \textcolor{keywordflow}{if} (--(count[len]) == 0) \{
00248             \textcolor{keywordflow}{if} (len == max) \textcolor{keywordflow}{break};
00249             len = lens[work[sym]];
00250         \}
00251 
00252         \textcolor{comment}{/* create new sub-table if needed */}
00253         \textcolor{keywordflow}{if} (len > root && (huff & mask) != low) \{
00254             \textcolor{comment}{/* if first time, transition to sub-tables */}
00255             \textcolor{keywordflow}{if} (drop == 0)
00256                 drop = root;
00257 
00258             \textcolor{comment}{/* increment past last table */}
00259             next += 1U << curr;
00260 
00261             \textcolor{comment}{/* determine length of next table */}
00262             curr = len - drop;
00263             left = (int)(1 << curr);
00264             \textcolor{keywordflow}{while} (curr + drop < max) \{
00265                 left -= count[curr + drop];
00266                 \textcolor{keywordflow}{if} (left <= 0) \textcolor{keywordflow}{break};
00267                 curr++;
00268                 left <<= 1;
00269             \}
00270 
00271             \textcolor{comment}{/* check for enough space */}
00272             used += 1U << curr;
00273             \textcolor{keywordflow}{if} ((type == LENS && used >= ENOUGH\_LENS) ||
00274                 (type == DISTS && used >= ENOUGH\_DISTS))
00275                 \textcolor{keywordflow}{return} 1;
00276 
00277             \textcolor{comment}{/* point entry in root table to sub-table */}
00278             low = huff & mask;
00279             (*table)[low].op = (\textcolor{keywordtype}{unsigned} char)curr;
00280             (*table)[low].bits = (\textcolor{keywordtype}{unsigned} char)root;
00281             (*table)[low].val = (\textcolor{keywordtype}{unsigned} short)(next - *table);
00282         \}
00283     \}
00284 
00285     \textcolor{comment}{/*}
00286 \textcolor{comment}{       Fill in rest of table for incomplete codes.  This loop is similar to the}
00287 \textcolor{comment}{       loop above in incrementing huff for table indices.  It is assumed that}
00288 \textcolor{comment}{       len is equal to curr + drop, so there is no loop needed to increment}
00289 \textcolor{comment}{       through high index bits.  When the current sub-table is filled, the loop}
00290 \textcolor{comment}{       drops back to the root table to fill in any remaining entries there.}
00291 \textcolor{comment}{     */}
00292     this.op = (\textcolor{keywordtype}{unsigned} char)64;                \textcolor{comment}{/* invalid code marker */}
00293     this.bits = (\textcolor{keywordtype}{unsigned} char)(len - drop);
00294     this.val = (\textcolor{keywordtype}{unsigned} short)0;
00295     \textcolor{keywordflow}{while} (huff != 0) \{
00296         \textcolor{comment}{/* when done with sub-table, drop back to root table */}
00297         \textcolor{keywordflow}{if} (drop != 0 && (huff & mask) != low) \{
00298             drop = 0;
00299             len = root;
00300             next = *table;
00301             curr = root;
00302             this.bits = (\textcolor{keywordtype}{unsigned} char)len;
00303         \}
00304 
00305         \textcolor{comment}{/* put invalid code marker in table */}
00306         next[huff >> drop] = \textcolor{keyword}{this};
00307 
00308         \textcolor{comment}{/* backwards increment the len-bit code huff */}
00309         incr = 1U << (len - 1);
00310         \textcolor{keywordflow}{while} (huff & incr)
00311             incr >>= 1;
00312         \textcolor{keywordflow}{if} (incr != 0) \{
00313             huff &= incr - 1;
00314             huff += incr;
00315         \}
00316         \textcolor{keywordflow}{else}
00317             huff = 0;
00318     \}
00319 
00320     \textcolor{comment}{/* set return parameters */}
00321     *table += used;
00322     *bits = root;
00323     \textcolor{keywordflow}{return} 0;
00324 \}
\end{DoxyCode}
