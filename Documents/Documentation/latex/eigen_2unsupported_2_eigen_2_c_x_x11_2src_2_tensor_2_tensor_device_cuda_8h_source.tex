\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_device_cuda_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Device\+Cuda.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_device_cuda_8h_source}\index{Tensor\+Device\+Cuda.\+h@{Tensor\+Device\+Cuda.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#if defined(EIGEN\_USE\_GPU) && !defined(EIGEN\_CXX11\_TENSOR\_TENSOR\_DEVICE\_CUDA\_H)}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_DEVICE\_CUDA\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} kCudaScratchSize = 1024;
00016 
00017 \textcolor{comment}{// This defines an interface that GPUDevice can take to use}
00018 \textcolor{comment}{// CUDA streams underneath.}
00019 \textcolor{keyword}{class }StreamInterface \{
00020  \textcolor{keyword}{public}:
00021   \textcolor{keyword}{virtual} ~StreamInterface() \{\}
00022 
00023   \textcolor{keyword}{virtual} \textcolor{keyword}{const} cudaStream\_t& stream() \textcolor{keyword}{const} = 0;
00024   \textcolor{keyword}{virtual} \textcolor{keyword}{const} cudaDeviceProp& deviceProperties() \textcolor{keyword}{const} = 0;
00025 
00026   \textcolor{comment}{// Allocate memory on the actual device where the computation will run}
00027   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void}* allocate(\textcolor{keywordtype}{size\_t} num\_bytes) \textcolor{keyword}{const} = 0;
00028   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} deallocate(\textcolor{keywordtype}{void}* buffer) \textcolor{keyword}{const} = 0;
00029 
00030   \textcolor{comment}{// Return a scratchpad buffer of size 1k}
00031   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void}* scratchpad() \textcolor{keyword}{const} = 0;
00032 
00033   \textcolor{comment}{// Return a semaphore. The semaphore is initially initialized to 0, and}
00034   \textcolor{comment}{// each kernel using it is responsible for resetting to 0 upon completion}
00035   \textcolor{comment}{// to maintain the invariant that the semaphore is always equal to 0 upon}
00036   \textcolor{comment}{// each kernel start.}
00037   \textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* semaphore() \textcolor{keyword}{const} = 0;
00038 \};
00039 
00040 \textcolor{keyword}{static} cudaDeviceProp* m\_deviceProperties;
00041 \textcolor{keyword}{static} \textcolor{keywordtype}{bool} m\_devicePropInitialized = \textcolor{keyword}{false};
00042 
00043 \textcolor{keyword}{static} \textcolor{keywordtype}{void} initializeDeviceProp() \{
00044   \textcolor{keywordflow}{if} (!m\_devicePropInitialized) \{
00045     \textcolor{comment}{// Attempts to ensure proper behavior in the case of multiple threads}
00046     \textcolor{comment}{// calling this function simultaneously. This would be trivial to}
00047     \textcolor{comment}{// implement if we could use std::mutex, but unfortunately mutex don't}
00048     \textcolor{comment}{// compile with nvcc, so we resort to atomics and thread fences instead.}
00049     \textcolor{comment}{// Note that if the caller uses a compiler that doesn't support c++11 we}
00050     \textcolor{comment}{// can't ensure that the initialization is thread safe.}
00051 \textcolor{preprocessor}{#if \_\_cplusplus >= 201103L}
00052     \textcolor{keyword}{static} std::atomic<bool> first(\textcolor{keyword}{true});
00053     \textcolor{keywordflow}{if} (first.exchange(\textcolor{keyword}{false})) \{
00054 \textcolor{preprocessor}{#else}
00055     \textcolor{keyword}{static} \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};
00056     \textcolor{keywordflow}{if} (first) \{
00057       first = \textcolor{keyword}{false};
00058 \textcolor{preprocessor}{#endif}
00059       \textcolor{comment}{// We're the first thread to reach this point.}
00060       \textcolor{keywordtype}{int} num\_devices;
00061       cudaError\_t status = cudaGetDeviceCount(&num\_devices);
00062       \textcolor{keywordflow}{if} (status != cudaSuccess) \{
00063         std::cerr << \textcolor{stringliteral}{"Failed to get the number of CUDA devices: "}
00064                   << cudaGetErrorString(status)
00065                   << std::endl;
00066         assert(status == cudaSuccess);
00067       \}
00068       m\_deviceProperties = \textcolor{keyword}{new} cudaDeviceProp[num\_devices];
00069       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_devices; ++i) \{
00070         status = cudaGetDeviceProperties(&m\_deviceProperties[i], i);
00071         \textcolor{keywordflow}{if} (status != cudaSuccess) \{
00072           std::cerr << \textcolor{stringliteral}{"Failed to initialize CUDA device #"}
00073                     << i
00074                     << \textcolor{stringliteral}{": "}
00075                     << cudaGetErrorString(status)
00076                     << std::endl;
00077           assert(status == cudaSuccess);
00078         \}
00079       \}
00080 
00081 \textcolor{preprocessor}{#if \_\_cplusplus >= 201103L}
00082       std::atomic\_thread\_fence(std::memory\_order\_release);
00083 \textcolor{preprocessor}{#endif}
00084       m\_devicePropInitialized = \textcolor{keyword}{true};
00085     \} \textcolor{keywordflow}{else} \{
00086       \textcolor{comment}{// Wait for the other thread to inititialize the properties.}
00087       \textcolor{keywordflow}{while} (!m\_devicePropInitialized) \{
00088 \textcolor{preprocessor}{#if \_\_cplusplus >= 201103L}
00089         std::atomic\_thread\_fence(std::memory\_order\_acquire);
00090 \textcolor{preprocessor}{#endif}
00091         sleep(1);
00092       \}
00093     \}
00094   \}
00095 \}
00096 
00097 \textcolor{keyword}{static} \textcolor{keyword}{const} cudaStream\_t default\_stream = cudaStreamDefault;
00098 
00099 \textcolor{keyword}{class }CudaStreamDevice : \textcolor{keyword}{public} StreamInterface \{
00100  \textcolor{keyword}{public}:
00101   \textcolor{comment}{// Use the default stream on the current device}
00102   CudaStreamDevice() : stream\_(&default\_stream), scratch\_(NULL), semaphore\_(NULL) \{
00103     cudaGetDevice(&device\_);
00104     initializeDeviceProp();
00105   \}
00106   \textcolor{comment}{// Use the default stream on the specified device}
00107   CudaStreamDevice(\textcolor{keywordtype}{int} device) : stream\_(&default\_stream), device\_(device), scratch\_(NULL), semaphore\_(NULL
      ) \{
00108     initializeDeviceProp();
00109   \}
00110   \textcolor{comment}{// Use the specified stream. Note that it's the}
00111   \textcolor{comment}{// caller responsibility to ensure that the stream can run on}
00112   \textcolor{comment}{// the specified device. If no device is specified the code}
00113   \textcolor{comment}{// assumes that the stream is associated to the current gpu device.}
00114   CudaStreamDevice(\textcolor{keyword}{const} cudaStream\_t* stream, \textcolor{keywordtype}{int} device = -1)
00115       : stream\_(stream), device\_(device), scratch\_(NULL), semaphore\_(NULL) \{
00116     \textcolor{keywordflow}{if} (device < 0) \{
00117       cudaGetDevice(&device\_);
00118     \} \textcolor{keywordflow}{else} \{
00119       \textcolor{keywordtype}{int} num\_devices;
00120       cudaError\_t err = cudaGetDeviceCount(&num\_devices);
00121       EIGEN\_UNUSED\_VARIABLE(err)
00122       assert(err == cudaSuccess);
00123       assert(device < num\_devices);
00124       device\_ = device;
00125     \}
00126     initializeDeviceProp();
00127   \}
00128 
00129   \textcolor{keyword}{virtual} ~CudaStreamDevice() \{
00130     \textcolor{keywordflow}{if} (scratch\_) \{
00131       deallocate(scratch\_);
00132     \}
00133   \}
00134 
00135   \textcolor{keyword}{const} cudaStream\_t& stream()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *stream\_; \}
00136   \textcolor{keyword}{const} cudaDeviceProp& deviceProperties()\textcolor{keyword}{ const }\{
00137     \textcolor{keywordflow}{return} m\_deviceProperties[device\_];
00138   \}
00139   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void}* allocate(\textcolor{keywordtype}{size\_t} num\_bytes)\textcolor{keyword}{ const }\{
00140     cudaError\_t err = cudaSetDevice(device\_);
00141     EIGEN\_UNUSED\_VARIABLE(err)
00142     assert(err == cudaSuccess);
00143     \textcolor{keywordtype}{void}* result;
00144     err = cudaMalloc(&result, num\_bytes);
00145     assert(err == cudaSuccess);
00146     assert(result != NULL);
00147     \textcolor{keywordflow}{return} result;
00148   \}
00149   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} deallocate(\textcolor{keywordtype}{void}* buffer)\textcolor{keyword}{ const }\{
00150     cudaError\_t err = cudaSetDevice(device\_);
00151     EIGEN\_UNUSED\_VARIABLE(err)
00152     assert(err == cudaSuccess);
00153     assert(buffer != NULL);
00154     err = cudaFree(buffer);
00155     assert(err == cudaSuccess);
00156   \}
00157 
00158   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void}* scratchpad()\textcolor{keyword}{ const }\{
00159     \textcolor{keywordflow}{if} (scratch\_ == NULL) \{
00160       scratch\_ = allocate(kCudaScratchSize + \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
00161     \}
00162     \textcolor{keywordflow}{return} scratch\_;
00163   \}
00164 
00165   \textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* semaphore()\textcolor{keyword}{ const }\{
00166     \textcolor{keywordflow}{if} (semaphore\_ == NULL) \{
00167       \textcolor{keywordtype}{char}* scratch = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(scratchpad()) + kCudaScratchSize;
00168       semaphore\_ = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}*\textcolor{keyword}{>}(scratch);
00169       cudaError\_t err = cudaMemsetAsync(semaphore\_, 0, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}), *stream\_);
00170       EIGEN\_UNUSED\_VARIABLE(err)
00171       assert(err == cudaSuccess);
00172     \}
00173     \textcolor{keywordflow}{return} semaphore\_;
00174   \}
00175 
00176  \textcolor{keyword}{private}:
00177   \textcolor{keyword}{const} cudaStream\_t* stream\_;
00178   \textcolor{keywordtype}{int} device\_;
00179   \textcolor{keyword}{mutable} \textcolor{keywordtype}{void}* scratch\_;
00180   \textcolor{keyword}{mutable} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* semaphore\_;
00181 \};
00182 
00183 \textcolor{keyword}{struct }GpuDevice \{
00184   \textcolor{comment}{// The StreamInterface is not owned: the caller is}
00185   \textcolor{comment}{// responsible for its initialization and eventual destruction.}
00186   \textcolor{keyword}{explicit} GpuDevice(\textcolor{keyword}{const} StreamInterface* stream) : stream\_(stream), max\_blocks\_(INT\_MAX) \{
00187     eigen\_assert(stream);
00188   \}
00189   \textcolor{keyword}{explicit} GpuDevice(\textcolor{keyword}{const} StreamInterface* stream, \textcolor{keywordtype}{int} num\_blocks) : stream\_(stream), max\_blocks\_(
      num\_blocks) \{
00190     eigen\_assert(stream);
00191   \}
00192   \textcolor{comment}{// TODO(bsteiner): This is an internal API, we should not expose it.}
00193   EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} cudaStream\_t& stream()\textcolor{keyword}{ const }\{
00194     \textcolor{keywordflow}{return} stream\_->stream();
00195   \}
00196 
00197   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}* allocate(\textcolor{keywordtype}{size\_t} num\_bytes)\textcolor{keyword}{ const }\{
00198     \textcolor{keywordflow}{return} stream\_->allocate(num\_bytes);
00199   \}
00200 
00201   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} deallocate(\textcolor{keywordtype}{void}* buffer)\textcolor{keyword}{ const }\{
00202     stream\_->deallocate(buffer);
00203   \}
00204 
00205   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}* scratchpad()\textcolor{keyword}{ const }\{
00206     \textcolor{keywordflow}{return} stream\_->scratchpad();
00207   \}
00208 
00209   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* semaphore()\textcolor{keyword}{ const }\{
00210     \textcolor{keywordflow}{return} stream\_->semaphore();
00211   \}
00212 
00213   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} memcpy(\textcolor{keywordtype}{void}* dst, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* src, \textcolor{keywordtype}{size\_t} n)\textcolor{keyword}{ const }\{
00214 \textcolor{preprocessor}{#ifndef \_\_CUDA\_ARCH\_\_}
00215     cudaError\_t err = cudaMemcpyAsync(dst, src, n, cudaMemcpyDeviceToDevice,
00216                                       stream\_->stream());
00217     EIGEN\_UNUSED\_VARIABLE(err)
00218     assert(err == cudaSuccess);
00219 \textcolor{preprocessor}{#else}
00220   eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"The default device should be used instead to generate kernel code"});
00221 \textcolor{preprocessor}{#endif}
00222   \}
00223 
00224   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} memcpyHostToDevice(\textcolor{keywordtype}{void}* dst, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* src, \textcolor{keywordtype}{size\_t} n)\textcolor{keyword}{ const }\{
00225     cudaError\_t err =
00226         cudaMemcpyAsync(dst, src, n, cudaMemcpyHostToDevice, stream\_->stream());
00227     EIGEN\_UNUSED\_VARIABLE(err)
00228     assert(err == cudaSuccess);
00229   \}
00230 
00231   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} memcpyDeviceToHost(\textcolor{keywordtype}{void}* dst, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* src, \textcolor{keywordtype}{size\_t} n)\textcolor{keyword}{ const }\{
00232     cudaError\_t err =
00233         cudaMemcpyAsync(dst, src, n, cudaMemcpyDeviceToHost, stream\_->stream());
00234     EIGEN\_UNUSED\_VARIABLE(err)
00235     assert(err == cudaSuccess);
00236   \}
00237 
00238   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} memset(\textcolor{keywordtype}{void}* buffer, \textcolor{keywordtype}{int} c, \textcolor{keywordtype}{size\_t} n)\textcolor{keyword}{ const }\{
00239 \textcolor{preprocessor}{#ifndef \_\_CUDA\_ARCH\_\_}
00240     cudaError\_t err = cudaMemsetAsync(buffer, c, n, stream\_->stream());
00241     EIGEN\_UNUSED\_VARIABLE(err)
00242     assert(err == cudaSuccess);
00243 \textcolor{preprocessor}{#else}
00244   eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"The default device should be used instead to generate kernel code"});
00245 \textcolor{preprocessor}{#endif}
00246   \}
00247 
00248   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{size\_t} numThreads()\textcolor{keyword}{ const }\{
00249     \textcolor{comment}{// FIXME}
00250     \textcolor{keywordflow}{return} 32;
00251   \}
00252 
00253   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{size\_t} firstLevelCacheSize()\textcolor{keyword}{ const }\{
00254     \textcolor{comment}{// FIXME}
00255     \textcolor{keywordflow}{return} 48*1024;
00256   \}
00257 
00258   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{size\_t} lastLevelCacheSize()\textcolor{keyword}{ const }\{
00259     \textcolor{comment}{// We won't try to take advantage of the l2 cache for the time being, and}
00260     \textcolor{comment}{// there is no l3 cache on cuda devices.}
00261     \textcolor{keywordflow}{return} firstLevelCacheSize();
00262   \}
00263 
00264   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} synchronize()\textcolor{keyword}{ const }\{
00265 \textcolor{preprocessor}{#if defined(\_\_CUDACC\_\_) && !defined(\_\_CUDA\_ARCH\_\_)}
00266     cudaError\_t err = cudaStreamSynchronize(stream\_->stream());
00267     \textcolor{keywordflow}{if} (err != cudaSuccess) \{
00268       std::cerr << \textcolor{stringliteral}{"Error detected in CUDA stream: "}
00269                 << cudaGetErrorString(err)
00270                 << std::endl;
00271       assert(err == cudaSuccess);
00272     \}
00273 \textcolor{preprocessor}{#else}
00274     assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"The default device should be used instead to generate kernel code"});
00275 \textcolor{preprocessor}{#endif}
00276   \}
00277 
00278   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} getNumCudaMultiProcessors()\textcolor{keyword}{ const }\{
00279     \textcolor{keywordflow}{return} stream\_->deviceProperties().multiProcessorCount;
00280   \}
00281   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} maxCudaThreadsPerBlock()\textcolor{keyword}{ const }\{
00282     \textcolor{keywordflow}{return} stream\_->deviceProperties().maxThreadsPerBlock;
00283   \}
00284   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} maxCudaThreadsPerMultiProcessor()\textcolor{keyword}{ const }\{
00285     \textcolor{keywordflow}{return} stream\_->deviceProperties().maxThreadsPerMultiProcessor;
00286   \}
00287   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} sharedMemPerBlock()\textcolor{keyword}{ const }\{
00288     \textcolor{keywordflow}{return} stream\_->deviceProperties().sharedMemPerBlock;
00289   \}
00290   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} majorDeviceVersion()\textcolor{keyword}{ const }\{
00291     \textcolor{keywordflow}{return} stream\_->deviceProperties().major;
00292   \}
00293   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} minorDeviceVersion()\textcolor{keyword}{ const }\{
00294     \textcolor{keywordflow}{return} stream\_->deviceProperties().minor;
00295   \}
00296 
00297   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} maxBlocks()\textcolor{keyword}{ const }\{
00298     \textcolor{keywordflow}{return} max\_blocks\_;
00299   \}
00300 
00301   \textcolor{comment}{// This function checks if the CUDA runtime recorded an error for the}
00302   \textcolor{comment}{// underlying stream device.}
00303   \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} ok()\textcolor{keyword}{ const }\{
00304 \textcolor{preprocessor}{#ifdef \_\_CUDACC\_\_}
00305     cudaError\_t error = cudaStreamQuery(stream\_->stream());
00306     \textcolor{keywordflow}{return} (error == cudaSuccess) || (error == cudaErrorNotReady);
00307 \textcolor{preprocessor}{#else}
00308     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00309 \textcolor{preprocessor}{#endif}
00310   \}
00311 
00312  \textcolor{keyword}{private}:
00313   \textcolor{keyword}{const} StreamInterface* stream\_;
00314   \textcolor{keywordtype}{int} max\_blocks\_;
00315 \};
00316 
00317 \textcolor{preprocessor}{#define LAUNCH\_CUDA\_KERNEL(kernel, gridsize, blocksize, sharedmem, device, ...)             \(\backslash\)}
00318 \textcolor{preprocessor}{  (kernel) <<< (gridsize), (blocksize), (sharedmem), (device).stream() >>> (\_\_VA\_ARGS\_\_);   \(\backslash\)}
00319 \textcolor{preprocessor}{  assert(cudaGetLastError() == cudaSuccess);}
00320 
00321 
00322 \textcolor{comment}{// FIXME: Should be device and kernel specific.}
00323 \textcolor{preprocessor}{#ifdef \_\_CUDACC\_\_}
00324 \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} setCudaSharedMemConfig(cudaSharedMemConfig 
      \hyperlink{structconfig__s}{config}) \{
00325 \textcolor{preprocessor}{#ifndef \_\_CUDA\_ARCH\_\_}
00326   cudaError\_t status = cudaDeviceSetSharedMemConfig(config);
00327   EIGEN\_UNUSED\_VARIABLE(status)
00328   assert(status == cudaSuccess);
00329 \textcolor{preprocessor}{#else}
00330   EIGEN\_UNUSED\_VARIABLE(config)
00331 \textcolor{preprocessor}{#endif}
00332 \}
00333 \textcolor{preprocessor}{#endif}
00334 
00335 \}  \textcolor{comment}{// end namespace Eigen}
00336 
00337 \textcolor{preprocessor}{#endif  // EIGEN\_CXX11\_TENSOR\_TENSOR\_DEVICE\_CUDA\_H}
\end{DoxyCode}
