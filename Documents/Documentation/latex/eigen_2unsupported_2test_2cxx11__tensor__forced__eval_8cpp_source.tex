\hypertarget{eigen_2unsupported_2test_2cxx11__tensor__forced__eval_8cpp_source}{}\section{eigen/unsupported/test/cxx11\+\_\+tensor\+\_\+forced\+\_\+eval.cpp}
\label{eigen_2unsupported_2test_2cxx11__tensor__forced__eval_8cpp_source}\index{cxx11\+\_\+tensor\+\_\+forced\+\_\+eval.\+cpp@{cxx11\+\_\+tensor\+\_\+forced\+\_\+eval.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{preprocessor}{#include <Eigen/Core>}
00013 \textcolor{preprocessor}{#include <Eigen/CXX11/Tensor>}
00014 
00015 \textcolor{keyword}{using} Eigen::MatrixXf;
00016 \textcolor{keyword}{using} \hyperlink{class_eigen_1_1_tensor}{Eigen::Tensor};
00017 
00018 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_simple()
00019 \{
00020   MatrixXf m1(3,3);
00021   MatrixXf m2(3,3);
00022   m1.setRandom();
00023   m2.setRandom();
00024 
00025   TensorMap<Tensor<float, 2> > mat1(m1.data(), 3,3);
00026   TensorMap<Tensor<float, 2> > mat2(m2.data(), 3,3);
00027 
00028   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 2>} mat3(3,3);
00029   mat3 = mat1;
00030 
00031   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 1>::DimensionPair} DimPair;
00032   \hyperlink{class_eigen_1_1array}{Eigen::array<DimPair, 1>} dims;
00033   dims[0] = DimPair(1, 0);
00034 
00035   mat3 = mat3.contract(mat2, dims).eval();
00036 
00037   VERIFY\_IS\_APPROX(mat3(0, 0), (m1*m2).eval()(0,0));
00038   VERIFY\_IS\_APPROX(mat3(0, 1), (m1*m2).eval()(0,1));
00039   VERIFY\_IS\_APPROX(mat3(0, 2), (m1*m2).eval()(0,2));
00040   VERIFY\_IS\_APPROX(mat3(1, 0), (m1*m2).eval()(1,0));
00041   VERIFY\_IS\_APPROX(mat3(1, 1), (m1*m2).eval()(1,1));
00042   VERIFY\_IS\_APPROX(mat3(1, 2), (m1*m2).eval()(1,2));
00043   VERIFY\_IS\_APPROX(mat3(2, 0), (m1*m2).eval()(2,0));
00044   VERIFY\_IS\_APPROX(mat3(2, 1), (m1*m2).eval()(2,1));
00045   VERIFY\_IS\_APPROX(mat3(2, 2), (m1*m2).eval()(2,2));
00046 \}
00047 
00048 
00049 \textcolor{keyword}{static} \textcolor{keywordtype}{void} test\_const()
00050 \{
00051   MatrixXf input(3,3);
00052   input.setRandom();
00053   MatrixXf output = input;
00054   output.rowwise() -= input.colwise().maxCoeff();
00055 
00056   \hyperlink{class_eigen_1_1array}{Eigen::array<int, 1>} depth\_dim;
00057   depth\_dim[0] = 0;
00058   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 2>::Dimensions} dims2d;
00059   dims2d[0] = 1;
00060   dims2d[1] = 3;
00061   \hyperlink{class_eigen_1_1array}{Eigen::array<int, 2>} bcast;
00062   bcast[0] = 3;
00063   bcast[1] = 1;
00064   \textcolor{keyword}{const} TensorMap<Tensor<const float, 2> > input\_tensor(input.data(), 3, 3);
00065   \hyperlink{class_eigen_1_1_tensor}{Tensor<float, 2>} output\_tensor= (input\_tensor - input\_tensor.maximum(depth\_dim).eval().
      reshape(dims2d).broadcast(bcast));
00066 
00067   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; ++i) \{
00068     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 3; ++j) \{
00069       VERIFY\_IS\_APPROX(output(i, j), output\_tensor(i, j));
00070     \}
00071   \}
00072 \}
00073 
00074 
00075 \textcolor{keywordtype}{void} test\_cxx11\_tensor\_forced\_eval()
00076 \{
00077   CALL\_SUBTEST(test\_simple());
00078   CALL\_SUBTEST(test\_const());
00079 \}
\end{DoxyCode}
