\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_d_g_m_r_e_s_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+Iterative\+Solvers/\+D\+G\+M\+R\+ES.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_d_g_m_r_e_s_8h_source}\index{D\+G\+M\+R\+E\+S.\+h@{D\+G\+M\+R\+E\+S.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_DGMRES\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_DGMRES\_H}
00012 
00013 \textcolor{preprocessor}{#include <Eigen/Eigenvalues>}
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00016   
00017 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \_MatrixType,
00018           \textcolor{keyword}{typename} \_Preconditioner = DiagonalPreconditioner<typename \_MatrixType::Scalar> >
00019 \textcolor{keyword}{class }DGMRES;
00020 
00021 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00022 
00023 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_Preconditioner>
00024 \textcolor{keyword}{struct }traits<DGMRES<\_MatrixType,\_Preconditioner> >
00025 \{
00026   \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00027   \textcolor{keyword}{typedef} \_Preconditioner Preconditioner;
00028 \};
00029 
00038 \textcolor{keyword}{template} <\textcolor{keyword}{typename} VectorType, \textcolor{keyword}{typename} IndexType>
00039 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_afe2a11c61eff70f7f68681a557fa21e7}{sortWithPermutation} (\hyperlink{struct_vector_type}{VectorType}& vec, IndexType& perm, \textcolor{keyword}{typename} 
      IndexType::Scalar& ncut)
00040 \{
00041   eigen\_assert(vec.size() == perm.size());
00042   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} IndexType::Scalar \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}; 
00043   \textcolor{keywordtype}{bool} flag; 
00044   \textcolor{keywordflow}{for} (Index k  = 0; k < ncut; k++)
00045   \{
00046     flag = \textcolor{keyword}{false};
00047     \textcolor{keywordflow}{for} (Index j = 0; j < vec.size()-1; j++)
00048     \{
00049       \textcolor{keywordflow}{if} ( vec(perm(j)) < vec(perm(j+1)) )
00050       \{
00051         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(perm(j),perm(j+1)); 
00052         flag = \textcolor{keyword}{true};
00053       \}
00054       \textcolor{keywordflow}{if} (!flag) \textcolor{keywordflow}{break}; \textcolor{comment}{// The vector is in sorted order}
00055     \}
00056   \}
00057 \}
00058 
00059 \}
00101 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_Preconditioner>
00102 \textcolor{keyword}{class }DGMRES : \textcolor{keyword}{public} IterativeSolverBase<DGMRES<\_MatrixType,\_Preconditioner> >
00103 \{
00104     \textcolor{keyword}{typedef} IterativeSolverBase<DGMRES> Base;
00105     \textcolor{keyword}{using} Base::matrix;
00106     \textcolor{keyword}{using} Base::m\_error;
00107     \textcolor{keyword}{using} Base::m\_iterations;
00108     \textcolor{keyword}{using} Base::m\_info;
00109     \textcolor{keyword}{using} Base::m\_isInitialized;
00110     \textcolor{keyword}{using} Base::m\_tolerance; 
00111   \textcolor{keyword}{public}:
00112     \textcolor{keyword}{using} Base::\_solve\_impl;
00113     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00114     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00115     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00116     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00117     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00118     \textcolor{keyword}{typedef} \_Preconditioner Preconditioner;
00119     \textcolor{keyword}{typedef} Matrix<Scalar,Dynamic,Dynamic> \hyperlink{group___core___module}{DenseMatrix}; 
00120     \textcolor{keyword}{typedef} Matrix<RealScalar,Dynamic,Dynamic> DenseRealMatrix; 
00121     \textcolor{keyword}{typedef} Matrix<Scalar,Dynamic,1> \hyperlink{group___core___module}{DenseVector};
00122     \textcolor{keyword}{typedef} Matrix<RealScalar,Dynamic,1> DenseRealVector; 
00123     \textcolor{keyword}{typedef} Matrix<std::complex<RealScalar>, \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, 1> ComplexVector;
00124  
00125     
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_d_g_m_r_e_s_8h_source_l00127}\hyperlink{class_eigen_1_1_d_g_m_r_e_s_a17bd25826b56c39bc7cc4ce8fbf8a848}{00127}   \hyperlink{class_eigen_1_1_d_g_m_r_e_s_a17bd25826b56c39bc7cc4ce8fbf8a848}{DGMRES}() : Base(),m\_restart(30),m\_neig(0),m\_r(0),m\_maxNeig(5),m\_isDeflAllocated(false),
      m\_isDeflInitialized(false) \{\}
00128 
00139   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixDerived>
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_d_g_m_r_e_s_8h_source_l00140}\hyperlink{class_eigen_1_1_d_g_m_r_e_s_a800fcf37c0ac66f76d5c070e4aeae2a7}{00140}   \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1_d_g_m_r_e_s_a800fcf37c0ac66f76d5c070e4aeae2a7}{DGMRES}(\textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<MatrixDerived>}& 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}) : Base(A.derived()), m\_restart(30),m\_neig(0),m\_r(0),m\_maxNeig(5),m\_isDeflAllocated(false),
      m\_isDeflInitialized(false) \{\}
00141 
00142   ~\hyperlink{class_eigen_1_1_d_g_m_r_e_s}{DGMRES}() \{\}
00143   
00145   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs,\textcolor{keyword}{typename} Dest>
00146   \textcolor{keywordtype}{void} \_solve\_with\_guess\_impl(\textcolor{keyword}{const} Rhs& b, Dest& x)\textcolor{keyword}{ const}
00147 \textcolor{keyword}{  }\{    
00148     \textcolor{keywordtype}{bool} failed = \textcolor{keyword}{false};
00149     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<b.cols(); ++j)
00150     \{
00151       m\_iterations = Base::maxIterations();
00152       m\_error = Base::m\_tolerance;
00153       
00154       \textcolor{keyword}{typename} Dest::ColXpr xj(x,j);
00155       dgmres(matrix(), b.col(j), xj, Base::m\_preconditioner);
00156     \}
00157     m\_info = failed ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue}
00158            : m\_error <= Base::m\_tolerance ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success}
00159            : \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence};
00160     m\_isInitialized = \textcolor{keyword}{true};
00161   \}
00162 
00164   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs,\textcolor{keyword}{typename} Dest>
00165   \textcolor{keywordtype}{void} \_solve\_impl(\textcolor{keyword}{const} Rhs& b, \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>}& x)\textcolor{keyword}{ const}
00166 \textcolor{keyword}{  }\{
00167     x = b;
00168     \_solve\_with\_guess\_impl(b,x.derived());
00169   \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_d_g_m_r_e_s_8h_source_l00173}\hyperlink{class_eigen_1_1_d_g_m_r_e_s_a8017848f8ea8abc26f9524a05c0d2476}{00173}   \textcolor{keywordtype}{int} \hyperlink{class_eigen_1_1_d_g_m_r_e_s_a8017848f8ea8abc26f9524a05c0d2476}{restart}() \{ \textcolor{keywordflow}{return} m\_restart; \}
00174   
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_d_g_m_r_e_s_8h_source_l00178}\hyperlink{class_eigen_1_1_d_g_m_r_e_s_a2f99e7b3b04da0ecb6607630a82b4e56}{00178}   \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_d_g_m_r_e_s_a2f99e7b3b04da0ecb6607630a82b4e56}{set\_restart}(\textcolor{keyword}{const} \textcolor{keywordtype}{int} restart) \{ m\_restart=restart; \}
00179   
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_d_g_m_r_e_s_8h_source_l00183}\hyperlink{class_eigen_1_1_d_g_m_r_e_s_a7510f3ded5959a8d98c3cd3aabebc84b}{00183}   \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_d_g_m_r_e_s_a7510f3ded5959a8d98c3cd3aabebc84b}{setEigenv}(\textcolor{keyword}{const} \textcolor{keywordtype}{int} neig) 
00184   \{
00185     m\_neig = neig;
00186     \textcolor{keywordflow}{if} (neig+1 > m\_maxNeig) m\_maxNeig = neig+1; \textcolor{comment}{// To allow for complex conjugates}
00187   \}
00188   
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_d_g_m_r_e_s_8h_source_l00192}\hyperlink{class_eigen_1_1_d_g_m_r_e_s_a724f0f2f124376c3694fd69c59a88d5a}{00192}   \textcolor{keywordtype}{int} \hyperlink{class_eigen_1_1_d_g_m_r_e_s_a724f0f2f124376c3694fd69c59a88d5a}{deflSize}() \{\textcolor{keywordflow}{return} m\_r; \}
00193   
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_iterative_solvers_2_d_g_m_r_e_s_8h_source_l00197}\hyperlink{class_eigen_1_1_d_g_m_r_e_s_ada9f5fbba382ae941f207322a8b84a01}{00197}   \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_d_g_m_r_e_s_ada9f5fbba382ae941f207322a8b84a01}{setMaxEigenv}(\textcolor{keyword}{const} \textcolor{keywordtype}{int} maxNeig) \{ m\_maxNeig = maxNeig; \}
00198   
00199   \textcolor{keyword}{protected}:
00200     \textcolor{comment}{// DGMRES algorithm }
00201     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest>
00202     \textcolor{keywordtype}{void} dgmres(\textcolor{keyword}{const} MatrixType& mat,\textcolor{keyword}{const} Rhs& rhs, Dest& x, \textcolor{keyword}{const} Preconditioner& precond) \textcolor{keyword}{const};
00203     \textcolor{comment}{// Perform one cycle of GMRES}
00204     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00205     \textcolor{keywordtype}{int} dgmresCycle(\textcolor{keyword}{const} MatrixType& mat, \textcolor{keyword}{const} Preconditioner& precond, Dest& x, DenseVector& r0, 
      RealScalar& beta, \textcolor{keyword}{const} RealScalar& normRhs, \textcolor{keywordtype}{int}& nbIts) \textcolor{keyword}{const}; 
00206     \textcolor{comment}{// Compute data to use for deflation }
00207     \textcolor{keywordtype}{int} dgmresComputeDeflationData(\textcolor{keyword}{const} MatrixType& mat, \textcolor{keyword}{const} Preconditioner& precond, \textcolor{keyword}{const} Index& it, 
      StorageIndex& neig) \textcolor{keyword}{const};
00208     \textcolor{comment}{// Apply deflation to a vector}
00209     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsType, \textcolor{keyword}{typename} DestType>
00210     \textcolor{keywordtype}{int} dgmresApplyDeflation(\textcolor{keyword}{const} RhsType& In, DestType& Out) \textcolor{keyword}{const}; 
00211     ComplexVector schurValues(\textcolor{keyword}{const} \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_schur}{ComplexSchur<DenseMatrix>}& schurofH) \textcolor{keyword}{const};
00212     ComplexVector schurValues(\textcolor{keyword}{const} \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur<DenseMatrix>}& schurofH) \textcolor{keyword}{const};
00213     \textcolor{comment}{// Init data for deflation}
00214     \textcolor{keywordtype}{void} dgmresInitDeflation(Index& rows) \textcolor{keyword}{const}; 
00215     \textcolor{keyword}{mutable} DenseMatrix m\_V; \textcolor{comment}{// Krylov basis vectors}
00216     \textcolor{keyword}{mutable} DenseMatrix m\_H; \textcolor{comment}{// Hessenberg matrix }
00217     \textcolor{keyword}{mutable} DenseMatrix m\_Hes; \textcolor{comment}{// Initial hessenberg matrix wihout Givens rotations applied}
00218     \textcolor{keyword}{mutable} Index m\_restart; \textcolor{comment}{// Maximum size of the Krylov subspace}
00219     \textcolor{keyword}{mutable} DenseMatrix m\_U; \textcolor{comment}{// Vectors that form the basis of the invariant subspace }
00220     \textcolor{keyword}{mutable} DenseMatrix m\_MU; \textcolor{comment}{// matrix operator applied to m\_U (for next cycles)}
00221     \textcolor{keyword}{mutable} DenseMatrix m\_T; \textcolor{comment}{/* T=U^T*M^\{-1\}*A*U */}
00222     \textcolor{keyword}{mutable} \hyperlink{group___l_u___module_class_eigen_1_1_partial_piv_l_u}{PartialPivLU<DenseMatrix>} m\_luT; \textcolor{comment}{// LU factorization of m\_T}
00223     \textcolor{keyword}{mutable} StorageIndex m\_neig; \textcolor{comment}{//Number of eigenvalues to extract at each restart}
00224     \textcolor{keyword}{mutable} \textcolor{keywordtype}{int} m\_r; \textcolor{comment}{// Current number of deflated eigenvalues, size of m\_U}
00225     \textcolor{keyword}{mutable} \textcolor{keywordtype}{int} m\_maxNeig; \textcolor{comment}{// Maximum number of eigenvalues to deflate}
00226     \textcolor{keyword}{mutable} RealScalar m\_lambdaN; \textcolor{comment}{//Modulus of the largest eigenvalue of A}
00227     \textcolor{keyword}{mutable} \textcolor{keywordtype}{bool} m\_isDeflAllocated;
00228     \textcolor{keyword}{mutable} \textcolor{keywordtype}{bool} m\_isDeflInitialized;
00229     
00230     \textcolor{comment}{//Adaptive strategy }
00231     \textcolor{keyword}{mutable} RealScalar m\_smv; \textcolor{comment}{// Smaller multiple of the remaining number of steps allowed}
00232     \textcolor{keyword}{mutable} \textcolor{keywordtype}{bool} m\_force; \textcolor{comment}{// Force the use of deflation at each restart}
00233     
00234 \}; 
00241 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_Preconditioner>
00242 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest>
00243 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_d_g_m_r_e_s_a1b06062ec16932d3a20ea4767d9de51d}{DGMRES<\_MatrixType, \_Preconditioner>::dgmres}(\textcolor{keyword}{const} 
      MatrixType& mat,\textcolor{keyword}{const} Rhs& rhs, Dest& x,
00244               \textcolor{keyword}{const} Preconditioner& precond)\textcolor{keyword}{ const}
00245 \textcolor{keyword}{}\{
00246   \textcolor{comment}{//Initialization}
00247   \textcolor{keywordtype}{int} n = mat.rows(); 
00248   \hyperlink{group___core___module}{DenseVector} r0(n); 
00249   \textcolor{keywordtype}{int} nbIts = 0; 
00250   m\_H.resize(m\_restart+1, m\_restart);
00251   m\_Hes.resize(m\_restart, m\_restart);
00252   m\_V.resize(n,m\_restart+1);
00253   \textcolor{comment}{//Initial residual vector and intial norm}
00254   x = precond.solve(x);
00255   r0 = rhs - mat * x; 
00256   RealScalar beta = r0.norm(); 
00257   RealScalar normRhs = rhs.norm();
00258   m\_error = beta/normRhs; 
00259   \textcolor{keywordflow}{if}(m\_error < m\_tolerance)
00260     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success}; 
00261   \textcolor{keywordflow}{else}
00262     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence};
00263   
00264   \textcolor{comment}{// Iterative process}
00265   \textcolor{keywordflow}{while} (nbIts < m\_iterations && m\_info == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence})
00266   \{
00267     dgmresCycle(mat, precond, x, r0, beta, normRhs, nbIts); 
00268     
00269     \textcolor{comment}{// Compute the new residual vector for the restart }
00270     \textcolor{keywordflow}{if} (nbIts < m\_iterations && m\_info == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence})
00271       r0 = rhs - mat * x; 
00272   \}
00273 \} 
00274 
00285 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_Preconditioner>
00286 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00287 \textcolor{keywordtype}{int} \hyperlink{class_eigen_1_1_d_g_m_r_e_s_a151b188720b20e13e8e6b112a8bcc167}{DGMRES<\_MatrixType, \_Preconditioner>::dgmresCycle}(\textcolor{keyword}{
      const} MatrixType& mat, \textcolor{keyword}{const} Preconditioner& precond, Dest& x, \hyperlink{group___core___module}{DenseVector}& r0, RealScalar& beta, \textcolor{keyword}{
      const} RealScalar& normRhs, \textcolor{keywordtype}{int}& nbIts)\textcolor{keyword}{ const}
00288 \textcolor{keyword}{}\{
00289   \textcolor{comment}{//Initialization }
00290   \hyperlink{group___core___module}{DenseVector} g(m\_restart+1); \textcolor{comment}{// Right hand side of the least square problem}
00291   g.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();  
00292   g(0) = Scalar(beta); 
00293   m\_V.col(0) = r0/beta; 
00294   m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence}; 
00295   std::vector<JacobiRotation<Scalar> >gr(m\_restart); \textcolor{comment}{// Givens rotations}
00296   \textcolor{keywordtype}{int} it = 0; \textcolor{comment}{// Number of inner iterations }
00297   \textcolor{keywordtype}{int} n = mat.rows();
00298   \hyperlink{group___core___module}{DenseVector} tv1(n), tv2(n);  \textcolor{comment}{//Temporary vectors}
00299   \textcolor{keywordflow}{while} (m\_info == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence} && it < m\_restart && nbIts < m\_iterations)
00300   \{    
00301     \textcolor{comment}{// Apply preconditioner(s) at right}
00302     \textcolor{keywordflow}{if} (m\_isDeflInitialized )
00303     \{
00304       dgmresApplyDeflation(m\_V.col(it), tv1); \textcolor{comment}{// Deflation}
00305       tv2 = precond.solve(tv1); 
00306     \}
00307     \textcolor{keywordflow}{else}
00308     \{
00309       tv2 = precond.solve(m\_V.col(it)); \textcolor{comment}{// User's selected preconditioner}
00310     \}
00311     tv1 = mat * tv2; 
00312    
00313     \textcolor{comment}{// Orthogonalize it with the previous basis in the basis using modified Gram-Schmidt}
00314     Scalar coef; 
00315     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i <= it; ++i)
00316     \{ 
00317       coef = tv1.dot(m\_V.col(i));
00318       tv1 = tv1 - coef * m\_V.col(i); 
00319       m\_H(i,it) = coef; 
00320       m\_Hes(i,it) = coef; 
00321     \}
00322     \textcolor{comment}{// Normalize the vector }
00323     coef = tv1.norm(); 
00324     m\_V.col(it+1) = tv1/coef;
00325     m\_H(it+1, it) = coef;
00326 \textcolor{comment}{//     m\_Hes(it+1,it) = coef; }
00327     
00328     \textcolor{comment}{// FIXME Check for happy breakdown }
00329     
00330     \textcolor{comment}{// Update Hessenberg matrix with Givens rotations}
00331     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i <= it; ++i) 
00332     \{
00333       m\_H.col(it).applyOnTheLeft(i-1,i,gr[i-1].adjoint());
00334     \}
00335     \textcolor{comment}{// Compute the new plane rotation }
00336     gr[it].makeGivens(m\_H(it, it), m\_H(it+1,it)); 
00337     \textcolor{comment}{// Apply the new rotation}
00338     m\_H.col(it).applyOnTheLeft(it,it+1,gr[it].adjoint());
00339     g.applyOnTheLeft(it,it+1, gr[it].adjoint()); 
00340     
00341     beta = std::abs(g(it+1));
00342     m\_error = beta/normRhs; 
00343     \textcolor{comment}{// std::cerr << nbIts << " Relative Residual Norm " << m\_error << std::endl;}
00344     it++; nbIts++; 
00345     
00346     \textcolor{keywordflow}{if} (m\_error < m\_tolerance)
00347     \{
00348       \textcolor{comment}{// The method has converged}
00349       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00350       \textcolor{keywordflow}{break};
00351     \}
00352   \}
00353   
00354   \textcolor{comment}{// Compute the new coefficients by solving the least square problem}
00355 \textcolor{comment}{//   it++;}
00356   \textcolor{comment}{//FIXME  Check first if the matrix is singular ... zero diagonal}
00357   \hyperlink{group___core___module}{DenseVector} nrs(m\_restart); 
00358   nrs = m\_H.topLeftCorner(it,it).template triangularView<Upper>().solve(g.head(it)); 
00359   
00360   \textcolor{comment}{// Form the new solution}
00361   \textcolor{keywordflow}{if} (m\_isDeflInitialized)
00362   \{
00363     tv1 = m\_V.leftCols(it) * nrs; 
00364     dgmresApplyDeflation(tv1, tv2); 
00365     x = x + precond.solve(tv2);
00366   \}
00367   \textcolor{keywordflow}{else}
00368     x = x + precond.solve(m\_V.leftCols(it) * nrs); 
00369   
00370   \textcolor{comment}{// Go for a new cycle and compute data for deflation}
00371   \textcolor{keywordflow}{if}(nbIts < m\_iterations && m\_info == NoConvergence && m\_neig > 0 && (m\_r+m\_neig) < m\_maxNeig)
00372     dgmresComputeDeflationData(mat, precond, it, m\_neig); 
00373   \textcolor{keywordflow}{return} 0; 
00374   
00375 \}
00376 
00377 
00378 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_Preconditioner>
00379 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_d_g_m_r_e_s}{DGMRES<\_MatrixType, \_Preconditioner>::dgmresInitDeflation}
      (Index& rows)\textcolor{keyword}{ const}
00380 \textcolor{keyword}{}\{
00381   m\_U.resize(rows, m\_maxNeig);
00382   m\_MU.resize(rows, m\_maxNeig); 
00383   m\_T.resize(m\_maxNeig, m\_maxNeig);
00384   m\_lambdaN = 0.0; 
00385   m\_isDeflAllocated = \textcolor{keyword}{true}; 
00386 \}
00387 
00388 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_Preconditioner>
00389 \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___core___module_class_eigen_1_1_matrix}{DGMRES<\_MatrixType, \_Preconditioner>::ComplexVector}
       \hyperlink{class_eigen_1_1_d_g_m_r_e_s}{DGMRES<\_MatrixType, \_Preconditioner>::schurValues}(\textcolor{keyword}{const} 
      \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_schur}{ComplexSchur<DenseMatrix>}& schurofH)\textcolor{keyword}{ const}
00390 \textcolor{keyword}{}\{
00391   \textcolor{keywordflow}{return} schurofH.\hyperlink{group___eigenvalues___module_add3ab5ed83f7f2f06b79fa910a2d5684}{matrixT}().diagonal();
00392 \}
00393 
00394 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_Preconditioner>
00395 \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___core___module_class_eigen_1_1_matrix}{DGMRES<\_MatrixType, \_Preconditioner>::ComplexVector}
       \hyperlink{class_eigen_1_1_d_g_m_r_e_s}{DGMRES<\_MatrixType, \_Preconditioner>::schurValues}(\textcolor{keyword}{const} 
      \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur<DenseMatrix>}& schurofH)\textcolor{keyword}{ const}
00396 \textcolor{keyword}{}\{
00397   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00398   \textcolor{keyword}{const} \hyperlink{group___core___module}{DenseMatrix}& \hyperlink{group___sparse_core___module}{T} = schurofH.\hyperlink{group___eigenvalues___module_abb78996b43b8642a5f507415730445cb}{matrixT}();
00399   Index it = T.rows();
00400   \hyperlink{group___core___module_class_eigen_1_1_matrix}{ComplexVector} eig(it);
00401   Index j = 0;
00402   \textcolor{keywordflow}{while} (j < it-1)
00403   \{
00404     \textcolor{keywordflow}{if} (T(j+1,j) ==Scalar(0))
00405     \{
00406       eig(j) = std::complex<RealScalar>(T(j,j),RealScalar(0)); 
00407       j++; 
00408     \}
00409     \textcolor{keywordflow}{else}
00410     \{
00411       eig(j) = std::complex<RealScalar>(T(j,j),T(j+1,j)); 
00412       eig(j+1) = std::complex<RealScalar>(T(j,j+1),T(j+1,j+1));
00413       j++;
00414     \}
00415   \}
00416   \textcolor{keywordflow}{if} (j < it-1) eig(j) = std::complex<RealScalar>(T(j,j),RealScalar(0));
00417   \textcolor{keywordflow}{return} eig;
00418 \}
00419 
00420 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_Preconditioner>
00421 \textcolor{keywordtype}{int} \hyperlink{class_eigen_1_1_d_g_m_r_e_s}{DGMRES<\_MatrixType, \_Preconditioner>::dgmresComputeDeflationData}
      (\textcolor{keyword}{const} MatrixType& mat, \textcolor{keyword}{const} Preconditioner& precond, \textcolor{keyword}{const} Index& it, StorageIndex& neig)\textcolor{keyword}{ const}
00422 \textcolor{keyword}{}\{
00423   \textcolor{comment}{// First, find the Schur form of the Hessenberg matrix H}
00424   \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{internal::conditional<NumTraits<Scalar>::IsComplex}
      , \hyperlink{group___eigenvalues___module_class_eigen_1_1_complex_schur}{ComplexSchur<DenseMatrix>}, \hyperlink{group___eigenvalues___module_class_eigen_1_1_real_schur}{RealSchur<DenseMatrix>} >::type 
      schurofH; 
00425   \textcolor{keywordtype}{bool} computeU = \textcolor{keyword}{true};
00426   \hyperlink{group___core___module}{DenseMatrix} matrixQ(it,it); 
00427   matrixQ.setIdentity();
00428   schurofH.computeFromHessenberg(m\_Hes.topLeftCorner(it,it), matrixQ, computeU); 
00429   
00430   \hyperlink{group___core___module_class_eigen_1_1_matrix}{ComplexVector} eig(it);
00431   \hyperlink{group___core___module}{Matrix<StorageIndex,Dynamic,1>}perm(it);
00432   eig = this->schurValues(schurofH);
00433   
00434   \textcolor{comment}{// Reorder the absolute values of Schur values}
00435   \hyperlink{group___core___module}{DenseRealVector} modulEig(it); 
00436   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<it; ++j) modulEig(j) = std::abs(eig(j)); 
00437   perm.setLinSpaced(it,0,it-1);
00438   \hyperlink{namespace_eigen_1_1internal_afe2a11c61eff70f7f68681a557fa21e7}{internal::sortWithPermutation}(modulEig, perm, neig);
00439   
00440   \textcolor{keywordflow}{if} (!m\_lambdaN)
00441   \{
00442     m\_lambdaN = (std::max)(modulEig.maxCoeff(), m\_lambdaN);
00443   \}
00444   \textcolor{comment}{//Count the real number of extracted eigenvalues (with complex conjugates)}
00445   \textcolor{keywordtype}{int} nbrEig = 0; 
00446   \textcolor{keywordflow}{while} (nbrEig < neig)
00447   \{
00448     \textcolor{keywordflow}{if}(eig(perm(it-nbrEig-1)).imag() == RealScalar(0)) nbrEig++; 
00449     \textcolor{keywordflow}{else} nbrEig += 2; 
00450   \}
00451   \textcolor{comment}{// Extract the  Schur vectors corresponding to the smallest Ritz values}
00452   \hyperlink{group___core___module}{DenseMatrix} Sr(it, nbrEig); 
00453   Sr.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00454   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < nbrEig; j++)
00455   \{
00456     Sr.col(j) = schurofH.matrixU().col(perm(it-j-1));
00457   \}
00458   
00459   \textcolor{comment}{// Form the Schur vectors of the initial matrix using the Krylov basis}
00460   \hyperlink{group___core___module}{DenseMatrix} X; 
00461   X = m\_V.leftCols(it) * Sr;
00462   \textcolor{keywordflow}{if} (m\_r)
00463   \{
00464    \textcolor{comment}{// Orthogonalize X against m\_U using modified Gram-Schmidt}
00465    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < nbrEig; j++)
00466      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k =0; k < m\_r; k++)
00467       X.col(j) = X.col(j) - (m\_U.col(k).dot(X.col(j)))*m\_U.col(k); 
00468   \}
00469   
00470   \textcolor{comment}{// Compute m\_MX = A * M^-1 * X}
00471   Index m = m\_V.rows();
00472   \textcolor{keywordflow}{if} (!m\_isDeflAllocated) 
00473     dgmresInitDeflation(m); 
00474   \hyperlink{group___core___module}{DenseMatrix} MX(m, nbrEig);
00475   \hyperlink{group___core___module}{DenseVector} tv1(m);
00476   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < nbrEig; j++)
00477   \{
00478     tv1 = mat * X.col(j);
00479     MX.col(j) = precond.solve(tv1);
00480   \}
00481   
00482   \textcolor{comment}{//Update m\_T = [U'MU U'MX; X'MU X'MX]}
00483   m\_T.block(m\_r, m\_r, nbrEig, nbrEig) = X.transpose() * MX; 
00484   \textcolor{keywordflow}{if}(m\_r)
00485   \{
00486     m\_T.block(0, m\_r, m\_r, nbrEig) = m\_U.leftCols(m\_r).transpose() * MX; 
00487     m\_T.block(m\_r, 0, nbrEig, m\_r) = X.transpose() * m\_MU.leftCols(m\_r);
00488   \}
00489   
00490   \textcolor{comment}{// Save X into m\_U and m\_MX in m\_MU}
00491   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < nbrEig; j++) m\_U.col(m\_r+j) = X.col(j);
00492   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < nbrEig; j++) m\_MU.col(m\_r+j) = MX.col(j);
00493   \textcolor{comment}{// Increase the size of the invariant subspace}
00494   m\_r += nbrEig; 
00495   
00496   \textcolor{comment}{// Factorize m\_T into m\_luT}
00497   m\_luT.compute(m\_T.topLeftCorner(m\_r, m\_r));
00498   
00499   \textcolor{comment}{//FIXME CHeck if the factorization was correctly done (nonsingular matrix)}
00500   m\_isDeflInitialized = \textcolor{keyword}{true};
00501   \textcolor{keywordflow}{return} 0; 
00502 \}
00503 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_Preconditioner>
00504 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsType, \textcolor{keyword}{typename} DestType>
00505 \textcolor{keywordtype}{int} \hyperlink{class_eigen_1_1_d_g_m_r_e_s}{DGMRES<\_MatrixType, \_Preconditioner>::dgmresApplyDeflation}
      (\textcolor{keyword}{const} RhsType &x, DestType &y)\textcolor{keyword}{ const}
00506 \textcolor{keyword}{}\{
00507   \hyperlink{group___core___module}{DenseVector} x1 = m\_U.leftCols(m\_r).transpose() * x; 
00508   y = x + m\_U.leftCols(m\_r) * ( m\_lambdaN * m\_luT.solve(x1) - x1);
00509   \textcolor{keywordflow}{return} 0; 
00510 \}
00511 
00512 \} \textcolor{comment}{// end namespace Eigen}
00513 \textcolor{preprocessor}{#endif }
\end{DoxyCode}
