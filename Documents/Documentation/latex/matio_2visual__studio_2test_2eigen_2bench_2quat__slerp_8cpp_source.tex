\hypertarget{matio_2visual__studio_2test_2eigen_2bench_2quat__slerp_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/bench/quat\+\_\+slerp.cpp}
\label{matio_2visual__studio_2test_2eigen_2bench_2quat__slerp_8cpp_source}\index{quat\+\_\+slerp.\+cpp@{quat\+\_\+slerp.\+cpp}}

\begin{DoxyCode}
00001 
00002 \textcolor{preprocessor}{#include <iostream>}
00003 \textcolor{preprocessor}{#include <Eigen/Geometry>}
00004 \textcolor{preprocessor}{#include <bench/BenchTimer.h>}
00005 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00006 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00007 
00008 
00009 
00010 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Q>
00011 EIGEN\_DONT\_INLINE Q nlerp(\textcolor{keyword}{const} Q& a, \textcolor{keyword}{const} Q& b, \textcolor{keyword}{typename} Q::Scalar t)
00012 \{
00013   \textcolor{keywordflow}{return} Q((a.coeffs() * (1.0-t) + b.coeffs() * t).normalized());
00014 \}
00015 
00016 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Q>
00017 EIGEN\_DONT\_INLINE Q slerp\_eigen(\textcolor{keyword}{const} Q& a, \textcolor{keyword}{const} Q& b, \textcolor{keyword}{typename} Q::Scalar t)
00018 \{
00019   \textcolor{keywordflow}{return} a.slerp(t,b);
00020 \}
00021 
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Q>
00023 EIGEN\_DONT\_INLINE Q slerp\_legacy(\textcolor{keyword}{const} Q& a, \textcolor{keyword}{const} Q& b, \textcolor{keyword}{typename} Q::Scalar t)
00024 \{
00025   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Q::Scalar Scalar;
00026   \textcolor{keyword}{static} \textcolor{keyword}{const} Scalar one = Scalar(1) - dummy\_precision<Scalar>();
00027   Scalar d = a.dot(b);
00028   Scalar absD = internal::abs(d);
00029   \textcolor{keywordflow}{if} (absD>=one)
00030     \textcolor{keywordflow}{return} a;
00031 
00032   \textcolor{comment}{// theta is the angle between the 2 quaternions}
00033   Scalar theta = std::acos(absD);
00034   Scalar sinTheta = internal::sin(theta);
00035 
00036   Scalar scale0 = internal::sin( ( Scalar(1) - t ) * theta) / sinTheta;
00037   Scalar scale1 = internal::sin( ( t * theta) ) / sinTheta;
00038   \textcolor{keywordflow}{if} (d<0)
00039     scale1 = -scale1;
00040 
00041   \textcolor{keywordflow}{return} Q(scale0 * a.coeffs() + scale1 * b.coeffs());
00042 \}
00043 
00044 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Q>
00045 EIGEN\_DONT\_INLINE Q slerp\_legacy\_nlerp(\textcolor{keyword}{const} Q& a, \textcolor{keyword}{const} Q& b, \textcolor{keyword}{typename} Q::Scalar t)
00046 \{
00047   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Q::Scalar Scalar;
00048   \textcolor{keyword}{static} \textcolor{keyword}{const} Scalar one = Scalar(1) - epsilon<Scalar>();
00049   Scalar d = a.dot(b);
00050   Scalar absD = internal::abs(d);
00051   
00052   Scalar scale0;
00053   Scalar scale1;
00054   
00055   \textcolor{keywordflow}{if} (absD>=one)
00056   \{
00057     scale0 = Scalar(1) - t;
00058     scale1 = t;
00059   \}
00060   \textcolor{keywordflow}{else}
00061   \{
00062     \textcolor{comment}{// theta is the angle between the 2 quaternions}
00063     Scalar theta = std::acos(absD);
00064     Scalar sinTheta = internal::sin(theta);
00065 
00066     scale0 = internal::sin( ( Scalar(1) - t ) * theta) / sinTheta;
00067     scale1 = internal::sin( ( t * theta) ) / sinTheta;
00068     \textcolor{keywordflow}{if} (d<0)
00069       scale1 = -scale1;
00070   \}
00071 
00072   \textcolor{keywordflow}{return} Q(scale0 * a.coeffs() + scale1 * b.coeffs());
00073 \}
00074 
00075 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00076 \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module}{T} sin\_over\_x(\hyperlink{group___sparse_core___module}{T} x)
00077 \{
00078   \textcolor{keywordflow}{if} (\hyperlink{group___sparse_core___module}{T}(1) + x*x == \hyperlink{group___sparse_core___module}{T}(1))
00079     \textcolor{keywordflow}{return} \hyperlink{group___sparse_core___module}{T}(1);
00080   \textcolor{keywordflow}{else}
00081     \textcolor{keywordflow}{return} std::sin(x)/x;
00082 \}
00083 
00084 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Q>
00085 EIGEN\_DONT\_INLINE Q slerp\_rw(\textcolor{keyword}{const} Q& a, \textcolor{keyword}{const} Q& b, \textcolor{keyword}{typename} Q::Scalar t)
00086 \{
00087   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Q::Scalar Scalar;
00088   
00089   Scalar d = a.dot(b);
00090   Scalar theta;
00091   \textcolor{keywordflow}{if} (d<0.0)
00092     theta = \textcolor{comment}{/*M\_PI -*/} Scalar(2)*std::asin( (a.coeffs()+b.coeffs()).norm()/2 );
00093   \textcolor{keywordflow}{else}
00094     theta = Scalar(2)*std::asin( (a.coeffs()-b.coeffs()).norm()/2 );
00095   
00096   \textcolor{comment}{// theta is the angle between the 2 quaternions}
00097 \textcolor{comment}{//   Scalar theta = std::acos(absD);}
00098   Scalar sinOverTheta = sin\_over\_x(theta);
00099 
00100   Scalar scale0 = (Scalar(1)-t)*sin\_over\_x( ( Scalar(1) - t ) * theta) / sinOverTheta;
00101   Scalar scale1 = t * sin\_over\_x( ( t * theta) ) / sinOverTheta;
00102   \textcolor{keywordflow}{if} (d<0)
00103     scale1 = -scale1;
00104 
00105   \textcolor{keywordflow}{return} \hyperlink{group___geometry___module_class_eigen_1_1_quaternion}{Quaternion<Scalar>}(scale0 * a.coeffs() + scale1 * b.coeffs());
00106 \}
00107 
00108 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Q>
00109 EIGEN\_DONT\_INLINE Q slerp\_gael(\textcolor{keyword}{const} Q& a, \textcolor{keyword}{const} Q& b, \textcolor{keyword}{typename} Q::Scalar t)
00110 \{
00111   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Q::Scalar Scalar;
00112   
00113   Scalar d = a.dot(b);
00114   Scalar theta;
00115 \textcolor{comment}{//   theta = Scalar(2) * atan2((a.coeffs()-b.coeffs()).norm(),(a.coeffs()+b.coeffs()).norm());}
00116 \textcolor{comment}{//   if (d<0.0)}
00117 \textcolor{comment}{//     theta = M\_PI-theta;}
00118   
00119   \textcolor{keywordflow}{if} (d<0.0)
00120     theta = \textcolor{comment}{/*M\_PI -*/} Scalar(2)*std::asin( (-a.coeffs()-b.coeffs()).norm()/2 );
00121   \textcolor{keywordflow}{else}
00122     theta = Scalar(2)*std::asin( (a.coeffs()-b.coeffs()).norm()/2 );
00123   
00124   
00125   Scalar scale0;
00126   Scalar scale1;
00127   \textcolor{keywordflow}{if}(theta*theta-Scalar(6)==-Scalar(6))
00128   \{
00129     scale0 = Scalar(1) - t;
00130     scale1 = t;
00131   \}
00132   \textcolor{keywordflow}{else}
00133   \{
00134     Scalar sinTheta = std::sin(theta);
00135     scale0 = internal::sin( ( Scalar(1) - t ) * theta) / sinTheta;
00136     scale1 = internal::sin( ( t * theta) ) / sinTheta;
00137     \textcolor{keywordflow}{if} (d<0)
00138       scale1 = -scale1;
00139   \}
00140 
00141   \textcolor{keywordflow}{return} \hyperlink{group___geometry___module_class_eigen_1_1_quaternion}{Quaternion<Scalar>}(scale0 * a.coeffs() + scale1 * b.coeffs());
00142 \}
00143 
00144 \textcolor{keywordtype}{int} main()
00145 \{
00146   \textcolor{keyword}{typedef} \textcolor{keywordtype}{double} RefScalar;
00147   \textcolor{keyword}{typedef} \textcolor{keywordtype}{float} TestScalar;
00148   
00149   \textcolor{keyword}{typedef} \hyperlink{group___geometry___module_class_eigen_1_1_quaternion}{Quaternion<RefScalar>}  Qd;
00150   \textcolor{keyword}{typedef} \hyperlink{group___geometry___module_class_eigen_1_1_quaternion}{Quaternion<TestScalar>} Qf;
00151   
00152   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} g\_seed = (\textcolor{keywordtype}{unsigned} int) time(NULL);
00153   std::cout << g\_seed << \textcolor{stringliteral}{"\(\backslash\)n"};
00154 \textcolor{comment}{//   g\_seed = 1259932496;}
00155   srand(g\_seed);
00156   
00157   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<RefScalar,Dynamic,1>} maxerr(7);
00158   maxerr.setZero();
00159   
00160   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<RefScalar,Dynamic,1>} avgerr(7);
00161   avgerr.setZero();
00162   
00163   cout << \textcolor{stringliteral}{"double=>float=>double       nlerp        eigen        legacy(snap)         legacy(nlerp)       
       rightway         gael's criteria\(\backslash\)n"};
00164   
00165   \textcolor{keywordtype}{int} rep = 100;
00166   \textcolor{keywordtype}{int} iters = 40;
00167   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} w=0; w<rep; ++w)
00168   \{
00169     Qf a, b;
00170     a.coeffs().setRandom();
00171     a.normalize();
00172     b.coeffs().setRandom();
00173     b.normalize();
00174     
00175     Qf c[6];
00176     
00177     Qd ar(a.cast<RefScalar>());
00178     Qd br(b.cast<RefScalar>());
00179     Qd cr;
00180     
00181     
00182     
00183     cout.precision(8);
00184     cout << std::scientific;
00185     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<iters; ++i)
00186     \{
00187       RefScalar t = 0.65;
00188       cr = slerp\_rw(ar,br,t);
00189       
00190       Qf refc = cr.cast<TestScalar>();
00191       c[0] = nlerp(a,b,t);
00192       c[1] = slerp\_eigen(a,b,t);
00193       c[2] = slerp\_legacy(a,b,t);
00194       c[3] = slerp\_legacy\_nlerp(a,b,t);
00195       c[4] = slerp\_rw(a,b,t);
00196       c[5] = slerp\_gael(a,b,t);
00197       
00198       VectorXd err(7);
00199       err[0] = (cr.coeffs()-refc.cast<RefScalar>().coeffs()).norm();
00200 \textcolor{comment}{//       std::cout << err[0] << "    ";}
00201       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<6; ++k)
00202       \{
00203         err[k+1] = (c[k].coeffs()-refc.coeffs()).norm();
00204 \textcolor{comment}{//         std::cout << err[k+1] << "    ";}
00205       \}
00206       maxerr = maxerr.cwise().max(err);
00207       avgerr += err;
00208 \textcolor{comment}{//       std::cout << "\(\backslash\)n";}
00209       b = cr.cast<TestScalar>();
00210       br = cr;
00211     \}
00212 \textcolor{comment}{//     std::cout << "\(\backslash\)n";}
00213   \}
00214   avgerr /= RefScalar(rep*iters);
00215   cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)nAccuracy:\(\backslash\)n"}
00216        << \textcolor{stringliteral}{"  max: "} << maxerr.transpose() << \textcolor{stringliteral}{"\(\backslash\)n"};
00217   cout << \textcolor{stringliteral}{"  avg: "} << avgerr.transpose() << \textcolor{stringliteral}{"\(\backslash\)n"};
00218   
00219   \textcolor{comment}{// perf bench}
00220   \hyperlink{group___geometry___module_class_eigen_1_1_quaternion}{Quaternionf} a,b;
00221   a.coeffs().setRandom();
00222   a.\hyperlink{group___geometry___module_aa8d67d855940925f634327827aed1cad}{normalize}();
00223   b.coeffs().setRandom();
00224   b.\hyperlink{group___geometry___module_aa8d67d855940925f634327827aed1cad}{normalize}();
00225   \textcolor{comment}{//b = a;}
00226   \textcolor{keywordtype}{float} s = 0.65;
00227     
00228 \textcolor{preprocessor}{  #define BENCH(FUNC) \{\(\backslash\)}
00229 \textcolor{preprocessor}{    BenchTimer t; \(\backslash\)}
00230 \textcolor{preprocessor}{    for(int k=0; k<2; ++k) \{\(\backslash\)}
00231 \textcolor{preprocessor}{      t.start(); \(\backslash\)}
00232 \textcolor{preprocessor}{      for(int i=0; i<1000000; ++i) \(\backslash\)}
00233 \textcolor{preprocessor}{        FUNC(a,b,s); \(\backslash\)}
00234 \textcolor{preprocessor}{      t.stop(); \(\backslash\)}
00235 \textcolor{preprocessor}{    \} \(\backslash\)}
00236 \textcolor{preprocessor}{    cout << "  " << #FUNC << " => \(\backslash\)t " << t.value() << "s\(\backslash\)n"; \(\backslash\)}
00237 \textcolor{preprocessor}{  \}}
00238   
00239   cout << \textcolor{stringliteral}{"\(\backslash\)nSpeed:\(\backslash\)n"} << std::fixed;
00240   BENCH(nlerp);
00241   BENCH(slerp\_eigen);
00242   BENCH(slerp\_legacy);
00243   BENCH(slerp\_legacy\_nlerp);
00244   BENCH(slerp\_rw);
00245   BENCH(slerp\_gael);
00246 \}
00247 
\end{DoxyCode}
