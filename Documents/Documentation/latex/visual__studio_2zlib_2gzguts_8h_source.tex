\hypertarget{visual__studio_2zlib_2gzguts_8h_source}{}\section{visual\+\_\+studio/zlib/gzguts.h}
\label{visual__studio_2zlib_2gzguts_8h_source}\index{gzguts.\+h@{gzguts.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* gzguts.h -- zlib internal header definitions for gz* operations}
00002 \textcolor{comment}{ * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ */}
00005 
00006 \textcolor{preprocessor}{#ifdef \_LARGEFILE64\_SOURCE}
00007 \textcolor{preprocessor}{#  ifndef \_LARGEFILE\_SOURCE}
00008 \textcolor{preprocessor}{#    define \_LARGEFILE\_SOURCE 1}
00009 \textcolor{preprocessor}{#  endif}
00010 \textcolor{preprocessor}{#  ifdef \_FILE\_OFFSET\_BITS}
00011 \textcolor{preprocessor}{#    undef \_FILE\_OFFSET\_BITS}
00012 \textcolor{preprocessor}{#  endif}
00013 \textcolor{preprocessor}{#endif}
00014 
00015 \textcolor{preprocessor}{#ifdef HAVE\_HIDDEN}
00016 \textcolor{preprocessor}{#  define ZLIB\_INTERNAL \_\_attribute\_\_((visibility ("hidden")))}
00017 \textcolor{preprocessor}{#else}
00018 \textcolor{preprocessor}{#  define ZLIB\_INTERNAL}
00019 \textcolor{preprocessor}{#endif}
00020 
00021 \textcolor{preprocessor}{#include <stdio.h>}
00022 \textcolor{preprocessor}{#include "zlib.h"}
00023 \textcolor{preprocessor}{#ifdef STDC}
00024 \textcolor{preprocessor}{#  include <string.h>}
00025 \textcolor{preprocessor}{#  include <stdlib.h>}
00026 \textcolor{preprocessor}{#  include <limits.h>}
00027 \textcolor{preprocessor}{#endif}
00028 
00029 \textcolor{preprocessor}{#ifndef \_POSIX\_SOURCE}
00030 \textcolor{preprocessor}{#  define \_POSIX\_SOURCE}
00031 \textcolor{preprocessor}{#endif}
00032 \textcolor{preprocessor}{#include <fcntl.h>}
00033 
00034 \textcolor{preprocessor}{#ifdef \_WIN32}
00035 \textcolor{preprocessor}{#  include <stddef.h>}
00036 \textcolor{preprocessor}{#endif}
00037 
00038 \textcolor{preprocessor}{#if defined(\_\_TURBOC\_\_) || defined(\_MSC\_VER) || defined(\_WIN32)}
00039 \textcolor{preprocessor}{#  include <io.h>}
00040 \textcolor{preprocessor}{#endif}
00041 
00042 \textcolor{preprocessor}{#if defined(\_WIN32) || defined(\_\_CYGWIN\_\_)}
00043 \textcolor{preprocessor}{#  define WIDECHAR}
00044 \textcolor{preprocessor}{#endif}
00045 
00046 \textcolor{preprocessor}{#ifdef WINAPI\_FAMILY}
00047 \textcolor{preprocessor}{#  define open \_open}
00048 \textcolor{preprocessor}{#  define read \_read}
00049 \textcolor{preprocessor}{#  define write \_write}
00050 \textcolor{preprocessor}{#  define close \_close}
00051 \textcolor{preprocessor}{#endif}
00052 
00053 \textcolor{preprocessor}{#ifdef NO\_DEFLATE       }\textcolor{comment}{/* for compatibility with old definition */}\textcolor{preprocessor}{}
00054 \textcolor{preprocessor}{#  define NO\_GZCOMPRESS}
00055 \textcolor{preprocessor}{#endif}
00056 
00057 \textcolor{preprocessor}{#if defined(STDC99) || (defined(\_\_TURBOC\_\_) && \_\_TURBOC\_\_ >= 0x550)}
00058 \textcolor{preprocessor}{#  ifndef HAVE\_VSNPRINTF}
00059 \textcolor{preprocessor}{#    define HAVE\_VSNPRINTF}
00060 \textcolor{preprocessor}{#  endif}
00061 \textcolor{preprocessor}{#endif}
00062 
00063 \textcolor{preprocessor}{#if defined(\_\_CYGWIN\_\_)}
00064 \textcolor{preprocessor}{#  ifndef HAVE\_VSNPRINTF}
00065 \textcolor{preprocessor}{#    define HAVE\_VSNPRINTF}
00066 \textcolor{preprocessor}{#  endif}
00067 \textcolor{preprocessor}{#endif}
00068 
00069 \textcolor{preprocessor}{#if defined(MSDOS) && defined(\_\_BORLANDC\_\_) && (BORLANDC > 0x410)}
00070 \textcolor{preprocessor}{#  ifndef HAVE\_VSNPRINTF}
00071 \textcolor{preprocessor}{#    define HAVE\_VSNPRINTF}
00072 \textcolor{preprocessor}{#  endif}
00073 \textcolor{preprocessor}{#endif}
00074 
00075 \textcolor{preprocessor}{#ifndef HAVE\_VSNPRINTF}
00076 \textcolor{preprocessor}{#  ifdef MSDOS}
00077 \textcolor{comment}{/* vsnprintf may exist on some MS-DOS compilers (DJGPP?),}
00078 \textcolor{comment}{   but for now we just assume it doesn't. */}
00079 \textcolor{preprocessor}{#    define NO\_vsnprintf}
00080 \textcolor{preprocessor}{#  endif}
00081 \textcolor{preprocessor}{#  ifdef \_\_TURBOC\_\_}
00082 \textcolor{preprocessor}{#    define NO\_vsnprintf}
00083 \textcolor{preprocessor}{#  endif}
00084 \textcolor{preprocessor}{#  ifdef WIN32}
00085 \textcolor{comment}{/* In Win32, vsnprintf is available as the "non-ANSI" \_vsnprintf. */}
00086 \textcolor{preprocessor}{#    if !defined(vsnprintf) && !defined(NO\_vsnprintf)}
00087 \textcolor{preprocessor}{#      if !defined(\_MSC\_VER) || ( defined(\_MSC\_VER) && \_MSC\_VER < 1500 )}
00088 \textcolor{preprocessor}{#         define vsnprintf \_vsnprintf}
00089 \textcolor{preprocessor}{#      endif}
00090 \textcolor{preprocessor}{#    endif}
00091 \textcolor{preprocessor}{#  endif}
00092 \textcolor{preprocessor}{#  ifdef \_\_SASC}
00093 \textcolor{preprocessor}{#    define NO\_vsnprintf}
00094 \textcolor{preprocessor}{#  endif}
00095 \textcolor{preprocessor}{#  ifdef VMS}
00096 \textcolor{preprocessor}{#    define NO\_vsnprintf}
00097 \textcolor{preprocessor}{#  endif}
00098 \textcolor{preprocessor}{#  ifdef \_\_OS400\_\_}
00099 \textcolor{preprocessor}{#    define NO\_vsnprintf}
00100 \textcolor{preprocessor}{#  endif}
00101 \textcolor{preprocessor}{#  ifdef \_\_MVS\_\_}
00102 \textcolor{preprocessor}{#    define NO\_vsnprintf}
00103 \textcolor{preprocessor}{#  endif}
00104 \textcolor{preprocessor}{#endif}
00105 
00106 \textcolor{comment}{/* unlike snprintf (which is required in C99), \_snprintf does not guarantee}
00107 \textcolor{comment}{   null termination of the result -- however this is only used in gzlib.c where}
00108 \textcolor{comment}{   the result is assured to fit in the space provided */}
00109 \textcolor{preprocessor}{#if defined(\_MSC\_VER) && \_MSC\_VER < 1900}
00110 \textcolor{preprocessor}{#  define snprintf \_snprintf}
00111 \textcolor{preprocessor}{#endif}
00112 
00113 \textcolor{preprocessor}{#ifndef local}
00114 \textcolor{preprocessor}{#  define local static}
00115 \textcolor{preprocessor}{#endif}
00116 \textcolor{comment}{/* since "static" is used to mean two completely different things in C, we}
00117 \textcolor{comment}{   define "local" for the non-static meaning of "static", for readability}
00118 \textcolor{comment}{   (compile with -Dlocal if your debugger can't find static symbols) */}
00119 
00120 \textcolor{comment}{/* gz* functions always use library allocation functions */}
00121 \textcolor{preprocessor}{#ifndef STDC}
00122   \textcolor{keyword}{extern} voidp  malloc OF((uInt size));
00123   \textcolor{keyword}{extern} \textcolor{keywordtype}{void}   free   OF((voidpf ptr));
00124 \textcolor{preprocessor}{#endif}
00125 
00126 \textcolor{comment}{/* get errno and strerror definition */}
00127 \textcolor{preprocessor}{#if defined UNDER\_CE}
00128 \textcolor{preprocessor}{#  include <windows.h>}
00129 \textcolor{preprocessor}{#  define zstrerror() gz\_strwinerror((DWORD)GetLastError())}
00130 \textcolor{preprocessor}{#else}
00131 \textcolor{preprocessor}{#  ifndef NO\_STRERROR}
00132 \textcolor{preprocessor}{#    include <errno.h>}
00133 \textcolor{preprocessor}{#    define zstrerror() strerror(errno)}
00134 \textcolor{preprocessor}{#  else}
00135 \textcolor{preprocessor}{#    define zstrerror() "stdio error (consult errno)"}
00136 \textcolor{preprocessor}{#  endif}
00137 \textcolor{preprocessor}{#endif}
00138 
00139 \textcolor{comment}{/* provide prototypes for these when building zlib without LFS */}
00140 \textcolor{preprocessor}{#if !defined(\_LARGEFILE64\_SOURCE) || \_LFS64\_LARGEFILE-0 == 0}
00141     ZEXTERN \hyperlink{structgz_file__s}{gzFile} ZEXPORT gzopen64 OF((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *));
00142     ZEXTERN z\_off64\_t ZEXPORT gzseek64 OF((\hyperlink{structgz_file__s}{gzFile}, z\_off64\_t, \textcolor{keywordtype}{int}));
00143     ZEXTERN z\_off64\_t ZEXPORT gztell64 OF((\hyperlink{structgz_file__s}{gzFile}));
00144     ZEXTERN z\_off64\_t ZEXPORT gzoffset64 OF((\hyperlink{structgz_file__s}{gzFile}));
00145 \textcolor{preprocessor}{#endif}
00146 
00147 \textcolor{comment}{/* default memLevel */}
00148 \textcolor{preprocessor}{#if MAX\_MEM\_LEVEL >= 8}
00149 \textcolor{preprocessor}{#  define DEF\_MEM\_LEVEL 8}
00150 \textcolor{preprocessor}{#else}
00151 \textcolor{preprocessor}{#  define DEF\_MEM\_LEVEL  MAX\_MEM\_LEVEL}
00152 \textcolor{preprocessor}{#endif}
00153 
00154 \textcolor{comment}{/* default i/o buffer size -- double this for output when reading (this and}
00155 \textcolor{comment}{   twice this must be able to fit in an unsigned type) */}
00156 \textcolor{preprocessor}{#define GZBUFSIZE 8192}
00157 
00158 \textcolor{comment}{/* gzip modes, also provide a little integrity check on the passed structure */}
00159 \textcolor{preprocessor}{#define GZ\_NONE 0}
00160 \textcolor{preprocessor}{#define GZ\_READ 7247}
00161 \textcolor{preprocessor}{#define GZ\_WRITE 31153}
00162 \textcolor{preprocessor}{#define GZ\_APPEND 1     }\textcolor{comment}{/* mode set to GZ\_WRITE after the file is opened */}\textcolor{preprocessor}{}
00163 
00164 \textcolor{comment}{/* values for gz\_state how */}
00165 \textcolor{preprocessor}{#define LOOK 0      }\textcolor{comment}{/* look for a gzip header */}\textcolor{preprocessor}{}
00166 \textcolor{preprocessor}{#define COPY 1      }\textcolor{comment}{/* copy input directly */}\textcolor{preprocessor}{}
00167 \textcolor{preprocessor}{#define GZIP 2      }\textcolor{comment}{/* decompress a gzip stream */}\textcolor{preprocessor}{}
00168 
00169 \textcolor{comment}{/* internal gzip file state data structure */}
\Hypertarget{visual__studio_2zlib_2gzguts_8h_source_l00170}\hyperlink{structgz__state}{00170} \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
00171         \textcolor{comment}{/* exposed contents for gzgetc() macro */}
00172     \textcolor{keyword}{struct }\hyperlink{structgz_file__s}{gzFile\_s} x;      \textcolor{comment}{/* "x" for exposed */}
00173                             \textcolor{comment}{/* x.have: number of bytes available at x.next */}
00174                             \textcolor{comment}{/* x.next: next output data to deliver or write */}
00175                             \textcolor{comment}{/* x.pos: current position in uncompressed data */}
00176         \textcolor{comment}{/* used for both reading and writing */}
00177     \textcolor{keywordtype}{int} mode;               \textcolor{comment}{/* see gzip modes above */}
00178     \textcolor{keywordtype}{int} fd;                 \textcolor{comment}{/* file descriptor */}
00179     \textcolor{keywordtype}{char} *path;             \textcolor{comment}{/* path or fd for error messages */}
00180     \textcolor{keywordtype}{unsigned} size;          \textcolor{comment}{/* buffer size, zero if not allocated yet */}
00181     \textcolor{keywordtype}{unsigned} want;          \textcolor{comment}{/* requested buffer size, default is GZBUFSIZE */}
00182     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *in;      \textcolor{comment}{/* input buffer (double-sized when writing) */}
00183     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *out;     \textcolor{comment}{/* output buffer (double-sized when reading) */}
00184     \textcolor{keywordtype}{int} direct;             \textcolor{comment}{/* 0 if processing gzip, 1 if transparent */}
00185         \textcolor{comment}{/* just for reading */}
00186     \textcolor{keywordtype}{int} how;                \textcolor{comment}{/* 0: get header, 1: copy, 2: decompress */}
00187     z\_off64\_t start;        \textcolor{comment}{/* where the gzip data started, for rewinding */}
00188     \textcolor{keywordtype}{int} eof;                \textcolor{comment}{/* true if end of input file reached */}
00189     \textcolor{keywordtype}{int} past;               \textcolor{comment}{/* true if read requested past end */}
00190         \textcolor{comment}{/* just for writing */}
00191     \textcolor{keywordtype}{int} level;              \textcolor{comment}{/* compression level */}
00192     \textcolor{keywordtype}{int} strategy;           \textcolor{comment}{/* compression strategy */}
00193         \textcolor{comment}{/* seek request */}
00194     z\_off64\_t skip;         \textcolor{comment}{/* amount to skip (already rewound if backwards) */}
00195     \textcolor{keywordtype}{int} seek;               \textcolor{comment}{/* true if seek request pending */}
00196         \textcolor{comment}{/* error information */}
00197     \textcolor{keywordtype}{int} err;                \textcolor{comment}{/* error code */}
00198     \textcolor{keywordtype}{char} *msg;              \textcolor{comment}{/* error message */}
00199         \textcolor{comment}{/* zlib inflate or deflate stream */}
00200     \hyperlink{structz__stream__s}{z\_stream} strm;          \textcolor{comment}{/* stream structure in-place (not a pointer) */}
00201 \} \hyperlink{structgz__state}{gz\_state};
00202 \textcolor{keyword}{typedef} \hyperlink{structgz__state}{gz\_state} FAR *gz\_statep;
00203 
00204 \textcolor{comment}{/* shared functions */}
00205 \textcolor{keywordtype}{void} ZLIB\_INTERNAL gz\_error OF((gz\_statep, \textcolor{keywordtype}{int}, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *));
00206 \textcolor{preprocessor}{#if defined UNDER\_CE}
00207 \textcolor{keywordtype}{char} ZLIB\_INTERNAL *gz\_strwinerror OF((DWORD error));
00208 \textcolor{preprocessor}{#endif}
00209 
00210 \textcolor{comment}{/* GT\_OFF(x), where x is an unsigned value, is true if x > maximum z\_off64\_t}
00211 \textcolor{comment}{   value -- needed when comparing unsigned to z\_off64\_t, which is signed}
00212 \textcolor{comment}{   (possible z\_off64\_t types off\_t, off64\_t, and long are all signed) */}
00213 \textcolor{preprocessor}{#ifdef INT\_MAX}
00214 \textcolor{preprocessor}{#  define GT\_OFF(x) (sizeof(int) == sizeof(z\_off64\_t) && (x) > INT\_MAX)}
00215 \textcolor{preprocessor}{#else}
00216 \textcolor{keywordtype}{unsigned} ZLIB\_INTERNAL gz\_intmax OF((\textcolor{keywordtype}{void}));
00217 \textcolor{preprocessor}{#  define GT\_OFF(x) (sizeof(int) == sizeof(z\_off64\_t) && (x) > gz\_intmax())}
00218 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
