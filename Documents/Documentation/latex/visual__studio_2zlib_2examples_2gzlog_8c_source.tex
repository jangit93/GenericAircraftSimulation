\hypertarget{visual__studio_2zlib_2examples_2gzlog_8c_source}{}\section{visual\+\_\+studio/zlib/examples/gzlog.c}
\label{visual__studio_2zlib_2examples_2gzlog_8c_source}\index{gzlog.\+c@{gzlog.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * gzlog.c}
00003 \textcolor{comment}{ * Copyright (C) 2004, 2008, 2012, 2016 Mark Adler, all rights reserved}
00004 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in gzlog.h}
00005 \textcolor{comment}{ * version 2.2, 14 Aug 2012}
00006 \textcolor{comment}{ */}
00007 
00008 \textcolor{comment}{/*}
00009 \textcolor{comment}{   gzlog provides a mechanism for frequently appending short strings to a gzip}
00010 \textcolor{comment}{   file that is efficient both in execution time and compression ratio.  The}
00011 \textcolor{comment}{   strategy is to write the short strings in an uncompressed form to the end of}
00012 \textcolor{comment}{   the gzip file, only compressing when the amount of uncompressed data has}
00013 \textcolor{comment}{   reached a given threshold.}
00014 \textcolor{comment}{}
00015 \textcolor{comment}{   gzlog also provides protection against interruptions in the process due to}
00016 \textcolor{comment}{   system crashes.  The status of the operation is recorded in an extra field}
00017 \textcolor{comment}{   in the gzip file, and is only updated once the gzip file is brought to a}
00018 \textcolor{comment}{   valid state.  The last data to be appended or compressed is saved in an}
00019 \textcolor{comment}{   auxiliary file, so that if the operation is interrupted, it can be completed}
00020 \textcolor{comment}{   the next time an append operation is attempted.}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{   gzlog maintains another auxiliary file with the last 32K of data from the}
00023 \textcolor{comment}{   compressed portion, which is preloaded for the compression of the subsequent}
00024 \textcolor{comment}{   data.  This minimizes the impact to the compression ratio of appending.}
00025 \textcolor{comment}{ */}
00026 
00027 \textcolor{comment}{/*}
00028 \textcolor{comment}{   Operations Concept:}
00029 \textcolor{comment}{}
00030 \textcolor{comment}{   Files (log name "foo"):}
00031 \textcolor{comment}{   foo.gz -- gzip file with the complete log}
00032 \textcolor{comment}{   foo.add -- last message to append or last data to compress}
00033 \textcolor{comment}{   foo.dict -- dictionary of the last 32K of data for next compression}
00034 \textcolor{comment}{   foo.temp -- temporary dictionary file for compression after this one}
00035 \textcolor{comment}{   foo.lock -- lock file for reading and writing the other files}
00036 \textcolor{comment}{   foo.repairs -- log file for log file recovery operations (not compressed)}
00037 \textcolor{comment}{}
00038 \textcolor{comment}{   gzip file structure:}
00039 \textcolor{comment}{   - fixed-length (no file name) header with extra field (see below)}
00040 \textcolor{comment}{   - compressed data ending initially with empty stored block}
00041 \textcolor{comment}{   - uncompressed data filling out originally empty stored block and}
00042 \textcolor{comment}{     subsequent stored blocks as needed (16K max each)}
00043 \textcolor{comment}{   - gzip trailer}
00044 \textcolor{comment}{   - no junk at end (no other gzip streams)}
00045 \textcolor{comment}{}
00046 \textcolor{comment}{   When appending data, the information in the first three items above plus the}
00047 \textcolor{comment}{   foo.add file are sufficient to recover an interrupted append operation.  The}
00048 \textcolor{comment}{   extra field has the necessary information to restore the start of the last}
00049 \textcolor{comment}{   stored block and determine where to append the data in the foo.add file, as}
00050 \textcolor{comment}{   well as the crc and length of the gzip data before the append operation.}
00051 \textcolor{comment}{}
00052 \textcolor{comment}{   The foo.add file is created before the gzip file is marked for append, and}
00053 \textcolor{comment}{   deleted after the gzip file is marked as complete.  So if the append}
00054 \textcolor{comment}{   operation is interrupted, the data to add will still be there.  If due to}
00055 \textcolor{comment}{   some external force, the foo.add file gets deleted between when the append}
00056 \textcolor{comment}{   operation was interrupted and when recovery is attempted, the gzip file will}
00057 \textcolor{comment}{   still be restored, but without the appended data.}
00058 \textcolor{comment}{}
00059 \textcolor{comment}{   When compressing data, the information in the first two items above plus the}
00060 \textcolor{comment}{   foo.add file are sufficient to recover an interrupted compress operation.}
00061 \textcolor{comment}{   The extra field has the necessary information to find the end of the}
00062 \textcolor{comment}{   compressed data, and contains both the crc and length of just the compressed}
00063 \textcolor{comment}{   data and of the complete set of data including the contents of the foo.add}
00064 \textcolor{comment}{   file.}
00065 \textcolor{comment}{}
00066 \textcolor{comment}{   Again, the foo.add file is maintained during the compress operation in case}
00067 \textcolor{comment}{   of an interruption.  If in the unlikely event the foo.add file with the data}
00068 \textcolor{comment}{   to be compressed is missing due to some external force, a gzip file with}
00069 \textcolor{comment}{   just the previous compressed data will be reconstructed.  In this case, all}
00070 \textcolor{comment}{   of the data that was to be compressed is lost (approximately one megabyte).}
00071 \textcolor{comment}{   This will not occur if all that happened was an interruption of the compress}
00072 \textcolor{comment}{   operation.}
00073 \textcolor{comment}{}
00074 \textcolor{comment}{   The third state that is marked is the replacement of the old dictionary with}
00075 \textcolor{comment}{   the new dictionary after a compress operation.  Once compression is}
00076 \textcolor{comment}{   complete, the gzip file is marked as being in the replace state.  This}
00077 \textcolor{comment}{   completes the gzip file, so an interrupt after being so marked does not}
00078 \textcolor{comment}{   result in recompression.  Then the dictionary file is replaced, and the gzip}
00079 \textcolor{comment}{   file is marked as completed.  This state prevents the possibility of}
00080 \textcolor{comment}{   restarting compression with the wrong dictionary file.}
00081 \textcolor{comment}{}
00082 \textcolor{comment}{   All three operations are wrapped by a lock/unlock procedure.  In order to}
00083 \textcolor{comment}{   gain exclusive access to the log files, first a foo.lock file must be}
00084 \textcolor{comment}{   exclusively created.  When all operations are complete, the lock is}
00085 \textcolor{comment}{   released by deleting the foo.lock file.  If when attempting to create the}
00086 \textcolor{comment}{   lock file, it already exists and the modify time of the lock file is more}
00087 \textcolor{comment}{   than five minutes old (set by the PATIENCE define below), then the old}
00088 \textcolor{comment}{   lock file is considered stale and deleted, and the exclusive creation of}
00089 \textcolor{comment}{   the lock file is retried.  To assure that there are no false assessments}
00090 \textcolor{comment}{   of the staleness of the lock file, the operations periodically touch the}
00091 \textcolor{comment}{   lock file to update the modified date.}
00092 \textcolor{comment}{}
00093 \textcolor{comment}{   Following is the definition of the extra field with all of the information}
00094 \textcolor{comment}{   required to enable the above append and compress operations and their}
00095 \textcolor{comment}{   recovery if interrupted.  Multi-byte values are stored little endian}
00096 \textcolor{comment}{   (consistent with the gzip format).  File pointers are eight bytes long.}
00097 \textcolor{comment}{   The crc's and lengths for the gzip trailer are four bytes long.  (Note that}
00098 \textcolor{comment}{   the length at the end of a gzip file is used for error checking only, and}
00099 \textcolor{comment}{   for large files is actually the length modulo 2^32.)  The stored block}
00100 \textcolor{comment}{   length is two bytes long.  The gzip extra field two-byte identification is}
00101 \textcolor{comment}{   "ap" for append.  It is assumed that writing the extra field to the file is}
00102 \textcolor{comment}{   an "atomic" operation.  That is, either all of the extra field is written}
00103 \textcolor{comment}{   to the file, or none of it is, if the operation is interrupted right at the}
00104 \textcolor{comment}{   point of updating the extra field.  This is a reasonable assumption, since}
00105 \textcolor{comment}{   the extra field is within the first 52 bytes of the file, which is smaller}
00106 \textcolor{comment}{   than any expected block size for a mass storage device (usually 512 bytes or}
00107 \textcolor{comment}{   larger).}
00108 \textcolor{comment}{}
00109 \textcolor{comment}{   Extra field (35 bytes):}
00110 \textcolor{comment}{   - Pointer to first stored block length -- this points to the two-byte length}
00111 \textcolor{comment}{     of the first stored block, which is followed by the two-byte, one's}
00112 \textcolor{comment}{     complement of that length.  The stored block length is preceded by the}
00113 \textcolor{comment}{     three-bit header of the stored block, which is the actual start of the}
00114 \textcolor{comment}{     stored block in the deflate format.  See the bit offset field below.}
00115 \textcolor{comment}{   - Pointer to the last stored block length.  This is the same as above, but}
00116 \textcolor{comment}{     for the last stored block of the uncompressed data in the gzip file.}
00117 \textcolor{comment}{     Initially this is the same as the first stored block length pointer.}
00118 \textcolor{comment}{     When the stored block gets to 16K (see the MAX\_STORE define), then a new}
00119 \textcolor{comment}{     stored block as added, at which point the last stored block length pointer}
00120 \textcolor{comment}{     is different from the first stored block length pointer.  When they are}
00121 \textcolor{comment}{     different, the first bit of the last stored block header is eight bits, or}
00122 \textcolor{comment}{     one byte back from the block length.}
00123 \textcolor{comment}{   - Compressed data crc and length.  This is the crc and length of the data}
00124 \textcolor{comment}{     that is in the compressed portion of the deflate stream.  These are used}
00125 \textcolor{comment}{     only in the event that the foo.add file containing the data to compress is}
00126 \textcolor{comment}{     lost after a compress operation is interrupted.}
00127 \textcolor{comment}{   - Total data crc and length.  This is the crc and length of all of the data}
00128 \textcolor{comment}{     stored in the gzip file, compressed and uncompressed.  It is used to}
00129 \textcolor{comment}{     reconstruct the gzip trailer when compressing, as well as when recovering}
00130 \textcolor{comment}{     interrupted operations.}
00131 \textcolor{comment}{   - Final stored block length.  This is used to quickly find where to append,}
00132 \textcolor{comment}{     and allows the restoration of the original final stored block state when}
00133 \textcolor{comment}{     an append operation is interrupted.}
00134 \textcolor{comment}{   - First stored block start as the number of bits back from the final stored}
00135 \textcolor{comment}{     block first length byte.  This value is in the range of 3..10, and is}
00136 \textcolor{comment}{     stored as the low three bits of the final byte of the extra field after}
00137 \textcolor{comment}{     subtracting three (0..7).  This allows the last-block bit of the stored}
00138 \textcolor{comment}{     block header to be updated when a new stored block is added, for the case}
00139 \textcolor{comment}{     when the first stored block and the last stored block are the same.  (When}
00140 \textcolor{comment}{     they are different, the numbers of bits back is known to be eight.)  This}
00141 \textcolor{comment}{     also allows for new compressed data to be appended to the old compressed}
00142 \textcolor{comment}{     data in the compress operation, overwriting the previous first stored}
00143 \textcolor{comment}{     block, or for the compressed data to be terminated and a valid gzip file}
00144 \textcolor{comment}{     reconstructed on the off chance that a compression operation was}
00145 \textcolor{comment}{     interrupted and the data to compress in the foo.add file was deleted.}
00146 \textcolor{comment}{   - The operation in process.  This is the next two bits in the last byte (the}
00147 \textcolor{comment}{     bits under the mask 0x18).  The are interpreted as 0: nothing in process,}
00148 \textcolor{comment}{     1: append in process, 2: compress in process, 3: replace in process.}
00149 \textcolor{comment}{   - The top three bits of the last byte in the extra field are reserved and}
00150 \textcolor{comment}{     are currently set to zero.}
00151 \textcolor{comment}{}
00152 \textcolor{comment}{   Main procedure:}
00153 \textcolor{comment}{   - Exclusively create the foo.lock file using the O\_CREAT and O\_EXCL modes of}
00154 \textcolor{comment}{     the system open() call.  If the modify time of an existing lock file is}
00155 \textcolor{comment}{     more than PATIENCE seconds old, then the lock file is deleted and the}
00156 \textcolor{comment}{     exclusive create is retried.}
00157 \textcolor{comment}{   - Load the extra field from the foo.gz file, and see if an operation was in}
00158 \textcolor{comment}{     progress but not completed.  If so, apply the recovery procedure below.}
00159 \textcolor{comment}{   - Perform the append procedure with the provided data.}
00160 \textcolor{comment}{   - If the uncompressed data in the foo.gz file is 1MB or more, apply the}
00161 \textcolor{comment}{     compress procedure.}
00162 \textcolor{comment}{   - Delete the foo.lock file.}
00163 \textcolor{comment}{}
00164 \textcolor{comment}{   Append procedure:}
00165 \textcolor{comment}{   - Put what to append in the foo.add file so that the operation can be}
00166 \textcolor{comment}{     restarted if this procedure is interrupted.}
00167 \textcolor{comment}{   - Mark the foo.gz extra field with the append operation in progress.}
00168 \textcolor{comment}{   + Restore the original last-block bit and stored block length of the last}
00169 \textcolor{comment}{     stored block from the information in the extra field, in case a previous}
00170 \textcolor{comment}{     append operation was interrupted.}
00171 \textcolor{comment}{   - Append the provided data to the last stored block, creating new stored}
00172 \textcolor{comment}{     blocks as needed and updating the stored blocks last-block bits and}
00173 \textcolor{comment}{     lengths.}
00174 \textcolor{comment}{   - Update the crc and length with the new data, and write the gzip trailer.}
00175 \textcolor{comment}{   - Write over the extra field (with a single write operation) with the new}
00176 \textcolor{comment}{     pointers, lengths, and crc's, and mark the gzip file as not in process.}
00177 \textcolor{comment}{     Though there is still a foo.add file, it will be ignored since nothing}
00178 \textcolor{comment}{     is in process.  If a foo.add file is leftover from a previously}
00179 \textcolor{comment}{     completed operation, it is truncated when writing new data to it.}
00180 \textcolor{comment}{   - Delete the foo.add file.}
00181 \textcolor{comment}{}
00182 \textcolor{comment}{   Compress and replace procedures:}
00183 \textcolor{comment}{   - Read all of the uncompressed data in the stored blocks in foo.gz and write}
00184 \textcolor{comment}{     it to foo.add.  Also write foo.temp with the last 32K of that data to}
00185 \textcolor{comment}{     provide a dictionary for the next invocation of this procedure.}
00186 \textcolor{comment}{   - Rewrite the extra field marking foo.gz with a compression in process.}
00187 \textcolor{comment}{   * If there is no data provided to compress (due to a missing foo.add file}
00188 \textcolor{comment}{     when recovering), reconstruct and truncate the foo.gz file to contain}
00189 \textcolor{comment}{     only the previous compressed data and proceed to the step after the next}
00190 \textcolor{comment}{     one.  Otherwise ...}
00191 \textcolor{comment}{   - Compress the data with the dictionary in foo.dict, and write to the}
00192 \textcolor{comment}{     foo.gz file starting at the bit immediately following the last previously}
00193 \textcolor{comment}{     compressed block.  If there is no foo.dict, proceed anyway with the}
00194 \textcolor{comment}{     compression at slightly reduced efficiency.  (For the foo.dict file to be}
00195 \textcolor{comment}{     missing requires some external failure beyond simply the interruption of}
00196 \textcolor{comment}{     a compress operation.)  During this process, the foo.lock file is}
00197 \textcolor{comment}{     periodically touched to assure that that file is not considered stale by}
00198 \textcolor{comment}{     another process before we're done.  The deflation is terminated with a}
00199 \textcolor{comment}{     non-last empty static block (10 bits long), that is then located and}
00200 \textcolor{comment}{     written over by a last-bit-set empty stored block.}
00201 \textcolor{comment}{   - Append the crc and length of the data in the gzip file (previously}
00202 \textcolor{comment}{     calculated during the append operations).}
00203 \textcolor{comment}{   - Write over the extra field with the updated stored block offsets, bits}
00204 \textcolor{comment}{     back, crc's, and lengths, and mark foo.gz as in process for a replacement}
00205 \textcolor{comment}{     of the dictionary.}
00206 \textcolor{comment}{   @ Delete the foo.add file.}
00207 \textcolor{comment}{   - Replace foo.dict with foo.temp.}
00208 \textcolor{comment}{   - Write over the extra field, marking foo.gz as complete.}
00209 \textcolor{comment}{}
00210 \textcolor{comment}{   Recovery procedure:}
00211 \textcolor{comment}{   - If not a replace recovery, read in the foo.add file, and provide that data}
00212 \textcolor{comment}{     to the appropriate recovery below.  If there is no foo.add file, provide}
00213 \textcolor{comment}{     a zero data length to the recovery.  In that case, the append recovery}
00214 \textcolor{comment}{     restores the foo.gz to the previous compressed + uncompressed data state.}
00215 \textcolor{comment}{     For the the compress recovery, a missing foo.add file results in foo.gz}
00216 \textcolor{comment}{     being restored to the previous compressed-only data state.}
00217 \textcolor{comment}{   - Append recovery:}
00218 \textcolor{comment}{     - Pick up append at + step above}
00219 \textcolor{comment}{   - Compress recovery:}
00220 \textcolor{comment}{     - Pick up compress at * step above}
00221 \textcolor{comment}{   - Replace recovery:}
00222 \textcolor{comment}{     - Pick up compress at @ step above}
00223 \textcolor{comment}{   - Log the repair with a date stamp in foo.repairs}
00224 \textcolor{comment}{ */}
00225 
00226 \textcolor{preprocessor}{#include <sys/types.h>}
00227 \textcolor{preprocessor}{#include <stdio.h>}      \textcolor{comment}{/* rename, fopen, fprintf, fclose */}
00228 \textcolor{preprocessor}{#include <stdlib.h>}     \textcolor{comment}{/* malloc, free */}
00229 \textcolor{preprocessor}{#include <string.h>}     \textcolor{comment}{/* strlen, strrchr, strcpy, strncpy, strcmp */}
00230 \textcolor{preprocessor}{#include <fcntl.h>}      \textcolor{comment}{/* open */}
00231 \textcolor{preprocessor}{#include <unistd.h>}     \textcolor{comment}{/* lseek, read, write, close, unlink, sleep, */}
00232                         \textcolor{comment}{/* ftruncate, fsync */}
00233 \textcolor{preprocessor}{#include <errno.h>}      \textcolor{comment}{/* errno */}
00234 \textcolor{preprocessor}{#include <time.h>}       \textcolor{comment}{/* time, ctime */}
00235 \textcolor{preprocessor}{#include <sys/stat.h>}   \textcolor{comment}{/* stat */}
00236 \textcolor{preprocessor}{#include <sys/time.h>}   \textcolor{comment}{/* utimes */}
00237 \textcolor{preprocessor}{#include "zlib.h"}       \textcolor{comment}{/* crc32 */}
00238 
00239 \textcolor{preprocessor}{#include "gzlog.h"}      \textcolor{comment}{/* header for external access */}
00240 
00241 \textcolor{preprocessor}{#define local static}
00242 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} uint;
00243 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} ulong;
00244 
00245 \textcolor{comment}{/* Macro for debugging to deterministically force recovery operations */}
00246 \textcolor{preprocessor}{#ifdef GZLOG\_DEBUG}
00247 \textcolor{preprocessor}{    #include <setjmp.h>}         \textcolor{comment}{/* longjmp */}
00248     jmp\_buf gzlog\_jump;         \textcolor{comment}{/* where to go back to */}
00249     \textcolor{keywordtype}{int} gzlog\_bail = 0;         \textcolor{comment}{/* which point to bail at (1..8) */}
00250     \textcolor{keywordtype}{int} gzlog\_count = -1;       \textcolor{comment}{/* number of times through to wait */}
00251 \textcolor{preprocessor}{#   define BAIL(n) do \{ if (n == gzlog\_bail && gzlog\_count-- == 0) \(\backslash\)}
00252 \textcolor{preprocessor}{                            longjmp(gzlog\_jump, gzlog\_bail); \} while (0)}
00253 \textcolor{preprocessor}{#else}
00254 \textcolor{preprocessor}{#   define BAIL(n)}
00255 \textcolor{preprocessor}{#endif}
00256 
00257 \textcolor{comment}{/* how old the lock file can be in seconds before considering it stale */}
00258 \textcolor{preprocessor}{#define PATIENCE 300}
00259 
00260 \textcolor{comment}{/* maximum stored block size in Kbytes -- must be in 1..63 */}
00261 \textcolor{preprocessor}{#define MAX\_STORE 16}
00262 
00263 \textcolor{comment}{/* number of stored Kbytes to trigger compression (must be >= 32 to allow}
00264 \textcolor{comment}{   dictionary construction, and <= 204 * MAX\_STORE, in order for >> 10 to}
00265 \textcolor{comment}{   discard the stored block headers contribution of five bytes each) */}
00266 \textcolor{preprocessor}{#define TRIGGER 1024}
00267 
00268 \textcolor{comment}{/* size of a deflate dictionary (this cannot be changed) */}
00269 \textcolor{preprocessor}{#define DICT 32768U}
00270 
00271 \textcolor{comment}{/* values for the operation (2 bits) */}
00272 \textcolor{preprocessor}{#define NO\_OP 0}
00273 \textcolor{preprocessor}{#define APPEND\_OP 1}
00274 \textcolor{preprocessor}{#define COMPRESS\_OP 2}
00275 \textcolor{preprocessor}{#define REPLACE\_OP 3}
00276 
00277 \textcolor{comment}{/* macros to extract little-endian integers from an unsigned byte buffer */}
00278 \textcolor{preprocessor}{#define PULL2(p) ((p)[0]+((uint)((p)[1])<<8))}
00279 \textcolor{preprocessor}{#define PULL4(p) (PULL2(p)+((ulong)PULL2(p+2)<<16))}
00280 \textcolor{preprocessor}{#define PULL8(p) (PULL4(p)+((off\_t)PULL4(p+4)<<32))}
00281 
00282 \textcolor{comment}{/* macros to store integers into a byte buffer in little-endian order */}
00283 \textcolor{preprocessor}{#define PUT2(p,a) do \{(p)[0]=a;(p)[1]=(a)>>8;\} while(0)}
00284 \textcolor{preprocessor}{#define PUT4(p,a) do \{PUT2(p,a);PUT2(p+2,a>>16);\} while(0)}
00285 \textcolor{preprocessor}{#define PUT8(p,a) do \{PUT4(p,a);PUT4(p+4,a>>32);\} while(0)}
00286 
00287 \textcolor{comment}{/* internal structure for log information */}
00288 \textcolor{preprocessor}{#define LOGID "\(\backslash\)106\(\backslash\)035\(\backslash\)172"    }\textcolor{comment}{/* should be three non-zero characters */}\textcolor{preprocessor}{}
\Hypertarget{visual__studio_2zlib_2examples_2gzlog_8c_source_l00289}\hyperlink{structlog}{00289} \textcolor{keyword}{struct }\hyperlink{structlog}{log} \{
00290     \textcolor{keywordtype}{char} \textcolor{keywordtype}{id}[4];     \textcolor{comment}{/* contains LOGID to detect inadvertent overwrites */}
00291     \textcolor{keywordtype}{int} fd;         \textcolor{comment}{/* file descriptor for .gz file, opened read/write */}
00292     \textcolor{keywordtype}{char} *path;     \textcolor{comment}{/* allocated path, e.g. "/var/log/foo" or "foo" */}
00293     \textcolor{keywordtype}{char} *end;      \textcolor{comment}{/* end of path, for appending suffices such as ".gz" */}
00294     off\_t first;    \textcolor{comment}{/* offset of first stored block first length byte */}
00295     \textcolor{keywordtype}{int} back;       \textcolor{comment}{/* location of first block id in bits back from first */}
00296     uint stored;    \textcolor{comment}{/* bytes currently in last stored block */}
00297     off\_t last;     \textcolor{comment}{/* offset of last stored block first length byte */}
00298     ulong ccrc;     \textcolor{comment}{/* crc of compressed data */}
00299     ulong clen;     \textcolor{comment}{/* length (modulo 2^32) of compressed data */}
00300     ulong tcrc;     \textcolor{comment}{/* crc of total data */}
00301     ulong tlen;     \textcolor{comment}{/* length (modulo 2^32) of total data */}
00302     time\_t lock;    \textcolor{comment}{/* last modify time of our lock file */}
00303 \};
00304 
00305 \textcolor{comment}{/* gzip header for gzlog */}
00306 local \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} log\_gzhead[] = \{
00307     0x1f, 0x8b,                 \textcolor{comment}{/* magic gzip id */}
00308     8,                          \textcolor{comment}{/* compression method is deflate */}
00309     4,                          \textcolor{comment}{/* there is an extra field (no file name) */}
00310     0, 0, 0, 0,                 \textcolor{comment}{/* no modification time provided */}
00311     0, 0xff,                    \textcolor{comment}{/* no extra flags, no OS specified */}
00312     39, 0, \textcolor{charliteral}{'a'}, \textcolor{charliteral}{'p'}, 35, 0      \textcolor{comment}{/* extra field with "ap" subfield */}
00313                                 \textcolor{comment}{/* 35 is EXTRA, 39 is EXTRA + 4 */}
00314 \};
00315 
00316 \textcolor{preprocessor}{#define HEAD sizeof(log\_gzhead)     }\textcolor{comment}{/* should be 16 */}\textcolor{preprocessor}{}
00317 
00318 \textcolor{comment}{/* initial gzip extra field content (52 == HEAD + EXTRA + 1) */}
00319 local \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} log\_gzext[] = \{
00320     52, 0, 0, 0, 0, 0, 0, 0,    \textcolor{comment}{/* offset of first stored block length */}
00321     52, 0, 0, 0, 0, 0, 0, 0,    \textcolor{comment}{/* offset of last stored block length */}
00322     0, 0, 0, 0, 0, 0, 0, 0,     \textcolor{comment}{/* compressed data crc and length */}
00323     0, 0, 0, 0, 0, 0, 0, 0,     \textcolor{comment}{/* total data crc and length */}
00324     0, 0,                       \textcolor{comment}{/* final stored block data length */}
00325     5                           \textcolor{comment}{/* op is NO\_OP, last bit 8 bits back */}
00326 \};
00327 
00328 \textcolor{preprocessor}{#define EXTRA sizeof(log\_gzext)     }\textcolor{comment}{/* should be 35 */}\textcolor{preprocessor}{}
00329 
00330 \textcolor{comment}{/* initial gzip data and trailer */}
00331 local \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} log\_gzbody[] = \{
00332     1, 0, 0, 0xff, 0xff,        \textcolor{comment}{/* empty stored block (last) */}
00333     0, 0, 0, 0,                 \textcolor{comment}{/* crc */}
00334     0, 0, 0, 0                  \textcolor{comment}{/* uncompressed length */}
00335 \};
00336 
00337 \textcolor{preprocessor}{#define BODY sizeof(log\_gzbody)}
00338 
00339 \textcolor{comment}{/* Exclusively create foo.lock in order to negotiate exclusive access to the}
00340 \textcolor{comment}{   foo.* files.  If the modify time of an existing lock file is greater than}
00341 \textcolor{comment}{   PATIENCE seconds in the past, then consider the lock file to have been}
00342 \textcolor{comment}{   abandoned, delete it, and try the exclusive create again.  Save the lock}
00343 \textcolor{comment}{   file modify time for verification of ownership.  Return 0 on success, or -1}
00344 \textcolor{comment}{   on failure, usually due to an access restriction or invalid path.  Note that}
00345 \textcolor{comment}{   if stat() or unlink() fails, it may be due to another process noticing the}
00346 \textcolor{comment}{   abandoned lock file a smidge sooner and deleting it, so those are not}
00347 \textcolor{comment}{   flagged as an error. */}
00348 local \textcolor{keywordtype}{int} log\_lock(\textcolor{keyword}{struct} \hyperlink{structlog}{log} *\hyperlink{structlog}{log})
00349 \{
00350     \textcolor{keywordtype}{int} fd;
00351     \textcolor{keyword}{struct }stat st;
00352 
00353     strcpy(log->end, \textcolor{stringliteral}{".lock"});
00354     \textcolor{keywordflow}{while} ((fd = open(log->path, O\_CREAT | O\_EXCL, 0644)) < 0) \{
00355         \textcolor{keywordflow}{if} (errno != EEXIST)
00356             \textcolor{keywordflow}{return} -1;
00357         \textcolor{keywordflow}{if} (stat(log->path, &st) == 0 && time(NULL) - st.st\_mtime > PATIENCE) \{
00358             unlink(log->path);
00359             \textcolor{keywordflow}{continue};
00360         \}
00361         sleep(2);       \textcolor{comment}{/* relinquish the CPU for two seconds while waiting */}
00362     \}
00363     close(fd);
00364     \textcolor{keywordflow}{if} (stat(log->path, &st) == 0)
00365         log->lock = st.st\_mtime;
00366     \textcolor{keywordflow}{return} 0;
00367 \}
00368 
00369 \textcolor{comment}{/* Update the modify time of the lock file to now, in order to prevent another}
00370 \textcolor{comment}{   task from thinking that the lock is stale.  Save the lock file modify time}
00371 \textcolor{comment}{   for verification of ownership. */}
00372 local \textcolor{keywordtype}{void} log\_touch(\textcolor{keyword}{struct} log *log)
00373 \{
00374     \textcolor{keyword}{struct }stat st;
00375 
00376     strcpy(log->end, \textcolor{stringliteral}{".lock"});
00377     utimes(log->path, NULL);
00378     \textcolor{keywordflow}{if} (stat(log->path, &st) == 0)
00379         log->lock = st.st\_mtime;
00380 \}
00381 
00382 \textcolor{comment}{/* Check the log file modify time against what is expected.  Return true if}
00383 \textcolor{comment}{   this is not our lock.  If it is our lock, touch it to keep it. */}
00384 local \textcolor{keywordtype}{int} log\_check(\textcolor{keyword}{struct} log *log)
00385 \{
00386     \textcolor{keyword}{struct }stat st;
00387 
00388     strcpy(log->end, \textcolor{stringliteral}{".lock"});
00389     \textcolor{keywordflow}{if} (stat(log->path, &st) || st.st\_mtime != log->lock)
00390         \textcolor{keywordflow}{return} 1;
00391     log\_touch(log);
00392     \textcolor{keywordflow}{return} 0;
00393 \}
00394 
00395 \textcolor{comment}{/* Unlock a previously acquired lock, but only if it's ours. */}
00396 local \textcolor{keywordtype}{void} log\_unlock(\textcolor{keyword}{struct} log *log)
00397 \{
00398     \textcolor{keywordflow}{if} (log\_check(log))
00399         \textcolor{keywordflow}{return};
00400     strcpy(log->end, \textcolor{stringliteral}{".lock"});
00401     unlink(log->path);
00402     log->lock = 0;
00403 \}
00404 
00405 \textcolor{comment}{/* Check the gzip header and read in the extra field, filling in the values in}
00406 \textcolor{comment}{   the log structure.  Return op on success or -1 if the gzip header was not as}
00407 \textcolor{comment}{   expected.  op is the current operation in progress last written to the extra}
00408 \textcolor{comment}{   field.  This assumes that the gzip file has already been opened, with the}
00409 \textcolor{comment}{   file descriptor log->fd. */}
00410 local \textcolor{keywordtype}{int} log\_head(\textcolor{keyword}{struct} log *log)
00411 \{
00412     \textcolor{keywordtype}{int} op;
00413     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[HEAD + EXTRA];
00414 
00415     \textcolor{keywordflow}{if} (lseek(log->fd, 0, SEEK\_SET) < 0 ||
00416         read(log->fd, buf, HEAD + EXTRA) != HEAD + EXTRA ||
00417         memcmp(buf, log\_gzhead, HEAD)) \{
00418         \textcolor{keywordflow}{return} -1;
00419     \}
00420     log->first = PULL8(buf + HEAD);
00421     log->last = PULL8(buf + HEAD + 8);
00422     log->ccrc = PULL4(buf + HEAD + 16);
00423     log->clen = PULL4(buf + HEAD + 20);
00424     log->tcrc = PULL4(buf + HEAD + 24);
00425     log->tlen = PULL4(buf + HEAD + 28);
00426     log->stored = PULL2(buf + HEAD + 32);
00427     log->back = 3 + (buf[HEAD + 34] & 7);
00428     op = (buf[HEAD + 34] >> 3) & 3;
00429     \textcolor{keywordflow}{return} op;
00430 \}
00431 
00432 \textcolor{comment}{/* Write over the extra field contents, marking the operation as op.  Use fsync}
00433 \textcolor{comment}{   to assure that the device is written to, and in the requested order.  This}
00434 \textcolor{comment}{   operation, and only this operation, is assumed to be atomic in order to}
00435 \textcolor{comment}{   assure that the log is recoverable in the event of an interruption at any}
00436 \textcolor{comment}{   point in the process.  Return -1 if the write to foo.gz failed. */}
00437 local \textcolor{keywordtype}{int} log\_mark(\textcolor{keyword}{struct} log *log, \textcolor{keywordtype}{int} op)
00438 \{
00439     \textcolor{keywordtype}{int} ret;
00440     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} ext[EXTRA];
00441 
00442     PUT8(ext, log->first);
00443     PUT8(ext + 8, log->last);
00444     PUT4(ext + 16, log->ccrc);
00445     PUT4(ext + 20, log->clen);
00446     PUT4(ext + 24, log->tcrc);
00447     PUT4(ext + 28, log->tlen);
00448     PUT2(ext + 32, log->stored);
00449     ext[34] = log->back - 3 + (op << 3);
00450     fsync(log->fd);
00451     ret = lseek(log->fd, HEAD, SEEK\_SET) < 0 ||
00452           write(log->fd, ext, EXTRA) != EXTRA ? -1 : 0;
00453     fsync(log->fd);
00454     \textcolor{keywordflow}{return} ret;
00455 \}
00456 
00457 \textcolor{comment}{/* Rewrite the last block header bits and subsequent zero bits to get to a byte}
00458 \textcolor{comment}{   boundary, setting the last block bit if last is true, and then write the}
00459 \textcolor{comment}{   remainder of the stored block header (length and one's complement).  Leave}
00460 \textcolor{comment}{   the file pointer after the end of the last stored block data.  Return -1 if}
00461 \textcolor{comment}{   there is a read or write failure on the foo.gz file */}
00462 local \textcolor{keywordtype}{int} log\_last(\textcolor{keyword}{struct} log *log, \textcolor{keywordtype}{int} last)
00463 \{
00464     \textcolor{keywordtype}{int} back, len, mask;
00465     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[6];
00466 
00467     \textcolor{comment}{/* determine the locations of the bytes and bits to modify */}
00468     back = log->last == log->first ? log->back : 8;
00469     len = back > 8 ? 2 : 1;                 \textcolor{comment}{/* bytes back from log->last */}
00470     mask = 0x80 >> ((back - 1) & 7);        \textcolor{comment}{/* mask for block last-bit */}
00471 
00472     \textcolor{comment}{/* get the byte to modify (one or two back) into buf[0] -- don't need to}
00473 \textcolor{comment}{       read the byte if the last-bit is eight bits back, since in that case}
00474 \textcolor{comment}{       the entire byte will be modified */}
00475     buf[0] = 0;
00476     \textcolor{keywordflow}{if} (back != 8 && (lseek(log->fd, log->last - len, SEEK\_SET) < 0 ||
00477                       read(log->fd, buf, 1) != 1))
00478         \textcolor{keywordflow}{return} -1;
00479 
00480     \textcolor{comment}{/* change the last-bit of the last stored block as requested -- note}
00481 \textcolor{comment}{       that all bits above the last-bit are set to zero, per the type bits}
00482 \textcolor{comment}{       of a stored block being 00 and per the convention that the bits to}
00483 \textcolor{comment}{       bring the stream to a byte boundary are also zeros */}
00484     buf[1] = 0;
00485     buf[2 - len] = (*buf & (mask - 1)) + (last ? mask : 0);
00486 
00487     \textcolor{comment}{/* write the modified stored block header and lengths, move the file}
00488 \textcolor{comment}{       pointer to after the last stored block data */}
00489     PUT2(buf + 2, log->stored);
00490     PUT2(buf + 4, log->stored ^ 0xffff);
00491     \textcolor{keywordflow}{return} lseek(log->fd, log->last - len, SEEK\_SET) < 0 ||
00492            write(log->fd, buf + 2 - len, len + 4) != len + 4 ||
00493            lseek(log->fd, log->stored, SEEK\_CUR) < 0 ? -1 : 0;
00494 \}
00495 
00496 \textcolor{comment}{/* Append len bytes from data to the locked and open log file.  len may be zero}
00497 \textcolor{comment}{   if recovering and no .add file was found.  In that case, the previous state}
00498 \textcolor{comment}{   of the foo.gz file is restored.  The data is appended uncompressed in}
00499 \textcolor{comment}{   deflate stored blocks.  Return -1 if there was an error reading or writing}
00500 \textcolor{comment}{   the foo.gz file. */}
00501 local \textcolor{keywordtype}{int} log\_append(\textcolor{keyword}{struct} log *log, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{size\_t} len)
00502 \{
00503     uint put;
00504     off\_t end;
00505     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[8];
00506 
00507     \textcolor{comment}{/* set the last block last-bit and length, in case recovering an}
00508 \textcolor{comment}{       interrupted append, then position the file pointer to append to the}
00509 \textcolor{comment}{       block */}
00510     \textcolor{keywordflow}{if} (log\_last(log, 1))
00511         \textcolor{keywordflow}{return} -1;
00512 
00513     \textcolor{comment}{/* append, adding stored blocks and updating the offset of the last stored}
00514 \textcolor{comment}{       block as needed, and update the total crc and length */}
00515     \textcolor{keywordflow}{while} (len) \{
00516         \textcolor{comment}{/* append as much as we can to the last block */}
00517         put = (MAX\_STORE << 10) - log->stored;
00518         if (put > len)
00519             put = (uint)len;
00520         \textcolor{keywordflow}{if} (put) \{
00521             \textcolor{keywordflow}{if} (write(log->fd, data, put) != put)
00522                 \textcolor{keywordflow}{return} -1;
00523             BAIL(1);
00524             log->tcrc = crc32(log->tcrc, data, put);
00525             log->tlen += put;
00526             log->stored += put;
00527             data += put;
00528             len -= put;
00529         \}
00530 
00531         \textcolor{comment}{/* if we need to, add a new empty stored block */}
00532         \textcolor{keywordflow}{if} (len) \{
00533             \textcolor{comment}{/* mark current block as not last */}
00534             \textcolor{keywordflow}{if} (log\_last(log, 0))
00535                 \textcolor{keywordflow}{return} -1;
00536 
00537             \textcolor{comment}{/* point to new, empty stored block */}
00538             log->last += 4 + log->stored + 1;
00539             log->stored = 0;
00540         \}
00541 
00542         \textcolor{comment}{/* mark last block as last, update its length */}
00543         \textcolor{keywordflow}{if} (log\_last(log, 1))
00544             \textcolor{keywordflow}{return} -1;
00545         BAIL(2);
00546     \}
00547 
00548     \textcolor{comment}{/* write the new crc and length trailer, and truncate just in case (could}
00549 \textcolor{comment}{       be recovering from partial append with a missing foo.add file) */}
00550     PUT4(buf, log->tcrc);
00551     PUT4(buf + 4, log->tlen);
00552     \textcolor{keywordflow}{if} (write(log->fd, buf, 8) != 8 ||
00553         (end = lseek(log->fd, 0, SEEK\_CUR)) < 0 || ftruncate(log->fd, end))
00554         \textcolor{keywordflow}{return} -1;
00555 
00556     \textcolor{comment}{/* write the extra field, marking the log file as done, delete .add file */}
00557     \textcolor{keywordflow}{if} (log\_mark(log, NO\_OP))
00558         \textcolor{keywordflow}{return} -1;
00559     strcpy(log->end, \textcolor{stringliteral}{".add"});
00560     unlink(log->path);          \textcolor{comment}{/* ignore error, since may not exist */}
00561     \textcolor{keywordflow}{return} 0;
00562 \}
00563 
00564 \textcolor{comment}{/* Replace the foo.dict file with the foo.temp file.  Also delete the foo.add}
00565 \textcolor{comment}{   file, since the compress operation may have been interrupted before that was}
00566 \textcolor{comment}{   done.  Returns 1 if memory could not be allocated, or -1 if reading or}
00567 \textcolor{comment}{   writing foo.gz fails, or if the rename fails for some reason other than}
00568 \textcolor{comment}{   foo.temp not existing.  foo.temp not existing is a permitted error, since}
00569 \textcolor{comment}{   the replace operation may have been interrupted after the rename is done,}
00570 \textcolor{comment}{   but before foo.gz is marked as complete. */}
00571 local \textcolor{keywordtype}{int} log\_replace(\textcolor{keyword}{struct} log *log)
00572 \{
00573     \textcolor{keywordtype}{int} ret;
00574     \textcolor{keywordtype}{char} *dest;
00575 
00576     \textcolor{comment}{/* delete foo.add file */}
00577     strcpy(log->end, \textcolor{stringliteral}{".add"});
00578     unlink(log->path);         \textcolor{comment}{/* ignore error, since may not exist */}
00579     BAIL(3);
00580 
00581     \textcolor{comment}{/* rename foo.name to foo.dict, replacing foo.dict if it exists */}
00582     strcpy(log->end, \textcolor{stringliteral}{".dict"});
00583     dest = malloc(strlen(log->path) + 1);
00584     \textcolor{keywordflow}{if} (dest == NULL)
00585         \textcolor{keywordflow}{return} -2;
00586     strcpy(dest, log->path);
00587     strcpy(log->end, \textcolor{stringliteral}{".temp"});
00588     ret = rename(log->path, dest);
00589     free(dest);
00590     \textcolor{keywordflow}{if} (ret && errno != ENOENT)
00591         \textcolor{keywordflow}{return} -1;
00592     BAIL(4);
00593 
00594     \textcolor{comment}{/* mark the foo.gz file as done */}
00595     \textcolor{keywordflow}{return} log\_mark(log, NO\_OP);
00596 \}
00597 
00598 \textcolor{comment}{/* Compress the len bytes at data and append the compressed data to the}
00599 \textcolor{comment}{   foo.gz deflate data immediately after the previous compressed data.  This}
00600 \textcolor{comment}{   overwrites the previous uncompressed data, which was stored in foo.add}
00601 \textcolor{comment}{   and is the data provided in data[0..len-1].  If this operation is}
00602 \textcolor{comment}{   interrupted, it picks up at the start of this routine, with the foo.add}
00603 \textcolor{comment}{   file read in again.  If there is no data to compress (len == 0), then we}
00604 \textcolor{comment}{   simply terminate the foo.gz file after the previously compressed data,}
00605 \textcolor{comment}{   appending a final empty stored block and the gzip trailer.  Return -1 if}
00606 \textcolor{comment}{   reading or writing the log.gz file failed, or -2 if there was a memory}
00607 \textcolor{comment}{   allocation failure. */}
00608 local \textcolor{keywordtype}{int} log\_compress(\textcolor{keyword}{struct} log *log, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{size\_t} len)
00609 \{
00610     \textcolor{keywordtype}{int} fd;
00611     uint got, max;
00612     ssize\_t dict;
00613     off\_t end;
00614     \hyperlink{structz__stream__s}{z\_stream} strm;
00615     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[DICT];
00616 
00617     \textcolor{comment}{/* compress and append compressed data */}
00618     \textcolor{keywordflow}{if} (len) \{
00619         \textcolor{comment}{/* set up for deflate, allocating memory */}
00620         strm.zalloc = Z\_NULL;
00621         strm.zfree = Z\_NULL;
00622         strm.opaque = Z\_NULL;
00623         \textcolor{keywordflow}{if} (deflateInit2(&strm, Z\_DEFAULT\_COMPRESSION, Z\_DEFLATED, -15, 8,
00624                          Z\_DEFAULT\_STRATEGY) != Z\_OK)
00625             \textcolor{keywordflow}{return} -2;
00626 
00627         \textcolor{comment}{/* read in dictionary (last 32K of data that was compressed) */}
00628         strcpy(log->end, \textcolor{stringliteral}{".dict"});
00629         fd = open(log->path, O\_RDONLY, 0);
00630         \textcolor{keywordflow}{if} (fd >= 0) \{
00631             dict = read(fd, buf, DICT);
00632             close(fd);
00633             \textcolor{keywordflow}{if} (dict < 0) \{
00634                 deflateEnd(&strm);
00635                 \textcolor{keywordflow}{return} -1;
00636             \}
00637             \textcolor{keywordflow}{if} (dict)
00638                 deflateSetDictionary(&strm, buf, (uint)dict);
00639         \}
00640         log\_touch(log);
00641 
00642         \textcolor{comment}{/* prime deflate with last bits of previous block, position write}
00643 \textcolor{comment}{           pointer to write those bits and overwrite what follows */}
00644         \textcolor{keywordflow}{if} (lseek(log->fd, log->first - (log->back > 8 ? 2 : 1),
00645                 SEEK\_SET) < 0 ||
00646             read(log->fd, buf, 1) != 1 || lseek(log->fd, -1, SEEK\_CUR) < 0) \{
00647             deflateEnd(&strm);
00648             \textcolor{keywordflow}{return} -1;
00649         \}
00650         deflatePrime(&strm, (8 - log->back) & 7, *buf);
00651 
00652         \textcolor{comment}{/* compress, finishing with a partial non-last empty static block */}
00653         strm.next\_in = data;
00654         max = (((uint)0 - 1) >> 1) + 1; \textcolor{comment}{/* in case int smaller than size\_t */}
00655         \textcolor{keywordflow}{do} \{
00656             strm.avail\_in = len > max ? max : (uint)len;
00657             len -= strm.avail\_in;
00658             \textcolor{keywordflow}{do} \{
00659                 strm.avail\_out = DICT;
00660                 strm.next\_out = buf;
00661                 deflate(&strm, len ? Z\_NO\_FLUSH : Z\_PARTIAL\_FLUSH);
00662                 got = DICT - strm.avail\_out;
00663                 \textcolor{keywordflow}{if} (got && write(log->fd, buf, got) != got) \{
00664                     deflateEnd(&strm);
00665                     \textcolor{keywordflow}{return} -1;
00666                 \}
00667                 log\_touch(log);
00668             \} \textcolor{keywordflow}{while} (strm.avail\_out == 0);
00669         \} \textcolor{keywordflow}{while} (len);
00670         deflateEnd(&strm);
00671         BAIL(5);
00672 
00673         \textcolor{comment}{/* find start of empty static block -- scanning backwards the first one}
00674 \textcolor{comment}{           bit is the second bit of the block, if the last byte is zero, then}
00675 \textcolor{comment}{           we know the byte before that has a one in the top bit, since an}
00676 \textcolor{comment}{           empty static block is ten bits long */}
00677         \textcolor{keywordflow}{if} ((log->first = lseek(log->fd, -1, SEEK\_CUR)) < 0 ||
00678             read(log->fd, buf, 1) != 1)
00679             \textcolor{keywordflow}{return} -1;
00680         log->first++;
00681         \textcolor{keywordflow}{if} (*buf) \{
00682             log->back = 1;
00683             \textcolor{keywordflow}{while} ((*buf & ((uint)1 << (8 - log->back++))) == 0)
00684                 ;       \textcolor{comment}{/* guaranteed to terminate, since *buf != 0 */}
00685         \}
00686         \textcolor{keywordflow}{else}
00687             log->back = 10;
00688 
00689         \textcolor{comment}{/* update compressed crc and length */}
00690         log->ccrc = log->tcrc;
00691         log->clen = log->tlen;
00692     \}
00693     \textcolor{keywordflow}{else} \{
00694         \textcolor{comment}{/* no data to compress -- fix up existing gzip stream */}
00695         log->tcrc = log->ccrc;
00696         log->tlen = log->clen;
00697     \}
00698 
00699     \textcolor{comment}{/* complete and truncate gzip stream */}
00700     log->last = log->first;
00701     log->stored = 0;
00702     PUT4(buf, log->tcrc);
00703     PUT4(buf + 4, log->tlen);
00704     \textcolor{keywordflow}{if} (log\_last(log, 1) || write(log->fd, buf, 8) != 8 ||
00705         (end = lseek(log->fd, 0, SEEK\_CUR)) < 0 || ftruncate(log->fd, end))
00706         \textcolor{keywordflow}{return} -1;
00707     BAIL(6);
00708 
00709     \textcolor{comment}{/* mark as being in the replace operation */}
00710     \textcolor{keywordflow}{if} (log\_mark(log, REPLACE\_OP))
00711         \textcolor{keywordflow}{return} -1;
00712 
00713     \textcolor{comment}{/* execute the replace operation and mark the file as done */}
00714     \textcolor{keywordflow}{return} log\_replace(log);
00715 \}
00716 
00717 \textcolor{comment}{/* log a repair record to the .repairs file */}
00718 local \textcolor{keywordtype}{void} log\_log(\textcolor{keyword}{struct} log *log, \textcolor{keywordtype}{int} op, \textcolor{keywordtype}{char} *record)
00719 \{
00720     time\_t now;
00721     FILE *rec;
00722 
00723     now = time(NULL);
00724     strcpy(log->end, \textcolor{stringliteral}{".repairs"});
00725     rec = fopen(log->path, \textcolor{stringliteral}{"a"});
00726     \textcolor{keywordflow}{if} (rec == NULL)
00727         \textcolor{keywordflow}{return};
00728     fprintf(rec, \textcolor{stringliteral}{"%.24s %s recovery: %s\(\backslash\)n"}, ctime(&now), op == APPEND\_OP ?
00729             \textcolor{stringliteral}{"append"} : (op == COMPRESS\_OP ? \textcolor{stringliteral}{"compress"} : \textcolor{stringliteral}{"replace"}), record);
00730     fclose(rec);
00731     \textcolor{keywordflow}{return};
00732 \}
00733 
00734 \textcolor{comment}{/* Recover the interrupted operation op.  First read foo.add for recovering an}
00735 \textcolor{comment}{   append or compress operation.  Return -1 if there was an error reading or}
00736 \textcolor{comment}{   writing foo.gz or reading an existing foo.add, or -2 if there was a memory}
00737 \textcolor{comment}{   allocation failure. */}
00738 local \textcolor{keywordtype}{int} log\_recover(\textcolor{keyword}{struct} log *log, \textcolor{keywordtype}{int} op)
00739 \{
00740     \textcolor{keywordtype}{int} fd, ret = 0;
00741     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data = NULL;
00742     \textcolor{keywordtype}{size\_t} len = 0;
00743     \textcolor{keyword}{struct }stat st;
00744 
00745     \textcolor{comment}{/* log recovery */}
00746     log\_log(log, op, \textcolor{stringliteral}{"start"});
00747 
00748     \textcolor{comment}{/* load foo.add file if expected and present */}
00749     \textcolor{keywordflow}{if} (op == APPEND\_OP || op == COMPRESS\_OP) \{
00750         strcpy(log->end, \textcolor{stringliteral}{".add"});
00751         \textcolor{keywordflow}{if} (stat(log->path, &st) == 0 && st.st\_size) \{
00752             len = (size\_t)(st.st\_size);
00753             \textcolor{keywordflow}{if} ((off\_t)len != st.st\_size ||
00754                     (data = malloc(st.st\_size)) == NULL) \{
00755                 log\_log(log, op, \textcolor{stringliteral}{"allocation failure"});
00756                 \textcolor{keywordflow}{return} -2;
00757             \}
00758             \textcolor{keywordflow}{if} ((fd = open(log->path, O\_RDONLY, 0)) < 0) \{
00759                 log\_log(log, op, \textcolor{stringliteral}{".add file read failure"});
00760                 \textcolor{keywordflow}{return} -1;
00761             \}
00762             ret = (size\_t)read(fd, data, len) != len;
00763             close(fd);
00764             \textcolor{keywordflow}{if} (ret) \{
00765                 log\_log(log, op, \textcolor{stringliteral}{".add file read failure"});
00766                 \textcolor{keywordflow}{return} -1;
00767             \}
00768             log\_log(log, op, \textcolor{stringliteral}{"loaded .add file"});
00769         \}
00770         \textcolor{keywordflow}{else}
00771             log\_log(log, op, \textcolor{stringliteral}{"missing .add file!"});
00772     \}
00773 
00774     \textcolor{comment}{/* recover the interrupted operation */}
00775     \textcolor{keywordflow}{switch} (op) \{
00776     \textcolor{keywordflow}{case} APPEND\_OP:
00777         ret = log\_append(log, data, len);
00778         \textcolor{keywordflow}{break};
00779     \textcolor{keywordflow}{case} COMPRESS\_OP:
00780         ret = log\_compress(log, data, len);
00781         \textcolor{keywordflow}{break};
00782     \textcolor{keywordflow}{case} REPLACE\_OP:
00783         ret = log\_replace(log);
00784     \}
00785 
00786     \textcolor{comment}{/* log status */}
00787     log\_log(log, op, ret ? \textcolor{stringliteral}{"failure"} : \textcolor{stringliteral}{"complete"});
00788 
00789     \textcolor{comment}{/* clean up */}
00790     \textcolor{keywordflow}{if} (data != NULL)
00791         free(data);
00792     \textcolor{keywordflow}{return} ret;
00793 \}
00794 
00795 \textcolor{comment}{/* Close the foo.gz file (if open) and release the lock. */}
00796 local \textcolor{keywordtype}{void} log\_close(\textcolor{keyword}{struct} log *log)
00797 \{
00798     \textcolor{keywordflow}{if} (log->fd >= 0)
00799         close(log->fd);
00800     log->fd = -1;
00801     log\_unlock(log);
00802 \}
00803 
00804 \textcolor{comment}{/* Open foo.gz, verify the header, and load the extra field contents, after}
00805 \textcolor{comment}{   first creating the foo.lock file to gain exclusive access to the foo.*}
00806 \textcolor{comment}{   files.  If foo.gz does not exist or is empty, then write the initial header,}
00807 \textcolor{comment}{   extra, and body content of an empty foo.gz log file.  If there is an error}
00808 \textcolor{comment}{   creating the lock file due to access restrictions, or an error reading or}
00809 \textcolor{comment}{   writing the foo.gz file, or if the foo.gz file is not a proper log file for}
00810 \textcolor{comment}{   this object (e.g. not a gzip file or does not contain the expected extra}
00811 \textcolor{comment}{   field), then return true.  If there is an error, the lock is released.}
00812 \textcolor{comment}{   Otherwise, the lock is left in place. */}
00813 local \textcolor{keywordtype}{int} log\_open(\textcolor{keyword}{struct} log *log)
00814 \{
00815     \textcolor{keywordtype}{int} op;
00816 
00817     \textcolor{comment}{/* release open file resource if left over -- can occur if lock lost}
00818 \textcolor{comment}{       between gzlog\_open() and gzlog\_write() */}
00819     \textcolor{keywordflow}{if} (log->fd >= 0)
00820         close(log->fd);
00821     log->fd = -1;
00822 
00823     \textcolor{comment}{/* negotiate exclusive access */}
00824     \textcolor{keywordflow}{if} (log\_lock(log) < 0)
00825         \textcolor{keywordflow}{return} -1;
00826 
00827     \textcolor{comment}{/* open the log file, foo.gz */}
00828     strcpy(log->end, \textcolor{stringliteral}{".gz"});
00829     log->fd = open(log->path, O\_RDWR | O\_CREAT, 0644);
00830     \textcolor{keywordflow}{if} (log->fd < 0) \{
00831         log\_close(log);
00832         \textcolor{keywordflow}{return} -1;
00833     \}
00834 
00835     \textcolor{comment}{/* if new, initialize foo.gz with an empty log, delete old dictionary */}
00836     \textcolor{keywordflow}{if} (lseek(log->fd, 0, SEEK\_END) == 0) \{
00837         \textcolor{keywordflow}{if} (write(log->fd, log\_gzhead, HEAD) != HEAD ||
00838             write(log->fd, log\_gzext, EXTRA) != EXTRA ||
00839             write(log->fd, log\_gzbody, BODY) != BODY) \{
00840             log\_close(log);
00841             \textcolor{keywordflow}{return} -1;
00842         \}
00843         strcpy(log->end, \textcolor{stringliteral}{".dict"});
00844         unlink(log->path);
00845     \}
00846 
00847     \textcolor{comment}{/* verify log file and load extra field information */}
00848     \textcolor{keywordflow}{if} ((op = log\_head(log)) < 0) \{
00849         log\_close(log);
00850         \textcolor{keywordflow}{return} -1;
00851     \}
00852 
00853     \textcolor{comment}{/* check for interrupted process and if so, recover */}
00854     \textcolor{keywordflow}{if} (op != NO\_OP && log\_recover(log, op)) \{
00855         log\_close(log);
00856         \textcolor{keywordflow}{return} -1;
00857     \}
00858 
00859     \textcolor{comment}{/* touch the lock file to prevent another process from grabbing it */}
00860     log\_touch(log);
00861     \textcolor{keywordflow}{return} 0;
00862 \}
00863 
00864 \textcolor{comment}{/* See gzlog.h for the description of the external methods below */}
00865 gzlog *gzlog\_open(\textcolor{keywordtype}{char} *path)
00866 \{
00867     \textcolor{keywordtype}{size\_t} n;
00868     \textcolor{keyword}{struct }log *log;
00869 
00870     \textcolor{comment}{/* check arguments */}
00871     \textcolor{keywordflow}{if} (path == NULL || *path == 0)
00872         \textcolor{keywordflow}{return} NULL;
00873 
00874     \textcolor{comment}{/* allocate and initialize log structure */}
00875     log = malloc(\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} log));
00876     \textcolor{keywordflow}{if} (log == NULL)
00877         \textcolor{keywordflow}{return} NULL;
00878     strcpy(log->id, LOGID);
00879     log->fd = -1;
00880 
00881     \textcolor{comment}{/* save path and end of path for name construction */}
00882     n = strlen(path);
00883     log->path = malloc(n + 9);              \textcolor{comment}{/* allow for ".repairs" */}
00884     \textcolor{keywordflow}{if} (log->path == NULL) \{
00885         free(log);
00886         \textcolor{keywordflow}{return} NULL;
00887     \}
00888     strcpy(log->path, path);
00889     log->end = log->path + n;
00890 
00891     \textcolor{comment}{/* gain exclusive access and verify log file -- may perform a}
00892 \textcolor{comment}{       recovery operation if needed */}
00893     \textcolor{keywordflow}{if} (log\_open(log)) \{
00894         free(log->path);
00895         free(log);
00896         \textcolor{keywordflow}{return} NULL;
00897     \}
00898 
00899     \textcolor{comment}{/* return pointer to log structure */}
00900     \textcolor{keywordflow}{return} log;
00901 \}
00902 
00903 \textcolor{comment}{/* gzlog\_compress() return values:}
00904 \textcolor{comment}{    0: all good}
00905 \textcolor{comment}{   -1: file i/o error (usually access issue)}
00906 \textcolor{comment}{   -2: memory allocation failure}
00907 \textcolor{comment}{   -3: invalid log pointer argument */}
00908 \textcolor{keywordtype}{int} gzlog\_compress(gzlog *logd)
00909 \{
00910     \textcolor{keywordtype}{int} fd, ret;
00911     uint block;
00912     \textcolor{keywordtype}{size\_t} len, next;
00913     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, buf[5];
00914     \textcolor{keyword}{struct }log *log = logd;
00915 
00916     \textcolor{comment}{/* check arguments */}
00917     \textcolor{keywordflow}{if} (log == NULL || strcmp(log->id, LOGID))
00918         \textcolor{keywordflow}{return} -3;
00919 
00920     \textcolor{comment}{/* see if we lost the lock -- if so get it again and reload the extra}
00921 \textcolor{comment}{       field information (it probably changed), recover last operation if}
00922 \textcolor{comment}{       necessary */}
00923     \textcolor{keywordflow}{if} (log\_check(log) && log\_open(log))
00924         \textcolor{keywordflow}{return} -1;
00925 
00926     \textcolor{comment}{/* create space for uncompressed data */}
00927     len = ((size\_t)(log->last - log->first) & ~(((size\_t)1 << 10) - 1)) +
00928           log->stored;
00929     \textcolor{keywordflow}{if} ((data = malloc(len)) == NULL)
00930         \textcolor{keywordflow}{return} -2;
00931 
00932     \textcolor{comment}{/* do statement here is just a cheap trick for error handling */}
00933     \textcolor{keywordflow}{do} \{
00934         \textcolor{comment}{/* read in the uncompressed data */}
00935         \textcolor{keywordflow}{if} (lseek(log->fd, log->first - 1, SEEK\_SET) < 0)
00936             \textcolor{keywordflow}{break};
00937         next = 0;
00938         \textcolor{keywordflow}{while} (next < len) \{
00939             \textcolor{keywordflow}{if} (read(log->fd, buf, 5) != 5)
00940                 \textcolor{keywordflow}{break};
00941             block = PULL2(buf + 1);
00942             \textcolor{keywordflow}{if} (next + block > len ||
00943                 read(log->fd, (\textcolor{keywordtype}{char} *)data + next, block) != block)
00944                 \textcolor{keywordflow}{break};
00945             next += block;
00946         \}
00947         \textcolor{keywordflow}{if} (lseek(log->fd, 0, SEEK\_CUR) != log->last + 4 + log->stored)
00948             \textcolor{keywordflow}{break};
00949         log\_touch(log);
00950 
00951         \textcolor{comment}{/* write the uncompressed data to the .add file */}
00952         strcpy(log->end, \textcolor{stringliteral}{".add"});
00953         fd = open(log->path, O\_WRONLY | O\_CREAT | O\_TRUNC, 0644);
00954         \textcolor{keywordflow}{if} (fd < 0)
00955             \textcolor{keywordflow}{break};
00956         ret = (size\_t)write(fd, data, len) != len;
00957         \textcolor{keywordflow}{if} (ret | close(fd))
00958             \textcolor{keywordflow}{break};
00959         log\_touch(log);
00960 
00961         \textcolor{comment}{/* write the dictionary for the next compress to the .temp file */}
00962         strcpy(log->end, \textcolor{stringliteral}{".temp"});
00963         fd = open(log->path, O\_WRONLY | O\_CREAT | O\_TRUNC, 0644);
00964         \textcolor{keywordflow}{if} (fd < 0)
00965             \textcolor{keywordflow}{break};
00966         next = DICT > len ? len : DICT;
00967         ret = (size\_t)write(fd, (\textcolor{keywordtype}{char} *)data + len - next, next) != next;
00968         \textcolor{keywordflow}{if} (ret | close(fd))
00969             \textcolor{keywordflow}{break};
00970         log\_touch(log);
00971 
00972         \textcolor{comment}{/* roll back to compressed data, mark the compress in progress */}
00973         log->last = log->first;
00974         log->stored = 0;
00975         \textcolor{keywordflow}{if} (log\_mark(log, COMPRESS\_OP))
00976             \textcolor{keywordflow}{break};
00977         BAIL(7);
00978 
00979         \textcolor{comment}{/* compress and append the data (clears mark) */}
00980         ret = log\_compress(log, data, len);
00981         free(data);
00982         \textcolor{keywordflow}{return} ret;
00983     \} \textcolor{keywordflow}{while} (0);
00984 
00985     \textcolor{comment}{/* broke out of do above on i/o error */}
00986     free(data);
00987     \textcolor{keywordflow}{return} -1;
00988 \}
00989 
00990 \textcolor{comment}{/* gzlog\_write() return values:}
00991 \textcolor{comment}{    0: all good}
00992 \textcolor{comment}{   -1: file i/o error (usually access issue)}
00993 \textcolor{comment}{   -2: memory allocation failure}
00994 \textcolor{comment}{   -3: invalid log pointer argument */}
00995 \textcolor{keywordtype}{int} gzlog\_write(gzlog *logd, \textcolor{keywordtype}{void} *data, \textcolor{keywordtype}{size\_t} len)
00996 \{
00997     \textcolor{keywordtype}{int} fd, ret;
00998     \textcolor{keyword}{struct }log *log = logd;
00999 
01000     \textcolor{comment}{/* check arguments */}
01001     \textcolor{keywordflow}{if} (log == NULL || strcmp(log->id, LOGID))
01002         \textcolor{keywordflow}{return} -3;
01003     \textcolor{keywordflow}{if} (data == NULL || len <= 0)
01004         \textcolor{keywordflow}{return} 0;
01005 
01006     \textcolor{comment}{/* see if we lost the lock -- if so get it again and reload the extra}
01007 \textcolor{comment}{       field information (it probably changed), recover last operation if}
01008 \textcolor{comment}{       necessary */}
01009     \textcolor{keywordflow}{if} (log\_check(log) && log\_open(log))
01010         \textcolor{keywordflow}{return} -1;
01011 
01012     \textcolor{comment}{/* create and write .add file */}
01013     strcpy(log->end, \textcolor{stringliteral}{".add"});
01014     fd = open(log->path, O\_WRONLY | O\_CREAT | O\_TRUNC, 0644);
01015     \textcolor{keywordflow}{if} (fd < 0)
01016         \textcolor{keywordflow}{return} -1;
01017     ret = (size\_t)write(fd, data, len) != len;
01018     \textcolor{keywordflow}{if} (ret | close(fd))
01019         \textcolor{keywordflow}{return} -1;
01020     log\_touch(log);
01021 
01022     \textcolor{comment}{/* mark log file with append in progress */}
01023     \textcolor{keywordflow}{if} (log\_mark(log, APPEND\_OP))
01024         \textcolor{keywordflow}{return} -1;
01025     BAIL(8);
01026 
01027     \textcolor{comment}{/* append data (clears mark) */}
01028     \textcolor{keywordflow}{if} (log\_append(log, data, len))
01029         \textcolor{keywordflow}{return} -1;
01030 
01031     \textcolor{comment}{/* check to see if it's time to compress -- if not, then done */}
01032     \textcolor{keywordflow}{if} (((log->last - log->first) >> 10) + (log->stored >> 10) < TRIGGER)
01033         \textcolor{keywordflow}{return} 0;
01034 
01035     \textcolor{comment}{/* time to compress */}
01036     \textcolor{keywordflow}{return} gzlog\_compress(log);
01037 \}
01038 
01039 \textcolor{comment}{/* gzlog\_close() return values:}
01040 \textcolor{comment}{    0: ok}
01041 \textcolor{comment}{   -3: invalid log pointer argument */}
01042 \textcolor{keywordtype}{int} gzlog\_close(gzlog *logd)
01043 \{
01044     \textcolor{keyword}{struct }log *log = logd;
01045 
01046     \textcolor{comment}{/* check arguments */}
01047     \textcolor{keywordflow}{if} (log == NULL || strcmp(log->id, LOGID))
01048         \textcolor{keywordflow}{return} -3;
01049 
01050     \textcolor{comment}{/* close the log file and release the lock */}
01051     log\_close(log);
01052 
01053     \textcolor{comment}{/* free structure and return */}
01054     \textcolor{keywordflow}{if} (log->path != NULL)
01055         free(log->path);
01056     strcpy(log->id, \textcolor{stringliteral}{"bad"});
01057     free(log);
01058     \textcolor{keywordflow}{return} 0;
01059 \}
\end{DoxyCode}
