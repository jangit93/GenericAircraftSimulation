\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_product_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+Core/\+Sparse\+Product.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_product_8h_source}\index{Sparse\+Product.\+h@{Sparse\+Product.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSEPRODUCT\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SPARSEPRODUCT\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00026 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00027 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00028 \textcolor{keyword}{inline} \textcolor{keyword}{const} Product<Derived,OtherDerived,AliasFreeProduct>
00029 SparseMatrixBase<Derived>::operator*(\textcolor{keyword}{const} SparseMatrixBase<OtherDerived> &other)\textcolor{keyword}{ const}
00030 \textcolor{keyword}{}\{
00031   \textcolor{keywordflow}{return} Product<Derived,OtherDerived,AliasFreeProduct>(derived(), other.derived());
00032 \}
00033 
00034 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00035 
00036 \textcolor{comment}{// sparse * sparse}
00037 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductType>
00038 \textcolor{keyword}{struct }generic\_product\_impl<Lhs, Rhs, SparseShape, SparseShape, ProductType>
00039 \{
00040   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00041   \textcolor{keyword}{static} \textcolor{keywordtype}{void} evalTo(Dest& dst, \textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs)
00042   \{
00043     evalTo(dst, lhs, rhs, \textcolor{keyword}{typename} evaluator\_traits<Dest>::Shape());
00044   \}
00045 
00046   \textcolor{comment}{// dense += sparse * sparse}
00047   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest,\textcolor{keyword}{typename} ActualLhs>
00048   \textcolor{keyword}{static} \textcolor{keywordtype}{void} addTo(Dest& dst, \textcolor{keyword}{const} ActualLhs& lhs, \textcolor{keyword}{const} Rhs& rhs, \textcolor{keyword}{typename} enable\_if<is\_same<\textcolor{keyword}{typename} 
      evaluator\_traits<Dest>::Shape,DenseShape>::value,\textcolor{keywordtype}{int}*>::type* = 0)
00049   \{
00050     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} nested\_eval<ActualLhs,Dynamic>::type LhsNested;
00051     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} nested\_eval<Rhs,Dynamic>::type RhsNested;
00052     LhsNested lhsNested(lhs);
00053     RhsNested rhsNested(rhs);
00054     internal::sparse\_sparse\_to\_dense\_product\_selector<typename remove\_all<LhsNested>::type,
00055                                                       \textcolor{keyword}{typename} remove\_all<RhsNested>::type, Dest>::run(
      lhsNested,rhsNested,dst);
00056   \}
00057 
00058   \textcolor{comment}{// dense -= sparse * sparse}
00059   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00060   \textcolor{keyword}{static} \textcolor{keywordtype}{void} subTo(Dest& dst, \textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, \textcolor{keyword}{typename} enable\_if<is\_same<\textcolor{keyword}{typename} 
      evaluator\_traits<Dest>::Shape,DenseShape>::value,\textcolor{keywordtype}{int}*>::type* = 0)
00061   \{
00062     addTo(dst, -lhs, rhs);
00063   \}
00064 
00065 \textcolor{keyword}{protected}:
00066 
00067   \textcolor{comment}{// sparse = sparse * sparse}
00068   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00069   \textcolor{keyword}{static} \textcolor{keywordtype}{void} evalTo(Dest& dst, \textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, SparseShape)
00070   \{
00071     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} nested\_eval<Lhs,Dynamic>::type LhsNested;
00072     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} nested\_eval<Rhs,Dynamic>::type RhsNested;
00073     LhsNested lhsNested(lhs);
00074     RhsNested rhsNested(rhs);
00075     internal::conservative\_sparse\_sparse\_product\_selector<typename remove\_all<LhsNested>::type,
00076                                                           \textcolor{keyword}{typename} remove\_all<RhsNested>::type, Dest>::run(
      lhsNested,rhsNested,dst);
00077   \}
00078 
00079   \textcolor{comment}{// dense = sparse * sparse}
00080   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00081   \textcolor{keyword}{static} \textcolor{keywordtype}{void} evalTo(Dest& dst, \textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, DenseShape)
00082   \{
00083     dst.setZero();
00084     addTo(dst, lhs, rhs);
00085   \}
00086 \};
00087 
00088 \textcolor{comment}{// sparse * sparse-triangular}
00089 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductType>
00090 \textcolor{keyword}{struct }generic\_product\_impl<Lhs, Rhs, SparseShape, SparseTriangularShape, ProductType>
00091  : \textcolor{keyword}{public} generic\_product\_impl<Lhs, Rhs, SparseShape, SparseShape, ProductType>
00092 \{\};
00093 
00094 \textcolor{comment}{// sparse-triangular * sparse}
00095 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductType>
00096 \textcolor{keyword}{struct }generic\_product\_impl<Lhs, Rhs, SparseTriangularShape, SparseShape, ProductType>
00097  : \textcolor{keyword}{public} generic\_product\_impl<Lhs, Rhs, SparseShape, SparseShape, ProductType>
00098 \{\};
00099 
00100 \textcolor{comment}{// dense = sparse-product (can be sparse*sparse, sparse*perm, etc.)}
00101 \textcolor{keyword}{template}< \textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00102 \textcolor{keyword}{struct }Assignment<DstXprType, Product<Lhs,Rhs,AliasFreeProduct>, \hyperlink{namespaceinternal}{internal}::assign\_op<typename DstXp
      rType::Scalar,typename Product<Lhs,Rhs,AliasFreeProduct>::Scalar>, Sparse2Dense>
00103 \{
00104   \textcolor{keyword}{typedef} Product<Lhs,Rhs,AliasFreeProduct> SrcXprType;
00105   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} internal::assign\_op<typename
       DstXprType::Scalar,typename SrcXprType::Scalar> &)
00106   \{
00107     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstRows = src.rows();
00108     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} dstCols = src.cols();
00109     \textcolor{keywordflow}{if}((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
00110       dst.resize(dstRows, dstCols);
00111     
00112     generic\_product\_impl<Lhs, Rhs>::evalTo(dst,src.lhs(),src.rhs());
00113   \}
00114 \};
00115 
00116 \textcolor{comment}{// dense += sparse-product (can be sparse*sparse, sparse*perm, etc.)}
00117 \textcolor{keyword}{template}< \textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00118 \textcolor{keyword}{struct }Assignment<DstXprType, Product<Lhs,Rhs,AliasFreeProduct>, \hyperlink{namespaceinternal}{internal}::add\_assign\_op<typename D
      stXprType::Scalar,typename Product<Lhs,Rhs,AliasFreeProduct>::Scalar>, Sparse2Dense>
00119 \{
00120   \textcolor{keyword}{typedef} Product<Lhs,Rhs,AliasFreeProduct> SrcXprType;
00121   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} internal::add\_assign\_op<typename
       DstXprType::Scalar,typename SrcXprType::Scalar> &)
00122   \{
00123     generic\_product\_impl<Lhs, Rhs>::addTo(dst,src.lhs(),src.rhs());
00124   \}
00125 \};
00126 
00127 \textcolor{comment}{// dense -= sparse-product (can be sparse*sparse, sparse*perm, etc.)}
00128 \textcolor{keyword}{template}< \textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00129 \textcolor{keyword}{struct }Assignment<DstXprType, Product<Lhs,Rhs,AliasFreeProduct>, \hyperlink{namespaceinternal}{internal}::sub\_assign\_op<typename D
      stXprType::Scalar,typename Product<Lhs,Rhs,AliasFreeProduct>::Scalar>, Sparse2Dense>
00130 \{
00131   \textcolor{keyword}{typedef} Product<Lhs,Rhs,AliasFreeProduct> SrcXprType;
00132   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} internal::sub\_assign\_op<typename
       DstXprType::Scalar,typename SrcXprType::Scalar> &)
00133   \{
00134     generic\_product\_impl<Lhs, Rhs>::subTo(dst,src.lhs(),src.rhs());
00135   \}
00136 \};
00137 
00138 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} Options>
00139 \textcolor{keyword}{struct }unary\_evaluator<SparseView<Product<Lhs, Rhs, Options> >, IteratorBased>
00140  : \textcolor{keyword}{public} evaluator<typename Product<Lhs, Rhs, DefaultProduct>::PlainObject>
00141 \{
00142   \textcolor{keyword}{typedef} SparseView<Product<Lhs, Rhs, Options> > XprType;
00143   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::PlainObject PlainObject;
00144   \textcolor{keyword}{typedef} evaluator<PlainObject> Base;
00145 
00146   \textcolor{keyword}{explicit} unary\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00147     : m\_result(xpr.rows(), xpr.cols())
00148   \{
00149     \textcolor{keyword}{using} std::abs;
00150     ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(m\_result);
00151     typedef typename nested\_eval<Lhs,\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}>::type LhsNested;
00152     typedef typename nested\_eval<Rhs,\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}>::type RhsNested;
00153     LhsNested lhsNested(xpr.nestedExpression().lhs());
00154     RhsNested rhsNested(xpr.nestedExpression().rhs());
00155 
00156     \hyperlink{namespaceinternal}{internal}::sparse\_sparse\_product\_with\_pruning\_selector<typename remove\_all<LhsNested>::type,
00157                                                           typename remove\_all<RhsNested>::type, PlainObject
      >::run(lhsNested,rhsNested,m\_result,
00158                                                                                                            
             abs(xpr.reference())*xpr.epsilon());
00159   \}
00160 
00161 protected:
00162   PlainObject m\_result;
00163 \};
00164 
00165 \} \textcolor{comment}{// end namespace internal}
00166 
00167 \} \textcolor{comment}{// end namespace Eigen}
00168 
00169 \textcolor{preprocessor}{#endif // EIGEN\_SPARSEPRODUCT\_H}
\end{DoxyCode}
