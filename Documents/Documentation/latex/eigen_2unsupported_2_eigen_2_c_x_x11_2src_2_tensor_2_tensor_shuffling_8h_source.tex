\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_shuffling_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Shuffling.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_shuffling_8h_source}\index{Tensor\+Shuffling.\+h@{Tensor\+Shuffling.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_SHUFFLING\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_SHUFFLING\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Shuffle, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_shuffling_8h_source_l00024}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_shuffling_op_3_01_shuffle_00_01_xpr_type_01_4_01_4}{00024} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_shuffling_op}{TensorShufflingOp}<Shuffle, XprType> > : \textcolor{keyword}{public} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<XprType>
00025 \{
00026   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00027   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>} \hyperlink{struct_eigen_1_1internal_1_1traits}{XprTraits};
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<Nested>::type} 
      \hyperlink{group___sparse_core___module}{\_Nested};
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00034 \};
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Shuffle, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_shuffling_8h_source_l00037}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_shuffling_op_3_01_shuffle_00_01_xpr_type_01_4_00_01_eigen_1_1_dense_01_4}{00037} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_shuffling_op}{TensorShufflingOp}<Shuffle, XprType>, \hyperlink{namespace_eigen}{Eigen}::
      \hyperlink{struct_eigen_1_1_dense}{Dense}>
00038 \{
00039   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_shuffling_op}{TensorShufflingOp<Shuffle, XprType>}& 
      \hyperlink{class_eigen_1_1_tensor_shuffling_op}{type};
00040 \};
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Shuffle, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_shuffling_8h_source_l00043}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_shuffling_op_3_01_shuffle_00_01_xpr_type_01_4_00_dada54f27507131254ad9331d623790d}{00043} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_shuffling_op}{TensorShufflingOp}<Shuffle, XprType>, 1, typename 
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_shuffling_op}{TensorShufflingOp}<Shuffle, XprType> >::\hyperlink{class_eigen_1_1_tensor_shuffling_op}{type}>
00044 \{
00045   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_shuffling_op}{TensorShufflingOp<Shuffle, XprType>} 
      \hyperlink{class_eigen_1_1_tensor_shuffling_op}{type};
00046 \};
00047 
00048 \}  \textcolor{comment}{// end namespace internal}
00049 
00050 
00051 
00052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Shuffle, \textcolor{keyword}{typename} XprType>
00053 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_shuffling_op}{TensorShufflingOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorShufflingOp<Shuffle, XprType> 
      >
00054 \{
00055   \textcolor{keyword}{public}:
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorShufflingOp>::Scalar}
       Scalar;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorShufflingOp>::type}
       Nested;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorShufflingOp>::StorageKind}
       StorageKind;
00061   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorShufflingOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00062 
00063   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_shuffling_op}{TensorShufflingOp}(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} 
      Shuffle& shuffle)
00064       : m\_xpr(expr), m\_shuffle(shuffle) \{\}
00065 
00066     EIGEN\_DEVICE\_FUNC
00067     \textcolor{keyword}{const} Shuffle& shufflePermutation()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_shuffle; \}
00068 
00069     EIGEN\_DEVICE\_FUNC
00070     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename XprType::Nested>::type}
      &
00071     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00072 
00073     EIGEN\_DEVICE\_FUNC
00074     EIGEN\_STRONG\_INLINE TensorShufflingOp& operator = (\textcolor{keyword}{const} TensorShufflingOp& other)
00075     \{
00076       \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp<TensorShufflingOp, const TensorShufflingOp>}
       Assign;
00077       Assign assign(*\textcolor{keyword}{this}, other);
00078       \hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{internal::TensorExecutor<const Assign, DefaultDevice>::run}
      (assign, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}());
00079       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00080     \}
00081 
00082     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00083     EIGEN\_DEVICE\_FUNC
00084     EIGEN\_STRONG\_INLINE TensorShufflingOp& operator = (\textcolor{keyword}{const} OtherDerived& other)
00085     \{
00086       \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp<TensorShufflingOp, const OtherDerived>}
       Assign;
00087       Assign assign(*\textcolor{keyword}{this}, other);
00088       \hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{internal::TensorExecutor<const Assign, DefaultDevice>::run}
      (assign, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}());
00089       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00090     \}
00091 
00092   \textcolor{keyword}{protected}:
00093     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00094     \textcolor{keyword}{const} Shuffle m\_shuffle;
00095 \};
00096 
00097 
00098 \textcolor{comment}{// Eval as rvalue}
00099 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Shuffle, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_shuffling_8h_source_l00100}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_shuffling_op_3_01_shuffle_00_01_arg_type_01_4_00_01_device_01_4}{00100} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_shuffling_op}{TensorShufflingOp}<Shuffle, ArgType>, Device>
00101 \{
00102   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_shuffling_op}{TensorShufflingOp<Shuffle, ArgType>} 
      \hyperlink{class_eigen_1_1_tensor_shuffling_op}{XprType};
00103   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00104   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<ArgType, Device>::Dimensions}
      >::value;
00105   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumDims>} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00106   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00107   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00108   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00109   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size};
00110 
00111   \textcolor{keyword}{enum} \{
00112     IsAligned = \textcolor{keyword}{false},
00113     PacketAccess = (\hyperlink{struct_eigen_1_1internal_1_1packet__traits}{internal::packet\_traits<Scalar>::size} > 1),
00114     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Layout},
00115     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00116     RawAccess = \textcolor{keyword}{false}
00117   \};
00118 
00119   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00120       : m\_impl(op.expression(), device)
00121   \{
00122     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Dimensions}
      & input\_dims = m\_impl.dimensions();
00123     \textcolor{keyword}{const} Shuffle& shuffle = op.shufflePermutation();
00124     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i) \{
00125       m\_dimensions[i] = input\_dims[shuffle[i]];
00126     \}
00127 
00128     \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} inputStrides;
00129 
00130     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00131       inputStrides[0] = 1;
00132       m\_outputStrides[0] = 1;
00133       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00134         inputStrides[i] = inputStrides[i - 1] * input\_dims[i - 1];
00135         m\_outputStrides[i] = m\_outputStrides[i - 1] * m\_dimensions[i - 1];
00136       \}
00137     \} \textcolor{keywordflow}{else} \{
00138       inputStrides[NumDims - 1] = 1;
00139       m\_outputStrides[NumDims - 1] = 1;
00140       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00141         inputStrides[i] = inputStrides[i + 1] * input\_dims[i + 1];
00142         m\_outputStrides[i] = m\_outputStrides[i + 1] * m\_dimensions[i + 1];
00143       \}
00144     \}
00145 
00146     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i) \{
00147       m\_inputStrides[i] = inputStrides[shuffle[i]];
00148     \}
00149   \}
00150 
00151   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00152 
00153   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/}) \{
00154     m\_impl.evalSubExprsIfNeeded(NULL);
00155     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00156   \}
00157   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00158     m\_impl.cleanup();
00159   \}
00160 
00161   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00162 \textcolor{keyword}{  }\{
00163     \textcolor{keywordflow}{return} m\_impl.coeff(srcCoeff(index));
00164   \}
00165 
00166   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00167   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00168 \textcolor{keyword}{  }\{
00169     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00170     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00171 
00172     EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<CoeffReturnType>::type}
       values[PacketSize];
00173     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00174       values[i] = coeff(index+i);
00175     \}
00176     PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00177     \textcolor{keywordflow}{return} rslt;
00178   \}
00179 
00180   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost} costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00181     \textcolor{keyword}{const} \textcolor{keywordtype}{double} compute\_cost = NumDims * (2 * TensorOpCost::AddCost<Index>() +
00182                                            2 * TensorOpCost::MulCost<Index>() +
00183                                            TensorOpCost::DivCost<Index>());
00184     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) +
00185            \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, compute\_cost, \textcolor{keyword}{false} \textcolor{comment}{/* vectorized */}, PacketSize);
00186   \}
00187 
00188   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00189 
00190  \textcolor{keyword}{protected}:
00191   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index srcCoeff(Index index)\textcolor{keyword}{ const }\{
00192     Index inputIndex = 0;
00193     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00194       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00195         \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00196         inputIndex += idx * m\_inputStrides[i];
00197         index -= idx * m\_outputStrides[i];
00198       \}
00199       \textcolor{keywordflow}{return} inputIndex + index * m\_inputStrides[0];
00200     \} \textcolor{keywordflow}{else} \{
00201       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00202         \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00203         inputIndex += idx * m\_inputStrides[i];
00204         index -= idx * m\_outputStrides[i];
00205       \}
00206       \textcolor{keywordflow}{return} inputIndex + index * m\_inputStrides[NumDims - 1];
00207     \}
00208   \}
00209 
00210   Dimensions m\_dimensions;
00211   \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} m\_outputStrides;
00212   \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} m\_inputStrides;
00213   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} m\_impl;
00214 \};
00215 
00216 
00217 \textcolor{comment}{// Eval as lvalue}
00218 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Shuffle, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_shuffling_8h_source_l00219}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01_tensor_shuffling_op_3_01_shuffle_00_01_arg_type_01_4_00_01_device_01_4}{00219} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<\hyperlink{class_eigen_1_1_tensor_shuffling_op}{TensorShufflingOp}<Shuffle, ArgType>, Device>
00220     : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const TensorShufflingOp<Shuffle, ArgType>, Device>
00221 \{
00222   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<const TensorShufflingOp<Shuffle, ArgType>}
      , Device> \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_shuffling_op_3_01_shuffle_00_01_arg_type_01_4_00_01_device_01_4}{Base};
00223 
00224   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_shuffling_op}{TensorShufflingOp<Shuffle, ArgType>} 
      \hyperlink{class_eigen_1_1_tensor_shuffling_op}{XprType};
00225   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00226   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<ArgType, Device>::Dimensions}
      >::value;
00227   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumDims>} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00228   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00229   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00230   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00231   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size};
00232 
00233   \textcolor{keyword}{enum} \{
00234     IsAligned = \textcolor{keyword}{false},
00235     PacketAccess = (\hyperlink{struct_eigen_1_1internal_1_1packet__traits}{internal::packet\_traits<Scalar>::size} > 1),
00236     RawAccess = \textcolor{keyword}{false}
00237   \};
00238 
00239   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00240       : Base(op, device)
00241   \{ \}
00242 
00243   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType& coeffRef(Index index)
00244   \{
00245     \textcolor{keywordflow}{return} this->m\_impl.coeffRef(this->srcCoeff(index));
00246   \}
00247 
00248   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} StoreMode> EIGEN\_STRONG\_INLINE
00249   \textcolor{keywordtype}{void} writePacket(Index index, \textcolor{keyword}{const} PacketReturnType& x)
00250   \{
00251     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00252 
00253     EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<CoeffReturnType>::type}
       values[PacketSize];
00254     internal::pstore<CoeffReturnType, PacketReturnType>(values, x);
00255     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00256       this->coeffRef(index+i) = values[i];
00257     \}
00258   \}
00259 \};
00260 
00261 
00262 \} \textcolor{comment}{// end namespace Eigen}
00263 
00264 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_SHUFFLING\_H}
\end{DoxyCode}
