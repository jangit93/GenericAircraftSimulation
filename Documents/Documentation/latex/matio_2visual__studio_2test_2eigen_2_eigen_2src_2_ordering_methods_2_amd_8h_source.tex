\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_ordering_methods_2_amd_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Ordering\+Methods/\+Amd.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_ordering_methods_2_amd_8h_source}\index{Amd.\+h@{Amd.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 
00006 \textcolor{comment}{/*}
00007 \textcolor{comment}{}
00008 \textcolor{comment}{NOTE: this routine has been adapted from the CSparse library:}
00009 \textcolor{comment}{}
00010 \textcolor{comment}{Copyright (c) 2006, Timothy A. Davis.}
00011 \textcolor{comment}{http://www.suitesparse.com}
00012 \textcolor{comment}{}
00013 \textcolor{comment}{CSparse is free software; you can redistribute it and/or}
00014 \textcolor{comment}{modify it under the terms of the GNU Lesser General Public}
00015 \textcolor{comment}{License as published by the Free Software Foundation; either}
00016 \textcolor{comment}{version 2.1 of the License, or (at your option) any later version.}
00017 \textcolor{comment}{}
00018 \textcolor{comment}{CSparse is distributed in the hope that it will be useful,}
00019 \textcolor{comment}{but WITHOUT ANY WARRANTY; without even the implied warranty of}
00020 \textcolor{comment}{MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU}
00021 \textcolor{comment}{Lesser General Public License for more details.}
00022 \textcolor{comment}{}
00023 \textcolor{comment}{You should have received a copy of the GNU Lesser General Public}
00024 \textcolor{comment}{License along with this Module; if not, write to the Free Software}
00025 \textcolor{comment}{Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA}
00026 \textcolor{comment}{}
00027 \textcolor{comment}{*/}
00028 
00029 \textcolor{preprocessor}{#include "../Core/util/NonMPL2.h"}
00030 
00031 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSE\_AMD\_H}
00032 \textcolor{preprocessor}{#define EIGEN\_SPARSE\_AMD\_H}
00033 
00034 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00035 
00036 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00037   
00038 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} amd\_flip(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& i) \{ \textcolor{keywordflow}{return} -i-2; \}
00039 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} amd\_unflip(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& i) \{ \textcolor{keywordflow}{return} i<0 ? amd\_flip(i) : i; \}
00040 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T0, \textcolor{keyword}{typename} T1> \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} amd\_marked(\textcolor{keyword}{const} T0* w, \textcolor{keyword}{const} T1& j) \{ \textcolor{keywordflow}{return} w[j]<0; \}
00041 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T0, \textcolor{keyword}{typename} T1> \textcolor{keyword}{inline} \textcolor{keywordtype}{void} amd\_mark(\textcolor{keyword}{const} T0* w, \textcolor{keyword}{const} T1& j) \{ \textcolor{keywordflow}{return} w[j] = amd\_flip(
      w[j]); \}
00042 
00043 \textcolor{comment}{/* clear w */}
00044 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StorageIndex>
00045 \textcolor{keyword}{static} StorageIndex cs\_wclear (StorageIndex mark, StorageIndex lemax, StorageIndex *w, StorageIndex n)
00046 \{
00047   StorageIndex k;
00048   \textcolor{keywordflow}{if}(mark < 2 || (mark + lemax < 0))
00049   \{
00050     \textcolor{keywordflow}{for}(k = 0; k < n; k++)
00051       \textcolor{keywordflow}{if}(w[k] != 0)
00052         w[k] = 1;
00053     mark = 2;
00054   \}
00055   \textcolor{keywordflow}{return} (mark);     \textcolor{comment}{/* at this point, w[0..n-1] < mark holds */}
00056 \}
00057 
00058 \textcolor{comment}{/* depth-first search and postorder of a tree rooted at node j */}
00059 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StorageIndex>
00060 StorageIndex cs\_tdfs(StorageIndex j, StorageIndex k, StorageIndex *head, \textcolor{keyword}{const} StorageIndex *next, 
      StorageIndex *post, StorageIndex *stack)
00061 \{
00062   StorageIndex i, p, top = 0;
00063   \textcolor{keywordflow}{if}(!head || !next || !post || !stack) \textcolor{keywordflow}{return} (-1);    \textcolor{comment}{/* check inputs */}
00064   stack[0] = j;                 \textcolor{comment}{/* place j on the stack */}
00065   \textcolor{keywordflow}{while} (top >= 0)                \textcolor{comment}{/* while (stack is not empty) */}
00066   \{
00067     p = stack[top];           \textcolor{comment}{/* p = top of stack */}
00068     i = head[p];              \textcolor{comment}{/* i = youngest child of p */}
00069     \textcolor{keywordflow}{if}(i == -1)
00070     \{
00071       top--;                 \textcolor{comment}{/* p has no unordered children left */}
00072       post[k++] = p;        \textcolor{comment}{/* node p is the kth postordered node */}
00073     \}
00074     \textcolor{keywordflow}{else}
00075     \{
00076       head[p] = next[i];   \textcolor{comment}{/* remove i from children of p */}
00077       stack[++top] = i;     \textcolor{comment}{/* start dfs on child node i */}
00078     \}
00079   \}
00080   \textcolor{keywordflow}{return} k;
00081 \}
00082 
00083 
00093 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} StorageIndex>
00094 \textcolor{keywordtype}{void} minimum\_degree\_ordering(SparseMatrix<Scalar,ColMajor,StorageIndex>& C, 
      PermutationMatrix<Dynamic,Dynamic,StorageIndex>& perm)
00095 \{
00096   \textcolor{keyword}{using} std::sqrt;
00097   
00098   StorageIndex d, dk, dext, lemax = 0, e, elenk, eln, i, j, k, k1,
00099                 k2, k3, jlast, ln, dense, nzmax, mindeg = 0, nvi, nvj, nvk, mark, wnvi,
00100                 ok, nel = 0, p, p1, p2, p3, p4, pj, pk, pk1, pk2, pn, q, t, h;
00101   
00102   StorageIndex n = StorageIndex(C.cols());
00103   dense = std::max<StorageIndex> (16, StorageIndex(10 * sqrt(\textcolor{keywordtype}{double}(n))));   \textcolor{comment}{/* find dense threshold */}
00104   dense = (std::min)(n-2, dense);
00105   
00106   StorageIndex cnz = StorageIndex(C.nonZeros());
00107   perm.resize(n+1);
00108   t = cnz + cnz/5 + 2*n;                 \textcolor{comment}{/* add elbow room to C */}
00109   C.resizeNonZeros(t);
00110   
00111   \textcolor{comment}{// get workspace}
00112   ei\_declare\_aligned\_stack\_constructed\_variable(StorageIndex,W,8*(n+1),0);
00113   StorageIndex* len     = W;
00114   StorageIndex* nv      = W +   (n+1);
00115   StorageIndex* next    = W + 2*(n+1);
00116   StorageIndex* head    = W + 3*(n+1);
00117   StorageIndex* elen    = W + 4*(n+1);
00118   StorageIndex* degree  = W + 5*(n+1);
00119   StorageIndex* w       = W + 6*(n+1);
00120   StorageIndex* hhead   = W + 7*(n+1);
00121   StorageIndex* last    = perm.indices().data();                              \textcolor{comment}{/* use P as workspace for
       last */}
00122   
00123   \textcolor{comment}{/* --- Initialize quotient graph ---------------------------------------- */}
00124   StorageIndex* Cp = C.outerIndexPtr();
00125   StorageIndex* Ci = C.innerIndexPtr();
00126   \textcolor{keywordflow}{for}(k = 0; k < n; k++)
00127     len[k] = Cp[k+1] - Cp[k];
00128   len[n] = 0;
00129   nzmax = t;
00130   
00131   \textcolor{keywordflow}{for}(i = 0; i <= n; i++)
00132   \{
00133     head[i]   = -1;                     \textcolor{comment}{// degree list i is empty}
00134     last[i]   = -1;
00135     next[i]   = -1;
00136     hhead[i]  = -1;                     \textcolor{comment}{// hash list i is empty }
00137     nv[i]     = 1;                      \textcolor{comment}{// node i is just one node}
00138     w[i]      = 1;                      \textcolor{comment}{// node i is alive}
00139     elen[i]   = 0;                      \textcolor{comment}{// Ek of node i is empty}
00140     degree[i] = len[i];                 \textcolor{comment}{// degree of node i}
00141   \}
00142   mark = internal::cs\_wclear<StorageIndex>(0, 0, w, n);         \textcolor{comment}{/* clear w */}
00143   
00144   \textcolor{comment}{/* --- Initialize degree lists ------------------------------------------ */}
00145   \textcolor{keywordflow}{for}(i = 0; i < n; i++)
00146   \{
00147     \textcolor{keywordtype}{bool} has\_diag = \textcolor{keyword}{false};
00148     \textcolor{keywordflow}{for}(p = Cp[i]; p<Cp[i+1]; ++p)
00149       \textcolor{keywordflow}{if}(Ci[p]==i)
00150       \{
00151         has\_diag = \textcolor{keyword}{true};
00152         \textcolor{keywordflow}{break};
00153       \}
00154    
00155     d = degree[i];
00156     \textcolor{keywordflow}{if}(d == 1 && has\_diag)           \textcolor{comment}{/* node i is empty */}
00157     \{
00158       elen[i] = -2;                 \textcolor{comment}{/* element i is dead */}
00159       nel++;
00160       Cp[i] = -1;                   \textcolor{comment}{/* i is a root of assembly tree */}
00161       w[i] = 0;
00162     \}
00163     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(d > dense || !has\_diag)  \textcolor{comment}{/* node i is dense or has no structural diagonal element */}
00164     \{
00165       nv[i] = 0;                    \textcolor{comment}{/* absorb i into element n */}
00166       elen[i] = -1;                 \textcolor{comment}{/* node i is dead */}
00167       nel++;
00168       Cp[i] = amd\_flip (n);
00169       nv[n]++;
00170     \}
00171     \textcolor{keywordflow}{else}
00172     \{
00173       \textcolor{keywordflow}{if}(head[d] != -1) last[head[d]] = i;
00174       next[i] = head[d];           \textcolor{comment}{/* put node i in degree list d */}
00175       head[d] = i;
00176     \}
00177   \}
00178   
00179   elen[n] = -2;                         \textcolor{comment}{/* n is a dead element */}
00180   Cp[n] = -1;                           \textcolor{comment}{/* n is a root of assembly tree */}
00181   w[n] = 0;                             \textcolor{comment}{/* n is a dead element */}
00182   
00183   \textcolor{keywordflow}{while} (nel < n)                         \textcolor{comment}{/* while (selecting pivots) do */}
00184   \{
00185     \textcolor{comment}{/* --- Select node of minimum approximate degree -------------------- */}
00186     \textcolor{keywordflow}{for}(k = -1; mindeg < n && (k = head[mindeg]) == -1; mindeg++) \{\}
00187     \textcolor{keywordflow}{if}(next[k] != -1) last[next[k]] = -1;
00188     head[mindeg] = next[k];          \textcolor{comment}{/* remove k from degree list */}
00189     elenk = elen[k];                  \textcolor{comment}{/* elenk = |Ek| */}
00190     nvk = nv[k];                      \textcolor{comment}{/* # of nodes k represents */}
00191     nel += nvk;                        \textcolor{comment}{/* nv[k] nodes of A eliminated */}
00192     
00193     \textcolor{comment}{/* --- Garbage collection ------------------------------------------- */}
00194     \textcolor{keywordflow}{if}(elenk > 0 && cnz + mindeg >= nzmax)
00195     \{
00196       \textcolor{keywordflow}{for}(j = 0; j < n; j++)
00197       \{
00198         \textcolor{keywordflow}{if}((p = Cp[j]) >= 0)      \textcolor{comment}{/* j is a live node or element */}
00199         \{
00200           Cp[j] = Ci[p];          \textcolor{comment}{/* save first entry of object */}
00201           Ci[p] = amd\_flip (j);    \textcolor{comment}{/* first entry is now amd\_flip(j) */}
00202         \}
00203       \}
00204       \textcolor{keywordflow}{for}(q = 0, p = 0; p < cnz; ) \textcolor{comment}{/* scan all of memory */}
00205       \{
00206         \textcolor{keywordflow}{if}((j = amd\_flip (Ci[p++])) >= 0)  \textcolor{comment}{/* found object j */}
00207         \{
00208           Ci[q] = Cp[j];       \textcolor{comment}{/* restore first entry of object */}
00209           Cp[j] = q++;          \textcolor{comment}{/* new pointer to object j */}
00210           \textcolor{keywordflow}{for}(k3 = 0; k3 < len[j]-1; k3++) Ci[q++] = Ci[p++];
00211         \}
00212       \}
00213       cnz = q;                       \textcolor{comment}{/* Ci[cnz...nzmax-1] now free */}
00214     \}
00215     
00216     \textcolor{comment}{/* --- Construct new element ---------------------------------------- */}
00217     dk = 0;
00218     nv[k] = -nvk;                     \textcolor{comment}{/* flag k as in Lk */}
00219     p = Cp[k];
00220     pk1 = (elenk == 0) ? p : cnz;      \textcolor{comment}{/* do in place if elen[k] == 0 */}
00221     pk2 = pk1;
00222     \textcolor{keywordflow}{for}(k1 = 1; k1 <= elenk + 1; k1++)
00223     \{
00224       \textcolor{keywordflow}{if}(k1 > elenk)
00225       \{
00226         e = k;                     \textcolor{comment}{/* search the nodes in k */}
00227         pj = p;                    \textcolor{comment}{/* list of nodes starts at Ci[pj]*/}
00228         ln = len[k] - elenk;      \textcolor{comment}{/* length of list of nodes in k */}
00229       \}
00230       \textcolor{keywordflow}{else}
00231       \{
00232         e = Ci[p++];              \textcolor{comment}{/* search the nodes in e */}
00233         pj = Cp[e];
00234         ln = len[e];              \textcolor{comment}{/* length of list of nodes in e */}
00235       \}
00236       \textcolor{keywordflow}{for}(k2 = 1; k2 <= ln; k2++)
00237       \{
00238         i = Ci[pj++];
00239         \textcolor{keywordflow}{if}((nvi = nv[i]) <= 0) \textcolor{keywordflow}{continue}; \textcolor{comment}{/* node i dead, or seen */}
00240         dk += nvi;                 \textcolor{comment}{/* degree[Lk] += size of node i */}
00241         nv[i] = -nvi;             \textcolor{comment}{/* negate nv[i] to denote i in Lk*/}
00242         Ci[pk2++] = i;            \textcolor{comment}{/* place i in Lk */}
00243         \textcolor{keywordflow}{if}(next[i] != -1) last[next[i]] = last[i];
00244         \textcolor{keywordflow}{if}(last[i] != -1)         \textcolor{comment}{/* remove i from degree list */}
00245         \{
00246           next[last[i]] = next[i];
00247         \}
00248         \textcolor{keywordflow}{else}
00249         \{
00250           head[degree[i]] = next[i];
00251         \}
00252       \}
00253       \textcolor{keywordflow}{if}(e != k)
00254       \{
00255         Cp[e] = amd\_flip (k);      \textcolor{comment}{/* absorb e into k */}
00256         w[e] = 0;                 \textcolor{comment}{/* e is now a dead element */}
00257       \}
00258     \}
00259     \textcolor{keywordflow}{if}(elenk != 0) cnz = pk2;         \textcolor{comment}{/* Ci[cnz...nzmax] is free */}
00260     degree[k] = dk;                   \textcolor{comment}{/* external degree of k - |Lk\(\backslash\)i| */}
00261     Cp[k] = pk1;                      \textcolor{comment}{/* element k is in Ci[pk1..pk2-1] */}
00262     len[k] = pk2 - pk1;
00263     elen[k] = -2;                     \textcolor{comment}{/* k is now an element */}
00264     
00265     \textcolor{comment}{/* --- Find set differences ----------------------------------------- */}
00266     mark = internal::cs\_wclear<StorageIndex>(mark, lemax, w, n);  \textcolor{comment}{/* clear w if necessary */}
00267     \textcolor{keywordflow}{for}(pk = pk1; pk < pk2; pk++)    \textcolor{comment}{/* scan 1: find |Le\(\backslash\)Lk| */}
00268     \{
00269       i = Ci[pk];
00270       \textcolor{keywordflow}{if}((eln = elen[i]) <= 0) \textcolor{keywordflow}{continue};\textcolor{comment}{/* skip if elen[i] empty */}
00271       nvi = -nv[i];                      \textcolor{comment}{/* nv[i] was negated */}
00272       wnvi = mark - nvi;
00273       \textcolor{keywordflow}{for}(p = Cp[i]; p <= Cp[i] + eln - 1; p++)  \textcolor{comment}{/* scan Ei */}
00274       \{
00275         e = Ci[p];
00276         \textcolor{keywordflow}{if}(w[e] >= mark)
00277         \{
00278           w[e] -= nvi;          \textcolor{comment}{/* decrement |Le\(\backslash\)Lk| */}
00279         \}
00280         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(w[e] != 0)        \textcolor{comment}{/* ensure e is a live element */}
00281         \{
00282           w[e] = degree[e] + wnvi; \textcolor{comment}{/* 1st time e seen in scan 1 */}
00283         \}
00284       \}
00285     \}
00286     
00287     \textcolor{comment}{/* --- Degree update ------------------------------------------------ */}
00288     \textcolor{keywordflow}{for}(pk = pk1; pk < pk2; pk++)    \textcolor{comment}{/* scan2: degree update */}
00289     \{
00290       i = Ci[pk];                   \textcolor{comment}{/* consider node i in Lk */}
00291       p1 = Cp[i];
00292       p2 = p1 + elen[i] - 1;
00293       pn = p1;
00294       \textcolor{keywordflow}{for}(h = 0, d = 0, p = p1; p <= p2; p++)    \textcolor{comment}{/* scan Ei */}
00295       \{
00296         e = Ci[p];
00297         \textcolor{keywordflow}{if}(w[e] != 0)             \textcolor{comment}{/* e is an unabsorbed element */}
00298         \{
00299           dext = w[e] - mark;   \textcolor{comment}{/* dext = |Le\(\backslash\)Lk| */}
00300           \textcolor{keywordflow}{if}(dext > 0)
00301           \{
00302             d += dext;         \textcolor{comment}{/* sum up the set differences */}
00303             Ci[pn++] = e;     \textcolor{comment}{/* keep e in Ei */}
00304             h += e;            \textcolor{comment}{/* compute the hash of node i */}
00305           \}
00306           \textcolor{keywordflow}{else}
00307           \{
00308             Cp[e] = amd\_flip (k);  \textcolor{comment}{/* aggressive absorb. e->k */}
00309             w[e] = 0;             \textcolor{comment}{/* e is a dead element */}
00310           \}
00311         \}
00312       \}
00313       elen[i] = pn - p1 + 1;        \textcolor{comment}{/* elen[i] = |Ei| */}
00314       p3 = pn;
00315       p4 = p1 + len[i];
00316       \textcolor{keywordflow}{for}(p = p2 + 1; p < p4; p++) \textcolor{comment}{/* prune edges in Ai */}
00317       \{
00318         j = Ci[p];
00319         \textcolor{keywordflow}{if}((nvj = nv[j]) <= 0) \textcolor{keywordflow}{continue}; \textcolor{comment}{/* node j dead or in Lk */}
00320         d += nvj;                  \textcolor{comment}{/* degree(i) += |j| */}
00321         Ci[pn++] = j;             \textcolor{comment}{/* place j in node list of i */}
00322         h += j;                    \textcolor{comment}{/* compute hash for node i */}
00323       \}
00324       \textcolor{keywordflow}{if}(d == 0)                     \textcolor{comment}{/* check for mass elimination */}
00325       \{
00326         Cp[i] = amd\_flip (k);      \textcolor{comment}{/* absorb i into k */}
00327         nvi = -nv[i];
00328         dk -= nvi;                 \textcolor{comment}{/* |Lk| -= |i| */}
00329         nvk += nvi;                \textcolor{comment}{/* |k| += nv[i] */}
00330         nel += nvi;
00331         nv[i] = 0;
00332         elen[i] = -1;             \textcolor{comment}{/* node i is dead */}
00333       \}
00334       \textcolor{keywordflow}{else}
00335       \{
00336         degree[i] = std::min<StorageIndex> (degree[i], d);   \textcolor{comment}{/* update degree(i) */}
00337         Ci[pn] = Ci[p3];         \textcolor{comment}{/* move first node to end */}
00338         Ci[p3] = Ci[p1];         \textcolor{comment}{/* move 1st el. to end of Ei */}
00339         Ci[p1] = k;               \textcolor{comment}{/* add k as 1st element in of Ei */}
00340         len[i] = pn - p1 + 1;     \textcolor{comment}{/* new len of adj. list of node i */}
00341         h %= n;                    \textcolor{comment}{/* finalize hash of i */}
00342         next[i] = hhead[h];      \textcolor{comment}{/* place i in hash bucket */}
00343         hhead[h] = i;
00344         last[i] = h;      \textcolor{comment}{/* save hash of i in last[i] */}
00345       \}
00346     \}                                   \textcolor{comment}{/* scan2 is done */}
00347     degree[k] = dk;                   \textcolor{comment}{/* finalize |Lk| */}
00348     lemax = std::max<StorageIndex>(lemax, dk);
00349     mark = internal::cs\_wclear<StorageIndex>(mark+lemax, lemax, w, n);    \textcolor{comment}{/* clear w */}
00350     
00351     \textcolor{comment}{/* --- Supernode detection ------------------------------------------ */}
00352     \textcolor{keywordflow}{for}(pk = pk1; pk < pk2; pk++)
00353     \{
00354       i = Ci[pk];
00355       \textcolor{keywordflow}{if}(nv[i] >= 0) \textcolor{keywordflow}{continue};         \textcolor{comment}{/* skip if i is dead */}
00356       h = last[i];                      \textcolor{comment}{/* scan hash bucket of node i */}
00357       i = hhead[h];
00358       hhead[h] = -1;                    \textcolor{comment}{/* hash bucket will be empty */}
00359       \textcolor{keywordflow}{for}(; i != -1 && next[i] != -1; i = next[i], mark++)
00360       \{
00361         ln = len[i];
00362         eln = elen[i];
00363         \textcolor{keywordflow}{for}(p = Cp[i]+1; p <= Cp[i] + ln-1; p++) w[Ci[p]] = mark;
00364         jlast = i;
00365         \textcolor{keywordflow}{for}(j = next[i]; j != -1; ) \textcolor{comment}{/* compare i with all j */}
00366         \{
00367           ok = (len[j] == ln) && (elen[j] == eln);
00368           \textcolor{keywordflow}{for}(p = Cp[j] + 1; ok && p <= Cp[j] + ln - 1; p++)
00369           \{
00370             \textcolor{keywordflow}{if}(w[Ci[p]] != mark) ok = 0;    \textcolor{comment}{/* compare i and j*/}
00371           \}
00372           \textcolor{keywordflow}{if}(ok)                     \textcolor{comment}{/* i and j are identical */}
00373           \{
00374             Cp[j] = amd\_flip (i);  \textcolor{comment}{/* absorb j into i */}
00375             nv[i] += nv[j];
00376             nv[j] = 0;
00377             elen[j] = -1;         \textcolor{comment}{/* node j is dead */}
00378             j = next[j];          \textcolor{comment}{/* delete j from hash bucket */}
00379             next[jlast] = j;
00380           \}
00381           \textcolor{keywordflow}{else}
00382           \{
00383             jlast = j;             \textcolor{comment}{/* j and i are different */}
00384             j = next[j];
00385           \}
00386         \}
00387       \}
00388     \}
00389     
00390     \textcolor{comment}{/* --- Finalize new element------------------------------------------ */}
00391     \textcolor{keywordflow}{for}(p = pk1, pk = pk1; pk < pk2; pk++)   \textcolor{comment}{/* finalize Lk */}
00392     \{
00393       i = Ci[pk];
00394       \textcolor{keywordflow}{if}((nvi = -nv[i]) <= 0) \textcolor{keywordflow}{continue};\textcolor{comment}{/* skip if i is dead */}
00395       nv[i] = nvi;                      \textcolor{comment}{/* restore nv[i] */}
00396       d = degree[i] + dk - nvi;         \textcolor{comment}{/* compute external degree(i) */}
00397       d = std::min<StorageIndex> (d, n - nel - nvi);
00398       \textcolor{keywordflow}{if}(head[d] != -1) last[head[d]] = i;
00399       next[i] = head[d];               \textcolor{comment}{/* put i back in degree list */}
00400       last[i] = -1;
00401       head[d] = i;
00402       mindeg = std::min<StorageIndex> (mindeg, d);       \textcolor{comment}{/* find new minimum degree */}
00403       degree[i] = d;
00404       Ci[p++] = i;                      \textcolor{comment}{/* place i in Lk */}
00405     \}
00406     nv[k] = nvk;                      \textcolor{comment}{/* # nodes absorbed into k */}
00407     \textcolor{keywordflow}{if}((len[k] = p-pk1) == 0)         \textcolor{comment}{/* length of adj list of element k*/}
00408     \{
00409       Cp[k] = -1;                   \textcolor{comment}{/* k is a root of the tree */}
00410       w[k] = 0;                     \textcolor{comment}{/* k is now a dead element */}
00411     \}
00412     \textcolor{keywordflow}{if}(elenk != 0) cnz = p;           \textcolor{comment}{/* free unused space in Lk */}
00413   \}
00414   
00415   \textcolor{comment}{/* --- Postordering ----------------------------------------------------- */}
00416   \textcolor{keywordflow}{for}(i = 0; i < n; i++) Cp[i] = amd\_flip (Cp[i]);\textcolor{comment}{/* fix assembly tree */}
00417   \textcolor{keywordflow}{for}(j = 0; j <= n; j++) head[j] = -1;
00418   \textcolor{keywordflow}{for}(j = n; j >= 0; j--)              \textcolor{comment}{/* place unordered nodes in lists */}
00419   \{
00420     \textcolor{keywordflow}{if}(nv[j] > 0) \textcolor{keywordflow}{continue};          \textcolor{comment}{/* skip if j is an element */}
00421     next[j] = head[Cp[j]];          \textcolor{comment}{/* place j in list of its parent */}
00422     head[Cp[j]] = j;
00423   \}
00424   \textcolor{keywordflow}{for}(e = n; e >= 0; e--)              \textcolor{comment}{/* place elements in lists */}
00425   \{
00426     \textcolor{keywordflow}{if}(nv[e] <= 0) \textcolor{keywordflow}{continue};         \textcolor{comment}{/* skip unless e is an element */}
00427     \textcolor{keywordflow}{if}(Cp[e] != -1)
00428     \{
00429       next[e] = head[Cp[e]];      \textcolor{comment}{/* place e in list of its parent */}
00430       head[Cp[e]] = e;
00431     \}
00432   \}
00433   \textcolor{keywordflow}{for}(k = 0, i = 0; i <= n; i++)       \textcolor{comment}{/* postorder the assembly tree */}
00434   \{
00435     \textcolor{keywordflow}{if}(Cp[i] == -1) k = internal::cs\_tdfs<StorageIndex>(i, k, head, next, perm.indices().data(), w);
00436   \}
00437   
00438   perm.indices().conservativeResize(n);
00439 \}
00440 
00441 \} \textcolor{comment}{// namespace internal}
00442 
00443 \} \textcolor{comment}{// end namespace Eigen}
00444 
00445 \textcolor{preprocessor}{#endif // EIGEN\_SPARSE\_AMD\_H}
\end{DoxyCode}
