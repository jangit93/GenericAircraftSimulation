\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_image_patch_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Image\+Patch.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_image_patch_8h_source}\index{Tensor\+Image\+Patch.\+h@{Tensor\+Image\+Patch.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_IMAGE\_PATCH\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_IMAGE\_PATCH\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00029 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00030 \textcolor{keyword}{template}<DenseIndex Rows, DenseIndex Cols, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_image_patch_8h_source_l00031}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_image_patch_op_3_01_rows_00_01_cols_00_01_xpr_type_01_4_01_4}{00031} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_image_patch_op}{TensorImagePatchOp}<Rows, Cols, XprType> > : \textcolor{keyword}{public} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<XprType>
00032 \{
00033   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<typename XprType::Scalar>::type}
       \hyperlink{group___sparse_core___module}{Scalar};
00034   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>} \hyperlink{struct_eigen_1_1internal_1_1traits}{XprTraits};
00035   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00036   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00037   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00038   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<Nested>::type} 
      \hyperlink{group___sparse_core___module}{\_Nested};
00039   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions + 1;
00040   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00041 \};
00042 
00043 \textcolor{keyword}{template}<DenseIndex Rows, DenseIndex Cols, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_image_patch_8h_source_l00044}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_image_patch_op_3_01_rows_00_01_cols_00_01_xpr_type_01_4_00_01_eigen_1_1_dense_01_4}{00044} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_image_patch_op}{TensorImagePatchOp}<Rows, Cols, XprType>, \hyperlink{namespace_eigen}{Eigen}::
      \hyperlink{struct_eigen_1_1_dense}{Dense}>
00045 \{
00046   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_image_patch_op}{TensorImagePatchOp<Rows, Cols, XprType>}& 
      \hyperlink{class_eigen_1_1_tensor_image_patch_op}{type};
00047 \};
00048 
00049 \textcolor{keyword}{template}<DenseIndex Rows, DenseIndex Cols, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_image_patch_8h_source_l00050}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_image_patch_op_3_01_rows_00_01_cols_00_01_xpr_typbdbaf7e5a7b5b77870e0e3f45395b2a8}{00050} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_image_patch_op}{TensorImagePatchOp}<Rows, Cols, XprType>, 1, typename 
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_image_patch_op}{TensorImagePatchOp}<Rows, Cols, XprType> >::\hyperlink{class_eigen_1_1_tensor_image_patch_op}{type}>
00051 \{
00052   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_image_patch_op}{TensorImagePatchOp<Rows, Cols, XprType>} 
      \hyperlink{class_eigen_1_1_tensor_image_patch_op}{type};
00053 \};
00054 
00055 \}  \textcolor{comment}{// end namespace internal}
00056 
00057 \textcolor{keyword}{template}<DenseIndex Rows, DenseIndex Cols, \textcolor{keyword}{typename} XprType>
00058 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_image_patch_op}{TensorImagePatchOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorImagePatchOp<Rows, Cols, Xpr
      Type>, ReadOnlyAccessors>
00059 \{
00060   \textcolor{keyword}{public}:
00061   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorImagePatchOp>::Scalar}
       Scalar;
00062   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00063   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00064   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorImagePatchOp>::type}
       Nested;
00065   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorImagePatchOp>::StorageKind}
       StorageKind;
00066   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorImagePatchOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00067 
00068   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_image_patch_op}{TensorImagePatchOp}(\textcolor{keyword}{const} XprType& expr, 
      DenseIndex patch\_rows, DenseIndex patch\_cols,
00069                                                            DenseIndex row\_strides, DenseIndex col\_strides,
00070                                                            DenseIndex in\_row\_strides, DenseIndex 
      in\_col\_strides,
00071                                                            DenseIndex row\_inflate\_strides, DenseIndex 
      col\_inflate\_strides,
00072                                                            PaddingType padding\_type, Scalar padding\_value)
00073       : m\_xpr(expr), m\_patch\_rows(patch\_rows), m\_patch\_cols(patch\_cols),
00074         m\_row\_strides(row\_strides), m\_col\_strides(col\_strides),
00075         m\_in\_row\_strides(in\_row\_strides), m\_in\_col\_strides(in\_col\_strides),
00076         m\_row\_inflate\_strides(row\_inflate\_strides), m\_col\_inflate\_strides(col\_inflate\_strides),
00077         m\_padding\_explicit(\textcolor{keyword}{false}), m\_padding\_top(0), m\_padding\_bottom(0), m\_padding\_left(0), 
      m\_padding\_right(0),
00078         m\_padding\_type(padding\_type), m\_padding\_value(padding\_value) \{\}
00079 
00080   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorImagePatchOp(\textcolor{keyword}{const} XprType& expr, DenseIndex patch\_rows, 
      DenseIndex patch\_cols,
00081                                                            DenseIndex row\_strides, DenseIndex col\_strides,
00082                                                            DenseIndex in\_row\_strides, DenseIndex 
      in\_col\_strides,
00083                                                            DenseIndex row\_inflate\_strides, DenseIndex 
      col\_inflate\_strides,
00084                                                            DenseIndex padding\_top, DenseIndex 
      padding\_bottom,
00085                                                            DenseIndex padding\_left, DenseIndex 
      padding\_right,
00086                                                            Scalar padding\_value)
00087       : m\_xpr(expr), m\_patch\_rows(patch\_rows), m\_patch\_cols(patch\_cols),
00088         m\_row\_strides(row\_strides), m\_col\_strides(col\_strides),
00089         m\_in\_row\_strides(in\_row\_strides), m\_in\_col\_strides(in\_col\_strides),
00090         m\_row\_inflate\_strides(row\_inflate\_strides), m\_col\_inflate\_strides(col\_inflate\_strides),
00091         m\_padding\_explicit(\textcolor{keyword}{true}), m\_padding\_top(padding\_top), m\_padding\_bottom(padding\_bottom),
00092         m\_padding\_left(padding\_left), m\_padding\_right(padding\_right),
00093         m\_padding\_type(PADDING\_VALID), m\_padding\_value(padding\_value) \{\}
00094 
00095     EIGEN\_DEVICE\_FUNC
00096     DenseIndex patch\_rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_patch\_rows; \}
00097     EIGEN\_DEVICE\_FUNC
00098     DenseIndex patch\_cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_patch\_cols; \}
00099     EIGEN\_DEVICE\_FUNC
00100     DenseIndex row\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_row\_strides; \}
00101     EIGEN\_DEVICE\_FUNC
00102     DenseIndex col\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_col\_strides; \}
00103     EIGEN\_DEVICE\_FUNC
00104     DenseIndex in\_row\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_in\_row\_strides; \}
00105     EIGEN\_DEVICE\_FUNC
00106     DenseIndex in\_col\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_in\_col\_strides; \}
00107     EIGEN\_DEVICE\_FUNC
00108     DenseIndex row\_inflate\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_row\_inflate\_strides; \}
00109     EIGEN\_DEVICE\_FUNC
00110     DenseIndex col\_inflate\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_col\_inflate\_strides; \}
00111     EIGEN\_DEVICE\_FUNC
00112     \textcolor{keywordtype}{bool} padding\_explicit()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_explicit; \}
00113     EIGEN\_DEVICE\_FUNC
00114     DenseIndex padding\_top()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_top; \}
00115     EIGEN\_DEVICE\_FUNC
00116     DenseIndex padding\_bottom()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_bottom; \}
00117     EIGEN\_DEVICE\_FUNC
00118     DenseIndex padding\_left()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_left; \}
00119     EIGEN\_DEVICE\_FUNC
00120     DenseIndex padding\_right()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_right; \}
00121     EIGEN\_DEVICE\_FUNC
00122     PaddingType padding\_type()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_type; \}
00123     EIGEN\_DEVICE\_FUNC
00124     Scalar padding\_value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_value; \}
00125 
00126     EIGEN\_DEVICE\_FUNC
00127     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename XprType::Nested>::type}
      &
00128     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00129 
00130   \textcolor{keyword}{protected}:
00131     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00132     \textcolor{keyword}{const} DenseIndex m\_patch\_rows;
00133     \textcolor{keyword}{const} DenseIndex m\_patch\_cols;
00134     \textcolor{keyword}{const} DenseIndex m\_row\_strides;
00135     \textcolor{keyword}{const} DenseIndex m\_col\_strides;
00136     \textcolor{keyword}{const} DenseIndex m\_in\_row\_strides;
00137     \textcolor{keyword}{const} DenseIndex m\_in\_col\_strides;
00138     \textcolor{keyword}{const} DenseIndex m\_row\_inflate\_strides;
00139     \textcolor{keyword}{const} DenseIndex m\_col\_inflate\_strides;
00140     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} m\_padding\_explicit;
00141     \textcolor{keyword}{const} DenseIndex m\_padding\_top;
00142     \textcolor{keyword}{const} DenseIndex m\_padding\_bottom;
00143     \textcolor{keyword}{const} DenseIndex m\_padding\_left;
00144     \textcolor{keyword}{const} DenseIndex m\_padding\_right;
00145     \textcolor{keyword}{const} PaddingType m\_padding\_type;
00146     \textcolor{keyword}{const} Scalar m\_padding\_value;
00147 \};
00148 
00149 \textcolor{comment}{// Eval as rvalue}
00150 \textcolor{keyword}{template}<DenseIndex Rows, DenseIndex Cols, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_image_patch_8h_source_l00151}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_image_patch_op_3_01_rows_00_01_cols_00_01_arg_type_01_4_00_01_device_01_4}{00151} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_image_patch_op}{TensorImagePatchOp}<Rows, Cols, ArgType>, 
      Device>
00152 \{
00153   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_image_patch_op}{TensorImagePatchOp<Rows, Cols, ArgType>} 
      \hyperlink{class_eigen_1_1_tensor_image_patch_op}{XprType};
00154   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00155   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumInputDims = 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<ArgType, Device>::Dimensions}
      >::value;
00156   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = NumInputDims + 1;
00157   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumDims>} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00158   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<typename XprType::Scalar>::type}
       \hyperlink{group___sparse_core___module}{Scalar};
00159   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<const TensorImagePatchOp<Rows, Cols, ArgType>}
      ,
00160                           Device> \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_image_patch_op_3_01_rows_00_01_cols_00_01_arg_type_01_4_00_01_device_01_4}{Self};
00161   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} \hyperlink{struct_eigen_1_1_tensor_evaluator}{Impl};
00162   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00163   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00164   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size};
00165 
00166   \textcolor{keyword}{enum} \{
00167     IsAligned = \textcolor{keyword}{false},
00168     PacketAccess = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::PacketAccess}
      ,
00169     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Layout},
00170     CoordAccess = \textcolor{keyword}{false},
00171     RawAccess = \textcolor{keyword}{false}
00172   \};
00173 
00174   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00175       : m\_impl(op.expression(), device)
00176   \{
00177     EIGEN\_STATIC\_ASSERT((NumDims >= 4), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00178 
00179     m\_paddingValue = op.padding\_value();
00180 
00181     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Dimensions}
      & input\_dims = m\_impl.dimensions();
00182 
00183     \textcolor{comment}{// Caches a few variables.}
00184     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00185       m\_inputDepth = input\_dims[0];
00186       m\_inputRows = input\_dims[1];
00187       m\_inputCols = input\_dims[2];
00188     \} \textcolor{keywordflow}{else} \{
00189       m\_inputDepth = input\_dims[NumInputDims-1];
00190       m\_inputRows = input\_dims[NumInputDims-2];
00191       m\_inputCols = input\_dims[NumInputDims-3];
00192     \}
00193 
00194     m\_row\_strides = op.row\_strides();
00195     m\_col\_strides = op.col\_strides();
00196 
00197     \textcolor{comment}{// Input strides and effective input/patch size}
00198     m\_in\_row\_strides = op.in\_row\_strides();
00199     m\_in\_col\_strides = op.in\_col\_strides();
00200     m\_row\_inflate\_strides = op.row\_inflate\_strides();
00201     m\_col\_inflate\_strides = op.col\_inflate\_strides();
00202     \textcolor{comment}{// The "effective" input rows and input cols are the input rows and cols}
00203     \textcolor{comment}{// after inflating them with zeros.}
00204     \textcolor{comment}{// For examples, a 2x3 matrix with row\_inflate\_strides and}
00205     \textcolor{comment}{// col\_inflate\_strides of 2 comes from:}
00206     \textcolor{comment}{//   A B C}
00207     \textcolor{comment}{//   D E F}
00208     \textcolor{comment}{//}
00209     \textcolor{comment}{// to a matrix is 3 x 5:}
00210     \textcolor{comment}{//}
00211     \textcolor{comment}{//   A . B . C}
00212     \textcolor{comment}{//   . . . . .}
00213     \textcolor{comment}{//   D . E . F}
00214 
00215     m\_input\_rows\_eff = (m\_inputRows - 1) * m\_row\_inflate\_strides + 1;
00216     m\_input\_cols\_eff = (m\_inputCols - 1) * m\_col\_inflate\_strides + 1;
00217     m\_patch\_rows\_eff = op.patch\_rows() + (op.patch\_rows() - 1) * (m\_in\_row\_strides - 1);
00218     m\_patch\_cols\_eff = op.patch\_cols() + (op.patch\_cols() - 1) * (m\_in\_col\_strides - 1);
00219 
00220     \textcolor{keywordflow}{if} (op.padding\_explicit()) \{
00221       m\_outputRows = numext::ceil((m\_input\_rows\_eff + op.padding\_top() + op.padding\_bottom() - 
      m\_patch\_rows\_eff + 1.f) / static\_cast<float>(m\_row\_strides));
00222       m\_outputCols = numext::ceil((m\_input\_cols\_eff + op.padding\_left() + op.padding\_right() - 
      m\_patch\_cols\_eff + 1.f) / static\_cast<float>(m\_col\_strides));
00223       m\_rowPaddingTop = op.padding\_top();
00224       m\_colPaddingLeft = op.padding\_left();
00225     \} \textcolor{keywordflow}{else} \{
00226       \textcolor{comment}{// Computing padding from the type}
00227       \textcolor{keywordflow}{switch} (op.padding\_type()) \{
00228         \textcolor{keywordflow}{case} PADDING\_VALID:
00229           m\_outputRows = numext::ceil((m\_input\_rows\_eff - m\_patch\_rows\_eff + 1.f) / static\_cast<float>(
      m\_row\_strides));
00230           m\_outputCols = numext::ceil((m\_input\_cols\_eff - m\_patch\_cols\_eff + 1.f) / static\_cast<float>(
      m\_col\_strides));
00231           \textcolor{comment}{// Calculate the padding}
00232           m\_rowPaddingTop = numext::maxi<Index>(0, ((m\_outputRows - 1) * m\_row\_strides + m\_patch\_rows\_eff -
       m\_input\_rows\_eff) / 2);
00233           m\_colPaddingLeft = numext::maxi<Index>(0, ((m\_outputCols - 1) * m\_col\_strides + m\_patch\_cols\_eff 
      - m\_input\_cols\_eff) / 2);
00234           \textcolor{keywordflow}{break};
00235         \textcolor{keywordflow}{case} PADDING\_SAME:
00236           m\_outputRows = numext::ceil(m\_input\_rows\_eff / static\_cast<float>(m\_row\_strides));
00237           m\_outputCols = numext::ceil(m\_input\_cols\_eff / static\_cast<float>(m\_col\_strides));
00238           \textcolor{comment}{// Calculate the padding}
00239           m\_rowPaddingTop = ((m\_outputRows - 1) * m\_row\_strides + m\_patch\_rows\_eff - m\_input\_rows\_eff) / 2;
00240           m\_colPaddingLeft = ((m\_outputCols - 1) * m\_col\_strides + m\_patch\_cols\_eff - m\_input\_cols\_eff) / 2
      ;
00241           \textcolor{keywordflow}{break};
00242         \textcolor{keywordflow}{default}:
00243           eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"unexpected padding"});
00244       \}
00245     \}
00246     eigen\_assert(m\_outputRows > 0);
00247     eigen\_assert(m\_outputCols > 0);
00248 
00249     \textcolor{comment}{// Dimensions for result of extraction.}
00250     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00251       \textcolor{comment}{// ColMajor}
00252       \textcolor{comment}{// 0: depth}
00253       \textcolor{comment}{// 1: patch\_rows}
00254       \textcolor{comment}{// 2: patch\_cols}
00255       \textcolor{comment}{// 3: number of patches}
00256       \textcolor{comment}{// 4 and beyond: anything else (such as batch).}
00257       m\_dimensions[0] = input\_dims[0];
00258       m\_dimensions[1] = op.patch\_rows();
00259       m\_dimensions[2] = op.patch\_cols();
00260       m\_dimensions[3] = m\_outputRows * m\_outputCols;
00261       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 4; i < NumDims; ++i) \{
00262         m\_dimensions[i] = input\_dims[i-1];
00263       \}
00264     \} \textcolor{keywordflow}{else} \{
00265       \textcolor{comment}{// RowMajor}
00266       \textcolor{comment}{// NumDims-1: depth}
00267       \textcolor{comment}{// NumDims-2: patch\_rows}
00268       \textcolor{comment}{// NumDims-3: patch\_cols}
00269       \textcolor{comment}{// NumDims-4: number of patches}
00270       \textcolor{comment}{// NumDims-5 and beyond: anything else (such as batch).}
00271       m\_dimensions[NumDims-1] = input\_dims[NumInputDims-1];
00272       m\_dimensions[NumDims-2] = op.patch\_rows();
00273       m\_dimensions[NumDims-3] = op.patch\_cols();
00274       m\_dimensions[NumDims-4] = m\_outputRows * m\_outputCols;
00275       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims-5; i >= 0; --i) \{
00276         m\_dimensions[i] = input\_dims[i];
00277       \}
00278     \}
00279 
00280     \textcolor{comment}{// Strides for moving the patch in various dimensions.}
00281     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00282       m\_colStride = m\_dimensions[1];
00283       m\_patchStride = m\_colStride * m\_dimensions[2] * m\_dimensions[0];
00284       m\_otherStride = m\_patchStride * m\_dimensions[3];
00285     \} \textcolor{keywordflow}{else} \{
00286       m\_colStride = m\_dimensions[NumDims-2];
00287       m\_patchStride = m\_colStride * m\_dimensions[NumDims-3] * m\_dimensions[NumDims-1];
00288       m\_otherStride = m\_patchStride * m\_dimensions[NumDims-4];
00289     \}
00290 
00291     \textcolor{comment}{// Strides for navigating through the input tensor.}
00292     m\_rowInputStride = m\_inputDepth;
00293     m\_colInputStride = m\_inputDepth * m\_inputRows;
00294     m\_patchInputStride = m\_inputDepth * m\_inputRows * m\_inputCols;
00295 
00296     \textcolor{comment}{// Fast representations of different variables.}
00297     m\_fastOtherStride = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_otherStride);
00298     m\_fastPatchStride = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_patchStride);
00299     m\_fastColStride = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_colStride);
00300     m\_fastInflateRowStride = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(
      m\_row\_inflate\_strides);
00301     m\_fastInflateColStride = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(
      m\_col\_inflate\_strides);
00302     m\_fastInputColsEff = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(
      m\_input\_cols\_eff);
00303 
00304     \textcolor{comment}{// Number of patches in the width dimension.}
00305     m\_fastOutputRows = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_outputRows);
00306     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00307       m\_fastOutputDepth = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_dimensions[0
      ]);
00308     \} \textcolor{keywordflow}{else} \{
00309       m\_fastOutputDepth = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_dimensions[
      NumDims-1]);
00310     \}
00311   \}
00312 
00313   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00314 
00315   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/}) \{
00316     m\_impl.evalSubExprsIfNeeded(NULL);
00317     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00318   \}
00319 
00320   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00321     m\_impl.cleanup();
00322   \}
00323 
00324   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00325 \textcolor{keyword}{  }\{
00326     \textcolor{comment}{// Patch index corresponding to the passed in index.}
00327     \textcolor{keyword}{const} Index patchIndex = index / m\_fastPatchStride;
00328     \textcolor{comment}{// Find the offset of the element wrt the location of the first element.}
00329     \textcolor{keyword}{const} Index patchOffset = (index - patchIndex * m\_patchStride) / m\_fastOutputDepth;
00330 
00331     \textcolor{comment}{// Other ways to index this element.}
00332     \textcolor{keyword}{const} Index otherIndex = (NumDims == 4) ? 0 : index / m\_fastOtherStride;
00333     \textcolor{keyword}{const} Index patch2DIndex = (NumDims == 4) ? patchIndex : (index - otherIndex * m\_otherStride) / 
      m\_fastPatchStride;
00334 
00335     \textcolor{comment}{// Calculate col index in the input original tensor.}
00336     \textcolor{keyword}{const} Index colIndex = patch2DIndex / m\_fastOutputRows;
00337     \textcolor{keyword}{const} Index colOffset = patchOffset / m\_fastColStride;
00338     \textcolor{keyword}{const} Index inputCol = colIndex * m\_col\_strides + colOffset * m\_in\_col\_strides - m\_colPaddingLeft;
00339     \textcolor{keyword}{const} Index origInputCol = (m\_col\_inflate\_strides == 1) ? inputCol : ((inputCol >= 0) ? (inputCol / 
      m\_fastInflateColStride) : 0);
00340     \textcolor{keywordflow}{if} (inputCol < 0 || inputCol >= m\_input\_cols\_eff ||
00341         ((m\_col\_inflate\_strides != 1) && (inputCol != origInputCol * m\_col\_inflate\_strides))) \{
00342       \textcolor{keywordflow}{return} Scalar(m\_paddingValue);
00343     \}
00344 
00345     \textcolor{comment}{// Calculate row index in the original input tensor.}
00346     \textcolor{keyword}{const} Index rowIndex = patch2DIndex - colIndex * m\_outputRows;
00347     \textcolor{keyword}{const} Index rowOffset = patchOffset - colOffset * m\_colStride;
00348     \textcolor{keyword}{const} Index inputRow = rowIndex * m\_row\_strides + rowOffset * m\_in\_row\_strides - m\_rowPaddingTop;
00349     \textcolor{keyword}{const} Index origInputRow = (m\_row\_inflate\_strides == 1) ? inputRow : ((inputRow >= 0) ? (inputRow / 
      m\_fastInflateRowStride) : 0);
00350     \textcolor{keywordflow}{if} (inputRow < 0 || inputRow >= m\_input\_rows\_eff ||
00351         ((m\_row\_inflate\_strides != 1) && (inputRow != origInputRow * m\_row\_inflate\_strides))) \{
00352       \textcolor{keywordflow}{return} Scalar(m\_paddingValue);
00353     \}
00354 
00355     \textcolor{keyword}{const} \textcolor{keywordtype}{int} depth\_index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) ? 0 : NumDims - 1;
00356     \textcolor{keyword}{const} Index depth = index - (index / m\_fastOutputDepth) * m\_dimensions[depth\_index];
00357 
00358     \textcolor{keyword}{const} Index inputIndex = depth + origInputRow * m\_rowInputStride + origInputCol * m\_colInputStride + 
      otherIndex * m\_patchInputStride;
00359     \textcolor{keywordflow}{return} m\_impl.coeff(inputIndex);
00360   \}
00361 
00362   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00363   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00364 \textcolor{keyword}{  }\{
00365     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00366     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00367 
00368     \textcolor{keywordflow}{if} (m\_in\_row\_strides != 1 || m\_in\_col\_strides != 1 || m\_row\_inflate\_strides != 1 || 
      m\_col\_inflate\_strides != 1) \{
00369       \textcolor{keywordflow}{return} packetWithPossibleZero(index);
00370     \}
00371 
00372     \textcolor{keyword}{const} Index indices[2] = \{index, index + PacketSize - 1\};
00373     \textcolor{keyword}{const} Index patchIndex = indices[0] / m\_fastPatchStride;
00374     \textcolor{keywordflow}{if} (patchIndex != indices[1] / m\_fastPatchStride) \{
00375       \textcolor{keywordflow}{return} packetWithPossibleZero(index);
00376     \}
00377     \textcolor{keyword}{const} Index otherIndex = (NumDims == 4) ? 0 : indices[0] / m\_fastOtherStride;
00378     eigen\_assert(otherIndex == indices[1] / m\_fastOtherStride);
00379 
00380     \textcolor{comment}{// Find the offset of the element wrt the location of the first element.}
00381     \textcolor{keyword}{const} Index patchOffsets[2] = \{(indices[0] - patchIndex * m\_patchStride) / m\_fastOutputDepth,
00382                                    (indices[1] - patchIndex * m\_patchStride) / m\_fastOutputDepth\};
00383 
00384     \textcolor{keyword}{const} Index patch2DIndex = (NumDims == 4) ? patchIndex : (indices[0] - otherIndex * m\_otherStride) / 
      m\_fastPatchStride;
00385     eigen\_assert(patch2DIndex == (indices[1] - otherIndex * m\_otherStride) / m\_fastPatchStride);
00386 
00387     \textcolor{keyword}{const} Index colIndex = patch2DIndex / m\_fastOutputRows;
00388     \textcolor{keyword}{const} Index colOffsets[2] = \{patchOffsets[0] / m\_fastColStride, patchOffsets[1] / m\_fastColStride\};
00389 
00390     \textcolor{comment}{// Calculate col indices in the original input tensor.}
00391     \textcolor{keyword}{const} Index inputCols[2] = \{colIndex * m\_col\_strides + colOffsets[0] -
00392       m\_colPaddingLeft, colIndex * m\_col\_strides + colOffsets[1] - m\_colPaddingLeft\};
00393     \textcolor{keywordflow}{if} (inputCols[1] < 0 || inputCols[0] >= m\_inputCols) \{
00394       \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(Scalar(m\_paddingValue));
00395     \}
00396 
00397     \textcolor{keywordflow}{if} (inputCols[0] == inputCols[1]) \{
00398       \textcolor{keyword}{const} Index rowIndex = patch2DIndex - colIndex * m\_outputRows;
00399       \textcolor{keyword}{const} Index rowOffsets[2] = \{patchOffsets[0] - colOffsets[0]*m\_colStride, patchOffsets[1] - 
      colOffsets[1]*m\_colStride\};
00400       eigen\_assert(rowOffsets[0] <= rowOffsets[1]);
00401       \textcolor{comment}{// Calculate col indices in the original input tensor.}
00402       \textcolor{keyword}{const} Index inputRows[2] = \{rowIndex * m\_row\_strides + rowOffsets[0] -
00403         m\_rowPaddingTop, rowIndex * m\_row\_strides + rowOffsets[1] - m\_rowPaddingTop\};
00404 
00405       \textcolor{keywordflow}{if} (inputRows[1] < 0 || inputRows[0] >= m\_inputRows) \{
00406         \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(Scalar(m\_paddingValue));
00407       \}
00408 
00409       \textcolor{keywordflow}{if} (inputRows[0] >= 0 && inputRows[1] < m\_inputRows) \{
00410         \textcolor{comment}{// no padding}
00411         \textcolor{keyword}{const} \textcolor{keywordtype}{int} depth\_index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) ? 0 : NumDims - 1;
00412         \textcolor{keyword}{const} Index depth = index - (index / m\_fastOutputDepth) * m\_dimensions[depth\_index];
00413         \textcolor{keyword}{const} Index inputIndex = depth + inputRows[0] * m\_rowInputStride + inputCols[0] * m\_colInputStride 
      + otherIndex * m\_patchInputStride;
00414         \textcolor{keywordflow}{return} m\_impl.template packet<Unaligned>(inputIndex);
00415       \}
00416     \}
00417 
00418     \textcolor{keywordflow}{return} packetWithPossibleZero(index);
00419   \}
00420 
00421   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00422 
00423   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>}& impl()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_impl; \}
00424 
00425   Index rowPaddingTop()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rowPaddingTop; \}
00426   Index colPaddingLeft()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_colPaddingLeft; \}
00427   Index outputRows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_outputRows; \}
00428   Index outputCols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_outputCols; \}
00429   Index userRowStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_row\_strides; \}
00430   Index userColStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_col\_strides; \}
00431   Index userInRowStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_in\_row\_strides; \}
00432   Index userInColStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_in\_col\_strides; \}
00433   Index rowInflateStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_row\_inflate\_strides; \}
00434   Index colInflateStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_col\_inflate\_strides; \}
00435 
00436   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}
00437   costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00438     \textcolor{comment}{// We conservatively estimate the cost for the code path where the computed}
00439     \textcolor{comment}{// index is inside the original image and}
00440     \textcolor{comment}{// TensorEvaluator<ArgType, Device>::CoordAccess is false.}
00441     \textcolor{keyword}{const} \textcolor{keywordtype}{double} compute\_cost = 3 * TensorOpCost::DivCost<Index>() +
00442                                 6 * TensorOpCost::MulCost<Index>() +
00443                                 8 * TensorOpCost::MulCost<Index>();
00444     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) +
00445            \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, compute\_cost, vectorized, PacketSize);
00446   \}
00447 
00448  \textcolor{keyword}{protected}:
00449   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packetWithPossibleZero(Index index)\textcolor{keyword}{ const}
00450 \textcolor{keyword}{  }\{
00451     EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<CoeffReturnType>::type}
       values[PacketSize];
00452     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00453       values[i] = coeff(index+i);
00454     \}
00455     PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00456     \textcolor{keywordflow}{return} rslt;
00457   \}
00458 
00459   Dimensions m\_dimensions;
00460 
00461   Index m\_otherStride;
00462   Index m\_patchStride;
00463   Index m\_colStride;
00464   Index m\_row\_strides;
00465   Index m\_col\_strides;
00466 
00467   Index m\_in\_row\_strides;
00468   Index m\_in\_col\_strides;
00469   Index m\_row\_inflate\_strides;
00470   Index m\_col\_inflate\_strides;
00471 
00472   Index m\_input\_rows\_eff;
00473   Index m\_input\_cols\_eff;
00474   Index m\_patch\_rows\_eff;
00475   Index m\_patch\_cols\_eff;
00476 
00477   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastOtherStride;
00478   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastPatchStride;
00479   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastColStride;
00480   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastInflateRowStride;
00481   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastInflateColStride;
00482   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastInputColsEff;
00483 
00484   Index m\_rowInputStride;
00485   Index m\_colInputStride;
00486   Index m\_patchInputStride;
00487 
00488   Index m\_inputDepth;
00489   Index m\_inputRows;
00490   Index m\_inputCols;
00491 
00492   Index m\_outputRows;
00493   Index m\_outputCols;
00494 
00495   Index m\_rowPaddingTop;
00496   Index m\_colPaddingLeft;
00497 
00498   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastOutputRows;
00499   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastOutputDepth;
00500 
00501   Scalar m\_paddingValue;
00502 
00503   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} m\_impl;
00504 \};
00505 
00506 
00507 \} \textcolor{comment}{// end namespace Eigen}
00508 
00509 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_IMAGE\_PATCH\_H}
\end{DoxyCode}
