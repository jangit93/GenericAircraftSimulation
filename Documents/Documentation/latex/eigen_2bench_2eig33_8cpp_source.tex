\hypertarget{eigen_2bench_2eig33_8cpp_source}{}\section{eigen/bench/eig33.cpp}
\label{eigen_2bench_2eig33_8cpp_source}\index{eig33.\+cpp@{eig33.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{comment}{// The computeRoots function included in this is based on materials}
00011 \textcolor{comment}{// covered by the following copyright and license:}
00012 \textcolor{comment}{// }
00013 \textcolor{comment}{// Geometric Tools, LLC}
00014 \textcolor{comment}{// Copyright (c) 1998-2010}
00015 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0.}
00016 \textcolor{comment}{// }
00017 \textcolor{comment}{// Permission is hereby granted, free of charge, to any person or organization}
00018 \textcolor{comment}{// obtaining a copy of the software and accompanying documentation covered by}
00019 \textcolor{comment}{// this license (the "Software") to use, reproduce, display, distribute,}
00020 \textcolor{comment}{// execute, and transmit the Software, and to prepare derivative works of the}
00021 \textcolor{comment}{// Software, and to permit third-parties to whom the Software is furnished to}
00022 \textcolor{comment}{// do so, all subject to the following:}
00023 \textcolor{comment}{// }
00024 \textcolor{comment}{// The copyright notices in the Software and this entire statement, including}
00025 \textcolor{comment}{// the above license grant, this restriction and the following disclaimer,}
00026 \textcolor{comment}{// must be included in all copies of the Software, in whole or in part, and}
00027 \textcolor{comment}{// all derivative works of the Software, unless such copies or derivative}
00028 \textcolor{comment}{// works are solely in the form of machine-executable object code generated by}
00029 \textcolor{comment}{// a source language processor.}
00030 \textcolor{comment}{// }
00031 \textcolor{comment}{// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}
00032 \textcolor{comment}{// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}
00033 \textcolor{comment}{// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT}
00034 \textcolor{comment}{// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE}
00035 \textcolor{comment}{// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,}
00036 \textcolor{comment}{// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER}
00037 \textcolor{comment}{// DEALINGS IN THE SOFTWARE.}
00038 
00039 \textcolor{preprocessor}{#include <iostream>}
00040 \textcolor{preprocessor}{#include <Eigen/Core>}
00041 \textcolor{preprocessor}{#include <Eigen/Eigenvalues>}
00042 \textcolor{preprocessor}{#include <Eigen/Geometry>}
00043 \textcolor{preprocessor}{#include <bench/BenchTimer.h>}
00044 
00045 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00046 \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00047 
00048 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Matrix, \textcolor{keyword}{typename} Roots>
00049 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} computeRoots(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}& m, Roots& roots)
00050 \{
00051   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Matrix::Scalar Scalar;
00052   \textcolor{keyword}{const} Scalar s\_inv3 = 1.0/3.0;
00053   \textcolor{keyword}{const} Scalar s\_sqrt3 = std::sqrt(Scalar(3.0));
00054 
00055   \textcolor{comment}{// The characteristic equation is x^3 - c2*x^2 + c1*x - c0 = 0.  The}
00056   \textcolor{comment}{// eigenvalues are the roots to this equation, all guaranteed to be}
00057   \textcolor{comment}{// real-valued, because the matrix is symmetric.}
00058   Scalar c0 = m(0,0)*m(1,1)*m(2,2) + Scalar(2)*m(0,1)*m(0,2)*m(1,2) - m(0,0)*m(1,2)*m(1,2) - m(1,1)*m(0,2)*
      m(0,2) - m(2,2)*m(0,1)*m(0,1);
00059   Scalar c1 = m(0,0)*m(1,1) - m(0,1)*m(0,1) + m(0,0)*m(2,2) - m(0,2)*m(0,2) + m(1,1)*m(2,2) - m(1,2)*m(1,2)
      ;
00060   Scalar c2 = m(0,0) + m(1,1) + m(2,2);
00061 
00062   \textcolor{comment}{// Construct the parameters used in classifying the roots of the equation}
00063   \textcolor{comment}{// and in solving the equation for the roots in closed form.}
00064   Scalar c2\_over\_3 = c2*s\_inv3;
00065   Scalar a\_over\_3 = (c1 - c2*c2\_over\_3)*s\_inv3;
00066   \textcolor{keywordflow}{if} (a\_over\_3 > Scalar(0))
00067     a\_over\_3 = Scalar(0);
00068 
00069   Scalar half\_b = Scalar(0.5)*(c0 + c2\_over\_3*(Scalar(2)*c2\_over\_3*c2\_over\_3 - c1));
00070 
00071   Scalar q = half\_b*half\_b + a\_over\_3*a\_over\_3*a\_over\_3;
00072   \textcolor{keywordflow}{if} (q > Scalar(0))
00073     q = Scalar(0);
00074 
00075   \textcolor{comment}{// Compute the eigenvalues by solving for the roots of the polynomial.}
00076   Scalar rho = std::sqrt(-a\_over\_3);
00077   Scalar theta = std::atan2(std::sqrt(-q),half\_b)*s\_inv3;
00078   Scalar cos\_theta = std::cos(theta);
00079   Scalar sin\_theta = std::sin(theta);
00080   roots(2) = c2\_over\_3 + Scalar(2)*rho*cos\_theta;
00081   roots(0) = c2\_over\_3 - rho*(cos\_theta + s\_sqrt3*sin\_theta);
00082   roots(1) = c2\_over\_3 - rho*(cos\_theta - s\_sqrt3*sin\_theta);
00083 \}
00084 
00085 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Matrix, \textcolor{keyword}{typename} Vector>
00086 \textcolor{keywordtype}{void} eigen33(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}& mat, \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}& evecs, Vector& evals)
00087 \{
00088   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Matrix::Scalar Scalar;
00089   \textcolor{comment}{// Scale the matrix so its entries are in [-1,1].  The scaling is applied}
00090   \textcolor{comment}{// only when at least one matrix entry has magnitude larger than 1.}
00091 
00092   Scalar shift = mat.trace()/3;
00093   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix} scaledMat = mat;
00094   scaledMat.diagonal().array() -= shift;
00095   Scalar scale = scaledMat.cwiseAbs()\textcolor{comment}{/*.template triangularView<Lower>()*/}.maxCoeff();
00096   scale = std::max(scale,Scalar(1));
00097   scaledMat/=scale;
00098 
00099   \textcolor{comment}{// Compute the eigenvalues}
00100 \textcolor{comment}{//   scaledMat.setZero();}
00101   computeRoots(scaledMat,evals);
00102 
00103   \textcolor{comment}{// compute the eigen vectors}
00104   \textcolor{comment}{// **here we assume 3 differents eigenvalues**}
00105 
00106   \textcolor{comment}{// "optimized version" which appears to be slower with gcc!}
00107 \textcolor{comment}{//     Vector base;}
00108 \textcolor{comment}{//     Scalar alpha, beta;}
00109 \textcolor{comment}{//     base <<   scaledMat(1,0) * scaledMat(2,1),}
00110 \textcolor{comment}{//               scaledMat(1,0) * scaledMat(2,0),}
00111 \textcolor{comment}{//              -scaledMat(1,0) * scaledMat(1,0);}
00112 \textcolor{comment}{//     for(int k=0; k<2; ++k)}
00113 \textcolor{comment}{//     \{}
00114 \textcolor{comment}{//       alpha = scaledMat(0,0) - evals(k);}
00115 \textcolor{comment}{//       beta  = scaledMat(1,1) - evals(k);}
00116 \textcolor{comment}{//       evecs.col(k) = (base + Vector(-beta*scaledMat(2,0), -alpha*scaledMat(2,1),
       alpha*beta)).normalized();}
00117 \textcolor{comment}{//     \}}
00118 \textcolor{comment}{//     evecs.col(2) = evecs.col(0).cross(evecs.col(1)).normalized();}
00119 
00120 \textcolor{comment}{//   // naive version}
00121 \textcolor{comment}{//   Matrix tmp;}
00122 \textcolor{comment}{//   tmp = scaledMat;}
00123 \textcolor{comment}{//   tmp.diagonal().array() -= evals(0);}
00124 \textcolor{comment}{//   evecs.col(0) = tmp.row(0).cross(tmp.row(1)).normalized();}
00125 \textcolor{comment}{// }
00126 \textcolor{comment}{//   tmp = scaledMat;}
00127 \textcolor{comment}{//   tmp.diagonal().array() -= evals(1);}
00128 \textcolor{comment}{//   evecs.col(1) = tmp.row(0).cross(tmp.row(1)).normalized();}
00129 \textcolor{comment}{// }
00130 \textcolor{comment}{//   tmp = scaledMat;}
00131 \textcolor{comment}{//   tmp.diagonal().array() -= evals(2);}
00132 \textcolor{comment}{//   evecs.col(2) = tmp.row(0).cross(tmp.row(1)).normalized();}
00133   
00134   \textcolor{comment}{// a more stable version:}
00135   \textcolor{keywordflow}{if}((evals(2)-evals(0))<=\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{Eigen::NumTraits<Scalar>::epsilon}())
00136   \{
00137     evecs.setIdentity();
00138   \}
00139   \textcolor{keywordflow}{else}
00140   \{
00141     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix} tmp;
00142     tmp = scaledMat;
00143     tmp.diagonal ().array () -= evals (2);
00144     evecs.col (2) = tmp.row (0).cross (tmp.row (1)).normalized ();
00145     
00146     tmp = scaledMat;
00147     tmp.diagonal ().array () -= evals (1);
00148     evecs.col(1) = tmp.row (0).cross(tmp.row (1));
00149     Scalar n1 = evecs.col(1).norm();
00150     \textcolor{keywordflow}{if}(n1<=\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{Eigen::NumTraits<Scalar>::epsilon}())
00151       evecs.col(1) = evecs.col(2).unitOrthogonal();
00152     \textcolor{keywordflow}{else}
00153       evecs.col(1) /= n1;
00154     
00155     \textcolor{comment}{// make sure that evecs[1] is orthogonal to evecs[2]}
00156     evecs.col(1) = evecs.col(2).cross(evecs.col(1).cross(evecs.col(2))).normalized();
00157     evecs.col(0) = evecs.col(2).cross(evecs.col(1));
00158   \}
00159   
00160   \textcolor{comment}{// Rescale back to the original size.}
00161   evals *= scale;
00162   evals.array()+=shift;
00163 \}
00164 
00165 \textcolor{keywordtype}{int} main()
00166 \{
00167   \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} t;
00168   \textcolor{keywordtype}{int} tries = 10;
00169   \textcolor{keywordtype}{int} rep = 400000;
00170   \textcolor{keyword}{typedef} Matrix3d \hyperlink{group___core___module}{Mat};
00171   \textcolor{keyword}{typedef} Vector3d \hyperlink{group___core___module_class_eigen_1_1_matrix}{Vec};
00172   Mat \hyperlink{group___core___module_class_eigen_1_1_matrix}{A} = Mat::Random(3,3);
00173   A = A.adjoint() * A;
00174 \textcolor{comment}{//   Mat Q = A.householderQr().householderQ();}
00175 \textcolor{comment}{//   A = Q * Vec(2.2424567,2.2424566,7.454353).asDiagonal() * Q.transpose();}
00176 
00177   \hyperlink{group___eigenvalues___module_class_eigen_1_1_self_adjoint_eigen_solver}{SelfAdjointEigenSolver<Mat>} eig(A);
00178   BENCH(t, tries, rep, eig.compute(A));
00179   std::cout << \textcolor{stringliteral}{"Eigen iterative:  "} << t.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}() << \textcolor{stringliteral}{"s\(\backslash\)n"};
00180   
00181   BENCH(t, tries, rep, eig.computeDirect(A));
00182   std::cout << \textcolor{stringliteral}{"Eigen direct   :  "} << t.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}() << \textcolor{stringliteral}{"s\(\backslash\)n"};
00183 
00184   Mat evecs;
00185   Vec evals;
00186   BENCH(t, tries, rep, eigen33(A,evecs,evals));
00187   std::cout << \textcolor{stringliteral}{"Direct: "} << t.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}() << \textcolor{stringliteral}{"s\(\backslash\)n\(\backslash\)n"};
00188 
00189 \textcolor{comment}{//   std::cerr << "Eigenvalue/eigenvector diffs:\(\backslash\)n";}
00190 \textcolor{comment}{//   std::cerr << (evals - eig.eigenvalues()).transpose() << "\(\backslash\)n";}
00191 \textcolor{comment}{//   for(int k=0;k<3;++k)}
00192 \textcolor{comment}{//     if(evecs.col(k).dot(eig.eigenvectors().col(k))<0)}
00193 \textcolor{comment}{//       evecs.col(k) = -evecs.col(k);}
00194 \textcolor{comment}{//   std::cerr << evecs - eig.eigenvectors() << "\(\backslash\)n\(\backslash\)n";}
00195 \}
\end{DoxyCode}
