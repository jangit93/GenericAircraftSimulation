\hypertarget{eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u__pivot_l_8h_source}{}\section{eigen/\+Eigen/src/\+Sparse\+L\+U/\+Sparse\+L\+U\+\_\+pivotL.h}
\label{eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u__pivot_l_8h_source}\index{Sparse\+L\+U\+\_\+pivot\+L.\+h@{Sparse\+L\+U\+\_\+pivot\+L.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{comment}{/* }
00011 \textcolor{comment}{ }
00012 \textcolor{comment}{ * NOTE: This file is the modified version of xpivotL.c file in SuperLU }
00013 \textcolor{comment}{ }
00014 \textcolor{comment}{ * -- SuperLU routine (version 3.0) --}
00015 \textcolor{comment}{ * Univ. of California Berkeley, Xerox Palo Alto Research Center,}
00016 \textcolor{comment}{ * and Lawrence Berkeley National Lab.}
00017 \textcolor{comment}{ * October 15, 2003}
00018 \textcolor{comment}{ *}
00019 \textcolor{comment}{ * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.}
00020 \textcolor{comment}{ *}
00021 \textcolor{comment}{ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY}
00022 \textcolor{comment}{ * EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.}
00023 \textcolor{comment}{ *}
00024 \textcolor{comment}{ * Permission is hereby granted to use or copy this program for any}
00025 \textcolor{comment}{ * purpose, provided the above notices are retained on all copies.}
00026 \textcolor{comment}{ * Permission to modify the code and to distribute modified code is}
00027 \textcolor{comment}{ * granted, provided the above notices are retained, and a notice that}
00028 \textcolor{comment}{ * the code was modified is included with the above copyright notice.}
00029 \textcolor{comment}{ */}
00030 \textcolor{preprocessor}{#ifndef SPARSELU\_PIVOTL\_H}
00031 \textcolor{preprocessor}{#define SPARSELU\_PIVOTL\_H}
00032 
00033 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00034 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00035   
00059 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} StorageIndex>
\Hypertarget{eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u__pivot_l_8h_source_l00060}\hyperlink{group___sparse_l_u___module_ab5f56947465b829f8d523575724c3ac6}{00060} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{group___sparse_l_u___module_ab5f56947465b829f8d523575724c3ac6}{SparseLUImpl<Scalar,StorageIndex>::pivotL}(\textcolor{keyword}{const} 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} jcol, \textcolor{keyword}{const} RealScalar& diagpivotthresh, \hyperlink{group___core___module_class_eigen_1_1_matrix}{IndexVector}& perm\_r, 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{IndexVector}& iperm\_c, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& pivrow, \hyperlink{struct_eigen_1_1internal_1_1_l_u___global_l_u__t}{GlobalLU\_t}& glu)
00061 \{
00062   
00063   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} fsupc = (glu.xsup)((glu.supno)(jcol)); \textcolor{comment}{// First column in the supernode containing the column
       jcol}
00064   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nsupc = jcol - fsupc; \textcolor{comment}{// Number of columns in the supernode portion, excluding jcol; nsupc >=0}
00065   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lptr = glu.xlsub(fsupc); \textcolor{comment}{// pointer to the starting location of the row subscripts for this
       supernode portion}
00066   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nsupr = glu.xlsub(fsupc+1) - lptr; \textcolor{comment}{// Number of rows in the supernode}
00067   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lda = glu.xlusup(fsupc+1) - glu.xlusup(fsupc); \textcolor{comment}{// leading dimension}
00068   Scalar* lu\_sup\_ptr = &(glu.lusup.data()[glu.xlusup(fsupc)]); \textcolor{comment}{// Start of the current supernode}
00069   Scalar* lu\_col\_ptr = &(glu.lusup.data()[glu.xlusup(jcol)]); \textcolor{comment}{// Start of jcol in the supernode}
00070   StorageIndex* lsub\_ptr = &(glu.lsub.data()[lptr]); \textcolor{comment}{// Start of row indices of the supernode}
00071   
00072   \textcolor{comment}{// Determine the largest abs numerical value for partial pivoting }
00073   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} diagind = iperm\_c(jcol); \textcolor{comment}{// diagonal index }
00074   RealScalar pivmax(-1.0);
00075   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} pivptr = nsupc; 
00076   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} diag = emptyIdxLU; 
00077   RealScalar rtemp;
00078   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} isub, icol, itemp, k; 
00079   \textcolor{keywordflow}{for} (isub = nsupc; isub < nsupr; ++isub) \{
00080     \textcolor{keyword}{using} std::abs;
00081     rtemp = abs(lu\_col\_ptr[isub]);
00082     \textcolor{keywordflow}{if} (rtemp > pivmax) \{
00083       pivmax = rtemp; 
00084       pivptr = isub;
00085     \} 
00086     \textcolor{keywordflow}{if} (lsub\_ptr[isub] == diagind) diag = isub;
00087   \}
00088   
00089   \textcolor{comment}{// Test for singularity}
00090   \textcolor{keywordflow}{if} ( pivmax <= RealScalar(0.0) ) \{
00091     \textcolor{comment}{// if pivmax == -1, the column is structurally empty, otherwise it is only numerically zero}
00092     pivrow = pivmax < RealScalar(0.0) ? diagind : lsub\_ptr[pivptr];
00093     perm\_r(pivrow) = StorageIndex(jcol);
00094     \textcolor{keywordflow}{return} (jcol+1);
00095   \}
00096   
00097   RealScalar thresh = diagpivotthresh * pivmax; 
00098   
00099   \textcolor{comment}{// Choose appropriate pivotal element }
00100   
00101   \{
00102     \textcolor{comment}{// Test if the diagonal element can be used as a pivot (given the threshold value)}
00103     \textcolor{keywordflow}{if} (diag >= 0 ) 
00104     \{
00105       \textcolor{comment}{// Diagonal element exists}
00106       \textcolor{keyword}{using} std::abs;
00107       rtemp = abs(lu\_col\_ptr[diag]);
00108       \textcolor{keywordflow}{if} (rtemp != RealScalar(0.0) && rtemp >= thresh) pivptr = diag;
00109     \}
00110     pivrow = lsub\_ptr[pivptr];
00111   \}
00112   
00113   \textcolor{comment}{// Record pivot row}
00114   perm\_r(pivrow) = StorageIndex(jcol);
00115   \textcolor{comment}{// Interchange row subscripts}
00116   \textcolor{keywordflow}{if} (pivptr != nsupc )
00117   \{
00118     \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}( lsub\_ptr[pivptr], lsub\_ptr[nsupc] );
00119     \textcolor{comment}{// Interchange numerical values as well, for the two rows in the whole snode}
00120     \textcolor{comment}{// such that L is indexed the same way as A}
00121     \textcolor{keywordflow}{for} (icol = 0; icol <= nsupc; icol++)
00122     \{
00123       itemp = pivptr + icol * lda; 
00124       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(lu\_sup\_ptr[itemp], lu\_sup\_ptr[nsupc + icol * lda]);
00125     \}
00126   \}
00127   \textcolor{comment}{// cdiv operations}
00128   Scalar temp = Scalar(1.0) / lu\_col\_ptr[nsupc];
00129   \textcolor{keywordflow}{for} (k = nsupc+1; k < nsupr; k++)
00130     lu\_col\_ptr[k] *= temp; 
00131   \textcolor{keywordflow}{return} 0;
00132 \}
00133 
00134 \} \textcolor{comment}{// end namespace internal}
00135 \} \textcolor{comment}{// end namespace Eigen}
00136 
00137 \textcolor{preprocessor}{#endif // SPARSELU\_PIVOTL\_H}
\end{DoxyCode}
