\hypertarget{eigen_2bench_2btl_2libs_2eigen3_2eigen3__interface_8hh_source}{}\section{eigen/bench/btl/libs/eigen3/eigen3\+\_\+interface.hh}
\label{eigen_2bench_2btl_2libs_2eigen3_2eigen3__interface_8hh_source}\index{eigen3\+\_\+interface.\+hh@{eigen3\+\_\+interface.\+hh}}

\begin{DoxyCode}
00001 \textcolor{comment}{//=====================================================}
00002 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00003 \textcolor{comment}{//=====================================================}
00004 \textcolor{comment}{//}
00005 \textcolor{comment}{// This program is free software; you can redistribute it and/or}
00006 \textcolor{comment}{// modify it under the terms of the GNU General Public License}
00007 \textcolor{comment}{// as published by the Free Software Foundation; either version 2}
00008 \textcolor{comment}{// of the License, or (at your option) any later version.}
00009 \textcolor{comment}{//}
00010 \textcolor{comment}{// This program is distributed in the hope that it will be useful,}
00011 \textcolor{comment}{// but WITHOUT ANY WARRANTY; without even the implied warranty of}
00012 \textcolor{comment}{// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
00013 \textcolor{comment}{// GNU General Public License for more details.}
00014 \textcolor{comment}{// You should have received a copy of the GNU General Public License}
00015 \textcolor{comment}{// along with this program; if not, write to the Free Software}
00016 \textcolor{comment}{// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.}
00017 \textcolor{comment}{//}
00018 \textcolor{preprocessor}{#ifndef EIGEN3\_INTERFACE\_HH}
00019 \textcolor{preprocessor}{#define EIGEN3\_INTERFACE\_HH}
00020 
00021 \textcolor{preprocessor}{#include <Eigen/Eigen>}
00022 \textcolor{preprocessor}{#include <vector>}
00023 \textcolor{preprocessor}{#include "btl.hh"}
00024 
00025 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00026 
00027 \textcolor{keyword}{template}<\textcolor{keyword}{class} real, \textcolor{keywordtype}{int} SIZE=Dynamic>
\Hypertarget{eigen_2bench_2btl_2libs_2eigen3_2eigen3__interface_8hh_source_l00028}\hyperlink{classeigen3__interface}{00028} \textcolor{keyword}{class }\hyperlink{classeigen3__interface}{eigen3\_interface}
00029 \{
00030 
00031 public :
00032 
00033   \textcolor{keyword}{enum} \{IsFixedSize = (SIZE!=\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic})\};
00034 
00035   \textcolor{keyword}{typedef} real real\_type;
00036 
00037   \textcolor{keyword}{typedef} std::vector<real> stl\_vector;
00038   \textcolor{keyword}{typedef} std::vector<stl\_vector> stl\_matrix;
00039 
00040   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Eigen::Matrix<real,SIZE,SIZE>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{gene\_matrix};
00041   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Eigen::Matrix<real,SIZE,1>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{gene\_vector};
00042 
00043   \textcolor{keyword}{static} \textcolor{keyword}{inline} std::string name( \textcolor{keywordtype}{void} )
00044   \{
00045     \textcolor{keywordflow}{return} EIGEN\_MAKESTRING(BTL\_PREFIX);
00046   \}
00047 
00048   \textcolor{keyword}{static} \textcolor{keywordtype}{void} free\_matrix(gene\_matrix & \textcolor{comment}{/*A*/}, \textcolor{keywordtype}{int} \textcolor{comment}{/*N*/}) \{\}
00049 
00050   \textcolor{keyword}{static} \textcolor{keywordtype}{void} free\_vector(gene\_vector & \textcolor{comment}{/*B*/}) \{\}
00051 
00052   \textcolor{keyword}{static} BTL\_DONT\_INLINE \textcolor{keywordtype}{void} matrix\_from\_stl(gene\_matrix & \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, stl\_matrix & A\_stl)\{
00053     A.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(A\_stl[0].size(), A\_stl.size());
00054 
00055     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j=0; j<A\_stl.size() ; j++)\{
00056       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<A\_stl[j].size() ; i++)\{
00057         A.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(i,j) = A\_stl[j][i];
00058       \}
00059     \}
00060   \}
00061 
00062   \textcolor{keyword}{static} BTL\_DONT\_INLINE  \textcolor{keywordtype}{void} vector\_from\_stl(gene\_vector & \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, stl\_vector & B\_stl)\{
00063     B.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(B\_stl.size(),1);
00064 
00065     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<B\_stl.size() ; i++)\{
00066       B.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(i) = B\_stl[i];
00067     \}
00068   \}
00069 
00070   \textcolor{keyword}{static} BTL\_DONT\_INLINE  \textcolor{keywordtype}{void} vector\_to\_stl(gene\_vector & B, stl\_vector & B\_stl)\{
00071     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0; i<B\_stl.size() ; i++)\{
00072       B\_stl[i] = B.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(i);
00073     \}
00074   \}
00075 
00076   \textcolor{keyword}{static} BTL\_DONT\_INLINE  \textcolor{keywordtype}{void} matrix\_to\_stl(gene\_matrix & A, stl\_matrix & A\_stl)\{
00077     \textcolor{keywordtype}{int}  N=A\_stl.size();
00078 
00079     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<N;j++)\{
00080       A\_stl[j].resize(N);
00081       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<N;i++)\{
00082         A\_stl[j][i] = A.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(i,j);
00083       \}
00084     \}
00085   \}
00086 
00087   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} matrix\_matrix\_product(\textcolor{keyword}{const} gene\_matrix & A, \textcolor{keyword}{const} gene\_matrix & B, gene\_matrix & X, \textcolor{keywordtype}{
      int}  \textcolor{comment}{/*N*/})\{
00088     X.noalias() = A*B;
00089   \}
00090 
00091   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} transposed\_matrix\_matrix\_product(\textcolor{keyword}{const} gene\_matrix & A, \textcolor{keyword}{const} gene\_matrix & B, 
      gene\_matrix & X, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00092     X.noalias() = A.transpose()*B.transpose();
00093   \}
00094 
00095 \textcolor{comment}{//   static inline void ata\_product(const gene\_matrix & A, gene\_matrix & X, int  /*N*/)\{}
00096 \textcolor{comment}{//     X.noalias() = A.transpose()*A;}
00097 \textcolor{comment}{//   \}}
00098 
00099   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} aat\_product(\textcolor{keyword}{const} gene\_matrix & A, gene\_matrix & X, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00100     X.template triangularView<Lower>().setZero();
00101     X.template selfadjointView<Lower>().rankUpdate(A);
00102   \}
00103 
00104   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} matrix\_vector\_product(\textcolor{keyword}{const} gene\_matrix & A, \textcolor{keyword}{const} gene\_vector & B, gene\_vector & X, \textcolor{keywordtype}{
      int}  \textcolor{comment}{/*N*/})\{
00105     X.noalias() = A*B;
00106   \}
00107 
00108   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} symv(\textcolor{keyword}{const} gene\_matrix & A, \textcolor{keyword}{const} gene\_vector & B, gene\_vector & X, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00109     X.noalias() = (A.template selfadjointView<Lower>() * B);
00110 \textcolor{comment}{//     internal::product\_selfadjoint\_vector<real,0,LowerTriangularBit,false,false>(N,A.data(),N, B.data(),
       1, X.data(), 1);}
00111   \}
00112 
00113   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest, \textcolor{keyword}{typename} Src> \textcolor{keyword}{static} \textcolor{keywordtype}{void} triassign(Dest& dst, \textcolor{keyword}{const} Src& src)
00114   \{
00115     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Dest::Scalar Scalar;
00116     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::packet\_traits<Scalar>::type} 
      \hyperlink{group___sparse_core___module}{Packet};
00117     \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = \textcolor{keyword}{sizeof}(Packet)/\textcolor{keyword}{sizeof}(Scalar);
00118     \textcolor{keywordtype}{int} size = dst.cols();
00119     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<size; j+=1)
00120     \{
00121 \textcolor{comment}{//       const int alignedEnd = alignedStart + ((innerSize-alignedStart) & ~packetAlignedMask);}
00122       Scalar* A0 = dst.data() + j*dst.stride();
00123       \textcolor{keywordtype}{int} starti = j;
00124       \textcolor{keywordtype}{int} alignedEnd = starti;
00125       \textcolor{keywordtype}{int} alignedStart = (starti) + internal::first\_aligned(&A0[starti], size-starti);
00126       alignedEnd = alignedStart + ((size-alignedStart)/(2*PacketSize))*(PacketSize*2);
00127 
00128       \textcolor{comment}{// do the non-vectorizable part of the assignment}
00129       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} index = starti; index<alignedStart ; ++index)
00130       \{
00131         \textcolor{keywordflow}{if}(Dest::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})
00132           dst.copyCoeff(j, index, src);
00133         \textcolor{keywordflow}{else}
00134           dst.copyCoeff(index, j, src);
00135       \}
00136 
00137       \textcolor{comment}{// do the vectorizable part of the assignment}
00138       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} index = alignedStart; index<alignedEnd; index+=PacketSize)
00139       \{
00140         \textcolor{keywordflow}{if}(Dest::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})
00141           dst.template copyPacket<Src, Aligned, Unaligned>(j, index, src);
00142         \textcolor{keywordflow}{else}
00143           dst.template copyPacket<Src, Aligned, Unaligned>(index, j, src);
00144       \}
00145 
00146       \textcolor{comment}{// do the non-vectorizable part of the assignment}
00147       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} index = alignedEnd; index<size; ++index)
00148       \{
00149         \textcolor{keywordflow}{if}(Dest::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})
00150           dst.copyCoeff(j, index, src);
00151         \textcolor{keywordflow}{else}
00152           dst.copyCoeff(index, j, src);
00153       \}
00154       \textcolor{comment}{//dst.col(j).tail(N-j) = src.col(j).tail(N-j);}
00155     \}
00156   \}
00157 
00158   \textcolor{keyword}{static} EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} syr2(gene\_matrix & A,  gene\_vector & X, gene\_vector & Y, \textcolor{keywordtype}{int}  N)\{
00159     \textcolor{comment}{// internal::product\_selfadjoint\_rank2\_update<real,0,LowerTriangularBit>(N,A.data(),N, X.data(), 1,
       Y.data(), 1, -1);}
00160     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<N; ++j)
00161       A.col(j).tail(N-j) += X[j] * Y.tail(N-j) + Y[j] * X.tail(N-j);
00162   \}
00163 
00164   \textcolor{keyword}{static} EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} ger(gene\_matrix & A,  gene\_vector & X, gene\_vector & Y, \textcolor{keywordtype}{int}  N)\{
00165     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<N; ++j)
00166       A.col(j) += X * Y[j];
00167   \}
00168 
00169   \textcolor{keyword}{static} EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} rot(gene\_vector & A,  gene\_vector & B, real c, real s, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00170     \hyperlink{namespace_eigen_1_1internal_a5f7738a5c56c9b9decf94d9728ba7906}{internal::apply\_rotation\_in\_the\_plane}(A, B, 
      \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<real>}(c,s));
00171   \}
00172 
00173   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} atv\_product(gene\_matrix & A, gene\_vector & B, gene\_vector & X, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00174     X.noalias() = (A.transpose()*B);
00175   \}
00176 
00177   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} axpy(real coef, \textcolor{keyword}{const} gene\_vector & X, gene\_vector & Y, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00178     Y += coef * X;
00179   \}
00180 
00181   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} axpby(real a, \textcolor{keyword}{const} gene\_vector & X, real b, gene\_vector & Y, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00182     Y = a*X + b*Y;
00183   \}
00184 
00185   \textcolor{keyword}{static} EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} copy\_matrix(\textcolor{keyword}{const} gene\_matrix & source, gene\_matrix & cible, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00186     cible = source;
00187   \}
00188 
00189   \textcolor{keyword}{static} EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} copy\_vector(\textcolor{keyword}{const} gene\_vector & source, gene\_vector & cible, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00190     cible = source;
00191   \}
00192 
00193   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} trisolve\_lower(\textcolor{keyword}{const} gene\_matrix & L, \textcolor{keyword}{const} gene\_vector& B, gene\_vector& X, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/}
      )\{
00194     X = L.template triangularView<Lower>().solve(B);
00195   \}
00196 
00197   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} trisolve\_lower\_matrix(\textcolor{keyword}{const} gene\_matrix & L, \textcolor{keyword}{const} gene\_matrix& B, gene\_matrix& X, \textcolor{keywordtype}{int}
        \textcolor{comment}{/*N*/})\{
00198     X = L.template triangularView<Upper>().solve(B);
00199   \}
00200 
00201   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} trmm(\textcolor{keyword}{const} gene\_matrix & L, \textcolor{keyword}{const} gene\_matrix& B, gene\_matrix& X, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00202     X.noalias() = L.template triangularView<Lower>() * B;
00203   \}
00204 
00205   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} cholesky(\textcolor{keyword}{const} gene\_matrix & X, gene\_matrix & \hyperlink{group___core___module}{C}, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00206     C = X;
00207     internal::llt\_inplace<real,Lower>::blocked(C);
00208     \textcolor{comment}{//C = X.llt().matrixL();}
00209 \textcolor{comment}{//     C = X;}
00210 \textcolor{comment}{//     Cholesky<gene\_matrix>::computeInPlace(C);}
00211 \textcolor{comment}{//     Cholesky<gene\_matrix>::computeInPlaceBlock(C);}
00212   \}
00213 
00214   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} lu\_decomp(\textcolor{keyword}{const} gene\_matrix & X, gene\_matrix & C, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00215     C = X.fullPivLu().matrixLU();
00216   \}
00217 
00218   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} partial\_lu\_decomp(\textcolor{keyword}{const} gene\_matrix & X, gene\_matrix & C, \textcolor{keywordtype}{int}  N)\{
00219     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<DenseIndex,1,Dynamic>} piv(N);
00220     DenseIndex nb;
00221     C = X;
00222     internal::partial\_lu\_inplace(C,piv,nb);
00223 \textcolor{comment}{//     C = X.partialPivLu().matrixLU();}
00224   \}
00225 
00226   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} tridiagonalization(\textcolor{keyword}{const} gene\_matrix & X, gene\_matrix & C, \textcolor{keywordtype}{int}  N)\{
00227     \textcolor{keyword}{typename} \hyperlink{group___core___module}{Tridiagonalization<gene\_matrix>::CoeffVectorType}
       aux(N-1);
00228     C = X;
00229     internal::tridiagonalization\_inplace(C, aux);
00230   \}
00231 
00232   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} hessenberg(\textcolor{keyword}{const} gene\_matrix & X, gene\_matrix & C, \textcolor{keywordtype}{int}  \textcolor{comment}{/*N*/})\{
00233     C = \hyperlink{group___eigenvalues___module_class_eigen_1_1_hessenberg_decomposition}{HessenbergDecomposition<gene\_matrix>}(X).packedMatrix();
00234   \}
00235 
00236 
00237 
00238 \};
00239 
00240 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
