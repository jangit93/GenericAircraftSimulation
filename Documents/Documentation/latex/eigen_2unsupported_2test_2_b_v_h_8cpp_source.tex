\hypertarget{eigen_2unsupported_2test_2_b_v_h_8cpp_source}{}\section{eigen/unsupported/test/\+B\+VH.cpp}
\label{eigen_2unsupported_2test_2_b_v_h_8cpp_source}\index{B\+V\+H.\+cpp@{B\+V\+H.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Ilya Baran <ibaran@mit.edu>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 \textcolor{preprocessor}{#include <Eigen/StdVector>}
00012 \textcolor{preprocessor}{#include <Eigen/Geometry>}
00013 \textcolor{preprocessor}{#include <unsupported/Eigen/BVH>}
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Dim> AlignedBox<Scalar, Dim> bounding\_box(\textcolor{keyword}{const} Matrix<Scalar, Dim, 1> &v) \{ \textcolor{keywordflow}{
      return} AlignedBox<Scalar, Dim>(v); \}
00018 
00019 \}
00020 
00021 
00022 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Dim>
\Hypertarget{eigen_2unsupported_2test_2_b_v_h_8cpp_source_l00023}\hyperlink{struct_ball}{00023} \textcolor{keyword}{struct }\hyperlink{struct_ball}{Ball}
00024 \{
00025 EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF\_VECTORIZABLE\_FIXED\_SIZE(\textcolor{keywordtype}{double}, Dim)
00026 
00027   \textcolor{keyword}{typedef} Matrix<double, Dim, 1> \hyperlink{struct_vector_type}{VectorType};
00028 
00029   \hyperlink{struct_ball}{Ball}() \{\}
00030   \hyperlink{struct_ball}{Ball}(\textcolor{keyword}{const} VectorType &c, \textcolor{keywordtype}{double} r) : center(c), radius(r) \{\}
00031 
00032   VectorType center;
00033   \textcolor{keywordtype}{double} radius;
00034 \};
00035 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Dim> AlignedBox<double, Dim> bounding\_box(\textcolor{keyword}{const} \hyperlink{struct_ball}{Ball<Dim>} &b)
00036 \{ \textcolor{keywordflow}{return} AlignedBox<double, Dim>(b.center.array() - b.radius, b.center.array() + b.radius); \}
00037 
00038 \textcolor{keyword}{inline} \textcolor{keywordtype}{double} SQR(\textcolor{keywordtype}{double} x) \{ \textcolor{keywordflow}{return} x * x; \}
00039 
00040 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Dim>
\Hypertarget{eigen_2unsupported_2test_2_b_v_h_8cpp_source_l00041}\hyperlink{struct_ball_point_stuff}{00041} \textcolor{keyword}{struct }\hyperlink{struct_ball_point_stuff}{BallPointStuff} \textcolor{comment}{//this class provides functions to be both an intersector and a
       minimizer, both for a ball and a point and for two trees}
00042 \{
00043   \textcolor{keyword}{typedef} \textcolor{keywordtype}{double} Scalar;
00044   \textcolor{keyword}{typedef} Matrix<double, Dim, 1> \hyperlink{struct_vector_type}{VectorType};
00045   \textcolor{keyword}{typedef} \hyperlink{struct_ball}{Ball<Dim>} \hyperlink{struct_ball}{BallType};
00046   \textcolor{keyword}{typedef} AlignedBox<double, Dim> BoxType;
00047 
00048   \hyperlink{struct_ball_point_stuff}{BallPointStuff}() : calls(0), count(0) \{\}
00049   \hyperlink{struct_ball_point_stuff}{BallPointStuff}(\textcolor{keyword}{const} VectorType &inP) : p(inP), calls(0), count(0) \{\}
00050 
00051 
00052   \textcolor{keywordtype}{bool} intersectVolume(\textcolor{keyword}{const} BoxType &r) \{ ++calls; \textcolor{keywordflow}{return} r.contains(p); \}
00053   \textcolor{keywordtype}{bool} intersectObject(\textcolor{keyword}{const} BallType &b) \{
00054     ++calls;
00055     \textcolor{keywordflow}{if}((b.center - p).squaredNorm() < SQR(b.radius))
00056       ++count;
00057     \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{//continue}
00058   \}
00059 
00060   \textcolor{keywordtype}{bool} intersectVolumeVolume(\textcolor{keyword}{const} BoxType &r1, \textcolor{keyword}{const} BoxType &r2) \{ ++calls; \textcolor{keywordflow}{return} !(r1.intersection(r2))
      .isNull(); \}
00061   \textcolor{keywordtype}{bool} intersectVolumeObject(\textcolor{keyword}{const} BoxType &r, \textcolor{keyword}{const} BallType &b) \{ ++calls; \textcolor{keywordflow}{return} r.
      squaredExteriorDistance(b.center) < SQR(b.radius); \}
00062   \textcolor{keywordtype}{bool} intersectObjectVolume(\textcolor{keyword}{const} BallType &b, \textcolor{keyword}{const} BoxType &r) \{ ++calls; \textcolor{keywordflow}{return} r.
      squaredExteriorDistance(b.center) < SQR(b.radius); \}
00063   \textcolor{keywordtype}{bool} intersectObjectObject(\textcolor{keyword}{const} BallType &b1, \textcolor{keyword}{const} BallType &b2)\{
00064     ++calls;
00065     \textcolor{keywordflow}{if}((b1.center - b2.center).norm() < b1.radius + b2.radius)
00066       ++count;
00067     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00068   \}
00069   \textcolor{keywordtype}{bool} intersectVolumeObject(\textcolor{keyword}{const} BoxType &r, \textcolor{keyword}{const} VectorType &v) \{ ++calls; \textcolor{keywordflow}{return} r.contains(v); \}
00070   \textcolor{keywordtype}{bool} intersectObjectObject(\textcolor{keyword}{const} BallType &b, \textcolor{keyword}{const} VectorType &v)\{
00071     ++calls;
00072     \textcolor{keywordflow}{if}((b.center - v).squaredNorm() < SQR(b.radius))
00073       ++count;
00074     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00075   \}
00076 
00077   \textcolor{keywordtype}{double} minimumOnVolume(\textcolor{keyword}{const} BoxType &r) \{ ++calls; \textcolor{keywordflow}{return} r.squaredExteriorDistance(p); \}
00078   \textcolor{keywordtype}{double} minimumOnObject(\textcolor{keyword}{const} BallType &b) \{ ++calls; \textcolor{keywordflow}{return} (std::max)(0., (b.center - p).squaredNorm() -
       SQR(b.radius)); \}
00079   \textcolor{keywordtype}{double} minimumOnVolumeVolume(\textcolor{keyword}{const} BoxType &r1, \textcolor{keyword}{const} BoxType &r2) \{ ++calls; \textcolor{keywordflow}{return} r1.
      squaredExteriorDistance(r2); \}
00080   \textcolor{keywordtype}{double} minimumOnVolumeObject(\textcolor{keyword}{const} BoxType &r, \textcolor{keyword}{const} BallType &b) \{ ++calls; \textcolor{keywordflow}{return} SQR((std::max)(0., r.
      exteriorDistance(b.center) - b.radius)); \}
00081   \textcolor{keywordtype}{double} minimumOnObjectVolume(\textcolor{keyword}{const} BallType &b, \textcolor{keyword}{const} BoxType &r) \{ ++calls; \textcolor{keywordflow}{return} SQR((std::max)(0., r.
      exteriorDistance(b.center) - b.radius)); \}
00082   \textcolor{keywordtype}{double} minimumOnObjectObject(\textcolor{keyword}{const} BallType &b1, \textcolor{keyword}{const} BallType &b2)\{ ++calls; \textcolor{keywordflow}{return} SQR((std::max)(0., 
      (b1.center - b2.center).norm() - b1.radius - b2.radius)); \}
00083   \textcolor{keywordtype}{double} minimumOnVolumeObject(\textcolor{keyword}{const} BoxType &r, \textcolor{keyword}{const} VectorType &v) \{ ++calls; \textcolor{keywordflow}{return} r.
      squaredExteriorDistance(v); \}
00084   \textcolor{keywordtype}{double} minimumOnObjectObject(\textcolor{keyword}{const} BallType &b, \textcolor{keyword}{const} VectorType &v)\{ ++calls; \textcolor{keywordflow}{return} SQR((std::max)(0., 
      (b.center - v).norm() - b.radius)); \}
00085 
00086   VectorType p;
00087   \textcolor{keywordtype}{int} calls;
00088   \textcolor{keywordtype}{int} count;
00089 \};
00090 
00091 
00092 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Dim>
\Hypertarget{eigen_2unsupported_2test_2_b_v_h_8cpp_source_l00093}\hyperlink{struct_tree_test}{00093} \textcolor{keyword}{struct }\hyperlink{struct_tree_test}{TreeTest}
00094 \{
00095   \textcolor{keyword}{typedef} Matrix<double, Dim, 1> \hyperlink{struct_vector_type}{VectorType};
00096   \textcolor{keyword}{typedef} std::vector<VectorType, aligned\_allocator<VectorType> > VectorTypeList;
00097   \textcolor{keyword}{typedef} \hyperlink{struct_ball}{Ball<Dim>} \hyperlink{struct_ball}{BallType};
00098   \textcolor{keyword}{typedef} std::vector<BallType, aligned\_allocator<BallType> > BallTypeList;
00099   \textcolor{keyword}{typedef} AlignedBox<double, Dim> BoxType;
00100 
00101   \textcolor{keywordtype}{void} testIntersect1()
00102   \{
00103     BallTypeList b;
00104     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 500; ++i) \{
00105         b.push\_back(BallType(VectorType::Random(), 0.5 * internal::random(0., 1.)));
00106     \}
00107     KdBVH<double, Dim, BallType> tree(b.begin(), b.end());
00108 
00109     VectorType pt = VectorType::Random();
00110     \hyperlink{struct_ball_point_stuff}{BallPointStuff<Dim>} i1(pt), i2(pt);
00111 
00112     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < (int)b.size(); ++i)
00113       i1.intersectObject(b[i]);
00114 
00115     \hyperlink{namespace_eigen_a07d8e283f082c972338f3fc4f644b2a9}{BVIntersect}(tree, i2);
00116 
00117     VERIFY(i1.count == i2.count);
00118   \}
00119 
00120   \textcolor{keywordtype}{void} testMinimize1()
00121   \{
00122     BallTypeList b;
00123     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 500; ++i) \{
00124         b.push\_back(BallType(VectorType::Random(), 0.01 * internal::random(0., 1.)));
00125     \}
00126     KdBVH<double, Dim, BallType> tree(b.begin(), b.end());
00127 
00128     VectorType pt = VectorType::Random();
00129     \hyperlink{struct_ball_point_stuff}{BallPointStuff<Dim>} i1(pt), i2(pt);
00130 
00131     \textcolor{keywordtype}{double} m1 = (std::numeric\_limits<double>::max)(), m2 = m1;
00132 
00133     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < (int)b.size(); ++i)
00134       m1 = (std::min)(m1, i1.minimumOnObject(b[i]));
00135 
00136     m2 = \hyperlink{namespace_eigen_adcbe73ac1482eacab0e18ee32c25508e}{BVMinimize}(tree, i2);
00137 
00138     VERIFY\_IS\_APPROX(m1, m2);
00139   \}
00140 
00141   \textcolor{keywordtype}{void} testIntersect2()
00142   \{
00143     BallTypeList b;
00144     VectorTypeList v;
00145 
00146     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 50; ++i) \{
00147         b.push\_back(BallType(VectorType::Random(), 0.5 * internal::random(0., 1.)));
00148         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < 3; ++j)
00149             v.push\_back(VectorType::Random());
00150     \}
00151 
00152     KdBVH<double, Dim, BallType> tree(b.begin(), b.end());
00153     KdBVH<double, Dim, VectorType> vTree(v.begin(), v.end());
00154 
00155     \hyperlink{struct_ball_point_stuff}{BallPointStuff<Dim>} i1, i2;
00156 
00157     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < (int)b.size(); ++i)
00158         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < (int)v.size(); ++j)
00159             i1.intersectObjectObject(b[i], v[j]);
00160 
00161     \hyperlink{namespace_eigen_a07d8e283f082c972338f3fc4f644b2a9}{BVIntersect}(tree, vTree, i2);
00162 
00163     VERIFY(i1.count == i2.count);
00164   \}
00165 
00166   \textcolor{keywordtype}{void} testMinimize2()
00167   \{
00168     BallTypeList b;
00169     VectorTypeList v;
00170 
00171     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 50; ++i) \{
00172         b.push\_back(BallType(VectorType::Random(), 1e-7 + 1e-6 * internal::random(0., 1.)));
00173         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < 3; ++j)
00174             v.push\_back(VectorType::Random());
00175     \}
00176 
00177     KdBVH<double, Dim, BallType> tree(b.begin(), b.end());
00178     KdBVH<double, Dim, VectorType> vTree(v.begin(), v.end());
00179 
00180     \hyperlink{struct_ball_point_stuff}{BallPointStuff<Dim>} i1, i2;
00181 
00182     \textcolor{keywordtype}{double} m1 = (std::numeric\_limits<double>::max)(), m2 = m1;
00183 
00184     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < (int)b.size(); ++i)
00185         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < (int)v.size(); ++j)
00186             m1 = (std::min)(m1, i1.minimumOnObjectObject(b[i], v[j]));
00187 
00188     m2 = \hyperlink{namespace_eigen_adcbe73ac1482eacab0e18ee32c25508e}{BVMinimize}(tree, vTree, i2);
00189 
00190     VERIFY\_IS\_APPROX(m1, m2);
00191   \}
00192 \};
00193 
00194 
00195 \textcolor{keywordtype}{void} test\_BVH()
00196 \{
00197   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00198 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_1}
00199     \hyperlink{struct_tree_test}{TreeTest<2>} test2;
00200     CALL\_SUBTEST(test2.testIntersect1());
00201     CALL\_SUBTEST(test2.testMinimize1());
00202     CALL\_SUBTEST(test2.testIntersect2());
00203     CALL\_SUBTEST(test2.testMinimize2());
00204 \textcolor{preprocessor}{#endif}
00205 
00206 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_2}
00207     \hyperlink{struct_tree_test}{TreeTest<3>} test3;
00208     CALL\_SUBTEST(test3.testIntersect1());
00209     CALL\_SUBTEST(test3.testMinimize1());
00210     CALL\_SUBTEST(test3.testIntersect2());
00211     CALL\_SUBTEST(test3.testMinimize2());
00212 \textcolor{preprocessor}{#endif}
00213 
00214 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_3}
00215     \hyperlink{struct_tree_test}{TreeTest<4>} test4;
00216     CALL\_SUBTEST(test4.testIntersect1());
00217     CALL\_SUBTEST(test4.testMinimize1());
00218     CALL\_SUBTEST(test4.testIntersect2());
00219     CALL\_SUBTEST(test4.testMinimize2());
00220 \textcolor{preprocessor}{#endif}
00221   \}
00222 \}
\end{DoxyCode}
