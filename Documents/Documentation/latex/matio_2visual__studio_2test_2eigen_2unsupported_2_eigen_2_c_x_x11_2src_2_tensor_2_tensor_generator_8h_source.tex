\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_generator_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Generator.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_generator_8h_source}\index{Tensor\+Generator.\+h@{Tensor\+Generator.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_GENERATOR\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_GENERATOR\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Generator, \textcolor{keyword}{typename} XprType>
00024 \textcolor{keyword}{struct }traits<TensorGeneratorOp<Generator, XprType> > : \textcolor{keyword}{public} traits<XprType>
00025 \{
00026   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00027   \textcolor{keyword}{typedef} traits<XprType> XprTraits;
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<Nested>::type \_Nested;
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00034 \};
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Generator, \textcolor{keyword}{typename} XprType>
00037 \textcolor{keyword}{struct }eval<TensorGeneratorOp<Generator, XprType>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00038 \{
00039   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorGeneratorOp<Generator, XprType>& type;
00040 \};
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Generator, \textcolor{keyword}{typename} XprType>
00043 \textcolor{keyword}{struct }nested<TensorGeneratorOp<Generator, XprType>, 1, typename eval<TensorGeneratorOp<Generator, XprType>
       >::type>
00044 \{
00045   \textcolor{keyword}{typedef} TensorGeneratorOp<Generator, XprType> type;
00046 \};
00047 
00048 \}  \textcolor{comment}{// end namespace internal}
00049 
00050 
00051 
00052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Generator, \textcolor{keyword}{typename} XprType>
00053 \textcolor{keyword}{class }TensorGeneratorOp : \textcolor{keyword}{public} TensorBase<TensorGeneratorOp<Generator, XprType>, ReadOnlyAccessors>
00054 \{
00055   \textcolor{keyword}{public}:
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorGeneratorOp>::Scalar}
       Scalar;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorGeneratorOp>::type}
       Nested;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorGeneratorOp>::StorageKind}
       StorageKind;
00061   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorGeneratorOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00062 
00063   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorGeneratorOp(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} Generator& generator)
00064       : m\_xpr(expr), m\_generator(generator) \{\}
00065 
00066     EIGEN\_DEVICE\_FUNC
00067     \textcolor{keyword}{const} Generator& generator()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_generator; \}
00068 
00069     EIGEN\_DEVICE\_FUNC
00070     \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type&
00071     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00072 
00073   \textcolor{keyword}{protected}:
00074     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00075     \textcolor{keyword}{const} Generator m\_generator;
00076 \};
00077 
00078 
00079 \textcolor{comment}{// Eval as rvalue}
00080 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Generator, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00081 \textcolor{keyword}{struct }TensorEvaluator<const TensorGeneratorOp<Generator, ArgType>, Device>
00082 \{
00083   \textcolor{keyword}{typedef} TensorGeneratorOp<Generator, ArgType> XprType;
00084   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00085   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} TensorEvaluator<ArgType, Device>::Dimensions Dimensions;
00086   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::array\_size<Dimensions>::value;
00087   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00088   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00089   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00090   \textcolor{keyword}{enum} \{
00091     IsAligned = \textcolor{keyword}{false},
00092     PacketAccess = (internal::unpacket\_traits<PacketReturnType>::size > 1),
00093     BlockAccess = \textcolor{keyword}{false},
00094     Layout = TensorEvaluator<ArgType, Device>::Layout,
00095     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00096     RawAccess = \textcolor{keyword}{false}
00097   \};
00098 
00099   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00100       : m\_generator(op.generator())
00101   \{
00102     TensorEvaluator<ArgType, Device> impl(op.expression(), device);
00103     m\_dimensions = impl.dimensions();
00104 
00105     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00106       m\_strides[0] = 1;
00107       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00108         m\_strides[i] = m\_strides[i - 1] * m\_dimensions[i - 1];
00109       \}
00110     \} \textcolor{keywordflow}{else} \{
00111       m\_strides[NumDims - 1] = 1;
00112       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00113         m\_strides[i] = m\_strides[i + 1] * m\_dimensions[i + 1];
00114       \}
00115     \}
00116   \}
00117 
00118   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00119 
00120   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/}) \{
00121     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00122   \}
00123   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00124   \}
00125 
00126   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00127 \textcolor{keyword}{  }\{
00128     array<Index, NumDims> coords;
00129     extract\_coordinates(index, coords);
00130     \textcolor{keywordflow}{return} m\_generator(coords);
00131   \}
00132 
00133   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00134   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00135 \textcolor{keyword}{  }\{
00136     \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetSize = internal::unpacket\_traits<PacketReturnType>::size;
00137     EIGEN\_STATIC\_ASSERT((packetSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00138     eigen\_assert(index+packetSize-1 < dimensions().TotalSize());
00139 
00140     EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} internal::remove\_const<CoeffReturnType>::type values[packetSize];
00141     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < packetSize; ++i) \{
00142       values[i] = coeff(index+i);
00143     \}
00144     PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00145     \textcolor{keywordflow}{return} rslt;
00146   \}
00147 
00148   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorOpCost
00149   costPerCoeff(\textcolor{keywordtype}{bool})\textcolor{keyword}{ const }\{
00150     \textcolor{comment}{// TODO(rmlarsen): This is just a placeholder. Define interface to make}
00151     \textcolor{comment}{// generators return their cost.}
00152     \textcolor{keywordflow}{return} TensorOpCost(0, 0, TensorOpCost::AddCost<Scalar>() +
00153                                   TensorOpCost::MulCost<Scalar>());
00154   \}
00155 
00156   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00157 
00158  \textcolor{keyword}{protected}:
00159   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00160   \textcolor{keywordtype}{void} extract\_coordinates(Index index, array<Index, NumDims>& coords)\textcolor{keyword}{ const }\{
00161     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00162       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00163         \textcolor{keyword}{const} Index idx = index / m\_strides[i];
00164         index -= idx * m\_strides[i];
00165         coords[i] = idx;
00166       \}
00167       coords[0] = index;
00168     \} \textcolor{keywordflow}{else} \{
00169       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00170         \textcolor{keyword}{const} Index idx = index / m\_strides[i];
00171         index -= idx * m\_strides[i];
00172         coords[i] = idx;
00173       \}
00174       coords[NumDims-1] = index;
00175     \}
00176   \}
00177 
00178   Dimensions m\_dimensions;
00179   array<Index, NumDims> m\_strides;
00180   Generator m\_generator;
00181 \};
00182 
00183 \} \textcolor{comment}{// end namespace Eigen}
00184 
00185 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_GENERATOR\_H}
\end{DoxyCode}
