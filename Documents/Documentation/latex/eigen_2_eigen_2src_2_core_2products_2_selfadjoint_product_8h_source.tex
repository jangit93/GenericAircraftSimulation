\hypertarget{eigen_2_eigen_2src_2_core_2products_2_selfadjoint_product_8h_source}{}\section{eigen/\+Eigen/src/\+Core/products/\+Selfadjoint\+Product.h}
\label{eigen_2_eigen_2src_2_core_2products_2_selfadjoint_product_8h_source}\index{Selfadjoint\+Product.\+h@{Selfadjoint\+Product.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SELFADJOINT\_PRODUCT\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SELFADJOINT\_PRODUCT\_H}
00012 
00013 \textcolor{comment}{/**********************************************************************}
00014 \textcolor{comment}{* This file implements a self adjoint product: C += A A^T updating only}
00015 \textcolor{comment}{* half of the selfadjoint matrix C.}
00016 \textcolor{comment}{* It corresponds to the level 3 SYRK and level 2 SYR Blas routines.}
00017 \textcolor{comment}{**********************************************************************/}
00018 
00019 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00020 
00021 
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} UpLo, \textcolor{keywordtype}{bool} ConjLhs, \textcolor{keywordtype}{bool} ConjRhs>
\Hypertarget{eigen_2_eigen_2src_2_core_2products_2_selfadjoint_product_8h_source_l00023}\hyperlink{struct_eigen_1_1selfadjoint__rank1__update_3_01_scalar_00_01_index_00_01_col_major_00_01_up_lo_0985162e7429113fdcd7a3950b8d00f1e}{00023} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1selfadjoint__rank1__update}{selfadjoint\_rank1\_update}<Scalar,\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},UpLo,ConjLhs,ConjRhs>
00024 \{
00025   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size, Scalar* mat, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride, \textcolor{keyword}{const} Scalar* vecX, \textcolor{keyword}{const} Scalar* vecY, \textcolor{keyword}{
      const} Scalar& alpha)
00026   \{
00027     \hyperlink{struct_eigen_1_1internal_1_1conj__if}{internal::conj\_if<ConjRhs>} cj;
00028     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Matrix<Scalar,Dynamic,1>} > OtherMap;
00029     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::conditional<ConjLhs,typename OtherMap::ConjugateReturnType,const OtherMap&>::type}
       ConjLhsType;
00030     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<size; ++i)
00031     \{
00032       \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<Scalar,Dynamic,1>} >(mat+stride*i+(UpLo==
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} ? i : 0), (UpLo==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} ? size-i : (i+1)))
00033           += (alpha * cj(vecY[i])) * ConjLhsType(OtherMap(vecX+(UpLo==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} ? i : 0),UpLo==
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} ? size-i : (i+1)));
00034     \}
00035   \}
00036 \};
00037 
00038 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} UpLo, \textcolor{keywordtype}{bool} ConjLhs, \textcolor{keywordtype}{bool} ConjRhs>
\Hypertarget{eigen_2_eigen_2src_2_core_2products_2_selfadjoint_product_8h_source_l00039}\hyperlink{struct_eigen_1_1selfadjoint__rank1__update_3_01_scalar_00_01_index_00_01_row_major_00_01_up_lo_03a9dcf0deae11b1da493e4caae5cd21a}{00039} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1selfadjoint__rank1__update}{selfadjoint\_rank1\_update}<Scalar,\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},UpLo,ConjLhs,ConjRhs>
00040 \{
00041   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size, Scalar* mat, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride, \textcolor{keyword}{const} Scalar* vecX, \textcolor{keyword}{const} Scalar* vecY, \textcolor{keyword}{
      const} Scalar& alpha)
00042   \{
00043     
      \hyperlink{struct_eigen_1_1selfadjoint__rank1__update}{selfadjoint\_rank1\_update<Scalar,Index,ColMajor,UpLo==Lower?Upper:Lower,ConjRhs,ConjLhs>::run}
      (size,mat,stride,vecY,vecX,alpha);
00044   \}
00045 \};
00046 
00047 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} OtherType, \textcolor{keywordtype}{int} UpLo, \textcolor{keywordtype}{bool} OtherIsVector = OtherType::IsVectorAtCompi
      leTime>
\Hypertarget{eigen_2_eigen_2src_2_core_2products_2_selfadjoint_product_8h_source_l00048}\hyperlink{struct_eigen_1_1selfadjoint__product__selector}{00048} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1selfadjoint__product__selector}{selfadjoint\_product\_selector};
00049 
00050 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} OtherType, \textcolor{keywordtype}{int} UpLo>
\Hypertarget{eigen_2_eigen_2src_2_core_2products_2_selfadjoint_product_8h_source_l00051}\hyperlink{struct_eigen_1_1selfadjoint__product__selector_3_01_matrix_type_00_01_other_type_00_01_up_lo_00_01true_01_4}{00051} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1selfadjoint__product__selector}{selfadjoint\_product\_selector}<MatrixType,OtherType,UpLo,true>
00052 \{
00053   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType& mat, \textcolor{keyword}{const} OtherType& other, \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::Scalar& alpha)
00054   \{
00055     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00056     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{internal::blas\_traits<OtherType>} OtherBlasTraits;
00057     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} OtherBlasTraits::DirectLinearAccessType ActualOtherType;
00058     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<ActualOtherType>::type}
       \_ActualOtherType;
00059     \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::add\_const\_on\_value\_type<ActualOtherType>::type}
       actualOther = OtherBlasTraits::extract(other.derived());
00060 
00061     Scalar actualAlpha = alpha * OtherBlasTraits::extractScalarFactor(other.derived());
00062 
00063     \textcolor{keyword}{enum} \{
00064       StorageOrder = (\hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<MatrixType>::Flags}&
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},
00065       UseOtherDirectly = \_ActualOtherType::InnerStrideAtCompileTime==1
00066     \};
00067     
      \hyperlink{struct_eigen_1_1internal_1_1gemv__static__vector__if}{
      internal::gemv\_static\_vector\_if<Scalar,OtherType::SizeAtCompileTime,OtherType::MaxSizeAtCompileTime,!UseOtherDirectly>}
       static\_other;
00068 
00069     ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, actualOtherPtr, other.size(),
00070       (UseOtherDirectly ? \textcolor{keyword}{const\_cast<}Scalar*\textcolor{keyword}{>}(actualOther.data()) : static\_other.data()));
00071       
00072     \textcolor{keywordflow}{if}(!UseOtherDirectly)
00073       \hyperlink{group___core___module_class_eigen_1_1_map}{Map<typename \_ActualOtherType::PlainObject>}(actualOtherPtr
      , actualOther.size()) = actualOther;
00074     
00075     \hyperlink{struct_eigen_1_1selfadjoint__rank1__update}{selfadjoint\_rank1\_update}<Scalar,\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},StorageOrder,UpLo,
00076                               OtherBlasTraits::NeedToConjugate  && 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsComplex},
00077                             (!OtherBlasTraits::NeedToConjugate) && NumTraits<Scalar>::IsComplex>
00078           ::run(other.size(), mat.data(), mat.outerStride(), actualOtherPtr, actualOtherPtr, actualAlpha);
00079   \}
00080 \};
00081 
00082 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} OtherType, \textcolor{keywordtype}{int} UpLo>
\Hypertarget{eigen_2_eigen_2src_2_core_2products_2_selfadjoint_product_8h_source_l00083}\hyperlink{struct_eigen_1_1selfadjoint__product__selector_3_01_matrix_type_00_01_other_type_00_01_up_lo_00_01false_01_4}{00083} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1selfadjoint__product__selector}{selfadjoint\_product\_selector}<MatrixType,OtherType,UpLo,false>
00084 \{
00085   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType& mat, \textcolor{keyword}{const} OtherType& other, \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::Scalar& alpha)
00086   \{
00087     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00088     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{internal::blas\_traits<OtherType>} OtherBlasTraits;
00089     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} OtherBlasTraits::DirectLinearAccessType ActualOtherType;
00090     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<ActualOtherType>::type}
       \_ActualOtherType;
00091     \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::add\_const\_on\_value\_type<ActualOtherType>::type}
       actualOther = OtherBlasTraits::extract(other.derived());
00092 
00093     Scalar actualAlpha = alpha * OtherBlasTraits::extractScalarFactor(other.derived());
00094 
00095     \textcolor{keyword}{enum} \{
00096       IsRowMajor = (\hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<MatrixType>::Flags}&
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? 1 : 0,
00097       OtherIsRowMajor = \_ActualOtherType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} ? 1 : 0
00098     \};
00099 
00100     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = mat.cols();
00101     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth = actualOther.cols();
00102 
00103     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1gemm__blocking__space}{internal::gemm\_blocking\_space}<IsRowMajor ? 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},Scalar,Scalar,
00104               MatrixType::MaxColsAtCompileTime, MatrixType::MaxColsAtCompileTime, 
      \_ActualOtherType::MaxColsAtCompileTime> BlockingType;
00105 
00106     BlockingType blocking(size, size, depth, 1, \textcolor{keyword}{false});
00107 
00108 
00109     \hyperlink{struct_eigen_1_1internal_1_1general__matrix__matrix__triangular__product}{internal::general\_matrix\_matrix\_triangular\_product}<
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00110       Scalar, OtherIsRowMajor ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},   OtherBlasTraits::NeedToConjugate  &&
       \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsComplex},
00111       Scalar, OtherIsRowMajor ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}, (!OtherBlasTraits::NeedToConjugate) &&
       NumTraits<Scalar>::IsComplex,
00112       IsRowMajor ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}, UpLo>
00113       ::run(size, depth,
00114             &actualOther.coeffRef(0,0), actualOther.outerStride(), &actualOther.coeffRef(0,0), actualOther.
      outerStride(),
00115             mat.data(), mat.outerStride(), actualAlpha, blocking);
00116   \}
00117 \};
00118 
00119 \textcolor{comment}{// high level API}
00120 
00121 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} UpLo>
00122 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedU>
00123 \hyperlink{group___core___module_class_eigen_1_1_self_adjoint_view}{SelfAdjointView<MatrixType,UpLo>}& 
      \hyperlink{group___core___module_a4739585861baa13b25dcce5ed6658311}{SelfAdjointView<MatrixType,UpLo>}
00124 \hyperlink{group___core___module_a4739585861baa13b25dcce5ed6658311}{::rankUpdate}(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<DerivedU>}& u, \textcolor{keyword}{const} Scalar& alpha)
00125 \{
00126   \hyperlink{struct_eigen_1_1selfadjoint__product__selector}{selfadjoint\_product\_selector<MatrixType,DerivedU,UpLo>::run}
      (\_expression().const\_cast\_derived(), u.derived(), alpha);
00127 
00128   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00129 \}
00130 
00131 \} \textcolor{comment}{// end namespace Eigen}
00132 
00133 \textcolor{preprocessor}{#endif // EIGEN\_SELFADJOINT\_PRODUCT\_H}
\end{DoxyCode}
