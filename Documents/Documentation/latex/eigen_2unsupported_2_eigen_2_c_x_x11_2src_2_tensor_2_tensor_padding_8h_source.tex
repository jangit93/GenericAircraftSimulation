\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_padding_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Padding.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_padding_8h_source}\index{Tensor\+Padding.\+h@{Tensor\+Padding.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_PADDING\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_PADDING\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PaddingDimensions, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_padding_8h_source_l00024}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_padding_op_3_01_padding_dimensions_00_01_xpr_type_01_4_01_4}{00024} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_padding_op}{TensorPaddingOp}<PaddingDimensions, XprType> > : \textcolor{keyword}{public} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<XprType>
00025 \{
00026   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00027   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>} \hyperlink{struct_eigen_1_1internal_1_1traits}{XprTraits};
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<Nested>::type} 
      \hyperlink{group___sparse_core___module}{\_Nested};
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00034 \};
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PaddingDimensions, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_padding_8h_source_l00037}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_padding_op_3_01_padding_dimensions_00_01_xpr_type_01_4_00_01_eigen_1_1_dense_01_4}{00037} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_padding_op}{TensorPaddingOp}<PaddingDimensions, XprType>, 
      \hyperlink{namespace_eigen}{Eigen}::\hyperlink{struct_eigen_1_1_dense}{Dense}>
00038 \{
00039   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_padding_op}{TensorPaddingOp<PaddingDimensions, XprType>}& 
      \hyperlink{class_eigen_1_1_tensor_padding_op}{type};
00040 \};
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PaddingDimensions, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_padding_8h_source_l00043}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_padding_op_3_01_padding_dimensions_00_01_xpr_type5274dc122ae52b0a0b0b3a8c02d9f9cb}{00043} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_padding_op}{TensorPaddingOp}<PaddingDimensions, XprType>, 1, typename 
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_padding_op}{TensorPaddingOp}<PaddingDimensions, XprType> >::\hyperlink{class_eigen_1_1_tensor_padding_op}{type}>
00044 \{
00045   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_padding_op}{TensorPaddingOp<PaddingDimensions, XprType>} 
      \hyperlink{class_eigen_1_1_tensor_padding_op}{type};
00046 \};
00047 
00048 \}  \textcolor{comment}{// end namespace internal}
00049 
00050 
00051 
00052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PaddingDimensions, \textcolor{keyword}{typename} XprType>
00053 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_padding_op}{TensorPaddingOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorPaddingOp<PaddingDimensions, XprTy
      pe>, ReadOnlyAccessors>
00054 \{
00055   \textcolor{keyword}{public}:
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorPaddingOp>::Scalar}
       Scalar;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorPaddingOp>::type}
       Nested;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorPaddingOp>::StorageKind}
       StorageKind;
00061   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorPaddingOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00062 
00063   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_padding_op}{TensorPaddingOp}(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} 
      PaddingDimensions& padding\_dims, \textcolor{keyword}{const} Scalar padding\_value)
00064       : m\_xpr(expr), m\_padding\_dims(padding\_dims), m\_padding\_value(padding\_value) \{\}
00065 
00066     EIGEN\_DEVICE\_FUNC
00067     \textcolor{keyword}{const} PaddingDimensions& padding()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_dims; \}
00068     EIGEN\_DEVICE\_FUNC
00069     Scalar padding\_value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_value; \}
00070 
00071     EIGEN\_DEVICE\_FUNC
00072     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename XprType::Nested>::type}
      &
00073     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00074 
00075   \textcolor{keyword}{protected}:
00076     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00077     \textcolor{keyword}{const} PaddingDimensions m\_padding\_dims;
00078     \textcolor{keyword}{const} Scalar m\_padding\_value;
00079 \};
00080 
00081 
00082 \textcolor{comment}{// Eval as rvalue}
00083 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PaddingDimensions, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_padding_8h_source_l00084}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_padding_op_3_01_padding_dimensions_00_01_arg_type_01_4_00_01_device_01_4}{00084} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_padding_op}{TensorPaddingOp}<PaddingDimensions, ArgType>, 
      Device>
00085 \{
00086   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_padding_op}{TensorPaddingOp<PaddingDimensions, ArgType>} 
      \hyperlink{class_eigen_1_1_tensor_padding_op}{XprType};
00087   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00088   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<PaddingDimensions>::value}
      ;
00089   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumDims>} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00090   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00091   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00092   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00093   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size};
00094 
00095   \textcolor{keyword}{enum} \{
00096     IsAligned = \textcolor{keyword}{true},
00097     PacketAccess = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::PacketAccess}
      ,
00098     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Layout},
00099     CoordAccess = \textcolor{keyword}{true},
00100     RawAccess = \textcolor{keyword}{false}
00101   \};
00102 
00103   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00104       : m\_impl(op.expression(), device), m\_padding(op.padding()), m\_paddingValue(op.padding\_value())
00105   \{
00106     \textcolor{comment}{// The padding op doesn't change the rank of the tensor. Directly padding a scalar would lead}
00107     \textcolor{comment}{// to a vector, which doesn't make sense. Instead one should reshape the scalar into a vector}
00108     \textcolor{comment}{// of 1 element first and then pad.}
00109     EIGEN\_STATIC\_ASSERT((NumDims > 0), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00110 
00111     \textcolor{comment}{// Compute dimensions}
00112     m\_dimensions = m\_impl.dimensions();
00113     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i) \{
00114       m\_dimensions[i] += m\_padding[i].first + m\_padding[i].second;
00115     \}
00116     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Dimensions}
      & input\_dims = m\_impl.dimensions();
00117     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00118       m\_inputStrides[0] = 1;
00119       m\_outputStrides[0] = 1;
00120       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00121         m\_inputStrides[i] = m\_inputStrides[i-1] * input\_dims[i-1];
00122         m\_outputStrides[i] = m\_outputStrides[i-1] * m\_dimensions[i-1];
00123       \}
00124       m\_outputStrides[NumDims] = m\_outputStrides[NumDims-1] * m\_dimensions[NumDims-1];
00125     \} \textcolor{keywordflow}{else} \{
00126       m\_inputStrides[NumDims - 1] = 1;
00127       m\_outputStrides[NumDims] = 1;
00128       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00129         m\_inputStrides[i] = m\_inputStrides[i+1] * input\_dims[i+1];
00130         m\_outputStrides[i+1] = m\_outputStrides[i+2] * m\_dimensions[i+1];
00131       \}
00132       m\_outputStrides[0] = m\_outputStrides[1] * m\_dimensions[0];
00133     \}
00134   \}
00135 
00136   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00137 
00138   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar*) \{
00139     m\_impl.evalSubExprsIfNeeded(NULL);
00140     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00141   \}
00142   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00143     m\_impl.cleanup();
00144   \}
00145 
00146   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00147 \textcolor{keyword}{  }\{
00148     eigen\_assert(index < dimensions().TotalSize());
00149     Index inputIndex = 0;
00150     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00151       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00152         \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00153         \textcolor{keywordflow}{if} (isPaddingAtIndexForDim(idx, i)) \{
00154           \textcolor{keywordflow}{return} m\_paddingValue;
00155         \}
00156         inputIndex += (idx - m\_padding[i].first) * m\_inputStrides[i];
00157         index -= idx * m\_outputStrides[i];
00158       \}
00159       \textcolor{keywordflow}{if} (isPaddingAtIndexForDim(index, 0)) \{
00160         \textcolor{keywordflow}{return} m\_paddingValue;
00161       \}
00162       inputIndex += (index - m\_padding[0].first);
00163     \} \textcolor{keywordflow}{else} \{
00164       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00165         \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i+1];
00166         \textcolor{keywordflow}{if} (isPaddingAtIndexForDim(idx, i)) \{
00167           \textcolor{keywordflow}{return} m\_paddingValue;
00168         \}
00169         inputIndex += (idx - m\_padding[i].first) * m\_inputStrides[i];
00170         index -= idx * m\_outputStrides[i+1];
00171       \}
00172       \textcolor{keywordflow}{if} (isPaddingAtIndexForDim(index, NumDims-1)) \{
00173         \textcolor{keywordflow}{return} m\_paddingValue;
00174       \}
00175       inputIndex += (index - m\_padding[NumDims-1].first);
00176     \}
00177     \textcolor{keywordflow}{return} m\_impl.coeff(inputIndex);
00178   \}
00179 
00180   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00181   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00182 \textcolor{keyword}{  }\{
00183     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00184       \textcolor{keywordflow}{return} packetColMajor(index);
00185     \}
00186     \textcolor{keywordflow}{return} packetRowMajor(index);
00187   \}
00188 
00189   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost} costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00190     \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost} cost = m\_impl.costPerCoeff(vectorized);
00191     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00192       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i)
00193         updateCostPerDimension(cost, i, i == 0);
00194     \} \textcolor{keywordflow}{else} \{
00195       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i >= 0; --i)
00196         updateCostPerDimension(cost, i, i == NumDims - 1);
00197     \}
00198     \textcolor{keywordflow}{return} cost;
00199   \}
00200 
00201   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00202 
00203  \textcolor{keyword}{private}:
00204   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \textcolor{keywordtype}{bool} isPaddingAtIndexForDim(
00205       Index index, \textcolor{keywordtype}{int} dim\_index)\textcolor{keyword}{ const }\{
00206 \textcolor{preprocessor}{#if defined(EIGEN\_HAS\_INDEX\_LIST)}
00207     \textcolor{keywordflow}{return} (!internal::index\_pair\_first\_statically\_eq<PaddingDimensions>(dim\_index, 0) &&
00208             index < m\_padding[dim\_index].first) ||
00209         (!internal::index\_pair\_second\_statically\_eq<PaddingDimensions>(dim\_index, 0) &&
00210          index >= m\_dimensions[dim\_index] - m\_padding[dim\_index].second);
00211 \textcolor{preprocessor}{#else}
00212     \textcolor{keywordflow}{return} (index < m\_padding[dim\_index].first) ||
00213            (index >= m\_dimensions[dim\_index] - m\_padding[dim\_index].second);
00214 \textcolor{preprocessor}{#endif}
00215   \}
00216 
00217   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \textcolor{keywordtype}{bool} isLeftPaddingCompileTimeZero(
00218       \textcolor{keywordtype}{int} dim\_index)\textcolor{keyword}{ const }\{
00219 \textcolor{preprocessor}{#if defined(EIGEN\_HAS\_INDEX\_LIST)}
00220     \textcolor{keywordflow}{return} internal::index\_pair\_first\_statically\_eq<PaddingDimensions>(dim\_index, 0);
00221 \textcolor{preprocessor}{#else}
00222     EIGEN\_UNUSED\_VARIABLE(dim\_index);
00223     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00224 \textcolor{preprocessor}{#endif}
00225   \}
00226 
00227   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \textcolor{keywordtype}{bool} isRightPaddingCompileTimeZero(
00228       \textcolor{keywordtype}{int} dim\_index)\textcolor{keyword}{ const }\{
00229 \textcolor{preprocessor}{#if defined(EIGEN\_HAS\_INDEX\_LIST)}
00230     \textcolor{keywordflow}{return} internal::index\_pair\_second\_statically\_eq<PaddingDimensions>(dim\_index, 0);
00231 \textcolor{preprocessor}{#else}
00232     EIGEN\_UNUSED\_VARIABLE(dim\_index);
00233     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00234 \textcolor{preprocessor}{#endif}
00235   \}
00236 
00237 
00238   \textcolor{keywordtype}{void} updateCostPerDimension(\hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}& cost, \textcolor{keywordtype}{int} i, \textcolor{keywordtype}{bool} first)\textcolor{keyword}{ const }\{
00239     \textcolor{keyword}{const} \textcolor{keywordtype}{double} in = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(m\_impl.dimensions()[i]);
00240     \textcolor{keyword}{const} \textcolor{keywordtype}{double} out = in + m\_padding[i].first + m\_padding[i].second;
00241     \textcolor{keywordflow}{if} (out == 0)
00242       \textcolor{keywordflow}{return};
00243     \textcolor{keyword}{const} \textcolor{keywordtype}{double} reduction = in / out;
00244     cost *= reduction;
00245     \textcolor{keywordflow}{if} (first) \{
00246       cost += \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, 2 * TensorOpCost::AddCost<Index>() +
00247                     reduction * (1 * TensorOpCost::AddCost<Index>()));
00248     \} \textcolor{keywordflow}{else} \{
00249       cost += \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, 2 * TensorOpCost::AddCost<Index>() +
00250                                  2 * TensorOpCost::MulCost<Index>() +
00251                     reduction * (2 * TensorOpCost::MulCost<Index>() +
00252                                  1 * TensorOpCost::DivCost<Index>()));
00253     \}
00254   \}
00255 
00256  \textcolor{keyword}{protected}:
00257 
00258   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packetColMajor(Index index)\textcolor{keyword}{ const}
00259 \textcolor{keyword}{  }\{
00260     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00261     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00262 
00263     \textcolor{keyword}{const} Index initialIndex = index;
00264     Index inputIndex = 0;
00265     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00266       \textcolor{keyword}{const} Index first = index;
00267       \textcolor{keyword}{const} Index last = index + PacketSize - 1;
00268       \textcolor{keyword}{const} Index lastPaddedLeft = m\_padding[i].first * m\_outputStrides[i];
00269       \textcolor{keyword}{const} Index firstPaddedRight = (m\_dimensions[i] - m\_padding[i].second) * m\_outputStrides[i];
00270       \textcolor{keyword}{const} Index lastPaddedRight = m\_outputStrides[i+1];
00271 
00272       \textcolor{keywordflow}{if} (!isLeftPaddingCompileTimeZero(i) && last < lastPaddedLeft) \{
00273         \textcolor{comment}{// all the coefficient are in the padding zone.}
00274         \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(m\_paddingValue);
00275       \}
00276       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isRightPaddingCompileTimeZero(i) && first >= firstPaddedRight && last < lastPaddedRight) \{
00277         \textcolor{comment}{// all the coefficient are in the padding zone.}
00278         \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(m\_paddingValue);
00279       \}
00280       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((isLeftPaddingCompileTimeZero(i) && isRightPaddingCompileTimeZero(i)) || (first >= 
      lastPaddedLeft && last < firstPaddedRight)) \{
00281         \textcolor{comment}{// all the coefficient are between the 2 padding zones.}
00282         \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00283         inputIndex += (idx - m\_padding[i].first) * m\_inputStrides[i];
00284         index -= idx * m\_outputStrides[i];
00285       \}
00286       \textcolor{keywordflow}{else} \{
00287         \textcolor{comment}{// Every other case}
00288         \textcolor{keywordflow}{return} packetWithPossibleZero(initialIndex);
00289       \}
00290     \}
00291 
00292     \textcolor{keyword}{const} Index last = index + PacketSize - 1;
00293     \textcolor{keyword}{const} Index first = index;
00294     \textcolor{keyword}{const} Index lastPaddedLeft = m\_padding[0].first;
00295     \textcolor{keyword}{const} Index firstPaddedRight = (m\_dimensions[0] - m\_padding[0].second);
00296     \textcolor{keyword}{const} Index lastPaddedRight = m\_outputStrides[1];
00297 
00298     \textcolor{keywordflow}{if} (!isLeftPaddingCompileTimeZero(0) && last < lastPaddedLeft) \{
00299       \textcolor{comment}{// all the coefficient are in the padding zone.}
00300       \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(m\_paddingValue);
00301     \}
00302     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isRightPaddingCompileTimeZero(0) && first >= firstPaddedRight && last < lastPaddedRight) \{
00303       \textcolor{comment}{// all the coefficient are in the padding zone.}
00304       \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(m\_paddingValue);
00305     \}
00306     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((isLeftPaddingCompileTimeZero(0) && isRightPaddingCompileTimeZero(0)) || (first >= 
      lastPaddedLeft && last < firstPaddedRight)) \{
00307       \textcolor{comment}{// all the coefficient are between the 2 padding zones.}
00308       inputIndex += (index - m\_padding[0].first);
00309       \textcolor{keywordflow}{return} m\_impl.template packet<Unaligned>(inputIndex);
00310     \}
00311     \textcolor{comment}{// Every other case}
00312     \textcolor{keywordflow}{return} packetWithPossibleZero(initialIndex);
00313   \}
00314 
00315   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packetRowMajor(Index index)\textcolor{keyword}{ const}
00316 \textcolor{keyword}{  }\{
00317     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00318     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00319 
00320     \textcolor{keyword}{const} Index initialIndex = index;
00321     Index inputIndex = 0;
00322 
00323     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00324       \textcolor{keyword}{const} Index first = index;
00325       \textcolor{keyword}{const} Index last = index + PacketSize - 1;
00326       \textcolor{keyword}{const} Index lastPaddedLeft = m\_padding[i].first * m\_outputStrides[i+1];
00327       \textcolor{keyword}{const} Index firstPaddedRight = (m\_dimensions[i] - m\_padding[i].second) * m\_outputStrides[i+1];
00328       \textcolor{keyword}{const} Index lastPaddedRight = m\_outputStrides[i];
00329 
00330       \textcolor{keywordflow}{if} (!isLeftPaddingCompileTimeZero(i) && last < lastPaddedLeft) \{
00331         \textcolor{comment}{// all the coefficient are in the padding zone.}
00332         \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(m\_paddingValue);
00333       \}
00334       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isRightPaddingCompileTimeZero(i) && first >= firstPaddedRight && last < lastPaddedRight) \{
00335         \textcolor{comment}{// all the coefficient are in the padding zone.}
00336         \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(m\_paddingValue);
00337       \}
00338       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((isLeftPaddingCompileTimeZero(i) && isRightPaddingCompileTimeZero(i)) || (first >= 
      lastPaddedLeft && last < firstPaddedRight)) \{
00339         \textcolor{comment}{// all the coefficient are between the 2 padding zones.}
00340         \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i+1];
00341         inputIndex += (idx - m\_padding[i].first) * m\_inputStrides[i];
00342         index -= idx * m\_outputStrides[i+1];
00343       \}
00344       \textcolor{keywordflow}{else} \{
00345         \textcolor{comment}{// Every other case}
00346         \textcolor{keywordflow}{return} packetWithPossibleZero(initialIndex);
00347       \}
00348     \}
00349 
00350     \textcolor{keyword}{const} Index last = index + PacketSize - 1;
00351     \textcolor{keyword}{const} Index first = index;
00352     \textcolor{keyword}{const} Index lastPaddedLeft = m\_padding[NumDims-1].first;
00353     \textcolor{keyword}{const} Index firstPaddedRight = (m\_dimensions[NumDims-1] - m\_padding[NumDims-1].second);
00354     \textcolor{keyword}{const} Index lastPaddedRight = m\_outputStrides[NumDims-1];
00355 
00356     \textcolor{keywordflow}{if} (!isLeftPaddingCompileTimeZero(NumDims-1) && last < lastPaddedLeft) \{
00357       \textcolor{comment}{// all the coefficient are in the padding zone.}
00358       \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(m\_paddingValue);
00359     \}
00360     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isRightPaddingCompileTimeZero(NumDims-1) && first >= firstPaddedRight && last < 
      lastPaddedRight) \{
00361       \textcolor{comment}{// all the coefficient are in the padding zone.}
00362       \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(m\_paddingValue);
00363     \}
00364     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((isLeftPaddingCompileTimeZero(NumDims-1) && isRightPaddingCompileTimeZero(NumDims-1)) || (
      first >= lastPaddedLeft && last < firstPaddedRight)) \{
00365       \textcolor{comment}{// all the coefficient are between the 2 padding zones.}
00366       inputIndex += (index - m\_padding[NumDims-1].first);
00367       \textcolor{keywordflow}{return} m\_impl.template packet<Unaligned>(inputIndex);
00368     \}
00369     \textcolor{comment}{// Every other case}
00370     \textcolor{keywordflow}{return} packetWithPossibleZero(initialIndex);
00371   \}
00372 
00373   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packetWithPossibleZero(Index index)\textcolor{keyword}{ const}
00374 \textcolor{keyword}{  }\{
00375     EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<CoeffReturnType>::type}
       values[PacketSize];
00376     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00377       values[i] = coeff(index+i);
00378     \}
00379     PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00380     \textcolor{keywordflow}{return} rslt;
00381   \}
00382 
00383   Dimensions m\_dimensions;
00384   \hyperlink{class_eigen_1_1array}{array<Index, NumDims+1>} m\_outputStrides;
00385   \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} m\_inputStrides;
00386   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} m\_impl;
00387   PaddingDimensions m\_padding;
00388 
00389   Scalar m\_paddingValue;
00390 \};
00391 
00392 
00393 
00394 
00395 \} \textcolor{comment}{// end namespace Eigen}
00396 
00397 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_PADDING\_H}
\end{DoxyCode}
