\hypertarget{getopt_2getopt__long_8c_source}{}\section{getopt/getopt\+\_\+long.c}
\label{getopt_2getopt__long_8c_source}\index{getopt\+\_\+long.\+c@{getopt\+\_\+long.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*  $OpenBSD: getopt\_long.c,v 1.21 2006/09/22 17:22:05 millert Exp $    */}
00002 \textcolor{comment}{/*  $NetBSD: getopt\_long.c,v 1.15 2002/01/31 22:43:40 tv Exp $  */}
00003 
00004 \textcolor{comment}{/*}
00005 \textcolor{comment}{ * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>}
00006 \textcolor{comment}{ *}
00007 \textcolor{comment}{ * Permission to use, copy, modify, and distribute this software for any}
00008 \textcolor{comment}{ * purpose with or without fee is hereby granted, provided that the above}
00009 \textcolor{comment}{ * copyright notice and this permission notice appear in all copies.}
00010 \textcolor{comment}{ *}
00011 \textcolor{comment}{ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES}
00012 \textcolor{comment}{ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF}
00013 \textcolor{comment}{ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR}
00014 \textcolor{comment}{ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES}
00015 \textcolor{comment}{ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN}
00016 \textcolor{comment}{ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF}
00017 \textcolor{comment}{ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.}
00018 \textcolor{comment}{ *}
00019 \textcolor{comment}{ * Sponsored in part by the Defense Advanced Research Projects}
00020 \textcolor{comment}{ * Agency (DARPA) and Air Force Research Laboratory, Air Force}
00021 \textcolor{comment}{ * Materiel Command, USAF, under agreement number F39502-99-1-0512.}
00022 \textcolor{comment}{ */}
00023 \textcolor{comment}{/*-}
00024 \textcolor{comment}{ * Copyright (c) 2000 The NetBSD Foundation, Inc.}
00025 \textcolor{comment}{ * All rights reserved.}
00026 \textcolor{comment}{ *}
00027 \textcolor{comment}{ * This code is derived from software contributed to The NetBSD Foundation}
00028 \textcolor{comment}{ * by Dieter Baron and Thomas Klausner.}
00029 \textcolor{comment}{ *}
00030 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00031 \textcolor{comment}{ * modification, are permitted provided that the following conditions}
00032 \textcolor{comment}{ * are met:}
00033 \textcolor{comment}{ * 1. Redistributions of source code must retain the above copyright}
00034 \textcolor{comment}{ *    notice, this list of conditions and the following disclaimer.}
00035 \textcolor{comment}{ * 2. Redistributions in binary form must reproduce the above copyright}
00036 \textcolor{comment}{ *    notice, this list of conditions and the following disclaimer in the}
00037 \textcolor{comment}{ *    documentation and/or other materials provided with the distribution.}
00038 \textcolor{comment}{ * 3. All advertising materials mentioning features or use of this software}
00039 \textcolor{comment}{ *    must display the following acknowledgement:}
00040 \textcolor{comment}{ *        This product includes software developed by the NetBSD}
00041 \textcolor{comment}{ *        Foundation, Inc. and its contributors.}
00042 \textcolor{comment}{ * 4. Neither the name of The NetBSD Foundation nor the names of its}
00043 \textcolor{comment}{ *    contributors may be used to endorse or promote products derived}
00044 \textcolor{comment}{ *    from this software without specific prior written permission.}
00045 \textcolor{comment}{ *}
00046 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS}
00047 \textcolor{comment}{ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED}
00048 \textcolor{comment}{ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR}
00049 \textcolor{comment}{ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS}
00050 \textcolor{comment}{ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00051 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00052 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00053 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00054 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00055 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00056 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00057 \textcolor{comment}{ */}
00058 
00059 \textcolor{preprocessor}{#if !defined(\_WIN32) && !defined(\_WIN64)}
00060 \textcolor{preprocessor}{#   include <sys/cdefs.h>}
00061 \textcolor{preprocessor}{#   include <err.h>}
00062 \textcolor{preprocessor}{#else}
00063 \textcolor{preprocessor}{#   include <stdio.h>}
00064 \textcolor{preprocessor}{#   define warnx printf}
00065 \textcolor{preprocessor}{#endif}
00066 
00067 \textcolor{preprocessor}{#include <errno.h>}
00068 \textcolor{preprocessor}{#include <getopt.h>}
00069 \textcolor{preprocessor}{#include <stdlib.h>}
00070 \textcolor{preprocessor}{#include <string.h>}
00071 
00072 \textcolor{preprocessor}{#define GNU\_COMPATIBLE      }\textcolor{comment}{/* Be more compatible, configure's use us! */}\textcolor{preprocessor}{}
00073 
00074 \textcolor{preprocessor}{#ifdef REPLACE\_GETOPT}
00075 \textcolor{keywordtype}{int} opterr = 1;     \textcolor{comment}{/* if error message should be printed */}
00076 \textcolor{keywordtype}{int} optind = 1;     \textcolor{comment}{/* index into parent argv vector */}
00077 \textcolor{keywordtype}{int} optopt = \textcolor{charliteral}{'?'};   \textcolor{comment}{/* character checked for validity */}
00078 \textcolor{keywordtype}{int} optreset;       \textcolor{comment}{/* reset getopt */}
00079 \textcolor{keywordtype}{char} *optarg;       \textcolor{comment}{/* argument associated with option */}
00080 \textcolor{preprocessor}{#endif}
00081 
00082 \textcolor{preprocessor}{#define PRINT\_ERROR ((opterr) && (*options != ':'))}
00083 
00084 \textcolor{preprocessor}{#define FLAG\_PERMUTE    0x01    }\textcolor{comment}{/* permute non-options to the end of argv */}\textcolor{preprocessor}{}
00085 \textcolor{preprocessor}{#define FLAG\_ALLARGS    0x02    }\textcolor{comment}{/* treat non-options as args to option "-1" */}\textcolor{preprocessor}{}
00086 \textcolor{preprocessor}{#define FLAG\_LONGONLY   0x04    }\textcolor{comment}{/* operate as getopt\_long\_only */}\textcolor{preprocessor}{}
00087 
00088 \textcolor{comment}{/* return values */}
00089 \textcolor{preprocessor}{#define BADCH       (int)'?'}
00090 \textcolor{preprocessor}{#define BADARG      ((*options == ':') ? (int)':' : (int)'?')}
00091 \textcolor{preprocessor}{#define INORDER     (int)1}
00092 
00093 \textcolor{preprocessor}{#define EMSG        ""}
00094 
00095 \textcolor{preprocessor}{#ifdef GNU\_COMPATIBLE}
00096 \textcolor{preprocessor}{#define NO\_PREFIX   (-1)}
00097 \textcolor{preprocessor}{#define D\_PREFIX    0}
00098 \textcolor{preprocessor}{#define DD\_PREFIX   1}
00099 \textcolor{preprocessor}{#define W\_PREFIX    2}
00100 \textcolor{preprocessor}{#endif}
00101 
00102 \textcolor{keyword}{static} \textcolor{keywordtype}{int} getopt\_internal(\textcolor{keywordtype}{int}, \textcolor{keywordtype}{char} * \textcolor{keyword}{const} *, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *,
00103                \textcolor{keyword}{const} \textcolor{keyword}{struct} \hyperlink{structoption}{option} *, \textcolor{keywordtype}{int} *, \textcolor{keywordtype}{int});
00104 \textcolor{keyword}{static} \textcolor{keywordtype}{int} parse\_long\_options(\textcolor{keywordtype}{char} * \textcolor{keyword}{const} *, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *,
00105                   \textcolor{keyword}{const} \textcolor{keyword}{struct} \hyperlink{structoption}{option} *, \textcolor{keywordtype}{int} *, \textcolor{keywordtype}{int}, \textcolor{keywordtype}{int});
00106 \textcolor{keyword}{static} \textcolor{keywordtype}{int} gcd(\textcolor{keywordtype}{int}, \textcolor{keywordtype}{int});
00107 \textcolor{keyword}{static} \textcolor{keywordtype}{void} permute\_args(\textcolor{keywordtype}{int}, \textcolor{keywordtype}{int}, \textcolor{keywordtype}{int}, \textcolor{keywordtype}{char} * \textcolor{keyword}{const} *);
00108 
00109 \textcolor{keyword}{static} \textcolor{keywordtype}{char} *place = EMSG; \textcolor{comment}{/* option letter processing */}
00110 
00111 \textcolor{comment}{/* XXX: set optreset to 1 rather than these two */}
00112 \textcolor{keyword}{static} \textcolor{keywordtype}{int} nonopt\_start = -1; \textcolor{comment}{/* first non option argument (for permute) */}
00113 \textcolor{keyword}{static} \textcolor{keywordtype}{int} nonopt\_end = -1;   \textcolor{comment}{/* first option after non options (for permute) */}
00114 
00115 \textcolor{comment}{/* Error messages */}
00116 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} recargchar[] = \textcolor{stringliteral}{"option requires an argument -- %c"};
00117 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} illoptchar[] = \textcolor{stringliteral}{"illegal option -- %c"}; \textcolor{comment}{/* From P1003.2 */}
00118 \textcolor{preprocessor}{#ifdef GNU\_COMPATIBLE}
00119 \textcolor{keyword}{static} \textcolor{keywordtype}{int} dash\_prefix = NO\_PREFIX;
00120 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} gnuoptchar[] = \textcolor{stringliteral}{"invalid option -- %c"};
00121 
00122 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} recargstring[] = \textcolor{stringliteral}{"option `%s%s' requires an argument"};
00123 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} ambig[] = \textcolor{stringliteral}{"option `%s%.*s' is ambiguous"};
00124 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} noarg[] = \textcolor{stringliteral}{"option `%s%.*s' doesn't allow an argument"};
00125 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} illoptstring[] = \textcolor{stringliteral}{"unrecognized option `%s%s'"};
00126 \textcolor{preprocessor}{#else}
00127 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} recargstring[] = \textcolor{stringliteral}{"option requires an argument -- %s"};
00128 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} ambig[] = \textcolor{stringliteral}{"ambiguous option -- %.*s"};
00129 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} noarg[] = \textcolor{stringliteral}{"option doesn't take an argument -- %.*s"};
00130 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} illoptstring[] = \textcolor{stringliteral}{"unknown option -- %s"};
00131 \textcolor{preprocessor}{#endif}
00132 
00133 \textcolor{comment}{/*}
00134 \textcolor{comment}{ * Compute the greatest common divisor of a and b.}
00135 \textcolor{comment}{ */}
00136 \textcolor{keyword}{static} \textcolor{keywordtype}{int}
00137 gcd(\textcolor{keywordtype}{int} a, \textcolor{keywordtype}{int} b)
00138 \{
00139     \textcolor{keywordtype}{int} c;
00140 
00141     c = a % b;
00142     \textcolor{keywordflow}{while} (c != 0) \{
00143         a = b;
00144         b = c;
00145         c = a % b;
00146     \}
00147 
00148     \textcolor{keywordflow}{return} (b);
00149 \}
00150 
00151 \textcolor{comment}{/*}
00152 \textcolor{comment}{ * Exchange the block from nonopt\_start to nonopt\_end with the block}
00153 \textcolor{comment}{ * from nonopt\_end to opt\_end (keeping the same order of arguments}
00154 \textcolor{comment}{ * in each block).}
00155 \textcolor{comment}{ */}
00156 \textcolor{keyword}{static} \textcolor{keywordtype}{void}
00157 permute\_args(\textcolor{keywordtype}{int} panonopt\_start, \textcolor{keywordtype}{int} panonopt\_end, \textcolor{keywordtype}{int} opt\_end,
00158     \textcolor{keywordtype}{char} * \textcolor{keyword}{const} *nargv)
00159 \{
00160     \textcolor{keywordtype}{int} cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
00161     \textcolor{keywordtype}{char} *\hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap};
00162 
00163     \textcolor{comment}{/*}
00164 \textcolor{comment}{     * compute lengths of blocks and number and size of cycles}
00165 \textcolor{comment}{     */}
00166     nnonopts = panonopt\_end - panonopt\_start;
00167     nopts = opt\_end - panonopt\_end;
00168     ncycle = gcd(nnonopts, nopts);
00169     cyclelen = (opt\_end - panonopt\_start) / ncycle;
00170 
00171     \textcolor{keywordflow}{for} (i = 0; i < ncycle; i++) \{
00172         cstart = panonopt\_end+i;
00173         pos = cstart;
00174         \textcolor{keywordflow}{for} (j = 0; j < cyclelen; j++) \{
00175             \textcolor{keywordflow}{if} (pos >= panonopt\_end)
00176                 pos -= nnonopts;
00177             \textcolor{keywordflow}{else}
00178                 pos += nopts;
00179             swap = nargv[pos];
00180             \textcolor{comment}{/* LINTED const cast */}
00181             ((\textcolor{keywordtype}{char} **) nargv)[pos] = nargv[cstart];
00182             \textcolor{comment}{/* LINTED const cast */}
00183             ((\textcolor{keywordtype}{char} **)nargv)[cstart] = \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap};
00184         \}
00185     \}
00186 \}
00187 
00188 \textcolor{comment}{/*}
00189 \textcolor{comment}{ * parse\_long\_options --}
00190 \textcolor{comment}{ *  Parse long options in argc/argv argument vector.}
00191 \textcolor{comment}{ * Returns -1 if short\_too is set and the option does not match long\_options.}
00192 \textcolor{comment}{ */}
00193 \textcolor{keyword}{static} \textcolor{keywordtype}{int}
00194 parse\_long\_options(\textcolor{keywordtype}{char} * \textcolor{keyword}{const} *nargv, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *options,
00195     \textcolor{keyword}{const} \textcolor{keyword}{struct} \hyperlink{structoption}{option} *\hyperlink{structlong__options}{long\_options}, \textcolor{keywordtype}{int} *idx, \textcolor{keywordtype}{int} short\_too, \textcolor{keywordtype}{int} flags)
00196 \{
00197     \textcolor{keywordtype}{char} *current\_argv, *has\_equal;
00198 \textcolor{preprocessor}{#ifdef GNU\_COMPATIBLE}
00199     \textcolor{keywordtype}{char} *current\_dash;
00200 \textcolor{preprocessor}{#endif}
00201     \textcolor{keywordtype}{size\_t} current\_argv\_len;
00202     \textcolor{keywordtype}{int} i, match, exact\_match, second\_partial\_match;
00203 
00204     current\_argv = place;
00205 \textcolor{preprocessor}{#ifdef GNU\_COMPATIBLE}
00206     \textcolor{keywordflow}{switch} (dash\_prefix) \{
00207         \textcolor{keywordflow}{case} D\_PREFIX:
00208             current\_dash = \textcolor{stringliteral}{"-"};
00209             \textcolor{keywordflow}{break};
00210         \textcolor{keywordflow}{case} DD\_PREFIX:
00211             current\_dash = \textcolor{stringliteral}{"--"};
00212             \textcolor{keywordflow}{break};
00213         \textcolor{keywordflow}{case} W\_PREFIX:
00214             current\_dash = \textcolor{stringliteral}{"-W "};
00215             \textcolor{keywordflow}{break};
00216         \textcolor{keywordflow}{default}:
00217             current\_dash = \textcolor{stringliteral}{""};
00218             \textcolor{keywordflow}{break};
00219     \}
00220 \textcolor{preprocessor}{#endif}
00221     match = -1;
00222     exact\_match = 0;
00223     second\_partial\_match = 0;
00224 
00225     optind++;
00226 
00227     \textcolor{keywordflow}{if} ((has\_equal = strchr(current\_argv, \textcolor{charliteral}{'='})) != NULL) \{
00228         \textcolor{comment}{/* argument found (--option=arg) */}
00229         current\_argv\_len = has\_equal - current\_argv;
00230         has\_equal++;
00231     \} \textcolor{keywordflow}{else}
00232         current\_argv\_len = strlen(current\_argv);
00233 
00234     \textcolor{keywordflow}{for} (i = 0; long\_options[i].name; i++) \{
00235         \textcolor{comment}{/* find matching long option */}
00236         \textcolor{keywordflow}{if} (strncmp(current\_argv, long\_options[i].name,
00237             current\_argv\_len))
00238             \textcolor{keywordflow}{continue};
00239 
00240         \textcolor{keywordflow}{if} (strlen(long\_options[i].name) == current\_argv\_len) \{
00241             \textcolor{comment}{/* exact match */}
00242             match = i;
00243             exact\_match = 1;
00244             \textcolor{keywordflow}{break};
00245         \}
00246         \textcolor{comment}{/*}
00247 \textcolor{comment}{         * If this is a known short option, don't allow}
00248 \textcolor{comment}{         * a partial match of a single character.}
00249 \textcolor{comment}{         */}
00250         \textcolor{keywordflow}{if} (short\_too && current\_argv\_len == 1)
00251             \textcolor{keywordflow}{continue};
00252 
00253         \textcolor{keywordflow}{if} (match == -1)        \textcolor{comment}{/* first partial match */}
00254             match = i;
00255         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((flags & FLAG\_LONGONLY) ||
00256              long\_options[i].has\_arg !=
00257                  long\_options[match].has\_arg ||
00258              long\_options[i].flag != long\_options[match].flag ||
00259              long\_options[i].val != long\_options[match].val)
00260             second\_partial\_match = 1;
00261     \}
00262     \textcolor{keywordflow}{if} (!exact\_match && second\_partial\_match) \{
00263         \textcolor{comment}{/* ambiguous abbreviation */}
00264         \textcolor{keywordflow}{if} (PRINT\_ERROR)
00265             warnx(ambig,
00266 #ifdef GNU\_COMPATIBLE
00267                  current\_dash,
00268 #endif
00269                  (\textcolor{keywordtype}{int})current\_argv\_len,
00270                  current\_argv);
00271         optopt = 0;
00272         \textcolor{keywordflow}{return} (BADCH);
00273     \}
00274     \textcolor{keywordflow}{if} (match != -1) \{      \textcolor{comment}{/* option found */}
00275         \textcolor{keywordflow}{if} (long\_options[match].has\_arg == no\_argument
00276             && has\_equal) \{
00277             \textcolor{keywordflow}{if} (PRINT\_ERROR)
00278                 warnx(noarg,
00279 #ifdef GNU\_COMPATIBLE
00280                      current\_dash,
00281 #endif
00282                      (\textcolor{keywordtype}{int})current\_argv\_len,
00283                      current\_argv);
00284             \textcolor{comment}{/*}
00285 \textcolor{comment}{             * XXX: GNU sets optopt to val regardless of flag}
00286 \textcolor{comment}{             */}
00287             \textcolor{keywordflow}{if} (long\_options[match].flag == NULL)
00288                 optopt = long\_options[match].val;
00289             \textcolor{keywordflow}{else}
00290                 optopt = 0;
00291 \textcolor{preprocessor}{#ifdef GNU\_COMPATIBLE}
00292             \textcolor{keywordflow}{return} (BADCH);
00293 \textcolor{preprocessor}{#else}
00294             \textcolor{keywordflow}{return} (BADARG);
00295 \textcolor{preprocessor}{#endif}
00296         \}
00297         \textcolor{keywordflow}{if} (long\_options[match].has\_arg == required\_argument ||
00298             long\_options[match].has\_arg == optional\_argument) \{
00299             \textcolor{keywordflow}{if} (has\_equal)
00300                 optarg = has\_equal;
00301             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (long\_options[match].has\_arg ==
00302                 required\_argument) \{
00303                 \textcolor{comment}{/*}
00304 \textcolor{comment}{                 * optional argument doesn't use next nargv}
00305 \textcolor{comment}{                 */}
00306                 optarg = nargv[optind++];
00307             \}
00308         \}
00309         \textcolor{keywordflow}{if} ((long\_options[match].has\_arg == required\_argument)
00310             && (optarg == NULL)) \{
00311             \textcolor{comment}{/*}
00312 \textcolor{comment}{             * Missing argument; leading ':' indicates no error}
00313 \textcolor{comment}{             * should be generated.}
00314 \textcolor{comment}{             */}
00315             \textcolor{keywordflow}{if} (PRINT\_ERROR)
00316                 warnx(recargstring,
00317 #ifdef GNU\_COMPATIBLE
00318                     current\_dash,
00319 #endif
00320                     current\_argv);
00321             \textcolor{comment}{/*}
00322 \textcolor{comment}{             * XXX: GNU sets optopt to val regardless of flag}
00323 \textcolor{comment}{             */}
00324             \textcolor{keywordflow}{if} (long\_options[match].flag == NULL)
00325                 optopt = long\_options[match].val;
00326             \textcolor{keywordflow}{else}
00327                 optopt = 0;
00328             --optind;
00329             \textcolor{keywordflow}{return} (BADARG);
00330         \}
00331     \} \textcolor{keywordflow}{else} \{            \textcolor{comment}{/* unknown option */}
00332         \textcolor{keywordflow}{if} (short\_too) \{
00333             --optind;
00334             \textcolor{keywordflow}{return} (-1);
00335         \}
00336         \textcolor{keywordflow}{if} (PRINT\_ERROR)
00337             warnx(illoptstring,
00338 #ifdef GNU\_COMPATIBLE
00339                   current\_dash,
00340 #endif
00341                   current\_argv);
00342         optopt = 0;
00343         \textcolor{keywordflow}{return} (BADCH);
00344     \}
00345     \textcolor{keywordflow}{if} (idx)
00346         *idx = match;
00347     \textcolor{keywordflow}{if} (long\_options[match].flag) \{
00348         *long\_options[match].flag = long\_options[match].val;
00349         \textcolor{keywordflow}{return} (0);
00350     \} \textcolor{keywordflow}{else}
00351         \textcolor{keywordflow}{return} (long\_options[match].val);
00352 \}
00353 
00354 \textcolor{comment}{/*}
00355 \textcolor{comment}{ * getopt\_internal --}
00356 \textcolor{comment}{ *  Parse argc/argv argument vector.  Called by user level routines.}
00357 \textcolor{comment}{ */}
00358 \textcolor{keyword}{static} \textcolor{keywordtype}{int}
00359 getopt\_internal(\textcolor{keywordtype}{int} nargc, \textcolor{keywordtype}{char} * \textcolor{keyword}{const} *nargv, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *options,
00360     \textcolor{keyword}{const} \textcolor{keyword}{struct} \hyperlink{structoption}{option} *long\_options, \textcolor{keywordtype}{int} *idx, \textcolor{keywordtype}{int} flags)
00361 \{
00362     \textcolor{keywordtype}{char} *oli;              \textcolor{comment}{/* option letter list index */}
00363     \textcolor{keywordtype}{int} optchar, short\_too;
00364     \textcolor{keywordtype}{int} posixly\_correct;    \textcolor{comment}{/* no static, can be changed on the fly */}
00365 
00366     \textcolor{keywordflow}{if} (options == NULL)
00367         \textcolor{keywordflow}{return} (-1);
00368 
00369     \textcolor{comment}{/*}
00370 \textcolor{comment}{     * Disable GNU extensions if POSIXLY\_CORRECT is set or options}
00371 \textcolor{comment}{     * string begins with a '+'.}
00372 \textcolor{comment}{     */}
00373     posixly\_correct = (getenv(\textcolor{stringliteral}{"POSIXLY\_CORRECT"}) != NULL);
00374 \textcolor{preprocessor}{#ifdef GNU\_COMPATIBLE}
00375     \textcolor{keywordflow}{if} (*options == \textcolor{charliteral}{'-'})
00376         flags |= FLAG\_ALLARGS;
00377     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (posixly\_correct || *options == \textcolor{charliteral}{'+'})
00378         flags &= ~FLAG\_PERMUTE;
00379 \textcolor{preprocessor}{#else}
00380     \textcolor{keywordflow}{if} (posixly\_correct || *options == \textcolor{charliteral}{'+'})
00381         flags &= ~FLAG\_PERMUTE;
00382     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*options == \textcolor{charliteral}{'-'})
00383         flags |= FLAG\_ALLARGS;
00384 \textcolor{preprocessor}{#endif}
00385     \textcolor{keywordflow}{if} (*options == \textcolor{charliteral}{'+'} || *options == \textcolor{charliteral}{'-'})
00386         options++;
00387 
00388     \textcolor{comment}{/*}
00389 \textcolor{comment}{     * XXX Some GNU programs (like cvs) set optind to 0 instead of}
00390 \textcolor{comment}{     * XXX using optreset.  Work around this braindamage.}
00391 \textcolor{comment}{     */}
00392     \textcolor{keywordflow}{if} (optind == 0)
00393         optind = optreset = 1;
00394 
00395     optarg = NULL;
00396     \textcolor{keywordflow}{if} (optreset)
00397         nonopt\_start = nonopt\_end = -1;
00398 start:
00399     \textcolor{keywordflow}{if} (optreset || !*place) \{      \textcolor{comment}{/* update scanning pointer */}
00400         optreset = 0;
00401         \textcolor{keywordflow}{if} (optind >= nargc) \{          \textcolor{comment}{/* end of argument vector */}
00402             place = EMSG;
00403             \textcolor{keywordflow}{if} (nonopt\_end != -1) \{
00404                 \textcolor{comment}{/* do permutation, if we have to */}
00405                 permute\_args(nonopt\_start, nonopt\_end,
00406                     optind, nargv);
00407                 optind -= nonopt\_end - nonopt\_start;
00408             \}
00409             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nonopt\_start != -1) \{
00410                 \textcolor{comment}{/*}
00411 \textcolor{comment}{                 * If we skipped non-options, set optind}
00412 \textcolor{comment}{                 * to the first of them.}
00413 \textcolor{comment}{                 */}
00414                 optind = nonopt\_start;
00415             \}
00416             nonopt\_start = nonopt\_end = -1;
00417             \textcolor{keywordflow}{return} (-1);
00418         \}
00419         \textcolor{keywordflow}{if} (*(place = nargv[optind]) != \textcolor{charliteral}{'-'} ||
00420 #ifdef GNU\_COMPATIBLE
00421             place[1] == \textcolor{charliteral}{'\(\backslash\)0'}) \{
00422 \textcolor{preprocessor}{#else}
00423             (place[1] == \textcolor{charliteral}{'\(\backslash\)0'} && strchr(options, \textcolor{charliteral}{'-'}) == NULL)) \{
00424 \textcolor{preprocessor}{#endif}
00425             place = EMSG;       \textcolor{comment}{/* found non-option */}
00426             \textcolor{keywordflow}{if} (flags & FLAG\_ALLARGS) \{
00427                 \textcolor{comment}{/*}
00428 \textcolor{comment}{                 * GNU extension:}
00429 \textcolor{comment}{                 * return non-option as argument to option 1}
00430 \textcolor{comment}{                 */}
00431                 optarg = nargv[optind++];
00432                 \textcolor{keywordflow}{return} (INORDER);
00433             \}
00434             \textcolor{keywordflow}{if} (!(flags & FLAG\_PERMUTE)) \{
00435                 \textcolor{comment}{/*}
00436 \textcolor{comment}{                 * If no permutation wanted, stop parsing}
00437 \textcolor{comment}{                 * at first non-option.}
00438 \textcolor{comment}{                 */}
00439                 \textcolor{keywordflow}{return} (-1);
00440             \}
00441             \textcolor{comment}{/* do permutation */}
00442             \textcolor{keywordflow}{if} (nonopt\_start == -1)
00443                 nonopt\_start = optind;
00444             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nonopt\_end != -1) \{
00445                 permute\_args(nonopt\_start, nonopt\_end,
00446                     optind, nargv);
00447                 nonopt\_start = optind -
00448                     (nonopt\_end - nonopt\_start);
00449                 nonopt\_end = -1;
00450             \}
00451             optind++;
00452             \textcolor{comment}{/* process next argument */}
00453             \textcolor{keywordflow}{goto} start;
00454         \}
00455         \textcolor{keywordflow}{if} (nonopt\_start != -1 && nonopt\_end == -1)
00456             nonopt\_end = optind;
00457 
00458         \textcolor{comment}{/*}
00459 \textcolor{comment}{         * If we have "-" do nothing, if "--" we are done.}
00460 \textcolor{comment}{         */}
00461         \textcolor{keywordflow}{if} (place[1] != \textcolor{charliteral}{'\(\backslash\)0'} && *++place == \textcolor{charliteral}{'-'} && place[1] == \textcolor{charliteral}{'\(\backslash\)0'}) \{
00462             optind++;
00463             place = EMSG;
00464             \textcolor{comment}{/*}
00465 \textcolor{comment}{             * We found an option (--), so if we skipped}
00466 \textcolor{comment}{             * non-options, we have to permute.}
00467 \textcolor{comment}{             */}
00468             \textcolor{keywordflow}{if} (nonopt\_end != -1) \{
00469                 permute\_args(nonopt\_start, nonopt\_end,
00470                     optind, nargv);
00471                 optind -= nonopt\_end - nonopt\_start;
00472             \}
00473             nonopt\_start = nonopt\_end = -1;
00474             \textcolor{keywordflow}{return} (-1);
00475         \}
00476     \}
00477 
00478     \textcolor{comment}{/*}
00479 \textcolor{comment}{     * Check long options if:}
00480 \textcolor{comment}{     *  1) we were passed some}
00481 \textcolor{comment}{     *  2) the arg is not just "-"}
00482 \textcolor{comment}{     *  3) either the arg starts with -- we are getopt\_long\_only()}
00483 \textcolor{comment}{     */}
00484     \textcolor{keywordflow}{if} (long\_options != NULL && place != nargv[optind] &&
00485         (*place == \textcolor{charliteral}{'-'} || (flags & FLAG\_LONGONLY))) \{
00486         short\_too = 0;
00487 \textcolor{preprocessor}{#ifdef GNU\_COMPATIBLE}
00488         dash\_prefix = D\_PREFIX;
00489 \textcolor{preprocessor}{#endif}
00490         \textcolor{keywordflow}{if} (*place == \textcolor{charliteral}{'-'}) \{
00491             place++;        \textcolor{comment}{/* --foo long option */}
00492 \textcolor{preprocessor}{#ifdef GNU\_COMPATIBLE}
00493             dash\_prefix = DD\_PREFIX;
00494 \textcolor{preprocessor}{#endif}
00495         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*place != \textcolor{charliteral}{':'} && strchr(options, *place) != NULL)
00496             short\_too = 1;      \textcolor{comment}{/* could be short option too */}
00497 
00498         optchar = parse\_long\_options(nargv, options, long\_options,
00499             idx, short\_too, flags);
00500         \textcolor{keywordflow}{if} (optchar != -1) \{
00501             place = EMSG;
00502             \textcolor{keywordflow}{return} (optchar);
00503         \}
00504     \}
00505 
00506     \textcolor{keywordflow}{if} ((optchar = (\textcolor{keywordtype}{int})*place++) == (\textcolor{keywordtype}{int})\textcolor{charliteral}{':'} ||
00507         (optchar == (\textcolor{keywordtype}{int})\textcolor{charliteral}{'-'} && *place != \textcolor{charliteral}{'\(\backslash\)0'}) ||
00508         (oli = (\textcolor{keywordtype}{char}*)strchr(options, optchar)) == NULL) \{
00509         \textcolor{comment}{/*}
00510 \textcolor{comment}{         * If the user specified "-" and  '-' isn't listed in}
00511 \textcolor{comment}{         * options, return -1 (non-option) as per POSIX.}
00512 \textcolor{comment}{         * Otherwise, it is an unknown option character (or ':').}
00513 \textcolor{comment}{         */}
00514         \textcolor{keywordflow}{if} (optchar == (\textcolor{keywordtype}{int})\textcolor{charliteral}{'-'} && *place == \textcolor{charliteral}{'\(\backslash\)0'})
00515             \textcolor{keywordflow}{return} (-1);
00516         \textcolor{keywordflow}{if} (!*place)
00517             ++optind;
00518 \textcolor{preprocessor}{#ifdef GNU\_COMPATIBLE}
00519         \textcolor{keywordflow}{if} (PRINT\_ERROR)
00520             warnx(posixly\_correct ? illoptchar : gnuoptchar,
00521                   optchar);
00522 \textcolor{preprocessor}{#else}
00523         \textcolor{keywordflow}{if} (PRINT\_ERROR)
00524             warnx(illoptchar, optchar);
00525 \textcolor{preprocessor}{#endif}
00526         optopt = optchar;
00527         \textcolor{keywordflow}{return} (BADCH);
00528     \}
00529     \textcolor{keywordflow}{if} (long\_options != NULL && optchar == \textcolor{charliteral}{'W'} && oli[1] == \textcolor{charliteral}{';'}) \{
00530         \textcolor{comment}{/* -W long-option */}
00531         \textcolor{keywordflow}{if} (*place)         \textcolor{comment}{/* no space */}
00532             \textcolor{comment}{/* NOTHING */};
00533         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (++optind >= nargc) \{   \textcolor{comment}{/* no arg */}
00534             place = EMSG;
00535             \textcolor{keywordflow}{if} (PRINT\_ERROR)
00536                 warnx(recargchar, optchar);
00537             optopt = optchar;
00538             \textcolor{keywordflow}{return} (BADARG);
00539         \} \textcolor{keywordflow}{else}              \textcolor{comment}{/* white space */}
00540             place = nargv[optind];
00541 \textcolor{preprocessor}{#ifdef GNU\_COMPATIBLE}
00542         dash\_prefix = W\_PREFIX;
00543 \textcolor{preprocessor}{#endif}
00544         optchar = parse\_long\_options(nargv, options, long\_options,
00545             idx, 0, flags);
00546         place = EMSG;
00547         \textcolor{keywordflow}{return} (optchar);
00548     \}
00549     \textcolor{keywordflow}{if} (*++oli != \textcolor{charliteral}{':'}) \{            \textcolor{comment}{/* doesn't take argument */}
00550         \textcolor{keywordflow}{if} (!*place)
00551             ++optind;
00552     \} \textcolor{keywordflow}{else} \{                \textcolor{comment}{/* takes (optional) argument */}
00553         optarg = NULL;
00554         \textcolor{keywordflow}{if} (*place)         \textcolor{comment}{/* no white space */}
00555             optarg = place;
00556         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (oli[1] != \textcolor{charliteral}{':'}) \{   \textcolor{comment}{/* arg not optional */}
00557             \textcolor{keywordflow}{if} (++optind >= nargc) \{    \textcolor{comment}{/* no arg */}
00558                 place = EMSG;
00559                 \textcolor{keywordflow}{if} (PRINT\_ERROR)
00560                     warnx(recargchar, optchar);
00561                 optopt = optchar;
00562                 \textcolor{keywordflow}{return} (BADARG);
00563             \} \textcolor{keywordflow}{else}
00564                 optarg = nargv[optind];
00565         \}
00566         place = EMSG;
00567         ++optind;
00568     \}
00569     \textcolor{comment}{/* dump back option letter */}
00570     \textcolor{keywordflow}{return} (optchar);
00571 \}
00572 
00573 \textcolor{preprocessor}{#ifdef REPLACE\_GETOPT}
00574 \textcolor{comment}{/*}
00575 \textcolor{comment}{ * getopt --}
00576 \textcolor{comment}{ *  Parse argc/argv argument vector.}
00577 \textcolor{comment}{ *}
00578 \textcolor{comment}{ * [eventually this will replace the BSD getopt]}
00579 \textcolor{comment}{ */}
00580 \textcolor{keywordtype}{int}
00581 getopt(\textcolor{keywordtype}{int} nargc, \textcolor{keywordtype}{char} * \textcolor{keyword}{const} *nargv, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *options)
00582 \{
00583 
00584     \textcolor{comment}{/*}
00585 \textcolor{comment}{     * We don't pass FLAG\_PERMUTE to getopt\_internal() since}
00586 \textcolor{comment}{     * the BSD getopt(3) (unlike GNU) has never done this.}
00587 \textcolor{comment}{     *}
00588 \textcolor{comment}{     * Furthermore, since many privileged programs call getopt()}
00589 \textcolor{comment}{     * before dropping privileges it makes sense to keep things}
00590 \textcolor{comment}{     * as simple (and bug-free) as possible.}
00591 \textcolor{comment}{     */}
00592     \textcolor{keywordflow}{return} (getopt\_internal(nargc, nargv, options, NULL, NULL, 0));
00593 \}
00594 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* REPLACE\_GETOPT */}\textcolor{preprocessor}{}
00595 
00596 \textcolor{comment}{/*}
00597 \textcolor{comment}{ * getopt\_long --}
00598 \textcolor{comment}{ *  Parse argc/argv argument vector.}
00599 \textcolor{comment}{ */}
00600 \textcolor{keywordtype}{int}
00601 getopt\_long(\textcolor{keywordtype}{int} nargc, \textcolor{keywordtype}{char} * \textcolor{keyword}{const} *nargv, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *options,
00602     \textcolor{keyword}{const} \textcolor{keyword}{struct} \hyperlink{structoption}{option} *long\_options, \textcolor{keywordtype}{int} *idx)
00603 \{
00604 
00605     \textcolor{keywordflow}{return} (getopt\_internal(nargc, nargv, options, long\_options, idx,
00606         FLAG\_PERMUTE));
00607 \}
00608 
00609 \textcolor{comment}{/*}
00610 \textcolor{comment}{ * getopt\_long\_only --}
00611 \textcolor{comment}{ *  Parse argc/argv argument vector.}
00612 \textcolor{comment}{ */}
00613 \textcolor{keywordtype}{int}
00614 getopt\_long\_only(\textcolor{keywordtype}{int} nargc, \textcolor{keywordtype}{char} * \textcolor{keyword}{const} *nargv, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *options,
00615     \textcolor{keyword}{const} \textcolor{keyword}{struct} \hyperlink{structoption}{option} *long\_options, \textcolor{keywordtype}{int} *idx)
00616 \{
00617 
00618     \textcolor{keywordflow}{return} (getopt\_internal(nargc, nargv, options, long\_options, idx,
00619         FLAG\_PERMUTE|FLAG\_LONGONLY));
00620 \}
\end{DoxyCode}
