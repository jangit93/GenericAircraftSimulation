\hypertarget{eigen_2bench_2sparse__product_8cpp_source}{}\section{eigen/bench/sparse\+\_\+product.cpp}
\label{eigen_2bench_2sparse__product_8cpp_source}\index{sparse\+\_\+product.\+cpp@{sparse\+\_\+product.\+cpp}}

\begin{DoxyCode}
00001 
00002 \textcolor{comment}{//g++ -O3 -g0 -DNDEBUG  sparse\_product.cpp -I.. -I/home/gael/Coding/LinearAlgebra/mtl4/ -DDENSITY=0.005
       -DSIZE=10000 && ./a.out}
00003 \textcolor{comment}{//g++ -O3 -g0 -DNDEBUG  sparse\_product.cpp -I.. -I/home/gael/Coding/LinearAlgebra/mtl4/ -DDENSITY=0.05
       -DSIZE=2000 && ./a.out}
00004 \textcolor{comment}{// -DNOGMM -DNOMTL -DCSPARSE}
00005 \textcolor{comment}{// -I /home/gael/Coding/LinearAlgebra/CSparse/Include/
       /home/gael/Coding/LinearAlgebra/CSparse/Lib/libcsparse.a}
00006 
00007 \textcolor{preprocessor}{#include <typeinfo>}
00008 
00009 \textcolor{preprocessor}{#ifndef SIZE}
00010 \textcolor{preprocessor}{#define SIZE 1000000}
00011 \textcolor{preprocessor}{#endif}
00012 
00013 \textcolor{preprocessor}{#ifndef NNZPERCOL}
00014 \textcolor{preprocessor}{#define NNZPERCOL 6}
00015 \textcolor{preprocessor}{#endif}
00016 
00017 \textcolor{preprocessor}{#ifndef REPEAT}
00018 \textcolor{preprocessor}{#define REPEAT 1}
00019 \textcolor{preprocessor}{#endif}
00020 
00021 \textcolor{preprocessor}{#include <algorithm>}
00022 \textcolor{preprocessor}{#include "BenchTimer.h"}
00023 \textcolor{preprocessor}{#include "BenchUtil.h"}
00024 \textcolor{preprocessor}{#include "BenchSparseUtil.h"}
00025 
00026 \textcolor{preprocessor}{#ifndef NBTRIES}
00027 \textcolor{preprocessor}{#define NBTRIES 1}
00028 \textcolor{preprocessor}{#endif}
00029 
00030 \textcolor{preprocessor}{#define BENCH(X) \(\backslash\)}
00031 \textcolor{preprocessor}{  timer.reset(); \(\backslash\)}
00032 \textcolor{preprocessor}{  for (int \_j=0; \_j<NBTRIES; ++\_j) \{ \(\backslash\)}
00033 \textcolor{preprocessor}{    timer.start(); \(\backslash\)}
00034 \textcolor{preprocessor}{    for (int \_k=0; \_k<REPEAT; ++\_k) \{ \(\backslash\)}
00035 \textcolor{preprocessor}{        X  \(\backslash\)}
00036 \textcolor{preprocessor}{  \} timer.stop(); \}}
00037 
00038 \textcolor{comment}{// #ifdef MKL}
00039 \textcolor{comment}{//}
00040 \textcolor{comment}{// #include "mkl\_types.h"}
00041 \textcolor{comment}{// #include "mkl\_spblas.h"}
00042 \textcolor{comment}{//}
00043 \textcolor{comment}{// template<typename Lhs,typename Rhs,typename Res>}
00044 \textcolor{comment}{// void mkl\_multiply(const Lhs& lhs, const Rhs& rhs, Res& res)}
00045 \textcolor{comment}{// \{}
00046 \textcolor{comment}{//   char n = 'N';}
00047 \textcolor{comment}{//   float alpha = 1;}
00048 \textcolor{comment}{//   char matdescra[6];}
00049 \textcolor{comment}{//   matdescra[0] = 'G';}
00050 \textcolor{comment}{//   matdescra[1] = 0;}
00051 \textcolor{comment}{//   matdescra[2] = 0;}
00052 \textcolor{comment}{//   matdescra[3] = 'C';}
00053 \textcolor{comment}{//   mkl\_scscmm(&n, lhs.rows(), rhs.cols(), lhs.cols(), &alpha, matdescra,}
00054 \textcolor{comment}{//              lhs.\_valuePtr(), lhs.\_innerIndexPtr(), lhs.outerIndexPtr(),}
00055 \textcolor{comment}{//              pntre, b, &ldb, &beta, c, &ldc);}
00056 \textcolor{comment}{// //   mkl\_somatcopy('C', 'T', lhs.rows(), lhs.cols(), 1,}
00057 \textcolor{comment}{// //                 lhs.\_valuePtr(), lhs.rows(), DST, dst\_stride);}
00058 \textcolor{comment}{// \}}
00059 \textcolor{comment}{//}
00060 \textcolor{comment}{// #endif}
00061 
00062 
00063 \textcolor{preprocessor}{#ifdef CSPARSE}
00064 cs* cs\_sorted\_multiply(\textcolor{keyword}{const} cs* a, \textcolor{keyword}{const} cs* b)
00065 \{
00066 \textcolor{comment}{//   return cs\_multiply(a,b);}
00067 
00068   cs* \hyperlink{group___core___module_class_eigen_1_1_matrix}{A} = cs\_transpose(a, 1);
00069   cs* \hyperlink{group___core___module_class_eigen_1_1_matrix}{B} = cs\_transpose(b, 1);
00070   cs* D = cs\_multiply(B,A);   \textcolor{comment}{/* D = B'*A' */}
00071   cs\_spfree (A) ;
00072   cs\_spfree (B) ;
00073   cs\_dropzeros (D) ;      \textcolor{comment}{/* drop zeros from D */}
00074   cs* \hyperlink{group___core___module}{C} = cs\_transpose (D, 1) ;   \textcolor{comment}{/* C = D', so that C is sorted */}
00075   cs\_spfree (D) ;
00076   \textcolor{keywordflow}{return} C;
00077 
00078 \textcolor{comment}{//   cs* A = cs\_transpose(a, 1);}
00079 \textcolor{comment}{//   cs* C = cs\_transpose(A, 1);}
00080 \textcolor{comment}{//   return C;}
00081 \}
00082 
00083 cs* cs\_sorted\_multiply2(\textcolor{keyword}{const} cs* a, \textcolor{keyword}{const} cs* b)
00084 \{
00085   cs* D = cs\_multiply(a,b);
00086   cs* E = cs\_transpose(D,1);
00087   cs\_spfree(D);
00088   cs* \hyperlink{group___core___module}{C} = cs\_transpose(E,1);
00089   cs\_spfree(E);
00090   \textcolor{keywordflow}{return} C;
00091 \}
00092 \textcolor{preprocessor}{#endif}
00093 
00094 \textcolor{keywordtype}{void} bench\_sort();
00095 
00096 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[])
00097 \{
00098 \textcolor{comment}{//   bench\_sort();}
00099 
00100   \textcolor{keywordtype}{int} rows = SIZE;
00101   \textcolor{keywordtype}{int} cols = SIZE;
00102   \textcolor{keywordtype}{float} density = DENSITY;
00103 
00104   \hyperlink{group___sparse_core___module}{EigenSparseMatrix} sm1(rows,cols), sm2(rows,cols), sm3(rows,cols), sm4(rows,cols);
00105 
00106   \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} timer;
00107   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} nnzPerCol = NNZPERCOL; nnzPerCol>1; nnzPerCol/=1.1)
00108   \{
00109     sm1.setZero();
00110     sm2.setZero();
00111     fillMatrix2(nnzPerCol, rows, cols, sm1);
00112     fillMatrix2(nnzPerCol, rows, cols, sm2);
00113 \textcolor{comment}{//     std::cerr << "filling OK\(\backslash\)n";}
00114 
00115     \textcolor{comment}{// dense matrices}
00116 \textcolor{preprocessor}{    #ifdef DENSEMATRIX}
00117     \{
00118       std::cout << \textcolor{stringliteral}{"Eigen Dense\(\backslash\)t"} << nnzPerCol << \textcolor{stringliteral}{"%\(\backslash\)n"};
00119       \hyperlink{group___core___module}{DenseMatrix} m1(rows,cols), m2(rows,cols), m3(rows,cols);
00120       eiToDense(sm1, m1);
00121       eiToDense(sm2, m2);
00122 
00123       timer.reset();
00124       timer.start();
00125       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<REPEAT; ++k)
00126         m3 = m1 * m2;
00127       timer.stop();
00128       std::cout << \textcolor{stringliteral}{"   a * b:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00129 
00130       timer.reset();
00131       timer.start();
00132       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<REPEAT; ++k)
00133         m3 = m1.transpose() * m2;
00134       timer.stop();
00135       std::cout << \textcolor{stringliteral}{"   a' * b:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00136 
00137       timer.reset();
00138       timer.start();
00139       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<REPEAT; ++k)
00140         m3 = m1.transpose() * m2.transpose();
00141       timer.stop();
00142       std::cout << \textcolor{stringliteral}{"   a' * b':\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00143 
00144       timer.reset();
00145       timer.start();
00146       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<REPEAT; ++k)
00147         m3 = m1 * m2.transpose();
00148       timer.stop();
00149       std::cout << \textcolor{stringliteral}{"   a * b':\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00150     \}
00151 \textcolor{preprocessor}{    #endif}
00152 
00153     \textcolor{comment}{// eigen sparse matrices}
00154     \{
00155       std::cout << \textcolor{stringliteral}{"Eigen sparse\(\backslash\)t"} << sm1.nonZeros()/(float(sm1.rows())*\textcolor{keywordtype}{float}(sm1.cols()))*100 << \textcolor{stringliteral}{"% * "}
00156                 << sm2.nonZeros()/(float(sm2.rows())*\textcolor{keywordtype}{float}(sm2.cols()))*100 << \textcolor{stringliteral}{"%\(\backslash\)n"};
00157 
00158       BENCH(sm3 = sm1 * sm2; )
00159       std::cout << \textcolor{stringliteral}{"   a * b:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00160 
00161 \textcolor{comment}{//       BENCH(sm3 = sm1.transpose() * sm2; )}
00162 \textcolor{comment}{//       std::cout << "   a' * b:\(\backslash\)t" << timer.value() << endl;}
00163 \textcolor{comment}{// //}
00164 \textcolor{comment}{//       BENCH(sm3 = sm1.transpose() * sm2.transpose(); )}
00165 \textcolor{comment}{//       std::cout << "   a' * b':\(\backslash\)t" << timer.value() << endl;}
00166 \textcolor{comment}{// //}
00167 \textcolor{comment}{//       BENCH(sm3 = sm1 * sm2.transpose(); )}
00168 \textcolor{comment}{//       std::cout << "   a * b' :\(\backslash\)t" << timer.value() << endl;}
00169 
00170 
00171 \textcolor{comment}{//       std::cout << "\(\backslash\)n";}
00172 \textcolor{comment}{//}
00173 \textcolor{comment}{//       BENCH( sm3.\_experimentalNewProduct(sm1, sm2); )}
00174 \textcolor{comment}{//       std::cout << "   a * b:\(\backslash\)t" << timer.value() << endl;}
00175 \textcolor{comment}{//}
00176 \textcolor{comment}{//       BENCH(sm3.\_experimentalNewProduct(sm1.transpose(),sm2); )}
00177 \textcolor{comment}{//       std::cout << "   a' * b:\(\backslash\)t" << timer.value() << endl;}
00178 \textcolor{comment}{// //}
00179 \textcolor{comment}{//       BENCH(sm3.\_experimentalNewProduct(sm1.transpose(),sm2.transpose()); )}
00180 \textcolor{comment}{//       std::cout << "   a' * b':\(\backslash\)t" << timer.value() << endl;}
00181 \textcolor{comment}{// //}
00182 \textcolor{comment}{//       BENCH(sm3.\_experimentalNewProduct(sm1, sm2.transpose());)}
00183 \textcolor{comment}{//       std::cout << "   a * b' :\(\backslash\)t" << timer.value() << endl;}
00184     \}
00185 
00186     \textcolor{comment}{// eigen dyn-sparse matrices}
00187     \textcolor{comment}{/*\{}
00188 \textcolor{comment}{      DynamicSparseMatrix<Scalar> m1(sm1), m2(sm2), m3(sm3);}
00189 \textcolor{comment}{      std::cout << "Eigen dyn-sparse\(\backslash\)t" << m1.nonZeros()/(float(m1.rows())*float(m1.cols()))*100 << "% * "}
00190 \textcolor{comment}{                << m2.nonZeros()/(float(m2.rows())*float(m2.cols()))*100 << "%\(\backslash\)n";}
00191 \textcolor{comment}{}
00192 \textcolor{comment}{//       timer.reset();}
00193 \textcolor{comment}{//       timer.start();}
00194 \textcolor{comment}{      BENCH(for (int k=0; k<REPEAT; ++k) m3 = m1 * m2;)}
00195 \textcolor{comment}{//       timer.stop();}
00196 \textcolor{comment}{      std::cout << "   a * b:\(\backslash\)t" << timer.value() << endl;}
00197 \textcolor{comment}{//       std::cout << sm3 << "\(\backslash\)n";}
00198 \textcolor{comment}{}
00199 \textcolor{comment}{      timer.reset();}
00200 \textcolor{comment}{      timer.start();}
00201 \textcolor{comment}{//       std::cerr << "transpose...\(\backslash\)n";}
00202 \textcolor{comment}{//       EigenSparseMatrix sm4 = sm1.transpose();}
00203 \textcolor{comment}{//       std::cout << sm4.nonZeros() << " == " << sm1.nonZeros() << "\(\backslash\)n";}
00204 \textcolor{comment}{//       exit(1);}
00205 \textcolor{comment}{//       std::cerr << "transpose OK\(\backslash\)n";}
00206 \textcolor{comment}{//       std::cout << sm1 << "\(\backslash\)n\(\backslash\)n" << sm1.transpose() << "\(\backslash\)n\(\backslash\)n" << sm4.transpose() << "\(\backslash\)n\(\backslash\)n";}
00207 \textcolor{comment}{      BENCH(for (int k=0; k<REPEAT; ++k) m3 = m1.transpose() * m2;)}
00208 \textcolor{comment}{//       timer.stop();}
00209 \textcolor{comment}{      std::cout << "   a' * b:\(\backslash\)t" << timer.value() << endl;}
00210 \textcolor{comment}{}
00211 \textcolor{comment}{//       timer.reset();}
00212 \textcolor{comment}{//       timer.start();}
00213 \textcolor{comment}{      BENCH( for (int k=0; k<REPEAT; ++k) m3 = m1.transpose() * m2.transpose(); )}
00214 \textcolor{comment}{//       timer.stop();}
00215 \textcolor{comment}{      std::cout << "   a' * b':\(\backslash\)t" << timer.value() << endl;}
00216 \textcolor{comment}{}
00217 \textcolor{comment}{//       timer.reset();}
00218 \textcolor{comment}{//       timer.start();}
00219 \textcolor{comment}{      BENCH( for (int k=0; k<REPEAT; ++k) m3 = m1 * m2.transpose(); )}
00220 \textcolor{comment}{//       timer.stop();}
00221 \textcolor{comment}{      std::cout << "   a * b' :\(\backslash\)t" << timer.value() << endl;}
00222 \textcolor{comment}{    \}*/}
00223 
00224     \textcolor{comment}{// CSparse}
00225 \textcolor{preprocessor}{    #ifdef CSPARSE}
00226     \{
00227       std::cout << \textcolor{stringliteral}{"CSparse \(\backslash\)t"} << nnzPerCol << \textcolor{stringliteral}{"%\(\backslash\)n"};
00228       cs *m1, *m2, *m3;
00229       eiToCSparse(sm1, m1);
00230       eiToCSparse(sm2, m2);
00231 
00232       BENCH(
00233       \{
00234         m3 = cs\_sorted\_multiply(m1, m2);
00235         \textcolor{keywordflow}{if} (!m3)
00236         \{
00237           std::cerr << \textcolor{stringliteral}{"cs\_multiply failed\(\backslash\)n"};
00238         \}
00239 \textcolor{comment}{//         cs\_print(m3, 0);}
00240         cs\_spfree(m3);
00241       \}
00242       );
00243 \textcolor{comment}{//       timer.stop();}
00244       std::cout << \textcolor{stringliteral}{"   a * b:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00245 
00246 \textcolor{comment}{//       BENCH( \{ m3 = cs\_sorted\_multiply2(m1, m2); cs\_spfree(m3); \} );}
00247 \textcolor{comment}{//       std::cout << "   a * b:\(\backslash\)t" << timer.value() << endl;}
00248     \}
00249 \textcolor{preprocessor}{    #endif}
00250 
00251 \textcolor{preprocessor}{    #ifndef NOUBLAS}
00252     \{
00253       std::cout << \textcolor{stringliteral}{"ublas\(\backslash\)t"} << nnzPerCol << \textcolor{stringliteral}{"%\(\backslash\)n"};
00254       UBlasSparse m1(rows,cols), m2(rows,cols), m3(rows,cols);
00255       eiToUblas(sm1, m1);
00256       eiToUblas(sm2, m2);
00257 
00258       BENCH(boost::numeric::ublas::prod(m1, m2, m3););
00259       std::cout << \textcolor{stringliteral}{"   a * b:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00260     \}
00261 \textcolor{preprocessor}{    #endif}
00262 
00263     \textcolor{comment}{// GMM++}
00264 \textcolor{preprocessor}{    #ifndef NOGMM}
00265     \{
00266       std::cout << \textcolor{stringliteral}{"GMM++ sparse\(\backslash\)t"} << nnzPerCol << \textcolor{stringliteral}{"%\(\backslash\)n"};
00267       GmmDynSparse  gmmT3(rows,cols);
00268       GmmSparse m1(rows,cols), m2(rows,cols), m3(rows,cols);
00269       eiToGmm(sm1, m1);
00270       eiToGmm(sm2, m2);
00271 
00272       BENCH(gmm::mult(m1, m2, gmmT3););
00273       std::cout << \textcolor{stringliteral}{"   a * b:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00274 
00275 \textcolor{comment}{//       BENCH(gmm::mult(gmm::transposed(m1), m2, gmmT3););}
00276 \textcolor{comment}{//       std::cout << "   a' * b:\(\backslash\)t" << timer.value() << endl;}
00277 \textcolor{comment}{//}
00278 \textcolor{comment}{//       if (rows<500)}
00279 \textcolor{comment}{//       \{}
00280 \textcolor{comment}{//         BENCH(gmm::mult(gmm::transposed(m1), gmm::transposed(m2), gmmT3););}
00281 \textcolor{comment}{//         std::cout << "   a' * b':\(\backslash\)t" << timer.value() << endl;}
00282 \textcolor{comment}{//}
00283 \textcolor{comment}{//         BENCH(gmm::mult(m1, gmm::transposed(m2), gmmT3););}
00284 \textcolor{comment}{//         std::cout << "   a * b':\(\backslash\)t" << timer.value() << endl;}
00285 \textcolor{comment}{//       \}}
00286 \textcolor{comment}{//       else}
00287 \textcolor{comment}{//       \{}
00288 \textcolor{comment}{//         std::cout << "   a' * b':\(\backslash\)t" << "forever" << endl;}
00289 \textcolor{comment}{//         std::cout << "   a * b':\(\backslash\)t" << "forever" << endl;}
00290 \textcolor{comment}{//       \}}
00291     \}
00292 \textcolor{preprocessor}{    #endif}
00293 
00294     \textcolor{comment}{// MTL4}
00295 \textcolor{preprocessor}{    #ifndef NOMTL}
00296     \{
00297       std::cout << \textcolor{stringliteral}{"MTL4\(\backslash\)t"} << nnzPerCol << \textcolor{stringliteral}{"%\(\backslash\)n"};
00298       MtlSparse m1(rows,cols), m2(rows,cols), m3(rows,cols);
00299       eiToMtl(sm1, m1);
00300       eiToMtl(sm2, m2);
00301 
00302       BENCH(m3 = m1 * m2;);
00303       std::cout << \textcolor{stringliteral}{"   a * b:\(\backslash\)t"} << timer.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() << endl;
00304 
00305 \textcolor{comment}{//       BENCH(m3 = trans(m1) * m2;);}
00306 \textcolor{comment}{//       std::cout << "   a' * b:\(\backslash\)t" << timer.value() << endl;}
00307 \textcolor{comment}{//}
00308 \textcolor{comment}{//       BENCH(m3 = trans(m1) * trans(m2););}
00309 \textcolor{comment}{//       std::cout << "  a' * b':\(\backslash\)t" << timer.value() << endl;}
00310 \textcolor{comment}{//}
00311 \textcolor{comment}{//       BENCH(m3 = m1 * trans(m2););}
00312 \textcolor{comment}{//       std::cout << "   a * b' :\(\backslash\)t" << timer.value() << endl;}
00313     \}
00314 \textcolor{preprocessor}{    #endif}
00315 
00316     std::cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
00317   \}
00318 
00319   \textcolor{keywordflow}{return} 0;
00320 \}
00321 
00322 
00323 
\end{DoxyCode}
