\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Conversion.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source}\index{Tensor\+Conversion.\+h@{Tensor\+Conversion.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_CONVERSION\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_CONVERSION\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TargetType, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00024}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_conversion_op_3_01_target_type_00_01_xpr_type_01_4_01_4}{00024} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_conversion_op}{TensorConversionOp}<TargetType, XprType> >
00025 \{
00026   \textcolor{comment}{// Type promotion to handle the case where the types of the lhs and the rhs are different.}
00027   \textcolor{keyword}{typedef} TargetType Scalar;
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>::StorageKind} StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>::Index} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<Nested>::type} 
      \hyperlink{group___sparse_core___module}{\_Nested};
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>::NumDimensions};
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>::Layout};
00034   \textcolor{keyword}{enum} \{ Flags = 0 \};
00035 \};
00036 
00037 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TargetType, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00038}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_conversion_op_3_01_target_type_00_01_xpr_type_01_4_00_01_eigen_1_1_dense_01_4}{00038} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_conversion_op}{TensorConversionOp}<TargetType, XprType>, \hyperlink{namespace_eigen}{Eigen}::
      \hyperlink{struct_eigen_1_1_dense}{Dense}>
00039 \{
00040   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_conversion_op}{TensorConversionOp<TargetType, XprType>}& 
      \hyperlink{class_eigen_1_1_tensor_conversion_op}{type};
00041 \};
00042 
00043 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TargetType, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00044}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_conversion_op_3_01_target_type_00_01_xpr_type_01_b83af6d243a47c048dc01ffbe6156814}{00044} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_conversion_op}{TensorConversionOp}<TargetType, XprType>, 1, typename 
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_conversion_op}{TensorConversionOp}<TargetType, XprType> >::\hyperlink{class_eigen_1_1_tensor_conversion_op}{type}>
00045 \{
00046   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_conversion_op}{TensorConversionOp<TargetType, XprType>} 
      \hyperlink{class_eigen_1_1_tensor_conversion_op}{type};
00047 \};
00048 
00049 \}  \textcolor{comment}{// end namespace internal}
00050 
00051 
00052 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TensorEvaluator, \textcolor{keyword}{typename} SrcPacket, \textcolor{keyword}{typename} TgtPacket, \textcolor{keywordtype}{int} SrcCoeffRatio, \textcolor{keywordtype}{int} TgtCoeff
      Ratio>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00053}\hyperlink{struct_eigen_1_1_packet_converter}{00053} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_packet_converter}{PacketConverter} \{
00054   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00055   \hyperlink{struct_eigen_1_1_packet_converter}{PacketConverter}(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}& impl)
00056       : m\_impl(impl) \{\}
00057 
00058   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} Index>
00059   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TgtPacket packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const }\{
00060     \textcolor{keywordflow}{return} internal::pcast<SrcPacket, TgtPacket>(m\_impl.template packet<LoadMode>(index));
00061   \}
00062 
00063  \textcolor{keyword}{private}:
00064   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}& m\_impl;
00065 \};
00066 
00067 
00068 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TensorEvaluator, \textcolor{keyword}{typename} SrcPacket, \textcolor{keyword}{typename} TgtPacket>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00069}\hyperlink{struct_eigen_1_1_packet_converter_3_01_tensor_evaluator_00_01_src_packet_00_01_tgt_packet_00_012_00_011_01_4}{00069} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_packet_converter}{PacketConverter}<\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}, SrcPacket, TgtPacket, 2, 1> \{
00070   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00071   \hyperlink{struct_eigen_1_1_packet_converter}{PacketConverter}(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}& impl)
00072       : m\_impl(impl) \{\}
00073 
00074   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} Index>
00075   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TgtPacket packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const }\{
00076     \textcolor{keyword}{const} \textcolor{keywordtype}{int} SrcPacketSize = \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<SrcPacket>::size}
      ;
00077 
00078     SrcPacket src1 = m\_impl.template packet<LoadMode>(index);
00079     SrcPacket src2 = m\_impl.template packet<LoadMode>(index + SrcPacketSize);
00080     TgtPacket result = internal::pcast<SrcPacket, TgtPacket>(src1, src2);
00081     \textcolor{keywordflow}{return} result;
00082   \}
00083 
00084  \textcolor{keyword}{private}:
00085   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}& m\_impl;
00086 \};
00087 
00088 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TensorEvaluator, \textcolor{keyword}{typename} SrcPacket, \textcolor{keyword}{typename} TgtPacket>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00089}\hyperlink{struct_eigen_1_1_packet_converter_3_01_tensor_evaluator_00_01_src_packet_00_01_tgt_packet_00_014_00_011_01_4}{00089} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_packet_converter}{PacketConverter}<\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}, SrcPacket, TgtPacket, 4, 1> \{
00090   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00091   \hyperlink{struct_eigen_1_1_packet_converter}{PacketConverter}(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}& impl)
00092       : m\_impl(impl) \{\}
00093 
00094   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} Index>
00095   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TgtPacket packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const }\{
00096     \textcolor{keyword}{const} \textcolor{keywordtype}{int} SrcPacketSize = \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<SrcPacket>::size}
      ;
00097 
00098     SrcPacket src1 = m\_impl.template packet<LoadMode>(index);
00099     SrcPacket src2 = m\_impl.template packet<LoadMode>(index + SrcPacketSize);
00100     SrcPacket src3 = m\_impl.template packet<LoadMode>(index + 2 * SrcPacketSize);
00101     SrcPacket src4 = m\_impl.template packet<LoadMode>(index + 3 * SrcPacketSize);
00102     TgtPacket result = internal::pcast<SrcPacket, TgtPacket>(src1, src2, src3, src4);
00103     \textcolor{keywordflow}{return} result;
00104   \}
00105 
00106  \textcolor{keyword}{private}:
00107   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}& m\_impl;
00108 \};
00109 
00110 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TensorEvaluator, \textcolor{keyword}{typename} SrcPacket, \textcolor{keyword}{typename} TgtPacket>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00111}\hyperlink{struct_eigen_1_1_packet_converter_3_01_tensor_evaluator_00_01_src_packet_00_01_tgt_packet_00_011_00_012_01_4}{00111} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_packet_converter}{PacketConverter}<\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}, SrcPacket, TgtPacket, 1, 2> \{
00112   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00113   \hyperlink{struct_eigen_1_1_packet_converter}{PacketConverter}(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}& impl)
00114       : m\_impl(impl), m\_maxIndex(impl.dimensions().TotalSize()) \{\}
00115 
00116   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode, \textcolor{keyword}{typename} Index>
00117   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TgtPacket packet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} index)\textcolor{keyword}{ const }\{
00118     \textcolor{keyword}{const} \textcolor{keywordtype}{int} SrcPacketSize = \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<SrcPacket>::size}
      ;
00119     \textcolor{comment}{// Only call m\_impl.packet() when we have direct access to the underlying data. This}
00120     \textcolor{comment}{// ensures that we don't compute the subexpression twice. We may however load some}
00121     \textcolor{comment}{// coefficients twice, but in practice this doesn't negatively impact performance.}
00122     \textcolor{keywordflow}{if} (m\_impl.data() && (index + SrcPacketSize < m\_maxIndex)) \{
00123       \textcolor{comment}{// Force unaligned memory loads since we can't ensure alignment anymore}
00124       \textcolor{keywordflow}{return} internal::pcast<SrcPacket, TgtPacket>(m\_impl.template packet<Unaligned>(index));
00125     \} \textcolor{keywordflow}{else} \{
00126       \textcolor{keyword}{const} \textcolor{keywordtype}{int} TgtPacketSize = \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<TgtPacket>::size}
      ;
00127       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{union_eigen_1_1internal_1_1_packet}{internal::unpacket\_traits<SrcPacket>::type}
       SrcType;
00128       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{union_eigen_1_1internal_1_1_packet}{internal::unpacket\_traits<TgtPacket>::type}
       TgtType;
00129       \hyperlink{struct_eigen_1_1internal_1_1scalar__cast__op}{internal::scalar\_cast\_op<SrcType, TgtType>} converter;
00130       EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} \hyperlink{union_eigen_1_1internal_1_1_packet}{internal::unpacket\_traits<TgtPacket>::type}
       values[TgtPacketSize];
00131       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < TgtPacketSize; ++i) \{
00132         values[i] = converter(m\_impl.coeff(index+i));
00133       \}
00134       TgtPacket rslt = internal::pload<TgtPacket>(values);
00135       \textcolor{keywordflow}{return} rslt;
00136     \}
00137   \}
00138 
00139  \textcolor{keyword}{private}:
00140   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}& m\_impl;
00141   \textcolor{keyword}{const} \textcolor{keyword}{typename} TensorEvaluator::Index m\_maxIndex;
00142 \};
00143 
00144 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TargetType, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00145}\hyperlink{class_eigen_1_1_tensor_conversion_op}{00145} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_conversion_op}{TensorConversionOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorConversionOp<TargetType, Xpr
      Type>, ReadOnlyAccessors>
00146 \{
00147   \textcolor{keyword}{public}:
00148     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<TensorConversionOp>::Scalar}
       Scalar;
00149     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<TensorConversionOp>::StorageKind}
       StorageKind;
00150     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<TensorConversionOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00151     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested<TensorConversionOp>::type} 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Nested};
00152     \textcolor{keyword}{typedef} Scalar CoeffReturnType;
00153     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00154 
00155     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_conversion_op}{TensorConversionOp}(\textcolor{keyword}{const} XprType& xpr)
00156         : m\_xpr(xpr) \{\}
00157 
00158     EIGEN\_DEVICE\_FUNC
00159     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename XprType::Nested>::type}
      &
00160     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00161 
00162   \textcolor{keyword}{protected}:
00163     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00164 \};
00165 
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00166}\hyperlink{struct_eigen_1_1_conversion_sub_expr_eval}{00166} \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} SameType, \textcolor{keyword}{typename} Eval, \textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }
      \hyperlink{struct_eigen_1_1_conversion_sub_expr_eval}{ConversionSubExprEval} \{
00167   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} run(Eval& impl, Scalar*) \{
00168     impl.evalSubExprsIfNeeded(NULL);
00169     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00170   \}
00171 \};
00172 
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00173}\hyperlink{struct_eigen_1_1_conversion_sub_expr_eval_3_01true_00_01_eval_00_01_scalar_01_4}{00173} \textcolor{keyword}{template} <\textcolor{keyword}{typename} Eval, \textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_conversion_sub_expr_eval}{ConversionSubExprEval}<true, Eval, 
      Scalar> \{
00174   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} run(Eval& impl, Scalar* data) \{
00175     \textcolor{keywordflow}{return} impl.evalSubExprsIfNeeded(data);
00176   \}
00177 \};
00178 
00179 
00180 \textcolor{comment}{// Eval as rvalue}
00181 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TargetType, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00182}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_conversion_op_3_01_target_type_00_01_arg_type_01_4_00_01_device_01_4}{00182} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_conversion_op}{TensorConversionOp}<TargetType, ArgType>, 
      Device>
00183 \{
00184   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_conversion_op}{TensorConversionOp<TargetType, ArgType>} 
      \hyperlink{class_eigen_1_1_tensor_conversion_op}{XprType};
00185   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00186   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Dimensions}
       Dimensions;
00187   \textcolor{keyword}{typedef} TargetType Scalar;
00188   \textcolor{keyword}{typedef} TargetType CoeffReturnType;
00189   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1remove__all}{internal::remove\_all<typename internal::traits<ArgType>::Scalar}
      >::type \hyperlink{group___sparse_core___module}{SrcType};
00190   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00191   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<SrcType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketSourceType};
00192   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size};
00193 
00194   \textcolor{keyword}{enum} \{
00195     IsAligned = \textcolor{keyword}{false},
00196     PacketAccess = \textcolor{keyword}{true},
00197     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Layout},
00198     RawAccess = \textcolor{keyword}{false}
00199   \};
00200 
00201   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00202     : m\_impl(op.expression(), device)
00203   \{
00204   \}
00205 
00206   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_impl.dimensions(); 
      \}
00207 
00208   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* data)
00209   \{
00210     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_conversion_sub_expr_eval}{ConversionSubExprEval<internal::is\_same<TargetType, SrcType>::value}
      , \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>}, Scalar>::run(m\_impl, data);
00211   \}
00212 
00213   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup()
00214   \{
00215     m\_impl.cleanup();
00216   \}
00217 
00218   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00219 \textcolor{keyword}{  }\{
00220     \hyperlink{struct_eigen_1_1internal_1_1scalar__cast__op}{internal::scalar\_cast\_op<SrcType, TargetType>} converter;
00221     \textcolor{keywordflow}{return} converter(m\_impl.coeff(index));
00222   \}
00223 
00224   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00225   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00226 \textcolor{keyword}{  }\{
00227     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} Vectorizable = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::PacketAccess}
       &
00228         \hyperlink{struct_eigen_1_1internal_1_1type__casting__traits}{internal::type\_casting\_traits<SrcType, TargetType>::VectorizedCast}
      ;
00229     \textcolor{keywordflow}{return} PacketConv<LoadMode, Vectorizable>::run(m\_impl, index);
00230   \}
00231 
00232   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}
00233   costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00234     \textcolor{keyword}{const} \textcolor{keywordtype}{double} cast\_cost = TensorOpCost::CastCost<SrcType, TargetType>();
00235     \textcolor{keywordflow}{if} (vectorized) \{
00236       \textcolor{keyword}{const} \textcolor{keywordtype}{double} SrcCoeffRatio =
00237           \hyperlink{struct_eigen_1_1internal_1_1type__casting__traits}{internal::type\_casting\_traits<SrcType, TargetType>::SrcCoeffRatio}
      ;
00238       \textcolor{keyword}{const} \textcolor{keywordtype}{double} TgtCoeffRatio =
00239           \hyperlink{struct_eigen_1_1internal_1_1type__casting__traits}{internal::type\_casting\_traits<SrcType, TargetType>::TgtCoeffRatio}
      ;
00240       \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) * (SrcCoeffRatio / PacketSize) +
00241           \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, TgtCoeffRatio * (cast\_cost / PacketSize));
00242     \} \textcolor{keywordflow}{else} \{
00243       \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) + \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, cast\_cost);
00244     \}
00245   \}
00246 
00247   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00248 
00249   \textcolor{keyword}{protected}:
00250   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} LoadMode, \textcolor{keywordtype}{bool} ActuallyVectorize>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00251}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_conversion_op_3_01_target_type_00_01_arg_t3168668fdfbeba0eb2459f9b9de77bc7}{00251}   \textcolor{keyword}{struct }PacketConv \{
00252     \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType run(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>}& impl, Index index) \{
00253       \hyperlink{struct_eigen_1_1internal_1_1scalar__cast__op}{internal::scalar\_cast\_op<SrcType, TargetType>} converter;
00254       EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<CoeffReturnType>::type}
       values[PacketSize];
00255       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00256         values[i] = converter(impl.coeff(index+i));
00257       \}
00258       PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00259       \textcolor{keywordflow}{return} rslt;
00260     \}
00261   \};
00262 
00263   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} LoadMode>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_conversion_8h_source_l00264}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_conversion_op_3_01_target_type_00_01_arg_t2fb5a078ff43de9fbe10110949df4d26}{00264}   \textcolor{keyword}{struct }PacketConv<LoadMode, true> \{
00265     \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType run(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>}& impl, Index index) \{
00266       \textcolor{keyword}{const} \textcolor{keywordtype}{int} SrcCoeffRatio = 
      \hyperlink{struct_eigen_1_1internal_1_1type__casting__traits}{internal::type\_casting\_traits<SrcType, TargetType>::SrcCoeffRatio}
      ;
00267       \textcolor{keyword}{const} \textcolor{keywordtype}{int} TgtCoeffRatio = 
      \hyperlink{struct_eigen_1_1internal_1_1type__casting__traits}{internal::type\_casting\_traits<SrcType, TargetType>::TgtCoeffRatio}
      ;
00268       \hyperlink{struct_eigen_1_1_packet_converter}{PacketConverter<TensorEvaluator<ArgType, Device>}, 
      PacketSourceType, PacketReturnType,
00269                       SrcCoeffRatio, TgtCoeffRatio> converter(impl);
00270       \textcolor{keywordflow}{return} converter.template packet<LoadMode>(index);
00271     \}
00272   \};
00273 
00274   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} m\_impl;
00275 \};
00276 
00277 \} \textcolor{comment}{// end namespace Eigen}
00278 
00279 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_CONVERSION\_H}
\end{DoxyCode}
