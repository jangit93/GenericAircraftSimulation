\hypertarget{eigen_2_eigen_2src_2_core_2_assign___m_k_l_8h_source}{}\section{eigen/\+Eigen/src/\+Core/\+Assign\+\_\+\+M\+KL.h}
\label{eigen_2_eigen_2src_2_core_2_assign___m_k_l_8h_source}\index{Assign\+\_\+\+M\+K\+L.\+h@{Assign\+\_\+\+M\+K\+L.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ Copyright (c) 2011, Intel Corporation. All rights reserved.}
00003 \textcolor{comment}{ Copyright (C) 2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00004 \textcolor{comment}{ }
00005 \textcolor{comment}{ Redistribution and use in source and binary forms, with or without modification,}
00006 \textcolor{comment}{ are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{}
00008 \textcolor{comment}{ * Redistributions of source code must retain the above copyright notice, this}
00009 \textcolor{comment}{   list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ * Redistributions in binary form must reproduce the above copyright notice,}
00011 \textcolor{comment}{   this list of conditions and the following disclaimer in the documentation}
00012 \textcolor{comment}{   and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ * Neither the name of Intel Corporation nor the names of its contributors may}
00014 \textcolor{comment}{   be used to endorse or promote products derived from this software without}
00015 \textcolor{comment}{   specific prior written permission.}
00016 \textcolor{comment}{}
00017 \textcolor{comment}{ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND}
00018 \textcolor{comment}{ ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED}
00019 \textcolor{comment}{ WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE}
00020 \textcolor{comment}{ DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR}
00021 \textcolor{comment}{ ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES}
00022 \textcolor{comment}{ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;}
00023 \textcolor{comment}{ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON}
00024 \textcolor{comment}{ ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}
00025 \textcolor{comment}{ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS}
00026 \textcolor{comment}{ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}
00027 \textcolor{comment}{}
00028 \textcolor{comment}{ ********************************************************************************}
00029 \textcolor{comment}{ *   Content : Eigen bindings to Intel(R) MKL}
00030 \textcolor{comment}{ *   MKL VML support for coefficient-wise unary Eigen expressions like a=b.sin()}
00031 \textcolor{comment}{ ********************************************************************************}
00032 \textcolor{comment}{*/}
00033 
00034 \textcolor{preprocessor}{#ifndef EIGEN\_ASSIGN\_VML\_H}
00035 \textcolor{preprocessor}{#define EIGEN\_ASSIGN\_VML\_H}
00036 
00037 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00038 
00039 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00040 
00041 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst, \textcolor{keyword}{typename} Src>
\Hypertarget{eigen_2_eigen_2src_2_core_2_assign___m_k_l_8h_source_l00042}\hyperlink{class_eigen_1_1internal_1_1vml__assign__traits}{00042} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1vml__assign__traits}{vml\_assign\_traits}
00043 \{
00044   \textcolor{keyword}{private}:
00045     \textcolor{keyword}{enum} \{
00046       DstHasDirectAccess = Dst::Flags & \hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit},
00047       SrcHasDirectAccess = Src::Flags & \hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit},
00048       StorageOrdersAgree = (int(Dst::IsRowMajor) == int(Src::IsRowMajor)),
00049       InnerSize = \textcolor{keywordtype}{int}(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)
00050                 : int(Dst::Flags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} ? int(Dst::ColsAtCompileTime)
00051                 : int(Dst::RowsAtCompileTime),
00052       InnerMaxSize  = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)
00053                     : int(Dst::Flags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} ? int(Dst::MaxColsAtCompileTime)
00054                     : int(Dst::MaxRowsAtCompileTime),
00055       MaxSizeAtCompileTime = Dst::SizeAtCompileTime,
00056 
00057       MightEnableVml = StorageOrdersAgree && DstHasDirectAccess && SrcHasDirectAccess && 
      Src::InnerStrideAtCompileTime==1 && Dst::InnerStrideAtCompileTime==1,
00058       MightLinearize = MightEnableVml && (int(Dst::Flags) & int(Src::Flags) & 
      \hyperlink{group__flags_ga4b983a15d57cd55806df618ac544d09e}{LinearAccessBit}),
00059       VmlSize = MightLinearize ? MaxSizeAtCompileTime : InnerMaxSize,
00060       LargeEnough = VmlSize==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic} || VmlSize>=EIGEN\_MKL\_VML\_THRESHOLD
00061     \};
00062   \textcolor{keyword}{public}:
00063     \textcolor{keyword}{enum} \{
00064       EnableVml = MightEnableVml && LargeEnough,
00065       Traversal = MightLinearize ? LinearTraversal : DefaultTraversal
00066     \};
00067 \};
00068 
00069 \textcolor{preprocessor}{#define EIGEN\_PP\_EXPAND(ARG) ARG}
00070 \textcolor{preprocessor}{#if !defined (EIGEN\_FAST\_MATH) || (EIGEN\_FAST\_MATH != 1)}
00071 \textcolor{preprocessor}{#define EIGEN\_VMLMODE\_EXPAND\_LA , VML\_HA}
00072 \textcolor{preprocessor}{#else}
00073 \textcolor{preprocessor}{#define EIGEN\_VMLMODE\_EXPAND\_LA , VML\_LA}
00074 \textcolor{preprocessor}{#endif}
00075 
00076 \textcolor{preprocessor}{#define EIGEN\_VMLMODE\_EXPAND\_\_ }
00077 
00078 \textcolor{preprocessor}{#define EIGEN\_VMLMODE\_PREFIX\_LA vm}
00079 \textcolor{preprocessor}{#define EIGEN\_VMLMODE\_PREFIX\_\_  v}
00080 \textcolor{preprocessor}{#define EIGEN\_VMLMODE\_PREFIX(VMLMODE) EIGEN\_CAT(EIGEN\_VMLMODE\_PREFIX\_,VMLMODE)}
00081 
00082 \textcolor{preprocessor}{#define EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALL(EIGENOP, VMLOP, EIGENTYPE, VMLTYPE, VMLMODE)                      
                           \(\backslash\)}
00083 \textcolor{preprocessor}{  template< typename DstXprType, typename SrcXprNested>                                                    
                           \(\backslash\)}
00084 \textcolor{preprocessor}{  struct Assignment<DstXprType, CwiseUnaryOp<scalar\_##EIGENOP##\_op<EIGENTYPE>, SrcXprNested>,
       assign\_op<EIGENTYPE,EIGENTYPE>,   \(\backslash\)}
00085 \textcolor{preprocessor}{                   Dense2Dense, typename
       enable\_if<vml\_assign\_traits<DstXprType,SrcXprNested>::EnableVml>::type> \{              \(\backslash\)}
00086 \textcolor{preprocessor}{    typedef CwiseUnaryOp<scalar\_##EIGENOP##\_op<EIGENTYPE>, SrcXprNested> SrcXprType;                       
                           \(\backslash\)}
00087 \textcolor{preprocessor}{    static void run(DstXprType &dst, const SrcXprType &src, const assign\_op<EIGENTYPE,EIGENTYPE> &}\textcolor{comment}{/*func*/}\textcolor{preprocessor}{)
       \{                   \(\backslash\)}
00088 \textcolor{preprocessor}{      eigen\_assert(dst.rows() == src.rows() && dst.cols() == src.cols());                                  
                           \(\backslash\)}
00089 \textcolor{preprocessor}{      if(vml\_assign\_traits<DstXprType,SrcXprNested>::Traversal==LinearTraversal) \{                         
                           \(\backslash\)}
00090 \textcolor{preprocessor}{        VMLOP(dst.size(), (const VMLTYPE*)src.nestedExpression().data(),                                   
                           \(\backslash\)}
00091 \textcolor{preprocessor}{              (VMLTYPE*)dst.data() EIGEN\_PP\_EXPAND(EIGEN\_VMLMODE\_EXPAND\_##VMLMODE) );                      
                           \(\backslash\)}
00092 \textcolor{preprocessor}{      \} else \{                                                                                             
                           \(\backslash\)}
00093 \textcolor{preprocessor}{        const Index outerSize = dst.outerSize();                                                           
                           \(\backslash\)}
00094 \textcolor{preprocessor}{        for(Index outer = 0; outer < outerSize; ++outer) \{                                                 
                           \(\backslash\)}
00095 \textcolor{preprocessor}{          const EIGENTYPE *src\_ptr = src.IsRowMajor ? &(src.nestedExpression().coeffRef(outer,0)) :        
                           \(\backslash\)}
00096 \textcolor{preprocessor}{                                                      &(src.nestedExpression().coeffRef(0, outer));        
                           \(\backslash\)}
00097 \textcolor{preprocessor}{          EIGENTYPE *dst\_ptr = dst.IsRowMajor ? &(dst.coeffRef(outer,0)) : &(dst.coeffRef(0, outer));      
                           \(\backslash\)}
00098 \textcolor{preprocessor}{          VMLOP( dst.innerSize(), (const VMLTYPE*)src\_ptr,                                                 
                           \(\backslash\)}
00099 \textcolor{preprocessor}{                (VMLTYPE*)dst\_ptr EIGEN\_PP\_EXPAND(EIGEN\_VMLMODE\_EXPAND\_##VMLMODE));                        
                           \(\backslash\)}
00100 \textcolor{preprocessor}{        \}                                                                                                  
                           \(\backslash\)}
00101 \textcolor{preprocessor}{      \}                                                                                                    
                           \(\backslash\)}
00102 \textcolor{preprocessor}{    \}                                                                                                      
                           \(\backslash\)}
00103 \textcolor{preprocessor}{  \};                                                                                                       
                           \(\backslash\)}
00104 \textcolor{preprocessor}{}
00105 
00106 \textcolor{preprocessor}{#define EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS\_REAL(EIGENOP, VMLOP, VMLMODE)                                    
                           \(\backslash\)}
00107 \textcolor{preprocessor}{  EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALL(EIGENOP, EIGEN\_CAT(EIGEN\_VMLMODE\_PREFIX(VMLMODE),s##VMLOP), float,
       float, VMLMODE)           \(\backslash\)}
00108 \textcolor{preprocessor}{  EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALL(EIGENOP, EIGEN\_CAT(EIGEN\_VMLMODE\_PREFIX(VMLMODE),d##VMLOP), double,
       double, VMLMODE)}
00109 
00110 \textcolor{preprocessor}{#define EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS\_CPLX(EIGENOP, VMLOP, VMLMODE)                                    
                           \(\backslash\)}
00111 \textcolor{preprocessor}{  EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALL(EIGENOP, EIGEN\_CAT(EIGEN\_VMLMODE\_PREFIX(VMLMODE),c##VMLOP), scomplex,
       MKL\_Complex8, VMLMODE) \(\backslash\)}
00112 \textcolor{preprocessor}{  EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALL(EIGENOP, EIGEN\_CAT(EIGEN\_VMLMODE\_PREFIX(VMLMODE),z##VMLOP), dcomplex,
       MKL\_Complex16, VMLMODE)}
00113   
00114 \textcolor{preprocessor}{#define EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(EIGENOP, VMLOP, VMLMODE)                                         
                           \(\backslash\)}
00115 \textcolor{preprocessor}{  EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS\_REAL(EIGENOP, VMLOP, VMLMODE)                                          
                           \(\backslash\)}
00116 \textcolor{preprocessor}{  EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS\_CPLX(EIGENOP, VMLOP, VMLMODE)}
00117 
00118   
00119 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(sin,   Sin,   LA)
00120 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(asin,  Asin,  LA)
00121 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(sinh,  Sinh,  LA)
00122 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(cos,   Cos,   LA)
00123 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(acos,  Acos,  LA)
00124 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(cosh,  Cosh,  LA)
00125 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(tan,   Tan,   LA)
00126 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(atan,  Atan,  LA)
00127 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(tanh,  Tanh,  LA)
00128 \textcolor{comment}{// EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(abs,   Abs,    \_)}
00129 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(exp,   Exp,   LA)
00130 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(\hyperlink{structlog}{log},   Ln,    LA)
00131 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(log10, Log10, LA)
00132 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS(sqrt,  Sqrt,  \_)
00133 
00134 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS\_REAL(square, Sqr,   \_)
00135 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS\_CPLX(arg, Arg,      \_)
00136 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS\_REAL(round, Round,  \_)
00137 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS\_REAL(floor, Floor,  \_)
00138 EIGEN\_MKL\_VML\_DECLARE\_UNARY\_CALLS\_REAL(ceil,  Ceil,   \_)
00139 
00140 \textcolor{preprocessor}{#define EIGEN\_MKL\_VML\_DECLARE\_POW\_CALL(EIGENOP, VMLOP, EIGENTYPE, VMLTYPE, VMLMODE)                        
                         \(\backslash\)}
00141 \textcolor{preprocessor}{  template< typename DstXprType, typename SrcXprNested, typename Plain>                                    
                         \(\backslash\)}
00142 \textcolor{preprocessor}{  struct Assignment<DstXprType, CwiseBinaryOp<scalar\_##EIGENOP##\_op<EIGENTYPE,EIGENTYPE>, SrcXprNested,    
                         \(\backslash\)}
00143 \textcolor{preprocessor}{                    const CwiseNullaryOp<internal::scalar\_constant\_op<EIGENTYPE>,Plain> >,
       assign\_op<EIGENTYPE,EIGENTYPE>,    \(\backslash\)}
00144 \textcolor{preprocessor}{                   Dense2Dense, typename
       enable\_if<vml\_assign\_traits<DstXprType,SrcXprNested>::EnableVml>::type> \{            \(\backslash\)}
00145 \textcolor{preprocessor}{    typedef CwiseBinaryOp<scalar\_##EIGENOP##\_op<EIGENTYPE,EIGENTYPE>, SrcXprNested,                        
                         \(\backslash\)}
00146 \textcolor{preprocessor}{                    const CwiseNullaryOp<internal::scalar\_constant\_op<EIGENTYPE>,Plain> > SrcXprType;      
                         \(\backslash\)}
00147 \textcolor{preprocessor}{    static void run(DstXprType &dst, const SrcXprType &src, const assign\_op<EIGENTYPE,EIGENTYPE> &}\textcolor{comment}{/*func*/}\textcolor{preprocessor}{)
       \{                 \(\backslash\)}
00148 \textcolor{preprocessor}{      eigen\_assert(dst.rows() == src.rows() && dst.cols() == src.cols());                                  
                         \(\backslash\)}
00149 \textcolor{preprocessor}{      VMLTYPE exponent = reinterpret\_cast<const VMLTYPE&>(src.rhs().functor().m\_other);                    
                         \(\backslash\)}
00150 \textcolor{preprocessor}{      if(vml\_assign\_traits<DstXprType,SrcXprNested>::Traversal==LinearTraversal)                           
                         \(\backslash\)}
00151 \textcolor{preprocessor}{      \{                                                                                                    
                         \(\backslash\)}
00152 \textcolor{preprocessor}{        VMLOP( dst.size(), (const VMLTYPE*)src.lhs().data(), exponent,                                     
                         \(\backslash\)}
00153 \textcolor{preprocessor}{              (VMLTYPE*)dst.data() EIGEN\_PP\_EXPAND(EIGEN\_VMLMODE\_EXPAND\_##VMLMODE) );                      
                         \(\backslash\)}
00154 \textcolor{preprocessor}{      \} else \{                                                                                             
                         \(\backslash\)}
00155 \textcolor{preprocessor}{        const Index outerSize = dst.outerSize();                                                           
                         \(\backslash\)}
00156 \textcolor{preprocessor}{        for(Index outer = 0; outer < outerSize; ++outer) \{                                                 
                         \(\backslash\)}
00157 \textcolor{preprocessor}{          const EIGENTYPE *src\_ptr = src.IsRowMajor ? &(src.lhs().coeffRef(outer,0)) :                     
                         \(\backslash\)}
00158 \textcolor{preprocessor}{                                                      &(src.lhs().coeffRef(0, outer));                     
                         \(\backslash\)}
00159 \textcolor{preprocessor}{          EIGENTYPE *dst\_ptr = dst.IsRowMajor ? &(dst.coeffRef(outer,0)) : &(dst.coeffRef(0, outer));      
                         \(\backslash\)}
00160 \textcolor{preprocessor}{          VMLOP( dst.innerSize(), (const VMLTYPE*)src\_ptr, exponent,                                       
                         \(\backslash\)}
00161 \textcolor{preprocessor}{                 (VMLTYPE*)dst\_ptr EIGEN\_PP\_EXPAND(EIGEN\_VMLMODE\_EXPAND\_##VMLMODE));                       
                         \(\backslash\)}
00162 \textcolor{preprocessor}{        \}                                                                                                  
                         \(\backslash\)}
00163 \textcolor{preprocessor}{      \}                                                                                                    
                         \(\backslash\)}
00164 \textcolor{preprocessor}{    \}                                                                                                      
                         \(\backslash\)}
00165 \textcolor{preprocessor}{  \};}
00166   
00167 EIGEN\_MKL\_VML\_DECLARE\_POW\_CALL(pow, vmsPowx, \textcolor{keywordtype}{float},    \textcolor{keywordtype}{float},         LA)
00168 EIGEN\_MKL\_VML\_DECLARE\_POW\_CALL(pow, vmdPowx, \textcolor{keywordtype}{double},   \textcolor{keywordtype}{double},        LA)
00169 EIGEN\_MKL\_VML\_DECLARE\_POW\_CALL(pow, vmcPowx, scomplex, MKL\_Complex8,  LA)
00170 EIGEN\_MKL\_VML\_DECLARE\_POW\_CALL(pow, vmzPowx, dcomplex, MKL\_Complex16, LA)
00171 
00172 \} \textcolor{comment}{// end namespace internal}
00173 
00174 \} \textcolor{comment}{// end namespace Eigen}
00175 
00176 \textcolor{preprocessor}{#endif // EIGEN\_ASSIGN\_VML\_H}
\end{DoxyCode}
