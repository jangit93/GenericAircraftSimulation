\hypertarget{matio_2visual__studio_2test_2eigen_2test_2geo__homogeneous_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/geo\+\_\+homogeneous.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2geo__homogeneous_8cpp_source}\index{geo\+\_\+homogeneous.\+cpp@{geo\+\_\+homogeneous.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 \textcolor{preprocessor}{#include <Eigen/Geometry>}
00012 
00013 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keywordtype}{int} Size> \textcolor{keywordtype}{void} homogeneous(\textcolor{keywordtype}{void})
00014 \{
00015   \textcolor{comment}{/* this test covers the following files:}
00016 \textcolor{comment}{     Homogeneous.h}
00017 \textcolor{comment}{  */}
00018 
00019   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Size,Size>} MatrixType;
00020   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Size,1, ColMajor>} 
      \hyperlink{struct_vector_type}{VectorType};
00021 
00022   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Size+1,Size>} HMatrixType;
00023   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Size+1,1>} HVectorType;
00024 
00025   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Size,Size+1>}   T1MatrixType;
00026   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Size+1,Size+1>} T2MatrixType;
00027   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Size+1,Size>} T3MatrixType;
00028 
00029   VectorType v0 = VectorType::Random(),
00030              ones = VectorType::Ones();
00031 
00032   HVectorType hv0 = HVectorType::Random();
00033 
00034   MatrixType m0 = MatrixType::Random();
00035 
00036   HMatrixType hm0 = HMatrixType::Random();
00037 
00038   hv0 << v0, 1;
00039   VERIFY\_IS\_APPROX(v0.homogeneous(), hv0);
00040   VERIFY\_IS\_APPROX(v0, hv0.hnormalized());
00041   
00042   VERIFY\_IS\_APPROX(v0.homogeneous().sum(), hv0.sum());
00043   VERIFY\_IS\_APPROX(v0.homogeneous().minCoeff(), hv0.minCoeff());
00044   VERIFY\_IS\_APPROX(v0.homogeneous().maxCoeff(), hv0.maxCoeff());
00045 
00046   hm0 << m0, ones.transpose();
00047   VERIFY\_IS\_APPROX(m0.colwise().homogeneous(), hm0);
00048   VERIFY\_IS\_APPROX(m0, hm0.colwise().hnormalized());
00049   hm0.row(Size-1).setRandom();
00050   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<Size; ++j)
00051     m0.col(j) = hm0.col(j).head(Size) / hm0(Size,j);
00052   VERIFY\_IS\_APPROX(m0, hm0.colwise().hnormalized());
00053 
00054   T1MatrixType t1 = T1MatrixType::Random();
00055   VERIFY\_IS\_APPROX(t1 * (v0.homogeneous().eval()), t1 * v0.homogeneous());
00056   VERIFY\_IS\_APPROX(t1 * (m0.colwise().homogeneous().eval()), t1 * m0.colwise().homogeneous());
00057 
00058   T2MatrixType t2 = T2MatrixType::Random();
00059   VERIFY\_IS\_APPROX(t2 * (v0.homogeneous().eval()), t2 * v0.homogeneous());
00060   VERIFY\_IS\_APPROX(t2 * (m0.colwise().homogeneous().eval()), t2 * m0.colwise().homogeneous());
00061   VERIFY\_IS\_APPROX(t2 * (v0.homogeneous().asDiagonal()), t2 * hv0.asDiagonal());
00062   VERIFY\_IS\_APPROX((v0.homogeneous().asDiagonal()) * t2, hv0.asDiagonal() * t2);
00063 
00064   VERIFY\_IS\_APPROX((v0.transpose().rowwise().homogeneous().eval()) * t2,
00065                     v0.transpose().rowwise().homogeneous() * t2);
00066   VERIFY\_IS\_APPROX((m0.transpose().rowwise().homogeneous().eval()) * t2,
00067                     m0.transpose().rowwise().homogeneous() * t2);
00068 
00069   T3MatrixType t3 = T3MatrixType::Random();
00070   VERIFY\_IS\_APPROX((v0.transpose().rowwise().homogeneous().eval()) * t3,
00071                     v0.transpose().rowwise().homogeneous() * t3);
00072   VERIFY\_IS\_APPROX((m0.transpose().rowwise().homogeneous().eval()) * t3,
00073                     m0.transpose().rowwise().homogeneous() * t3);
00074 
00075   \textcolor{comment}{// test product with a Transform object}
00076   \hyperlink{group___geometry___module_class_eigen_1_1_transform}{Transform<Scalar, Size, Affine>} aff;
00077   \hyperlink{group___geometry___module_class_eigen_1_1_transform}{Transform<Scalar, Size, AffineCompact>} caff;
00078   \hyperlink{group___geometry___module_class_eigen_1_1_transform}{Transform<Scalar, Size, Projective>} proj;
00079   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Size, Dynamic>}   pts;
00080   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Size+1, Dynamic>} pts1, pts2;
00081 
00082   aff.affine().\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00083   proj = caff = aff;
00084   pts.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(Size,internal::random<int>(1,20));
00085   
00086   pts1 = pts.colwise().homogeneous();
00087   VERIFY\_IS\_APPROX(aff  * pts.colwise().homogeneous(), (aff  * pts1).colwise().hnormalized());
00088   VERIFY\_IS\_APPROX(caff * pts.colwise().homogeneous(), (caff * pts1).colwise().hnormalized());
00089   VERIFY\_IS\_APPROX(proj * pts.colwise().homogeneous(), (proj * pts1));
00090 
00091   VERIFY\_IS\_APPROX((aff  * pts1).colwise().hnormalized(),  aff  * pts);
00092   VERIFY\_IS\_APPROX((caff * pts1).colwise().hnormalized(), caff * pts);
00093   
00094   pts2 = pts1;
00095   pts2.row(Size).\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00096   VERIFY\_IS\_APPROX((aff  * pts2).colwise().hnormalized(), aff  * pts2.colwise().hnormalized());
00097   VERIFY\_IS\_APPROX((caff * pts2).colwise().hnormalized(), caff * pts2.colwise().hnormalized());
00098   VERIFY\_IS\_APPROX((proj * pts2).colwise().hnormalized(), (proj * pts2.colwise().hnormalized().colwise().
      homogeneous()).colwise().hnormalized());
00099   
00100   \textcolor{comment}{// Test combination of homogeneous}
00101   
00102   VERIFY\_IS\_APPROX( (t2 * v0.homogeneous()).hnormalized(),
00103                        (t2.template topLeftCorner<Size,Size>() * v0 + t2.template topRightCorner<Size,1>())
00104                      / ((t2.template bottomLeftCorner<1,Size>()*v0).value() + t2(Size,Size)) );
00105   
00106   VERIFY\_IS\_APPROX( (t2 * pts.colwise().homogeneous()).colwise().hnormalized(),
00107                     (\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Size+1, Dynamic>}(t2 * pts1).colwise().
      hnormalized()) );
00108   
00109   VERIFY\_IS\_APPROX( (t2 .lazyProduct( v0.homogeneous() )).hnormalized(), (t2 * v0.homogeneous()).
      hnormalized() );
00110   VERIFY\_IS\_APPROX( (t2 .lazyProduct  ( pts.colwise().homogeneous() )).colwise().hnormalized(), (t2 * pts1)
      .colwise().hnormalized() );
00111   
00112   VERIFY\_IS\_APPROX( (v0.transpose().homogeneous() .lazyProduct( t2 )).hnormalized(), (v0.transpose().
      homogeneous()*t2).hnormalized() );
00113   VERIFY\_IS\_APPROX( (pts.transpose().rowwise().homogeneous() .lazyProduct( t2 )).rowwise().hnormalized(), (
      pts1.transpose()*t2).rowwise().hnormalized() );
00114 
00115   VERIFY\_IS\_APPROX( (t2.template triangularView<Lower>() * v0.homogeneous()).eval(), (t2.template 
      triangularView<Lower>()*hv0) );
00116 \}
00117 
00118 \textcolor{keywordtype}{void} test\_geo\_homogeneous()
00119 \{
00120   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00121     CALL\_SUBTEST\_1(( homogeneous<float,1>() ));
00122     CALL\_SUBTEST\_2(( homogeneous<double,3>() ));
00123     CALL\_SUBTEST\_3(( homogeneous<double,8>() ));
00124   \}
00125 \}
\end{DoxyCode}
