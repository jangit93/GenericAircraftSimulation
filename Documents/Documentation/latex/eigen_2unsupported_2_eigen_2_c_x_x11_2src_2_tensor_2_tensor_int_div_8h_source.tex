\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_int_div_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Int\+Div.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_int_div_8h_source}\index{Tensor\+Int\+Div.\+h@{Tensor\+Int\+Div.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_INTDIV\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_INTDIV\_H}
00012 
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 
00029 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00030 
00031 \textcolor{keyword}{namespace }\{
00032 
00033   \textcolor{comment}{// Note: result is undefined if val == 0}
00034   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00035   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE
00036   \textcolor{keyword}{typename} internal::enable\_if<sizeof(T)==4,int>::type count\_leading\_zeros(\textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} val)
00037   \{
00038 \textcolor{preprocessor}{#ifdef \_\_CUDA\_ARCH\_\_}
00039     \textcolor{keywordflow}{return} \_\_clz(val);
00040 \textcolor{preprocessor}{#elif EIGEN\_COMP\_MSVC}
00041     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} index;
00042     \_BitScanReverse(&index, val);
00043     \textcolor{keywordflow}{return} 31 - index;
00044 \textcolor{preprocessor}{#else}
00045     EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) == 8, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00046     \textcolor{keywordflow}{return} \_\_builtin\_clz(static\_cast<uint32\_t>(val));
00047 \textcolor{preprocessor}{#endif}
00048   \}
00049 
00050   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00051   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE
00052   \textcolor{keyword}{typename} internal::enable\_if<sizeof(T)==8,int>::type count\_leading\_zeros(\textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} val)
00053   \{
00054 \textcolor{preprocessor}{#ifdef \_\_CUDA\_ARCH\_\_}
00055     \textcolor{keywordflow}{return} \_\_clzll(val);
00056 \textcolor{preprocessor}{#elif EIGEN\_COMP\_MSVC && EIGEN\_ARCH\_x86\_64}
00057     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} index;
00058     \_BitScanReverse64(&index, val);
00059     \textcolor{keywordflow}{return} 63 - index;
00060 \textcolor{preprocessor}{#elif EIGEN\_COMP\_MSVC}
00061     \textcolor{comment}{// MSVC's \_BitScanReverse64 is not available for 32bits builds.}
00062     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} lo = (\textcolor{keywordtype}{unsigned} int)(val&0xffffffff);
00063     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} hi = (\textcolor{keywordtype}{unsigned} int)((val>>32)&0xffffffff);
00064     \textcolor{keywordtype}{int} n;
00065     \textcolor{keywordflow}{if}(hi==0)
00066       n = 32 + count\_leading\_zeros<unsigned int>(lo);
00067     \textcolor{keywordflow}{else}
00068       n = count\_leading\_zeros<unsigned int>(hi);
00069     \textcolor{keywordflow}{return} n;
00070 \textcolor{preprocessor}{#else}
00071     EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) == 8, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00072     \textcolor{keywordflow}{return} \_\_builtin\_clzll(static\_cast<uint64\_t>(val));
00073 \textcolor{preprocessor}{#endif}
00074   \}
00075 
00076   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00077   \textcolor{keyword}{struct }UnsignedTraits \{
00078     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<sizeof(T) == 8, uint64\_t, uint32\_t>::type type;
00079   \};
00080 
00081   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00082   \textcolor{keyword}{struct }DividerTraits \{
00083     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} UnsignedTraits<T>::type type;
00084     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} N = \textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}) * 8;
00085   \};
00086 
00087   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00088   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE uint32\_t muluh(\textcolor{keyword}{const} uint32\_t a, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} b) \{
00089 \textcolor{preprocessor}{#if defined(\_\_CUDA\_ARCH\_\_)}
00090     \textcolor{keywordflow}{return} \_\_umulhi(a, b);
00091 \textcolor{preprocessor}{#else}
00092     \textcolor{keywordflow}{return} (static\_cast<uint64\_t>(a) * b) >> 32;
00093 \textcolor{preprocessor}{#endif}
00094   \}
00095 
00096   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00097   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE uint64\_t muluh(\textcolor{keyword}{const} uint64\_t a, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} b) \{
00098 \textcolor{preprocessor}{#if defined(\_\_CUDA\_ARCH\_\_)}
00099     \textcolor{keywordflow}{return} \_\_umul64hi(a, b);
00100 \textcolor{preprocessor}{#elif defined(\_\_SIZEOF\_INT128\_\_)}
00101     \_\_uint128\_t v = \textcolor{keyword}{static\_cast<}\_\_uint128\_t\textcolor{keyword}{>}(a) * static\_cast<\_\_uint128\_t>(b);
00102     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(v >> 64);
00103 \textcolor{preprocessor}{#else}
00104     \textcolor{keywordflow}{return} (TensorUInt128<static\_val<0>, uint64\_t>(a) * TensorUInt128<static\_val<0>, uint64\_t>(b)).upper();
00105 \textcolor{preprocessor}{#endif}
00106   \}
00107 
00108   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{typename} T>
00109   \textcolor{keyword}{struct }DividerHelper \{
00110     \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE uint32\_t computeMultiplier(\textcolor{keyword}{const} \textcolor{keywordtype}{int} log\_div, \textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} divider) \{
00111       EIGEN\_STATIC\_ASSERT(N == 32, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00112       \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}((\textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(1) << (N+log\_div)) / divider - (
      static\_cast<uint64\_t>(1) << N) + 1);
00113     \}
00114   \};
00115 
00116   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00117   \textcolor{keyword}{struct }DividerHelper<64, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}> \{
00118     \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE uint64\_t computeMultiplier(\textcolor{keyword}{const} \textcolor{keywordtype}{int} log\_div, \textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} divider) \{
00119 \textcolor{preprocessor}{#if defined(\_\_SIZEOF\_INT128\_\_) && !defined(\_\_CUDA\_ARCH\_\_)}
00120       \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}((\textcolor{keyword}{static\_cast<}\_\_uint128\_t\textcolor{keyword}{>}(1) << (64+log\_div)) / static\_cast<\_\_uint128\_t>
      (divider) - (\textcolor{keyword}{static\_cast<}\_\_uint128\_t\textcolor{keyword}{>}(1) << 64) + 1);
00121 \textcolor{preprocessor}{#else}
00122       \textcolor{keyword}{const} uint64\_t shift = 1ULL << log\_div;
00123       TensorUInt128<uint64\_t, uint64\_t> result = TensorUInt128<uint64\_t, static\_val<0> >(shift, 0) / 
      TensorUInt128<static\_val<0>, uint64\_t>(divider)
00124                                                - TensorUInt128<static\_val<1>, static\_val<0> >(1, 0)
00125                                                + TensorUInt128<static\_val<0>, static\_val<1> >(1);
00126       \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(result);
00127 \textcolor{preprocessor}{#endif}
00128     \}
00129   \};
00130 \}
00131 
00132 
00133 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} div\_gt\_one = false>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_int_div_8h_source_l00134}\hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{00134} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{TensorIntDivisor} \{
00135  \textcolor{keyword}{public}:
00136   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{TensorIntDivisor}() \{
00137     multiplier = 0;
00138     shift1 = 0;
00139     shift2 = 0;
00140   \}
00141 
00142   \textcolor{comment}{// Must have 0 < divider < 2^31. This is relaxed to}
00143   \textcolor{comment}{// 0 < divider < 2^63 when using 64-bit indices on platforms that support}
00144   \textcolor{comment}{// the \_\_uint128\_t type.}
00145   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{TensorIntDivisor}(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T} divider) \{
00146     \textcolor{keyword}{const} \textcolor{keywordtype}{int} N = DividerTraits<T>::N;
00147     eigen\_assert(\textcolor{keyword}{static\_cast<}typename \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{UnsignedTraits<T>::type}\textcolor{keyword}{>}(divider) < 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<UnsignedType>::highest}()/2);
00148     eigen\_assert(divider > 0);
00149 
00150     \textcolor{comment}{// fast ln2}
00151     \textcolor{keyword}{const} \textcolor{keywordtype}{int} leading\_zeros = count\_leading\_zeros(static\_cast<UnsignedType>(divider));
00152     \textcolor{keywordtype}{int} log\_div = N - leading\_zeros;
00153     \textcolor{comment}{// if divider is a power of two then log\_div is 1 more than it should be.}
00154     \textcolor{keywordflow}{if} ((\textcolor{keyword}{static\_cast<}typename \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{UnsignedTraits<T>::type}\textcolor{keyword}{>}(1) << (log\_div-1)) == \textcolor{keyword}{
      static\_cast<}typename \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{UnsignedTraits<T>::type}\textcolor{keyword}{>}(divider))
00155       log\_div--;
00156 
00157     multiplier = DividerHelper<N, T>::computeMultiplier(log\_div, divider);
00158     shift1 = log\_div > 1 ? 1 : log\_div;
00159     shift2 = log\_div > 1 ? log\_div-1 : 0;
00160   \}
00161 
00162   \textcolor{comment}{// Must have 0 <= numerator. On platforms that dont support the \_\_uint128\_t}
00163   \textcolor{comment}{// type numerator should also be less than 2^32-1.}
00164   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{group___sparse_core___module}{T} divide(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T} numerator)\textcolor{keyword}{ const }\{
00165     eigen\_assert(\textcolor{keyword}{static\_cast<}typename \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{UnsignedTraits<T>::type}\textcolor{keyword}{>}(numerator) < 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<UnsignedType>::highest}()/2);
00166     \textcolor{comment}{//eigen\_assert(numerator >= 0); // this is implicitly asserted by the line above}
00167 
00168     \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{UnsignedType} t1 = muluh(multiplier, numerator);
00169     \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{UnsignedType} t = (\textcolor{keyword}{static\_cast<}\hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{UnsignedType}\textcolor{keyword}{>}(numerator) - t1) >> shift1;
00170     \textcolor{keywordflow}{return} (t1 + t) >> shift2;
00171   \}
00172 
00173  \textcolor{keyword}{private}:
00174   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{DividerTraits<T>::type} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{UnsignedType};
00175   UnsignedType multiplier;
00176   int32\_t shift1;
00177   int32\_t shift2;
00178 \};
00179 
00180 
00181 \textcolor{comment}{// Optimized version for signed 32 bit integers.}
00182 \textcolor{comment}{// Derived from Hacker's Delight.}
00183 \textcolor{comment}{// Only works for divisors strictly greater than one}
00184 \textcolor{keyword}{template} <>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_int_div_8h_source_l00185}\hyperlink{class_eigen_1_1internal_1_1_tensor_int_divisor_3_01int32__t_00_01true_01_4}{00185} \textcolor{keyword}{class }\hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{TensorIntDivisor}<int32\_t, true> \{
00186  \textcolor{keyword}{public}:
00187   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{TensorIntDivisor}() \{
00188     magic = 0;
00189     shift = 0;
00190   \}
00191   \textcolor{comment}{// Must have 2 <= divider}
00192   EIGEN\_DEVICE\_FUNC \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{TensorIntDivisor}(int32\_t divider)  \{
00193     eigen\_assert(divider >= 2);
00194     calcMagic(divider);
00195   \}
00196 
00197   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \textcolor{keywordtype}{int} divide(\textcolor{keyword}{const} int32\_t n)\textcolor{keyword}{ const }\{
00198 \textcolor{preprocessor}{#ifdef \_\_CUDA\_ARCH\_\_}
00199     \textcolor{keywordflow}{return} (\_\_umulhi(magic, n) >> shift);
00200 \textcolor{preprocessor}{#else}
00201     uint64\_t v = \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(magic) * static\_cast<uint64\_t>(n);
00202     \textcolor{keywordflow}{return} (static\_cast<uint32\_t>(v >> 32) >> shift);
00203 \textcolor{preprocessor}{#endif}
00204   \}
00205 
00206 \textcolor{keyword}{private}:
00207   \textcolor{comment}{// Compute the magic numbers. See Hacker's Delight section 10 for an in}
00208   \textcolor{comment}{// depth explanation.}
00209   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} calcMagic(int32\_t d) \{
00210    \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} two31 = 0x80000000;     \textcolor{comment}{// 2**31.}
00211    \textcolor{keywordtype}{unsigned} ad = d;
00212    \textcolor{keywordtype}{unsigned} t = two31 + (ad >> 31);
00213    \textcolor{keywordtype}{unsigned} anc = t - 1 - t%ad;     \textcolor{comment}{// Absolute value of nc.}
00214    \textcolor{keywordtype}{int} p = 31;                      \textcolor{comment}{// Init. p.}
00215    \textcolor{keywordtype}{unsigned} q1 = two31/anc;         \textcolor{comment}{// Init. q1 = 2**p/|nc|.}
00216    \textcolor{keywordtype}{unsigned} r1 = two31 - q1*anc;    \textcolor{comment}{// Init. r1 = rem(2**p, |nc|).}
00217    \textcolor{keywordtype}{unsigned} q2 = two31/ad;          \textcolor{comment}{// Init. q2 = 2**p/|d|.}
00218    \textcolor{keywordtype}{unsigned} r2 = two31 - q2*ad;     \textcolor{comment}{// Init. r2 = rem(2**p, |d|).}
00219    \textcolor{keywordtype}{unsigned} delta = 0;
00220    \textcolor{keywordflow}{do} \{
00221       p = p + 1;
00222       q1 = 2*q1;           \textcolor{comment}{// Update q1 = 2**p/|nc|.}
00223       r1 = 2*r1;           \textcolor{comment}{// Update r1 = rem(2**p, |nc|).}
00224       \textcolor{keywordflow}{if} (r1 >= anc) \{     \textcolor{comment}{// (Must be an unsigned}
00225          q1 = q1 + 1;      \textcolor{comment}{// comparison here).}
00226          r1 = r1 - anc;\}
00227       q2 = 2*q2;           \textcolor{comment}{// Update q2 = 2**p/|d|.}
00228       r2 = 2*r2;           \textcolor{comment}{// Update r2 = rem(2**p, |d|).}
00229       \textcolor{keywordflow}{if} (r2 >= ad) \{      \textcolor{comment}{// (Must be an unsigned}
00230          q2 = q2 + 1;      \textcolor{comment}{// comparison here).}
00231          r2 = r2 - ad;\}
00232       delta = ad - r2;
00233    \} \textcolor{keywordflow}{while} (q1 < delta || (q1 == delta && r1 == 0));
00234 
00235    magic = (unsigned)(q2 + 1);
00236    shift = p - 32;
00237   \}
00238 
00239   uint32\_t magic;
00240   int32\_t shift;
00241 \};
00242 
00243 
00244 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} div\_gt\_one>
00245 \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{group___sparse_core___module}{T} operator / (\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& numerator, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{TensorIntDivisor<T, div\_gt\_one>}& divisor) \{
00246   \textcolor{keywordflow}{return} divisor.divide(numerator);
00247 \}
00248 
00249 
00250 \} \textcolor{comment}{// end namespace internal}
00251 \} \textcolor{comment}{// end namespace Eigen}
00252 
00253 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_INTDIV\_H}
\end{DoxyCode}
