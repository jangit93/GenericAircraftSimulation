\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_euler_angles_2_euler_system_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+Euler\+Angles/\+Euler\+System.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_euler_angles_2_euler_system_8h_source}\index{Euler\+System.\+h@{Euler\+System.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Tal Hadad <tal\_hd@hotmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_EULERSYSTEM\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_EULERSYSTEM\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen}
00014 \{
00015   \textcolor{comment}{// Forward declerations}
00016   \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_Scalar, \textcolor{keyword}{class} \_System>
00017   \textcolor{keyword}{class }\hyperlink{class_euler_angles}{EulerAngles};
00018   
00019   \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal}
00020   \{
00021     \textcolor{comment}{// TODO: Check if already exists on the rest API}
00022     \textcolor{keyword}{template} <\textcolor{keywordtype}{int} Num, \textcolor{keywordtype}{bool} IsPositive = (Num > 0)>
00023     \textcolor{keyword}{struct} Abs
00024     \{
00025       \textcolor{keyword}{enum} \{ value = Num \};
00026     \};
00027   
00028     \textcolor{keyword}{template} <\textcolor{keywordtype}{int} Num>
00029     \textcolor{keyword}{struct }Abs<Num, false>
00030     \{
00031       \textcolor{keyword}{enum} \{ value = -Num \};
00032     \};
00033 
00034     \textcolor{keyword}{template} <\textcolor{keywordtype}{int} Axis>
00035     \textcolor{keyword}{struct }IsValidAxis
00036     \{
00037       \textcolor{keyword}{enum} \{ value = Axis != 0 && Abs<Axis>::value <= 3 \};
00038     \};
00039   \}
00040   
00041 \textcolor{preprocessor}{  #define EIGEN\_EULER\_ANGLES\_CLASS\_STATIC\_ASSERT(COND,MSG) typedef char static\_assertion\_##MSG[(COND)?1:-1]}
00042   
\Hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_euler_angles_2_euler_system_8h_source_l00055}\hyperlink{namespace_eigen_ae614aa7cdd687fb5c421a54f2ce5c361}{00055}   \textcolor{keyword}{enum} \hyperlink{namespace_eigen_ae614aa7cdd687fb5c421a54f2ce5c361}{EulerAxis}
00056   \{
00057     \hyperlink{namespace_eigen_ae614aa7cdd687fb5c421a54f2ce5c361ae8110af93d433bfcf247d6bac5e1d387}{EULER\_X} = 1, 
00058     \hyperlink{namespace_eigen_ae614aa7cdd687fb5c421a54f2ce5c361a7309edb53a9d9cdb77fac7c1e9200263}{EULER\_Y} = 2, 
00059     \hyperlink{namespace_eigen_ae614aa7cdd687fb5c421a54f2ce5c361a0c641fd5050b5219d6c172ac83fb379d}{EULER\_Z} = 3  
00060   \};
00061   
00119   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \_AlphaAxis, \textcolor{keywordtype}{int} \_BetaAxis, \textcolor{keywordtype}{int} \_GammaAxis>
00120   \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_euler_system}{EulerSystem}
00121   \{
00122     \textcolor{keyword}{public}:
00123     \textcolor{comment}{// It's defined this way and not as enum, because I think}
00124     \textcolor{comment}{//  that enum is not guerantee to support negative numbers}
00125     
00127     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} AlphaAxis = \_AlphaAxis;
00128     
00130     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} BetaAxis = \_BetaAxis;
00131     
00133     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} GammaAxis = \_GammaAxis;
00134 
00135     \textcolor{keyword}{enum}
00136     \{
00137       AlphaAxisAbs = \hyperlink{struct_eigen_1_1internal_1_1_abs}{internal::Abs<AlphaAxis>::value}, 
00138       BetaAxisAbs = \hyperlink{struct_eigen_1_1internal_1_1_abs}{internal::Abs<BetaAxis>::value}, 
00139       GammaAxisAbs = \hyperlink{struct_eigen_1_1internal_1_1_abs}{internal::Abs<GammaAxis>::value}, 
00141       IsAlphaOpposite = (AlphaAxis < 0) ? 1 : 0, 
00142       IsBetaOpposite = (BetaAxis < 0) ? 1 : 0, 
00143       IsGammaOpposite = (GammaAxis < 0) ? 1 : 0, 
00145       IsOdd = ((AlphaAxisAbs)%3 == (BetaAxisAbs - 1)%3) ? 0 : 1, 
00146       IsEven = IsOdd ? 0 : 1, 
00148       IsTaitBryan = ((unsigned)AlphaAxisAbs != (\textcolor{keywordtype}{unsigned})GammaAxisAbs) ? 1 : 0 
00149     \};
00150     
00151     \textcolor{keyword}{private}:
00152     
00153     EIGEN\_EULER\_ANGLES\_CLASS\_STATIC\_ASSERT(
      \hyperlink{struct_eigen_1_1internal_1_1_is_valid_axis}{internal::IsValidAxis<AlphaAxis>::value},
00154       ALPHA\_AXIS\_IS\_INVALID);
00155       
00156     EIGEN\_EULER\_ANGLES\_CLASS\_STATIC\_ASSERT(
      \hyperlink{struct_eigen_1_1internal_1_1_is_valid_axis}{internal::IsValidAxis<BetaAxis>::value},
00157       BETA\_AXIS\_IS\_INVALID);
00158       
00159     EIGEN\_EULER\_ANGLES\_CLASS\_STATIC\_ASSERT(
      \hyperlink{struct_eigen_1_1internal_1_1_is_valid_axis}{internal::IsValidAxis<GammaAxis>::value},
00160       GAMMA\_AXIS\_IS\_INVALID);
00161       
00162     EIGEN\_EULER\_ANGLES\_CLASS\_STATIC\_ASSERT((\textcolor{keywordtype}{unsigned})AlphaAxisAbs != (\textcolor{keywordtype}{unsigned})BetaAxisAbs,
00163       ALPHA\_AXIS\_CANT\_BE\_EQUAL\_TO\_BETA\_AXIS);
00164       
00165     EIGEN\_EULER\_ANGLES\_CLASS\_STATIC\_ASSERT((\textcolor{keywordtype}{unsigned})BetaAxisAbs != (\textcolor{keywordtype}{unsigned})GammaAxisAbs,
00166       BETA\_AXIS\_CANT\_BE\_EQUAL\_TO\_GAMMA\_AXIS);
00167 
00168     \textcolor{keyword}{enum}
00169     \{
00170       \textcolor{comment}{// I, J, K are the pivot indexes permutation for the rotation matrix, that match this Euler system. }
00171       \textcolor{comment}{// They are used in this class converters.}
00172       \textcolor{comment}{// They are always different from each other, and their possible values are: 0, 1, or 2.}
00173       I = AlphaAxisAbs - 1,
00174       J = (AlphaAxisAbs - 1 + 1 + IsOdd)%3,
00175       K = (AlphaAxisAbs - 1 + 2 - IsOdd)%3
00176     \};
00177     
00178     \textcolor{comment}{// TODO: Get @mat parameter in form that avoids double evaluation.}
00179     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>
00180     \textcolor{keyword}{static} \textcolor{keywordtype}{void} CalcEulerAngles\_imp(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<\textcolor{keyword}{typename} MatrixBase<Derived>::Scalar, 3, 1>& res, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& mat, \hyperlink{struct_eigen_1_1internal_1_1true__type}{internal::true\_type} \textcolor{comment}{/*isTaitBryan*/})
00181     \{
00182       \textcolor{keyword}{using} std::atan2;
00183       \textcolor{keyword}{using} std::sin;
00184       \textcolor{keyword}{using} std::cos;
00185       
00186       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00187       \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,2,1>} Vector2;
00188       
00189       res[0] = atan2(mat(J,K), mat(K,K));
00190       Scalar c2 = Vector2(mat(I,I), mat(I,J)).norm();
00191       \textcolor{keywordflow}{if}((IsOdd && res[0]<Scalar(0)) || ((!IsOdd) && res[0]>Scalar(0))) \{
00192         \textcolor{keywordflow}{if}(res[0] > Scalar(0)) \{
00193           res[0] -= Scalar(EIGEN\_PI);
00194         \}
00195         \textcolor{keywordflow}{else} \{
00196           res[0] += Scalar(EIGEN\_PI);
00197         \}
00198         res[1] = atan2(-mat(I,K), -c2);
00199       \}
00200       \textcolor{keywordflow}{else}
00201         res[1] = atan2(-mat(I,K), c2);
00202       Scalar s1 = sin(res[0]);
00203       Scalar c1 = cos(res[0]);
00204       res[2] = atan2(s1*mat(K,I)-c1*mat(J,I), c1*mat(J,J) - s1 * mat(K,J));
00205     \}
00206 
00207     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>
00208     \textcolor{keyword}{static} \textcolor{keywordtype}{void} CalcEulerAngles\_imp(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<\textcolor{keyword}{typename} MatrixBase<Derived>::Scalar,3,1>& res, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& mat, \hyperlink{struct_eigen_1_1internal_1_1false__type}{internal::false\_type} \textcolor{comment}{/*isTaitBryan*/})
00209     \{
00210       \textcolor{keyword}{using} std::atan2;
00211       \textcolor{keyword}{using} std::sin;
00212       \textcolor{keyword}{using} std::cos;
00213 
00214       \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00215       \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,2,1>} Vector2;
00216       
00217       res[0] = atan2(mat(J,I), mat(K,I));
00218       \textcolor{keywordflow}{if}((IsOdd && res[0]<Scalar(0)) || ((!IsOdd) && res[0]>Scalar(0)))
00219       \{
00220         \textcolor{keywordflow}{if}(res[0] > Scalar(0)) \{
00221           res[0] -= Scalar(EIGEN\_PI);
00222         \}
00223         \textcolor{keywordflow}{else} \{
00224           res[0] += Scalar(EIGEN\_PI);
00225         \}
00226         Scalar s2 = Vector2(mat(J,I), mat(K,I)).norm();
00227         res[1] = -atan2(s2, mat(I,I));
00228       \}
00229       \textcolor{keywordflow}{else}
00230       \{
00231         Scalar s2 = Vector2(mat(J,I), mat(K,I)).norm();
00232         res[1] = atan2(s2, mat(I,I));
00233       \}
00234 
00235       \textcolor{comment}{// With a=(0,1,0), we have i=0; j=1; k=2, and after computing the first two angles,}
00236       \textcolor{comment}{// we can compute their respective rotation, and apply its inverse to M. Since the result must}
00237       \textcolor{comment}{// be a rotation around x, we have:}
00238       \textcolor{comment}{//}
00239       \textcolor{comment}{//  c2  s1.s2 c1.s2                   1  0   0 }
00240       \textcolor{comment}{//  0   c1    -s1       *    M    =   0  c3  s3}
00241       \textcolor{comment}{//  -s2 s1.c2 c1.c2                   0 -s3  c3}
00242       \textcolor{comment}{//}
00243       \textcolor{comment}{//  Thus:  m11.c1 - m21.s1 = c3  &   m12.c1 - m22.s1 = s3}
00244 
00245       Scalar s1 = sin(res[0]);
00246       Scalar c1 = cos(res[0]);
00247       res[2] = atan2(c1*mat(J,K)-s1*mat(K,K), c1*mat(J,J) - s1 * mat(K,J));
00248     \}
00249     
00250     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00251     \textcolor{keyword}{static} \textcolor{keywordtype}{void} CalcEulerAngles(
00252       \hyperlink{class_eigen_1_1_euler_angles}{EulerAngles<Scalar, EulerSystem>}& res,
00253       \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___core___module_class_eigen_1_1_matrix}{EulerAngles<Scalar, EulerSystem>::Matrix3}& 
      mat)
00254     \{
00255       CalcEulerAngles(res, mat, \textcolor{keyword}{false}, \textcolor{keyword}{false}, \textcolor{keyword}{false});
00256     \}
00257     
00258     \textcolor{keyword}{template}<
00259       \textcolor{keywordtype}{bool} PositiveRangeAlpha,
00260       \textcolor{keywordtype}{bool} PositiveRangeBeta,
00261       \textcolor{keywordtype}{bool} PositiveRangeGamma,
00262       \textcolor{keyword}{typename} Scalar>
00263     \textcolor{keyword}{static} \textcolor{keywordtype}{void} CalcEulerAngles(
00264       \hyperlink{class_eigen_1_1_euler_angles}{EulerAngles<Scalar, EulerSystem>}& res,
00265       \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___core___module_class_eigen_1_1_matrix}{EulerAngles<Scalar, EulerSystem>::Matrix3}& 
      mat)
00266     \{
00267       CalcEulerAngles(res, mat, PositiveRangeAlpha, PositiveRangeBeta, PositiveRangeGamma);
00268     \}
00269     
00270     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00271     \textcolor{keyword}{static} \textcolor{keywordtype}{void} CalcEulerAngles(
00272       \hyperlink{class_eigen_1_1_euler_angles}{EulerAngles<Scalar, EulerSystem>}& res,
00273       \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___core___module_class_eigen_1_1_matrix}{EulerAngles<Scalar, EulerSystem>::Matrix3}& 
      mat,
00274       \textcolor{keywordtype}{bool} PositiveRangeAlpha,
00275       \textcolor{keywordtype}{bool} PositiveRangeBeta,
00276       \textcolor{keywordtype}{bool} PositiveRangeGamma)
00277     \{
00278       CalcEulerAngles\_imp(
00279         res.\hyperlink{class_eigen_1_1_euler_angles_a2decf84b5efd265f7251fd32f539a36b}{angles}(), mat,
00280         \textcolor{keyword}{typename} 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::conditional<IsTaitBryan, internal::true\_type, internal::false\_type>::type}
      ());
00281 
00282       \textcolor{keywordflow}{if} (IsAlphaOpposite == IsOdd)
00283         res.\hyperlink{class_eigen_1_1_euler_angles_a6146f78ee0fb9d9a7d685a4654066825}{alpha}() = -res.\hyperlink{class_eigen_1_1_euler_angles_a6146f78ee0fb9d9a7d685a4654066825}{alpha}();
00284         
00285       \textcolor{keywordflow}{if} (IsBetaOpposite == IsOdd)
00286         res.\hyperlink{class_eigen_1_1_euler_angles_a1bf59f8acaed985964c98c1f59d8f5ab}{beta}() = -res.\hyperlink{class_eigen_1_1_euler_angles_a1bf59f8acaed985964c98c1f59d8f5ab}{beta}();
00287         
00288       \textcolor{keywordflow}{if} (IsGammaOpposite == IsOdd)
00289         res.\hyperlink{class_eigen_1_1_euler_angles_aa75a5f16105d96eedf81bf9f8e789e21}{gamma}() = -res.\hyperlink{class_eigen_1_1_euler_angles_aa75a5f16105d96eedf81bf9f8e789e21}{gamma}();
00290       
00291       \textcolor{comment}{// Saturate results to the requested range}
00292       \textcolor{keywordflow}{if} (PositiveRangeAlpha && (res.\hyperlink{class_eigen_1_1_euler_angles_a6146f78ee0fb9d9a7d685a4654066825}{alpha}() < 0))
00293         res.\hyperlink{class_eigen_1_1_euler_angles_a6146f78ee0fb9d9a7d685a4654066825}{alpha}() += Scalar(2 * EIGEN\_PI);
00294       
00295       \textcolor{keywordflow}{if} (PositiveRangeBeta && (res.\hyperlink{class_eigen_1_1_euler_angles_a1bf59f8acaed985964c98c1f59d8f5ab}{beta}() < 0))
00296         res.\hyperlink{class_eigen_1_1_euler_angles_a1bf59f8acaed985964c98c1f59d8f5ab}{beta}() += Scalar(2 * EIGEN\_PI);
00297       
00298       \textcolor{keywordflow}{if} (PositiveRangeGamma && (res.\hyperlink{class_eigen_1_1_euler_angles_aa75a5f16105d96eedf81bf9f8e789e21}{gamma}() < 0))
00299         res.\hyperlink{class_eigen_1_1_euler_angles_aa75a5f16105d96eedf81bf9f8e789e21}{gamma}() += Scalar(2 * EIGEN\_PI);
00300     \}
00301     
00302     \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_Scalar, \textcolor{keyword}{class} \_System>
00303     \textcolor{keyword}{friend} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_euler_angles}{Eigen::EulerAngles};
00304   \};
00305 
00306 \textcolor{preprocessor}{#define EIGEN\_EULER\_SYSTEM\_TYPEDEF(A, B, C) \(\backslash\)}
00307 \textcolor{preprocessor}{ \(\backslash\)}
00308 \textcolor{preprocessor}{  typedef EulerSystem<EULER\_##A, EULER\_##B, EULER\_##C> EulerSystem##A##B##C;}
00309   
00310   EIGEN\_EULER\_SYSTEM\_TYPEDEF(X,Y,Z)
00311   EIGEN\_EULER\_SYSTEM\_TYPEDEF(X,Y,X)
00312   EIGEN\_EULER\_SYSTEM\_TYPEDEF(X,Z,Y)
00313   EIGEN\_EULER\_SYSTEM\_TYPEDEF(X,Z,X)
00314   
00315   EIGEN\_EULER\_SYSTEM\_TYPEDEF(Y,Z,X)
00316   EIGEN\_EULER\_SYSTEM\_TYPEDEF(Y,Z,Y)
00317   EIGEN\_EULER\_SYSTEM\_TYPEDEF(Y,X,Z)
00318   EIGEN\_EULER\_SYSTEM\_TYPEDEF(Y,X,Y)
00319   
00320   EIGEN\_EULER\_SYSTEM\_TYPEDEF(Z,X,Y)
00321   EIGEN\_EULER\_SYSTEM\_TYPEDEF(Z,X,Z)
00322   EIGEN\_EULER\_SYSTEM\_TYPEDEF(Z,Y,X)
00323   EIGEN\_EULER\_SYSTEM\_TYPEDEF(Z,Y,Z)
00324 \}
00325 
00326 \textcolor{preprocessor}{#endif // EIGEN\_EULERSYSTEM\_H}
\end{DoxyCode}
