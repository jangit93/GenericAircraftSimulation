\hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_col_etree_8h_source}{}\section{eigen/\+Eigen/src/\+Sparse\+Core/\+Sparse\+Col\+Etree.h}
\label{eigen_2_eigen_2src_2_sparse_core_2_sparse_col_etree_8h_source}\index{Sparse\+Col\+Etree.\+h@{Sparse\+Col\+Etree.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 
00011 \textcolor{comment}{/* }
00012 \textcolor{comment}{ }
00013 \textcolor{comment}{ * NOTE: This file is the modified version of sp\_coletree.c file in SuperLU }
00014 \textcolor{comment}{ }
00015 \textcolor{comment}{ * -- SuperLU routine (version 3.1) --}
00016 \textcolor{comment}{ * Univ. of California Berkeley, Xerox Palo Alto Research Center,}
00017 \textcolor{comment}{ * and Lawrence Berkeley National Lab.}
00018 \textcolor{comment}{ * August 1, 2008}
00019 \textcolor{comment}{ *}
00020 \textcolor{comment}{ * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.}
00021 \textcolor{comment}{ *}
00022 \textcolor{comment}{ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY}
00023 \textcolor{comment}{ * EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.}
00024 \textcolor{comment}{ *}
00025 \textcolor{comment}{ * Permission is hereby granted to use or copy this program for any}
00026 \textcolor{comment}{ * purpose, provided the above notices are retained on all copies.}
00027 \textcolor{comment}{ * Permission to modify the code and to distribute modified code is}
00028 \textcolor{comment}{ * granted, provided the above notices are retained, and a notice that}
00029 \textcolor{comment}{ * the code was modified is included with the above copyright notice.}
00030 \textcolor{comment}{ */}
00031 \textcolor{preprocessor}{#ifndef SPARSE\_COLETREE\_H}
00032 \textcolor{preprocessor}{#define SPARSE\_COLETREE\_H}
00033 
00034 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00035 
00036 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00037 
00039 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} IndexVector>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_col_etree_8h_source_l00040}\hyperlink{namespace_eigen_1_1internal_af1daa938f6414254cc9a754f1ef2490b}{00040} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{namespace_eigen_1_1internal_af1daa938f6414254cc9a754f1ef2490b}{etree\_find} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, IndexVector& pp)
00041 \{
00042   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p = pp(i); \textcolor{comment}{// Parent }
00043   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} gp = pp(p); \textcolor{comment}{// Grand parent }
00044   \textcolor{keywordflow}{while} (gp != p) 
00045   \{
00046     pp(i) = gp; \textcolor{comment}{// Parent pointer on find path is changed to former grand parent}
00047     i = gp; 
00048     p = pp(i);
00049     gp = pp(p);
00050   \}
00051   \textcolor{keywordflow}{return} p; 
00052 \}
00053 
00060 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} IndexVector>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_col_etree_8h_source_l00061}\hyperlink{namespace_eigen_1_1internal_a86181db74ba596a7afbfd89efcc5788c}{00061} \textcolor{keywordtype}{int} \hyperlink{namespace_eigen_1_1internal_a86181db74ba596a7afbfd89efcc5788c}{coletree}(\textcolor{keyword}{const} MatrixType& mat, IndexVector& parent, IndexVector& firstRowElt, \textcolor{keyword}{typename} 
      MatrixType::StorageIndex *perm=0)
00062 \{
00063   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00064   StorageIndex nc = convert\_index<StorageIndex>(mat.cols()); \textcolor{comment}{// Number of columns}
00065   StorageIndex m = convert\_index<StorageIndex>(mat.rows());
00066   StorageIndex diagSize = (std::min)(nc,m);
00067   IndexVector root(nc); \textcolor{comment}{// root of subtree of etree }
00068   root.setZero();
00069   IndexVector pp(nc); \textcolor{comment}{// disjoint sets }
00070   pp.setZero(); \textcolor{comment}{// Initialize disjoint sets }
00071   parent.resize(mat.cols());
00072   \textcolor{comment}{//Compute first nonzero column in each row }
00073   firstRowElt.resize(m);
00074   firstRowElt.setConstant(nc);
00075   firstRowElt.segment(0, diagSize).setLinSpaced(diagSize, 0, diagSize-1);
00076   \textcolor{keywordtype}{bool} found\_diag;
00077   \textcolor{keywordflow}{for} (StorageIndex col = 0; col < nc; col++)
00078   \{
00079     StorageIndex pcol = col;
00080     \textcolor{keywordflow}{if}(perm) pcol  = perm[col];
00081     \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} MatrixType::InnerIterator it(mat, pcol); it; ++it)
00082     \{ 
00083       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row = it.row();
00084       firstRowElt(row) = (std::min)(firstRowElt(row), col);
00085     \}
00086   \}
00087   \textcolor{comment}{/* Compute etree by Liu's algorithm for symmetric matrices,}
00088 \textcolor{comment}{          except use (firstRowElt[r],c) in place of an edge (r,c) of A.}
00089 \textcolor{comment}{    Thus each row clique in A'*A is replaced by a star}
00090 \textcolor{comment}{    centered at its first vertex, which has the same fill. */}
00091   StorageIndex rset, cset, rroot;
00092   \textcolor{keywordflow}{for} (StorageIndex col = 0; col < nc; col++) 
00093   \{
00094     found\_diag = col>=m;
00095     pp(col) = col; 
00096     cset = col; 
00097     root(cset) = col; 
00098     parent(col) = nc; 
00099     \textcolor{comment}{/* The diagonal element is treated here even if it does not exist in the matrix}
00100 \textcolor{comment}{     * hence the loop is executed once more */} 
00101     StorageIndex pcol = col;
00102     \textcolor{keywordflow}{if}(perm) pcol  = perm[col];
00103     \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} MatrixType::InnerIterator it(mat, pcol); it||!found\_diag; ++it)
00104     \{ \textcolor{comment}{//  A sequence of interleaved find and union is performed }
00105       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = col;
00106       \textcolor{keywordflow}{if}(it) i = it.index();
00107       \textcolor{keywordflow}{if} (i == col) found\_diag = \textcolor{keyword}{true};
00108       
00109       StorageIndex row = firstRowElt(i);
00110       \textcolor{keywordflow}{if} (row >= col) \textcolor{keywordflow}{continue}; 
00111       rset = \hyperlink{namespace_eigen_1_1internal_af1daa938f6414254cc9a754f1ef2490b}{internal::etree\_find}(row, pp); \textcolor{comment}{// Find the name of the set containing row}
00112       rroot = root(rset);
00113       \textcolor{keywordflow}{if} (rroot != col) 
00114       \{
00115         parent(rroot) = col; 
00116         pp(cset) = rset; 
00117         cset = rset; 
00118         root(cset) = col; 
00119       \}
00120     \}
00121   \}
00122   \textcolor{keywordflow}{return} 0;  
00123 \}
00124 
00129 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexVector>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_col_etree_8h_source_l00130}\hyperlink{namespace_eigen_1_1internal_acbd726e03f667e0dc788c6b4e92d61ec}{00130} \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_acbd726e03f667e0dc788c6b4e92d61ec}{nr\_etdfs} (\textcolor{keyword}{typename} IndexVector::Scalar n, IndexVector& parent, IndexVector& first\_kid, 
      IndexVector& next\_kid, IndexVector& post, \textcolor{keyword}{typename} IndexVector::Scalar postnum)
00131 \{
00132   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} IndexVector::Scalar StorageIndex;
00133   StorageIndex current = n, first, next;
00134   \textcolor{keywordflow}{while} (postnum != n) 
00135   \{
00136     \textcolor{comment}{// No kid for the current node}
00137     first = first\_kid(current);
00138     
00139     \textcolor{comment}{// no kid for the current node}
00140     \textcolor{keywordflow}{if} (first == -1) 
00141     \{
00142       \textcolor{comment}{// Numbering this node because it has no kid }
00143       post(current) = postnum++;
00144       
00145       \textcolor{comment}{// looking for the next kid }
00146       next = next\_kid(current); 
00147       \textcolor{keywordflow}{while} (next == -1) 
00148       \{
00149         \textcolor{comment}{// No more kids : back to the parent node}
00150         current = parent(current); 
00151         \textcolor{comment}{// numbering the parent node }
00152         post(current) = postnum++;
00153         
00154         \textcolor{comment}{// Get the next kid }
00155         next = next\_kid(current); 
00156       \}
00157       \textcolor{comment}{// stopping criterion }
00158       \textcolor{keywordflow}{if} (postnum == n+1) \textcolor{keywordflow}{return}; 
00159       
00160       \textcolor{comment}{// Updating current node }
00161       current = next; 
00162     \}
00163     \textcolor{keywordflow}{else} 
00164     \{
00165       current = first; 
00166     \}
00167   \}
00168 \}
00169 
00170 
00177 \textcolor{keyword}{template} <\textcolor{keyword}{typename} IndexVector>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_col_etree_8h_source_l00178}\hyperlink{namespace_eigen_1_1internal_ab414b5990bd6c865958a9231ff418d20}{00178} \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_ab414b5990bd6c865958a9231ff418d20}{treePostorder}(\textcolor{keyword}{typename} IndexVector::Scalar n, IndexVector& parent, IndexVector& post)
00179 \{
00180   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} IndexVector::Scalar StorageIndex;
00181   IndexVector first\_kid, next\_kid; \textcolor{comment}{// Linked list of children }
00182   StorageIndex postnum; 
00183   \textcolor{comment}{// Allocate storage for working arrays and results }
00184   first\_kid.resize(n+1); 
00185   next\_kid.setZero(n+1);
00186   post.setZero(n+1);
00187   
00188   \textcolor{comment}{// Set up structure describing children}
00189   first\_kid.setConstant(-1); 
00190   \textcolor{keywordflow}{for} (StorageIndex v = n-1; v >= 0; v--) 
00191   \{
00192     StorageIndex dad = parent(v);
00193     next\_kid(v) = first\_kid(dad); 
00194     first\_kid(dad) = v; 
00195   \}
00196   
00197   \textcolor{comment}{// Depth-first search from dummy root vertex #n}
00198   postnum = 0; 
00199   \hyperlink{namespace_eigen_1_1internal_acbd726e03f667e0dc788c6b4e92d61ec}{internal::nr\_etdfs}(n, parent, first\_kid, next\_kid, post, postnum);
00200 \}
00201 
00202 \} \textcolor{comment}{// end namespace internal}
00203 
00204 \} \textcolor{comment}{// end namespace Eigen}
00205 
00206 \textcolor{preprocessor}{#endif // SPARSE\_COLETREE\_H}
\end{DoxyCode}
