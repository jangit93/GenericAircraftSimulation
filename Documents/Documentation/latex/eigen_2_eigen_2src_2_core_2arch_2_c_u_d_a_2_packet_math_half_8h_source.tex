\hypertarget{eigen_2_eigen_2src_2_core_2arch_2_c_u_d_a_2_packet_math_half_8h_source}{}\section{eigen/\+Eigen/src/\+Core/arch/\+C\+U\+D\+A/\+Packet\+Math\+Half.h}
\label{eigen_2_eigen_2src_2_core_2arch_2_c_u_d_a_2_packet_math_half_8h_source}\index{Packet\+Math\+Half.\+h@{Packet\+Math\+Half.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2016 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_PACKET\_MATH\_HALF\_CUDA\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_PACKET\_MATH\_HALF\_CUDA\_H}
00012 
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{comment}{// Most of the following operations require arch >= 3.0}
00018 \textcolor{preprocessor}{#if defined(EIGEN\_HAS\_CUDA\_FP16) && defined(\_\_CUDACC\_\_) && defined(\_\_CUDA\_ARCH\_\_) && \_\_CUDA\_ARCH\_\_ >= 300}
00019 
00020 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<half2> \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00021 
00022 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<\hyperlink{namespace_eigen}{Eigen}::half> : default\_packet\_traits
00023 \{
00024   \textcolor{keyword}{typedef} half2 type;
00025   \textcolor{keyword}{typedef} half2 half;
00026   \textcolor{keyword}{enum} \{
00027     Vectorizable = 1,
00028     AlignedOnScalar = 1,
00029     size=2,
00030     HasHalfPacket = 0,
00031     HasAdd    = 1,
00032     HasMul    = 1,
00033     HasDiv    = 1,
00034     HasSqrt   = 1,
00035     HasRsqrt  = 1,
00036     HasExp    = 1,
00037     HasLog    = 1,
00038     HasLog1p  = 1
00039   \};
00040 \};
00041 
00042 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<half2> \{ \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1half}{Eigen::half} type; \textcolor{keyword}{enum} \{size=2, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} half2 half; \};
00043 
00044 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 pset1<half2>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}& from) \{
00045   \textcolor{keywordflow}{return} \_\_half2half2(from);
00046 \}
00047 
00048 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 pload<half2>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
00049   \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }half2*\textcolor{keyword}{>}(from);
00050 \}
00051 
00052 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 ploadu<half2>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
00053   \textcolor{keywordflow}{return} \_\_halves2half2(from[0], from[1]);
00054 \}
00055 
00056 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE half2 ploaddup<half2>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}*  from) \{
00057   \textcolor{keywordflow}{return} \_\_halves2half2(from[0], from[0]);
00058 \}
00059 
00060 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<Eigen::half>(\hyperlink{struct_eigen_1_1half}{Eigen::half}* to, \textcolor{keyword}{const} half2&
       from) \{
00061   *\textcolor{keyword}{reinterpret\_cast<}half2*\textcolor{keyword}{>}(to) = from;
00062 \}
00063 
00064 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<Eigen::half>(\hyperlink{struct_eigen_1_1half}{Eigen::half}* to, \textcolor{keyword}{const} half2
      & from) \{
00065   to[0] = \_\_low2half(from);
00066   to[1] = \_\_high2half(from);
00067 \}
00068 
00069 \textcolor{keyword}{template}<>
00070  \_\_device\_\_ EIGEN\_ALWAYS\_INLINE half2 ploadt\_ro<half2, Aligned>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
00071 \textcolor{preprocessor}{#if \_\_CUDA\_ARCH\_\_ >= 350}
00072    \textcolor{keywordflow}{return} \_\_ldg((\textcolor{keyword}{const} half2*)from);
00073 \textcolor{preprocessor}{#else}
00074   \textcolor{keywordflow}{return} \_\_halves2half2(*(from+0), *(from+1));
00075 \textcolor{preprocessor}{#endif}
00076 \}
00077 
00078 \textcolor{keyword}{template}<>
00079 \_\_device\_\_ EIGEN\_ALWAYS\_INLINE half2 ploadt\_ro<half2, Unaligned>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
00080 \textcolor{preprocessor}{#if \_\_CUDA\_ARCH\_\_ >= 350}
00081    \textcolor{keywordflow}{return} \_\_halves2half2(\_\_ldg(from+0), \_\_ldg(from+1));
00082 \textcolor{preprocessor}{#else}
00083   \textcolor{keywordflow}{return} \_\_halves2half2(*(from+0), *(from+1));
00084 \textcolor{preprocessor}{#endif}
00085 \}
00086 
00087 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 pgather<Eigen::half, half2>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}* from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride) \{
00088   \textcolor{keywordflow}{return} \_\_halves2half2(from[0*stride], from[1*stride]);
00089 \}
00090 
00091 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pscatter<Eigen::half, half2>(
      \hyperlink{struct_eigen_1_1half}{Eigen::half}* to, \textcolor{keyword}{const} half2& from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride) \{
00092   to[stride*0] = \_\_low2half(from);
00093   to[stride*1] = \_\_high2half(from);
00094 \}
00095 
00096 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} pfirst<half2>(\textcolor{keyword}{const} half2& a) \{
00097   \textcolor{keywordflow}{return} \_\_low2half(a);
00098 \}
00099 
00100 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 pabs<half2>(\textcolor{keyword}{const} half2& a) \{
00101   half2 result;
00102   result.x = a.x & 0x7FFF7FFF;
00103   \textcolor{keywordflow}{return} result;
00104 \}
00105 
00106 
00107 \_\_device\_\_ EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00108 ptranspose(PacketBlock<half2,2>& kernel) \{
00109   \_\_half a1 = \_\_low2half(kernel.packet[0]);
00110   \_\_half a2 = \_\_high2half(kernel.packet[0]);
00111   \_\_half b1 = \_\_low2half(kernel.packet[1]);
00112   \_\_half b2 = \_\_high2half(kernel.packet[1]);
00113   kernel.packet[0] = \_\_halves2half2(a1, b1);
00114   kernel.packet[1] = \_\_halves2half2(a2, b2);
00115 \}
00116 
00117 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 plset<half2>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}& a) \{
00118 \textcolor{preprocessor}{#if \_\_CUDA\_ARCH\_\_ >= 530}
00119   \textcolor{keywordflow}{return} \_\_halves2half2(a, \_\_hadd(a, \_\_float2half(1.0f)));
00120 \textcolor{preprocessor}{#else}
00121   \textcolor{keywordtype}{float} f = \_\_half2float(a) + 1.0f;
00122   \textcolor{keywordflow}{return} \_\_halves2half2(a, \_\_float2half(f));
00123 \textcolor{preprocessor}{#endif}
00124 \}
00125 
00126 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 padd<half2>(\textcolor{keyword}{const} half2& a, \textcolor{keyword}{const} half2& b) \{
00127 \textcolor{preprocessor}{#if \_\_CUDA\_ARCH\_\_ >= 530}
00128   \textcolor{keywordflow}{return} \_\_hadd2(a, b);
00129 \textcolor{preprocessor}{#else}
00130   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00131   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00132   \textcolor{keywordtype}{float} b1 = \_\_low2float(b);
00133   \textcolor{keywordtype}{float} b2 = \_\_high2float(b);
00134   \textcolor{keywordtype}{float} r1 = a1 + b1;
00135   \textcolor{keywordtype}{float} r2 = a2 + b2;
00136   \textcolor{keywordflow}{return} \_\_floats2half2\_rn(r1, r2);
00137 \textcolor{preprocessor}{#endif}
00138 \}
00139 
00140 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 psub<half2>(\textcolor{keyword}{const} half2& a, \textcolor{keyword}{const} half2& b) \{
00141 \textcolor{preprocessor}{#if \_\_CUDA\_ARCH\_\_ >= 530}
00142   \textcolor{keywordflow}{return} \_\_hsub2(a, b);
00143 \textcolor{preprocessor}{#else}
00144   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00145   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00146   \textcolor{keywordtype}{float} b1 = \_\_low2float(b);
00147   \textcolor{keywordtype}{float} b2 = \_\_high2float(b);
00148   \textcolor{keywordtype}{float} r1 = a1 - b1;
00149   \textcolor{keywordtype}{float} r2 = a2 - b2;
00150   \textcolor{keywordflow}{return} \_\_floats2half2\_rn(r1, r2);
00151 \textcolor{preprocessor}{#endif}
00152 \}
00153 
00154 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 pnegate(\textcolor{keyword}{const} half2& a) \{
00155 \textcolor{preprocessor}{#if \_\_CUDA\_ARCH\_\_ >= 530}
00156   \textcolor{keywordflow}{return} \_\_hneg2(a);
00157 \textcolor{preprocessor}{#else}
00158   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00159   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00160   \textcolor{keywordflow}{return} \_\_floats2half2\_rn(-a1, -a2);
00161 \textcolor{preprocessor}{#endif}
00162 \}
00163 
00164 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 pconj(\textcolor{keyword}{const} half2& a) \{ \textcolor{keywordflow}{return} a; \}
00165 
00166 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 pmul<half2>(\textcolor{keyword}{const} half2& a, \textcolor{keyword}{const} half2& b) \{
00167 \textcolor{preprocessor}{#if \_\_CUDA\_ARCH\_\_ >= 530}
00168   \textcolor{keywordflow}{return} \_\_hmul2(a, b);
00169 \textcolor{preprocessor}{#else}
00170   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00171   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00172   \textcolor{keywordtype}{float} b1 = \_\_low2float(b);
00173   \textcolor{keywordtype}{float} b2 = \_\_high2float(b);
00174   \textcolor{keywordtype}{float} r1 = a1 * b1;
00175   \textcolor{keywordtype}{float} r2 = a2 * b2;
00176   \textcolor{keywordflow}{return} \_\_floats2half2\_rn(r1, r2);
00177 \textcolor{preprocessor}{#endif}
00178 \}
00179 
00180 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 pmadd<half2>(\textcolor{keyword}{const} half2& a, \textcolor{keyword}{const} half2& b, \textcolor{keyword}{const} half2& c
      ) \{
00181 \textcolor{preprocessor}{#if \_\_CUDA\_ARCH\_\_ >= 530}
00182    \textcolor{keywordflow}{return} \_\_hfma2(a, b, c);
00183 \textcolor{preprocessor}{#else}
00184   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00185   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00186   \textcolor{keywordtype}{float} b1 = \_\_low2float(b);
00187   \textcolor{keywordtype}{float} b2 = \_\_high2float(b);
00188   \textcolor{keywordtype}{float} c1 = \_\_low2float(c);
00189   \textcolor{keywordtype}{float} c2 = \_\_high2float(c);
00190   \textcolor{keywordtype}{float} r1 = a1 * b1 + c1;
00191   \textcolor{keywordtype}{float} r2 = a2 * b2 + c2;
00192   \textcolor{keywordflow}{return} \_\_floats2half2\_rn(r1, r2);
00193 \textcolor{preprocessor}{#endif}
00194 \}
00195 
00196 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 pdiv<half2>(\textcolor{keyword}{const} half2& a, \textcolor{keyword}{const} half2& b) \{
00197   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00198   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00199   \textcolor{keywordtype}{float} b1 = \_\_low2float(b);
00200   \textcolor{keywordtype}{float} b2 = \_\_high2float(b);
00201   \textcolor{keywordtype}{float} r1 = a1 / b1;
00202   \textcolor{keywordtype}{float} r2 = a2 / b2;
00203   \textcolor{keywordflow}{return} \_\_floats2half2\_rn(r1, r2);
00204 \}
00205 
00206 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 pmin<half2>(\textcolor{keyword}{const} half2& a, \textcolor{keyword}{const} half2& b) \{
00207   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00208   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00209   \textcolor{keywordtype}{float} b1 = \_\_low2float(b);
00210   \textcolor{keywordtype}{float} b2 = \_\_high2float(b);
00211   \_\_half r1 = a1 < b1 ? \_\_low2half(a) : \_\_low2half(b);
00212   \_\_half r2 = a2 < b2 ? \_\_high2half(a) : \_\_high2half(b);
00213   \textcolor{keywordflow}{return} \_\_halves2half2(r1, r2);
00214 \}
00215 
00216 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 pmax<half2>(\textcolor{keyword}{const} half2& a, \textcolor{keyword}{const} half2& b) \{
00217   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00218   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00219   \textcolor{keywordtype}{float} b1 = \_\_low2float(b);
00220   \textcolor{keywordtype}{float} b2 = \_\_high2float(b);
00221   \_\_half r1 = a1 > b1 ? \_\_low2half(a) : \_\_low2half(b);
00222   \_\_half r2 = a2 > b2 ? \_\_high2half(a) : \_\_high2half(b);
00223   \textcolor{keywordflow}{return} \_\_halves2half2(r1, r2);
00224 \}
00225 
00226 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} predux<half2>(\textcolor{keyword}{const} half2& a) \{
00227 \textcolor{preprocessor}{#if \_\_CUDA\_ARCH\_\_ >= 530}
00228   \textcolor{keywordflow}{return} \_\_hadd(\_\_low2half(a), \_\_high2half(a));
00229 \textcolor{preprocessor}{#else}
00230   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00231   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00232   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(half\_impl::raw\_uint16\_to\_half(\_\_float2half\_rn(a1 + a2)));
00233 \textcolor{preprocessor}{#endif}
00234 \}
00235 
00236 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} predux\_max<half2>(\textcolor{keyword}{const} half2& a) \{
00237 \textcolor{preprocessor}{#if \_\_CUDA\_ARCH\_\_ >= 530}
00238   \_\_half first = \_\_low2half(a);
00239   \_\_half second = \_\_high2half(a);
00240   \textcolor{keywordflow}{return} \_\_hgt(first, second) ? first : second;
00241 \textcolor{preprocessor}{#else}
00242   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00243   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00244   \textcolor{keywordflow}{return} a1 > a2 ? \_\_low2half(a) : \_\_high2half(a);
00245 \textcolor{preprocessor}{#endif}
00246 \}
00247 
00248 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} predux\_min<half2>(\textcolor{keyword}{const} half2& a) \{
00249 \textcolor{preprocessor}{#if \_\_CUDA\_ARCH\_\_ >= 530}
00250   \_\_half first = \_\_low2half(a);
00251   \_\_half second = \_\_high2half(a);
00252   \textcolor{keywordflow}{return} \_\_hlt(first, second) ? first : second;
00253 \textcolor{preprocessor}{#else}
00254   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00255   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00256   \textcolor{keywordflow}{return} a1 < a2 ? \_\_low2half(a) : \_\_high2half(a);
00257 \textcolor{preprocessor}{#endif}
00258 \}
00259 
00260 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} predux\_mul<half2>(\textcolor{keyword}{const} half2& a) \{
00261 \textcolor{preprocessor}{#if \_\_CUDA\_ARCH\_\_ >= 530}
00262   \textcolor{keywordflow}{return} \_\_hmul(\_\_low2half(a), \_\_high2half(a));
00263 \textcolor{preprocessor}{#else}
00264   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00265   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00266   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(half\_impl::raw\_uint16\_to\_half(\_\_float2half\_rn(a1 * a2)));
00267 \textcolor{preprocessor}{#endif}
00268 \}
00269 
00270 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 plog1p<half2>(\textcolor{keyword}{const} half2& a) \{
00271   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00272   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00273   \textcolor{keywordtype}{float} r1 = log1pf(a1);
00274   \textcolor{keywordtype}{float} r2 = log1pf(a2);
00275   \textcolor{keywordflow}{return} \_\_floats2half2\_rn(r1, r2);
00276 \}
00277 
00278 \textcolor{preprocessor}{#if defined \_\_CUDACC\_VER\_\_ && \_\_CUDACC\_VER\_\_ >= 80000 && defined \_\_CUDA\_ARCH\_\_ && \_\_CUDA\_ARCH\_\_ >= 530}
00279 
00280 \textcolor{keyword}{template}<>  \_\_device\_\_ EIGEN\_STRONG\_INLINE
00281 half2 plog<half2>(\textcolor{keyword}{const} half2& a) \{
00282   \textcolor{keywordflow}{return} h2log(a);
00283 \}
00284 
00285 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE
00286 half2 pexp<half2>(\textcolor{keyword}{const} half2& a) \{
00287   \textcolor{keywordflow}{return} h2exp(a);
00288 \}
00289 
00290 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE
00291 half2 psqrt<half2>(\textcolor{keyword}{const} half2& a) \{
00292   \textcolor{keywordflow}{return} h2sqrt(a);
00293 \}
00294 
00295 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE
00296 half2 prsqrt<half2>(\textcolor{keyword}{const} half2& a) \{
00297   \textcolor{keywordflow}{return} h2rsqrt(a);
00298 \}
00299 
00300 \textcolor{preprocessor}{#else}
00301 
00302 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 plog<half2>(\textcolor{keyword}{const} half2& a) \{
00303   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00304   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00305   \textcolor{keywordtype}{float} r1 = logf(a1);
00306   \textcolor{keywordtype}{float} r2 = logf(a2);
00307   \textcolor{keywordflow}{return} \_\_floats2half2\_rn(r1, r2);
00308 \}
00309 
00310 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 pexp<half2>(\textcolor{keyword}{const} half2& a) \{
00311   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00312   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00313   \textcolor{keywordtype}{float} r1 = expf(a1);
00314   \textcolor{keywordtype}{float} r2 = expf(a2);
00315   \textcolor{keywordflow}{return} \_\_floats2half2\_rn(r1, r2);
00316 \}
00317 
00318 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 psqrt<half2>(\textcolor{keyword}{const} half2& a) \{
00319   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00320   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00321   \textcolor{keywordtype}{float} r1 = sqrtf(a1);
00322   \textcolor{keywordtype}{float} r2 = sqrtf(a2);
00323   \textcolor{keywordflow}{return} \_\_floats2half2\_rn(r1, r2);
00324 \}
00325 
00326 \textcolor{keyword}{template}<> \_\_device\_\_ EIGEN\_STRONG\_INLINE half2 prsqrt<half2>(\textcolor{keyword}{const} half2& a) \{
00327   \textcolor{keywordtype}{float} a1 = \_\_low2float(a);
00328   \textcolor{keywordtype}{float} a2 = \_\_high2float(a);
00329   \textcolor{keywordtype}{float} r1 = rsqrtf(a1);
00330   \textcolor{keywordtype}{float} r2 = rsqrtf(a2);
00331   \textcolor{keywordflow}{return} \_\_floats2half2\_rn(r1, r2);
00332 \}
00333 
00334 \textcolor{preprocessor}{#endif}
00335 
00336 \textcolor{preprocessor}{#elif defined EIGEN\_VECTORIZE\_AVX512}
00337 
00338 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
00339   \_\_m256i x;
00340 \} Packet16h;
00341 
00342 
00343 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<Packet16h> \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00344 
00345 \textcolor{keyword}{template} <>
00346 \textcolor{keyword}{struct }packet\_traits<half> : default\_packet\_traits \{
00347   \textcolor{keyword}{typedef} Packet16h type;
00348   \textcolor{comment}{// There is no half-size packet for Packet16h.}
00349   \textcolor{keyword}{typedef} Packet16h half;
00350   \textcolor{keyword}{enum} \{
00351     Vectorizable = 1,
00352     AlignedOnScalar = 1,
00353     size = 16,
00354     HasHalfPacket = 0,
00355     HasAdd    = 0,
00356     HasSub    = 0,
00357     HasMul    = 0,
00358     HasNegate = 0,
00359     HasAbs    = 0,
00360     HasAbs2   = 0,
00361     HasMin    = 0,
00362     HasMax    = 0,
00363     HasConj   = 0,
00364     HasSetLinear = 0,
00365     HasDiv = 0,
00366     HasSqrt = 0,
00367     HasRsqrt = 0,
00368     HasExp = 0,
00369     HasLog = 0,
00370     HasBlend = 0
00371   \};
00372 \};
00373 
00374 
00375 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet16h> \{ \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1half}{Eigen::half} type; \textcolor{keyword}{enum} \{size=16, 
      alignment=\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1a7797d247b86f6e9837cc338beb6060de}{Aligned32}\}; \textcolor{keyword}{typedef} Packet16h half; \};
00376 
00377 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet16h pset1<Packet16h>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}& from) \{
00378   Packet16h result;
00379   result.x = \_mm256\_set1\_epi16(from.x);
00380   \textcolor{keywordflow}{return} result;
00381 \}
00382 
00383 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} pfirst<Packet16h>(\textcolor{keyword}{const} Packet16h& from) \{
00384   \textcolor{keywordflow}{return} half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(\_mm256\_extract\_epi16(from.x, 0)));
00385 \}
00386 
00387 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet16h pload<Packet16h>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
00388   Packet16h result;
00389   result.x = \_mm256\_load\_si256(reinterpret\_cast<const \_\_m256i*>(from));
00390   \textcolor{keywordflow}{return} result;
00391 \}
00392 
00393 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet16h ploadu<Packet16h>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
00394   Packet16h result;
00395   result.x = \_mm256\_loadu\_si256(reinterpret\_cast<const \_\_m256i*>(from));
00396   \textcolor{keywordflow}{return} result;
00397 \}
00398 
00399 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<half>(\hyperlink{struct_eigen_1_1half}{Eigen::half}* to, \textcolor{keyword}{const} Packet16h& from) \{
00400   \_mm256\_store\_si256((\_\_m256i*)to, from.x);
00401 \}
00402 
00403 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<half>(\hyperlink{struct_eigen_1_1half}{Eigen::half}* to, \textcolor{keyword}{const} Packet16h& from) \{
00404   \_mm256\_storeu\_si256((\_\_m256i*)to, from.x);
00405 \}
00406 
00407 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet16h
00408 ploadquad(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
00409   Packet16h result;
00410   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} a = from[0].x;
00411   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} b = from[1].x;
00412   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} c = from[2].x;
00413   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} d = from[3].x;
00414   result.x = \_mm256\_set\_epi16(d, d, d, d, c, c, c, c, b, b, b, b, a, a, a, a);
00415   \textcolor{keywordflow}{return} result;
00416 \}
00417 
00418 EIGEN\_STRONG\_INLINE Packet16f half2float(\textcolor{keyword}{const} Packet16h& a) \{
00419 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_FP16\_C}
00420   \textcolor{keywordflow}{return} \_mm512\_cvtph\_ps(a.x);
00421 \textcolor{preprocessor}{#else}
00422   EIGEN\_ALIGN64 half aux[16];
00423   pstore(aux, a);
00424   \textcolor{keywordtype}{float} f0(aux[0]);
00425   \textcolor{keywordtype}{float} f1(aux[1]);
00426   \textcolor{keywordtype}{float} f2(aux[2]);
00427   \textcolor{keywordtype}{float} f3(aux[3]);
00428   \textcolor{keywordtype}{float} f4(aux[4]);
00429   \textcolor{keywordtype}{float} f5(aux[5]);
00430   \textcolor{keywordtype}{float} f6(aux[6]);
00431   \textcolor{keywordtype}{float} f7(aux[7]);
00432   \textcolor{keywordtype}{float} f8(aux[8]);
00433   \textcolor{keywordtype}{float} f9(aux[9]);
00434   \textcolor{keywordtype}{float} fa(aux[10]);
00435   \textcolor{keywordtype}{float} fb(aux[11]);
00436   \textcolor{keywordtype}{float} fc(aux[12]);
00437   \textcolor{keywordtype}{float} fd(aux[13]);
00438   \textcolor{keywordtype}{float} fe(aux[14]);
00439   \textcolor{keywordtype}{float} ff(aux[15]);
00440 
00441   \textcolor{keywordflow}{return} \_mm512\_set\_ps(
00442       ff, fe, fd, fc, fb, fa, f9, f8, f7, f6, f5, f4, f3, f2, f1, f0);
00443 \textcolor{preprocessor}{#endif}
00444 \}
00445 
00446 EIGEN\_STRONG\_INLINE Packet16h float2half(\textcolor{keyword}{const} Packet16f& a) \{
00447 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_FP16\_C}
00448   Packet16h result;
00449   result.x = \_mm512\_cvtps\_ph(a, \_MM\_FROUND\_TO\_NEAREST\_INT|\_MM\_FROUND\_NO\_EXC);
00450   \textcolor{keywordflow}{return} result;
00451 \textcolor{preprocessor}{#else}
00452   EIGEN\_ALIGN64 \textcolor{keywordtype}{float} aux[16];
00453   pstore(aux, a);
00454   half h0(aux[0]);
00455   half h1(aux[1]);
00456   half h2(aux[2]);
00457   half h3(aux[3]);
00458   half h4(aux[4]);
00459   half h5(aux[5]);
00460   half h6(aux[6]);
00461   half h7(aux[7]);
00462   half h8(aux[8]);
00463   half h9(aux[9]);
00464   half ha(aux[10]);
00465   half hb(aux[11]);
00466   half hc(aux[12]);
00467   half hd(aux[13]);
00468   half he(aux[14]);
00469   half hf(aux[15]);
00470 
00471   Packet16h result;
00472   result.x = \_mm256\_set\_epi16(
00473       hf.x, he.x, hd.x, hc.x, hb.x, ha.x, h9.x, h8.x,
00474       h7.x, h6.x, h5.x, h4.x, h3.x, h2.x, h1.x, h0.x);
00475   \textcolor{keywordflow}{return} result;
00476 \textcolor{preprocessor}{#endif}
00477 \}
00478 
00479 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet16h padd<Packet16h>(\textcolor{keyword}{const} Packet16h& a, \textcolor{keyword}{const} Packet16h& b) \{
00480   Packet16f af = half2float(a);
00481   Packet16f bf = half2float(b);
00482   Packet16f rf = padd(af, bf);
00483   \textcolor{keywordflow}{return} float2half(rf);
00484 \}
00485 
00486 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet16h pmul<Packet16h>(\textcolor{keyword}{const} Packet16h& a, \textcolor{keyword}{const} Packet16h& b) \{
00487   Packet16f af = half2float(a);
00488   Packet16f bf = half2float(b);
00489   Packet16f rf = pmul(af, bf);
00490   \textcolor{keywordflow}{return} float2half(rf);
00491 \}
00492 
00493 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE half predux<Packet16h>(\textcolor{keyword}{const} Packet16h& from) \{
00494   Packet16f from\_float = half2float(from);
00495   \textcolor{keywordflow}{return} half(predux(from\_float));
00496 \}
00497 
00498 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet16h pgather<Eigen::half, Packet16h>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}* from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00499 \{
00500   Packet16h result;
00501   result.x = \_mm256\_set\_epi16(
00502       from[15*stride].x, from[14*stride].x, from[13*stride].x, from[12*stride].x,
00503       from[11*stride].x, from[10*stride].x, from[9*stride].x, from[8*stride].x,
00504       from[7*stride].x, from[6*stride].x, from[5*stride].x, from[4*stride].x,
00505       from[3*stride].x, from[2*stride].x, from[1*stride].x, from[0*stride].x);
00506   \textcolor{keywordflow}{return} result;
00507 \}
00508 
00509 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pscatter<half, Packet16h>(half* to, \textcolor{keyword}{const} Packet16h& from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00510 \{
00511   EIGEN\_ALIGN64 half aux[16];
00512   pstore(aux, from);
00513   to[stride*0].x = aux[0].x;
00514   to[stride*1].x = aux[1].x;
00515   to[stride*2].x = aux[2].x;
00516   to[stride*3].x = aux[3].x;
00517   to[stride*4].x = aux[4].x;
00518   to[stride*5].x = aux[5].x;
00519   to[stride*6].x = aux[6].x;
00520   to[stride*7].x = aux[7].x;
00521   to[stride*8].x = aux[8].x;
00522   to[stride*9].x = aux[9].x;
00523   to[stride*10].x = aux[10].x;
00524   to[stride*11].x = aux[11].x;
00525   to[stride*12].x = aux[12].x;
00526   to[stride*13].x = aux[13].x;
00527   to[stride*14].x = aux[14].x;
00528   to[stride*15].x = aux[15].x;
00529 \}
00530 
00531 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00532 ptranspose(PacketBlock<Packet16h,16>& kernel) \{
00533   \_\_m256i a = kernel.packet[0].x;
00534   \_\_m256i b = kernel.packet[1].x;
00535   \_\_m256i c = kernel.packet[2].x;
00536   \_\_m256i d = kernel.packet[3].x;
00537   \_\_m256i e = kernel.packet[4].x;
00538   \_\_m256i f = kernel.packet[5].x;
00539   \_\_m256i g = kernel.packet[6].x;
00540   \_\_m256i h = kernel.packet[7].x;
00541   \_\_m256i i = kernel.packet[8].x;
00542   \_\_m256i j = kernel.packet[9].x;
00543   \_\_m256i k = kernel.packet[10].x;
00544   \_\_m256i l = kernel.packet[11].x;
00545   \_\_m256i m = kernel.packet[12].x;
00546   \_\_m256i n = kernel.packet[13].x;
00547   \_\_m256i o = kernel.packet[14].x;
00548   \_\_m256i p = kernel.packet[15].x;
00549 
00550   \_\_m256i ab\_07 = \_mm256\_unpacklo\_epi16(a, b);
00551   \_\_m256i cd\_07 = \_mm256\_unpacklo\_epi16(c, d);
00552   \_\_m256i ef\_07 = \_mm256\_unpacklo\_epi16(e, f);
00553   \_\_m256i gh\_07 = \_mm256\_unpacklo\_epi16(g, h);
00554   \_\_m256i ij\_07 = \_mm256\_unpacklo\_epi16(i, j);
00555   \_\_m256i kl\_07 = \_mm256\_unpacklo\_epi16(k, l);
00556   \_\_m256i mn\_07 = \_mm256\_unpacklo\_epi16(m, n);
00557   \_\_m256i op\_07 = \_mm256\_unpacklo\_epi16(o, p);
00558 
00559   \_\_m256i ab\_8f = \_mm256\_unpackhi\_epi16(a, b);
00560   \_\_m256i cd\_8f = \_mm256\_unpackhi\_epi16(c, d);
00561   \_\_m256i ef\_8f = \_mm256\_unpackhi\_epi16(e, f);
00562   \_\_m256i gh\_8f = \_mm256\_unpackhi\_epi16(g, h);
00563   \_\_m256i ij\_8f = \_mm256\_unpackhi\_epi16(i, j);
00564   \_\_m256i kl\_8f = \_mm256\_unpackhi\_epi16(k, l);
00565   \_\_m256i mn\_8f = \_mm256\_unpackhi\_epi16(m, n);
00566   \_\_m256i op\_8f = \_mm256\_unpackhi\_epi16(o, p);
00567 
00568   \_\_m256i abcd\_03 = \_mm256\_unpacklo\_epi32(ab\_07, cd\_07);
00569   \_\_m256i abcd\_47 = \_mm256\_unpackhi\_epi32(ab\_07, cd\_07);
00570   \_\_m256i efgh\_03 = \_mm256\_unpacklo\_epi32(ef\_07, gh\_07);
00571   \_\_m256i efgh\_47 = \_mm256\_unpackhi\_epi32(ef\_07, gh\_07);
00572   \_\_m256i ijkl\_03 = \_mm256\_unpacklo\_epi32(ij\_07, kl\_07);
00573   \_\_m256i ijkl\_47 = \_mm256\_unpackhi\_epi32(ij\_07, kl\_07);
00574   \_\_m256i mnop\_03 = \_mm256\_unpacklo\_epi32(mn\_07, op\_07);
00575   \_\_m256i mnop\_47 = \_mm256\_unpackhi\_epi32(mn\_07, op\_07);
00576 
00577   \_\_m256i abcd\_8b = \_mm256\_unpacklo\_epi32(ab\_8f, cd\_8f);
00578   \_\_m256i abcd\_cf = \_mm256\_unpackhi\_epi32(ab\_8f, cd\_8f);
00579   \_\_m256i efgh\_8b = \_mm256\_unpacklo\_epi32(ef\_8f, gh\_8f);
00580   \_\_m256i efgh\_cf = \_mm256\_unpackhi\_epi32(ef\_8f, gh\_8f);
00581   \_\_m256i ijkl\_8b = \_mm256\_unpacklo\_epi32(ij\_8f, kl\_8f);
00582   \_\_m256i ijkl\_cf = \_mm256\_unpackhi\_epi32(ij\_8f, kl\_8f);
00583   \_\_m256i mnop\_8b = \_mm256\_unpacklo\_epi32(mn\_8f, op\_8f);
00584   \_\_m256i mnop\_cf = \_mm256\_unpackhi\_epi32(mn\_8f, op\_8f);
00585 
00586   \_\_m256i abcdefgh\_01 = \_mm256\_unpacklo\_epi64(abcd\_03, efgh\_03);
00587   \_\_m256i abcdefgh\_23 = \_mm256\_unpackhi\_epi64(abcd\_03, efgh\_03);
00588   \_\_m256i ijklmnop\_01 = \_mm256\_unpacklo\_epi64(ijkl\_03, mnop\_03);
00589   \_\_m256i ijklmnop\_23 = \_mm256\_unpackhi\_epi64(ijkl\_03, mnop\_03);
00590   \_\_m256i abcdefgh\_45 = \_mm256\_unpacklo\_epi64(abcd\_47, efgh\_47);
00591   \_\_m256i abcdefgh\_67 = \_mm256\_unpackhi\_epi64(abcd\_47, efgh\_47);
00592   \_\_m256i ijklmnop\_45 = \_mm256\_unpacklo\_epi64(ijkl\_47, mnop\_47);
00593   \_\_m256i ijklmnop\_67 = \_mm256\_unpackhi\_epi64(ijkl\_47, mnop\_47);
00594   \_\_m256i abcdefgh\_89 = \_mm256\_unpacklo\_epi64(abcd\_8b, efgh\_8b);
00595   \_\_m256i abcdefgh\_ab = \_mm256\_unpackhi\_epi64(abcd\_8b, efgh\_8b);
00596   \_\_m256i ijklmnop\_89 = \_mm256\_unpacklo\_epi64(ijkl\_8b, mnop\_8b);
00597   \_\_m256i ijklmnop\_ab = \_mm256\_unpackhi\_epi64(ijkl\_8b, mnop\_8b);
00598   \_\_m256i abcdefgh\_cd = \_mm256\_unpacklo\_epi64(abcd\_cf, efgh\_cf);
00599   \_\_m256i abcdefgh\_ef = \_mm256\_unpackhi\_epi64(abcd\_cf, efgh\_cf);
00600   \_\_m256i ijklmnop\_cd = \_mm256\_unpacklo\_epi64(ijkl\_cf, mnop\_cf);
00601   \_\_m256i ijklmnop\_ef = \_mm256\_unpackhi\_epi64(ijkl\_cf, mnop\_cf);
00602 
00603   \textcolor{comment}{// NOTE: no unpacklo/hi instr in this case, so using permute instr.}
00604   \_\_m256i a\_p\_0 = \_mm256\_permute2x128\_si256(abcdefgh\_01, ijklmnop\_01, 0x20);
00605   \_\_m256i a\_p\_1 = \_mm256\_permute2x128\_si256(abcdefgh\_01, ijklmnop\_01, 0x31);
00606   \_\_m256i a\_p\_2 = \_mm256\_permute2x128\_si256(abcdefgh\_23, ijklmnop\_23, 0x20);
00607   \_\_m256i a\_p\_3 = \_mm256\_permute2x128\_si256(abcdefgh\_23, ijklmnop\_23, 0x31);
00608   \_\_m256i a\_p\_4 = \_mm256\_permute2x128\_si256(abcdefgh\_45, ijklmnop\_45, 0x20);
00609   \_\_m256i a\_p\_5 = \_mm256\_permute2x128\_si256(abcdefgh\_45, ijklmnop\_45, 0x31);
00610   \_\_m256i a\_p\_6 = \_mm256\_permute2x128\_si256(abcdefgh\_67, ijklmnop\_67, 0x20);
00611   \_\_m256i a\_p\_7 = \_mm256\_permute2x128\_si256(abcdefgh\_67, ijklmnop\_67, 0x31);
00612   \_\_m256i a\_p\_8 = \_mm256\_permute2x128\_si256(abcdefgh\_89, ijklmnop\_89, 0x20);
00613   \_\_m256i a\_p\_9 = \_mm256\_permute2x128\_si256(abcdefgh\_89, ijklmnop\_89, 0x31);
00614   \_\_m256i a\_p\_a = \_mm256\_permute2x128\_si256(abcdefgh\_ab, ijklmnop\_ab, 0x20);
00615   \_\_m256i a\_p\_b = \_mm256\_permute2x128\_si256(abcdefgh\_ab, ijklmnop\_ab, 0x31);
00616   \_\_m256i a\_p\_c = \_mm256\_permute2x128\_si256(abcdefgh\_cd, ijklmnop\_cd, 0x20);
00617   \_\_m256i a\_p\_d = \_mm256\_permute2x128\_si256(abcdefgh\_cd, ijklmnop\_cd, 0x31);
00618   \_\_m256i a\_p\_e = \_mm256\_permute2x128\_si256(abcdefgh\_ef, ijklmnop\_ef, 0x20);
00619   \_\_m256i a\_p\_f = \_mm256\_permute2x128\_si256(abcdefgh\_ef, ijklmnop\_ef, 0x31);
00620 
00621   kernel.packet[0].x = a\_p\_0;
00622   kernel.packet[1].x = a\_p\_1;
00623   kernel.packet[2].x = a\_p\_2;
00624   kernel.packet[3].x = a\_p\_3;
00625   kernel.packet[4].x = a\_p\_4;
00626   kernel.packet[5].x = a\_p\_5;
00627   kernel.packet[6].x = a\_p\_6;
00628   kernel.packet[7].x = a\_p\_7;
00629   kernel.packet[8].x = a\_p\_8;
00630   kernel.packet[9].x = a\_p\_9;
00631   kernel.packet[10].x = a\_p\_a;
00632   kernel.packet[11].x = a\_p\_b;
00633   kernel.packet[12].x = a\_p\_c;
00634   kernel.packet[13].x = a\_p\_d;
00635   kernel.packet[14].x = a\_p\_e;
00636   kernel.packet[15].x = a\_p\_f;
00637 \}
00638 
00639 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00640 ptranspose(PacketBlock<Packet16h,8>& kernel) \{
00641   EIGEN\_ALIGN64 half in[8][16];
00642   pstore<half>(in[0], kernel.packet[0]);
00643   pstore<half>(in[1], kernel.packet[1]);
00644   pstore<half>(in[2], kernel.packet[2]);
00645   pstore<half>(in[3], kernel.packet[3]);
00646   pstore<half>(in[4], kernel.packet[4]);
00647   pstore<half>(in[5], kernel.packet[5]);
00648   pstore<half>(in[6], kernel.packet[6]);
00649   pstore<half>(in[7], kernel.packet[7]);
00650 
00651   EIGEN\_ALIGN64 half out[8][16];
00652 
00653   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 8; ++i) \{
00654     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 8; ++j) \{
00655       out[i][j] = in[j][2*i];
00656     \}
00657     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 8; ++j) \{
00658       out[i][j+8] = in[j][2*i+1];
00659     \}
00660   \}
00661 
00662   kernel.packet[0] = pload<Packet16h>(out[0]);
00663   kernel.packet[1] = pload<Packet16h>(out[1]);
00664   kernel.packet[2] = pload<Packet16h>(out[2]);
00665   kernel.packet[3] = pload<Packet16h>(out[3]);
00666   kernel.packet[4] = pload<Packet16h>(out[4]);
00667   kernel.packet[5] = pload<Packet16h>(out[5]);
00668   kernel.packet[6] = pload<Packet16h>(out[6]);
00669   kernel.packet[7] = pload<Packet16h>(out[7]);
00670 \}
00671 
00672 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00673 ptranspose(PacketBlock<Packet16h,4>& kernel) \{
00674   EIGEN\_ALIGN64 half in[4][16];
00675   pstore<half>(in[0], kernel.packet[0]);
00676   pstore<half>(in[1], kernel.packet[1]);
00677   pstore<half>(in[2], kernel.packet[2]);
00678   pstore<half>(in[3], kernel.packet[3]);
00679 
00680   EIGEN\_ALIGN64 half out[4][16];
00681 
00682   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; ++i) \{
00683     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 4; ++j) \{
00684       out[i][j] = in[j][4*i];
00685     \}
00686     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 4; ++j) \{
00687       out[i][j+4] = in[j][4*i+1];
00688     \}
00689     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 4; ++j) \{
00690       out[i][j+8] = in[j][4*i+2];
00691     \}
00692     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 4; ++j) \{
00693       out[i][j+12] = in[j][4*i+3];
00694     \}
00695   \}
00696 
00697   kernel.packet[0] = pload<Packet16h>(out[0]);
00698   kernel.packet[1] = pload<Packet16h>(out[1]);
00699   kernel.packet[2] = pload<Packet16h>(out[2]);
00700   kernel.packet[3] = pload<Packet16h>(out[3]);
00701 \}
00702 
00703 
00704 \textcolor{preprocessor}{#elif defined EIGEN\_VECTORIZE\_AVX}
00705 
00706 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
00707   \_\_m128i x;
00708 \} Packet8h;
00709 
00710 
00711 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<Packet8h> \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00712 
00713 \textcolor{keyword}{template} <>
00714 \textcolor{keyword}{struct }packet\_traits<\hyperlink{namespace_eigen}{Eigen}::half> : default\_packet\_traits \{
00715   \textcolor{keyword}{typedef} Packet8h type;
00716   \textcolor{comment}{// There is no half-size packet for Packet8h.}
00717   \textcolor{keyword}{typedef} Packet8h half;
00718   \textcolor{keyword}{enum} \{
00719     Vectorizable = 1,
00720     AlignedOnScalar = 1,
00721     size = 8,
00722     HasHalfPacket = 0,
00723     HasAdd    = 0,
00724     HasSub    = 0,
00725     HasMul    = 0,
00726     HasNegate = 0,
00727     HasAbs    = 0,
00728     HasAbs2   = 0,
00729     HasMin    = 0,
00730     HasMax    = 0,
00731     HasConj   = 0,
00732     HasSetLinear = 0,
00733     HasDiv = 0,
00734     HasSqrt = 0,
00735     HasRsqrt = 0,
00736     HasExp = 0,
00737     HasLog = 0,
00738     HasBlend = 0
00739   \};
00740 \};
00741 
00742 
00743 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet8h> \{ \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1half}{Eigen::half} type; \textcolor{keyword}{enum} \{size=8, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet8h half; \};
00744 
00745 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8h pset1<Packet8h>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}& from) \{
00746   Packet8h result;
00747   result.x = \_mm\_set1\_epi16(from.x);
00748   \textcolor{keywordflow}{return} result;
00749 \}
00750 
00751 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} pfirst<Packet8h>(\textcolor{keyword}{const} Packet8h& from) \{
00752   \textcolor{keywordflow}{return} half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(\_mm\_extract\_epi16(from.x, 0)));
00753 \}
00754 
00755 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8h pload<Packet8h>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
00756   Packet8h result;
00757   result.x = \_mm\_load\_si128(reinterpret\_cast<const \_\_m128i*>(from));
00758   \textcolor{keywordflow}{return} result;
00759 \}
00760 
00761 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8h ploadu<Packet8h>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
00762   Packet8h result;
00763   result.x = \_mm\_loadu\_si128(reinterpret\_cast<const \_\_m128i*>(from));
00764   \textcolor{keywordflow}{return} result;
00765 \}
00766 
00767 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<Eigen::half>(\hyperlink{struct_eigen_1_1half}{Eigen::half}* to, \textcolor{keyword}{const} Packet8h& from) \{
00768   \_mm\_store\_si128(reinterpret\_cast<\_\_m128i*>(to), from.x);
00769 \}
00770 
00771 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<Eigen::half>(\hyperlink{struct_eigen_1_1half}{Eigen::half}* to, \textcolor{keyword}{const} Packet8h& from) 
      \{
00772   \_mm\_storeu\_si128(reinterpret\_cast<\_\_m128i*>(to), from.x);
00773 \}
00774 
00775 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8h
00776 ploadquad<Packet8h>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
00777   Packet8h result;
00778   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} a = from[0].x;
00779   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} b = from[1].x;
00780   result.x = \_mm\_set\_epi16(b, b, b, b, a, a, a, a);
00781   \textcolor{keywordflow}{return} result;
00782 \}
00783 
00784 EIGEN\_STRONG\_INLINE Packet8f half2float(\textcolor{keyword}{const} Packet8h& a) \{
00785 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_FP16\_C}
00786   \textcolor{keywordflow}{return} \_mm256\_cvtph\_ps(a.x);
00787 \textcolor{preprocessor}{#else}
00788   EIGEN\_ALIGN32 \hyperlink{struct_eigen_1_1half}{Eigen::half} aux[8];
00789   pstore(aux, a);
00790   \textcolor{keywordtype}{float} f0(aux[0]);
00791   \textcolor{keywordtype}{float} f1(aux[1]);
00792   \textcolor{keywordtype}{float} f2(aux[2]);
00793   \textcolor{keywordtype}{float} f3(aux[3]);
00794   \textcolor{keywordtype}{float} f4(aux[4]);
00795   \textcolor{keywordtype}{float} f5(aux[5]);
00796   \textcolor{keywordtype}{float} f6(aux[6]);
00797   \textcolor{keywordtype}{float} f7(aux[7]);
00798 
00799   \textcolor{keywordflow}{return} \_mm256\_set\_ps(f7, f6, f5, f4, f3, f2, f1, f0);
00800 \textcolor{preprocessor}{#endif}
00801 \}
00802 
00803 EIGEN\_STRONG\_INLINE Packet8h float2half(\textcolor{keyword}{const} Packet8f& a) \{
00804 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_FP16\_C}
00805   Packet8h result;
00806   result.x = \_mm256\_cvtps\_ph(a, \_MM\_FROUND\_TO\_NEAREST\_INT|\_MM\_FROUND\_NO\_EXC);
00807   \textcolor{keywordflow}{return} result;
00808 \textcolor{preprocessor}{#else}
00809   EIGEN\_ALIGN32 \textcolor{keywordtype}{float} aux[8];
00810   pstore(aux, a);
00811   \hyperlink{struct_eigen_1_1half}{Eigen::half} h0(aux[0]);
00812   \hyperlink{struct_eigen_1_1half}{Eigen::half} h1(aux[1]);
00813   \hyperlink{struct_eigen_1_1half}{Eigen::half} h2(aux[2]);
00814   \hyperlink{struct_eigen_1_1half}{Eigen::half} h3(aux[3]);
00815   \hyperlink{struct_eigen_1_1half}{Eigen::half} h4(aux[4]);
00816   \hyperlink{struct_eigen_1_1half}{Eigen::half} h5(aux[5]);
00817   \hyperlink{struct_eigen_1_1half}{Eigen::half} h6(aux[6]);
00818   \hyperlink{struct_eigen_1_1half}{Eigen::half} h7(aux[7]);
00819 
00820   Packet8h result;
00821   result.x = \_mm\_set\_epi16(h7.x, h6.x, h5.x, h4.x, h3.x, h2.x, h1.x, h0.x);
00822   \textcolor{keywordflow}{return} result;
00823 \textcolor{preprocessor}{#endif}
00824 \}
00825 
00826 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8h pconj(\textcolor{keyword}{const} Packet8h& a) \{ \textcolor{keywordflow}{return} a; \}
00827 
00828 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8h padd<Packet8h>(\textcolor{keyword}{const} Packet8h& a, \textcolor{keyword}{const} Packet8h& b) \{
00829   Packet8f af = half2float(a);
00830   Packet8f bf = half2float(b);
00831   Packet8f rf = padd(af, bf);
00832   \textcolor{keywordflow}{return} float2half(rf);
00833 \}
00834 
00835 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8h pmul<Packet8h>(\textcolor{keyword}{const} Packet8h& a, \textcolor{keyword}{const} Packet8h& b) \{
00836   Packet8f af = half2float(a);
00837   Packet8f bf = half2float(b);
00838   Packet8f rf = pmul(af, bf);
00839   \textcolor{keywordflow}{return} float2half(rf);
00840 \}
00841 
00842 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8h pgather<Eigen::half, Packet8h>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}* from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00843 \{
00844   Packet8h result;
00845   result.x = \_mm\_set\_epi16(from[7*stride].x, from[6*stride].x, from[5*stride].x, from[4*stride].x, from[3*
      stride].x, from[2*stride].x, from[1*stride].x, from[0*stride].x);
00846   \textcolor{keywordflow}{return} result;
00847 \}
00848 
00849 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pscatter<Eigen::half, Packet8h>(\hyperlink{struct_eigen_1_1half}{Eigen::half}* to, \textcolor{keyword}{const} 
      Packet8h& from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00850 \{
00851   EIGEN\_ALIGN32 \hyperlink{struct_eigen_1_1half}{Eigen::half} aux[8];
00852   pstore(aux, from);
00853   to[stride*0].x = aux[0].x;
00854   to[stride*1].x = aux[1].x;
00855   to[stride*2].x = aux[2].x;
00856   to[stride*3].x = aux[3].x;
00857   to[stride*4].x = aux[4].x;
00858   to[stride*5].x = aux[5].x;
00859   to[stride*6].x = aux[6].x;
00860   to[stride*7].x = aux[7].x;
00861 \}
00862 
00863 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} predux<Packet8h>(\textcolor{keyword}{const} Packet8h& a) \{
00864   Packet8f af = half2float(a);
00865   \textcolor{keywordtype}{float} reduced = predux<Packet8f>(af);
00866   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(reduced);
00867 \}
00868 
00869 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} predux\_max<Packet8h>(\textcolor{keyword}{const} Packet8h& a) \{
00870   Packet8f af = half2float(a);
00871   \textcolor{keywordtype}{float} reduced = predux\_max<Packet8f>(af);
00872   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(reduced);
00873 \}
00874 
00875 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} predux\_min<Packet8h>(\textcolor{keyword}{const} Packet8h& a) \{
00876   Packet8f af = half2float(a);
00877   \textcolor{keywordtype}{float} reduced = predux\_min<Packet8f>(af);
00878   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(reduced);
00879 \}
00880 
00881 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} predux\_mul<Packet8h>(\textcolor{keyword}{const} Packet8h& a) \{
00882   Packet8f af = half2float(a);
00883   \textcolor{keywordtype}{float} reduced = predux\_mul<Packet8f>(af);
00884   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(reduced);
00885 \}
00886 
00887 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00888 ptranspose(PacketBlock<Packet8h,8>& kernel) \{
00889   \_\_m128i a = kernel.packet[0].x;
00890   \_\_m128i b = kernel.packet[1].x;
00891   \_\_m128i c = kernel.packet[2].x;
00892   \_\_m128i d = kernel.packet[3].x;
00893   \_\_m128i e = kernel.packet[4].x;
00894   \_\_m128i f = kernel.packet[5].x;
00895   \_\_m128i g = kernel.packet[6].x;
00896   \_\_m128i h = kernel.packet[7].x;
00897 
00898   \_\_m128i a03b03 = \_mm\_unpacklo\_epi16(a, b);
00899   \_\_m128i c03d03 = \_mm\_unpacklo\_epi16(c, d);
00900   \_\_m128i e03f03 = \_mm\_unpacklo\_epi16(e, f);
00901   \_\_m128i g03h03 = \_mm\_unpacklo\_epi16(g, h);
00902   \_\_m128i a47b47 = \_mm\_unpackhi\_epi16(a, b);
00903   \_\_m128i c47d47 = \_mm\_unpackhi\_epi16(c, d);
00904   \_\_m128i e47f47 = \_mm\_unpackhi\_epi16(e, f);
00905   \_\_m128i g47h47 = \_mm\_unpackhi\_epi16(g, h);
00906 
00907   \_\_m128i a01b01c01d01 = \_mm\_unpacklo\_epi32(a03b03, c03d03);
00908   \_\_m128i a23b23c23d23 = \_mm\_unpackhi\_epi32(a03b03, c03d03);
00909   \_\_m128i e01f01g01h01 = \_mm\_unpacklo\_epi32(e03f03, g03h03);
00910   \_\_m128i e23f23g23h23 = \_mm\_unpackhi\_epi32(e03f03, g03h03);
00911   \_\_m128i a45b45c45d45 = \_mm\_unpacklo\_epi32(a47b47, c47d47);
00912   \_\_m128i a67b67c67d67 = \_mm\_unpackhi\_epi32(a47b47, c47d47);
00913   \_\_m128i e45f45g45h45 = \_mm\_unpacklo\_epi32(e47f47, g47h47);
00914   \_\_m128i e67f67g67h67 = \_mm\_unpackhi\_epi32(e47f47, g47h47);
00915 
00916   \_\_m128i a0b0c0d0e0f0g0h0 = \_mm\_unpacklo\_epi64(a01b01c01d01, e01f01g01h01);
00917   \_\_m128i a1b1c1d1e1f1g1h1 = \_mm\_unpackhi\_epi64(a01b01c01d01, e01f01g01h01);
00918   \_\_m128i a2b2c2d2e2f2g2h2 = \_mm\_unpacklo\_epi64(a23b23c23d23, e23f23g23h23);
00919   \_\_m128i a3b3c3d3e3f3g3h3 = \_mm\_unpackhi\_epi64(a23b23c23d23, e23f23g23h23);
00920   \_\_m128i a4b4c4d4e4f4g4h4 = \_mm\_unpacklo\_epi64(a45b45c45d45, e45f45g45h45);
00921   \_\_m128i a5b5c5d5e5f5g5h5 = \_mm\_unpackhi\_epi64(a45b45c45d45, e45f45g45h45);
00922   \_\_m128i a6b6c6d6e6f6g6h6 = \_mm\_unpacklo\_epi64(a67b67c67d67, e67f67g67h67);
00923   \_\_m128i a7b7c7d7e7f7g7h7 = \_mm\_unpackhi\_epi64(a67b67c67d67, e67f67g67h67);
00924 
00925   kernel.packet[0].x = a0b0c0d0e0f0g0h0;
00926   kernel.packet[1].x = a1b1c1d1e1f1g1h1;
00927   kernel.packet[2].x = a2b2c2d2e2f2g2h2;
00928   kernel.packet[3].x = a3b3c3d3e3f3g3h3;
00929   kernel.packet[4].x = a4b4c4d4e4f4g4h4;
00930   kernel.packet[5].x = a5b5c5d5e5f5g5h5;
00931   kernel.packet[6].x = a6b6c6d6e6f6g6h6;
00932   kernel.packet[7].x = a7b7c7d7e7f7g7h7;
00933 \}
00934 
00935 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
00936 ptranspose(PacketBlock<Packet8h,4>& kernel) \{
00937   EIGEN\_ALIGN32 \hyperlink{struct_eigen_1_1half}{Eigen::half} in[4][8];
00938   pstore<Eigen::half>(in[0], kernel.packet[0]);
00939   pstore<Eigen::half>(in[1], kernel.packet[1]);
00940   pstore<Eigen::half>(in[2], kernel.packet[2]);
00941   pstore<Eigen::half>(in[3], kernel.packet[3]);
00942 
00943   EIGEN\_ALIGN32 \hyperlink{struct_eigen_1_1half}{Eigen::half} out[4][8];
00944 
00945   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; ++i) \{
00946     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 4; ++j) \{
00947       out[i][j] = in[j][2*i];
00948     \}
00949     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 4; ++j) \{
00950       out[i][j+4] = in[j][2*i+1];
00951     \}
00952   \}
00953 
00954   kernel.packet[0] = pload<Packet8h>(out[0]);
00955   kernel.packet[1] = pload<Packet8h>(out[1]);
00956   kernel.packet[2] = pload<Packet8h>(out[2]);
00957   kernel.packet[3] = pload<Packet8h>(out[3]);
00958 \}
00959 
00960 
00961 \textcolor{comment}{// Disable the following code since it's broken on too many platforms / compilers.}
00962 \textcolor{comment}{//#elif defined(EIGEN\_VECTORIZE\_SSE) && (!EIGEN\_ARCH\_x86\_64) && (!EIGEN\_COMP\_MSVC)}
00963 \textcolor{preprocessor}{#elif 0}
00964 
00965 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{
00966   \_\_m64 x;
00967 \} Packet4h;
00968 
00969 
00970 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<Packet4h> \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00971 
00972 \textcolor{keyword}{template} <>
00973 \textcolor{keyword}{struct }packet\_traits<\hyperlink{namespace_eigen}{Eigen}::half> : default\_packet\_traits \{
00974   \textcolor{keyword}{typedef} Packet4h type;
00975   \textcolor{comment}{// There is no half-size packet for Packet4h.}
00976   \textcolor{keyword}{typedef} Packet4h half;
00977   \textcolor{keyword}{enum} \{
00978     Vectorizable = 1,
00979     AlignedOnScalar = 1,
00980     size = 4,
00981     HasHalfPacket = 0,
00982     HasAdd    = 0,
00983     HasSub    = 0,
00984     HasMul    = 0,
00985     HasNegate = 0,
00986     HasAbs    = 0,
00987     HasAbs2   = 0,
00988     HasMin    = 0,
00989     HasMax    = 0,
00990     HasConj   = 0,
00991     HasSetLinear = 0,
00992     HasDiv = 0,
00993     HasSqrt = 0,
00994     HasRsqrt = 0,
00995     HasExp = 0,
00996     HasLog = 0,
00997     HasBlend = 0
00998   \};
00999 \};
01000 
01001 
01002 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet4h> \{ \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1half}{Eigen::half} type; \textcolor{keyword}{enum} \{size=4, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet4h half; \};
01003 
01004 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4h pset1<Packet4h>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}& from) \{
01005   Packet4h result;
01006   result.x = \_mm\_set1\_pi16(from.x);
01007   \textcolor{keywordflow}{return} result;
01008 \}
01009 
01010 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} pfirst<Packet4h>(\textcolor{keyword}{const} Packet4h& from) \{
01011   \textcolor{keywordflow}{return} half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(\_mm\_cvtsi64\_si32(from.x)));
01012 \}
01013 
01014 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4h pconj(\textcolor{keyword}{const} Packet4h& a) \{ \textcolor{keywordflow}{return} a; \}
01015 
01016 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4h padd<Packet4h>(\textcolor{keyword}{const} Packet4h& a, \textcolor{keyword}{const} Packet4h& b) \{
01017   \_\_int64\_t a64 = \_mm\_cvtm64\_si64(a.x);
01018   \_\_int64\_t b64 = \_mm\_cvtm64\_si64(b.x);
01019 
01020   \hyperlink{struct_eigen_1_1half}{Eigen::half} h[4];
01021 
01022   \hyperlink{struct_eigen_1_1half}{Eigen::half} ha = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(a64));
01023   \hyperlink{struct_eigen_1_1half}{Eigen::half} hb = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(b64));
01024   h[0] = ha + hb;
01025   ha = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(a64 >> 16));
01026   hb = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(b64 >> 16));
01027   h[1] = ha + hb;
01028   ha = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(a64 >> 32));
01029   hb = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(b64 >> 32));
01030   h[2] = ha + hb;
01031   ha = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(a64 >> 48));
01032   hb = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(b64 >> 48));
01033   h[3] = ha + hb;
01034   Packet4h result;
01035   result.x = \_mm\_set\_pi16(h[3].x, h[2].x, h[1].x, h[0].x);
01036   \textcolor{keywordflow}{return} result;
01037 \}
01038 
01039 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4h pmul<Packet4h>(\textcolor{keyword}{const} Packet4h& a, \textcolor{keyword}{const} Packet4h& b) \{
01040   \_\_int64\_t a64 = \_mm\_cvtm64\_si64(a.x);
01041   \_\_int64\_t b64 = \_mm\_cvtm64\_si64(b.x);
01042 
01043   \hyperlink{struct_eigen_1_1half}{Eigen::half} h[4];
01044 
01045   \hyperlink{struct_eigen_1_1half}{Eigen::half} ha = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(a64));
01046   \hyperlink{struct_eigen_1_1half}{Eigen::half} hb = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(b64));
01047   h[0] = ha * hb;
01048   ha = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(a64 >> 16));
01049   hb = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(b64 >> 16));
01050   h[1] = ha * hb;
01051   ha = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(a64 >> 32));
01052   hb = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(b64 >> 32));
01053   h[2] = ha * hb;
01054   ha = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(a64 >> 48));
01055   hb = half\_impl::raw\_uint16\_to\_half(static\_cast<unsigned short>(b64 >> 48));
01056   h[3] = ha * hb;
01057   Packet4h result;
01058   result.x = \_mm\_set\_pi16(h[3].x, h[2].x, h[1].x, h[0].x);
01059   \textcolor{keywordflow}{return} result;
01060 \}
01061 
01062 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4h pload<Packet4h>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
01063   Packet4h result;
01064   result.x = \_mm\_cvtsi64\_m64(*reinterpret\_cast<const \_\_int64\_t*>(from));
01065   \textcolor{keywordflow}{return} result;
01066 \}
01067 
01068 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4h ploadu<Packet4h>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
01069   Packet4h result;
01070   result.x = \_mm\_cvtsi64\_m64(*reinterpret\_cast<const \_\_int64\_t*>(from));
01071   \textcolor{keywordflow}{return} result;
01072 \}
01073 
01074 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<Eigen::half>(\hyperlink{struct_eigen_1_1half}{Eigen::half}* to, \textcolor{keyword}{const} Packet4h& from) \{
01075   \_\_int64\_t r = \_mm\_cvtm64\_si64(from.x);
01076   *(\textcolor{keyword}{reinterpret\_cast<}\_\_int64\_t*\textcolor{keyword}{>}(to)) = r;
01077 \}
01078 
01079 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<Eigen::half>(\hyperlink{struct_eigen_1_1half}{Eigen::half}* to, \textcolor{keyword}{const} Packet4h& from) 
      \{
01080   \_\_int64\_t r = \_mm\_cvtm64\_si64(from.x);
01081   *(\textcolor{keyword}{reinterpret\_cast<}\_\_int64\_t*\textcolor{keyword}{>}(to)) = r;
01082 \}
01083 
01084 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4h
01085 ploadquad<Packet4h>(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}* from) \{
01086   \textcolor{keywordflow}{return} pset1<Packet4h>(*from);
01087 \}
01088 
01089 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4h pgather<Eigen::half, Packet4h>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}* from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
01090 \{
01091   Packet4h result;
01092   result.x = \_mm\_set\_pi16(from[3*stride].x, from[2*stride].x, from[1*stride].x, from[0*stride].x);
01093   \textcolor{keywordflow}{return} result;
01094 \}
01095 
01096 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pscatter<Eigen::half, Packet4h>(\hyperlink{struct_eigen_1_1half}{Eigen::half}* to, \textcolor{keyword}{const} 
      Packet4h& from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
01097 \{
01098   \_\_int64\_t a = \_mm\_cvtm64\_si64(from.x);
01099   to[stride*0].x = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}\textcolor{keyword}{>}(a);
01100   to[stride*1].x = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}\textcolor{keyword}{>}(a >> 16);
01101   to[stride*2].x = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}\textcolor{keyword}{>}(a >> 32);
01102   to[stride*3].x = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}\textcolor{keyword}{>}(a >> 48);
01103 \}
01104 
01105 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void}
01106 ptranspose(PacketBlock<Packet4h,4>& kernel) \{
01107   \_\_m64 T0 = \_mm\_unpacklo\_pi16(kernel.packet[0].x, kernel.packet[1].x);
01108   \_\_m64 T1 = \_mm\_unpacklo\_pi16(kernel.packet[2].x, kernel.packet[3].x);
01109   \_\_m64 T2 = \_mm\_unpackhi\_pi16(kernel.packet[0].x, kernel.packet[1].x);
01110   \_\_m64 T3 = \_mm\_unpackhi\_pi16(kernel.packet[2].x, kernel.packet[3].x);
01111 
01112   kernel.packet[0].x = \_mm\_unpacklo\_pi32(T0, T1);
01113   kernel.packet[1].x = \_mm\_unpackhi\_pi32(T0, T1);
01114   kernel.packet[2].x = \_mm\_unpacklo\_pi32(T2, T3);
01115   kernel.packet[3].x = \_mm\_unpackhi\_pi32(T2, T3);
01116 \}
01117 
01118 \textcolor{preprocessor}{#endif}
01119 
01120 \}
01121 \}
01122 
01123 \textcolor{preprocessor}{#endif // EIGEN\_PACKET\_MATH\_HALF\_CUDA\_H}
\end{DoxyCode}
