\hypertarget{eigen_2test_2main_8h_source}{}\section{eigen/test/main.h}
\label{eigen_2test_2main_8h_source}\index{main.\+h@{main.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#include <cstdlib>}
00012 \textcolor{preprocessor}{#include <cerrno>}
00013 \textcolor{preprocessor}{#include <ctime>}
00014 \textcolor{preprocessor}{#include <iostream>}
00015 \textcolor{preprocessor}{#include <fstream>}
00016 \textcolor{preprocessor}{#include <string>}
00017 \textcolor{preprocessor}{#include <sstream>}
00018 \textcolor{preprocessor}{#include <vector>}
00019 \textcolor{preprocessor}{#include <typeinfo>}
00020 
00021 \textcolor{comment}{// The following includes of STL headers have to be done \_before\_ the}
00022 \textcolor{comment}{// definition of macros min() and max().  The reason is that many STL}
00023 \textcolor{comment}{// implementations will not work properly as the min and max symbols collide}
00024 \textcolor{comment}{// with the STL functions std:min() and std::max().  The STL headers may check}
00025 \textcolor{comment}{// for the macro definition of min/max and issue a warning or undefine the}
00026 \textcolor{comment}{// macros.}
00027 \textcolor{comment}{//}
00028 \textcolor{comment}{// Still, Windows defines min() and max() in windef.h as part of the regular}
00029 \textcolor{comment}{// Windows system interfaces and many other Windows APIs depend on these}
00030 \textcolor{comment}{// macros being available.  To prevent the macro expansion of min/max and to}
00031 \textcolor{comment}{// make Eigen compatible with the Windows environment all function calls of}
00032 \textcolor{comment}{// std::min() and std::max() have to be written with parenthesis around the}
00033 \textcolor{comment}{// function name.}
00034 \textcolor{comment}{//}
00035 \textcolor{comment}{// All STL headers used by Eigen should be included here.  Because main.h is}
00036 \textcolor{comment}{// included before any Eigen header and because the STL headers are guarded}
00037 \textcolor{comment}{// against multiple inclusions, no STL header will see our own min/max macro}
00038 \textcolor{comment}{// definitions.}
00039 \textcolor{preprocessor}{#include <limits>}
00040 \textcolor{preprocessor}{#include <algorithm>}
00041 \textcolor{preprocessor}{#include <complex>}
00042 \textcolor{preprocessor}{#include <deque>}
00043 \textcolor{preprocessor}{#include <queue>}
00044 \textcolor{preprocessor}{#include <cassert>}
00045 \textcolor{preprocessor}{#include <list>}
00046 \textcolor{preprocessor}{#if \_\_cplusplus >= 201103L}
00047 \textcolor{preprocessor}{#include <random>}
00048 \textcolor{preprocessor}{#ifdef EIGEN\_USE\_THREADS}
00049 \textcolor{preprocessor}{#include <future>}
00050 \textcolor{preprocessor}{#endif}
00051 \textcolor{preprocessor}{#endif}
00052 
00053 \textcolor{comment}{// To test that all calls from Eigen code to std::min() and std::max() are}
00054 \textcolor{comment}{// protected by parenthesis against macro expansion, the min()/max() macros}
00055 \textcolor{comment}{// are defined here and any not-parenthesized min/max call will cause a}
00056 \textcolor{comment}{// compiler error.}
00057 \textcolor{preprocessor}{#define min(A,B) please\_protect\_your\_min\_with\_parentheses}
00058 \textcolor{preprocessor}{#define max(A,B) please\_protect\_your\_max\_with\_parentheses}
00059 \textcolor{preprocessor}{#define isnan(X) please\_protect\_your\_isnan\_with\_parentheses}
00060 \textcolor{preprocessor}{#define isinf(X) please\_protect\_your\_isinf\_with\_parentheses}
00061 \textcolor{preprocessor}{#define isfinite(X) please\_protect\_your\_isfinite\_with\_parentheses}
00062 \textcolor{preprocessor}{#ifdef M\_PI}
00063 \textcolor{preprocessor}{#undef M\_PI}
00064 \textcolor{preprocessor}{#endif}
00065 \textcolor{preprocessor}{#define M\_PI please\_use\_EIGEN\_PI\_instead\_of\_M\_PI}
00066 
00067 \textcolor{preprocessor}{#define FORBIDDEN\_IDENTIFIER (this\_identifier\_is\_forbidden\_to\_avoid\_clashes)
       this\_identifier\_is\_forbidden\_to\_avoid\_clashes}
00068 \textcolor{comment}{// B0 is defined in POSIX header termios.h}
00069 \textcolor{preprocessor}{#define B0 FORBIDDEN\_IDENTIFIER}
00070 
00071 \textcolor{comment}{// Unit tests calling Eigen's blas library must preserve the default blocking size}
00072 \textcolor{comment}{// to avoid troubles.}
00073 \textcolor{preprocessor}{#ifndef EIGEN\_NO\_DEBUG\_SMALL\_PRODUCT\_BLOCKS}
00074 \textcolor{preprocessor}{#define EIGEN\_DEBUG\_SMALL\_PRODUCT\_BLOCKS}
00075 \textcolor{preprocessor}{#endif}
00076 
00077 \textcolor{comment}{// shuts down ICC's remark #593: variable "XXX" was set but never used}
00078 \textcolor{preprocessor}{#define TEST\_SET\_BUT\_UNUSED\_VARIABLE(X) EIGEN\_UNUSED\_VARIABLE(X)}
00079 
00080 \textcolor{preprocessor}{#ifdef TEST\_ENABLE\_TEMPORARY\_TRACKING}
00081 
00082 \textcolor{keyword}{static} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} nb\_temporaries;
00083 \textcolor{keyword}{static} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} nb\_temporaries\_on\_assert = -1;
00084 
00085 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} on\_temporary\_creation(\textcolor{keywordtype}{long} \textcolor{keywordtype}{int} size) \{
00086   \textcolor{comment}{// here's a great place to set a breakpoint when debugging failures in this test!}
00087   \textcolor{keywordflow}{if}(size!=0) nb\_temporaries++;
00088   \textcolor{keywordflow}{if}(nb\_temporaries\_on\_assert>0) assert(nb\_temporaries<nb\_temporaries\_on\_assert);
00089 \}
00090 
00091 \textcolor{preprocessor}{#define EIGEN\_DENSE\_STORAGE\_CTOR\_PLUGIN \{ on\_temporary\_creation(size); \}}
00092 
00093 \textcolor{preprocessor}{#define VERIFY\_EVALUATION\_COUNT(XPR,N) \{\(\backslash\)}
00094 \textcolor{preprocessor}{    nb\_temporaries = 0; \(\backslash\)}
00095 \textcolor{preprocessor}{    XPR; \(\backslash\)}
00096 \textcolor{preprocessor}{    if(nb\_temporaries!=N) \{ std::cerr << "nb\_temporaries == " << nb\_temporaries << "\(\backslash\)n"; \}\(\backslash\)}
00097 \textcolor{preprocessor}{    VERIFY( (#XPR) && nb\_temporaries==N ); \(\backslash\)}
00098 \textcolor{preprocessor}{  \}}
00099   
00100 \textcolor{preprocessor}{#endif}
00101 
00102 \textcolor{comment}{// the following file is automatically generated by cmake}
00103 \textcolor{preprocessor}{#include "split\_test\_helper.h"}
00104 
00105 \textcolor{preprocessor}{#ifdef NDEBUG}
00106 \textcolor{preprocessor}{#undef NDEBUG}
00107 \textcolor{preprocessor}{#endif}
00108 
00109 \textcolor{comment}{// On windows CE, NDEBUG is automatically defined <assert.h> if NDEBUG is not defined.}
00110 \textcolor{preprocessor}{#ifndef DEBUG}
00111 \textcolor{preprocessor}{#define DEBUG}
00112 \textcolor{preprocessor}{#endif}
00113 
00114 \textcolor{comment}{// bounds integer values for AltiVec}
00115 \textcolor{preprocessor}{#if defined(\_\_ALTIVEC\_\_) || defined(\_\_VSX\_\_)}
00116 \textcolor{preprocessor}{#define EIGEN\_MAKING\_DOCS}
00117 \textcolor{preprocessor}{#endif}
00118 
00119 \textcolor{preprocessor}{#ifndef EIGEN\_TEST\_FUNC}
00120 \textcolor{preprocessor}{#error EIGEN\_TEST\_FUNC must be defined}
00121 \textcolor{preprocessor}{#endif}
00122 
00123 \textcolor{preprocessor}{#define DEFAULT\_REPEAT 10}
00124 
00125 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen}
00126 \{
00127   \textcolor{keyword}{static} std::vector<std::string> g\_test\_stack;
00128   \textcolor{comment}{// level == 0 <=> abort if test fail}
00129   \textcolor{comment}{// level >= 1 <=> warning message to std::cerr if test fail}
00130   \textcolor{keyword}{static} \textcolor{keywordtype}{int} g\_test\_level = 0;
00131   \textcolor{keyword}{static} \textcolor{keywordtype}{int} g\_repeat;
00132   \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} g\_seed;
00133   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} g\_has\_set\_repeat, g\_has\_set\_seed;
00134 \}
00135 
00136 \textcolor{preprocessor}{#define TRACK std::cerr << \_\_FILE\_\_ << " " << \_\_LINE\_\_ << std::endl}
00137 \textcolor{comment}{// #define TRACK while()}
00138 
00139 \textcolor{preprocessor}{#define EI\_PP\_MAKE\_STRING2(S) #S}
00140 \textcolor{preprocessor}{#define EI\_PP\_MAKE\_STRING(S) EI\_PP\_MAKE\_STRING2(S)}
00141 
00142 \textcolor{preprocessor}{#define EIGEN\_DEFAULT\_IO\_FORMAT IOFormat(4, 0, "  ", "\(\backslash\)n", "", "", "", "")}
00143 
00144 \textcolor{preprocessor}{#if (defined(\_CPPUNWIND) || defined(\_\_EXCEPTIONS)) && !defined(\_\_CUDA\_ARCH\_\_)}
00145 \textcolor{preprocessor}{  #define EIGEN\_EXCEPTIONS}
00146 \textcolor{preprocessor}{#endif}
00147 
00148 \textcolor{preprocessor}{#ifndef EIGEN\_NO\_ASSERTION\_CHECKING}
00149 
00150   \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen}
00151   \{
00152     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} should\_raise\_an\_assert = \textcolor{keyword}{false};
00153 
00154     \textcolor{comment}{// Used to avoid to raise two exceptions at a time in which}
00155     \textcolor{comment}{// case the exception is not properly caught.}
00156     \textcolor{comment}{// This may happen when a second exceptions is triggered in a destructor.}
00157     \textcolor{keyword}{static} \textcolor{keywordtype}{bool} no\_more\_assert = \textcolor{keyword}{false};
00158     \textcolor{keyword}{static} \textcolor{keywordtype}{bool} report\_on\_cerr\_on\_assert\_failure = \textcolor{keyword}{true};
00159 
\Hypertarget{eigen_2test_2main_8h_source_l00160}\hyperlink{struct_eigen_1_1eigen__assert__exception}{00160}     \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1eigen__assert__exception}{eigen\_assert\_exception}
00161     \{
00162       \hyperlink{struct_eigen_1_1eigen__assert__exception}{eigen\_assert\_exception}(\textcolor{keywordtype}{void}) \{\}
00163       ~\hyperlink{struct_eigen_1_1eigen__assert__exception}{eigen\_assert\_exception}() \{ Eigen::no\_more\_assert = \textcolor{keyword}{false}; \}
00164     \};
00165   \}
00166   \textcolor{comment}{// If EIGEN\_DEBUG\_ASSERTS is defined and if no assertion is triggered while}
00167   \textcolor{comment}{// one should have been, then the list of excecuted assertions is printed out.}
00168   \textcolor{comment}{//}
00169   \textcolor{comment}{// EIGEN\_DEBUG\_ASSERTS is not enabled by default as it}
00170   \textcolor{comment}{// significantly increases the compilation time}
00171   \textcolor{comment}{// and might even introduce side effects that would hide}
00172   \textcolor{comment}{// some memory errors.}
00173 \textcolor{preprocessor}{  #ifdef EIGEN\_DEBUG\_ASSERTS}
00174 
00175     \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen}
00176     \{
00177       \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal}
00178       \{
00179         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} push\_assert = \textcolor{keyword}{false};
00180       \}
00181       \textcolor{keyword}{static} std::vector<std::string> eigen\_assert\_list;
00182     \}
00183 \textcolor{preprocessor}{    #define eigen\_assert(a)                       \(\backslash\)}
00184 \textcolor{preprocessor}{      if( (!(a)) && (!no\_more\_assert) )     \(\backslash\)}
00185 \textcolor{preprocessor}{      \{ \(\backslash\)}
00186 \textcolor{preprocessor}{        if(report\_on\_cerr\_on\_assert\_failure) \(\backslash\)}
00187 \textcolor{preprocessor}{          std::cerr <<  #a << " " \_\_FILE\_\_ << "(" << \_\_LINE\_\_ << ")\(\backslash\)n"; \(\backslash\)}
00188 \textcolor{preprocessor}{        Eigen::no\_more\_assert = true;       \(\backslash\)}
00189 \textcolor{preprocessor}{        EIGEN\_THROW\_X(Eigen::eigen\_assert\_exception()); \(\backslash\)}
00190 \textcolor{preprocessor}{      \}                                     \(\backslash\)}
00191 \textcolor{preprocessor}{      else if (Eigen::internal::push\_assert)       \(\backslash\)}
00192 \textcolor{preprocessor}{      \{                                     \(\backslash\)}
00193 \textcolor{preprocessor}{        eigen\_assert\_list.push\_back(std::string(EI\_PP\_MAKE\_STRING(\_\_FILE\_\_) " ("
       EI\_PP\_MAKE\_STRING(\_\_LINE\_\_) ") : " #a) ); \(\backslash\)}
00194 \textcolor{preprocessor}{      \}}
00195 
00196 \textcolor{preprocessor}{    #ifdef EIGEN\_EXCEPTIONS}
00197 \textcolor{preprocessor}{    #define VERIFY\_RAISES\_ASSERT(a)                                                   \(\backslash\)}
00198 \textcolor{preprocessor}{      \{                                                                               \(\backslash\)}
00199 \textcolor{preprocessor}{        Eigen::no\_more\_assert = false;                                                \(\backslash\)}
00200 \textcolor{preprocessor}{        Eigen::eigen\_assert\_list.clear();                                             \(\backslash\)}
00201 \textcolor{preprocessor}{        Eigen::internal::push\_assert = true;                                          \(\backslash\)}
00202 \textcolor{preprocessor}{        Eigen::report\_on\_cerr\_on\_assert\_failure = false;                              \(\backslash\)}
00203 \textcolor{preprocessor}{        try \{                                                                         \(\backslash\)}
00204 \textcolor{preprocessor}{          a;                                                                          \(\backslash\)}
00205 \textcolor{preprocessor}{          std::cerr << "One of the following asserts should have been triggered:\(\backslash\)n";  \(\backslash\)}
00206 \textcolor{preprocessor}{          for (uint ai=0 ; ai<eigen\_assert\_list.size() ; ++ai)                        \(\backslash\)}
00207 \textcolor{preprocessor}{            std::cerr << "  " << eigen\_assert\_list[ai] << "\(\backslash\)n";                       \(\backslash\)}
00208 \textcolor{preprocessor}{          VERIFY(Eigen::should\_raise\_an\_assert && # a);                               \(\backslash\)}
00209 \textcolor{preprocessor}{        \} catch (Eigen::eigen\_assert\_exception) \{                                     \(\backslash\)}
00210 \textcolor{preprocessor}{          Eigen::internal::push\_assert = false; VERIFY(true);                         \(\backslash\)}
00211 \textcolor{preprocessor}{        \}                                                                             \(\backslash\)}
00212 \textcolor{preprocessor}{        Eigen::report\_on\_cerr\_on\_assert\_failure = true;                               \(\backslash\)}
00213 \textcolor{preprocessor}{        Eigen::internal::push\_assert = false;                                         \(\backslash\)}
00214 \textcolor{preprocessor}{      \}}
00215 \textcolor{preprocessor}{    #endif //EIGEN\_EXCEPTIONS}
00216 
00217 \textcolor{preprocessor}{  #elif !defined(\_\_CUDACC\_\_) // EIGEN\_DEBUG\_ASSERTS}
00218     \textcolor{comment}{// see bug 89. The copy\_bool here is working around a bug in gcc <= 4.3}
00219 \textcolor{preprocessor}{    #define eigen\_assert(a) \(\backslash\)}
00220 \textcolor{preprocessor}{      if( (!Eigen::internal::copy\_bool(a)) && (!no\_more\_assert) )\(\backslash\)}
00221 \textcolor{preprocessor}{      \{                                       \(\backslash\)}
00222 \textcolor{preprocessor}{        Eigen::no\_more\_assert = true;         \(\backslash\)}
00223 \textcolor{preprocessor}{        if(report\_on\_cerr\_on\_assert\_failure)  \(\backslash\)}
00224 \textcolor{preprocessor}{          eigen\_plain\_assert(a);              \(\backslash\)}
00225 \textcolor{preprocessor}{        else                                  \(\backslash\)}
00226 \textcolor{preprocessor}{          EIGEN\_THROW\_X(Eigen::eigen\_assert\_exception()); \(\backslash\)}
00227 \textcolor{preprocessor}{      \}}
00228 \textcolor{preprocessor}{    #ifdef EIGEN\_EXCEPTIONS}
00229 \textcolor{preprocessor}{      #define VERIFY\_RAISES\_ASSERT(a) \{                           \(\backslash\)}
00230 \textcolor{preprocessor}{        Eigen::no\_more\_assert = false;                            \(\backslash\)}
00231 \textcolor{preprocessor}{        Eigen::report\_on\_cerr\_on\_assert\_failure = false;          \(\backslash\)}
00232 \textcolor{preprocessor}{        try \{                                                     \(\backslash\)}
00233 \textcolor{preprocessor}{          a;                                                      \(\backslash\)}
00234 \textcolor{preprocessor}{          VERIFY(Eigen::should\_raise\_an\_assert && # a);           \(\backslash\)}
00235 \textcolor{preprocessor}{        \}                                                         \(\backslash\)}
00236 \textcolor{preprocessor}{        catch (Eigen::eigen\_assert\_exception&) \{ VERIFY(true); \}  \(\backslash\)}
00237 \textcolor{preprocessor}{        Eigen::report\_on\_cerr\_on\_assert\_failure = true;           \(\backslash\)}
00238 \textcolor{preprocessor}{      \}}
00239 \textcolor{preprocessor}{    #endif //EIGEN\_EXCEPTIONS}
00240 \textcolor{preprocessor}{  #endif // EIGEN\_DEBUG\_ASSERTS}
00241 
00242 \textcolor{preprocessor}{#ifndef VERIFY\_RAISES\_ASSERT}
00243 \textcolor{preprocessor}{  #define VERIFY\_RAISES\_ASSERT(a) \(\backslash\)}
00244 \textcolor{preprocessor}{    std::cout << "Can't VERIFY\_RAISES\_ASSERT( " #a " ) with exceptions disabled\(\backslash\)n";}
00245 \textcolor{preprocessor}{#endif}
00246     
00247 \textcolor{preprocessor}{  #if !defined(\_\_CUDACC\_\_)}
00248 \textcolor{preprocessor}{  #define EIGEN\_USE\_CUSTOM\_ASSERT}
00249 \textcolor{preprocessor}{  #endif}
00250 
00251 \textcolor{preprocessor}{#else // EIGEN\_NO\_ASSERTION\_CHECKING}
00252 
00253 \textcolor{preprocessor}{  #define VERIFY\_RAISES\_ASSERT(a) \{\}}
00254 
00255 \textcolor{preprocessor}{#endif // EIGEN\_NO\_ASSERTION\_CHECKING}
00256 
00257 
00258 \textcolor{preprocessor}{#define EIGEN\_INTERNAL\_DEBUGGING}
00259 \textcolor{preprocessor}{#include <Eigen/QR>} \textcolor{comment}{// required for createRandomPIMatrixOfRank}
00260 
00261 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} verify\_impl(\textcolor{keywordtype}{bool} condition, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *testname, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\hyperlink{structfile}{file}, \textcolor{keywordtype}{int} line, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *
      condition\_as\_string)
00262 \{
00263   \textcolor{keywordflow}{if} (!condition)
00264   \{
00265     \textcolor{keywordflow}{if}(Eigen::g\_test\_level>0)
00266       std::cerr << \textcolor{stringliteral}{"WARNING: "};
00267     std::cerr << \textcolor{stringliteral}{"Test "} << testname << \textcolor{stringliteral}{" failed in "} << file << \textcolor{stringliteral}{" ("} << line << \textcolor{stringliteral}{")"}
00268       << std::endl << \textcolor{stringliteral}{"    "} << condition\_as\_string << std::endl;
00269     std::cerr << \textcolor{stringliteral}{"Stack:\(\backslash\)n"};
00270     \textcolor{keyword}{const} \textcolor{keywordtype}{int} test\_stack\_size = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Eigen::g\_test\_stack.size());
00271     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=test\_stack\_size-1; i>=0; --i)
00272       std::cerr << \textcolor{stringliteral}{"  - "} << Eigen::g\_test\_stack[i] << \textcolor{stringliteral}{"\(\backslash\)n"};
00273     std::cerr << \textcolor{stringliteral}{"\(\backslash\)n"};
00274     \textcolor{keywordflow}{if}(Eigen::g\_test\_level==0)
00275       abort();
00276   \}
00277 \}
00278 
00279 \textcolor{preprocessor}{#define VERIFY(a) ::verify\_impl(a, g\_test\_stack.back().c\_str(), \_\_FILE\_\_, \_\_LINE\_\_, EI\_PP\_MAKE\_STRING(a))}
00280 
00281 \textcolor{preprocessor}{#define VERIFY\_GE(a, b) ::verify\_impl(a >= b, g\_test\_stack.back().c\_str(), \_\_FILE\_\_, \_\_LINE\_\_,
       EI\_PP\_MAKE\_STRING(a >= b))}
00282 \textcolor{preprocessor}{#define VERIFY\_LE(a, b) ::verify\_impl(a <= b, g\_test\_stack.back().c\_str(), \_\_FILE\_\_, \_\_LINE\_\_,
       EI\_PP\_MAKE\_STRING(a <= b))}
00283 
00284 
00285 \textcolor{preprocessor}{#define VERIFY\_IS\_EQUAL(a, b) VERIFY(test\_is\_equal(a, b, true))}
00286 \textcolor{preprocessor}{#define VERIFY\_IS\_NOT\_EQUAL(a, b) VERIFY(test\_is\_equal(a, b, false))}
00287 \textcolor{preprocessor}{#define VERIFY\_IS\_APPROX(a, b) VERIFY(verifyIsApprox(a, b))}
00288 \textcolor{preprocessor}{#define VERIFY\_IS\_NOT\_APPROX(a, b) VERIFY(!test\_isApprox(a, b))}
00289 \textcolor{preprocessor}{#define VERIFY\_IS\_MUCH\_SMALLER\_THAN(a, b) VERIFY(test\_isMuchSmallerThan(a, b))}
00290 \textcolor{preprocessor}{#define VERIFY\_IS\_NOT\_MUCH\_SMALLER\_THAN(a, b) VERIFY(!test\_isMuchSmallerThan(a, b))}
00291 \textcolor{preprocessor}{#define VERIFY\_IS\_APPROX\_OR\_LESS\_THAN(a, b) VERIFY(test\_isApproxOrLessThan(a, b))}
00292 \textcolor{preprocessor}{#define VERIFY\_IS\_NOT\_APPROX\_OR\_LESS\_THAN(a, b) VERIFY(!test\_isApproxOrLessThan(a, b))}
00293 
00294 \textcolor{preprocessor}{#define VERIFY\_IS\_UNITARY(a) VERIFY(test\_isUnitary(a))}
00295 
00296 \textcolor{preprocessor}{#define CALL\_SUBTEST(FUNC) do \{ \(\backslash\)}
00297 \textcolor{preprocessor}{    g\_test\_stack.push\_back(EI\_PP\_MAKE\_STRING(FUNC)); \(\backslash\)}
00298 \textcolor{preprocessor}{    FUNC; \(\backslash\)}
00299 \textcolor{preprocessor}{    g\_test\_stack.pop\_back(); \(\backslash\)}
00300 \textcolor{preprocessor}{  \} while (0)}
00301 
00302 
00303 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00304 
00305 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{NumTraits<T>::Real} test\_precision() \{ \textcolor{keywordflow}{return} 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<T>::dummy\_precision}(); \}
00306 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{float} test\_precision<float>() \{ \textcolor{keywordflow}{return} 1e-3f; \}
00307 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{double} test\_precision<double>() \{ \textcolor{keywordflow}{return} 1e-6; \}
00308 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} test\_precision<long double>() \{ \textcolor{keywordflow}{return} 1e-6l; \}
00309 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{float} test\_precision<std::complex<float> >() \{ \textcolor{keywordflow}{return} test\_precision<float>(); \}
00310 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{double} test\_precision<std::complex<double> >() \{ \textcolor{keywordflow}{return} test\_precision<double>(); \}
00311 \textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} test\_precision<std::complex<long double> >() \{ \textcolor{keywordflow}{return} test\_precision<long
       double>(); \}
00312 
00313 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} \textcolor{keywordtype}{short}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{short}& b)
00314 \{ \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<short>()); \}
00315 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}& b)
00316 \{ \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<unsigned long>()); \}
00317 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}& b)
00318 \{ \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<unsigned int>()); \}
00319 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} \textcolor{keywordtype}{long}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{long}& b)
00320 \{ \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<long>()); \}
00321 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}& b)
00322 \{ \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<unsigned long>()); \}
00323 
00324 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} \textcolor{keywordtype}{int}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{int}& b)
00325 \{ \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<int>()); \}
00326 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isMuchSmallerThan(\textcolor{keyword}{const} \textcolor{keywordtype}{int}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{int}& b)
00327 \{ \textcolor{keywordflow}{return} internal::isMuchSmallerThan(a, b, test\_precision<int>()); \}
00328 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApproxOrLessThan(\textcolor{keyword}{const} \textcolor{keywordtype}{int}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{int}& b)
00329 \{ \textcolor{keywordflow}{return} internal::isApproxOrLessThan(a, b, test\_precision<int>()); \}
00330 
00331 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} \textcolor{keywordtype}{float}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{float}& b)
00332 \{ \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<float>()); \}
00333 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isMuchSmallerThan(\textcolor{keyword}{const} \textcolor{keywordtype}{float}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{float}& b)
00334 \{ \textcolor{keywordflow}{return} internal::isMuchSmallerThan(a, b, test\_precision<float>()); \}
00335 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApproxOrLessThan(\textcolor{keyword}{const} \textcolor{keywordtype}{float}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{float}& b)
00336 \{ \textcolor{keywordflow}{return} internal::isApproxOrLessThan(a, b, test\_precision<float>()); \}
00337 
00338 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& b)
00339 \{ \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<double>()); \}
00340 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isMuchSmallerThan(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& b)
00341 \{ \textcolor{keywordflow}{return} internal::isMuchSmallerThan(a, b, test\_precision<double>()); \}
00342 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApproxOrLessThan(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& b)
00343 \{ \textcolor{keywordflow}{return} internal::isApproxOrLessThan(a, b, test\_precision<double>()); \}
00344 
00345 \textcolor{preprocessor}{#ifndef EIGEN\_TEST\_NO\_COMPLEX}
00346 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} std::complex<float>& a, \textcolor{keyword}{const} std::complex<float>& b)
00347 \{ \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<std::complex<float> >()); \}
00348 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isMuchSmallerThan(\textcolor{keyword}{const} std::complex<float>& a, \textcolor{keyword}{const} std::complex<float>& b)
00349 \{ \textcolor{keywordflow}{return} internal::isMuchSmallerThan(a, b, test\_precision<std::complex<float> >()); \}
00350 
00351 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} std::complex<double>& a, \textcolor{keyword}{const} std::complex<double>& b)
00352 \{ \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<std::complex<double> >()); \}
00353 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isMuchSmallerThan(\textcolor{keyword}{const} std::complex<double>& a, \textcolor{keyword}{const} std::complex<double>& b)
00354 \{ \textcolor{keywordflow}{return} internal::isMuchSmallerThan(a, b, test\_precision<std::complex<double> >()); \}
00355 
00356 \textcolor{preprocessor}{#ifndef EIGEN\_TEST\_NO\_LONGDOUBLE}
00357 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} std::complex<long double>& a, \textcolor{keyword}{const} std::complex<long double>& b)
00358 \{ \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<std::complex<long double> >()); \}
00359 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isMuchSmallerThan(\textcolor{keyword}{const} std::complex<long double>& a, \textcolor{keyword}{const} std::complex<long double>& b)
00360 \{ \textcolor{keywordflow}{return} internal::isMuchSmallerThan(a, b, test\_precision<std::complex<long double> >()); \}
00361 \textcolor{preprocessor}{#endif}
00362 \textcolor{preprocessor}{#endif}
00363 
00364 \textcolor{preprocessor}{#ifndef EIGEN\_TEST\_NO\_LONGDOUBLE}
00365 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{double}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{double}& b)
00366 \{
00367     \textcolor{keywordtype}{bool} ret = internal::isApprox(a, b, test\_precision<long double>());
00368     \textcolor{keywordflow}{if} (!ret) std::cerr
00369         << std::endl << \textcolor{stringliteral}{"    actual   = "} << a
00370         << std::endl << \textcolor{stringliteral}{"    expected = "} << b << std::endl << std::endl;
00371     \textcolor{keywordflow}{return} ret;
00372 \}
00373 
00374 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isMuchSmallerThan(\textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{double}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{double}& b)
00375 \{ \textcolor{keywordflow}{return} internal::isMuchSmallerThan(a, b, test\_precision<long double>()); \}
00376 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApproxOrLessThan(\textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{double}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{double}& b)
00377 \{ \textcolor{keywordflow}{return} internal::isApproxOrLessThan(a, b, test\_precision<long double>()); \}
00378 \textcolor{preprocessor}{#endif // EIGEN\_TEST\_NO\_LONGDOUBLE}
00379 
00380 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{half}& a, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{half}& b)
00381 \{ \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<half>()); \}
00382 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isMuchSmallerThan(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{half}& a, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{half}& b)
00383 \{ \textcolor{keywordflow}{return} internal::isMuchSmallerThan(a, b, test\_precision<half>()); \}
00384 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApproxOrLessThan(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{half}& a, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{half}& b)
00385 \{ \textcolor{keywordflow}{return} internal::isApproxOrLessThan(a, b, test\_precision<half>()); \}
00386 
00387 \textcolor{comment}{// test\_relative\_error returns the relative difference between a and b as a real scalar as used in
       isApprox.}
00388 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1,\textcolor{keyword}{typename} T2>
00389 \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename T1::RealScalar>::NonInteger} 
      test\_relative\_error(\textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<T1>} &a, \textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<T2>} &b)
00390 \{
00391   \textcolor{keyword}{using} std::sqrt;
00392   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename T1::RealScalar>::NonInteger}
       RealScalar;
00393   \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<T1,2>::type} ea(a.
      \hyperlink{group___core___module_a324b16961a11d2ecfd2d1b7dd7946545}{derived}());
00394   \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<T2,2>::type} eb(b.
      \hyperlink{group___core___module_a324b16961a11d2ecfd2d1b7dd7946545}{derived}());
00395   \textcolor{keywordflow}{return} sqrt(RealScalar((ea-eb).cwiseAbs2().sum()) / RealScalar((std::min)(eb.cwiseAbs2().sum(),ea.
      cwiseAbs2().sum())));
00396 \}
00397 
00398 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1,\textcolor{keyword}{typename} T2>
00399 \textcolor{keyword}{typename} T1::RealScalar test\_relative\_error(\textcolor{keyword}{const} T1 &a, \textcolor{keyword}{const} T2 &b, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::Coefficients* = 0)
00400 \{
00401   \textcolor{keywordflow}{return} test\_relative\_error(a.coeffs(), b.coeffs());
00402 \}
00403 
00404 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1,\textcolor{keyword}{typename} T2>
00405 \textcolor{keyword}{typename} T1::Scalar test\_relative\_error(\textcolor{keyword}{const} T1 &a, \textcolor{keyword}{const} T2 &b, \textcolor{keyword}{const} \textcolor{keyword}{typename} T1::MatrixType* = 0)
00406 \{
00407   \textcolor{keywordflow}{return} test\_relative\_error(a.matrix(), b.matrix());
00408 \}
00409 
00410 \textcolor{keyword}{template}<\textcolor{keyword}{typename} S, \textcolor{keywordtype}{int} D>
00411 S test\_relative\_error(\textcolor{keyword}{const} \hyperlink{group___geometry___module_class_eigen_1_1_translation}{Translation<S,D>} &a, \textcolor{keyword}{const} 
      \hyperlink{group___geometry___module_class_eigen_1_1_translation}{Translation<S,D>} &b)
00412 \{
00413   \textcolor{keywordflow}{return} test\_relative\_error(a.vector(), b.vector());
00414 \}
00415 
00416 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keywordtype}{int} D, \textcolor{keywordtype}{int} O>
00417 S test\_relative\_error(\textcolor{keyword}{const} \hyperlink{group___geometry___module_class_eigen_1_1_parametrized_line}{ParametrizedLine<S,D,O>} &a, \textcolor{keyword}{const} 
      \hyperlink{group___geometry___module_class_eigen_1_1_parametrized_line}{ParametrizedLine<S,D,O>} &b)
00418 \{
00419   \textcolor{keywordflow}{return} (std::max)(test\_relative\_error(a.origin(), b.origin()), test\_relative\_error(a.origin(), b.origin()
      ));
00420 \}
00421 
00422 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keywordtype}{int} D>
00423 S test\_relative\_error(\textcolor{keyword}{const} \hyperlink{group___geometry___module_class_eigen_1_1_aligned_box}{AlignedBox<S,D>} &a, \textcolor{keyword}{const} 
      \hyperlink{group___geometry___module_class_eigen_1_1_aligned_box}{AlignedBox<S,D>} &b)
00424 \{
00425   \textcolor{keywordflow}{return} (std::max)(test\_relative\_error((a.\hyperlink{group___geometry___module_a4b23dedc65215a939c1794f83017c58d}{min})(), (b.\hyperlink{group___geometry___module_a4b23dedc65215a939c1794f83017c58d}{min})()), test\_relative\_error((a.
      \hyperlink{group___geometry___module_ad10b1fa3021f705e3104d09b8842c37e}{max})(), (b.\hyperlink{group___geometry___module_ad10b1fa3021f705e3104d09b8842c37e}{max})()));
00426 \}
00427 
00428 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase};
00429 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1,\textcolor{keyword}{typename} T2>
00430 \textcolor{keyword}{typename} T1::RealScalar test\_relative\_error(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<T1>} &a, \textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<T2>} &b)
00431 \{
00432   \textcolor{keywordflow}{return} test\_relative\_error(a,b.toDense());
00433 \}
00434 
00435 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase};
00436 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1,\textcolor{keyword}{typename} T2>
00437 \textcolor{keyword}{typename} T1::RealScalar test\_relative\_error(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<T1>} &a, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<T2>} &b)
00438 \{
00439   \textcolor{keywordflow}{return} test\_relative\_error(a.toDense(),b);
00440 \}
00441 
00442 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase};
00443 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1,\textcolor{keyword}{typename} T2>
00444 \textcolor{keyword}{typename} T1::RealScalar test\_relative\_error(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<T1>} &a, \textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<T2>} &b)
00445 \{
00446   \textcolor{keywordflow}{return} test\_relative\_error(a.toDense(),b.toDense());
00447 \}
00448 
00449 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1,\textcolor{keyword}{typename} T2>
00450 \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename NumTraits<T1>::Real}>::NonInteger 
      test\_relative\_error(\textcolor{keyword}{const} T1 &a, \textcolor{keyword}{const} T2 &b, \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1enable__if}{internal::enable\_if}<
      \hyperlink{struct_eigen_1_1internal_1_1is__arithmetic}{internal::is\_arithmetic}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{NumTraits<T1>::Real}>::value, T1>
      ::type* = 0)
00451 \{
00452   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<typename NumTraits<T1>::Real}>
      ::NonInteger RealScalar;
00453   \textcolor{keywordflow}{return} numext::sqrt(RealScalar(numext::abs2(a-b))/RealScalar((numext::mini)(numext::abs2(a),numext::abs2(
      b))));
00454 \}
00455 
00456 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00457 \hyperlink{group___sparse_core___module}{T} test\_relative\_error(\textcolor{keyword}{const} \hyperlink{group___geometry___module_class_eigen_1_1_rotation2_d}{Rotation2D<T>} &a, \textcolor{keyword}{const} \hyperlink{group___geometry___module_class_eigen_1_1_rotation2_d}{Rotation2D<T>} &b)
00458 \{
00459   \textcolor{keywordflow}{return} test\_relative\_error(a.\hyperlink{group___geometry___module_af34ab8da6bfe010ca66c8acafa239a6e}{angle}(), b.\hyperlink{group___geometry___module_af34ab8da6bfe010ca66c8acafa239a6e}{angle}());
00460 \}
00461 
00462 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00463 \hyperlink{group___sparse_core___module}{T} test\_relative\_error(\textcolor{keyword}{const} \hyperlink{group___geometry___module_class_eigen_1_1_angle_axis}{AngleAxis<T>} &a, \textcolor{keyword}{const} \hyperlink{group___geometry___module_class_eigen_1_1_angle_axis}{AngleAxis<T>} &b)
00464 \{
00465   \textcolor{keywordflow}{return} (std::max)(test\_relative\_error(a.\hyperlink{group___geometry___module_a83d3c08a73c111550b7e480d3ed043d4}{angle}(), b.\hyperlink{group___geometry___module_a83d3c08a73c111550b7e480d3ed043d4}{angle}()), test\_relative\_error(a.
      \hyperlink{group___geometry___module_ae40cc36c8dcd9977e1540d91a80696bb}{axis}(), b.\hyperlink{group___geometry___module_ae40cc36c8dcd9977e1540d91a80696bb}{axis}()));
00466 \}
00467 
00468 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Type1, \textcolor{keyword}{typename} Type2>
00469 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} Type1& a, \textcolor{keyword}{const} Type2& b, \textcolor{keyword}{typename} Type1::Scalar* = 0) \textcolor{comment}{// Enabled for
       Eigen's type only}
00470 \{
00471   \textcolor{keywordflow}{return} a.isApprox(b, test\_precision<typename Type1::Scalar>());
00472 \}
00473 
00474 \textcolor{comment}{// get\_test\_precision is a small wrapper to test\_precision allowing to return the scalar precision for
       either scalars or expressions}
00475 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00476 \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{NumTraits<typename T::Scalar>::Real} get\_test\_precision(\textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module}{T}&, \textcolor{keyword}{const} \textcolor{keyword}{typename} T::Scalar* = 0)
00477 \{
00478   \textcolor{keywordflow}{return} test\_precision<typename NumTraits<typename T::Scalar>::Real>();
00479 \}
00480 
00481 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00482 \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{NumTraits<T>::Real} get\_test\_precision(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}&,\textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1enable__if}{internal::enable\_if}<\hyperlink{struct_eigen_1_1internal_1_1is__arithmetic}{internal::is\_arithmetic}<\textcolor{keyword}{typename} 
      \hyperlink{group___sparse_core___module}{NumTraits<T>::Real}>::value, \hyperlink{group___sparse_core___module}{T}>::type* = 0)
00483 \{
00484   \textcolor{keywordflow}{return} test\_precision<typename NumTraits<T>::Real>();
00485 \}
00486 
00487 \textcolor{comment}{// verifyIsApprox is a wrapper to test\_isApprox that outputs the relative difference magnitude if the test
       fails.}
00488 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Type1, \textcolor{keyword}{typename} Type2>
00489 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} verifyIsApprox(\textcolor{keyword}{const} Type1& a, \textcolor{keyword}{const} Type2& b)
00490 \{
00491   \textcolor{keywordtype}{bool} ret = test\_isApprox(a,b);
00492   \textcolor{keywordflow}{if}(!ret)
00493   \{
00494     std::cerr << \textcolor{stringliteral}{"Difference too large wrt tolerance "} << get\_test\_precision(a)  << \textcolor{stringliteral}{", relative error is: "}
       << test\_relative\_error(a,b) << std::endl;
00495   \}
00496   \textcolor{keywordflow}{return} ret;
00497 \}
00498 
00499 \textcolor{comment}{// The idea behind this function is to compare the two scalars a and b where}
00500 \textcolor{comment}{// the scalar ref is a hint about the expected order of magnitude of a and b.}
00501 \textcolor{comment}{// WARNING: the scalar a and b must be positive}
00502 \textcolor{comment}{// Therefore, if for some reason a and b are very small compared to ref,}
00503 \textcolor{comment}{// we won't issue a false negative.}
00504 \textcolor{comment}{// This test could be: abs(a-b) <= eps * ref}
00505 \textcolor{comment}{// However, it seems that simply comparing a+ref and b+ref is more sensitive to true error.}
00506 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} ScalarRef>
00507 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApproxWithRef(\textcolor{keyword}{const} Scalar& a, \textcolor{keyword}{const} Scalar& b, \textcolor{keyword}{const} ScalarRef& ref)
00508 \{
00509   \textcolor{keywordflow}{return} test\_isApprox(a+ref, b+ref);
00510 \}
00511 
00512 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived1, \textcolor{keyword}{typename} Derived2>
00513 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isMuchSmallerThan(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived1>}& m1,
00514                                    \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived2>}& m2)
00515 \{
00516   \textcolor{keywordflow}{return} m1.isMuchSmallerThan(m2, test\_precision<\textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived1>::Scalar}>());
00517 \}
00518 
00519 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00520 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isMuchSmallerThan(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& m,
00521                                    \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits}<\textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Scalar}>::Real& s)
00522 \{
00523   \textcolor{keywordflow}{return} m.isMuchSmallerThan(s, test\_precision<\textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Scalar}>());
00524 \}
00525 
00526 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00527 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isUnitary(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& m)
00528 \{
00529   \textcolor{keywordflow}{return} m.\hyperlink{group___core___module_a8a7ee34ce202cac3eeea9cf20c9e4833}{isUnitary}(test\_precision<\textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Derived>::Scalar}>());
00530 \}
00531 
00532 \textcolor{comment}{// Forward declaration to avoid ICC warning}
00533 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>
00534 \textcolor{keywordtype}{bool} test\_is\_equal(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& actual, \textcolor{keyword}{const} U& expected, \textcolor{keywordtype}{bool} expect\_equal=\textcolor{keyword}{true});
00535 
00536 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>
00537 \textcolor{keywordtype}{bool} test\_is\_equal(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& actual, \textcolor{keyword}{const} U& expected, \textcolor{keywordtype}{bool} expect\_equal)
00538 \{
00539     \textcolor{keywordflow}{if} ((actual==expected) == expect\_equal)
00540         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00541     \textcolor{comment}{// false:}
00542     std::cerr
00543         << \textcolor{stringliteral}{"\(\backslash\)n    actual   = "} << actual
00544         << \textcolor{stringliteral}{"\(\backslash\)n    expected "} << (expect\_equal ? \textcolor{stringliteral}{"= "} : \textcolor{stringliteral}{"!="}) << expected << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
00545     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00546 \}
00547 
00553 \textcolor{comment}{// Forward declaration to avoid ICC warning}
00554 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00555 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_a0d9a7ddcee5c7c8defaba3628455efb2}{createRandomPIMatrixOfRank}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} desired\_rank, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, MatrixType& m);
00556 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2test_2main_8h_source_l00557}\hyperlink{namespace_eigen_a0d9a7ddcee5c7c8defaba3628455efb2}{00557} \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_a0d9a7ddcee5c7c8defaba3628455efb2}{createRandomPIMatrixOfRank}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} desired\_rank, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, MatrixType& m)
00558 \{
00559   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<MatrixType>::Scalar} Scalar;
00560   \textcolor{keyword}{enum} \{ Rows = MatrixType::RowsAtCompileTime, Cols = MatrixType::ColsAtCompileTime \};
00561 
00562   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>} \hyperlink{struct_vector_type}{VectorType};
00563   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Rows, Rows>} MatrixAType;
00564   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, Cols, Cols>} MatrixBType;
00565 
00566   \textcolor{keywordflow}{if}(desired\_rank == 0)
00567   \{
00568     m.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}(rows,cols);
00569     \textcolor{keywordflow}{return};
00570   \}
00571 
00572   \textcolor{keywordflow}{if}(desired\_rank == 1)
00573   \{
00574     \textcolor{comment}{// here we normalize the vectors to get a partial isometry}
00575     m = VectorType::Random(rows).normalized() * VectorType::Random(cols).normalized().transpose();
00576     \textcolor{keywordflow}{return};
00577   \}
00578 
00579   MatrixAType a = MatrixAType::Random(rows,rows);
00580   MatrixType d = MatrixType::Identity(rows,cols);
00581   MatrixBType  b = MatrixBType::Random(cols,cols);
00582 
00583   \textcolor{comment}{// set the diagonal such that only desired\_rank non-zero entries reamain}
00584   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} diag\_size = (std::min)(d.rows(),d.cols());
00585   \textcolor{keywordflow}{if}(diag\_size != desired\_rank)
00586     d.diagonal().segment(desired\_rank, diag\_size-desired\_rank) = VectorType::Zero(diag\_size-desired\_rank);
00587 
00588   \hyperlink{group___q_r___module_class_eigen_1_1_householder_q_r}{HouseholderQR<MatrixAType>} qra(a);
00589   \hyperlink{group___q_r___module_class_eigen_1_1_householder_q_r}{HouseholderQR<MatrixBType>} qrb(b);
00590   m = qra.\hyperlink{group___q_r___module_affd506c10ef2d25f56e7b1f9f25ff885}{householderQ}() * d * qrb.\hyperlink{group___q_r___module_affd506c10ef2d25f56e7b1f9f25ff885}{householderQ}();
00591 \}
00592 
00593 \textcolor{comment}{// Forward declaration to avoid ICC warning}
00594 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PermutationVectorType>
00595 \textcolor{keywordtype}{void} randomPermutationVector(PermutationVectorType& v, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size);
00596 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PermutationVectorType>
00597 \textcolor{keywordtype}{void} randomPermutationVector(PermutationVectorType& v, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size)
00598 \{
00599   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PermutationVectorType::Scalar Scalar;
00600   v.resize(size);
00601   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < size; ++i) v(i) = Scalar(i);
00602   \textcolor{keywordflow}{if}(size == 1) \textcolor{keywordflow}{return};
00603   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = 0; n < 3 * size; ++n)
00604   \{
00605     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = internal::random<Index>(0, size-1);
00606     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j;
00607     \textcolor{keywordflow}{do} j = internal::random<Index>(0, size-1); \textcolor{keywordflow}{while}(j==i);
00608     \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(v(i), v(j));
00609   \}
00610 \}
00611 
00612 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keywordtype}{bool} isNotNaN(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& x)
00613 \{
00614   \textcolor{keywordflow}{return} x==x;
00615 \}
00616 
00617 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keywordtype}{bool} isPlusInf(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& x)
00618 \{
00619   \textcolor{keywordflow}{return} x > \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<T>::highest}();
00620 \}
00621 
00622 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keywordtype}{bool} isMinusInf(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& x)
00623 \{
00624   \textcolor{keywordflow}{return} x < NumTraits<T>::lowest();
00625 \}
00626 
00627 \} \textcolor{comment}{// end namespace Eigen}
00628 
\Hypertarget{eigen_2test_2main_8h_source_l00629}\hyperlink{struct_get_different_type}{00629} \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\hyperlink{struct_get_different_type}{GetDifferentType};
00630 
\Hypertarget{eigen_2test_2main_8h_source_l00631}\hyperlink{struct_get_different_type_3_01float_01_4}{00631} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_get_different_type}{GetDifferentType}<float> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{double} type; \};
\Hypertarget{eigen_2test_2main_8h_source_l00632}\hyperlink{struct_get_different_type_3_01double_01_4}{00632} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_get_different_type}{GetDifferentType}<double> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{float} type; \};
\Hypertarget{eigen_2test_2main_8h_source_l00633}\hyperlink{struct_get_different_type_3_01std_1_1complex_3_01_t_01_4_01_4}{00633} \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\hyperlink{struct_get_different_type}{GetDifferentType}<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<T> >
00634 \{ \textcolor{keyword}{typedef} std::complex<typename GetDifferentType<T>::type> type; \};
00635 
00636 \textcolor{comment}{// Forward declaration to avoid ICC warning}
00637 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> std::string type\_name();
00638 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> std::string type\_name()                    \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"other"}; \}
00639 \textcolor{keyword}{template}<> std::string type\_name<float>()                       \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"float"}; \}
00640 \textcolor{keyword}{template}<> std::string type\_name<double>()                      \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"double"}; \}
00641 \textcolor{keyword}{template}<> std::string type\_name<long double>()                 \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"long double"}; \}
00642 \textcolor{keyword}{template}<> std::string type\_name<int>()                         \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"int"}; \}
00643 \textcolor{keyword}{template}<> std::string type\_name<std::complex<float> >()        \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"complex<float>"}; \}
00644 \textcolor{keyword}{template}<> std::string type\_name<std::complex<double> >()       \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"complex<double>"}; \}
00645 \textcolor{keyword}{template}<> std::string type\_name<std::complex<long double> >()  \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"complex<long double>"}; \}
00646 \textcolor{keyword}{template}<> std::string type\_name<std::complex<int> >()          \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"complex<int>"}; \}
00647 
00648 \textcolor{comment}{// forward declaration of the main test function}
00649 \textcolor{keywordtype}{void} EIGEN\_CAT(test\_,EIGEN\_TEST\_FUNC)();
00650 
00651 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00652 
00653 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} set\_repeat\_from\_string(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *str)
00654 \{
00655   errno = 0;
00656   g\_repeat = int(strtoul(str, 0, 10));
00657   \textcolor{keywordflow}{if}(errno || g\_repeat <= 0)
00658   \{
00659     std::cout << \textcolor{stringliteral}{"Invalid repeat value "} << str << std::endl;
00660     exit(EXIT\_FAILURE);
00661   \}
00662   g\_has\_set\_repeat = \textcolor{keyword}{true};
00663 \}
00664 
00665 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} set\_seed\_from\_string(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *str)
00666 \{
00667   errno = 0;
00668   g\_seed = int(strtoul(str, 0, 10));
00669   \textcolor{keywordflow}{if}(errno || g\_seed == 0)
00670   \{
00671     std::cout << \textcolor{stringliteral}{"Invalid seed value "} << str << std::endl;
00672     exit(EXIT\_FAILURE);
00673   \}
00674   g\_has\_set\_seed = \textcolor{keyword}{true};
00675 \}
00676 
00677 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[])
00678 \{
00679     g\_has\_set\_repeat = \textcolor{keyword}{false};
00680     g\_has\_set\_seed = \textcolor{keyword}{false};
00681     \textcolor{keywordtype}{bool} need\_help = \textcolor{keyword}{false};
00682 
00683     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 1; i < argc; i++)
00684     \{
00685       \textcolor{keywordflow}{if}(argv[i][0] == \textcolor{charliteral}{'r'})
00686       \{
00687         \textcolor{keywordflow}{if}(g\_has\_set\_repeat)
00688         \{
00689           std::cout << \textcolor{stringliteral}{"Argument "} << argv[i] << \textcolor{stringliteral}{" conflicting with a former argument"} << std::endl;
00690           \textcolor{keywordflow}{return} 1;
00691         \}
00692         set\_repeat\_from\_string(argv[i]+1);
00693       \}
00694       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(argv[i][0] == \textcolor{charliteral}{'s'})
00695       \{
00696         \textcolor{keywordflow}{if}(g\_has\_set\_seed)
00697         \{
00698           std::cout << \textcolor{stringliteral}{"Argument "} << argv[i] << \textcolor{stringliteral}{" conflicting with a former argument"} << std::endl;
00699           \textcolor{keywordflow}{return} 1;
00700         \}
00701          set\_seed\_from\_string(argv[i]+1);
00702       \}
00703       \textcolor{keywordflow}{else}
00704       \{
00705         need\_help = \textcolor{keyword}{true};
00706       \}
00707     \}
00708 
00709     \textcolor{keywordflow}{if}(need\_help)
00710     \{
00711       std::cout << \textcolor{stringliteral}{"This test application takes the following optional arguments:"} << std::endl;
00712       std::cout << \textcolor{stringliteral}{"  rN     Repeat each test N times (default: "} << DEFAULT\_REPEAT << \textcolor{stringliteral}{")"} << std::endl;
00713       std::cout << \textcolor{stringliteral}{"  sN     Use N as seed for random numbers (default: based on current time)"} << 
      std::endl;
00714       std::cout << std::endl;
00715       std::cout << \textcolor{stringliteral}{"If defined, the environment variables EIGEN\_REPEAT and EIGEN\_SEED"} << std::endl;
00716       std::cout << \textcolor{stringliteral}{"will be used as default values for these parameters."} << std::endl;
00717       \textcolor{keywordflow}{return} 1;
00718     \}
00719 
00720     \textcolor{keywordtype}{char} *env\_EIGEN\_REPEAT = getenv(\textcolor{stringliteral}{"EIGEN\_REPEAT"});
00721     \textcolor{keywordflow}{if}(!g\_has\_set\_repeat && env\_EIGEN\_REPEAT)
00722       set\_repeat\_from\_string(env\_EIGEN\_REPEAT);
00723     \textcolor{keywordtype}{char} *env\_EIGEN\_SEED = getenv(\textcolor{stringliteral}{"EIGEN\_SEED"});
00724     \textcolor{keywordflow}{if}(!g\_has\_set\_seed && env\_EIGEN\_SEED)
00725       set\_seed\_from\_string(env\_EIGEN\_SEED);
00726 
00727     \textcolor{keywordflow}{if}(!g\_has\_set\_seed) g\_seed = (\textcolor{keywordtype}{unsigned} int) time(NULL);
00728     \textcolor{keywordflow}{if}(!g\_has\_set\_repeat) g\_repeat = DEFAULT\_REPEAT;
00729 
00730     std::cout << \textcolor{stringliteral}{"Initializing random number generator with seed "} << g\_seed << std::endl;
00731     std::stringstream ss;
00732     ss << \textcolor{stringliteral}{"Seed: "} << g\_seed;
00733     g\_test\_stack.push\_back(ss.str());
00734     srand(g\_seed);
00735     std::cout << \textcolor{stringliteral}{"Repeating each test "} << g\_repeat << \textcolor{stringliteral}{" times"} << std::endl;
00736 
00737     Eigen::g\_test\_stack.push\_back(std::string(EI\_PP\_MAKE\_STRING(EIGEN\_TEST\_FUNC)));
00738 
00739     EIGEN\_CAT(test\_,EIGEN\_TEST\_FUNC)();
00740     \textcolor{keywordflow}{return} 0;
00741 \}
00742 
00743 \textcolor{comment}{// These warning are disabled here such that they are still ON when parsing Eigen's header files.}
00744 \textcolor{preprocessor}{#if defined \_\_INTEL\_COMPILER}
00745   \textcolor{comment}{// remark #383: value copied to temporary, reference to temporary used}
00746   \textcolor{comment}{//  -> this warning is raised even for legal usage as: g\_test\_stack.push\_back("foo"); where g\_test\_stack
       is a std::vector<std::string>}
00747   \textcolor{comment}{// remark #1418: external function definition with no prior declaration}
00748   \textcolor{comment}{//  -> this warning is raised for all our test functions. Declaring them static would fix the issue.}
00749   \textcolor{comment}{// warning #279: controlling expression is constant}
00750   \textcolor{comment}{// remark #1572: floating-point equality and inequality comparisons are unreliable}
00751 \textcolor{preprocessor}{  #pragma warning disable 279 383 1418 1572}
00752 \textcolor{preprocessor}{#endif}
00753 
00754 \textcolor{preprocessor}{#ifdef \_MSC\_VER}
00755   \textcolor{comment}{// 4503 - decorated name length exceeded, name was truncated}
00756 \textcolor{preprocessor}{  #pragma warning( disable : 4503)}
00757 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
