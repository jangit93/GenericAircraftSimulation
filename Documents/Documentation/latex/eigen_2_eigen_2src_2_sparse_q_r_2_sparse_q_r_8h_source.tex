\hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source}{}\section{eigen/\+Eigen/src/\+Sparse\+Q\+R/\+Sparse\+QR.h}
\label{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source}\index{Sparse\+Q\+R.\+h@{Sparse\+Q\+R.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012-2013 Desire Nuentsa <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2012-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSE\_QR\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_SPARSE\_QR\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00016}\hyperlink{group___sparse_q_r___module}{00016} \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} OrderingType> \textcolor{keyword}{class }\hyperlink{group___sparse_q_r___module_class_eigen_1_1_sparse_q_r}{SparseQR};
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00017}\hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{00017} \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseQRType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SparseQRMatrixQReturnType};
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00018}\hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_transpose_return_type}{00018} \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseQRType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_transpose_return_type}{SparseQRMatrixQTransposeReturnType}
      ;
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00019}\hyperlink{struct_eigen_1_1_sparse_q_r___q_product}{00019} \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseQRType, \textcolor{keyword}{typename} Derived> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_sparse_q_r___q_product}{SparseQR\_QProduct};
00020 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00021}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_sparse_q_r_matrix_q_return_type_3_01_sparse_q_r_type_01_4_01_4}{00021}   \textcolor{keyword}{template} <\textcolor{keyword}{typename} SparseQRType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SparseQRMatrixQReturnType}<
      SparseQRType> >
00022   \{
00023     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseQRType::MatrixType ReturnType;
00024     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ReturnType::StorageIndex StorageIndex;
00025     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ReturnType::StorageKind StorageKind;
00026     \textcolor{keyword}{enum} \{
00027       RowsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00028       ColsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}
00029     \};
00030   \};
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00031}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_sparse_q_r_matrix_q_transpose_return_type_3_01_sparse_q_r_type_01_4_01_4}{00031}   \textcolor{keyword}{template} <\textcolor{keyword}{typename} SparseQRType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<
      \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_transpose_return_type}{SparseQRMatrixQTransposeReturnType}<SparseQRType> >
00032   \{
00033     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseQRType::MatrixType ReturnType;
00034   \};
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00035}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_sparse_q_r___q_product_3_01_sparse_q_r_type_00_01_derived_01_4_01_4}{00035}   \textcolor{keyword}{template} <\textcolor{keyword}{typename} SparseQRType, \textcolor{keyword}{typename} Derived> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<
      \hyperlink{struct_eigen_1_1_sparse_q_r___q_product}{SparseQR\_QProduct}<SparseQRType, Derived> >
00036   \{
00037     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::PlainObject ReturnType;
00038   \};
00039 \} \textcolor{comment}{// End namespace internal}
00040 
00070 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_OrderingType>
00071 \textcolor{keyword}{class }\hyperlink{group___sparse_q_r___module_class_eigen_1_1_sparse_q_r}{SparseQR} : \textcolor{keyword}{public} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase}<SparseQR<\_MatrixType,\_OrderingType> >
00072 \{
00073   \textcolor{keyword}{protected}:
00074     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase<SparseQR<\_MatrixType,\_OrderingType>}
       > Base;
00075     \textcolor{keyword}{using} Base::m\_isInitialized;
00076   \textcolor{keyword}{public}:
00077     \textcolor{keyword}{using} Base::\_solve\_impl;
00078     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00079     \textcolor{keyword}{typedef} \_OrderingType OrderingType;
00080     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00081     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00082     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00083     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar,ColMajor,StorageIndex>} 
      QRMatrixType;
00084     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<StorageIndex, Dynamic, 1>} IndexVector;
00085     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar, Dynamic, 1>} ScalarVector;
00086     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{PermutationMatrix<Dynamic, Dynamic, StorageIndex>}
       PermutationType;
00087 
00088     \textcolor{keyword}{enum} \{
00089       ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00090       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
00091     \};
00092     
00093   \textcolor{keyword}{public}:
00094     \hyperlink{group___sparse_q_r___module_class_eigen_1_1_sparse_q_r}{SparseQR} () :  m\_analysisIsok(\textcolor{keyword}{false}), m\_lastError(\textcolor{stringliteral}{""}), m\_useDefaultThreshold(\textcolor{keyword}{true}),m\_isQSorted(\textcolor{keyword}{
      false}),m\_isEtreeOk(\textcolor{keyword}{false})
00095     \{ \}
00096     
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00103}\hyperlink{group___sparse_q_r___module_ac50f705d686d4bc687ce6acbc76447d2}{00103}     \textcolor{keyword}{explicit} \hyperlink{group___sparse_q_r___module_ac50f705d686d4bc687ce6acbc76447d2}{SparseQR}(\textcolor{keyword}{const} MatrixType& mat) : m\_analysisIsok(false), m\_lastError(\textcolor{stringliteral}{""}), 
      m\_useDefaultThreshold(true),m\_isQSorted(false),m\_isEtreeOk(false)
00104     \{
00105       compute(mat);
00106     \}
00107     
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00114}\hyperlink{group___sparse_q_r___module_aedaf52b7543de4d55c58c8f830c2aeb7}{00114}     \textcolor{keywordtype}{void} \hyperlink{group___sparse_q_r___module_aedaf52b7543de4d55c58c8f830c2aeb7}{compute}(\textcolor{keyword}{const} MatrixType& mat)
00115     \{
00116       analyzePattern(mat);
00117       factorize(mat);
00118     \}
00119     \textcolor{keywordtype}{void} analyzePattern(\textcolor{keyword}{const} MatrixType& mat);
00120     \textcolor{keywordtype}{void} factorize(\textcolor{keyword}{const} MatrixType& mat);
00121     
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00124}\hyperlink{group___sparse_q_r___module_ab9133b7ace1c19714df99f553666316d}{00124}     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{group___sparse_q_r___module_ab9133b7ace1c19714df99f553666316d}{rows}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_pmat.rows(); \}
00125     
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00128}\hyperlink{group___sparse_q_r___module_a57bedc9b1351c0995bae8ad0088a6fce}{00128}     \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{group___sparse_q_r___module_a57bedc9b1351c0995bae8ad0088a6fce}{cols}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_pmat.cols();\}
00129     
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00143}\hyperlink{group___sparse_q_r___module_a564524ff13b2b6dd1e76127404f7b920}{00143}     \textcolor{keyword}{const} QRMatrixType& \hyperlink{group___sparse_q_r___module_a564524ff13b2b6dd1e76127404f7b920}{matrixR}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_R; \}
00144     
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00149}\hyperlink{group___sparse_q_r___module_a70ec2b9e5cb62a41dc1ee2adfb54e9b0}{00149}     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{group___sparse_q_r___module_a70ec2b9e5cb62a41dc1ee2adfb54e9b0}{rank}()\textcolor{keyword}{ const}
00150 \textcolor{keyword}{    }\{
00151       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"The factorization should be called first, use compute()"});
00152       \textcolor{keywordflow}{return} m\_nonzeropivots; 
00153     \}
00154     
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00173}\hyperlink{group___sparse_q_r___module_ae1cc0a836c177d4f42600f8639354be1}{00173}     \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SparseQRMatrixQReturnType<SparseQR>} 
      \hyperlink{group___sparse_q_r___module_ae1cc0a836c177d4f42600f8639354be1}{matrixQ}()\textcolor{keyword}{ const }
00174 \textcolor{keyword}{    }\{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SparseQRMatrixQReturnType<SparseQR>}(*this); \}
00175     
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00179}\hyperlink{group___sparse_q_r___module_a140930ebbf89dfd57a173761716db38f}{00179}     \textcolor{keyword}{const} PermutationType& \hyperlink{group___sparse_q_r___module_a140930ebbf89dfd57a173761716db38f}{colsPermutation}()\textcolor{keyword}{ const}
00180 \textcolor{keyword}{    }\{ 
00181       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"Decomposition is not initialized."});
00182       \textcolor{keywordflow}{return} m\_outputPerm\_c;
00183     \}
00184     
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00188}\hyperlink{group___sparse_q_r___module_a1222e59649d77125d91f1368cf293c63}{00188}     std::string \hyperlink{group___sparse_q_r___module_a1222e59649d77125d91f1368cf293c63}{lastErrorMessage}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lastError; \}
00189     
00191     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest>
00192     \textcolor{keywordtype}{bool} \_solve\_impl(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>} &\hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Dest>} &dest)\textcolor{keyword}{
       const}
00193 \textcolor{keyword}{    }\{
00194       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"The factorization should be called first, use compute()"});
00195       eigen\_assert(this->rows() == B.rows() && \textcolor{stringliteral}{"SparseQR::solve() : invalid number of rows in the right
       hand side matrix"});
00196 
00197       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rank = this->rank();
00198       
00199       \textcolor{comment}{// Compute Q^T * b;}
00200       \textcolor{keyword}{typename} Dest::PlainObject y, b;
00201       y = this->matrixQ().transpose() * B; 
00202       b = y;
00203       
00204       \textcolor{comment}{// Solve with the triangular matrix R}
00205       y.\hyperlink{group___core___module_a13027a493a68a13496610caf3d81bd3e}{resize}((std::max<Index>)(cols(),y.rows()),y.cols());
00206       y.topRows(rank) = this->matrixR().topLeftCorner(rank, rank).template triangularView<Upper>().solve(b.
      topRows(rank));
00207       y.bottomRows(y.rows()-rank).setZero();
00208       
00209       \textcolor{comment}{// Apply the column permutation}
00210       \textcolor{keywordflow}{if} (m\_perm\_c.size())  dest = colsPermutation() * y.\hyperlink{group___core___module_ad3e01f9216955704228eaeac0b442d24}{topRows}(cols());
00211       \textcolor{keywordflow}{else}                  dest = y.\hyperlink{group___core___module_ad3e01f9216955704228eaeac0b442d24}{topRows}(cols());
00212       
00213       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00214       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00215     \}
00216 
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00222}\hyperlink{group___sparse_q_r___module_adb7bfa65f99e3ef91ed58ea663a850a1}{00222}     \textcolor{keywordtype}{void} \hyperlink{group___sparse_q_r___module_adb7bfa65f99e3ef91ed58ea663a850a1}{setPivotThreshold}(\textcolor{keyword}{const} RealScalar& threshold)
00223     \{
00224       m\_useDefaultThreshold = \textcolor{keyword}{false};
00225       m\_threshold = threshold;
00226     \}
00227     
00232     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs>
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00233}\hyperlink{group___sparse_q_r___module_aea13a2c6823cd8408ba49afde9b3d4e4}{00233}     \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_solve}{Solve<SparseQR, Rhs>} \hyperlink{group___sparse_q_r___module_aea13a2c6823cd8408ba49afde9b3d4e4}{solve}(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>}& B)\textcolor{keyword}{ const }
00234 \textcolor{keyword}{    }\{
00235       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"The factorization should be called first, use compute()"});
00236       eigen\_assert(this->rows() == B.rows() && \textcolor{stringliteral}{"SparseQR::solve() : invalid number of rows in the right
       hand side matrix"});
00237       \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_solve}{Solve<SparseQR, Rhs>}(*\textcolor{keyword}{this}, B.derived());
00238     \}
00239     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs>
00240     \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_solve}{Solve<SparseQR, Rhs>} solve(\textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<Rhs>}& B)\textcolor{keyword}{ const}
00241 \textcolor{keyword}{    }\{
00242           eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"The factorization should be called first, use compute()"});
00243           eigen\_assert(this->rows() == B.\hyperlink{group___sparse_core___module_a1944e9fa9ce7937bfc3a87b2cb94371f}{rows}() && \textcolor{stringliteral}{"SparseQR::solve() : invalid number of rows in the
       right hand side matrix"});
00244           \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_solve}{Solve<SparseQR, Rhs>}(*\textcolor{keyword}{this}, B.derived());
00245     \}
00246     
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00255}\hyperlink{group___sparse_q_r___module_a234b0580aaf57237393f2e73a3d38690}{00255}     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} \hyperlink{group___sparse_q_r___module_a234b0580aaf57237393f2e73a3d38690}{info}()\textcolor{keyword}{ const}
00256 \textcolor{keyword}{    }\{
00257       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"Decomposition is not initialized."});
00258       \textcolor{keywordflow}{return} m\_info;
00259     \}
00260 
00261 
00263     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \_sort\_matrix\_Q()
00264     \{
00265       \textcolor{keywordflow}{if}(this->m\_isQSorted) \textcolor{keywordflow}{return};
00266       \textcolor{comment}{// The matrix Q is sorted during the transposition}
00267       \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar, RowMajor, Index>} mQrm(this->m\_Q);
00268       this->m\_Q = mQrm;
00269       this->m\_isQSorted = \textcolor{keyword}{true};
00270     \}
00271 
00272     
00273   \textcolor{keyword}{protected}:
00274     \textcolor{keywordtype}{bool} m\_analysisIsok;
00275     \textcolor{keywordtype}{bool} m\_factorizationIsok;
00276     \textcolor{keyword}{mutable} \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} m\_info;
00277     std::string m\_lastError;
00278     QRMatrixType m\_pmat;            \textcolor{comment}{// Temporary matrix}
00279     QRMatrixType m\_R;               \textcolor{comment}{// The triangular factor matrix}
00280     QRMatrixType m\_Q;               \textcolor{comment}{// The orthogonal reflectors}
00281     ScalarVector m\_hcoeffs;         \textcolor{comment}{// The Householder coefficients}
00282     PermutationType m\_perm\_c;       \textcolor{comment}{// Fill-reducing  Column  permutation}
00283     PermutationType m\_pivotperm;    \textcolor{comment}{// The permutation for rank revealing}
00284     PermutationType m\_outputPerm\_c; \textcolor{comment}{// The final column permutation}
00285     RealScalar m\_threshold;         \textcolor{comment}{// Threshold to determine null Householder reflections}
00286     \textcolor{keywordtype}{bool} m\_useDefaultThreshold;     \textcolor{comment}{// Use default threshold}
00287     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_nonzeropivots;          \textcolor{comment}{// Number of non zero pivots found}
00288     IndexVector m\_etree;            \textcolor{comment}{// Column elimination tree}
00289     IndexVector m\_firstRowElt;      \textcolor{comment}{// First element in each row}
00290     \textcolor{keywordtype}{bool} m\_isQSorted;               \textcolor{comment}{// whether Q is sorted or not}
00291     \textcolor{keywordtype}{bool} m\_isEtreeOk;               \textcolor{comment}{// whether the elimination tree match the initial input matrix}
00292     
00293     \textcolor{keyword}{template} <\textcolor{keyword}{typename}, \textcolor{keyword}{typename} > \textcolor{keyword}{friend} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_sparse_q_r___q_product}{SparseQR\_QProduct};
00294     
00295 \};
00296 
00306 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} OrderingType>
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00307}\hyperlink{group___sparse_q_r___module_a4b425ddb1358c914d764cde48853a4f6}{00307} \textcolor{keywordtype}{void} \hyperlink{group___sparse_q_r___module_a4b425ddb1358c914d764cde48853a4f6}{SparseQR<MatrixType,OrderingType>::analyzePattern}(\textcolor{keyword}{
      const} MatrixType& mat)
00308 \{
00309   eigen\_assert(mat.isCompressed() && \textcolor{stringliteral}{"SparseQR requires a sparse matrix in compressed mode. Call
       .makeCompressed() before passing it to SparseQR"});
00310   \textcolor{comment}{// Copy to a column major matrix if the input is rowmajor}
00311   \textcolor{keyword}{typename} 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::conditional<MatrixType::IsRowMajor,QRMatrixType,const MatrixType&>::type}
       matCpy(mat);
00312   \textcolor{comment}{// Compute the column fill reducing ordering}
00313   OrderingType ord; 
00314   ord(matCpy, m\_perm\_c); 
00315   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = mat.cols();
00316   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m = mat.rows();
00317   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} diagSize = (std::min)(m,n);
00318   
00319   \textcolor{keywordflow}{if} (!m\_perm\_c.size())
00320   \{
00321     m\_perm\_c.resize(n);
00322     m\_perm\_c.indices().setLinSpaced(n, 0,StorageIndex(n-1));
00323   \}
00324   
00325   \textcolor{comment}{// Compute the column elimination tree of the permuted matrix}
00326   m\_outputPerm\_c = m\_perm\_c.inverse();
00327   \hyperlink{namespace_eigen_1_1internal_a86181db74ba596a7afbfd89efcc5788c}{internal::coletree}(matCpy, m\_etree, m\_firstRowElt, m\_outputPerm\_c.indices().data());
00328   m\_isEtreeOk = \textcolor{keyword}{true};
00329   
00330   m\_R.resize(m, n);
00331   m\_Q.resize(m, diagSize);
00332   
00333   \textcolor{comment}{// Allocate space for nonzero elements : rough estimation}
00334   m\_R.reserve(2*mat.nonZeros()); \textcolor{comment}{//FIXME Get a more accurate estimation through symbolic factorization with
       the etree}
00335   m\_Q.reserve(2*mat.nonZeros());
00336   m\_hcoeffs.resize(diagSize);
00337   m\_analysisIsok = \textcolor{keyword}{true};
00338 \}
00339 
00347 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} OrderingType>
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00348}\hyperlink{group___sparse_q_r___module_a55a34bacf05bd30a1dacbccad9f03c6d}{00348} \textcolor{keywordtype}{void} \hyperlink{group___sparse_q_r___module_a55a34bacf05bd30a1dacbccad9f03c6d}{SparseQR<MatrixType,OrderingType>::factorize}(\textcolor{keyword}{const} 
      MatrixType& mat)
00349 \{
00350   \textcolor{keyword}{using} std::abs;
00351   
00352   eigen\_assert(m\_analysisIsok && \textcolor{stringliteral}{"analyzePattern() should be called before this step"});
00353   StorageIndex m = StorageIndex(mat.rows());
00354   StorageIndex n = StorageIndex(mat.cols());
00355   StorageIndex diagSize = (std::min)(m,n);
00356   \hyperlink{group___core___module}{IndexVector} mark((std::max)(m,n)); mark.\hyperlink{class_eigen_1_1_plain_object_base_ac8dea1df3d92b752cc683ff42abf6f9b}{setConstant}(-1);  \textcolor{comment}{// Record the visited
       nodes}
00357   \hyperlink{group___core___module}{IndexVector} Ridx(n), Qidx(m);                             \textcolor{comment}{// Store temporarily the row indexes
       for the current column of R and Q}
00358   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nzcolR, nzcolQ;                                     \textcolor{comment}{// Number of nonzero for the current
       column of R and Q}
00359   \hyperlink{group___core___module}{ScalarVector} tval(m);                                     \textcolor{comment}{// The dense vector used to compute
       the current column}
00360   RealScalar pivotThreshold = m\_threshold;
00361   
00362   m\_R.setZero();
00363   m\_Q.setZero();
00364   m\_pmat = mat;
00365   \textcolor{keywordflow}{if}(!m\_isEtreeOk)
00366   \{
00367     m\_outputPerm\_c = m\_perm\_c.inverse();
00368     \hyperlink{namespace_eigen_1_1internal_a86181db74ba596a7afbfd89efcc5788c}{internal::coletree}(m\_pmat, m\_etree, m\_firstRowElt, m\_outputPerm\_c.indices().data());
00369     m\_isEtreeOk = \textcolor{keyword}{true};
00370   \}
00371 
00372   m\_pmat.uncompress(); \textcolor{comment}{// To have the innerNonZeroPtr allocated}
00373   
00374   \textcolor{comment}{// Apply the fill-in reducing permutation lazily:}
00375   \{
00376     \textcolor{comment}{// If the input is row major, copy the original column indices,}
00377     \textcolor{comment}{// otherwise directly use the input matrix}
00378     \textcolor{comment}{// }
00379     \hyperlink{group___core___module}{IndexVector} originalOuterIndicesCpy;
00380     \textcolor{keyword}{const} StorageIndex *originalOuterIndices = mat.outerIndexPtr();
00381     \textcolor{keywordflow}{if}(MatrixType::IsRowMajor)
00382     \{
00383       originalOuterIndicesCpy = IndexVector::Map(m\_pmat.outerIndexPtr(),n+1);
00384       originalOuterIndices = originalOuterIndicesCpy.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}();
00385     \}
00386     
00387     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < n; i++)
00388     \{
00389       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p = m\_perm\_c.size() ? m\_perm\_c.indices()(i) : i;
00390       m\_pmat.outerIndexPtr()[p] = originalOuterIndices[i]; 
00391       m\_pmat.innerNonZeroPtr()[p] = originalOuterIndices[i+1] - originalOuterIndices[i]; 
00392     \}
00393   \}
00394   
00395   \textcolor{comment}{/* Compute the default threshold as in MatLab, see:}
00396 \textcolor{comment}{   * Tim Davis, "Algorithm 915, SuiteSparseQR: Multifrontal Multithreaded Rank-Revealing}
00397 \textcolor{comment}{   * Sparse QR Factorization, ACM Trans. on Math. Soft. 38(1), 2011, Page 8:3 }
00398 \textcolor{comment}{   */}
00399   \textcolor{keywordflow}{if}(m\_useDefaultThreshold) 
00400   \{
00401     RealScalar max2Norm = 0.0;
00402     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < n; j++) max2Norm = numext::maxi(max2Norm, m\_pmat.col(j).norm());
00403     \textcolor{keywordflow}{if}(max2Norm==RealScalar(0))
00404       max2Norm = RealScalar(1);
00405     pivotThreshold = 20 * (m + n) * max2Norm * \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::epsilon}
      ();
00406   \}
00407   
00408   \textcolor{comment}{// Initialize the numerical permutation}
00409   m\_pivotperm.setIdentity(n);
00410   
00411   StorageIndex nonzeroCol = 0; \textcolor{comment}{// Record the number of valid pivots}
00412   m\_Q.startVec(0);
00413 
00414   \textcolor{comment}{// Left looking rank-revealing QR factorization: compute a column of R and Q at a time}
00415   \textcolor{keywordflow}{for} (StorageIndex col = 0; col < n; ++col)
00416   \{
00417     mark.\hyperlink{class_eigen_1_1_plain_object_base_ac8dea1df3d92b752cc683ff42abf6f9b}{setConstant}(-1);
00418     m\_R.startVec(col);
00419     mark(nonzeroCol) = col;
00420     Qidx(0) = nonzeroCol;
00421     nzcolR = 0; nzcolQ = 1;
00422     \textcolor{keywordtype}{bool} found\_diag = nonzeroCol>=m;
00423     tval.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}(); 
00424     
00425     \textcolor{comment}{// Symbolic factorization: find the nonzero locations of the column k of the factors R and Q, i.e.,}
00426     \textcolor{comment}{// all the nodes (with indexes lower than rank) reachable through the column elimination tree (etree)
       rooted at node k.}
00427     \textcolor{comment}{// Note: if the diagonal entry does not exist, then its contribution must be explicitly added,}
00428     \textcolor{comment}{// thus the trick with found\_diag that permits to do one more iteration on the diagonal element if this
       one has not been found.}
00429     \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} QRMatrixType::InnerIterator itp(m\_pmat, col); itp || !found\_diag; ++itp)
00430     \{
00431       StorageIndex curIdx = nonzeroCol;
00432       \textcolor{keywordflow}{if}(itp) curIdx = StorageIndex(itp.row());
00433       \textcolor{keywordflow}{if}(curIdx == nonzeroCol) found\_diag = \textcolor{keyword}{true};
00434       
00435       \textcolor{comment}{// Get the nonzeros indexes of the current column of R}
00436       StorageIndex st = m\_firstRowElt(curIdx); \textcolor{comment}{// The traversal of the etree starts here}
00437       \textcolor{keywordflow}{if} (st < 0 )
00438       \{
00439         m\_lastError = \textcolor{stringliteral}{"Empty row found during numerical factorization"};
00440         m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434}{InvalidInput};
00441         \textcolor{keywordflow}{return};
00442       \}
00443 
00444       \textcolor{comment}{// Traverse the etree }
00445       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} bi = nzcolR;
00446       \textcolor{keywordflow}{for} (; mark(st) != col; st = m\_etree(st))
00447       \{
00448         Ridx(nzcolR) = st;  \textcolor{comment}{// Add this row to the list,}
00449         mark(st) = col;     \textcolor{comment}{// and mark this row as visited}
00450         nzcolR++;
00451       \}
00452 
00453       \textcolor{comment}{// Reverse the list to get the topological ordering}
00454       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nt = nzcolR-bi;
00455       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < nt/2; i++) \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(Ridx(bi+i), Ridx(nzcolR-i-1));
00456        
00457       \textcolor{comment}{// Copy the current (curIdx,pcol) value of the input matrix}
00458       \textcolor{keywordflow}{if}(itp) tval(curIdx) = itp.value();
00459       \textcolor{keywordflow}{else}    tval(curIdx) = Scalar(0);
00460       
00461       \textcolor{comment}{// Compute the pattern of Q(:,k)}
00462       \textcolor{keywordflow}{if}(curIdx > nonzeroCol && mark(curIdx) != col ) 
00463       \{
00464         Qidx(nzcolQ) = curIdx;  \textcolor{comment}{// Add this row to the pattern of Q,}
00465         mark(curIdx) = col;     \textcolor{comment}{// and mark it as visited}
00466         nzcolQ++;
00467       \}
00468     \}
00469 
00470     \textcolor{comment}{// Browse all the indexes of R(:,col) in reverse order}
00471     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = nzcolR-1; i >= 0; i--)
00472     \{
00473       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} curIdx = Ridx(i);
00474       
00475       \textcolor{comment}{// Apply the curIdx-th householder vector to the current column (temporarily stored into tval)}
00476       Scalar tdot(0);
00477       
00478       \textcolor{comment}{// First compute q' * tval}
00479       tdot = m\_Q.col(curIdx).dot(tval);
00480 
00481       tdot *= m\_hcoeffs(curIdx);
00482       
00483       \textcolor{comment}{// Then update tval = tval - q * tau}
00484       \textcolor{comment}{// FIXME: tval -= tdot * m\_Q.col(curIdx) should amount to the same (need to check/add support for
       efficient "dense ?= sparse")}
00485       \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} QRMatrixType::InnerIterator itq(m\_Q, curIdx); itq; ++itq)
00486         tval(itq.row()) -= itq.value() * tdot;
00487 
00488       \textcolor{comment}{// Detect fill-in for the current column of Q}
00489       \textcolor{keywordflow}{if}(m\_etree(Ridx(i)) == nonzeroCol)
00490       \{
00491         \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} QRMatrixType::InnerIterator itq(m\_Q, curIdx); itq; ++itq)
00492         \{
00493           StorageIndex iQ = StorageIndex(itq.row());
00494           \textcolor{keywordflow}{if} (mark(iQ) != col)
00495           \{
00496             Qidx(nzcolQ++) = iQ;  \textcolor{comment}{// Add this row to the pattern of Q,}
00497             mark(iQ) = col;       \textcolor{comment}{// and mark it as visited}
00498           \}
00499         \}
00500       \}
00501     \} \textcolor{comment}{// End update current column}
00502     
00503     Scalar tau = RealScalar(0);
00504     RealScalar beta = 0;
00505     
00506     \textcolor{keywordflow}{if}(nonzeroCol < diagSize)
00507     \{
00508       \textcolor{comment}{// Compute the Householder reflection that eliminate the current column}
00509       \textcolor{comment}{// FIXME this step should call the Householder module.}
00510       Scalar c0 = nzcolQ ? tval(Qidx(0)) : Scalar(0);
00511       
00512       \textcolor{comment}{// First, the squared norm of Q((col+1):m, col)}
00513       RealScalar sqrNorm = 0.;
00514       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} itq = 1; itq < nzcolQ; ++itq) sqrNorm += numext::abs2(tval(Qidx(itq)));
00515       \textcolor{keywordflow}{if}(sqrNorm == RealScalar(0) && numext::imag(c0) == RealScalar(0))
00516       \{
00517         beta = numext::real(c0);
00518         tval(Qidx(0)) = 1;
00519       \}
00520       \textcolor{keywordflow}{else}
00521       \{
00522         \textcolor{keyword}{using} std::sqrt;
00523         beta = sqrt(numext::abs2(c0) + sqrNorm);
00524         \textcolor{keywordflow}{if}(numext::real(c0) >= RealScalar(0))
00525           beta = -beta;
00526         tval(Qidx(0)) = 1;
00527         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} itq = 1; itq < nzcolQ; ++itq)
00528           tval(Qidx(itq)) /= (c0 - beta);
00529         tau = numext::conj((beta-c0) / beta);
00530           
00531       \}
00532     \}
00533 
00534     \textcolor{comment}{// Insert values in R}
00535     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}  i = nzcolR-1; i >= 0; i--)
00536     \{
00537       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} curIdx = Ridx(i);
00538       \textcolor{keywordflow}{if}(curIdx < nonzeroCol) 
00539       \{
00540         m\_R.insertBackByOuterInnerUnordered(col, curIdx) = tval(curIdx);
00541         tval(curIdx) = Scalar(0.);
00542       \}
00543     \}
00544 
00545     \textcolor{keywordflow}{if}(nonzeroCol < diagSize && abs(beta) >= pivotThreshold)
00546     \{
00547       m\_R.insertBackByOuterInner(col, nonzeroCol) = beta;
00548       \textcolor{comment}{// The householder coefficient}
00549       m\_hcoeffs(nonzeroCol) = tau;
00550       \textcolor{comment}{// Record the householder reflections}
00551       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} itq = 0; itq < nzcolQ; ++itq)
00552       \{
00553         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} iQ = Qidx(itq);
00554         m\_Q.insertBackByOuterInnerUnordered(nonzeroCol,iQ) = tval(iQ);
00555         tval(iQ) = Scalar(0.);
00556       \}
00557       nonzeroCol++;
00558       \textcolor{keywordflow}{if}(nonzeroCol<diagSize)
00559         m\_Q.startVec(nonzeroCol);
00560     \}
00561     \textcolor{keywordflow}{else}
00562     \{
00563       \textcolor{comment}{// Zero pivot found: move implicitly this column to the end}
00564       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = nonzeroCol; j < n-1; j++) 
00565         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_pivotperm.indices()(j), m\_pivotperm.indices()[j+1]);
00566       
00567       \textcolor{comment}{// Recompute the column elimination tree}
00568       \hyperlink{namespace_eigen_1_1internal_a86181db74ba596a7afbfd89efcc5788c}{internal::coletree}(m\_pmat, m\_etree, m\_firstRowElt, m\_pivotperm.indices().data());
00569       m\_isEtreeOk = \textcolor{keyword}{false};
00570     \}
00571   \}
00572   
00573   m\_hcoeffs.tail(diagSize-nonzeroCol).setZero();
00574   
00575   \textcolor{comment}{// Finalize the column pointers of the sparse matrices R and Q}
00576   m\_Q.finalize();
00577   m\_Q.makeCompressed();
00578   m\_R.finalize();
00579   m\_R.makeCompressed();
00580   m\_isQSorted = \textcolor{keyword}{false};
00581 
00582   m\_nonzeropivots = nonzeroCol;
00583   
00584   \textcolor{keywordflow}{if}(nonzeroCol<n)
00585   \{
00586     \textcolor{comment}{// Permute the triangular factor to put the 'dead' columns to the end}
00587     \hyperlink{group___sparse_core___module}{QRMatrixType} tempR(m\_R);
00588     m\_R = tempR * m\_pivotperm;
00589     
00590     \textcolor{comment}{// Update the column permutation}
00591     m\_outputPerm\_c = m\_outputPerm\_c * m\_pivotperm;
00592   \}
00593   
00594   m\_isInitialized = \textcolor{keyword}{true}; 
00595   m\_factorizationIsok = \textcolor{keyword}{true};
00596   m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00597 \}
00598 
00599 \textcolor{keyword}{template} <\textcolor{keyword}{typename} SparseQRType, \textcolor{keyword}{typename} Derived>
00600 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_sparse_q_r___q_product}{SparseQR\_QProduct} : \hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue}<SparseQR\_QProduct<SparseQRType, Deri
      ved> >
00601 \{
00602   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseQRType::QRMatrixType MatrixType;
00603   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseQRType::Scalar Scalar;
00604   \textcolor{comment}{// Get the references }
00605   \hyperlink{struct_eigen_1_1_sparse_q_r___q_product}{SparseQR\_QProduct}(\textcolor{keyword}{const} SparseQRType& qr, \textcolor{keyword}{const} Derived& other, \textcolor{keywordtype}{bool} transpose) : 
00606   m\_qr(qr),m\_other(other),m\_transpose(transpose) \{\}
00607   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_transpose ? m\_qr.rows() : m\_qr.cols(); \}
00608   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_other.cols(); \}
00609   
00610   \textcolor{comment}{// Assign to a vector}
00611   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DesType>
00612   \textcolor{keywordtype}{void} evalTo(DesType& res)\textcolor{keyword}{ const}
00613 \textcolor{keyword}{  }\{
00614     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m = m\_qr.rows();
00615     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = m\_qr.cols();
00616     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} diagSize = (std::min)(m,n);
00617     res = m\_other;
00618     \textcolor{keywordflow}{if} (m\_transpose)
00619     \{
00620       eigen\_assert(m\_qr.m\_Q.rows() == m\_other.rows() && \textcolor{stringliteral}{"Non conforming object sizes"});
00621       \textcolor{comment}{//Compute res = Q' * other column by column}
00622       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < res.cols(); j++)\{
00623         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = 0; k < diagSize; k++)
00624         \{
00625           Scalar tau = Scalar(0);
00626           tau = m\_qr.m\_Q.col(k).dot(res.col(j));
00627           \textcolor{keywordflow}{if}(tau==Scalar(0)) \textcolor{keywordflow}{continue};
00628           tau = tau * m\_qr.m\_hcoeffs(k);
00629           res.col(j) -= tau * m\_qr.m\_Q.col(k);
00630         \}
00631       \}
00632     \}
00633     \textcolor{keywordflow}{else}
00634     \{
00635       eigen\_assert(m\_qr.m\_Q.rows() == m\_other.rows() && \textcolor{stringliteral}{"Non conforming object sizes"});
00636       \textcolor{comment}{// Compute res = Q * other column by column}
00637       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < res.cols(); j++)
00638       \{
00639         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = diagSize-1; k >=0; k--)
00640         \{
00641           Scalar tau = Scalar(0);
00642           tau = m\_qr.m\_Q.col(k).dot(res.col(j));
00643           \textcolor{keywordflow}{if}(tau==Scalar(0)) \textcolor{keywordflow}{continue};
00644           tau = tau * m\_qr.m\_hcoeffs(k);
00645           res.col(j) -= tau * m\_qr.m\_Q.col(k);
00646         \}
00647       \}
00648     \}
00649   \}
00650   
00651   \textcolor{keyword}{const} SparseQRType& m\_qr;
00652   \textcolor{keyword}{const} Derived& m\_other;
00653   \textcolor{keywordtype}{bool} m\_transpose;
00654 \};
00655 
00656 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseQRType>
00657 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SparseQRMatrixQReturnType} : \textcolor{keyword}{public} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase}<SparseQRMatrixQReturn
      Type<SparseQRType> >
00658 \{  
00659   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseQRType::Scalar Scalar;
00660   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} 
      \hyperlink{group___core___module}{DenseMatrix};
00661   \textcolor{keyword}{enum} \{
00662     RowsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00663     ColsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}
00664   \};
00665   \textcolor{keyword}{explicit} \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SparseQRMatrixQReturnType}(\textcolor{keyword}{const} SparseQRType& qr) : m\_qr(qr) \{\}
00666   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00667   \hyperlink{struct_eigen_1_1_sparse_q_r___q_product}{SparseQR\_QProduct<SparseQRType, Derived>} operator*(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& other)
00668   \{
00669     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_sparse_q_r___q_product}{SparseQR\_QProduct<SparseQRType,Derived>}(m\_qr,other.
      derived(),\textcolor{keyword}{false});
00670   \}
00671   \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_transpose_return_type}{SparseQRMatrixQTransposeReturnType<SparseQRType>} adjoint(
      )\textcolor{keyword}{ const}
00672 \textcolor{keyword}{  }\{
00673     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_transpose_return_type}{SparseQRMatrixQTransposeReturnType<SparseQRType>}
      (m\_qr);
00674   \}
00675   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_qr.rows(); \}
00676   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} (std::min)(m\_qr.rows(),m\_qr.cols()); \}
00677   \textcolor{comment}{// To use for operations with the transpose of Q}
00678   \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_transpose_return_type}{SparseQRMatrixQTransposeReturnType<SparseQRType>} 
      transpose()\textcolor{keyword}{ const}
00679 \textcolor{keyword}{  }\{
00680     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_transpose_return_type}{SparseQRMatrixQTransposeReturnType<SparseQRType>}
      (m\_qr);
00681   \}
00682   \textcolor{keyword}{const} SparseQRType& m\_qr;
00683 \};
00684 
00685 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseQRType>
00686 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_transpose_return_type}{SparseQRMatrixQTransposeReturnType}
00687 \{
00688   \textcolor{keyword}{explicit} \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_transpose_return_type}{SparseQRMatrixQTransposeReturnType}(\textcolor{keyword}{const} SparseQRType& qr) : 
      m\_qr(qr) \{\}
00689   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00690   \hyperlink{struct_eigen_1_1_sparse_q_r___q_product}{SparseQR\_QProduct<SparseQRType,Derived>} operator*(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>}& other)
00691   \{
00692     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1_sparse_q_r___q_product}{SparseQR\_QProduct<SparseQRType,Derived>}(m\_qr,other.
      derived(), \textcolor{keyword}{true});
00693   \}
00694   \textcolor{keyword}{const} SparseQRType& m\_qr;
00695 \};
00696 
00697 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00698   
00699 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseQRType>
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00700}\hyperlink{struct_eigen_1_1internal_1_1evaluator__traits_3_01_sparse_q_r_matrix_q_return_type_3_01_sparse_q_r_type_01_4_01_4}{00700} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1evaluator__traits}{evaluator\_traits}<\hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SparseQRMatrixQReturnType}<SparseQRType> >
00701 \{
00702   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseQRType::MatrixType MatrixType;
00703   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1_index_based}{storage\_kind\_to\_evaluator\_kind<typename MatrixType::StorageKind>::Kind}
       \hyperlink{struct_eigen_1_1internal_1_1_index_based}{Kind};
00704   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_sparse_shape}{SparseShape} \hyperlink{struct_eigen_1_1_sparse_shape}{Shape};
00705 \};
00706 
00707 \textcolor{keyword}{template}< \textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SparseQRType>
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00708}\hyperlink{struct_eigen_1_1internal_1_1_assignment_3_01_dst_xpr_type_00_01_sparse_q_r_matrix_q_return_type_359637caee80b00c35b5e63bb0a6509c}{00708} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment}{Assignment}<DstXprType, \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SparseQRMatrixQReturnType}<SparseQRType>, 
      \hyperlink{namespaceinternal}{internal}::\hyperlink{struct_eigen_1_1internal_1_1assign__op}{assign\_op}<typename DstXprType::Scalar,typename DstXprType::Scalar>, 
      \hyperlink{struct_eigen_1_1internal_1_1_sparse2_sparse}{Sparse2Sparse}>
00709 \{
00710   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SparseQRMatrixQReturnType<SparseQRType>} 
      \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SrcXprType};
00711   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::Scalar Scalar;
00712   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::StorageIndex StorageIndex;
00713   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<Scalar,Scalar>} &\textcolor{comment}{/*func*/})
00714   \{
00715     \textcolor{keyword}{typename} DstXprType::PlainObject idMat(src.m\_qr.rows(), src.m\_qr.rows());
00716     idMat.setIdentity();
00717     \textcolor{comment}{// Sort the sparse householder reflectors if needed}
00718     \textcolor{keyword}{const\_cast<}SparseQRType *\textcolor{keyword}{>}(&src.m\_qr)->\_sort\_matrix\_Q();
00719     dst = \hyperlink{struct_eigen_1_1_sparse_q_r___q_product}{SparseQR\_QProduct<SparseQRType, DstXprType>}(src.m\_qr, 
      idMat, \textcolor{keyword}{false});
00720   \}
00721 \};
00722 
00723 \textcolor{keyword}{template}< \textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SparseQRType>
\Hypertarget{eigen_2_eigen_2src_2_sparse_q_r_2_sparse_q_r_8h_source_l00724}\hyperlink{struct_eigen_1_1internal_1_1_assignment_3_01_dst_xpr_type_00_01_sparse_q_r_matrix_q_return_type_aa91d8fc26832a494363cd7146c14303}{00724} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment}{Assignment}<DstXprType, \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SparseQRMatrixQReturnType}<SparseQRType>, 
      \hyperlink{namespaceinternal}{internal}::\hyperlink{struct_eigen_1_1internal_1_1assign__op}{assign\_op}<typename DstXprType::Scalar,typename DstXprType::Scalar>, 
      \hyperlink{struct_eigen_1_1internal_1_1_sparse2_dense}{Sparse2Dense}>
00725 \{
00726   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SparseQRMatrixQReturnType<SparseQRType>} 
      \hyperlink{struct_eigen_1_1_sparse_q_r_matrix_q_return_type}{SrcXprType};
00727   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::Scalar Scalar;
00728   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::StorageIndex StorageIndex;
00729   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<Scalar,Scalar>} &\textcolor{comment}{/*func*/})
00730   \{
00731     dst = src.m\_qr.matrixQ() * DstXprType::Identity(src.m\_qr.rows(), src.m\_qr.rows());
00732   \}
00733 \};
00734 
00735 \} \textcolor{comment}{// end namespace internal}
00736 
00737 \} \textcolor{comment}{// end namespace Eigen}
00738 
00739 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
