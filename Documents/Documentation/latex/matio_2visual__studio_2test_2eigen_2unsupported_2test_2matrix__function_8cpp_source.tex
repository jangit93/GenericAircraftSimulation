\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2test_2matrix__function_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/test/matrix\+\_\+function.cpp}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2test_2matrix__function_8cpp_source}\index{matrix\+\_\+function.\+cpp@{matrix\+\_\+function.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2010 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 \textcolor{preprocessor}{#include <unsupported/Eigen/MatrixFunctions>}
00012 
00013 \textcolor{comment}{// Variant of VERIFY\_IS\_APPROX which uses absolute error instead of}
00014 \textcolor{comment}{// relative error.}
00015 \textcolor{preprocessor}{#define VERIFY\_IS\_APPROX\_ABS(a, b) VERIFY(test\_isApprox\_abs(a, b))}
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Type1, \textcolor{keyword}{typename} Type2>
00018 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox\_abs(\textcolor{keyword}{const} Type1& a, \textcolor{keyword}{const} Type2& b)
00019 \{
00020   \textcolor{keywordflow}{return} ((a-b).array().abs() < test\_precision<typename Type1::RealScalar>()).all();
00021 \}
00022 
00023 
00024 \textcolor{comment}{// Returns a matrix with eigenvalues clustered around 0, 1 and 2.}
00025 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00026 MatrixType randomMatrixWithRealEivals(\textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::Index size)
00027 \{
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00031   MatrixType diag = MatrixType::Zero(size, size);
00032   \textcolor{keywordflow}{for} (Index i = 0; i < size; ++i) \{
00033     diag(i, i) = Scalar(RealScalar(internal::random<int>(0,2)))
00034       + internal::random<Scalar>() * Scalar(RealScalar(0.01));
00035   \}
00036   MatrixType A = MatrixType::Random(size, size);
00037   HouseholderQR<MatrixType> QRofA(A);
00038   \textcolor{keywordflow}{return} QRofA.householderQ().inverse() * diag * QRofA.householderQ();
00039 \}
00040 
00041 template <typename MatrixType, int IsComplex = NumTraits<typename internal::traits<MatrixType>::Scalar>
      ::IsComplex>
00042 \textcolor{keyword}{struct }\hyperlink{structrandom_matrix_with_imag_eivals}{randomMatrixWithImagEivals}
00043 \{
00044   \textcolor{comment}{// Returns a matrix with eigenvalues clustered around 0 and +/- i.}
00045   \textcolor{keyword}{static} MatrixType run(\textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::Index size);
00046 \};
00047 
00048 \textcolor{comment}{// Partial specialization for real matrices}
00049 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00050 \textcolor{keyword}{struct }\hyperlink{structrandom_matrix_with_imag_eivals}{randomMatrixWithImagEivals}<MatrixType, 0>
00051 \{
00052   \textcolor{keyword}{static} MatrixType run(\textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::Index size)
00053   \{
00054     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index Index;
00055     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00056     MatrixType diag = MatrixType::Zero(size, size);
00057     Index i = 0;
00058     \textcolor{keywordflow}{while} (i < size) \{
00059       Index randomInt = internal::random<Index>(-1, 1);
00060       \textcolor{keywordflow}{if} (randomInt == 0 || i == size-1) \{
00061         diag(i, i) = internal::random<Scalar>() * Scalar(0.01);
00062         ++i;
00063       \} \textcolor{keywordflow}{else} \{
00064         Scalar alpha = Scalar(randomInt) + internal::random<Scalar>() * Scalar(0.01);
00065         diag(i, i+1) = alpha;
00066         diag(i+1, i) = -alpha;
00067         i += 2;
00068       \}
00069     \}
00070     MatrixType A = MatrixType::Random(size, size);
00071     HouseholderQR<MatrixType> QRofA(A);
00072     \textcolor{keywordflow}{return} QRofA.householderQ().inverse() * diag * QRofA.householderQ();
00073   \}
00074 \};
00075 
00076 \textcolor{comment}{// Partial specialization for complex matrices}
00077 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00078 \textcolor{keyword}{struct }\hyperlink{structrandom_matrix_with_imag_eivals}{randomMatrixWithImagEivals}<MatrixType, 1>
00079 \{
00080   \textcolor{keyword}{static} MatrixType run(\textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::Index size)
00081   \{
00082     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index Index;
00083     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00084     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00085     \textcolor{keyword}{const} Scalar imagUnit(0, 1);
00086     MatrixType diag = MatrixType::Zero(size, size);
00087     \textcolor{keywordflow}{for} (Index i = 0; i < size; ++i) \{
00088       diag(i, i) = Scalar(RealScalar(internal::random<Index>(-1, 1))) * imagUnit
00089         + internal::random<Scalar>() * Scalar(RealScalar(0.01));
00090     \}
00091     MatrixType A = MatrixType::Random(size, size);
00092     HouseholderQR<MatrixType> QRofA(A);
00093     \textcolor{keywordflow}{return} QRofA.householderQ().inverse() * diag * QRofA.householderQ();
00094   \}
00095 \};
00096 
00097 
00098 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00099 \textcolor{keywordtype}{void} testMatrixExponential(\textcolor{keyword}{const} MatrixType& A)
00100 \{
00101   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<MatrixType>::Scalar Scalar;
00102   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar;
00103   \textcolor{keyword}{typedef} std::complex<RealScalar> ComplexScalar;
00104 
00105   VERIFY\_IS\_APPROX(A.exp(), A.matrixFunction(internal::stem\_function\_exp<ComplexScalar>));
00106 \}
00107 
00108 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00109 \textcolor{keywordtype}{void} testMatrixLogarithm(\textcolor{keyword}{const} MatrixType& A)
00110 \{
00111   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<MatrixType>::Scalar Scalar;
00112   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar;
00113 
00114   MatrixType scaledA;
00115   RealScalar maxImagPartOfSpectrum = A.eigenvalues().imag().cwiseAbs().maxCoeff();
00116   \textcolor{keywordflow}{if} (maxImagPartOfSpectrum >= RealScalar(0.9L * EIGEN\_PI))
00117     scaledA = A * RealScalar(0.9L * EIGEN\_PI) / maxImagPartOfSpectrum;
00118   \textcolor{keywordflow}{else}
00119     scaledA = A;
00120 
00121   \textcolor{comment}{// identity X.exp().log() = X only holds if Im(lambda) < pi for all eigenvalues of X}
00122   MatrixType expA = scaledA.exp();
00123   MatrixType logExpA = expA.log();
00124   VERIFY\_IS\_APPROX(logExpA, scaledA);
00125 \}
00126 
00127 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00128 \textcolor{keywordtype}{void} testHyperbolicFunctions(\textcolor{keyword}{const} MatrixType& A)
00129 \{
00130   \textcolor{comment}{// Need to use absolute error because of possible cancellation when}
00131   \textcolor{comment}{// adding/subtracting expA and expmA.}
00132   VERIFY\_IS\_APPROX\_ABS(A.sinh(), (A.exp() - (-A).exp()) / 2);
00133   VERIFY\_IS\_APPROX\_ABS(A.cosh(), (A.exp() + (-A).exp()) / 2);
00134 \}
00135 
00136 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00137 \textcolor{keywordtype}{void} testGonioFunctions(\textcolor{keyword}{const} MatrixType& A)
00138 \{
00139   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00140   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar;
00141   \textcolor{keyword}{typedef} std::complex<RealScalar> ComplexScalar;
00142   \textcolor{keyword}{typedef} Matrix<ComplexScalar, MatrixType::RowsAtCompileTime, 
00143                  MatrixType::ColsAtCompileTime, MatrixType::Options> ComplexMatrix;
00144 
00145   ComplexScalar imagUnit(0,1);
00146   ComplexScalar two(2,0);
00147 
00148   ComplexMatrix Ac = A.template cast<ComplexScalar>();
00149   
00150   ComplexMatrix exp\_iA = (imagUnit * Ac).exp();
00151   ComplexMatrix exp\_miA = (-imagUnit * Ac).exp();
00152   
00153   ComplexMatrix sinAc = A.sin().template cast<ComplexScalar>();
00154   VERIFY\_IS\_APPROX\_ABS(sinAc, (exp\_iA - exp\_miA) / (two*imagUnit));
00155   
00156   ComplexMatrix cosAc = A.cos().template cast<ComplexScalar>();
00157   VERIFY\_IS\_APPROX\_ABS(cosAc, (exp\_iA + exp\_miA) / 2);
00158 \}
00159 
00160 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00161 \textcolor{keywordtype}{void} testMatrix(\textcolor{keyword}{const} MatrixType& A)
00162 \{
00163   testMatrixExponential(A);
00164   testMatrixLogarithm(A);
00165   testHyperbolicFunctions(A);
00166   testGonioFunctions(A);
00167 \}
00168 
00169 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00170 \textcolor{keywordtype}{void} testMatrixType(\textcolor{keyword}{const} MatrixType& m)
00171 \{
00172   \textcolor{comment}{// Matrices with clustered eigenvalue lead to different code paths}
00173   \textcolor{comment}{// in MatrixFunction.h and are thus useful for testing.}
00174   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Index Index;
00175 
00176   \textcolor{keyword}{const} Index size = m.rows();
00177   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00178     testMatrix(MatrixType::Random(size, size).eval());
00179     testMatrix(randomMatrixWithRealEivals<MatrixType>(size));
00180     testMatrix(\hyperlink{structrandom_matrix_with_imag_eivals}{randomMatrixWithImagEivals<MatrixType>::run}(size)
      );
00181   \}
00182 \}
00183 
00184 \textcolor{keywordtype}{void} test\_matrix\_function()
00185 \{
00186   CALL\_SUBTEST\_1(testMatrixType(Matrix<float,1,1>()));
00187   CALL\_SUBTEST\_2(testMatrixType(Matrix3cf()));
00188   CALL\_SUBTEST\_3(testMatrixType(MatrixXf(8,8)));
00189   CALL\_SUBTEST\_4(testMatrixType(Matrix2d()));
00190   CALL\_SUBTEST\_5(testMatrixType(Matrix<double,5,5,RowMajor>()));
00191   CALL\_SUBTEST\_6(testMatrixType(Matrix4cd()));
00192   CALL\_SUBTEST\_7(testMatrixType(MatrixXd(13,13)));
00193 \}
\end{DoxyCode}
