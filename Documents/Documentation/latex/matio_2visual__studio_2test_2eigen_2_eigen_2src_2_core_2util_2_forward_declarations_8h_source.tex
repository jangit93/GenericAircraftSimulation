\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2util_2_forward_declarations_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/util/\+Forward\+Declarations.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2util_2_forward_declarations_8h_source}\index{Forward\+Declarations.\+h@{Forward\+Declarations.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2007-2010 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_FORWARDDECLARATIONS\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_FORWARDDECLARATIONS\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }traits;
00018 
00019 \textcolor{comment}{// here we say once and for all that traits<const T> == traits<T>}
00020 \textcolor{comment}{// When constness must affect traits, it has to be constness on template parameters on which T itself
       depends.}
00021 \textcolor{comment}{// For example, traits<Map<const T> > != traits<Map<T> >, but}
00022 \textcolor{comment}{//              traits<const Map<T> > == traits<Map<T> >}
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }traits<const \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}> : traits<T> \{\};
00024 
00025 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{struct }has\_direct\_access
00026 \{
00027   \textcolor{keyword}{enum} \{ ret = (traits<Derived>::Flags & \hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit}) ? 1 : 0 \};
00028 \};
00029 
00030 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{struct }accessors\_level
00031 \{
00032   \textcolor{keyword}{enum} \{ has\_direct\_access = (traits<Derived>::Flags & \hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit}) ? 1 : 0,
00033          has\_write\_access = (traits<Derived>::Flags & \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit}) ? 1 : 0,
00034          value = has\_direct\_access ? (has\_write\_access ? \hyperlink{group__enums_gga9f93eac38eb83deb0e8dbd42ddf11d5dae218802d4436c6907e60368c28609472}{DirectWriteAccessors} : 
      \hyperlink{group__enums_gga9f93eac38eb83deb0e8dbd42ddf11d5da47996b52dd3a8c298a8821675a557c55}{DirectAccessors})
00035                                    : (has\_write\_access ? \hyperlink{group__enums_gga9f93eac38eb83deb0e8dbd42ddf11d5da2c59ef3697d65866c3a8e16eda7881ab}{WriteAccessors}       : 
      \hyperlink{group__enums_gga9f93eac38eb83deb0e8dbd42ddf11d5da42865f87356ad7e585a1bfbfd1b81699}{ReadOnlyAccessors})
00036   \};
00037 \};
00038 
00039 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }evaluator\_traits;
00040 
00041 \textcolor{keyword}{template}< \textcolor{keyword}{typename} T> \textcolor{keyword}{struct }evaluator;
00042 
00043 \} \textcolor{comment}{// end namespace internal}
00044 
00045 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }NumTraits;
00046 
00047 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{struct }EigenBase;
00048 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }DenseBase;
00049 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }PlainObjectBase;
00050 
00051 
00052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived,
00053          \textcolor{keywordtype}{int} Level = internal::accessors\_level<Derived>::value >
00054 \textcolor{keyword}{class }DenseCoeffsBase;
00055 
00056 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Rows, \textcolor{keywordtype}{int} \_Cols,
00057          \textcolor{keywordtype}{int} \_Options = \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a28d63c0dd8560827162decfd898804f4}{AutoAlign} |
00058 \textcolor{preprocessor}{#if EIGEN\_GNUC\_AT(3,4)}
00059     \textcolor{comment}{// workaround a bug in at least gcc 3.4.6}
00060     \textcolor{comment}{// the innermost ?: ternary operator is misparsed. We write it slightly}
00061     \textcolor{comment}{// differently and this makes gcc 3.4.6 happy, but it's ugly.}
00062     \textcolor{comment}{// The error would only show up with EIGEN\_DEFAULT\_TO\_ROW\_MAJOR is defined}
00063     \textcolor{comment}{// (when EIGEN\_DEFAULT\_MATRIX\_STORAGE\_ORDER\_OPTION is RowMajor)}
00064                           ( (\_Rows==1 && \_Cols!=1) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{Eigen::RowMajor}
00065                           : !(\_Cols==1 && \_Rows!=1) ?  EIGEN\_DEFAULT\_MATRIX\_STORAGE\_ORDER\_OPTION
00066                           : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{Eigen::ColMajor} ),
00067 #\textcolor{keywordflow}{else}
00068                           ( (\_Rows==1 && \_Cols!=1) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{Eigen::RowMajor}
00069                           : (\_Cols==1 && \_Rows!=1) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{Eigen::ColMajor}
00070                           : EIGEN\_DEFAULT\_MATRIX\_STORAGE\_ORDER\_OPTION ),
00071 \textcolor{preprocessor}{#endif}
00072          \textcolor{keywordtype}{int} \_MaxRows = \_Rows,
00073          \textcolor{keywordtype}{int} \_MaxCols = \_Cols
00074 > \textcolor{keyword}{class }Matrix;
00075 
00076 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }MatrixBase;
00077 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }ArrayBase;
00078 
00079 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Added, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Removed> \textcolor{keyword}{class }Flagged;
00080 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType, \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{class }StorageBase > \textcolor{keyword}{class }NoAlias;
00081 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType> \textcolor{keyword}{class }NestByValue;
00082 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType> \textcolor{keyword}{class }ForceAlignedAccess;
00083 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType> \textcolor{keyword}{class }SwapWrapper;
00084 
00085 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keywordtype}{int} BlockRows=Dynamic, \textcolor{keywordtype}{int} BlockCols=Dynamic, \textcolor{keywordtype}{bool} InnerPanel = false> \textcolor{keyword}{class }
      Block;
00086 
00087 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} Size=Dynamic> \textcolor{keyword}{class }VectorBlock;
00088 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }Transpose;
00089 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }Conjugate;
00090 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NullaryOp, \textcolor{keyword}{typename} MatrixType>         \textcolor{keyword}{class }CwiseNullaryOp;
00091 \textcolor{keyword}{template}<\textcolor{keyword}{typename} UnaryOp,   \textcolor{keyword}{typename} MatrixType>         \textcolor{keyword}{class }CwiseUnaryOp;
00092 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ViewOp,    \textcolor{keyword}{typename} MatrixType>         \textcolor{keyword}{class }CwiseUnaryView;
00093 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp,  \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>  \textcolor{keyword}{class }CwiseBinaryOp;
00094 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TernaryOp, \textcolor{keyword}{typename} Arg1, \textcolor{keyword}{typename} Arg2, \textcolor{keyword}{typename} Arg3>  \textcolor{keyword}{class }CwiseTernaryOp;
00095 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Decomposition, \textcolor{keyword}{typename} Rhstype>        \textcolor{keyword}{class }Solve;
00096 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>                                \textcolor{keyword}{class }Inverse;
00097 
00098 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} Option = DefaultProduct> \textcolor{keyword}{class }Product;
00099 
00100 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }DiagonalBase;
00101 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_DiagonalVectorType> \textcolor{keyword}{class }DiagonalWrapper;
00102 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} SizeAtCompileTime, \textcolor{keywordtype}{int} MaxSizeAtCompileTime=SizeAtCompileTime> \textcolor{keyword}{class }
      DiagonalMatrix;
00103 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} DiagonalType, \textcolor{keywordtype}{int} ProductOrder> \textcolor{keyword}{class }DiagonalProduct;
00104 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} Index = 0> \textcolor{keyword}{class }Diagonal;
00105 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SizeAtCompileTime, \textcolor{keywordtype}{int} MaxSizeAtCompileTime = SizeAtCompileTime, \textcolor{keyword}{typename} IndexType=\textcolor{keywordtype}{int}> \textcolor{keyword}{class
       }PermutationMatrix;
00106 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SizeAtCompileTime, \textcolor{keywordtype}{int} MaxSizeAtCompileTime = SizeAtCompileTime, \textcolor{keyword}{typename} IndexType=\textcolor{keywordtype}{int}> \textcolor{keyword}{class
       }Transpositions;
00107 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }PermutationBase;
00108 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }TranspositionsBase;
00109 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_IndicesType> \textcolor{keyword}{class }PermutationWrapper;
00110 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_IndicesType> \textcolor{keyword}{class }TranspositionsWrapper;
00111 
00112 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived,
00113          \textcolor{keywordtype}{int} Level = internal::accessors\_level<Derived>::has\_write\_access ? 
      \hyperlink{group__enums_gga9f93eac38eb83deb0e8dbd42ddf11d5da2c59ef3697d65866c3a8e16eda7881ab}{WriteAccessors} : \hyperlink{group__enums_gga9f93eac38eb83deb0e8dbd42ddf11d5da42865f87356ad7e585a1bfbfd1b81699}{ReadOnlyAccessors}
00114 > \textcolor{keyword}{class }MapBase;
00115 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} InnerStr\textcolor{keywordtype}{id}eAtCompileTime, \textcolor{keywordtype}{int} OuterStr\textcolor{keywordtype}{id}eAtCompileTime> \textcolor{keyword}{class }Stride;
00116 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Value = Dynamic> \textcolor{keyword}{class }InnerStride;
00117 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Value = Dynamic> \textcolor{keyword}{class }OuterStride;
00118 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} MapOptions=Unaligned, \textcolor{keyword}{typename} Str\textcolor{keywordtype}{id}eType = Str\textcolor{keywordtype}{id}e<0,0> > \textcolor{keyword}{class }Map;
00119 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }RefBase;
00120 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType, \textcolor{keywordtype}{int} Options = 0,
00121          \textcolor{keyword}{typename} StrideType = \textcolor{keyword}{typename} 
      internal::conditional<PlainObjectType::IsVectorAtCompileTime,InnerStride<1>,OuterStride<> >::type > \textcolor{keyword}{class }Ref;
00122 
00123 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }TriangularBase;
00124 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Mode> \textcolor{keyword}{class }TriangularView;
00125 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Mode> \textcolor{keyword}{class }SelfAdjointView;
00126 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }SparseView;
00127 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType> \textcolor{keyword}{class }WithFormat;
00128 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{struct }CommaInitializer;
00129 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }ReturnByValue;
00130 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType> \textcolor{keyword}{class }ArrayWrapper;
00131 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType> \textcolor{keyword}{class }MatrixWrapper;
00132 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }SolverBase;
00133 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType> \textcolor{keyword}{class }InnerIterator;
00134 
00135 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00136 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DecompositionType> \textcolor{keyword}{struct }kernel\_retval\_base;
00137 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DecompositionType> \textcolor{keyword}{struct }kernel\_retval;
00138 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DecompositionType> \textcolor{keyword}{struct }image\_retval\_base;
00139 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DecompositionType> \textcolor{keyword}{struct }image\_retval;
00140 \} \textcolor{comment}{// end namespace internal}
00141 
00142 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00143 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} Rows=Dynamic, \textcolor{keywordtype}{int} Cols=Dynamic, \textcolor{keywordtype}{int} Supers=Dynamic, \textcolor{keywordtype}{int} Subs=Dynamic, \textcolor{keywordtype}{int} Op
      tions=0> \textcolor{keyword}{class }BandMatrix;
00144 \}
00145 
00146 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00147 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs> \textcolor{keyword}{struct }product\_type;
00148 
00149 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool}> \textcolor{keyword}{struct }EnableIf;
00150 
00156 \textcolor{keyword}{template}< \textcolor{keyword}{typename} T,
00157           \textcolor{keywordtype}{int} ProductTag = internal::product\_type<typename T::Lhs,typename T::Rhs>::ret,
00158           \textcolor{keyword}{typename} LhsShape = \textcolor{keyword}{typename} evaluator\_traits<typename T::Lhs>::Shape,
00159           \textcolor{keyword}{typename} RhsShape = \textcolor{keyword}{typename} evaluator\_traits<typename T::Rhs>::Shape,
00160           \textcolor{keyword}{typename} LhsScalar = \textcolor{keyword}{typename} traits<typename T::Lhs>::Scalar,
00161           \textcolor{keyword}{typename} RhsScalar = \textcolor{keyword}{typename} traits<typename T::Rhs>::Scalar
00162         > \textcolor{keyword}{struct }product\_evaluator;
00163 \}
00164 
00165 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs,
00166          \textcolor{keywordtype}{int} ProductType = internal::product\_type<Lhs,Rhs>::value>
00167 \textcolor{keyword}{struct }ProductReturnType;
00168 
00169 \textcolor{comment}{// this is a workaround for sun CC}
00170 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs> \textcolor{keyword}{struct }LazyProductReturnType;
00171 
00172 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00173 
00174 \textcolor{comment}{// Provides scalar/packet-wise product and product with accumulation}
00175 \textcolor{comment}{// with optional conjugation of the arguments.}
00176 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{bool} ConjLhs=false, \textcolor{keywordtype}{bool} ConjRhs=false> \textcolor{keyword}{struct }conj\_helper
      ;
00177 
00178 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar=LhsScalar> \textcolor{keyword}{struct }scalar\_sum\_op;
00179 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar=LhsScalar> \textcolor{keyword}{struct }scalar\_difference\_op;
00180 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar=LhsScalar> \textcolor{keyword}{struct }scalar\_conj\_product\_op;
00181 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar=LhsScalar> \textcolor{keyword}{struct }scalar\_min\_op;
00182 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar=LhsScalar> \textcolor{keyword}{struct }scalar\_max\_op;
00183 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_opposite\_op;
00184 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_conjugate\_op;
00185 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_real\_op;
00186 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_imag\_op;
00187 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_abs\_op;
00188 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_abs2\_op;
00189 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_sqrt\_op;
00190 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_rsqrt\_op;
00191 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_exp\_op;
00192 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_log\_op;
00193 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_cos\_op;
00194 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_sin\_op;
00195 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_acos\_op;
00196 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_asin\_op;
00197 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_tan\_op;
00198 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_inverse\_op;
00199 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_square\_op;
00200 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_cube\_op;
00201 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} NewType> \textcolor{keyword}{struct }scalar\_cast\_op;
00202 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_random\_op;
00203 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_constant\_op;
00204 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_identity\_op;
00205 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keywordtype}{bool} iscpx> \textcolor{keyword}{struct }scalar\_sign\_op;
00206 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keyword}{typename} ScalarExponent> \textcolor{keyword}{struct }scalar\_pow\_op;
00207 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar=LhsScalar> \textcolor{keyword}{struct }scalar\_hypot\_op;
00208 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar=LhsScalar> \textcolor{keyword}{struct }scalar\_product\_op;
00209 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar,\textcolor{keyword}{typename} RhsScalar=LhsScalar> \textcolor{keyword}{struct }scalar\_quotient\_op;
00210 
00211 \textcolor{comment}{// SpecialFunctions module}
00212 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_lgamma\_op;
00213 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_digamma\_op;
00214 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_erf\_op;
00215 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_erfc\_op;
00216 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_igamma\_op;
00217 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_igammac\_op;
00218 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_zeta\_op;
00219 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }scalar\_betainc\_op;
00220 
00221 \} \textcolor{comment}{// end namespace internal}
00222 
00223 \textcolor{keyword}{struct }IOFormat;
00224 
00225 \textcolor{comment}{// Array module}
00226 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Rows, \textcolor{keywordtype}{int} \_Cols,
00227          \textcolor{keywordtype}{int} \_Options = \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a28d63c0dd8560827162decfd898804f4}{AutoAlign} |
00228 \textcolor{preprocessor}{#if EIGEN\_GNUC\_AT(3,4)}
00229     \textcolor{comment}{// workaround a bug in at least gcc 3.4.6}
00230     \textcolor{comment}{// the innermost ?: ternary operator is misparsed. We write it slightly}
00231     \textcolor{comment}{// differently and this makes gcc 3.4.6 happy, but it's ugly.}
00232     \textcolor{comment}{// The error would only show up with EIGEN\_DEFAULT\_TO\_ROW\_MAJOR is defined}
00233     \textcolor{comment}{// (when EIGEN\_DEFAULT\_MATRIX\_STORAGE\_ORDER\_OPTION is RowMajor)}
00234                           ( (\_Rows==1 && \_Cols!=1) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{Eigen::RowMajor}
00235                           : !(\_Cols==1 && \_Rows!=1) ?  EIGEN\_DEFAULT\_MATRIX\_STORAGE\_ORDER\_OPTION
00236                           : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{Eigen::ColMajor} ),
00237 #\textcolor{keywordflow}{else}
00238                           ( (\_Rows==1 && \_Cols!=1) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{Eigen::RowMajor}
00239                           : (\_Cols==1 && \_Rows!=1) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{Eigen::ColMajor}
00240                           : EIGEN\_DEFAULT\_MATRIX\_STORAGE\_ORDER\_OPTION ),
00241 \textcolor{preprocessor}{#endif}
00242          \textcolor{keywordtype}{int} \_MaxRows = \_Rows, \textcolor{keywordtype}{int} \_MaxCols = \_Cols> \textcolor{keyword}{class }Array;
00243 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ConditionMatrixType, \textcolor{keyword}{typename} ThenMatrixType, \textcolor{keyword}{typename} ElseMatrixType> \textcolor{keyword}{class }Select;
00244 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} BinaryOp, \textcolor{keywordtype}{int} Direction> \textcolor{keyword}{class }PartialReduxExpr;
00245 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType, \textcolor{keywordtype}{int} Direction> \textcolor{keyword}{class }VectorwiseOp;
00246 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType,\textcolor{keywordtype}{int} RowFactor,\textcolor{keywordtype}{int} ColFactor> \textcolor{keyword}{class }Replicate;
00247 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} Direction = BothDirections> \textcolor{keyword}{class }Reverse;
00248 
00249 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }FullPivLU;
00250 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }PartialPivLU;
00251 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00252 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{struct }inverse\_impl;
00253 \}
00254 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }HouseholderQR;
00255 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }ColPivHouseholderQR;
00256 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }FullPivHouseholderQR;
00257 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }CompleteOrthogonalDecomposition;
00258 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} QRPreconditioner = ColPivHouseholderQRPreconditioner> \textcolor{keyword}{class }JacobiSVD;
00259 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType> \textcolor{keyword}{class }BDCSVD;
00260 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} UpLo = Lower> \textcolor{keyword}{class }LLT;
00261 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} UpLo = Lower> \textcolor{keyword}{class }LDLT;
00262 \textcolor{keyword}{template}<\textcolor{keyword}{typename} VectorsType, \textcolor{keyword}{typename} CoeffsType, \textcolor{keywordtype}{int} S\textcolor{keywordtype}{id}e=OnTheLeft> \textcolor{keyword}{class }HouseholderSequence;
00263 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>     \textcolor{keyword}{class }JacobiRotation;
00264 
00265 \textcolor{comment}{// Geometry module:}
00266 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keywordtype}{int} \_Dim> \textcolor{keyword}{class }RotationBase;
00267 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs> \textcolor{keyword}{class }Cross;
00268 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }QuaternionBase;
00269 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{class }Rotation2D;
00270 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{class }AngleAxis;
00271 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keywordtype}{int} Dim> \textcolor{keyword}{class }Translation;
00272 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keywordtype}{int} Dim> \textcolor{keyword}{class }AlignedBox;
00273 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Options = AutoAlign> \textcolor{keyword}{class }Quaternion;
00274 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keywordtype}{int} Dim,\textcolor{keywordtype}{int} Mode,\textcolor{keywordtype}{int} \_Options=AutoAlign> \textcolor{keyword}{class }Transform;
00275 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_AmbientDim, \textcolor{keywordtype}{int} Options=AutoAlign> \textcolor{keyword}{class }ParametrizedLine;
00276 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_AmbientDim, \textcolor{keywordtype}{int} Options=AutoAlign> \textcolor{keyword}{class }Hyperplane;
00277 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{class }UniformScaling;
00278 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType,\textcolor{keywordtype}{int} Direction> \textcolor{keyword}{class }Homogeneous;
00279 
00280 \textcolor{comment}{// Sparse module:}
00281 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }SparseMatrixBase;
00282 
00283 \textcolor{comment}{// MatrixFunctions module}
00284 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{struct }MatrixExponentialReturnValue;
00285 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }MatrixFunctionReturnValue;
00286 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }MatrixSquareRootReturnValue;
00287 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }MatrixLogarithmReturnValue;
00288 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }MatrixPowerReturnValue;
00289 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived> \textcolor{keyword}{class }MatrixComplexPowerReturnValue;
00290 
00291 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00292 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00293 \textcolor{keyword}{struct }stem\_function
00294 \{
00295   \textcolor{keyword}{typedef} std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;
00296   \textcolor{keyword}{typedef} ComplexScalar type(ComplexScalar, \textcolor{keywordtype}{int});
00297 \};
00298 \}
00299 
00300 \} \textcolor{comment}{// end namespace Eigen}
00301 
00302 \textcolor{preprocessor}{#endif // EIGEN\_FORWARDDECLARATIONS\_H}
\end{DoxyCode}
