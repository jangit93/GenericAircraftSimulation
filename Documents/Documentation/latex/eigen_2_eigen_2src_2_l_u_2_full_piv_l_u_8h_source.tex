\hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source}{}\section{eigen/\+Eigen/src/\+L\+U/\+Full\+Piv\+LU.h}
\label{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source}\index{Full\+Piv\+L\+U.\+h@{Full\+Piv\+L\+U.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2006-2009 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_LU\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_LU\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00016}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_full_piv_l_u_3_01___matrix_type_01_4_01_4}{00016} \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU}<\_MatrixType> >
00017  : \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\_MatrixType>
00018 \{
00019   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_matrix_xpr}{MatrixXpr} \hyperlink{struct_eigen_1_1_matrix_xpr}{XprKind};
00020   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_solver_storage}{SolverStorage} \hyperlink{struct_eigen_1_1_solver_storage}{StorageKind};
00021   \textcolor{keyword}{enum} \{ Flags = 0 \};
00022 \};
00023 
00024 \} \textcolor{comment}{// end namespace internal}
00025 
00059 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType> \textcolor{keyword}{class }\hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU}
00060   : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_solver_base}{SolverBase}<FullPivLU<\_MatrixType> >
00061 \{
00062   \textcolor{keyword}{public}:
00063     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00064     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_solver_base}{SolverBase<FullPivLU>} Base;
00065 
00066     EIGEN\_GENERIC\_PUBLIC\_INTERFACE(\hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU})
00067     \textcolor{comment}{// FIXME StorageIndex defined in EIGEN\_GENERIC\_PUBLIC\_INTERFACE should be int}
00068     \textcolor{keyword}{enum} \{
00069       MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
00070       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
00071     \};
00072     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::plain\_row\_type<MatrixType, StorageIndex>::type}
       IntRowVectorType;
00073     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::plain\_col\_type<MatrixType, StorageIndex>::type}
       IntColVectorType;
00074     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime>}
       PermutationQType;
00075     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime>}
       PermutationPType;
00076     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::PlainObject PlainObject;
00077 
00084     \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU}();
00085 
00092     \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols);
00093 
00099     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>
00100     \textcolor{keyword}{explicit} \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU}(\textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<InputType>}& matrix);
00101 
00108     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>
00109     \textcolor{keyword}{explicit} \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU}(\hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<InputType>}& matrix);
00110 
00118     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00119}\hyperlink{group___l_u___module_a0a3c3b1bbafa31a03567a4573ebabc79}{00119}     \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU}& \hyperlink{group___l_u___module_a0a3c3b1bbafa31a03567a4573ebabc79}{compute}(\textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<InputType>}& matrix) \{
00120       m\_lu = matrix.\hyperlink{group___core___module_a324b16961a11d2ecfd2d1b7dd7946545}{derived}();
00121       computeInPlace();
00122       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00123     \}
00124 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00131}\hyperlink{group___l_u___module_afea0b8fc707a9097d46fe358cb18bbff}{00131}     \textcolor{keyword}{inline} \textcolor{keyword}{const} MatrixType& \hyperlink{group___l_u___module_afea0b8fc707a9097d46fe358cb18bbff}{matrixLU}()\textcolor{keyword}{ const}
00132 \textcolor{keyword}{    }\{
00133       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00134       \textcolor{keywordflow}{return} m\_lu;
00135     \}
00136 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00144}\hyperlink{group___l_u___module_aa71132a751ad3c78178e33d6b2987400}{00144}     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} \hyperlink{group___l_u___module_aa71132a751ad3c78178e33d6b2987400}{nonzeroPivots}()\textcolor{keyword}{ const}
00145 \textcolor{keyword}{    }\{
00146       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00147       \textcolor{keywordflow}{return} m\_nonzero\_pivots;
00148     \}
00149 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00153}\hyperlink{group___l_u___module_abced9f280f5fc49c2e62605c782b237b}{00153}     RealScalar \hyperlink{group___l_u___module_abced9f280f5fc49c2e62605c782b237b}{maxPivot}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_maxpivot; \}
00154 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00159}\hyperlink{group___l_u___module_a09274c82240f6441af5e6c99e24e756d}{00159}     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} PermutationPType& \hyperlink{group___l_u___module_a09274c82240f6441af5e6c99e24e756d}{permutationP}()\textcolor{keyword}{ const}
00160 \textcolor{keyword}{    }\{
00161       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00162       \textcolor{keywordflow}{return} m\_p;
00163     \}
00164 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00169}\hyperlink{group___l_u___module_a8d18190c7618de271cba7293f0493a36}{00169}     \textcolor{keyword}{inline} \textcolor{keyword}{const} PermutationQType& \hyperlink{group___l_u___module_a8d18190c7618de271cba7293f0493a36}{permutationQ}()\textcolor{keyword}{ const}
00170 \textcolor{keyword}{    }\{
00171       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00172       \textcolor{keywordflow}{return} m\_q;
00173     \}
00174 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00189}\hyperlink{group___l_u___module_a70f52eeb2cd07dfbf790fce106fb4015}{00189}     \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1kernel__retval}{internal::kernel\_retval<FullPivLU>} 
      \hyperlink{group___l_u___module_a70f52eeb2cd07dfbf790fce106fb4015}{kernel}()\textcolor{keyword}{ const}
00190 \textcolor{keyword}{    }\{
00191       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00192       \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1kernel__retval}{internal::kernel\_retval<FullPivLU>}(*this);
00193     \}
00194 
00214     \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1image__retval}{internal::image\_retval<FullPivLU>}
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00215}\hyperlink{group___l_u___module_a0893985d2dab367baa6e57c6fd0c4956}{00215}       \hyperlink{group___l_u___module_a0893985d2dab367baa6e57c6fd0c4956}{image}(\textcolor{keyword}{const} MatrixType& originalMatrix)\textcolor{keyword}{ const}
00216 \textcolor{keyword}{    }\{
00217       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00218       \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1image__retval}{internal::image\_retval<FullPivLU>}(*\textcolor{keyword}{this}, originalMatrix);
00219     \}
00220 
00240     \textcolor{comment}{// FIXME this is a copy-paste of the base-class member to add the isInitialized assertion.}
00241     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs>
00242     \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_solve}{Solve<FullPivLU, Rhs>}
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00243}\hyperlink{group___l_u___module_af563471f6f3283fd10779ef02dd0b748}{00243}     \hyperlink{group___l_u___module_af563471f6f3283fd10779ef02dd0b748}{solve}(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>}& b)\textcolor{keyword}{ const}
00244 \textcolor{keyword}{    }\{
00245       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00246       \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_solve}{Solve<FullPivLU, Rhs>}(*\textcolor{keyword}{this}, b.derived());
00247     \}
00248 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00252}\hyperlink{group___l_u___module_a0bc63f910960dc3e35acecc8442025b6}{00252}     \textcolor{keyword}{inline} RealScalar \hyperlink{group___l_u___module_a0bc63f910960dc3e35acecc8442025b6}{rcond}()\textcolor{keyword}{ const}
00253 \textcolor{keyword}{    }\{
00254       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"PartialPivLU is not initialized."});
00255       \textcolor{keywordflow}{return} \hyperlink{namespace_eigen_1_1internal_ad1de0d785387bfb5435c410bf0554068}{internal::rcond\_estimate\_helper}(m\_l1\_norm, *\textcolor{keyword}{this});
00256     \}
00257 
00273     \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<MatrixType>::Scalar} determinant() \textcolor{keyword}{const};
00274 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00292}\hyperlink{group___l_u___module_a414592d82de98f5bd075965caf56d681}{00292}     \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU}& \hyperlink{group___l_u___module_a414592d82de98f5bd075965caf56d681}{setThreshold}(\textcolor{keyword}{const} RealScalar& threshold)
00293     \{
00294       m\_usePrescribedThreshold = \textcolor{keyword}{true};
00295       m\_prescribedThreshold = threshold;
00296       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00297     \}
00298 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00307}\hyperlink{group___l_u___module_a1b5e30add3dfb6625da1213d68418f44}{00307}     \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU}& \hyperlink{group___l_u___module_a1b5e30add3dfb6625da1213d68418f44}{setThreshold}(Default\_t)
00308     \{
00309       m\_usePrescribedThreshold = \textcolor{keyword}{false};
00310       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00311     \}
00312 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00317}\hyperlink{group___l_u___module_ad77539203694f2d85ff7d11616e5a0a5}{00317}     RealScalar \hyperlink{group___l_u___module_ad77539203694f2d85ff7d11616e5a0a5}{threshold}()\textcolor{keyword}{ const}
00318 \textcolor{keyword}{    }\{
00319       eigen\_assert(m\_isInitialized || m\_usePrescribedThreshold);
00320       \textcolor{keywordflow}{return} m\_usePrescribedThreshold ? m\_prescribedThreshold
00321       \textcolor{comment}{// this formula comes from experimenting (see "LU precision tuning" thread on the list)}
00322       \textcolor{comment}{// and turns out to be identical to Higham's formula used already in LDLt.}
00323                                       : \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::epsilon}() * m\_lu.
      diagonalSize();
00324     \}
00325 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00332}\hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{00332}     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}()\textcolor{keyword}{ const}
00333 \textcolor{keyword}{    }\{
00334       \textcolor{keyword}{using} std::abs;
00335       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00336       RealScalar premultiplied\_threshold = abs(m\_maxpivot) * threshold();
00337       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} result = 0;
00338       \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i = 0; i < m\_nonzero\_pivots; ++i)
00339         result += (abs(m\_lu.coeff(i,i)) > premultiplied\_threshold);
00340       \textcolor{keywordflow}{return} result;
00341     \}
00342 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00349}\hyperlink{group___l_u___module_a64e191225834e91161ea53ad4b78167b}{00349}     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} \hyperlink{group___l_u___module_a64e191225834e91161ea53ad4b78167b}{dimensionOfKernel}()\textcolor{keyword}{ const}
00350 \textcolor{keyword}{    }\{
00351       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00352       \textcolor{keywordflow}{return} cols() - rank();
00353     \}
00354 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00362}\hyperlink{group___l_u___module_ab13992c852aa593461d9b81790b56667}{00362}     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \hyperlink{group___l_u___module_ab13992c852aa593461d9b81790b56667}{isInjective}()\textcolor{keyword}{ const}
00363 \textcolor{keyword}{    }\{
00364       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00365       \textcolor{keywordflow}{return} rank() == cols();
00366     \}
00367 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00375}\hyperlink{group___l_u___module_a1f6222875fc3a181ee1544b9b36dfda5}{00375}     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \hyperlink{group___l_u___module_a1f6222875fc3a181ee1544b9b36dfda5}{isSurjective}()\textcolor{keyword}{ const}
00376 \textcolor{keyword}{    }\{
00377       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00378       \textcolor{keywordflow}{return} rank() == rows();
00379     \}
00380 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00387}\hyperlink{group___l_u___module_afdf2579c93473650f2ef2a47a376c4a0}{00387}     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \hyperlink{group___l_u___module_afdf2579c93473650f2ef2a47a376c4a0}{isInvertible}()\textcolor{keyword}{ const}
00388 \textcolor{keyword}{    }\{
00389       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00390       \textcolor{keywordflow}{return} isInjective() && (m\_lu.rows() == m\_lu.cols());
00391     \}
00392 
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00400}\hyperlink{group___l_u___module_ae6f4bb55f859f6353f99cf15ecff4b25}{00400}     \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_inverse}{Inverse<FullPivLU>} \hyperlink{group___l_u___module_ae6f4bb55f859f6353f99cf15ecff4b25}{inverse}()\textcolor{keyword}{ const}
00401 \textcolor{keyword}{    }\{
00402       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00403       eigen\_assert(m\_lu.rows() == m\_lu.cols() && \textcolor{stringliteral}{"You can't take the inverse of a non-square matrix!"});
00404       \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_inverse}{Inverse<FullPivLU>}(*this);
00405     \}
00406 
00407     MatrixType reconstructedMatrix() \textcolor{keyword}{const};
00408 
00409     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lu.rows(); \}
00410     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lu.cols(); \}
00411 
00412 \textcolor{preprocessor}{    #ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00413     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsType, \textcolor{keyword}{typename} DstType>
00414     EIGEN\_DEVICE\_FUNC
00415     \textcolor{keywordtype}{void} \_solve\_impl(\textcolor{keyword}{const} RhsType &rhs, DstType &dst) \textcolor{keyword}{const};
00416 
00417     \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Conjugate, \textcolor{keyword}{typename} RhsType, \textcolor{keyword}{typename} DstType>
00418     EIGEN\_DEVICE\_FUNC
00419     \textcolor{keywordtype}{void} \_solve\_impl\_transposed(\textcolor{keyword}{const} RhsType &rhs, DstType &dst) \textcolor{keyword}{const};
00420 \textcolor{preprocessor}{    #endif}
00421 
00422   \textcolor{keyword}{protected}:
00423 
00424     \textcolor{keyword}{static} \textcolor{keywordtype}{void} check\_template\_parameters()
00425     \{
00426       EIGEN\_STATIC\_ASSERT\_NON\_INTEGER(Scalar);
00427     \}
00428 
00429     \textcolor{keywordtype}{void} computeInPlace();
00430 
00431     MatrixType m\_lu;
00432     PermutationPType m\_p;
00433     PermutationQType m\_q;
00434     IntColVectorType m\_rowsTranspositions;
00435     IntRowVectorType m\_colsTranspositions;
00436     \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} m\_nonzero\_pivots;
00437     RealScalar m\_l1\_norm;
00438     RealScalar m\_maxpivot, m\_prescribedThreshold;
00439     \textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} m\_det\_pq;
00440     \textcolor{keywordtype}{bool} m\_isInitialized, m\_usePrescribedThreshold;
00441 \};
00442 
00443 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00444}\hyperlink{group___l_u___module_af225528d1c6e623a2b1dce091907d13e}{00444} \hyperlink{group___l_u___module_af225528d1c6e623a2b1dce091907d13e}{FullPivLU<MatrixType>::FullPivLU}()
00445   : m\_isInitialized(false), m\_usePrescribedThreshold(false)
00446 \{
00447 \}
00448 
00449 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00450}\hyperlink{group___l_u___module_ae83ebd2a24088f04e3ac835b0dc001e1}{00450} \hyperlink{group___l_u___module_af225528d1c6e623a2b1dce091907d13e}{FullPivLU<MatrixType>::FullPivLU}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} rows, 
      \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} cols)
00451   : m\_lu(rows, cols),
00452     m\_p(rows),
00453     m\_q(cols),
00454     m\_rowsTranspositions(rows),
00455     m\_colsTranspositions(cols),
00456     m\_isInitialized(false),
00457     m\_usePrescribedThreshold(false)
00458 \{
00459 \}
00460 
00461 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00462 \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00463}\hyperlink{group___l_u___module_a31a6a984478a9f721f367667fe4c5ab1}{00463} \hyperlink{group___l_u___module_af225528d1c6e623a2b1dce091907d13e}{FullPivLU<MatrixType>::FullPivLU}(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<InputType>}& matrix)
00464   : m\_lu(matrix.rows(), matrix.cols()),
00465     m\_p(matrix.rows()),
00466     m\_q(matrix.cols()),
00467     m\_rowsTranspositions(matrix.rows()),
00468     m\_colsTranspositions(matrix.cols()),
00469     m\_isInitialized(false),
00470     m\_usePrescribedThreshold(false)
00471 \{
00472   \hyperlink{group___l_u___module_a0a3c3b1bbafa31a03567a4573ebabc79}{compute}(matrix.\hyperlink{group___core___module_a324b16961a11d2ecfd2d1b7dd7946545}{derived}());
00473 \}
00474 
00475 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00476 \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00477}\hyperlink{group___l_u___module_a3e903b9f401e3fc5d1ca7c6951c76185}{00477} \hyperlink{group___l_u___module_af225528d1c6e623a2b1dce091907d13e}{FullPivLU<MatrixType>::FullPivLU}(
      \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<InputType>}& matrix)
00478   : m\_lu(matrix.\hyperlink{group___core___module_a324b16961a11d2ecfd2d1b7dd7946545}{derived}()),
00479     m\_p(matrix.rows()),
00480     m\_q(matrix.cols()),
00481     m\_rowsTranspositions(matrix.rows()),
00482     m\_colsTranspositions(matrix.cols()),
00483     m\_isInitialized(false),
00484     m\_usePrescribedThreshold(false)
00485 \{
00486   computeInPlace();
00487 \}
00488 
00489 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00490 \textcolor{keywordtype}{void} \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU<MatrixType>::computeInPlace}()
00491 \{
00492   check\_template\_parameters();
00493 
00494   \textcolor{comment}{// the permutations are stored as int indices, so just to be sure:}
00495   eigen\_assert(m\_lu.rows()<=\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<int>::highest}() && m\_lu.cols()<=
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<int>::highest}());
00496 
00497   m\_l1\_norm = m\_lu.cwiseAbs().colwise().sum().maxCoeff();
00498 
00499   \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} size = m\_lu.diagonalSize();
00500   \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} rows = m\_lu.rows();
00501   \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} cols = m\_lu.cols();
00502 
00503   \textcolor{comment}{// will store the transpositions, before we accumulate them at the end.}
00504   \textcolor{comment}{// can't accumulate on-the-fly because that will be done in reverse order for the rows.}
00505   m\_rowsTranspositions.resize(m\_lu.rows());
00506   m\_colsTranspositions.resize(m\_lu.cols());
00507   \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} number\_of\_transpositions = 0; \textcolor{comment}{// number of NONTRIVIAL transpositions, i.e.
       m\_rowsTranspositions[i]!=i}
00508 
00509   m\_nonzero\_pivots = \hyperlink{group___core___module_ac2c9348df3bb9c0044dbae6c278a8977}{size}; \textcolor{comment}{// the generic case is that in which all pivots are nonzero (invertible
       case)}
00510   m\_maxpivot = RealScalar(0);
00511 
00512   \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} k = 0; k < \hyperlink{group___core___module_ac2c9348df3bb9c0044dbae6c278a8977}{size}; ++k)
00513   \{
00514     \textcolor{comment}{// First, we need to find the pivot.}
00515 
00516     \textcolor{comment}{// biggest coefficient in the remaining bottom-right corner (starting at row k, col k)}
00517     \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row\_of\_biggest\_in\_corner, col\_of\_biggest\_in\_corner;
00518     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1scalar__score__coeff__op}{internal::scalar\_score\_coeff\_op<Scalar>} Scoring;
00519     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Scoring::result\_type Score;
00520     Score biggest\_in\_corner;
00521     biggest\_in\_corner = m\_lu.bottomRightCorner(rows-k, cols-k)
00522                         .unaryExpr(Scoring())
00523                         .maxCoeff(&row\_of\_biggest\_in\_corner, &col\_of\_biggest\_in\_corner);
00524     row\_of\_biggest\_in\_corner += k; \textcolor{comment}{// correct the values! since they were computed in the corner,}
00525     col\_of\_biggest\_in\_corner += k; \textcolor{comment}{// need to add k to them.}
00526 
00527     \textcolor{keywordflow}{if}(biggest\_in\_corner==Score(0))
00528     \{
00529       \textcolor{comment}{// before exiting, make sure to initialize the still uninitialized transpositions}
00530       \textcolor{comment}{// in a sane state without destroying what we already have.}
00531       m\_nonzero\_pivots = k;
00532       \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i = k; i < \hyperlink{group___core___module_ac2c9348df3bb9c0044dbae6c278a8977}{size}; ++i)
00533       \{
00534         m\_rowsTranspositions.coeffRef(i) = i;
00535         m\_colsTranspositions.coeffRef(i) = i;
00536       \}
00537       \textcolor{keywordflow}{break};
00538     \}
00539 
00540     RealScalar abs\_pivot = \hyperlink{struct_eigen_1_1internal_1_1abs__knowing__score}{internal::abs\_knowing\_score<Scalar>}()(m\_lu(
      row\_of\_biggest\_in\_corner, col\_of\_biggest\_in\_corner), biggest\_in\_corner);
00541     \textcolor{keywordflow}{if}(abs\_pivot > m\_maxpivot) m\_maxpivot = abs\_pivot;
00542 
00543     \textcolor{comment}{// Now that we've found the pivot, we need to apply the row/col swaps to}
00544     \textcolor{comment}{// bring it to the location (k,k).}
00545 
00546     m\_rowsTranspositions.coeffRef(k) = row\_of\_biggest\_in\_corner;
00547     m\_colsTranspositions.coeffRef(k) = col\_of\_biggest\_in\_corner;
00548     \textcolor{keywordflow}{if}(k != row\_of\_biggest\_in\_corner) \{
00549       m\_lu.row(k).swap(m\_lu.row(row\_of\_biggest\_in\_corner));
00550       ++number\_of\_transpositions;
00551     \}
00552     \textcolor{keywordflow}{if}(k != col\_of\_biggest\_in\_corner) \{
00553       m\_lu.col(k).swap(m\_lu.col(col\_of\_biggest\_in\_corner));
00554       ++number\_of\_transpositions;
00555     \}
00556 
00557     \textcolor{comment}{// Now that the pivot is at the right location, we update the remaining}
00558     \textcolor{comment}{// bottom-right corner by Gaussian elimination.}
00559 
00560     \textcolor{keywordflow}{if}(k<rows-1)
00561       m\_lu.col(k).tail(rows-k-1) /= m\_lu.coeff(k,k);
00562     \textcolor{keywordflow}{if}(k<size-1)
00563       m\_lu.block(k+1,k+1,rows-k-1,cols-k-1).noalias() -= m\_lu.col(k).tail(rows-k-1) * m\_lu.row(k).tail(cols
      -k-1);
00564   \}
00565 
00566   \textcolor{comment}{// the main loop is over, we still have to accumulate the transpositions to find the}
00567   \textcolor{comment}{// permutations P and Q}
00568 
00569   m\_p.\hyperlink{group___core___module_a6805bb75fd7966ea71895c24ff196444}{setIdentity}(rows);
00570   \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} k = size-1; k >= 0; --k)
00571     m\_p.\hyperlink{group___core___module_a5f98da0712570d0c4b12f61839ae4193}{applyTranspositionOnTheRight}(k, m\_rowsTranspositions.coeff(k));
00572 
00573   m\_q.\hyperlink{group___core___module_a6805bb75fd7966ea71895c24ff196444}{setIdentity}(cols);
00574   \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} k = 0; k < \hyperlink{group___core___module_ac2c9348df3bb9c0044dbae6c278a8977}{size}; ++k)
00575     m\_q.\hyperlink{group___core___module_a5f98da0712570d0c4b12f61839ae4193}{applyTranspositionOnTheRight}(k, m\_colsTranspositions.coeff(k));
00576 
00577   m\_det\_pq = (number\_of\_transpositions%2) ? -1 : 1;
00578 
00579   m\_isInitialized = \textcolor{keyword}{true};
00580 \}
00581 
00582 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00583}\hyperlink{group___l_u___module_a71654e5c60a26407ecccfaa5b34bb0aa}{00583} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<MatrixType>::Scalar} 
      \hyperlink{group___l_u___module_a71654e5c60a26407ecccfaa5b34bb0aa}{FullPivLU<MatrixType>::determinant}()\textcolor{keyword}{ const}
00584 \textcolor{keyword}{}\{
00585   eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00586   eigen\_assert(m\_lu.rows() == m\_lu.cols() && \textcolor{stringliteral}{"You can't take the determinant of a non-square matrix!"});
00587   \textcolor{keywordflow}{return} Scalar(m\_det\_pq) * Scalar(m\_lu.diagonal().prod());
00588 \}
00589 
00593 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00594}\hyperlink{group___l_u___module_a191a4f598b0c192a83ab48984e87ee51}{00594} MatrixType \hyperlink{group___l_u___module_a191a4f598b0c192a83ab48984e87ee51}{FullPivLU<MatrixType>::reconstructedMatrix}()\textcolor{keyword}{ const}
00595 \textcolor{keyword}{}\{
00596   eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"LU is not initialized."});
00597   \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} smalldim = (std::min)(m\_lu.rows(), m\_lu.cols());
00598   \textcolor{comment}{// LU}
00599   MatrixType res(m\_lu.rows(),m\_lu.cols());
00600   \textcolor{comment}{// FIXME the .toDenseMatrix() should not be needed...}
00601   res = m\_lu.leftCols(smalldim)
00602             .template triangularView<UnitLower>().toDenseMatrix()
00603       * m\_lu.topRows(smalldim)
00604             .template triangularView<Upper>().toDenseMatrix();
00605 
00606   \textcolor{comment}{// P^\{-1\}(LU)}
00607   res = m\_p.\hyperlink{group___core___module_adb9af427f317202366c2832876064eb3}{inverse}() * res;
00608 
00609   \textcolor{comment}{// (P^\{-1\}LU)Q^\{-1\}}
00610   res = res * m\_q.\hyperlink{group___core___module_adb9af427f317202366c2832876064eb3}{inverse}();
00611 
00612   \textcolor{keywordflow}{return} res;
00613 \}
00614 
00615 \textcolor{comment}{/********* Implementation of kernel() **************************************************/}
00616 
00617 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00618 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00619}\hyperlink{struct_eigen_1_1internal_1_1kernel__retval_3_01_full_piv_l_u_3_01___matrix_type_01_4_01_4}{00619} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1kernel__retval}{kernel\_retval}<\hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU}<\_MatrixType> >
00620   : \hyperlink{struct_eigen_1_1internal_1_1kernel__retval__base}{kernel\_retval\_base}<FullPivLU<\_MatrixType> >
00621 \{
00622   EIGEN\_MAKE\_KERNEL\_HELPERS(\hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU<\_MatrixType>})
00623 
00624   \textcolor{keyword}{enum} \{ MaxSmallDimAtCompileTime = EIGEN\_SIZE\_MIN\_PREFER\_FIXED(
00625             MatrixType::MaxColsAtCompileTime,
00626             MatrixType::MaxRowsAtCompileTime)
00627   \};
00628 
00629   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest> \textcolor{keywordtype}{void} evalTo(Dest& dst)\textcolor{keyword}{ const}
00630 \textcolor{keyword}{  }\{
00631     \textcolor{keyword}{using} std::abs;
00632     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols = dec().matrixLU().cols(), dimker = cols - \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}();
00633     \textcolor{keywordflow}{if}(dimker == 0)
00634     \{
00635       \textcolor{comment}{// The Kernel is just \{0\}, so it doesn't have a basis properly speaking, but let's}
00636       \textcolor{comment}{// avoid crashing/asserting as that depends on floating point calculations. Let's}
00637       \textcolor{comment}{// just return a single column vector filled with zeros.}
00638       dst.setZero();
00639       \textcolor{keywordflow}{return};
00640     \}
00641 
00642     \textcolor{comment}{/* Let us use the following lemma:}
00643 \textcolor{comment}{      *}
00644 \textcolor{comment}{      * Lemma: If the matrix A has the LU decomposition PAQ = LU,}
00645 \textcolor{comment}{      * then Ker A = Q(Ker U).}
00646 \textcolor{comment}{      *}
00647 \textcolor{comment}{      * Proof: trivial: just keep in mind that P, Q, L are invertible.}
00648 \textcolor{comment}{      */}
00649 
00650     \textcolor{comment}{/* Thus, all we need to do is to compute Ker U, and then apply Q.}
00651 \textcolor{comment}{      *}
00652 \textcolor{comment}{      * U is upper triangular, with eigenvalues sorted so that any zeros appear at the end.}
00653 \textcolor{comment}{      * Thus, the diagonal of U ends with exactly}
00654 \textcolor{comment}{      * dimKer zero's. Let us use that to construct dimKer linearly}
00655 \textcolor{comment}{      * independent vectors in Ker U.}
00656 \textcolor{comment}{      */}
00657 
00658     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Index, Dynamic, 1, 0, MaxSmallDimAtCompileTime, 1>}
       pivots(\hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}());
00659     RealScalar premultiplied\_threshold = dec().maxPivot() * dec().threshold();
00660     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p = 0;
00661     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < dec().nonzeroPivots(); ++i)
00662       \textcolor{keywordflow}{if}(abs(dec().\hyperlink{group___l_u___module_afea0b8fc707a9097d46fe358cb18bbff}{matrixLU}().coeff(i,i)) > premultiplied\_threshold)
00663         pivots.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(p++) = i;
00664     eigen\_internal\_assert(p == \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}());
00665 
00666     \textcolor{comment}{// we construct a temporaty trapezoid matrix m, by taking the U matrix and}
00667     \textcolor{comment}{// permuting the rows and cols to bring the nonnegligible pivots to the top of}
00668     \textcolor{comment}{// the main diagonal. We need that to be able to apply our triangular solvers.}
00669     \textcolor{comment}{// FIXME when we get triangularView-for-rectangular-matrices, this can be simplified}
00670     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<\textcolor{keyword}{typename} MatrixType::Scalar, \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, MatrixType::Options,
00671            MaxSmallDimAtCompileTime, MatrixType::MaxColsAtCompileTime>
00672       m(dec().\hyperlink{group___l_u___module_afea0b8fc707a9097d46fe358cb18bbff}{matrixLU}().block(0, 0, \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}(), cols));
00673     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}(); ++i)
00674     \{
00675       \textcolor{keywordflow}{if}(i) m.row(i).head(i).setZero();
00676       m.row(i).tail(cols-i) = dec().matrixLU().row(pivots.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(i)).tail(cols-i);
00677     \}
00678     m.block(0, 0, \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}(), \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}());
00679     m.block(0, 0, \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}(), \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}()).template triangularView<StrictlyLower>().setZero();
00680     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}(); ++i)
00681       m.col(i).swap(m.col(pivots.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(i)));
00682 
00683     \textcolor{comment}{// ok, we have our trapezoid matrix, we can apply the triangular solver.}
00684     \textcolor{comment}{// notice that the math behind this suggests that we should apply this to the}
00685     \textcolor{comment}{// negative of the RHS, but for performance we just put the negative sign elsewhere, see below.}
00686     m.topLeftCorner(\hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}(), \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}())
00687      .template triangularView<Upper>().solveInPlace(
00688         m.topRightCorner(rank(), dimker)
00689       );
00690 
00691     \textcolor{comment}{// now we must undo the column permutation that we had applied!}
00692     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}()-1; i >= 0; --i)
00693       m.col(i).swap(m.col(pivots.\hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(i)));
00694 
00695     \textcolor{comment}{// see the negative sign in the next line, that's what we were talking about above.}
00696     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}(); ++i) dst.row(dec().\hyperlink{group___l_u___module_a8d18190c7618de271cba7293f0493a36}{permutationQ}().indices().coeff(i))
       = -m.row(i).tail(dimker);
00697     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}(); i < cols; ++i) dst.row(dec().\hyperlink{group___l_u___module_a8d18190c7618de271cba7293f0493a36}{permutationQ}().indices().coeff(
      i)).setZero();
00698     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = 0; k < dimker; ++k) dst.coeffRef(dec().\hyperlink{group___l_u___module_a8d18190c7618de271cba7293f0493a36}{permutationQ}().indices().coeff(
      \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}()+k), k) = Scalar(1);
00699   \}
00700 \};
00701 
00702 \textcolor{comment}{/***** Implementation of image() *****************************************************/}
00703 
00704 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00705}\hyperlink{struct_eigen_1_1internal_1_1image__retval_3_01_full_piv_l_u_3_01___matrix_type_01_4_01_4}{00705} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1image__retval}{image\_retval}<\hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU}<\_MatrixType> >
00706   : \hyperlink{struct_eigen_1_1internal_1_1image__retval__base}{image\_retval\_base}<FullPivLU<\_MatrixType> >
00707 \{
00708   EIGEN\_MAKE\_IMAGE\_HELPERS(\hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU<\_MatrixType>})
00709 
00710   \textcolor{keyword}{enum} \{ MaxSmallDimAtCompileTime = EIGEN\_SIZE\_MIN\_PREFER\_FIXED(
00711             MatrixType::MaxColsAtCompileTime,
00712             MatrixType::MaxRowsAtCompileTime)
00713   \};
00714 
00715   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest> \textcolor{keywordtype}{void} evalTo(Dest& dst)\textcolor{keyword}{ const}
00716 \textcolor{keyword}{  }\{
00717     \textcolor{keyword}{using} std::abs;
00718     \textcolor{keywordflow}{if}(\hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}() == 0)
00719     \{
00720       \textcolor{comment}{// The Image is just \{0\}, so it doesn't have a basis properly speaking, but let's}
00721       \textcolor{comment}{// avoid crashing/asserting as that depends on floating point calculations. Let's}
00722       \textcolor{comment}{// just return a single column vector filled with zeros.}
00723       dst.setZero();
00724       \textcolor{keywordflow}{return};
00725     \}
00726 
00727     \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Index, Dynamic, 1, 0, MaxSmallDimAtCompileTime, 1>}
       pivots(\hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}());
00728     RealScalar premultiplied\_threshold = dec().maxPivot() * dec().threshold();
00729     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p = 0;
00730     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < dec().nonzeroPivots(); ++i)
00731       \textcolor{keywordflow}{if}(abs(dec().\hyperlink{group___l_u___module_afea0b8fc707a9097d46fe358cb18bbff}{matrixLU}().coeff(i,i)) > premultiplied\_threshold)
00732         pivots.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(p++) = i;
00733     eigen\_internal\_assert(p == \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}());
00734 
00735     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < \hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}(); ++i)
00736       dst.col(i) = originalMatrix().col(dec().\hyperlink{group___l_u___module_a8d18190c7618de271cba7293f0493a36}{permutationQ}().indices().coeff(pivots.
      \hyperlink{class_eigen_1_1_plain_object_base_afbfc12954f16d21aedb7bd839f64a278}{coeff}(i)));
00737   \}
00738 \};
00739 
00740 \textcolor{comment}{/***** Implementation of solve() *****************************************************/}
00741 
00742 \} \textcolor{comment}{// end namespace internal}
00743 
00744 \textcolor{preprocessor}{#ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00745 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
00746 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsType, \textcolor{keyword}{typename} DstType>
00747 \textcolor{keywordtype}{void} \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU<\_MatrixType>::\_solve\_impl}(\textcolor{keyword}{const} RhsType &rhs, DstType &
      dst)\textcolor{keyword}{ const}
00748 \textcolor{keyword}{}\{
00749   \textcolor{comment}{/* The decomposition PAQ = LU can be rewritten as A = P^\{-1\} L U Q^\{-1\}.}
00750 \textcolor{comment}{  * So we proceed as follows:}
00751 \textcolor{comment}{  * Step 1: compute c = P * rhs.}
00752 \textcolor{comment}{  * Step 2: replace c by the solution x to Lx = c. Exists because L is invertible.}
00753 \textcolor{comment}{  * Step 3: replace c by the solution x to Ux = c. May or may not exist.}
00754 \textcolor{comment}{  * Step 4: result = Q * c;}
00755 \textcolor{comment}{  */}
00756 
00757   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows = this->rows(),
00758               cols = this->cols(),
00759               nonzero\_pivots = this->\hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}();
00760   eigen\_assert(rhs.rows() == rows);
00761   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} smalldim = (std::min)(rows, cols);
00762 
00763   \textcolor{keywordflow}{if}(nonzero\_pivots == 0)
00764   \{
00765     dst.setZero();
00766     \textcolor{keywordflow}{return};
00767   \}
00768 
00769   \textcolor{keyword}{typename} RhsType::PlainObject c(rhs.rows(), rhs.cols());
00770 
00771   \textcolor{comment}{// Step 1}
00772   c = \hyperlink{group___l_u___module_a09274c82240f6441af5e6c99e24e756d}{permutationP}() * rhs;
00773 
00774   \textcolor{comment}{// Step 2}
00775   m\_lu.topLeftCorner(smalldim,smalldim)
00776       .template triangularView<UnitLower>()
00777       .solveInPlace(c.topRows(smalldim));
00778   \textcolor{keywordflow}{if}(rows>cols)
00779     c.bottomRows(rows-cols) -= m\_lu.bottomRows(rows-cols) * c.topRows(cols);
00780 
00781   \textcolor{comment}{// Step 3}
00782   m\_lu.topLeftCorner(nonzero\_pivots, nonzero\_pivots)
00783       .template triangularView<Upper>()
00784       .solveInPlace(c.topRows(nonzero\_pivots));
00785 
00786   \textcolor{comment}{// Step 4}
00787   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < nonzero\_pivots; ++i)
00788     dst.row(\hyperlink{group___l_u___module_a8d18190c7618de271cba7293f0493a36}{permutationQ}().indices().coeff(i)) = c.row(i);
00789   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = nonzero\_pivots; i < m\_lu.cols(); ++i)
00790     dst.row(\hyperlink{group___l_u___module_a8d18190c7618de271cba7293f0493a36}{permutationQ}().indices().coeff(i)).setZero();
00791 \}
00792 
00793 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
00794 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Conjugate, \textcolor{keyword}{typename} RhsType, \textcolor{keyword}{typename} DstType>
00795 \textcolor{keywordtype}{void} \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU<\_MatrixType>::\_solve\_impl\_transposed}(\textcolor{keyword}{const} 
      RhsType &rhs, DstType &dst)\textcolor{keyword}{ const}
00796 \textcolor{keyword}{}\{
00797   \textcolor{comment}{/* The decomposition PAQ = LU can be rewritten as A = P^\{-1\} L U Q^\{-1\},}
00798 \textcolor{comment}{   * and since permutations are real and unitary, we can write this}
00799 \textcolor{comment}{   * as   A^T = Q U^T L^T P,}
00800 \textcolor{comment}{   * So we proceed as follows:}
00801 \textcolor{comment}{   * Step 1: compute c = Q^T rhs.}
00802 \textcolor{comment}{   * Step 2: replace c by the solution x to U^T x = c. May or may not exist.}
00803 \textcolor{comment}{   * Step 3: replace c by the solution x to L^T x = c.}
00804 \textcolor{comment}{   * Step 4: result = P^T c.}
00805 \textcolor{comment}{   * If Conjugate is true, replace "^T" by "^*" above.}
00806 \textcolor{comment}{   */}
00807 
00808   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows = this->rows(), cols = this->cols(),
00809     nonzero\_pivots = this->\hyperlink{group___l_u___module_a67a870aa69e699e058d04802ba0bdad9}{rank}();
00810    eigen\_assert(rhs.rows() == cols);
00811   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} smalldim = (std::min)(rows, cols);
00812 
00813   \textcolor{keywordflow}{if}(nonzero\_pivots == 0)
00814   \{
00815     dst.setZero();
00816     \textcolor{keywordflow}{return};
00817   \}
00818 
00819   \textcolor{keyword}{typename} RhsType::PlainObject c(rhs.rows(), rhs.cols());
00820 
00821   \textcolor{comment}{// Step 1}
00822   c = \hyperlink{group___l_u___module_a8d18190c7618de271cba7293f0493a36}{permutationQ}().\hyperlink{group___core___module_adb9af427f317202366c2832876064eb3}{inverse}() * rhs;
00823 
00824   \textcolor{keywordflow}{if} (\hyperlink{class_eigen_1_1_conjugate}{Conjugate}) \{
00825     \textcolor{comment}{// Step 2}
00826     m\_lu.topLeftCorner(nonzero\_pivots, nonzero\_pivots)
00827         .template triangularView<Upper>()
00828         .\hyperlink{class_eigen_1_1_solver_base_a05a3686a89888681c8e0c2bcab6d1ce5}{adjoint}()
00829         .solveInPlace(c.topRows(nonzero\_pivots));
00830     \textcolor{comment}{// Step 3}
00831     m\_lu.topLeftCorner(smalldim, smalldim)
00832         .template triangularView<UnitLower>()
00833         .\hyperlink{class_eigen_1_1_solver_base_a05a3686a89888681c8e0c2bcab6d1ce5}{adjoint}()
00834         .solveInPlace(c.topRows(smalldim));
00835   \} \textcolor{keywordflow}{else} \{
00836     \textcolor{comment}{// Step 2}
00837     m\_lu.topLeftCorner(nonzero\_pivots, nonzero\_pivots)
00838         .template triangularView<Upper>()
00839         .\hyperlink{class_eigen_1_1_solver_base_a732e75b5132bb4db3775916927b0e86c}{transpose}()
00840         .solveInPlace(c.topRows(nonzero\_pivots));
00841     \textcolor{comment}{// Step 3}
00842     m\_lu.topLeftCorner(smalldim, smalldim)
00843         .template triangularView<UnitLower>()
00844         .\hyperlink{class_eigen_1_1_solver_base_a732e75b5132bb4db3775916927b0e86c}{transpose}()
00845         .solveInPlace(c.topRows(smalldim));
00846   \}
00847 
00848   \textcolor{comment}{// Step 4}
00849   PermutationPType invp = \hyperlink{group___l_u___module_a09274c82240f6441af5e6c99e24e756d}{permutationP}().\hyperlink{group___core___module_adb9af427f317202366c2832876064eb3}{inverse}().eval();
00850   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < smalldim; ++i)
00851     dst.row(invp.indices().coeff(i)) = c.row(i);
00852   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = smalldim; i < rows; ++i)
00853     dst.row(invp.indices().coeff(i)).setZero();
00854 \}
00855 
00856 \textcolor{preprocessor}{#endif}
00857 
00858 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00859 
00860 
00861 \textcolor{comment}{/***** Implementation of inverse() *****************************************************/}
00862 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} MatrixType>
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00863}\hyperlink{struct_eigen_1_1internal_1_1_assignment_3_01_dst_xpr_type_00_01_inverse_3_01_full_piv_l_u_3_01_m9a195c884433725cd2990fc22dc66c56}{00863} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment}{Assignment}<DstXprType, \hyperlink{class_eigen_1_1_inverse}{Inverse}<\hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU}<MatrixType> >, 
      \hyperlink{namespaceinternal}{internal}::\hyperlink{struct_eigen_1_1internal_1_1assign__op}{assign\_op}<typename DstXprType::Scalar,typename FullPivLU<MatrixType>::Scalar>, 
      \hyperlink{struct_eigen_1_1internal_1_1_dense2_dense}{Dense2Dense}>
00864 \{
00865   \textcolor{keyword}{typedef} \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU<MatrixType>} \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{LuType};
00866   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_inverse}{Inverse<LuType>} \hyperlink{class_eigen_1_1_inverse}{SrcXprType};
00867   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(DstXprType &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<typename DstXprType::Scalar,typename MatrixType::Scalar>}
       &)
00868   \{
00869     dst = src.nestedExpression().solve(MatrixType::Identity(src.rows(), src.cols()));
00870   \}
00871 \};
00872 \} \textcolor{comment}{// end namespace internal}
00873 
00874 \textcolor{comment}{/******* MatrixBase methods *****************************************************************/}
00875 
00882 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00883 \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU<typename MatrixBase<Derived>::PlainObject}
      >
\Hypertarget{eigen_2_eigen_2src_2_l_u_2_full_piv_l_u_8h_source_l00884}\hyperlink{group___core___module_a25da97d31acab0ee5d9d13bdbb0569da}{00884} \hyperlink{group___core___module_a25da97d31acab0ee5d9d13bdbb0569da}{MatrixBase<Derived>::fullPivLu}()\textcolor{keyword}{ const}
00885 \textcolor{keyword}{}\{
00886   \textcolor{keywordflow}{return} \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU<PlainObject>}(eval());
00887 \}
00888 
00889 \} \textcolor{comment}{// end namespace Eigen}
00890 
00891 \textcolor{preprocessor}{#endif // EIGEN\_LU\_H}
\end{DoxyCode}
