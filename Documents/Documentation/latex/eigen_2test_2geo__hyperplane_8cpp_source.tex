\hypertarget{eigen_2test_2geo__hyperplane_8cpp_source}{}\section{eigen/test/geo\+\_\+hyperplane.cpp}
\label{eigen_2test_2geo__hyperplane_8cpp_source}\index{geo\+\_\+hyperplane.\+cpp@{geo\+\_\+hyperplane.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#include "main.h"}
00012 \textcolor{preprocessor}{#include <Eigen/Geometry>}
00013 \textcolor{preprocessor}{#include <Eigen/LU>}
00014 \textcolor{preprocessor}{#include <Eigen/QR>}
00015 
00016 \textcolor{keyword}{template}<\textcolor{keyword}{typename} HyperplaneType> \textcolor{keywordtype}{void} hyperplane(\textcolor{keyword}{const} HyperplaneType& \_plane)
00017 \{
00018   \textcolor{comment}{/* this test covers the following files:}
00019 \textcolor{comment}{     Hyperplane.h}
00020 \textcolor{comment}{  */}
00021   \textcolor{keyword}{using} std::abs;
00022   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} HyperplaneType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00023   \textcolor{keyword}{const} Index dim = \_plane.dim();
00024   \textcolor{keyword}{enum} \{ Options = HyperplaneType::Options \};
00025   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} HyperplaneType::Scalar Scalar;
00026   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} HyperplaneType::RealScalar RealScalar;
00027   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, HyperplaneType::AmbientDimAtCompileTime, 1>}
       \hyperlink{struct_vector_type}{VectorType};
00028   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<Scalar, HyperplaneType::AmbientDimAtCompileTime,
00029                          HyperplaneType::AmbientDimAtCompileTime> MatrixType;
00030 
00031   VectorType p0 = VectorType::Random(dim);
00032   VectorType p1 = VectorType::Random(dim);
00033 
00034   VectorType n0 = VectorType::Random(dim).normalized();
00035   VectorType n1 = VectorType::Random(dim).normalized();
00036 
00037   HyperplaneType pl0(n0, p0);
00038   HyperplaneType pl1(n1, p1);
00039   HyperplaneType pl2 = pl1;
00040 
00041   Scalar s0 = internal::random<Scalar>();
00042   Scalar s1 = internal::random<Scalar>();
00043 
00044   VERIFY\_IS\_APPROX( n1.dot(n1), Scalar(1) );
00045 
00046   VERIFY\_IS\_MUCH\_SMALLER\_THAN( pl0.absDistance(p0), Scalar(1) );
00047   \textcolor{keywordflow}{if}(numext::abs2(s0)>RealScalar(1e-6))
00048     VERIFY\_IS\_APPROX( pl1.signedDistance(p1 + n1 * s0), s0);
00049   \textcolor{keywordflow}{else}
00050     VERIFY\_IS\_MUCH\_SMALLER\_THAN( abs(pl1.signedDistance(p1 + n1 * s0) - s0), Scalar(1) );
00051   VERIFY\_IS\_MUCH\_SMALLER\_THAN( pl1.signedDistance(pl1.projection(p0)), Scalar(1) );
00052   VERIFY\_IS\_MUCH\_SMALLER\_THAN( pl1.absDistance(p1 +  pl1.normal().unitOrthogonal() * s1), Scalar(1) );
00053 
00054   \textcolor{comment}{// transform}
00055   \textcolor{keywordflow}{if} (!\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsComplex})
00056   \{
00057     MatrixType rot = MatrixType::Random(dim,dim).householderQr().householderQ();
00058     \hyperlink{group___core___module_class_eigen_1_1_diagonal_matrix}{DiagonalMatrix<Scalar,HyperplaneType::AmbientDimAtCompileTime>}
       scaling(VectorType::Random());
00059     \hyperlink{group___geometry___module_class_eigen_1_1_translation}{Translation<Scalar,HyperplaneType::AmbientDimAtCompileTime>}
       translation(VectorType::Random());
00060     
00061     \textcolor{keywordflow}{while}(scaling.diagonal().cwiseAbs().minCoeff()<RealScalar(1e-4)) scaling.diagonal() = 
      VectorType::Random();
00062 
00063     pl2 = pl1;
00064     VERIFY\_IS\_MUCH\_SMALLER\_THAN( pl2.transform(rot).absDistance(rot * p1), Scalar(1) );
00065     pl2 = pl1;
00066     VERIFY\_IS\_MUCH\_SMALLER\_THAN( pl2.transform(rot,\hyperlink{group__enums_ggaee59a86102f150923b0cac6d4ff05107a080cd5366173608f701cd945c2335568}{Isometry}).absDistance(rot * p1), Scalar(1) );
00067     pl2 = pl1;
00068     VERIFY\_IS\_MUCH\_SMALLER\_THAN( pl2.transform(rot*scaling).absDistance((rot*scaling) * p1), Scalar(1) );
00069     VERIFY\_IS\_APPROX( pl2.normal().norm(), RealScalar(1) );
00070     pl2 = pl1;
00071     VERIFY\_IS\_MUCH\_SMALLER\_THAN( pl2.transform(rot*scaling*translation)
00072                                   .absDistance((rot*scaling*translation) * p1), Scalar(1) );
00073     VERIFY\_IS\_APPROX( pl2.normal().norm(), RealScalar(1) );
00074     pl2 = pl1;
00075     VERIFY\_IS\_MUCH\_SMALLER\_THAN( pl2.transform(rot*translation,\hyperlink{group__enums_ggaee59a86102f150923b0cac6d4ff05107a080cd5366173608f701cd945c2335568}{Isometry})
00076                                  .absDistance((rot*translation) * p1), Scalar(1) );
00077     VERIFY\_IS\_APPROX( pl2.normal().norm(), RealScalar(1) );
00078   \}
00079 
00080   \textcolor{comment}{// casting}
00081   \textcolor{keyword}{const} \textcolor{keywordtype}{int} Dim = HyperplaneType::AmbientDimAtCompileTime;
00082   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_get_different_type}{GetDifferentType<Scalar>::type} OtherScalar;
00083   \hyperlink{group___geometry___module_class_eigen_1_1_hyperplane}{Hyperplane<OtherScalar,Dim,Options>} hp1f = pl1.template 
      cast<OtherScalar>();
00084   VERIFY\_IS\_APPROX(hp1f.template cast<Scalar>(),pl1);
00085   \hyperlink{group___geometry___module_class_eigen_1_1_hyperplane}{Hyperplane<Scalar,Dim,Options>} hp1d = pl1.template cast<Scalar>();
00086   VERIFY\_IS\_APPROX(hp1d.template cast<Scalar>(),pl1);
00087 \}
00088 
00089 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} lines()
00090 \{
00091   \textcolor{keyword}{using} std::abs;
00092   \textcolor{keyword}{typedef} \hyperlink{group___geometry___module_class_eigen_1_1_hyperplane}{Hyperplane<Scalar, 2>} HLine;
00093   \textcolor{keyword}{typedef} \hyperlink{group___geometry___module_class_eigen_1_1_parametrized_line}{ParametrizedLine<Scalar, 2>} PLine;
00094   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,2,1>} Vector;
00095   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,3,1>} CoeffsType;
00096 
00097   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 10; i++)
00098   \{
00099     Vector center = Vector::Random();
00100     Vector u = Vector::Random();
00101     Vector v = Vector::Random();
00102     Scalar a = internal::random<Scalar>();
00103     \textcolor{keywordflow}{while} (abs(a-1) < Scalar(1e-4)) a = internal::random<Scalar>();
00104     \textcolor{keywordflow}{while} (u.norm() < Scalar(1e-4)) u = Vector::Random();
00105     \textcolor{keywordflow}{while} (v.norm() < Scalar(1e-4)) v = Vector::Random();
00106 
00107     HLine line\_u = HLine::Through(center + u, center + a*u);
00108     HLine line\_v = HLine::Through(center + v, center + a*v);
00109 
00110     \textcolor{comment}{// the line equations should be normalized so that a^2+b^2=1}
00111     VERIFY\_IS\_APPROX(line\_u.normal().norm(), Scalar(1));
00112     VERIFY\_IS\_APPROX(line\_v.normal().norm(), Scalar(1));
00113 
00114     Vector result = line\_u.intersection(line\_v);
00115 
00116     \textcolor{comment}{// the lines should intersect at the point we called "center"}
00117     \textcolor{keywordflow}{if}(abs(a-1) > Scalar(1e-2) && abs(v.normalized().dot(u.normalized()))<Scalar(0.9))
00118       VERIFY\_IS\_APPROX(result, center);
00119 
00120     \textcolor{comment}{// check conversions between two types of lines}
00121     PLine pl(line\_u); \textcolor{comment}{// gcc 3.3 will commit suicide if we don't name this variable}
00122     HLine line\_u2(pl);
00123     CoeffsType converted\_coeffs = line\_u2.coeffs();
00124     \textcolor{keywordflow}{if}(line\_u2.normal().dot(line\_u.normal())<Scalar(0))
00125       converted\_coeffs = -line\_u2.coeffs();
00126     VERIFY(line\_u.coeffs().isApprox(converted\_coeffs));
00127   \}
00128 \}
00129 
00130 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} planes()
00131 \{
00132   \textcolor{keyword}{using} std::abs;
00133   \textcolor{keyword}{typedef} \hyperlink{group___geometry___module_class_eigen_1_1_hyperplane}{Hyperplane<Scalar, 3>} Plane;
00134   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,3,1>} Vector;
00135 
00136   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 10; i++)
00137   \{
00138     Vector v0 = Vector::Random();
00139     Vector v1(v0), v2(v0);
00140     \textcolor{keywordflow}{if}(internal::random<double>(0,1)>0.25)
00141       v1 += Vector::Random();
00142     \textcolor{keywordflow}{if}(internal::random<double>(0,1)>0.25)
00143       v2 += v1 * std::pow(internal::random<Scalar>(0,1),internal::random<int>(1,16));
00144     \textcolor{keywordflow}{if}(internal::random<double>(0,1)>0.25)
00145       v2 += Vector::Random() * std::pow(internal::random<Scalar>(0,1),internal::random<int>(1,16));
00146 
00147     Plane p0 = Plane::Through(v0, v1, v2);
00148 
00149     VERIFY\_IS\_APPROX(p0.normal().norm(), Scalar(1));
00150     VERIFY\_IS\_MUCH\_SMALLER\_THAN(p0.absDistance(v0), Scalar(1));
00151     VERIFY\_IS\_MUCH\_SMALLER\_THAN(p0.absDistance(v1), Scalar(1));
00152     VERIFY\_IS\_MUCH\_SMALLER\_THAN(p0.absDistance(v2), Scalar(1));
00153   \}
00154 \}
00155 
00156 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} hyperplane\_alignment()
00157 \{
00158   \textcolor{keyword}{typedef} \hyperlink{group___geometry___module_class_eigen_1_1_hyperplane}{Hyperplane<Scalar,3,AutoAlign>} Plane3a;
00159   \textcolor{keyword}{typedef} \hyperlink{group___geometry___module_class_eigen_1_1_hyperplane}{Hyperplane<Scalar,3,DontAlign>} Plane3u;
00160 
00161   EIGEN\_ALIGN\_MAX Scalar array1[4];
00162   EIGEN\_ALIGN\_MAX Scalar array2[4];
00163   EIGEN\_ALIGN\_MAX Scalar array3[4+1];
00164   Scalar* array3u = array3+1;
00165 
00166   Plane3a *p1 = ::new(reinterpret\_cast<void*>(array1)) Plane3a;
00167   Plane3u *p2 = ::new(reinterpret\_cast<void*>(array2)) Plane3u;
00168   Plane3u *p3 = ::new(reinterpret\_cast<void*>(array3u)) Plane3u;
00169   
00170   p1->coeffs().setRandom();
00171   *p2 = *p1;
00172   *p3 = *p1;
00173 
00174   VERIFY\_IS\_APPROX(p1->coeffs(), p2->coeffs());
00175   VERIFY\_IS\_APPROX(p1->coeffs(), p3->coeffs());
00176   
00177 \textcolor{preprocessor}{  #if defined(EIGEN\_VECTORIZE) && EIGEN\_MAX\_STATIC\_ALIGN\_BYTES > 0}
00178   \textcolor{keywordflow}{if}(internal::packet\_traits<Scalar>::Vectorizable && internal::packet\_traits<Scalar>::size<=4)
00179     VERIFY\_RAISES\_ASSERT((::\textcolor{keyword}{new}(reinterpret\_cast<void*>(array3u)) Plane3a));
00180 \textcolor{preprocessor}{  #endif}
00181 \}
00182 
00183 
00184 \textcolor{keywordtype}{void} test\_geo\_hyperplane()
00185 \{
00186   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00187     CALL\_SUBTEST\_1( hyperplane(\hyperlink{group___geometry___module_class_eigen_1_1_hyperplane}{Hyperplane<float,2>}()) );
00188     CALL\_SUBTEST\_2( hyperplane(\hyperlink{group___geometry___module_class_eigen_1_1_hyperplane}{Hyperplane<float,3>}()) );
00189     CALL\_SUBTEST\_2( hyperplane(\hyperlink{group___geometry___module_class_eigen_1_1_hyperplane}{Hyperplane<float,3,DontAlign>}()) );
00190     CALL\_SUBTEST\_2( hyperplane\_alignment<float>() );
00191     CALL\_SUBTEST\_3( hyperplane(\hyperlink{group___geometry___module_class_eigen_1_1_hyperplane}{Hyperplane<double,4>}()) );
00192     CALL\_SUBTEST\_4( hyperplane(\hyperlink{group___geometry___module_class_eigen_1_1_hyperplane}{Hyperplane}<std::complex<double>,5>()) );
00193     CALL\_SUBTEST\_1( lines<float>() );
00194     CALL\_SUBTEST\_3( lines<double>() );
00195     CALL\_SUBTEST\_2( planes<float>() );
00196     CALL\_SUBTEST\_5( planes<double>() );
00197   \}
00198 \}
\end{DoxyCode}
