\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reverse_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Reverse.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reverse_8h_source}\index{Tensor\+Reverse.\+h@{Tensor\+Reverse.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Navdeep Jaitly <ndjaitly@google.com>}
00005 \textcolor{comment}{//                    Benoit Steiner <benoit.steiner.goog@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_REVERSE\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_REVERSE\_H}
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00021 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReverseDimensions, \textcolor{keyword}{typename} XprType>
00023 \textcolor{keyword}{struct }traits<TensorReverseOp<ReverseDimensions,
00024                               XprType> > : \textcolor{keyword}{public} traits<XprType>
00025 \{
00026   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00027   \textcolor{keyword}{typedef} traits<XprType> XprTraits;
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<Nested>::type \_Nested;
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00034 \};
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReverseDimensions, \textcolor{keyword}{typename} XprType>
00037 \textcolor{keyword}{struct }eval<TensorReverseOp<ReverseDimensions, XprType>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00038 \{
00039   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorReverseOp<ReverseDimensions, XprType>& type;
00040 \};
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReverseDimensions, \textcolor{keyword}{typename} XprType>
00043 \textcolor{keyword}{struct }nested<TensorReverseOp<ReverseDimensions, XprType>, 1,
00044             typename eval<TensorReverseOp<ReverseDimensions, XprType> >::type>
00045 \{
00046   \textcolor{keyword}{typedef} TensorReverseOp<ReverseDimensions, XprType> type;
00047 \};
00048 
00049 \}  \textcolor{comment}{// end namespace internal}
00050 
00051 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReverseDimensions, \textcolor{keyword}{typename} XprType>
00052 \textcolor{keyword}{class }TensorReverseOp : \textcolor{keyword}{public} TensorBase<TensorReverseOp<ReverseDimensions,
00053                                           XprType>, WriteAccessors>
00054 \{
00055   \textcolor{keyword}{public}:
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorReverseOp>::Scalar}
       Scalar;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorReverseOp>::type}
       Nested;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorReverseOp>::StorageKind}
00061                                                                     StorageKind;
00062   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorReverseOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00063 
00064   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorReverseOp(
00065       \textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} ReverseDimensions& reverse\_dims)
00066       : m\_xpr(expr), m\_reverse\_dims(reverse\_dims) \{ \}
00067 
00068     EIGEN\_DEVICE\_FUNC
00069     \textcolor{keyword}{const} ReverseDimensions& reverse()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_reverse\_dims; \}
00070 
00071     EIGEN\_DEVICE\_FUNC
00072     \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type&
00073     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00074 
00075     EIGEN\_DEVICE\_FUNC
00076     EIGEN\_STRONG\_INLINE TensorReverseOp& operator = (\textcolor{keyword}{const} TensorReverseOp& other)
00077     \{
00078       \textcolor{keyword}{typedef} TensorAssignOp<TensorReverseOp, const TensorReverseOp> Assign;
00079       Assign assign(*\textcolor{keyword}{this}, other);
00080       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00081       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00082     \}
00083 
00084     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00085     EIGEN\_DEVICE\_FUNC
00086     EIGEN\_STRONG\_INLINE TensorReverseOp& operator = (\textcolor{keyword}{const} OtherDerived& other)
00087     \{
00088       \textcolor{keyword}{typedef} TensorAssignOp<TensorReverseOp, const OtherDerived> Assign;
00089       Assign assign(*\textcolor{keyword}{this}, other);
00090       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00091       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00092     \}
00093 
00094   \textcolor{keyword}{protected}:
00095     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00096     \textcolor{keyword}{const} ReverseDimensions m\_reverse\_dims;
00097 \};
00098 
00099 \textcolor{comment}{// Eval as rvalue}
00100 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReverseDimensions, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00101 \textcolor{keyword}{struct }TensorEvaluator<const TensorReverseOp<ReverseDimensions, ArgType>, Device>
00102 \{
00103   \textcolor{keyword}{typedef} TensorReverseOp<ReverseDimensions, ArgType> XprType;
00104   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00105   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::array\_size<ReverseDimensions>::value;
00106   \textcolor{keyword}{typedef} DSizes<Index, NumDims> Dimensions;
00107   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00108   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00109   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00110   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = internal::unpacket\_traits<PacketReturnType>::size;
00111 
00112   \textcolor{keyword}{enum} \{
00113     IsAligned = \textcolor{keyword}{false},
00114     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00115     Layout = TensorEvaluator<ArgType, Device>::Layout,
00116     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00117     RawAccess = \textcolor{keyword}{false}
00118   \};
00119 
00120   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op,
00121                                                         \textcolor{keyword}{const} Device& device)
00122       : m\_impl(op.expression(), device), m\_reverse(op.reverse())
00123   \{
00124     \textcolor{comment}{// Reversing a scalar isn't supported yet. It would be a no-op anyway.}
00125     EIGEN\_STATIC\_ASSERT((NumDims > 0), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00126 
00127     \textcolor{comment}{// Compute strides}
00128     m\_dimensions = m\_impl.dimensions();
00129     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00130       m\_strides[0] = 1;
00131       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00132         m\_strides[i] = m\_strides[i-1] * m\_dimensions[i-1];
00133       \}
00134     \} \textcolor{keywordflow}{else} \{
00135       m\_strides[NumDims-1] = 1;
00136       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00137         m\_strides[i] = m\_strides[i+1] * m\_dimensions[i+1];
00138       \}
00139     \}
00140   \}
00141 
00142   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00143   \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00144 
00145   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar*) \{
00146     m\_impl.evalSubExprsIfNeeded(NULL);
00147     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00148   \}
00149   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00150     m\_impl.cleanup();
00151   \}
00152 
00153   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index reverseIndex(
00154       Index index)\textcolor{keyword}{ const }\{
00155     eigen\_assert(index < dimensions().TotalSize());
00156     Index inputIndex = 0;
00157     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00158       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00159         Index idx = index / m\_strides[i];
00160         index -= idx * m\_strides[i];
00161         \textcolor{keywordflow}{if} (m\_reverse[i]) \{
00162           idx = m\_dimensions[i] - idx - 1;
00163         \}
00164         inputIndex += idx * m\_strides[i] ;
00165       \}
00166       \textcolor{keywordflow}{if} (m\_reverse[0]) \{
00167         inputIndex += (m\_dimensions[0] - index - 1);
00168       \} \textcolor{keywordflow}{else} \{
00169         inputIndex += index;
00170       \}
00171     \} \textcolor{keywordflow}{else} \{
00172       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00173         Index idx = index / m\_strides[i];
00174         index -= idx * m\_strides[i];
00175         \textcolor{keywordflow}{if} (m\_reverse[i]) \{
00176           idx = m\_dimensions[i] - idx - 1;
00177         \}
00178         inputIndex += idx * m\_strides[i] ;
00179       \}
00180       \textcolor{keywordflow}{if} (m\_reverse[NumDims-1]) \{
00181         inputIndex += (m\_dimensions[NumDims-1] - index - 1);
00182       \} \textcolor{keywordflow}{else} \{
00183         inputIndex += index;
00184       \}
00185     \}
00186     \textcolor{keywordflow}{return} inputIndex;
00187   \}
00188 
00189   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(
00190       Index index)\textcolor{keyword}{ const  }\{
00191     \textcolor{keywordflow}{return} m\_impl.coeff(reverseIndex(index));
00192   \}
00193 
00194   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00195   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00196   PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00197 \textcolor{keyword}{  }\{
00198     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00199     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00200 
00201     \textcolor{comment}{// TODO(ndjaitly): write a better packing routine that uses}
00202     \textcolor{comment}{// local structure.}
00203     EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} internal::remove\_const<CoeffReturnType>::type
00204                                                             values[PacketSize];
00205     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00206       values[i] = coeff(index+i);
00207     \}
00208     PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00209     \textcolor{keywordflow}{return} rslt;
00210   \}
00211 
00212   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorOpCost costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00213     \textcolor{keywordtype}{double} compute\_cost = NumDims * (2 * TensorOpCost::AddCost<Index>() +
00214                                      2 * TensorOpCost::MulCost<Index>() +
00215                                      TensorOpCost::DivCost<Index>());
00216     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims; ++i) \{
00217       \textcolor{keywordflow}{if} (m\_reverse[i]) \{
00218         compute\_cost += 2 * TensorOpCost::AddCost<Index>();
00219       \}
00220     \}
00221     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) +
00222            TensorOpCost(0, 0, compute\_cost, \textcolor{keyword}{false} \textcolor{comment}{/* vectorized */}, PacketSize);
00223   \}
00224 
00225   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00226 
00227  \textcolor{keyword}{protected}:
00228   Dimensions m\_dimensions;
00229   array<Index, NumDims> m\_strides;
00230   TensorEvaluator<ArgType, Device> m\_impl;
00231   ReverseDimensions m\_reverse;
00232 \};
00233 
00234 \textcolor{comment}{// Eval as lvalue}
00235 
00236 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ReverseDimensions, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00237 \textcolor{keyword}{struct }TensorEvaluator<TensorReverseOp<ReverseDimensions, ArgType>, Device>
00238     : \textcolor{keyword}{public} TensorEvaluator<const TensorReverseOp<ReverseDimensions, ArgType>,
00239                              Device> \{
00240   \textcolor{keyword}{typedef} TensorEvaluator<const TensorReverseOp<ReverseDimensions, ArgType>,
00241                           Device> Base;
00242   \textcolor{keyword}{typedef} TensorReverseOp<ReverseDimensions, ArgType> XprType;
00243   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00244   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::array\_size<ReverseDimensions>::value;
00245   \textcolor{keyword}{typedef} DSizes<Index, NumDims> Dimensions;
00246 
00247   \textcolor{keyword}{enum} \{
00248     IsAligned = \textcolor{keyword}{false},
00249     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00250     Layout = TensorEvaluator<ArgType, Device>::Layout,
00251     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00252     RawAccess = \textcolor{keyword}{false}
00253   \};
00254   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op,
00255                                                         \textcolor{keyword}{const} Device& device)
00256       : Base(op, device) \{\}
00257 
00258   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00259   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00260   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00261   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = internal::unpacket\_traits<PacketReturnType>::size;
00262 
00263   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00264   \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} this->m\_dimensions; \}
00265 
00266   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& coeffRef(Index index) \{
00267     \textcolor{keywordflow}{return} this->m\_impl.coeffRef(this->reverseIndex(index));
00268   \}
00269 
00270   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} StoreMode> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00271   \textcolor{keywordtype}{void} writePacket(Index index, \textcolor{keyword}{const} PacketReturnType& x) \{
00272     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00273     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00274 
00275     \textcolor{comment}{// This code is pilfered from TensorMorphing.h}
00276     EIGEN\_ALIGN\_MAX CoeffReturnType values[PacketSize];
00277     internal::pstore<CoeffReturnType, PacketReturnType>(values, x);
00278     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00279       this->coeffRef(index+i) = values[i];
00280     \}
00281   \}
00282 
00283 \};
00284 
00285 
00286 \}  \textcolor{comment}{// end namespace Eigen}
00287 
00288 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_REVERSE\_H}
\end{DoxyCode}
