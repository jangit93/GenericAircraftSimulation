\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_8h_source}\index{Tensor.\+h@{Tensor.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2013 Christian Seiler <christian@iwakd.de>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 
00062 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_, \textcolor{keywordtype}{int} NumIndices\_, \textcolor{keywordtype}{int} Options\_, \textcolor{keyword}{typename} IndexType\_>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_8h_source_l00063}\hyperlink{class_eigen_1_1_tensor}{00063} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor}{Tensor} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<Tensor<Scalar\_, NumIndices\_, Options\_, IndexType\_> >
00064 \{
00065   \textcolor{keyword}{public}:
00066     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor}{Tensor<Scalar\_, NumIndices\_, Options\_, IndexType\_>}
       \hyperlink{class_eigen_1_1_tensor}{Self};
00067     \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase<Tensor<Scalar\_, NumIndices\_, Options\_, IndexType\_>}
       > \hyperlink{class_eigen_1_1_tensor_base}{Base};
00068     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<Self>::type} 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Nested};
00069     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Self>::StorageKind} StorageKind;
00070     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<Self>::Index} Index;
00071     \textcolor{keyword}{typedef} Scalar\_ Scalar;
00072     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00073     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::CoeffReturnType CoeffReturnType;
00074 
00075     \textcolor{keyword}{enum} \{
00076       IsAligned = bool(EIGEN\_MAX\_ALIGN\_BYTES>0) & !(Options\_&\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a40a452614141522dd313363dbbd65726}{DontAlign}),
00077       Layout = Options\_ & \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},
00078       CoordAccess = \textcolor{keyword}{true},
00079       RawAccess = \textcolor{keyword}{true}
00080     \};
00081 
00082     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Options = Options\_;
00083     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumIndices = NumIndices\_;
00084     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumIndices\_>} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00085 
00086   \textcolor{keyword}{protected}:
00087     \hyperlink{class_eigen_1_1_tensor_storage}{TensorStorage<Scalar, Dimensions, Options>} m\_storage;
00088 
00089 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_SFINAE}
00090     \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomIndices>
00091     \textcolor{keyword}{struct }isOfNormalIndex\{
00092       \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_array = internal::is\_base\_of<array<Index, NumIndices>, CustomIndices>::value;
00093       \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_int = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<CustomIndices>::IsInteger};
00094       \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = is\_array | is\_int;
00095     \};
00096 \textcolor{preprocessor}{#endif}
00097 
00098   \textcolor{keyword}{public}:
00099     \textcolor{comment}{// Metadata}
00100     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index                         rank()\textcolor{keyword}{                   const }\{ \textcolor{keywordflow}{
      return} NumIndices; \}
00101     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index                         dimension(std::size\_t n)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{
      return} m\_storage.dimensions()[n]; \}
00102     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions&             dimensions()\textcolor{keyword}{             const }\{ \textcolor{keywordflow}{
      return} m\_storage.dimensions(); \}
00103     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index                         size()\textcolor{keyword}{                   const }\{ \textcolor{keywordflow}{
      return} m\_storage.size(); \}
00104     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar                        *data()                        \{ \textcolor{keywordflow}{
      return} m\_storage.data(); \}
00105     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar                  *data()\textcolor{keyword}{                  const }\{ \textcolor{keywordflow}{
      return} m\_storage.data(); \}
00106 
00107     \textcolor{comment}{// This makes EIGEN\_INITIALIZE\_COEFFS\_IF\_THAT\_OPTION\_IS\_ENABLED}
00108     \textcolor{comment}{// work, because that uses base().coeffRef() - and we don't yet}
00109     \textcolor{comment}{// implement a similar class hierarchy}
00110     \textcolor{keyword}{inline} Self& base()             \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}
00111     \textcolor{keyword}{inline} \textcolor{keyword}{const} Self& base()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}
00112 
00113 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00114     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes>
00115     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar& coeff(Index firstIndex, Index secondIndex, IndexTypes... 
      otherIndices)\textcolor{keyword}{ const}
00116 \textcolor{keyword}{    }\{
00117       \textcolor{comment}{// The number of indices used to access a tensor coefficient must be equal to the rank of the tensor.}
00118       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}...(otherIndices) + 2 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00119       \textcolor{keywordflow}{return} coeff(\hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}\{\{firstIndex, secondIndex, otherIndices.
      ..\}\});
00120     \}
00121 \textcolor{preprocessor}{#endif}
00122 
00123     \textcolor{comment}{// normal indices}
00124     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& coeff(\textcolor{keyword}{const} 
      \hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}& indices)\textcolor{keyword}{ const}
00125 \textcolor{keyword}{    }\{
00126       eigen\_internal\_assert(checkIndexRange(indices));
00127       \textcolor{keywordflow}{return} m\_storage.data()[linearizedIndex(indices)];
00128     \}
00129 
00130     \textcolor{comment}{// custom indices}
00131 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_SFINAE}
00132     \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomIndices,
00133              EIGEN\_SFINAE\_ENABLE\_IF( !(isOfNormalIndex<CustomIndices>::value) )
00134     >
00135     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& coeff(CustomIndices& indices)\textcolor{keyword}{ const}
00136 \textcolor{keyword}{    }\{
00137         \textcolor{keywordflow}{return} coeff(internal::customIndices2Array<Index,NumIndices>(indices));
00138     \}
00139 \textcolor{preprocessor}{#endif}
00140 
00141     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& coeff()\textcolor{keyword}{ const}
00142 \textcolor{keyword}{    }\{
00143       EIGEN\_STATIC\_ASSERT(NumIndices == 0, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00144       \textcolor{keywordflow}{return} m\_storage.data()[0];
00145     \}
00146 
00147     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& coeff(Index index)\textcolor{keyword}{ const}
00148 \textcolor{keyword}{    }\{
00149       eigen\_internal\_assert(index >= 0 && index < size());
00150       \textcolor{keywordflow}{return} m\_storage.data()[index];
00151     \}
00152 
00153 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00154     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes>
00155     \textcolor{keyword}{inline} Scalar& coeffRef(Index firstIndex, Index secondIndex, IndexTypes... otherIndices)
00156     \{
00157       \textcolor{comment}{// The number of indices used to access a tensor coefficient must be equal to the rank of the tensor.}
00158       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}...(otherIndices) + 2 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00159       \textcolor{keywordflow}{return} coeffRef(\hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}\{\{firstIndex, secondIndex, 
      otherIndices...\}\});
00160     \}
00161 \textcolor{preprocessor}{#endif}
00162 
00163     \textcolor{comment}{// normal indices}
00164     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& coeffRef(\textcolor{keyword}{const} 
      \hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}& indices)
00165     \{
00166       eigen\_internal\_assert(checkIndexRange(indices));
00167       \textcolor{keywordflow}{return} m\_storage.data()[linearizedIndex(indices)];
00168     \}
00169 
00170     \textcolor{comment}{// custom indices}
00171 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_SFINAE}
00172     \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomIndices,
00173              EIGEN\_SFINAE\_ENABLE\_IF( !(isOfNormalIndex<CustomIndices>::value) )
00174              >
00175     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& coeffRef(CustomIndices& indices)
00176     \{
00177         \textcolor{keywordflow}{return} coeffRef(internal::customIndices2Array<Index,NumIndices>(indices));
00178     \}
00179 \textcolor{preprocessor}{#endif}
00180 
00181     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& coeffRef()
00182     \{
00183       EIGEN\_STATIC\_ASSERT(NumIndices == 0, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00184       \textcolor{keywordflow}{return} m\_storage.data()[0];
00185     \}
00186 
00187     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& coeffRef(Index index)
00188     \{
00189       eigen\_internal\_assert(index >= 0 && index < size());
00190       \textcolor{keywordflow}{return} m\_storage.data()[index];
00191     \}
00192 
00193 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00194     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes>
00195     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar& operator()(Index firstIndex, Index secondIndex, IndexTypes... otherIndices)\textcolor{keyword}{ const}
00196 \textcolor{keyword}{    }\{
00197       \textcolor{comment}{// The number of indices used to access a tensor coefficient must be equal to the rank of the tensor.}
00198       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}...(otherIndices) + 2 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00199       \textcolor{keywordflow}{return} this->operator()(\hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}\{\{firstIndex, secondIndex, 
      otherIndices...\}\});
00200     \}
00201 \textcolor{preprocessor}{#else}
00202     EIGEN\_DEVICE\_FUNC
00203     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index i0, Index i1)\textcolor{keyword}{ const}
00204 \textcolor{keyword}{    }\{
00205       \textcolor{keywordflow}{return} coeff(\hyperlink{class_eigen_1_1array}{array<Index, 2>}(i0, i1));
00206     \}
00207     EIGEN\_DEVICE\_FUNC
00208     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index i0, Index i1, Index i2)\textcolor{keyword}{ const}
00209 \textcolor{keyword}{    }\{
00210       \textcolor{keywordflow}{return} coeff(\hyperlink{class_eigen_1_1array}{array<Index, 3>}(i0, i1, i2));
00211     \}
00212     EIGEN\_DEVICE\_FUNC
00213     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index i0, Index i1, Index i2, Index i3)\textcolor{keyword}{ const}
00214 \textcolor{keyword}{    }\{
00215       \textcolor{keywordflow}{return} coeff(\hyperlink{class_eigen_1_1array}{array<Index, 4>}(i0, i1, i2, i3));
00216     \}
00217     EIGEN\_DEVICE\_FUNC
00218     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index i0, Index i1, Index i2, Index i3, Index i4)\textcolor{keyword}{ const}
00219 \textcolor{keyword}{    }\{
00220       \textcolor{keywordflow}{return} coeff(\hyperlink{class_eigen_1_1array}{array<Index, 5>}(i0, i1, i2, i3, i4));
00221     \}
00222 \textcolor{preprocessor}{#endif}
00223 
00224     \textcolor{comment}{// custom indices}
00225 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_SFINAE}
00226     \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomIndices,
00227              EIGEN\_SFINAE\_ENABLE\_IF( !(isOfNormalIndex<CustomIndices>::value) )
00228     >
00229     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(CustomIndices& indices)\textcolor{keyword}{ const}
00230 \textcolor{keyword}{    }\{
00231         \textcolor{keywordflow}{return} coeff(internal::customIndices2Array<Index,NumIndices>(indices));
00232     \}
00233 \textcolor{preprocessor}{#endif}
00234 
00235     \textcolor{comment}{// normal indices}
00236     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(\textcolor{keyword}{const} 
      \hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}& indices)\textcolor{keyword}{ const}
00237 \textcolor{keyword}{    }\{
00238       \textcolor{keywordflow}{return} coeff(indices);
00239     \}
00240 
00241     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index index)\textcolor{keyword}{ const}
00242 \textcolor{keyword}{    }\{
00243       eigen\_internal\_assert(index >= 0 && index < size());
00244       \textcolor{keywordflow}{return} coeff(index);
00245     \}
00246 
00247     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()()\textcolor{keyword}{ const}
00248 \textcolor{keyword}{    }\{
00249       EIGEN\_STATIC\_ASSERT(NumIndices == 0, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00250       \textcolor{keywordflow}{return} coeff();
00251     \}
00252 
00253     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator[](Index index)\textcolor{keyword}{ const}
00254 \textcolor{keyword}{    }\{
00255       \textcolor{comment}{// The bracket operator is only for vectors, use the parenthesis operator instead.}
00256       EIGEN\_STATIC\_ASSERT(NumIndices == 1, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00257       \textcolor{keywordflow}{return} coeff(index);
00258     \}
00259 
00260 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00261     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes>
00262     \textcolor{keyword}{inline} Scalar& operator()(Index firstIndex, Index secondIndex, IndexTypes... otherIndices)
00263     \{
00264       \textcolor{comment}{// The number of indices used to access a tensor coefficient must be equal to the rank of the tensor.}
00265       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}...(otherIndices) + 2 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00266       \textcolor{keywordflow}{return} operator()(\hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}\{\{firstIndex, secondIndex, 
      otherIndices...\}\});
00267     \}
00268 \textcolor{preprocessor}{#else}
00269     EIGEN\_DEVICE\_FUNC
00270     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1)
00271     \{
00272       \textcolor{keywordflow}{return} coeffRef(\hyperlink{class_eigen_1_1array}{array<Index, 2>}(i0, i1));
00273     \}
00274     EIGEN\_DEVICE\_FUNC
00275     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1, Index i2)
00276     \{
00277       \textcolor{keywordflow}{return} coeffRef(\hyperlink{class_eigen_1_1array}{array<Index, 3>}(i0, i1, i2));
00278     \}
00279     EIGEN\_DEVICE\_FUNC
00280     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3)
00281     \{
00282       \textcolor{keywordflow}{return} coeffRef(\hyperlink{class_eigen_1_1array}{array<Index, 4>}(i0, i1, i2, i3));
00283     \}
00284     EIGEN\_DEVICE\_FUNC
00285     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3, Index i4)
00286     \{
00287       \textcolor{keywordflow}{return} coeffRef(\hyperlink{class_eigen_1_1array}{array<Index, 5>}(i0, i1, i2, i3, i4));
00288     \}
00289 \textcolor{preprocessor}{#endif}
00290 
00291     \textcolor{comment}{// normal indices}
00292     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& operator()(\textcolor{keyword}{const} 
      \hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}& indices)
00293     \{
00294       \textcolor{keywordflow}{return} coeffRef(indices);
00295     \}
00296 
00297     \textcolor{comment}{// custom indices}
00298 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_SFINAE}
00299     \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomIndices,
00300              EIGEN\_SFINAE\_ENABLE\_IF( !(isOfNormalIndex<CustomIndices>::value) )
00301     >
00302     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& operator()(CustomIndices& indices)
00303     \{
00304       \textcolor{keywordflow}{return} coeffRef(internal::customIndices2Array<Index,NumIndices>(indices));
00305     \}
00306 \textcolor{preprocessor}{#endif}
00307 
00308     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& operator()(Index index)
00309     \{
00310       eigen\_assert(index >= 0 && index < size());
00311       \textcolor{keywordflow}{return} coeffRef(index);
00312     \}
00313 
00314     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& operator()()
00315     \{
00316       EIGEN\_STATIC\_ASSERT(NumIndices == 0, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00317       \textcolor{keywordflow}{return} coeffRef();
00318     \}
00319 
00320     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar& operator[](Index index)
00321     \{
00322       \textcolor{comment}{// The bracket operator is only for vectors, use the parenthesis operator instead}
00323       EIGEN\_STATIC\_ASSERT(NumIndices == 1, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00324       \textcolor{keywordflow}{return} coeffRef(index);
00325     \}
00326 
00327     EIGEN\_DEVICE\_FUNC
00328     EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor}{Tensor}()
00329       : m\_storage()
00330     \{
00331     \}
00332 
00333     EIGEN\_DEVICE\_FUNC
00334     EIGEN\_STRONG\_INLINE Tensor(\textcolor{keyword}{const} Self& other)
00335       : m\_storage(other.m\_storage)
00336     \{
00337     \}
00338 
00339 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00340     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes>
00341     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Tensor(Index firstDimension, IndexTypes... otherDimensions)
00342         : m\_storage(firstDimension, otherDimensions...)
00343     \{
00344       \textcolor{comment}{// The number of dimensions used to construct a tensor must be equal to the rank of the tensor.}
00345       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}...(otherDimensions) + 1 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00346     \}
00347 \textcolor{preprocessor}{#else}
00348     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} Tensor(Index dim1)
00349       : m\_storage(dim1, \hyperlink{class_eigen_1_1array}{array<Index, 1>}(dim1))
00350     \{
00351       EIGEN\_STATIC\_ASSERT(1 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00352     \}
00353     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Tensor(Index dim1, Index dim2)
00354       : m\_storage(dim1*dim2, \hyperlink{class_eigen_1_1array}{array<Index, 2>}(dim1, dim2))
00355     \{
00356       EIGEN\_STATIC\_ASSERT(2 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00357     \}
00358     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Tensor(Index dim1, Index dim2, Index dim3)
00359       : m\_storage(dim1*dim2*dim3, \hyperlink{class_eigen_1_1array}{array<Index, 3>}(dim1, dim2, dim3))
00360     \{
00361       EIGEN\_STATIC\_ASSERT(3 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00362     \}
00363     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Tensor(Index dim1, Index dim2, Index dim3, Index dim4)
00364       : m\_storage(dim1*dim2*dim3*dim4, \hyperlink{class_eigen_1_1array}{array<Index, 4>}(dim1, dim2, dim3, dim4))
00365     \{
00366       EIGEN\_STATIC\_ASSERT(4 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00367     \}
00368     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Tensor(Index dim1, Index dim2, Index dim3, Index dim4, Index dim5
      )
00369       : m\_storage(dim1*dim2*dim3*dim4*dim5, \hyperlink{class_eigen_1_1array}{array<Index, 5>}(dim1, dim2, dim3, dim4, dim5))
00370     \{
00371       EIGEN\_STATIC\_ASSERT(5 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00372     \}
00373 \textcolor{preprocessor}{#endif}
00374 
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_8h_source_l00376}\hyperlink{class_eigen_1_1_tensor_a6ef6b578cd0ca367842b0d8888e22195}{00376}     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1_tensor_a6ef6b578cd0ca367842b0d8888e22195}{Tensor}(\textcolor{keyword}{const} 
      \hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}& dimensions)
00377         : m\_storage(\hyperlink{namespaceinternal}{internal}::array\_prod(dimensions), dimensions)
00378     \{
00379       EIGEN\_INITIALIZE\_COEFFS\_IF\_THAT\_OPTION\_IS\_ENABLED
00380     \}
00381 
00382     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00383     EIGEN\_DEVICE\_FUNC
00384     EIGEN\_STRONG\_INLINE Tensor(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase<OtherDerived, ReadOnlyAccessors>}
      & other)
00385     \{
00386       \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp<Tensor, const OtherDerived>} Assign;
00387       Assign assign(*\textcolor{keyword}{this}, other.derived());
00388       resize(\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<const Assign, DefaultDevice>}(
      assign, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}()).dimensions());
00389       \hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{internal::TensorExecutor<const Assign, DefaultDevice>::run}
      (assign, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}());
00390     \}
00391     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00392     EIGEN\_DEVICE\_FUNC
00393     EIGEN\_STRONG\_INLINE Tensor(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase<OtherDerived, WriteAccessors>}
      & other)
00394     \{
00395       \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp<Tensor, const OtherDerived>} Assign;
00396       Assign assign(*\textcolor{keyword}{this}, other.derived());
00397       resize(\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<const Assign, DefaultDevice>}(
      assign, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}()).dimensions());
00398       \hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{internal::TensorExecutor<const Assign, DefaultDevice>::run}
      (assign, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}());
00399     \}
00400 
00401     EIGEN\_DEVICE\_FUNC
00402     EIGEN\_STRONG\_INLINE Tensor& operator=(\textcolor{keyword}{const} Tensor& other)
00403     \{
00404       \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp<Tensor, const Tensor>} Assign;
00405       Assign assign(*\textcolor{keyword}{this}, other);
00406       resize(\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<const Assign, DefaultDevice>}(
      assign, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}()).dimensions());
00407       \hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{internal::TensorExecutor<const Assign, DefaultDevice>::run}
      (assign, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}());
00408       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00409     \}
00410     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00411     EIGEN\_DEVICE\_FUNC
00412     EIGEN\_STRONG\_INLINE Tensor& operator=(\textcolor{keyword}{const} OtherDerived& other)
00413     \{
00414       \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_assign_op}{TensorAssignOp<Tensor, const OtherDerived>} Assign;
00415       Assign assign(*\textcolor{keyword}{this}, other);
00416       resize(\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<const Assign, DefaultDevice>}(
      assign, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}()).dimensions());
00417       \hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{internal::TensorExecutor<const Assign, DefaultDevice>::run}
      (assign, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}());
00418       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00419     \}
00420 
00421 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00422     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes> EIGEN\_DEVICE\_FUNC
00423     \textcolor{keywordtype}{void} resize(Index firstDimension, IndexTypes... otherDimensions)
00424     \{
00425       \textcolor{comment}{// The number of dimensions used to resize a tensor must be equal to the rank of the tensor.}
00426       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}...(otherDimensions) + 1 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00427       resize(\hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}\{\{firstDimension, otherDimensions...\}\});
00428     \}
00429 \textcolor{preprocessor}{#endif}
00430 
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_8h_source_l00432}\hyperlink{class_eigen_1_1_tensor_a5ab1ec6dc9b05d5e4db3600bc9d2cc6b}{00432}     EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_tensor_a5ab1ec6dc9b05d5e4db3600bc9d2cc6b}{resize}(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}& dimensions)
00433     \{
00434       \textcolor{keywordtype}{int} i;
00435       Index size = Index(1);
00436       \textcolor{keywordflow}{for} (i = 0; i < NumIndices; i++) \{
00437         \hyperlink{struct_eigen_1_1internal_1_1check__rows__cols__for__overflow}{internal::check\_rows\_cols\_for\_overflow<Dynamic>::run}
      (size, dimensions[i]);
00438         size *= dimensions[i];
00439       \}
00440 \textcolor{preprocessor}{      #ifdef EIGEN\_INITIALIZE\_COEFFS}
00441         \textcolor{keywordtype}{bool} size\_changed = size != this->size();
00442         m\_storage.resize(size, dimensions);
00443         \textcolor{keywordflow}{if}(size\_changed) EIGEN\_INITIALIZE\_COEFFS\_IF\_THAT\_OPTION\_IS\_ENABLED
00444 \textcolor{preprocessor}{      #else}
00445         m\_storage.resize(size, dimensions);
00446 \textcolor{preprocessor}{      #endif}
00447     \}
00448 
00449     \textcolor{comment}{// Why this overload, DSizes is derived from array ??? //}
00450     EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} resize(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumIndices>}& dimensions) \{
00451       \hyperlink{class_eigen_1_1array}{array<Index, NumIndices>} dims;
00452       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumIndices; ++i) \{
00453         dims[i] = dimensions[i];
00454       \}
00455       resize(dims);
00456     \}
00457 
00458     EIGEN\_DEVICE\_FUNC
00459     \textcolor{keywordtype}{void} resize()
00460     \{
00461       EIGEN\_STATIC\_ASSERT(NumIndices == 0, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00462       \textcolor{comment}{// Nothing to do: rank 0 tensors have fixed size}
00463     \}
00464 
00466 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_SFINAE}
00467     \textcolor{keyword}{template}<\textcolor{keyword}{typename} CustomDimension,
00468              EIGEN\_SFINAE\_ENABLE\_IF( !(isOfNormalIndex<CustomDimension>::value) )
00469     >
00470     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} resize(CustomDimension& dimensions)
00471     \{
00472       resize(internal::customIndices2Array<Index,NumIndices>(dimensions));
00473     \}
00474 \textcolor{preprocessor}{#endif}
00475 
00476 \textcolor{preprocessor}{#ifndef EIGEN\_EMULATE\_CXX11\_META\_H}
00477     \textcolor{keyword}{template} <\textcolor{keyword}{typename} std::ptrdiff\_t... Indices>
00478     EIGEN\_DEVICE\_FUNC
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_8h_source_l00479}\hyperlink{class_eigen_1_1_tensor_a4f637a19784e5d0391882bd9fab0917e}{00479}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_tensor_a4f637a19784e5d0391882bd9fab0917e}{resize}(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_sizes}{Sizes<Indices...>}& dimensions) \{
00480       \hyperlink{class_eigen_1_1array}{array<Index, NumIndices>} dims;
00481       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumIndices; ++i) \{
00482         dims[i] = \textcolor{keyword}{static\_cast<}Index\textcolor{keyword}{>}(dimensions[i]);
00483       \}
00484       resize(dims);
00485     \}
00486 \textcolor{preprocessor}{#else}
00487     \textcolor{keyword}{template} <std::\textcolor{keywordtype}{size\_t} V1, std::\textcolor{keywordtype}{size\_t} V2, std::\textcolor{keywordtype}{size\_t} V3, std::\textcolor{keywordtype}{size\_t} V4, std::\textcolor{keywordtype}{size\_t} V5>
00488     EIGEN\_DEVICE\_FUNC
00489     \textcolor{keywordtype}{void} resize(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_sizes}{Sizes<V1, V2, V3, V4, V5>}& dimensions) \{
00490       \hyperlink{class_eigen_1_1array}{array<Index, NumIndices>} dims;
00491       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumIndices; ++i) \{
00492         dims[i] = \textcolor{keyword}{static\_cast<}Index\textcolor{keyword}{>}(dimensions[i]);
00493       \}
00494       resize(dims);
00495     \}
00496 \textcolor{preprocessor}{#endif}
00497 
00498   \textcolor{keyword}{protected}:
00499 
00500     \textcolor{keywordtype}{bool} checkIndexRange(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}& indices)\textcolor{keyword}{ const}
00501 \textcolor{keyword}{    }\{
00502       \textcolor{keyword}{using} internal::array\_apply\_and\_reduce;
00503       \textcolor{keyword}{using} internal::array\_zip\_and\_reduce;
00504       \textcolor{keyword}{using} \hyperlink{struct_eigen_1_1internal_1_1greater__equal__zero__op}{internal::greater\_equal\_zero\_op};
00505       \textcolor{keyword}{using} \hyperlink{struct_eigen_1_1internal_1_1logical__and__op}{internal::logical\_and\_op};
00506       \textcolor{keyword}{using} \hyperlink{struct_eigen_1_1internal_1_1lesser__op}{internal::lesser\_op};
00507 
00508       \textcolor{keywordflow}{return}
00509         \textcolor{comment}{// check whether the indices are all >= 0}
00510         array\_apply\_and\_reduce<logical\_and\_op, greater\_equal\_zero\_op>(indices) &&
00511         \textcolor{comment}{// check whether the indices fit in the dimensions}
00512         array\_zip\_and\_reduce<logical\_and\_op, lesser\_op>(indices, m\_storage.dimensions());
00513     \}
00514 
00515     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index linearizedIndex(\textcolor{keyword}{const} 
      \hyperlink{class_eigen_1_1array}{array<Index, NumIndices>}& indices)\textcolor{keyword}{ const}
00516 \textcolor{keyword}{    }\{
00517       \textcolor{keywordflow}{if} (Options&\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) \{
00518         \textcolor{keywordflow}{return} m\_storage.dimensions().IndexOfRowMajor(indices);
00519       \} \textcolor{keywordflow}{else} \{
00520         \textcolor{keywordflow}{return} m\_storage.dimensions().IndexOfColMajor(indices);
00521       \}
00522     \}
00523 \};
00524 
00525 \} \textcolor{comment}{// end namespace Eigen}
00526 
00527 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_H}
\end{DoxyCode}
