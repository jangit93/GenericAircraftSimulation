\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_cwise_binary_op_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+Core/\+Sparse\+Cwise\+Binary\+Op.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_cwise_binary_op_8h_source}\index{Sparse\+Cwise\+Binary\+Op.\+h@{Sparse\+Cwise\+Binary\+Op.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSE\_CWISE\_BINARY\_OP\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SPARSE\_CWISE\_BINARY\_OP\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{comment}{// Here we have to handle 3 cases:}
00016 \textcolor{comment}{//  1 - sparse op dense}
00017 \textcolor{comment}{//  2 - dense op sparse}
00018 \textcolor{comment}{//  3 - sparse op sparse}
00019 \textcolor{comment}{// We also need to implement a 4th iterator for:}
00020 \textcolor{comment}{//  4 - dense op dense}
00021 \textcolor{comment}{// Finally, we also need to distinguish between the product and other operations :}
00022 \textcolor{comment}{//                configuration      returned mode}
00023 \textcolor{comment}{//  1 - sparse op dense    product      sparse}
00024 \textcolor{comment}{//                         generic      dense}
00025 \textcolor{comment}{//  2 - dense op sparse    product      sparse}
00026 \textcolor{comment}{//                         generic      dense}
00027 \textcolor{comment}{//  3 - sparse op sparse   product      sparse}
00028 \textcolor{comment}{//                         generic      sparse}
00029 \textcolor{comment}{//  4 - dense op dense     product      dense}
00030 \textcolor{comment}{//                         generic      dense}
00031 \textcolor{comment}{//}
00032 \textcolor{comment}{// TODO to ease compiler job, we could specialize product/quotient with a scalar}
00033 \textcolor{comment}{//      and fallback to cwise-unary evaluator using bind1st\_op and bind2nd\_op.}
00034 
00035 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00036 \textcolor{keyword}{class }CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Sparse>
00037   : \textcolor{keyword}{public} SparseMatrixBase<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
00038 \{
00039   \textcolor{keyword}{public}:
00040     \textcolor{keyword}{typedef} CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;
00041     \textcolor{keyword}{typedef} SparseMatrixBase<Derived> Base;
00042     EIGEN\_SPARSE\_PUBLIC\_INTERFACE(Derived)
00043     CwiseBinaryOpImpl()
00044     \{
00045       EIGEN\_STATIC\_ASSERT((
00046                 (!internal::is\_same<\textcolor{keyword}{typename} internal::traits<Lhs>::StorageKind,
00047                                     \textcolor{keyword}{typename} internal::traits<Rhs>::StorageKind>::value)
00048             ||  ((internal::evaluator<Lhs>::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) == (
      internal::evaluator<Rhs>::Flags&RowMajorBit))),
00049             THE\_STORAGE\_ORDER\_OF\_BOTH\_SIDES\_MUST\_MATCH);
00050     \}
00051 \};
00052 
00053 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00054 
00055   
00056 \textcolor{comment}{// Generic "sparse OP sparse"}
00057 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType> \textcolor{keyword}{struct }binary\_sparse\_evaluator;
00058 
00059 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00060 \textcolor{keyword}{struct }binary\_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IteratorBased, IteratorBased>
00061   : evaluator\_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
00062 \{
00063 \textcolor{keyword}{protected}:
00064   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<Lhs>::InnerIterator  LhsIterator;
00065   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<Rhs>::InnerIterator  RhsIterator;
00066   \textcolor{keyword}{typedef} CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;
00067   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<XprType>::Scalar Scalar;
00068   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::StorageIndex StorageIndex;
00069 \textcolor{keyword}{public}:
00070 
00071   \textcolor{keyword}{class }InnerIterator
00072   \{
00073   \textcolor{keyword}{public}:
00074     
00075     EIGEN\_STRONG\_INLINE InnerIterator(\textcolor{keyword}{const} binary\_evaluator& aEval, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer)
00076       : m\_lhsIter(aEval.m\_lhsImpl,outer), m\_rhsIter(aEval.m\_rhsImpl,outer), m\_functor(aEval.m\_functor)
00077     \{
00078       this->operator++();
00079     \}
00080 
00081     EIGEN\_STRONG\_INLINE InnerIterator& operator++()
00082     \{
00083       \textcolor{keywordflow}{if} (m\_lhsIter && m\_rhsIter && (m\_lhsIter.index() == m\_rhsIter.index()))
00084       \{
00085         m\_id = m\_lhsIter.index();
00086         m\_value = m\_functor(m\_lhsIter.value(), m\_rhsIter.value());
00087         ++m\_lhsIter;
00088         ++m\_rhsIter;
00089       \}
00090       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_lhsIter && (!m\_rhsIter || (m\_lhsIter.index() < m\_rhsIter.index())))
00091       \{
00092         m\_id = m\_lhsIter.index();
00093         m\_value = m\_functor(m\_lhsIter.value(), Scalar(0));
00094         ++m\_lhsIter;
00095       \}
00096       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_rhsIter && (!m\_lhsIter || (m\_lhsIter.index() > m\_rhsIter.index())))
00097       \{
00098         m\_id = m\_rhsIter.index();
00099         m\_value = m\_functor(Scalar(0), m\_rhsIter.value());
00100         ++m\_rhsIter;
00101       \}
00102       \textcolor{keywordflow}{else}
00103       \{
00104         m\_value = 0; \textcolor{comment}{// this is to avoid a compilation warning}
00105         m\_id = -1;
00106       \}
00107       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00108     \}
00109 
00110     EIGEN\_STRONG\_INLINE Scalar value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_value; \}
00111 
00112     EIGEN\_STRONG\_INLINE StorageIndex index()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_id; \}
00113     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhsIter.outer(); \}
00114     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} Lhs::IsRowMajor ? m\_lhsIter.row() : index(); \}
00115     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} Lhs::IsRowMajor ? index() : m\_lhsIter.col(); \}
00116 
00117     EIGEN\_STRONG\_INLINE \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_id>=0; \}
00118 
00119   \textcolor{keyword}{protected}:
00120     LhsIterator m\_lhsIter;
00121     RhsIterator m\_rhsIter;
00122     \textcolor{keyword}{const} BinaryOp& m\_functor;
00123     Scalar m\_value;
00124     StorageIndex m\_id;
00125   \};
00126   
00127   
00128   \textcolor{keyword}{enum} \{
00129     CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + 
      functor\_traits<BinaryOp>::Cost,
00130     Flags = XprType::Flags
00131   \};
00132   
00133   \textcolor{keyword}{explicit} binary\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00134     : m\_functor(xpr.functor()),
00135       m\_lhsImpl(xpr.lhs()), 
00136       m\_rhsImpl(xpr.rhs())  
00137   \{
00138     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(functor\_traits<BinaryOp>::Cost);
00139     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00140   \}
00141   
00142   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nonZerosEstimate()\textcolor{keyword}{ const }\{
00143     \textcolor{keywordflow}{return} m\_lhsImpl.nonZerosEstimate() + m\_rhsImpl.nonZerosEstimate();
00144   \}
00145 
00146 \textcolor{keyword}{protected}:
00147   \textcolor{keyword}{const} BinaryOp m\_functor;
00148   evaluator<Lhs> m\_lhsImpl;
00149   evaluator<Rhs> m\_rhsImpl;
00150 \};
00151 
00152 \textcolor{comment}{// dense op sparse}
00153 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00154 \textcolor{keyword}{struct }binary\_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IndexBased, IteratorBased>
00155   : evaluator\_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
00156 \{
00157 \textcolor{keyword}{protected}:
00158   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<Rhs>::InnerIterator  RhsIterator;
00159   \textcolor{keyword}{typedef} CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;
00160   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<XprType>::Scalar Scalar;
00161   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::StorageIndex StorageIndex;
00162 \textcolor{keyword}{public}:
00163 
00164   \textcolor{keyword}{class }InnerIterator
00165   \{
00166     \textcolor{keyword}{enum} \{ IsRowMajor = (int(Rhs::Flags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} \};
00167   \textcolor{keyword}{public}:
00168 
00169     EIGEN\_STRONG\_INLINE InnerIterator(\textcolor{keyword}{const} binary\_evaluator& aEval, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer)
00170       : m\_lhsEval(aEval.m\_lhsImpl), m\_rhsIter(aEval.m\_rhsImpl,outer), m\_functor(aEval.m\_functor), m\_value(0
      ), m\_id(-1), m\_innerSize(aEval.m\_expr.rhs().innerSize())
00171     \{
00172       this->operator++();
00173     \}
00174 
00175     EIGEN\_STRONG\_INLINE InnerIterator& operator++()
00176     \{
00177       ++m\_id;
00178       \textcolor{keywordflow}{if}(m\_id<m\_innerSize)
00179       \{
00180         Scalar lhsVal = m\_lhsEval.coeff(IsRowMajor?m\_rhsIter.outer():m\_id,
00181                                         IsRowMajor?m\_id:m\_rhsIter.outer());
00182         \textcolor{keywordflow}{if}(m\_rhsIter && m\_rhsIter.index()==m\_id)
00183         \{
00184           m\_value = m\_functor(lhsVal, m\_rhsIter.value());
00185           ++m\_rhsIter;
00186         \}
00187         \textcolor{keywordflow}{else}
00188           m\_value = m\_functor(lhsVal, Scalar(0));
00189       \}
00190 
00191       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00192     \}
00193 
00194     EIGEN\_STRONG\_INLINE Scalar value()\textcolor{keyword}{ const }\{ eigen\_internal\_assert(m\_id<m\_innerSize); \textcolor{keywordflow}{return} m\_value; \}
00195 
00196     EIGEN\_STRONG\_INLINE StorageIndex index()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_id; \}
00197     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rhsIter.outer(); \}
00198     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_rhsIter.outer() : m\_id; \}
00199     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_id : m\_rhsIter.outer(); \}
00200 
00201     EIGEN\_STRONG\_INLINE \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_id<m\_innerSize; \}
00202 
00203   \textcolor{keyword}{protected}:
00204     \textcolor{keyword}{const} evaluator<Lhs> &m\_lhsEval;
00205     RhsIterator m\_rhsIter;
00206     \textcolor{keyword}{const} BinaryOp& m\_functor;
00207     Scalar m\_value;
00208     StorageIndex m\_id;
00209     StorageIndex m\_innerSize;
00210   \};
00211 
00212 
00213   \textcolor{keyword}{enum} \{
00214     CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + 
      functor\_traits<BinaryOp>::Cost,
00215     \textcolor{comment}{// Expose storage order of the sparse expression}
00216     Flags = (XprType::Flags & ~\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) | (\textcolor{keywordtype}{int}(Rhs::Flags)&
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})
00217   \};
00218 
00219   \textcolor{keyword}{explicit} binary\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00220     : m\_functor(xpr.functor()),
00221       m\_lhsImpl(xpr.lhs()),
00222       m\_rhsImpl(xpr.rhs()),
00223       m\_expr(xpr)
00224   \{
00225     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(functor\_traits<BinaryOp>::Cost);
00226     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00227   \}
00228 
00229   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nonZerosEstimate()\textcolor{keyword}{ const }\{
00230     \textcolor{keywordflow}{return} m\_expr.size();
00231   \}
00232 
00233 \textcolor{keyword}{protected}:
00234   \textcolor{keyword}{const} BinaryOp m\_functor;
00235   evaluator<Lhs> m\_lhsImpl;
00236   evaluator<Rhs> m\_rhsImpl;
00237   \textcolor{keyword}{const} XprType &m\_expr;
00238 \};
00239 
00240 \textcolor{comment}{// sparse op dense}
00241 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00242 \textcolor{keyword}{struct }binary\_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IteratorBased, IndexBased>
00243   : evaluator\_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
00244 \{
00245 \textcolor{keyword}{protected}:
00246   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<Lhs>::InnerIterator  LhsIterator;
00247   \textcolor{keyword}{typedef} CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;
00248   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<XprType>::Scalar Scalar;
00249   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::StorageIndex StorageIndex;
00250 \textcolor{keyword}{public}:
00251 
00252   \textcolor{keyword}{class }InnerIterator
00253   \{
00254     \textcolor{keyword}{enum} \{ IsRowMajor = (int(Lhs::Flags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} \};
00255   \textcolor{keyword}{public}:
00256 
00257     EIGEN\_STRONG\_INLINE InnerIterator(\textcolor{keyword}{const} binary\_evaluator& aEval, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer)
00258       : m\_lhsIter(aEval.m\_lhsImpl,outer), m\_rhsEval(aEval.m\_rhsImpl), m\_functor(aEval.m\_functor), m\_value(0
      ), m\_id(-1), m\_innerSize(aEval.m\_expr.lhs().innerSize())
00259     \{
00260       this->operator++();
00261     \}
00262 
00263     EIGEN\_STRONG\_INLINE InnerIterator& operator++()
00264     \{
00265       ++m\_id;
00266       \textcolor{keywordflow}{if}(m\_id<m\_innerSize)
00267       \{
00268         Scalar rhsVal = m\_rhsEval.coeff(IsRowMajor?m\_lhsIter.outer():m\_id,
00269                                         IsRowMajor?m\_id:m\_lhsIter.outer());
00270         \textcolor{keywordflow}{if}(m\_lhsIter && m\_lhsIter.index()==m\_id)
00271         \{
00272           m\_value = m\_functor(m\_lhsIter.value(), rhsVal);
00273           ++m\_lhsIter;
00274         \}
00275         \textcolor{keywordflow}{else}
00276           m\_value = m\_functor(Scalar(0),rhsVal);
00277       \}
00278 
00279       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00280     \}
00281 
00282     EIGEN\_STRONG\_INLINE Scalar value()\textcolor{keyword}{ const }\{ eigen\_internal\_assert(m\_id<m\_innerSize); \textcolor{keywordflow}{return} m\_value; \}
00283 
00284     EIGEN\_STRONG\_INLINE StorageIndex index()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_id; \}
00285     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhsIter.outer(); \}
00286     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_lhsIter.outer() : m\_id; \}
00287     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_id : m\_lhsIter.outer(); \}
00288 
00289     EIGEN\_STRONG\_INLINE \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_id<m\_innerSize; \}
00290 
00291   \textcolor{keyword}{protected}:
00292     LhsIterator m\_lhsIter;
00293     \textcolor{keyword}{const} evaluator<Rhs> &m\_rhsEval;
00294     \textcolor{keyword}{const} BinaryOp& m\_functor;
00295     Scalar m\_value;
00296     StorageIndex m\_id;
00297     StorageIndex m\_innerSize;
00298   \};
00299 
00300 
00301   \textcolor{keyword}{enum} \{
00302     CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + 
      functor\_traits<BinaryOp>::Cost,
00303     \textcolor{comment}{// Expose storage order of the sparse expression}
00304     Flags = (XprType::Flags & ~\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) | (\textcolor{keywordtype}{int}(Lhs::Flags)&
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})
00305   \};
00306 
00307   \textcolor{keyword}{explicit} binary\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00308     : m\_functor(xpr.functor()),
00309       m\_lhsImpl(xpr.lhs()),
00310       m\_rhsImpl(xpr.rhs()),
00311       m\_expr(xpr)
00312   \{
00313     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(functor\_traits<BinaryOp>::Cost);
00314     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00315   \}
00316 
00317   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nonZerosEstimate()\textcolor{keyword}{ const }\{
00318     \textcolor{keywordflow}{return} m\_expr.size();
00319   \}
00320 
00321 \textcolor{keyword}{protected}:
00322   \textcolor{keyword}{const} BinaryOp m\_functor;
00323   evaluator<Lhs> m\_lhsImpl;
00324   evaluator<Rhs> m\_rhsImpl;
00325   \textcolor{keyword}{const} XprType &m\_expr;
00326 \};
00327 
00328 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T},
00329          \textcolor{keyword}{typename} LhsKind   = \textcolor{keyword}{typename} evaluator\_traits<typename T::Lhs>::Kind,
00330          \textcolor{keyword}{typename} RhsKind   = \textcolor{keyword}{typename} evaluator\_traits<typename T::Rhs>::Kind,
00331          \textcolor{keyword}{typename} LhsScalar = \textcolor{keyword}{typename} traits<typename T::Lhs>::Scalar,
00332          \textcolor{keyword}{typename} RhsScalar = \textcolor{keyword}{typename} traits<typename T::Rhs>::Scalar> \textcolor{keyword}{struct }sparse\_conjunction\_evaluator
      ;
00333 
00334 \textcolor{comment}{// "sparse .* sparse"}
00335 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00336 \textcolor{keyword}{struct }binary\_evaluator<CwiseBinaryOp<scalar\_product\_op<T1,T2>, Lhs, Rhs>, IteratorBased, IteratorBased>
00337   : sparse\_conjunction\_evaluator<CwiseBinaryOp<scalar\_product\_op<T1,T2>, Lhs, Rhs> >
00338 \{
00339   \textcolor{keyword}{typedef} CwiseBinaryOp<scalar\_product\_op<T1,T2>, Lhs, Rhs> XprType;
00340   \textcolor{keyword}{typedef} sparse\_conjunction\_evaluator<XprType> Base;
00341   \textcolor{keyword}{explicit} binary\_evaluator(\textcolor{keyword}{const} XprType& xpr) : Base(xpr) \{\}
00342 \};
00343 \textcolor{comment}{// "dense .* sparse"}
00344 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00345 \textcolor{keyword}{struct }binary\_evaluator<CwiseBinaryOp<scalar\_product\_op<T1,T2>, Lhs, Rhs>, IndexBased, IteratorBased>
00346   : sparse\_conjunction\_evaluator<CwiseBinaryOp<scalar\_product\_op<T1,T2>, Lhs, Rhs> >
00347 \{
00348   \textcolor{keyword}{typedef} CwiseBinaryOp<scalar\_product\_op<T1,T2>, Lhs, Rhs> XprType;
00349   \textcolor{keyword}{typedef} sparse\_conjunction\_evaluator<XprType> Base;
00350   \textcolor{keyword}{explicit} binary\_evaluator(\textcolor{keyword}{const} XprType& xpr) : Base(xpr) \{\}
00351 \};
00352 \textcolor{comment}{// "sparse .* dense"}
00353 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00354 \textcolor{keyword}{struct }binary\_evaluator<CwiseBinaryOp<scalar\_product\_op<T1,T2>, Lhs, Rhs>, IteratorBased, IndexBased>
00355   : sparse\_conjunction\_evaluator<CwiseBinaryOp<scalar\_product\_op<T1,T2>, Lhs, Rhs> >
00356 \{
00357   \textcolor{keyword}{typedef} CwiseBinaryOp<scalar\_product\_op<T1,T2>, Lhs, Rhs> XprType;
00358   \textcolor{keyword}{typedef} sparse\_conjunction\_evaluator<XprType> Base;
00359   \textcolor{keyword}{explicit} binary\_evaluator(\textcolor{keyword}{const} XprType& xpr) : Base(xpr) \{\}
00360 \};
00361 
00362 \textcolor{comment}{// "sparse ./ dense"}
00363 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00364 \textcolor{keyword}{struct }binary\_evaluator<CwiseBinaryOp<scalar\_quotient\_op<T1,T2>, Lhs, Rhs>, IteratorBased, IndexBased>
00365   : sparse\_conjunction\_evaluator<CwiseBinaryOp<scalar\_quotient\_op<T1,T2>, Lhs, Rhs> >
00366 \{
00367   \textcolor{keyword}{typedef} CwiseBinaryOp<scalar\_quotient\_op<T1,T2>, Lhs, Rhs> XprType;
00368   \textcolor{keyword}{typedef} sparse\_conjunction\_evaluator<XprType> Base;
00369   \textcolor{keyword}{explicit} binary\_evaluator(\textcolor{keyword}{const} XprType& xpr) : Base(xpr) \{\}
00370 \};
00371 
00372 \textcolor{comment}{// "sparse && sparse"}
00373 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00374 \textcolor{keyword}{struct }binary\_evaluator<CwiseBinaryOp<scalar\_boolean\_and\_op, Lhs, Rhs>, IteratorBased, IteratorBased>
00375   : sparse\_conjunction\_evaluator<CwiseBinaryOp<scalar\_boolean\_and\_op, Lhs, Rhs> >
00376 \{
00377   \textcolor{keyword}{typedef} CwiseBinaryOp<scalar\_boolean\_and\_op, Lhs, Rhs> XprType;
00378   \textcolor{keyword}{typedef} sparse\_conjunction\_evaluator<XprType> Base;
00379   \textcolor{keyword}{explicit} binary\_evaluator(\textcolor{keyword}{const} XprType& xpr) : Base(xpr) \{\}
00380 \};
00381 \textcolor{comment}{// "dense && sparse"}
00382 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00383 \textcolor{keyword}{struct }binary\_evaluator<CwiseBinaryOp<scalar\_boolean\_and\_op, Lhs, Rhs>, IndexBased, IteratorBased>
00384   : sparse\_conjunction\_evaluator<CwiseBinaryOp<scalar\_boolean\_and\_op, Lhs, Rhs> >
00385 \{
00386   \textcolor{keyword}{typedef} CwiseBinaryOp<scalar\_boolean\_and\_op, Lhs, Rhs> XprType;
00387   \textcolor{keyword}{typedef} sparse\_conjunction\_evaluator<XprType> Base;
00388   \textcolor{keyword}{explicit} binary\_evaluator(\textcolor{keyword}{const} XprType& xpr) : Base(xpr) \{\}
00389 \};
00390 \textcolor{comment}{// "sparse && dense"}
00391 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00392 \textcolor{keyword}{struct }binary\_evaluator<CwiseBinaryOp<scalar\_boolean\_and\_op, Lhs, Rhs>, IteratorBased, IndexBased>
00393   : sparse\_conjunction\_evaluator<CwiseBinaryOp<scalar\_boolean\_and\_op, Lhs, Rhs> >
00394 \{
00395   \textcolor{keyword}{typedef} CwiseBinaryOp<scalar\_boolean\_and\_op, Lhs, Rhs> XprType;
00396   \textcolor{keyword}{typedef} sparse\_conjunction\_evaluator<XprType> Base;
00397   \textcolor{keyword}{explicit} binary\_evaluator(\textcolor{keyword}{const} XprType& xpr) : Base(xpr) \{\}
00398 \};
00399 
00400 \textcolor{comment}{// "sparse ^ sparse"}
00401 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
00402 \textcolor{keyword}{struct }sparse\_conjunction\_evaluator<XprType, IteratorBased, IteratorBased>
00403   : evaluator\_base<XprType>
00404 \{
00405 \textcolor{keyword}{protected}:
00406   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Functor BinaryOp;
00407   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Lhs LhsArg;
00408   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Rhs RhsArg;
00409   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<LhsArg>::InnerIterator  LhsIterator;
00410   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<RhsArg>::InnerIterator  RhsIterator;
00411   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::StorageIndex StorageIndex;
00412   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<XprType>::Scalar Scalar;
00413 \textcolor{keyword}{public}:
00414 
00415   \textcolor{keyword}{class }InnerIterator
00416   \{
00417   \textcolor{keyword}{public}:
00418     
00419     EIGEN\_STRONG\_INLINE InnerIterator(\textcolor{keyword}{const} sparse\_conjunction\_evaluator& aEval, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer)
00420       : m\_lhsIter(aEval.m\_lhsImpl,outer), m\_rhsIter(aEval.m\_rhsImpl,outer), m\_functor(aEval.m\_functor)
00421     \{
00422       \textcolor{keywordflow}{while} (m\_lhsIter && m\_rhsIter && (m\_lhsIter.index() != m\_rhsIter.index()))
00423       \{
00424         \textcolor{keywordflow}{if} (m\_lhsIter.index() < m\_rhsIter.index())
00425           ++m\_lhsIter;
00426         \textcolor{keywordflow}{else}
00427           ++m\_rhsIter;
00428       \}
00429     \}
00430 
00431     EIGEN\_STRONG\_INLINE InnerIterator& operator++()
00432     \{
00433       ++m\_lhsIter;
00434       ++m\_rhsIter;
00435       \textcolor{keywordflow}{while} (m\_lhsIter && m\_rhsIter && (m\_lhsIter.index() != m\_rhsIter.index()))
00436       \{
00437         \textcolor{keywordflow}{if} (m\_lhsIter.index() < m\_rhsIter.index())
00438           ++m\_lhsIter;
00439         \textcolor{keywordflow}{else}
00440           ++m\_rhsIter;
00441       \}
00442       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00443     \}
00444     
00445     EIGEN\_STRONG\_INLINE Scalar value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_functor(m\_lhsIter.value(), m\_rhsIter.value()); \}
00446 
00447     EIGEN\_STRONG\_INLINE StorageIndex index()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhsIter.index(); \}
00448     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhsIter.outer(); \}
00449     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhsIter.row(); \}
00450     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhsIter.col(); \}
00451 
00452     EIGEN\_STRONG\_INLINE \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} (m\_lhsIter && m\_rhsIter); \}
00453 
00454   \textcolor{keyword}{protected}:
00455     LhsIterator m\_lhsIter;
00456     RhsIterator m\_rhsIter;
00457     \textcolor{keyword}{const} BinaryOp& m\_functor;
00458   \};
00459   
00460   
00461   \textcolor{keyword}{enum} \{
00462     CoeffReadCost = evaluator<LhsArg>::CoeffReadCost + evaluator<RhsArg>::CoeffReadCost + 
      functor\_traits<BinaryOp>::Cost,
00463     Flags = XprType::Flags
00464   \};
00465   
00466   \textcolor{keyword}{explicit} sparse\_conjunction\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00467     : m\_functor(xpr.functor()),
00468       m\_lhsImpl(xpr.lhs()), 
00469       m\_rhsImpl(xpr.rhs())  
00470   \{
00471     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(functor\_traits<BinaryOp>::Cost);
00472     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00473   \}
00474   
00475   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nonZerosEstimate()\textcolor{keyword}{ const }\{
00476     \textcolor{keywordflow}{return} (std::min)(m\_lhsImpl.nonZerosEstimate(), m\_rhsImpl.nonZerosEstimate());
00477   \}
00478 
00479 \textcolor{keyword}{protected}:
00480   \textcolor{keyword}{const} BinaryOp m\_functor;
00481   evaluator<LhsArg> m\_lhsImpl;
00482   evaluator<RhsArg> m\_rhsImpl;
00483 \};
00484 
00485 \textcolor{comment}{// "dense ^ sparse"}
00486 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
00487 \textcolor{keyword}{struct }sparse\_conjunction\_evaluator<XprType, IndexBased, IteratorBased>
00488   : evaluator\_base<XprType>
00489 \{
00490 \textcolor{keyword}{protected}:
00491   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Functor BinaryOp;
00492   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Lhs LhsArg;
00493   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Rhs RhsArg;
00494   \textcolor{keyword}{typedef} evaluator<LhsArg> LhsEvaluator;
00495   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<RhsArg>::InnerIterator  RhsIterator;
00496   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::StorageIndex StorageIndex;
00497   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<XprType>::Scalar Scalar;
00498 \textcolor{keyword}{public}:
00499 
00500   \textcolor{keyword}{class }InnerIterator
00501   \{
00502     \textcolor{keyword}{enum} \{ IsRowMajor = (int(RhsArg::Flags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} \};
00503 
00504   \textcolor{keyword}{public}:
00505     
00506     EIGEN\_STRONG\_INLINE InnerIterator(\textcolor{keyword}{const} sparse\_conjunction\_evaluator& aEval, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer)
00507       : m\_lhsEval(aEval.m\_lhsImpl), m\_rhsIter(aEval.m\_rhsImpl,outer), m\_functor(aEval.m\_functor), m\_outer(
      outer)
00508     \{\}
00509 
00510     EIGEN\_STRONG\_INLINE InnerIterator& operator++()
00511     \{
00512       ++m\_rhsIter;
00513       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00514     \}
00515 
00516     EIGEN\_STRONG\_INLINE Scalar value()\textcolor{keyword}{ const}
00517 \textcolor{keyword}{    }\{ \textcolor{keywordflow}{return} m\_functor(m\_lhsEval.coeff(IsRowMajor?m\_outer:m\_rhsIter.index(),IsRowMajor?m\_rhsIter.index():
      m\_outer), m\_rhsIter.value()); \}
00518 
00519     EIGEN\_STRONG\_INLINE StorageIndex index()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rhsIter.index(); \}
00520     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rhsIter.outer(); \}
00521     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rhsIter.row(); \}
00522     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rhsIter.col(); \}
00523 
00524     EIGEN\_STRONG\_INLINE \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rhsIter; \}
00525     
00526   \textcolor{keyword}{protected}:
00527     \textcolor{keyword}{const} LhsEvaluator &m\_lhsEval;
00528     RhsIterator m\_rhsIter;
00529     \textcolor{keyword}{const} BinaryOp& m\_functor;
00530     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_outer;
00531   \};
00532   
00533   
00534   \textcolor{keyword}{enum} \{
00535     CoeffReadCost = evaluator<LhsArg>::CoeffReadCost + evaluator<RhsArg>::CoeffReadCost + 
      functor\_traits<BinaryOp>::Cost,
00536     \textcolor{comment}{// Expose storage order of the sparse expression}
00537     Flags = (XprType::Flags & ~\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) | (\textcolor{keywordtype}{int}(RhsArg::Flags)&
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})
00538   \};
00539   
00540   \textcolor{keyword}{explicit} sparse\_conjunction\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00541     : m\_functor(xpr.functor()),
00542       m\_lhsImpl(xpr.lhs()), 
00543       m\_rhsImpl(xpr.rhs())  
00544   \{
00545     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(functor\_traits<BinaryOp>::Cost);
00546     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00547   \}
00548   
00549   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nonZerosEstimate()\textcolor{keyword}{ const }\{
00550     \textcolor{keywordflow}{return} m\_rhsImpl.nonZerosEstimate();
00551   \}
00552 
00553 \textcolor{keyword}{protected}:
00554   \textcolor{keyword}{const} BinaryOp m\_functor;
00555   evaluator<LhsArg> m\_lhsImpl;
00556   evaluator<RhsArg> m\_rhsImpl;
00557 \};
00558 
00559 \textcolor{comment}{// "sparse ^ dense"}
00560 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType>
00561 \textcolor{keyword}{struct }sparse\_conjunction\_evaluator<XprType, IteratorBased, IndexBased>
00562   : evaluator\_base<XprType>
00563 \{
00564 \textcolor{keyword}{protected}:
00565   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Functor BinaryOp;
00566   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Lhs LhsArg;
00567   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Rhs RhsArg;
00568   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<LhsArg>::InnerIterator LhsIterator;
00569   \textcolor{keyword}{typedef} evaluator<RhsArg> RhsEvaluator;
00570   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::StorageIndex StorageIndex;
00571   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits<XprType>::Scalar Scalar;
00572 \textcolor{keyword}{public}:
00573 
00574   \textcolor{keyword}{class }InnerIterator
00575   \{
00576     \textcolor{keyword}{enum} \{ IsRowMajor = (int(LhsArg::Flags)&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} \};
00577 
00578   \textcolor{keyword}{public}:
00579     
00580     EIGEN\_STRONG\_INLINE InnerIterator(\textcolor{keyword}{const} sparse\_conjunction\_evaluator& aEval, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer)
00581       : m\_lhsIter(aEval.m\_lhsImpl,outer), m\_rhsEval(aEval.m\_rhsImpl), m\_functor(aEval.m\_functor), m\_outer(
      outer)
00582     \{\}
00583 
00584     EIGEN\_STRONG\_INLINE InnerIterator& operator++()
00585     \{
00586       ++m\_lhsIter;
00587       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00588     \}
00589 
00590     EIGEN\_STRONG\_INLINE Scalar value()\textcolor{keyword}{ const}
00591 \textcolor{keyword}{    }\{ \textcolor{keywordflow}{return} m\_functor(m\_lhsIter.value(),
00592                        m\_rhsEval.coeff(IsRowMajor?m\_outer:m\_lhsIter.index(),IsRowMajor?m\_lhsIter.index():
      m\_outer)); \}
00593 
00594     EIGEN\_STRONG\_INLINE StorageIndex index()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhsIter.index(); \}
00595     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhsIter.outer(); \}
00596     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhsIter.row(); \}
00597     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhsIter.col(); \}
00598 
00599     EIGEN\_STRONG\_INLINE \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_lhsIter; \}
00600     
00601   \textcolor{keyword}{protected}:
00602     LhsIterator m\_lhsIter;
00603     \textcolor{keyword}{const} evaluator<RhsArg> &m\_rhsEval;
00604     \textcolor{keyword}{const} BinaryOp& m\_functor;
00605     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_outer;
00606   \};
00607   
00608   
00609   \textcolor{keyword}{enum} \{
00610     CoeffReadCost = evaluator<LhsArg>::CoeffReadCost + evaluator<RhsArg>::CoeffReadCost + 
      functor\_traits<BinaryOp>::Cost,
00611     \textcolor{comment}{// Expose storage order of the sparse expression}
00612     Flags = (XprType::Flags & ~\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) | (\textcolor{keywordtype}{int}(LhsArg::Flags)&
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})
00613   \};
00614   
00615   \textcolor{keyword}{explicit} sparse\_conjunction\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00616     : m\_functor(xpr.functor()),
00617       m\_lhsImpl(xpr.lhs()), 
00618       m\_rhsImpl(xpr.rhs())  
00619   \{
00620     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(functor\_traits<BinaryOp>::Cost);
00621     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00622   \}
00623   
00624   \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nonZerosEstimate()\textcolor{keyword}{ const }\{
00625     \textcolor{keywordflow}{return} m\_lhsImpl.nonZerosEstimate();
00626   \}
00627 
00628 \textcolor{keyword}{protected}:
00629   \textcolor{keyword}{const} BinaryOp m\_functor;
00630   evaluator<LhsArg> m\_lhsImpl;
00631   evaluator<RhsArg> m\_rhsImpl;
00632 \};
00633 
00634 \}
00635 
00636 \textcolor{comment}{/***************************************************************************}
00637 \textcolor{comment}{* Implementation of SparseMatrixBase and SparseCwise functions/operators}
00638 \textcolor{comment}{***************************************************************************/}
00639 
00640 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00641 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00642 Derived& SparseMatrixBase<Derived>::operator+=(\textcolor{keyword}{const} EigenBase<OtherDerived> &other)
00643 \{
00644   call\_assignment(derived(), other.derived(), internal::add\_assign\_op<Scalar,typename OtherDerived::Scalar>
      ());
00645   \textcolor{keywordflow}{return} derived();
00646 \}
00647 
00648 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00649 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00650 Derived& SparseMatrixBase<Derived>::operator-=(\textcolor{keyword}{const} EigenBase<OtherDerived> &other)
00651 \{
00652   call\_assignment(derived(), other.derived(), internal::assign\_op<Scalar,typename OtherDerived::Scalar>());
00653   \textcolor{keywordflow}{return} derived();
00654 \}
00655 
00656 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00657 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00658 EIGEN\_STRONG\_INLINE Derived &
00659 SparseMatrixBase<Derived>::operator-=(\textcolor{keyword}{const} SparseMatrixBase<OtherDerived> &other)
00660 \{
00661   \textcolor{keywordflow}{return} derived() = derived() - other.derived();
00662 \}
00663 
00664 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00665 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00666 EIGEN\_STRONG\_INLINE Derived &
00667 SparseMatrixBase<Derived>::operator+=(\textcolor{keyword}{const} SparseMatrixBase<OtherDerived>& other)
00668 \{
00669   \textcolor{keywordflow}{return} derived() = derived() + other.derived();
00670 \}
00671 
00672 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00673 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00674 Derived& SparseMatrixBase<Derived>::operator+=(\textcolor{keyword}{const} DiagonalBase<OtherDerived>& other)
00675 \{
00676   call\_assignment\_no\_alias(derived(), other.derived(), internal::add\_assign\_op<Scalar,typename
       OtherDerived::Scalar>());
00677   \textcolor{keywordflow}{return} derived();
00678 \}
00679 
00680 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00681 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00682 Derived& SparseMatrixBase<Derived>::operator-=(\textcolor{keyword}{const} DiagonalBase<OtherDerived>& other)
00683 \{
00684   call\_assignment\_no\_alias(derived(), other.derived(), internal::sub\_assign\_op<Scalar,typename
       OtherDerived::Scalar>());
00685   \textcolor{keywordflow}{return} derived();
00686 \}
00687     
00688 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00689 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00690 EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} \textcolor{keyword}{typename} SparseMatrixBase<Derived>::template 
      CwiseProductDenseReturnType<OtherDerived>::Type
00691 SparseMatrixBase<Derived>::cwiseProduct(\textcolor{keyword}{const} MatrixBase<OtherDerived> &other)\textcolor{keyword}{ const}
00692 \textcolor{keyword}{}\{
00693   \textcolor{keywordflow}{return} \textcolor{keyword}{typename} CwiseProductDenseReturnType<OtherDerived>::Type(derived(), other.derived());
00694 \}
00695 
00696 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DenseDerived, \textcolor{keyword}{typename} SparseDerived>
00697 EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_sum\_op<typename DenseDerived::Scalar,typename
       SparseDerived::Scalar>, \textcolor{keyword}{const} DenseDerived, \textcolor{keyword}{const} SparseDerived>
00698 operator+(\textcolor{keyword}{const} MatrixBase<DenseDerived> &a, \textcolor{keyword}{const} SparseMatrixBase<SparseDerived> &b)
00699 \{
00700   \textcolor{keywordflow}{return} CwiseBinaryOp<internal::scalar\_sum\_op<typename DenseDerived::Scalar,typename
       SparseDerived::Scalar>, \textcolor{keyword}{const} DenseDerived, \textcolor{keyword}{const} SparseDerived>(a.derived(), b.derived());
00701 \}
00702 
00703 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseDerived, \textcolor{keyword}{typename} DenseDerived>
00704 EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_sum\_op<typename SparseDerived::Scalar,typename
       DenseDerived::Scalar>, \textcolor{keyword}{const} SparseDerived, \textcolor{keyword}{const} DenseDerived>
00705 operator+(\textcolor{keyword}{const} SparseMatrixBase<SparseDerived> &a, \textcolor{keyword}{const} MatrixBase<DenseDerived> &b)
00706 \{
00707   \textcolor{keywordflow}{return} CwiseBinaryOp<internal::scalar\_sum\_op<typename SparseDerived::Scalar,typename
       DenseDerived::Scalar>, \textcolor{keyword}{const} SparseDerived, \textcolor{keyword}{const} DenseDerived>(a.derived(), b.derived());
00708 \}
00709 
00710 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DenseDerived, \textcolor{keyword}{typename} SparseDerived>
00711 EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_difference\_op<typename
       DenseDerived::Scalar,typename SparseDerived::Scalar>, \textcolor{keyword}{const} DenseDerived, \textcolor{keyword}{const} SparseDerived>
00712 operator-(\textcolor{keyword}{const} MatrixBase<DenseDerived> &a, \textcolor{keyword}{const} SparseMatrixBase<SparseDerived> &b)
00713 \{
00714   \textcolor{keywordflow}{return} CwiseBinaryOp<internal::scalar\_difference\_op<typename DenseDerived::Scalar,typename
       SparseDerived::Scalar>, \textcolor{keyword}{const} DenseDerived, \textcolor{keyword}{const} SparseDerived>(a.derived(), b.derived());
00715 \}
00716 
00717 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseDerived, \textcolor{keyword}{typename} DenseDerived>
00718 EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_difference\_op<typename
       SparseDerived::Scalar,typename DenseDerived::Scalar>, \textcolor{keyword}{const} SparseDerived, \textcolor{keyword}{const} DenseDerived>
00719 operator-(\textcolor{keyword}{const} SparseMatrixBase<SparseDerived> &a, \textcolor{keyword}{const} MatrixBase<DenseDerived> &b)
00720 \{
00721   \textcolor{keywordflow}{return} CwiseBinaryOp<internal::scalar\_difference\_op<typename SparseDerived::Scalar,typename
       DenseDerived::Scalar>, \textcolor{keyword}{const} SparseDerived, \textcolor{keyword}{const} DenseDerived>(a.derived(), b.derived());
00722 \}
00723 
00724 \} \textcolor{comment}{// end namespace Eigen}
00725 
00726 \textcolor{preprocessor}{#endif // EIGEN\_SPARSE\_CWISE\_BINARY\_OP\_H}
\end{DoxyCode}
