\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Iterative\+Linear\+Solvers/\+Incomplete\+Cholesky.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source}\index{Incomplete\+Cholesky.\+h@{Incomplete\+Cholesky.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_INCOMPLETE\_CHOlESKY\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_INCOMPLETE\_CHOlESKY\_H}
00013 
00014 \textcolor{preprocessor}{#include <vector>}
00015 \textcolor{preprocessor}{#include <list>}
00016 
00017 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{  
00044 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} \_UpLo = \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}, \textcolor{keyword}{typename} \_OrderingType =
00045 \textcolor{preprocessor}{#ifndef EIGEN\_MPL2\_ONLY}
00046 AMDOrdering<int>
00047 \textcolor{preprocessor}{#else}
00048 NaturalOrdering<int>
00049 \textcolor{preprocessor}{#endif}
00050 >
00051 \textcolor{keyword}{class }IncompleteCholesky : \textcolor{keyword}{public} SparseSolverBase<IncompleteCholesky<Scalar,\_UpLo,\_OrderingType> >
00052 \{
00053   \textcolor{keyword}{protected}:
00054     \textcolor{keyword}{typedef} SparseSolverBase<IncompleteCholesky<Scalar,\_UpLo,\_OrderingType> > Base;
00055     \textcolor{keyword}{using} Base::m\_isInitialized;
00056   \textcolor{keyword}{public}:
00057     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar; 
00058     \textcolor{keyword}{typedef} \_OrderingType OrderingType;
00059     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} OrderingType::PermutationType PermutationType;
00060     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PermutationType::StorageIndex StorageIndex; 
00061     \textcolor{keyword}{typedef} SparseMatrix<Scalar,ColMajor,StorageIndex> FactorType;
00062     \textcolor{keyword}{typedef} Matrix<Scalar,Dynamic,1> VectorSx;
00063     \textcolor{keyword}{typedef} Matrix<RealScalar,Dynamic,1> VectorRx;
00064     \textcolor{keyword}{typedef} Matrix<StorageIndex,Dynamic, 1> VectorIx;
00065     \textcolor{keyword}{typedef} std::vector<std::list<StorageIndex> > VectorList; 
00066     \textcolor{keyword}{enum} \{ UpLo = \_UpLo \};
00067     \textcolor{keyword}{enum} \{
00068       ColsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00069       MaxColsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}
00070     \};
00071   \textcolor{keyword}{public}:
00072 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source_l00079}\hyperlink{class_eigen_1_1_incomplete_cholesky_adaaa3975b8cf53f910d6a3344af92379}{00079}     \hyperlink{class_eigen_1_1_incomplete_cholesky_adaaa3975b8cf53f910d6a3344af92379}{IncompleteCholesky}() : m\_initialShift(1e-3),m\_factorizationIsOk(false) \{\}
00080     
00083     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source_l00084}\hyperlink{class_eigen_1_1_incomplete_cholesky_a757499fc814988a5b112b1f34d0295e1}{00084}     \hyperlink{class_eigen_1_1_incomplete_cholesky_a757499fc814988a5b112b1f34d0295e1}{IncompleteCholesky}(\textcolor{keyword}{const} MatrixType& matrix) : m\_initialShift(1e-3),
      m\_factorizationIsOk(false)
00085     \{
00086       \hyperlink{class_eigen_1_1_incomplete_cholesky_a7966bedeebbeaa7a8fe4dd1da3797a0b}{compute}(matrix);
00087     \}
00088     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source_l00090}\hyperlink{class_eigen_1_1_incomplete_cholesky_a4780a83266c871782595081021268b5a}{00090}     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{class_eigen_1_1_incomplete_cholesky_a4780a83266c871782595081021268b5a}{rows}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_L.\hyperlink{group___sparse_core___module_a62e61bb861eee306d5b069ce652b5aa5}{rows}(); \}
00091     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source_l00093}\hyperlink{class_eigen_1_1_incomplete_cholesky_a0d66a1c8e340617e7ff404e63186fedb}{00093}     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{class_eigen_1_1_incomplete_cholesky_a0d66a1c8e340617e7ff404e63186fedb}{cols}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_L.\hyperlink{group___sparse_core___module_aa391750e3c530227e4a5c3c52e959975}{cols}(); \}
00094     
00095 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source_l00104}\hyperlink{class_eigen_1_1_incomplete_cholesky_ada0e68cb22601849464506f5986a88c1}{00104}     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} \hyperlink{class_eigen_1_1_incomplete_cholesky_ada0e68cb22601849464506f5986a88c1}{info}()\textcolor{keyword}{ const}
00105 \textcolor{keyword}{    }\{
00106       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"IncompleteCholesky is not initialized."});
00107       \textcolor{keywordflow}{return} m\_info;
00108     \}
00109     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source_l00112}\hyperlink{class_eigen_1_1_incomplete_cholesky_a409c9586e7d29566dda2c8f5e38a1228}{00112}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_incomplete_cholesky_a409c9586e7d29566dda2c8f5e38a1228}{setInitialShift}(RealScalar shift) \{ m\_initialShift = shift; \}
00113     
00116     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source_l00117}\hyperlink{class_eigen_1_1_incomplete_cholesky_a702560ecdddef77dc51d20ab22bd974e}{00117}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_incomplete_cholesky_a702560ecdddef77dc51d20ab22bd974e}{analyzePattern}(\textcolor{keyword}{const} MatrixType& mat)
00118     \{
00119       OrderingType ord; 
00120       PermutationType pinv;
00121       ord(mat.template selfadjointView<UpLo>(), pinv); 
00122       \textcolor{keywordflow}{if}(pinv.size()>0) m\_perm = pinv.inverse();
00123       \textcolor{keywordflow}{else}              m\_perm.resize(0);
00124       m\_L.\hyperlink{group___sparse_core___module_af88551f30202341b7cc24cfadabdec5c}{resize}(mat.rows(), mat.cols());
00125       m\_analysisIsOk = \textcolor{keyword}{true};
00126       m\_isInitialized = \textcolor{keyword}{true};
00127       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00128     \}
00129     
00137     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00138     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_incomplete_cholesky_ac39c75ff7ca5d2db9a9f03b937e12601}{factorize}(\textcolor{keyword}{const} MatrixType& mat);
00139     
00146     \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source_l00147}\hyperlink{class_eigen_1_1_incomplete_cholesky_a7966bedeebbeaa7a8fe4dd1da3797a0b}{00147}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_incomplete_cholesky_a7966bedeebbeaa7a8fe4dd1da3797a0b}{compute}(\textcolor{keyword}{const} MatrixType& mat)
00148     \{
00149       \hyperlink{class_eigen_1_1_incomplete_cholesky_a702560ecdddef77dc51d20ab22bd974e}{analyzePattern}(mat);
00150       \hyperlink{class_eigen_1_1_incomplete_cholesky_ac39c75ff7ca5d2db9a9f03b937e12601}{factorize}(mat);
00151     \}
00152     
00153     \textcolor{comment}{// internal}
00154     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest>
00155     \textcolor{keywordtype}{void} \_solve\_impl(\textcolor{keyword}{const} Rhs& b, Dest& x)\textcolor{keyword}{ const}
00156 \textcolor{keyword}{    }\{
00157       eigen\_assert(m\_factorizationIsOk && \textcolor{stringliteral}{"factorize() should be called first"});
00158       \textcolor{keywordflow}{if} (m\_perm.rows() == b.rows())  x = m\_perm * b;
00159       \textcolor{keywordflow}{else}                            x = b;
00160       x = m\_scale.asDiagonal() * x;
00161       x = m\_L.template triangularView<Lower>().\hyperlink{group___sparse_core___module_a4a66e9498b06e3ec4ec36f06b26d4e8f}{solve}(x);
00162       x = m\_L.adjoint().template triangularView<Upper>().\hyperlink{group___sparse_core___module_a4a66e9498b06e3ec4ec36f06b26d4e8f}{solve}(x);
00163       x = m\_scale.asDiagonal() * x;
00164       \textcolor{keywordflow}{if} (m\_perm.rows() == b.rows())
00165         x = m\_perm.inverse() * x;
00166     \}
00167 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source_l00169}\hyperlink{class_eigen_1_1_incomplete_cholesky_a7d1f1878505fd1862e6f2286d27ff09a}{00169}     \textcolor{keyword}{const} FactorType& \hyperlink{class_eigen_1_1_incomplete_cholesky_a7d1f1878505fd1862e6f2286d27ff09a}{matrixL}()\textcolor{keyword}{ const }\{ eigen\_assert(\textcolor{stringliteral}{"m\_factorizationIsOk"}); \textcolor{keywordflow}{return} m\_L; \}
00170 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source_l00172}\hyperlink{class_eigen_1_1_incomplete_cholesky_a30d66dd77147a84ec3302e7d5fe5d924}{00172}     \textcolor{keyword}{const} VectorRx& \hyperlink{class_eigen_1_1_incomplete_cholesky_a30d66dd77147a84ec3302e7d5fe5d924}{scalingS}()\textcolor{keyword}{ const }\{ eigen\_assert(\textcolor{stringliteral}{"m\_factorizationIsOk"}); \textcolor{keywordflow}{return} m\_scale; \}
00173 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_incomplete_cholesky_8h_source_l00175}\hyperlink{class_eigen_1_1_incomplete_cholesky_a0d52cec5e17f485a362766363ba90b02}{00175}     \textcolor{keyword}{const} PermutationType& \hyperlink{class_eigen_1_1_incomplete_cholesky_a0d52cec5e17f485a362766363ba90b02}{permutationP}()\textcolor{keyword}{ const }\{ eigen\_assert(\textcolor{stringliteral}{"m\_analysisIsOk"}); \textcolor{keywordflow}{return} m\_perm
      ; \}
00176 
00177   \textcolor{keyword}{protected}:
00178     FactorType m\_L;              \textcolor{comment}{// The lower part stored in CSC}
00179     VectorRx m\_scale;            \textcolor{comment}{// The vector for scaling the matrix }
00180     RealScalar m\_initialShift;   \textcolor{comment}{// The initial shift parameter}
00181     \textcolor{keywordtype}{bool} m\_analysisIsOk; 
00182     \textcolor{keywordtype}{bool} m\_factorizationIsOk; 
00183     \hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{ComputationInfo} m\_info;
00184     PermutationType m\_perm; 
00185 
00186   \textcolor{keyword}{private}:
00187     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} updateList(\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const VectorIx>} colPtr, 
      \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<VectorIx>} rowIdx, \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<VectorSx>} vals, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& col, \textcolor{keyword}{const} 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& jk, VectorIx& firstElt, VectorList& listCol); 
00188 \}; 
00189 
00190 \textcolor{comment}{// Based on the following paper:}
00191 \textcolor{comment}{//   C-J. Lin and J. J. Moré, Incomplete Cholesky Factorizations with}
00192 \textcolor{comment}{//   Limited memory, SIAM J. Sci. Comput.  21(1), pp. 24-45, 1999}
00193 \textcolor{comment}{//   http://ftp.mcs.anl.gov/pub/tech\_reports/reports/P682.pdf}
00194 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} \_UpLo, \textcolor{keyword}{typename} OrderingType>
00195 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
00196 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_incomplete_cholesky_ac39c75ff7ca5d2db9a9f03b937e12601}{IncompleteCholesky<Scalar,\_UpLo, OrderingType>::factorize}
      (\textcolor{keyword}{const} \_MatrixType& mat)
00197 \{
00198   \textcolor{keyword}{using} std::sqrt;
00199   eigen\_assert(m\_analysisIsOk && \textcolor{stringliteral}{"analyzePattern() should be called first"}); 
00200     
00201   \textcolor{comment}{// Dropping strategy : Keep only the p largest elements per column, where p is the number of elements in
       the column of the original matrix. Other strategies will be added}
00202   
00203   \textcolor{comment}{// Apply the fill-reducing permutation computed in analyzePattern()}
00204   \textcolor{keywordflow}{if} (m\_perm.rows() == mat.rows() ) \textcolor{comment}{// To detect the null permutation}
00205   \{
00206     \textcolor{comment}{// The temporary is needed to make sure that the diagonal entry is properly sorted}
00207     \hyperlink{group___sparse_core___module}{FactorType} tmp(mat.rows(), mat.cols());
00208     tmp = mat.template selfadjointView<\_UpLo>().twistedBy(m\_perm);
00209     m\_L.template selfadjointView<Lower>() = tmp.template selfadjointView<Lower>();
00210   \}
00211   \textcolor{keywordflow}{else}
00212   \{
00213     m\_L.template selfadjointView<Lower>() = mat.template selfadjointView<\_UpLo>();
00214   \}
00215   
00216   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = m\_L.\hyperlink{group___sparse_core___module_aa391750e3c530227e4a5c3c52e959975}{cols}(); 
00217   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nnz = m\_L.\hyperlink{group___sparse_core___module_a03de8b3da2c142ce8698a76123b3e7d3}{nonZeros}();
00218   \hyperlink{group___core___module_class_eigen_1_1_map}{Map<VectorSx>} vals(m\_L.\hyperlink{group___sparse_core___module_a9d4354d3f4d121d764bbed33cac05329}{valuePtr}(), nnz);         \textcolor{comment}{//values}
00219   \hyperlink{group___core___module_class_eigen_1_1_map}{Map<VectorIx>} rowIdx(m\_L.\hyperlink{group___sparse_core___module_ae7b804bd39745156d20ca1611a296b67}{innerIndexPtr}(), nnz);  \textcolor{comment}{//Row indices}
00220   \hyperlink{group___core___module_class_eigen_1_1_map}{Map<VectorIx>} colPtr( m\_L.\hyperlink{group___sparse_core___module_a75506964d86d6badb32d0b4917acf2e2}{outerIndexPtr}(), n+1); \textcolor{comment}{// Pointer to the beginning of
       each row}
00221   \hyperlink{group___core___module}{VectorIx} firstElt(n-1); \textcolor{comment}{// for each j, points to the next entry in vals that will be used in the
       factorization}
00222   VectorList listCol(n);  \textcolor{comment}{// listCol(j) is a linked list of columns to update column j}
00223   \hyperlink{group___core___module}{VectorSx} col\_vals(n);   \textcolor{comment}{// Store a  nonzero values in each column}
00224   \hyperlink{group___core___module}{VectorIx} col\_irow(n);   \textcolor{comment}{// Row indices of nonzero elements in each column}
00225   \hyperlink{group___core___module}{VectorIx} col\_pattern(n);
00226   col\_pattern.fill(-1);
00227   StorageIndex col\_nnz;
00228   
00229   
00230   \textcolor{comment}{// Computes the scaling factors }
00231   m\_scale.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(n);
00232   m\_scale.\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00233   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < n; j++)
00234     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = colPtr[j]; k < colPtr[j+1]; k++)
00235     \{
00236       m\_scale(j) += numext::abs2(vals(k));
00237       \textcolor{keywordflow}{if}(rowIdx[k]!=j)
00238         m\_scale(rowIdx[k]) += numext::abs2(vals(k));
00239     \}
00240   
00241   m\_scale = m\_scale.cwiseSqrt().cwiseSqrt();
00242 
00243   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < n; ++j)
00244     \textcolor{keywordflow}{if}(m\_scale(j)>(std::numeric\_limits<RealScalar>::min)())
00245       m\_scale(j) = RealScalar(1)/m\_scale(j);
00246     \textcolor{keywordflow}{else}
00247       m\_scale(j) = 1;
00248 
00249   \textcolor{comment}{// TODO disable scaling if not needed, i.e., if it is roughly uniform? (this will make solve() faster)}
00250   
00251   \textcolor{comment}{// Scale and compute the shift for the matrix }
00252   RealScalar mindiag = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::highest}();
00253   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < n; j++)
00254   \{
00255     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = colPtr[j]; k < colPtr[j+1]; k++)
00256       vals[k] *= (m\_scale(j)*m\_scale(rowIdx[k]));
00257     eigen\_internal\_assert(rowIdx[colPtr[j]]==j && \textcolor{stringliteral}{"IncompleteCholesky: only the lower triangular part must
       be stored"});
00258     mindiag = numext::mini(numext::real(vals[colPtr[j]]), mindiag);
00259   \}
00260 
00261   \hyperlink{group___sparse_core___module}{FactorType} L\_save = m\_L;
00262   
00263   RealScalar shift = 0;
00264   \textcolor{keywordflow}{if}(mindiag <= RealScalar(0.))
00265     shift = m\_initialShift - mindiag;
00266 
00267   m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00268 
00269   \textcolor{comment}{// Try to perform the incomplete factorization using the current shift}
00270   \textcolor{keywordtype}{int} iter = 0;
00271   \textcolor{keywordflow}{do}
00272   \{
00273     \textcolor{comment}{// Apply the shift to the diagonal elements of the matrix}
00274     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < n; j++)
00275       vals[colPtr[j]] += shift;
00276 
00277     \textcolor{comment}{// jki version of the Cholesky factorization}
00278     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0;
00279     \textcolor{keywordflow}{for} (; j < n; ++j)
00280     \{
00281       \textcolor{comment}{// Left-looking factorization of the j-th column}
00282       \textcolor{comment}{// First, load the j-th column into col\_vals}
00283       Scalar diag = vals[colPtr[j]];  \textcolor{comment}{// It is assumed that only the lower part is stored}
00284       col\_nnz = 0;
00285       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = colPtr[j] + 1; i < colPtr[j+1]; i++)
00286       \{
00287         StorageIndex l = rowIdx[i];
00288         col\_vals(col\_nnz) = vals[i];
00289         col\_irow(col\_nnz) = l;
00290         col\_pattern(l) = col\_nnz;
00291         col\_nnz++;
00292       \}
00293       \{
00294         \textcolor{keyword}{typename} std::list<StorageIndex>::iterator k;
00295         \textcolor{comment}{// Browse all previous columns that will update column j}
00296         \textcolor{keywordflow}{for}(k = listCol[j].begin(); k != listCol[j].end(); k++)
00297         \{
00298           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} jk = firstElt(*k); \textcolor{comment}{// First element to use in the column}
00299           eigen\_internal\_assert(rowIdx[jk]==j);
00300           Scalar v\_j\_jk = numext::conj(vals[jk]);
00301 
00302           jk += 1;
00303           \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = jk; i < colPtr[*k+1]; i++)
00304           \{
00305             StorageIndex l = rowIdx[i];
00306             \textcolor{keywordflow}{if}(col\_pattern[l]<0)
00307             \{
00308               col\_vals(col\_nnz) = vals[i] * v\_j\_jk;
00309               col\_irow[col\_nnz] = l;
00310               col\_pattern(l) = col\_nnz;
00311               col\_nnz++;
00312             \}
00313             \textcolor{keywordflow}{else}
00314               col\_vals(col\_pattern[l]) -= vals[i] * v\_j\_jk;
00315           \}
00316           updateList(colPtr,rowIdx,vals, *k, jk, firstElt, listCol);
00317         \}
00318       \}
00319 
00320       \textcolor{comment}{// Scale the current column}
00321       \textcolor{keywordflow}{if}(numext::real(diag) <= 0)
00322       \{
00323         \textcolor{keywordflow}{if}(++iter>=10)
00324           \textcolor{keywordflow}{return};
00325 
00326         \textcolor{comment}{// increase shift}
00327         shift = numext::maxi(m\_initialShift,RealScalar(2)*shift);
00328         \textcolor{comment}{// restore m\_L, col\_pattern, and listCol}
00329         vals = \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const VectorSx>}(L\_save.\hyperlink{group___sparse_core___module_a9d4354d3f4d121d764bbed33cac05329}{valuePtr}(), nnz);
00330         rowIdx = \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const VectorIx>}(L\_save.\hyperlink{group___sparse_core___module_ae7b804bd39745156d20ca1611a296b67}{innerIndexPtr}(), nnz);
00331         colPtr = \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const VectorIx>}(L\_save.\hyperlink{group___sparse_core___module_a75506964d86d6badb32d0b4917acf2e2}{outerIndexPtr}(), n+1);
00332         col\_pattern.fill(-1);
00333         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<n; ++i)
00334           listCol[i].clear();
00335 
00336         \textcolor{keywordflow}{break};
00337       \}
00338 
00339       RealScalar rdiag = sqrt(numext::real(diag));
00340       vals[colPtr[j]] = rdiag;
00341       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = 0; k<col\_nnz; ++k)
00342       \{
00343         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = col\_irow[k];
00344         \textcolor{comment}{//Scale}
00345         col\_vals(k) /= rdiag;
00346         \textcolor{comment}{//Update the remaining diagonals with col\_vals}
00347         vals[colPtr[i]] -= numext::abs2(col\_vals(k));
00348       \}
00349       \textcolor{comment}{// Select the largest p elements}
00350       \textcolor{comment}{// p is the original number of elements in the column (without the diagonal)}
00351       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p = colPtr[j+1] - colPtr[j] - 1 ;
00352       \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<VectorSx>} cvals = col\_vals.head(col\_nnz);
00353       \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<VectorIx>} cirow = col\_irow.head(col\_nnz);
00354       internal::QuickSplit(cvals,cirow, p);
00355       \textcolor{comment}{// Insert the largest p elements in the matrix}
00356       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cpt = 0;
00357       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = colPtr[j]+1; i < colPtr[j+1]; i++)
00358       \{
00359         vals[i] = col\_vals(cpt);
00360         rowIdx[i] = col\_irow(cpt);
00361         \textcolor{comment}{// restore col\_pattern:}
00362         col\_pattern(col\_irow(cpt)) = -1;
00363         cpt++;
00364       \}
00365       \textcolor{comment}{// Get the first smallest row index and put it after the diagonal element}
00366       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} jk = colPtr(j)+1;
00367       updateList(colPtr,rowIdx,vals,j,jk,firstElt,listCol);
00368     \}
00369 
00370     \textcolor{keywordflow}{if}(j==n)
00371     \{
00372       m\_factorizationIsOk = \textcolor{keyword}{true};
00373       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00374     \}
00375   \} \textcolor{keywordflow}{while}(m\_info!=\hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success});
00376 \}
00377 
00378 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} \_UpLo, \textcolor{keyword}{typename} OrderingType>
00379 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1_incomplete_cholesky}{IncompleteCholesky<Scalar,\_UpLo, OrderingType>::updateList}
      (\hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<const VectorIx>} colPtr, \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<VectorIx>} rowIdx, 
      \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<VectorSx>} vals, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& col, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& jk, 
      \hyperlink{group___core___module}{VectorIx}& firstElt, VectorList& listCol)
00380 \{
00381   \textcolor{keywordflow}{if} (jk < colPtr(col+1) )
00382   \{
00383     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p = colPtr(col+1) - jk;
00384     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} minpos; 
00385     rowIdx.segment(jk,p).minCoeff(&minpos);
00386     minpos += jk;
00387     \textcolor{keywordflow}{if} (rowIdx(minpos) != rowIdx(jk))
00388     \{
00389       \textcolor{comment}{//Swap}
00390       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(rowIdx(jk),rowIdx(minpos));
00391       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(vals(jk),vals(minpos));
00392     \}
00393     firstElt(col) = internal::convert\_index<StorageIndex,Index>(jk);
00394     listCol[rowIdx(jk)].push\_back(internal::convert\_index<StorageIndex,Index>(col));
00395   \}
00396 \}
00397 
00398 \} \textcolor{comment}{// end namespace Eigen }
00399 
00400 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
