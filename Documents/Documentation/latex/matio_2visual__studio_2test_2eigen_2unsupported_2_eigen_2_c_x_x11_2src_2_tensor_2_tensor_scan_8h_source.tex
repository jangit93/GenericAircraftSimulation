\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_scan_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Scan.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_scan_8h_source}\index{Tensor\+Scan.\+h@{Tensor\+Scan.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2016 Igor Babuschkin <igor@babuschk.in>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_SCAN\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_SCAN\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} XprType>
00018 \textcolor{keyword}{struct }traits<TensorScanOp<Op, XprType> >
00019     : \textcolor{keyword}{public} traits<XprType> \{
00020   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00021   \textcolor{keyword}{typedef} traits<XprType> XprTraits;
00022   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00023   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00024   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<Nested>::type \_Nested;
00025   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions;
00026   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00027 \};
00028 
00029 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} XprType>
00030 \textcolor{keyword}{struct }eval<TensorScanOp<Op, XprType>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00031 \{
00032   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorScanOp<Op, XprType>& type;
00033 \};
00034 
00035 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} XprType>
00036 \textcolor{keyword}{struct }nested<TensorScanOp<Op, XprType>, 1,
00037             typename eval<TensorScanOp<Op, XprType> >::type>
00038 \{
00039   \textcolor{keyword}{typedef} TensorScanOp<Op, XprType> type;
00040 \};
00041 \} \textcolor{comment}{// end namespace internal}
00042 
00048 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} XprType>
00049 \textcolor{keyword}{class }TensorScanOp
00050     : \textcolor{keyword}{public} TensorBase<TensorScanOp<Op, XprType>, ReadOnlyAccessors> \{
00051 \textcolor{keyword}{public}:
00052   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorScanOp>::Scalar}
       Scalar;
00053   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00054   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00055   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorScanOp>::type} 
      Nested;
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorScanOp>::StorageKind}
       StorageKind;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorScanOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00058 
00059   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorScanOp(
00060       \textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} Index& axis, \textcolor{keywordtype}{bool} exclusive = \textcolor{keyword}{false}, \textcolor{keyword}{const} Op& op = Op())
00061       : m\_expr(expr), m\_axis(axis), m\_accumulator(op), m\_exclusive(exclusive) \{\}
00062 
00063   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00064   \textcolor{keyword}{const} Index axis()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_axis; \}
00065   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00066   \textcolor{keyword}{const} XprType& expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_expr; \}
00067   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00068   \textcolor{keyword}{const} Op accumulator()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_accumulator; \}
00069   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00070   \textcolor{keywordtype}{bool} exclusive()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_exclusive; \}
00071 
00072 \textcolor{keyword}{protected}:
00073   \textcolor{keyword}{typename} XprType::Nested m\_expr;
00074   \textcolor{keyword}{const} Index m\_axis;
00075   \textcolor{keyword}{const} Op m\_accumulator;
00076   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} m\_exclusive;
00077 \};
00078 
00079 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} Device>
00080 \textcolor{keyword}{struct }ScanLauncher;
00081 
00082 \textcolor{comment}{// Eval as rvalue}
00083 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00084 \textcolor{keyword}{struct }TensorEvaluator<const TensorScanOp<Op, ArgType>, Device> \{
00085 
00086   \textcolor{keyword}{typedef} TensorScanOp<Op, ArgType> XprType;
00087   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00088   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = internal::array\_size<typename TensorEvaluator<ArgType, Device>::Dimensions>
      ::value;
00089   \textcolor{keyword}{typedef} DSizes<Index, NumDims> Dimensions;
00090   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_const<typename XprType::Scalar>::type Scalar;
00091   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00092   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00093   \textcolor{keyword}{typedef} TensorEvaluator<const TensorScanOp<Op, ArgType>, Device> Self;
00094 
00095   \textcolor{keyword}{enum} \{
00096     IsAligned = \textcolor{keyword}{false},
00097     PacketAccess = (internal::unpacket\_traits<PacketReturnType>::size > 1),
00098     BlockAccess = \textcolor{keyword}{false},
00099     Layout = TensorEvaluator<ArgType, Device>::Layout,
00100     CoordAccess = \textcolor{keyword}{false},
00101     RawAccess = \textcolor{keyword}{true}
00102   \};
00103 
00104   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op,
00105                                                         \textcolor{keyword}{const} Device& device)
00106       : m\_impl(op.expression(), device),
00107         m\_device(device),
00108         m\_exclusive(op.exclusive()),
00109         m\_accumulator(op.accumulator()),
00110         m\_size(m\_impl.dimensions()[op.axis()]),
00111         m\_stride(1),
00112         m\_output(NULL) \{
00113 
00114     \textcolor{comment}{// Accumulating a scalar isn't supported.}
00115     EIGEN\_STATIC\_ASSERT((NumDims > 0), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00116     eigen\_assert(op.axis() >= 0 && op.axis() < NumDims);
00117 
00118     \textcolor{comment}{// Compute stride of scan axis}
00119     \textcolor{keyword}{const} Dimensions& dims = m\_impl.dimensions();
00120     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00121       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < op.axis(); ++i) \{
00122         m\_stride = m\_stride * dims[i];
00123       \}
00124     \} \textcolor{keywordflow}{else} \{
00125       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > op.axis(); --i) \{
00126         m\_stride = m\_stride * dims[i];
00127       \}
00128     \}
00129   \}
00130 
00131   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{
00132     \textcolor{keywordflow}{return} m\_impl.dimensions();
00133   \}
00134 
00135   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Index& stride()\textcolor{keyword}{ const }\{
00136     \textcolor{keywordflow}{return} m\_stride;
00137   \}
00138 
00139   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Index& size()\textcolor{keyword}{ const }\{
00140     \textcolor{keywordflow}{return} m\_size;
00141   \}
00142 
00143   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Op& accumulator()\textcolor{keyword}{ const }\{
00144     \textcolor{keywordflow}{return} m\_accumulator;
00145   \}
00146 
00147   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} exclusive()\textcolor{keyword}{ const }\{
00148     \textcolor{keywordflow}{return} m\_exclusive;
00149   \}
00150 
00151   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} TensorEvaluator<ArgType, Device>& inner()\textcolor{keyword}{ const }\{
00152     \textcolor{keywordflow}{return} m\_impl;
00153   \}
00154 
00155   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Device& device()\textcolor{keyword}{ const }\{
00156     \textcolor{keywordflow}{return} m\_device;
00157   \}
00158 
00159   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* data) \{
00160     m\_impl.evalSubExprsIfNeeded(NULL);
00161     ScanLauncher<Self, Op, Device> launcher;
00162     \textcolor{keywordflow}{if} (data) \{
00163       launcher(*\textcolor{keyword}{this}, data);
00164       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00165     \}
00166 
00167     \textcolor{keyword}{const} Index total\_size = internal::array\_prod(dimensions());
00168     m\_output = \textcolor{keyword}{static\_cast<}CoeffReturnType*\textcolor{keyword}{>}(m\_device.allocate(total\_size * \textcolor{keyword}{sizeof}(Scalar)));
00169     launcher(*\textcolor{keyword}{this}, m\_output);
00170     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00171   \}
00172 
00173   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00174   EIGEN\_DEVICE\_FUNC PacketReturnType packet(Index index)\textcolor{keyword}{ const }\{
00175     \textcolor{keywordflow}{return} internal::ploadt<PacketReturnType, LoadMode>(m\_output + index);
00176   \}
00177 
00178   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType* data()\textcolor{keyword}{ const}
00179 \textcolor{keyword}{  }\{
00180     \textcolor{keywordflow}{return} m\_output;
00181   \}
00182 
00183   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00184 \textcolor{keyword}{  }\{
00185     \textcolor{keywordflow}{return} m\_output[index];
00186   \}
00187 
00188   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorOpCost costPerCoeff(\textcolor{keywordtype}{bool})\textcolor{keyword}{ const }\{
00189     \textcolor{keywordflow}{return} TensorOpCost(\textcolor{keyword}{sizeof}(CoeffReturnType), 0, 0);
00190   \}
00191 
00192   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00193     \textcolor{keywordflow}{if} (m\_output != NULL) \{
00194       m\_device.deallocate(m\_output);
00195       m\_output = NULL;
00196     \}
00197     m\_impl.cleanup();
00198   \}
00199 
00200 \textcolor{keyword}{protected}:
00201   TensorEvaluator<ArgType, Device> m\_impl;
00202   \textcolor{keyword}{const} Device& m\_device;
00203   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} m\_exclusive;
00204   Op m\_accumulator;
00205   \textcolor{keyword}{const} Index m\_size;
00206   Index m\_stride;
00207   CoeffReturnType* m\_output;
00208 \};
00209 
00210 \textcolor{comment}{// CPU implementation of scan}
00211 \textcolor{comment}{// TODO(ibab) This single-threaded implementation should be parallelized,}
00212 \textcolor{comment}{// at least by running multiple scans at the same time.}
00213 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Reducer, \textcolor{keyword}{typename} Device>
00214 \textcolor{keyword}{struct }ScanLauncher \{
00215   \textcolor{keywordtype}{void} operator()(Self& \textcolor{keyword}{self}, \textcolor{keyword}{typename} Self::CoeffReturnType *data) \{
00216     Index total\_size = internal::array\_prod(\textcolor{keyword}{self}.dimensions());
00217 
00218     \textcolor{comment}{// We fix the index along the scan axis to 0 and perform a}
00219     \textcolor{comment}{// scan per remaining entry. The iteration is split into two nested}
00220     \textcolor{comment}{// loops to avoid an integer division by keeping track of each idx1 and idx2.}
00221     \textcolor{keywordflow}{for} (Index idx1 = 0; idx1 < total\_size; idx1 += \textcolor{keyword}{self}.stride() * \textcolor{keyword}{self}.size()) \{
00222       \textcolor{keywordflow}{for} (Index idx2 = 0; idx2 < \textcolor{keyword}{self}.stride(); idx2++) \{
00223         \textcolor{comment}{// Calculate the starting offset for the scan}
00224         Index offset = idx1 + idx2;
00225 
00226         \textcolor{comment}{// Compute the scan along the axis, starting at the calculated offset}
00227         \textcolor{keyword}{typename} Self::CoeffReturnType accum = \textcolor{keyword}{self}.accumulator().initialize();
00228         \textcolor{keywordflow}{for} (Index idx3 = 0; idx3 < \textcolor{keyword}{self}.size(); idx3++) \{
00229           Index curr = offset + idx3 * \textcolor{keyword}{self}.stride();
00230 
00231           \textcolor{keywordflow}{if} (\textcolor{keyword}{self}.exclusive()) \{
00232             data[curr] = \textcolor{keyword}{self}.accumulator().finalize(accum);
00233             \textcolor{keyword}{self}.accumulator().reduce(\textcolor{keyword}{self}.inner().coeff(curr), &accum);
00234           \} \textcolor{keywordflow}{else} \{
00235             \textcolor{keyword}{self}.accumulator().reduce(\textcolor{keyword}{self}.inner().coeff(curr), &accum);
00236             data[curr] = \textcolor{keyword}{self}.accumulator().finalize(accum);
00237           \}
00238         \}
00239       \}
00240     \}
00241   \}
00242 \};
00243 
00244 \textcolor{preprocessor}{#if defined(EIGEN\_USE\_GPU) && defined(\_\_CUDACC\_\_)}
00245 
00246 \textcolor{comment}{// GPU implementation of scan}
00247 \textcolor{comment}{// TODO(ibab) This placeholder implementation performs multiple scans in}
00248 \textcolor{comment}{// parallel, but it would be better to use a parallel scan algorithm and}
00249 \textcolor{comment}{// optimize memory access.}
00250 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Reducer>
00251 \_\_global\_\_ \textcolor{keywordtype}{void} ScanKernel(Self \textcolor{keyword}{self}, Index total\_size, \textcolor{keyword}{typename} Self::CoeffReturnType* data) \{
00252   \textcolor{comment}{// Compute offset as in the CPU version}
00253   Index val = threadIdx.x + blockIdx.x * blockDim.x;
00254   Index offset = (val / \textcolor{keyword}{self}.stride()) * \textcolor{keyword}{self}.stride() * \textcolor{keyword}{self}.size() + val % \textcolor{keyword}{self}.stride();
00255 
00256   \textcolor{keywordflow}{if} (offset + (\textcolor{keyword}{self}.size() - 1) * \textcolor{keyword}{self}.stride() < total\_size) \{
00257     \textcolor{comment}{// Compute the scan along the axis, starting at the calculated offset}
00258     \textcolor{keyword}{typename} Self::CoeffReturnType accum = \textcolor{keyword}{self}.accumulator().initialize();
00259     \textcolor{keywordflow}{for} (Index idx = 0; idx < \textcolor{keyword}{self}.size(); idx++) \{
00260       Index curr = offset + idx * \textcolor{keyword}{self}.stride();
00261       \textcolor{keywordflow}{if} (\textcolor{keyword}{self}.exclusive()) \{
00262         data[curr] = \textcolor{keyword}{self}.accumulator().finalize(accum);
00263         \textcolor{keyword}{self}.accumulator().reduce(\textcolor{keyword}{self}.inner().coeff(curr), &accum);
00264       \} \textcolor{keywordflow}{else} \{
00265         \textcolor{keyword}{self}.accumulator().reduce(\textcolor{keyword}{self}.inner().coeff(curr), &accum);
00266         data[curr] = \textcolor{keyword}{self}.accumulator().finalize(accum);
00267       \}
00268     \}
00269   \}
00270   \_\_syncthreads();
00271 
00272 \}
00273 
00274 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Reducer>
00275 \textcolor{keyword}{struct }ScanLauncher<Self, Reducer, GpuDevice> \{
00276   \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, \textcolor{keyword}{typename} Self::CoeffReturnType* data) \{
00277      Index total\_size = internal::array\_prod(\textcolor{keyword}{self}.dimensions());
00278      Index num\_blocks = (total\_size / \textcolor{keyword}{self}.size() + 63) / 64;
00279      Index block\_size = 64;
00280      LAUNCH\_CUDA\_KERNEL((ScanKernel<Self, Reducer>), num\_blocks, block\_size, 0, \textcolor{keyword}{self}.device(), \textcolor{keyword}{self}, 
      total\_size, data);
00281   \}
00282 \};
00283 \textcolor{preprocessor}{#endif  // EIGEN\_USE\_GPU && \_\_CUDACC\_\_}
00284 
00285 \}  \textcolor{comment}{// end namespace Eigen}
00286 
00287 \textcolor{preprocessor}{#endif  // EIGEN\_CXX11\_TENSOR\_TENSOR\_SCAN\_H}
\end{DoxyCode}
