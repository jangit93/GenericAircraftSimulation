\hypertarget{matio_2visual__studio_2test_2eigen_2bench_2bench_eigen_solver_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/bench/bench\+Eigen\+Solver.cpp}
\label{matio_2visual__studio_2test_2eigen_2bench_2bench_eigen_solver_8cpp_source}\index{bench\+Eigen\+Solver.\+cpp@{bench\+Eigen\+Solver.\+cpp}}

\begin{DoxyCode}
00001 
00002 \textcolor{comment}{// g++ -DNDEBUG -O3 -I.. benchEigenSolver.cpp  -o benchEigenSolver && ./benchEigenSolver}
00003 \textcolor{comment}{// options:}
00004 \textcolor{comment}{//  -DBENCH\_GMM}
00005 \textcolor{comment}{//  -DBENCH\_GSL -lgsl /usr/lib/libcblas.so.3}
00006 \textcolor{comment}{//  -DEIGEN\_DONT\_VECTORIZE}
00007 \textcolor{comment}{//  -msse2}
00008 \textcolor{comment}{//  -DREPEAT=100}
00009 \textcolor{comment}{//  -DTRIES=10}
00010 \textcolor{comment}{//  -DSCALAR=double}
00011 
00012 \textcolor{preprocessor}{#include <iostream>}
00013 
00014 \textcolor{preprocessor}{#include <Eigen/Core>}
00015 \textcolor{preprocessor}{#include <Eigen/QR>}
00016 \textcolor{preprocessor}{#include <bench/BenchUtil.h>}
00017 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00018 
00019 \textcolor{preprocessor}{#ifndef REPEAT}
00020 \textcolor{preprocessor}{#define REPEAT 1000}
00021 \textcolor{preprocessor}{#endif}
00022 
00023 \textcolor{preprocessor}{#ifndef TRIES}
00024 \textcolor{preprocessor}{#define TRIES 4}
00025 \textcolor{preprocessor}{#endif}
00026 
00027 \textcolor{preprocessor}{#ifndef SCALAR}
00028 \textcolor{preprocessor}{#define SCALAR float}
00029 \textcolor{preprocessor}{#endif}
00030 
00031 \textcolor{keyword}{typedef} SCALAR Scalar;
00032 
00033 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00034 \_\_attribute\_\_ ((noinline)) \textcolor{keywordtype}{void} benchEigenSolver(\textcolor{keyword}{const} MatrixType& m)
00035 \{
00036   \textcolor{keywordtype}{int} rows = m.rows();
00037   \textcolor{keywordtype}{int} cols = m.cols();
00038 
00039   \textcolor{keywordtype}{int} stdRepeats = std::max(1,\textcolor{keywordtype}{int}((REPEAT*1000)/(rows*rows*sqrt(rows))));
00040   \textcolor{keywordtype}{int} saRepeats = stdRepeats * 4;
00041 
00042   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00043   \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, MatrixType::RowsAtCompileTime, MatrixType::RowsAtCompileTime>}
       SquareMatrixType;
00044 
00045   MatrixType a = MatrixType::Random(rows,cols);
00046   SquareMatrixType covMat =  a * a.adjoint();
00047 
00048   \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} timerSa, timerStd;
00049 
00050   Scalar acc = 0;
00051   \textcolor{keywordtype}{int} r = internal::random<int>(0,covMat.rows()-1);
00052   \textcolor{keywordtype}{int} c = internal::random<int>(0,covMat.cols()-1);
00053   \{
00054     \hyperlink{group___eigenvalues___module_class_eigen_1_1_self_adjoint_eigen_solver}{SelfAdjointEigenSolver<SquareMatrixType>} ei(covMat);
00055     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} t=0; t<TRIES; ++t)
00056     \{
00057       timerSa.start();
00058       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<saRepeats; ++k)
00059       \{
00060         ei.compute(covMat);
00061         acc += ei.eigenvectors().coeff(r,c);
00062       \}
00063       timerSa.stop();
00064     \}
00065   \}
00066 
00067   \{
00068     \hyperlink{group___eigenvalues___module_class_eigen_1_1_eigen_solver}{EigenSolver<SquareMatrixType>} ei(covMat);
00069     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} t=0; t<TRIES; ++t)
00070     \{
00071       timerStd.start();
00072       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<stdRepeats; ++k)
00073       \{
00074         ei.compute(covMat);
00075         acc += ei.eigenvectors().coeff(r,c);
00076       \}
00077       timerStd.stop();
00078     \}
00079   \}
00080 
00081   \textcolor{keywordflow}{if} (MatrixType::RowsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic})
00082     std::cout << \textcolor{stringliteral}{"dyn   "};
00083   \textcolor{keywordflow}{else}
00084     std::cout << \textcolor{stringliteral}{"fixed "};
00085   std::cout << covMat.rows() << \textcolor{stringliteral}{" \(\backslash\)t"}
00086             << timerSa.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() * REPEAT / saRepeats << \textcolor{stringliteral}{"s \(\backslash\)t"}
00087             << timerStd.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() * REPEAT / stdRepeats << \textcolor{stringliteral}{"s"};
00088 
00089 \textcolor{preprocessor}{  #ifdef BENCH\_GMM}
00090   \textcolor{keywordflow}{if} (MatrixType::RowsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic})
00091   \{
00092     timerSa.reset();
00093     timerStd.reset();
00094 
00095     gmm::dense\_matrix<Scalar> gmmCovMat(covMat.rows(),covMat.cols());
00096     gmm::dense\_matrix<Scalar> eigvect(covMat.rows(),covMat.cols());
00097     std::vector<Scalar> eigval(covMat.rows());
00098     eiToGmm(covMat, gmmCovMat);
00099     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} t=0; t<TRIES; ++t)
00100     \{
00101       timerSa.start();
00102       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<saRepeats; ++k)
00103       \{
00104         gmm::symmetric\_qr\_algorithm(gmmCovMat, eigval, eigvect);
00105         acc += eigvect(r,c);
00106       \}
00107       timerSa.stop();
00108     \}
00109     \textcolor{comment}{// the non-selfadjoint solver does not compute the eigen vectors}
00110 \textcolor{comment}{//     for (int t=0; t<TRIES; ++t)}
00111 \textcolor{comment}{//     \{}
00112 \textcolor{comment}{//       timerStd.start();}
00113 \textcolor{comment}{//       for (int k=0; k<stdRepeats; ++k)}
00114 \textcolor{comment}{//       \{}
00115 \textcolor{comment}{//         gmm::implicit\_qr\_algorithm(gmmCovMat, eigval, eigvect);}
00116 \textcolor{comment}{//         acc += eigvect(r,c);}
00117 \textcolor{comment}{//       \}}
00118 \textcolor{comment}{//       timerStd.stop();}
00119 \textcolor{comment}{//     \}}
00120 
00121     std::cout << \textcolor{stringliteral}{" | \(\backslash\)t"}
00122               << timerSa.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() * REPEAT / saRepeats << \textcolor{stringliteral}{"s"}
00123               << \textcolor{comment}{/*timerStd.value() * REPEAT / stdRepeats << "s"*/} \textcolor{stringliteral}{"   na   "};
00124   \}
00125 \textcolor{preprocessor}{  #endif}
00126 
00127 \textcolor{preprocessor}{  #ifdef BENCH\_GSL}
00128   \textcolor{keywordflow}{if} (MatrixType::RowsAtCompileTime==\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic})
00129   \{
00130     timerSa.reset();
00131     timerStd.reset();
00132 
00133     gsl\_matrix* gslCovMat = gsl\_matrix\_alloc(covMat.rows(),covMat.cols());
00134     gsl\_matrix* gslCopy = gsl\_matrix\_alloc(covMat.rows(),covMat.cols());
00135     gsl\_matrix* eigvect = gsl\_matrix\_alloc(covMat.rows(),covMat.cols());
00136     gsl\_vector* eigval  = gsl\_vector\_alloc(covMat.rows());
00137     gsl\_eigen\_symmv\_workspace* eisymm = gsl\_eigen\_symmv\_alloc(covMat.rows());
00138     
00139     gsl\_matrix\_complex* eigvectz = gsl\_matrix\_complex\_alloc(covMat.rows(),covMat.cols());
00140     gsl\_vector\_complex* eigvalz  = gsl\_vector\_complex\_alloc(covMat.rows());
00141     gsl\_eigen\_nonsymmv\_workspace* einonsymm = gsl\_eigen\_nonsymmv\_alloc(covMat.rows());
00142     
00143     eiToGsl(covMat, &gslCovMat);
00144     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} t=0; t<TRIES; ++t)
00145     \{
00146       timerSa.start();
00147       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<saRepeats; ++k)
00148       \{
00149         gsl\_matrix\_memcpy(gslCopy,gslCovMat);
00150         gsl\_eigen\_symmv(gslCopy, eigval, eigvect, eisymm);
00151         acc += gsl\_matrix\_get(eigvect,r,c);
00152       \}
00153       timerSa.stop();
00154     \}
00155     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} t=0; t<TRIES; ++t)
00156     \{
00157       timerStd.start();
00158       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<stdRepeats; ++k)
00159       \{
00160         gsl\_matrix\_memcpy(gslCopy,gslCovMat);
00161         gsl\_eigen\_nonsymmv(gslCopy, eigvalz, eigvectz, einonsymm);
00162         acc += GSL\_REAL(gsl\_matrix\_complex\_get(eigvectz,r,c));
00163       \}
00164       timerStd.stop();
00165     \}
00166 
00167     std::cout << \textcolor{stringliteral}{" | \(\backslash\)t"}
00168               << timerSa.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() * REPEAT / saRepeats << \textcolor{stringliteral}{"s \(\backslash\)t"}
00169               << timerStd.\hyperlink{class_eigen_1_1_bench_timer_a26760f963ed8b64c126159bfea57735e}{value}() * REPEAT / stdRepeats << \textcolor{stringliteral}{"s"};
00170 
00171     gsl\_matrix\_free(gslCovMat);
00172     gsl\_vector\_free(gslCopy);
00173     gsl\_matrix\_free(eigvect);
00174     gsl\_vector\_free(eigval);
00175     gsl\_matrix\_complex\_free(eigvectz);
00176     gsl\_vector\_complex\_free(eigvalz);
00177     gsl\_eigen\_symmv\_free(eisymm);
00178     gsl\_eigen\_nonsymmv\_free(einonsymm);
00179   \}
00180 \textcolor{preprocessor}{  #endif}
00181 
00182   std::cout << \textcolor{stringliteral}{"\(\backslash\)n"};
00183   
00184   \textcolor{comment}{// make sure the compiler does not optimize too much}
00185   \textcolor{keywordflow}{if} (acc==123)
00186     std::cout << acc;
00187 \}
00188 
00189 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
00190 \{
00191   \textcolor{keyword}{const} \textcolor{keywordtype}{int} dynsizes[] = \{4,6,8,12,16,24,32,64,128,256,512,0\};
00192   std::cout << \textcolor{stringliteral}{"size            selfadjoint       generic"};
00193 \textcolor{preprocessor}{  #ifdef BENCH\_GMM}
00194   std::cout << \textcolor{stringliteral}{"        GMM++          "};
00195 \textcolor{preprocessor}{  #endif}
00196 \textcolor{preprocessor}{  #ifdef BENCH\_GSL}
00197   std::cout << \textcolor{stringliteral}{"       GSL (double + ATLAS)  "};
00198 \textcolor{preprocessor}{  #endif}
00199   std::cout << \textcolor{stringliteral}{"\(\backslash\)n"};
00200   \textcolor{keywordflow}{for} (uint i=0; dynsizes[i]>0; ++i)
00201     benchEigenSolver(\hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>}(dynsizes[i],dynsizes[i]))
      ;
00202 
00203   benchEigenSolver(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,2,2>}());
00204   benchEigenSolver(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,3,3>}());
00205   benchEigenSolver(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,4,4>}());
00206   benchEigenSolver(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,6,6>}());
00207   benchEigenSolver(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,8,8>}());
00208   benchEigenSolver(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,12,12>}());
00209   benchEigenSolver(\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,16,16>}());
00210   \textcolor{keywordflow}{return} 0;
00211 \}
00212 
\end{DoxyCode}
