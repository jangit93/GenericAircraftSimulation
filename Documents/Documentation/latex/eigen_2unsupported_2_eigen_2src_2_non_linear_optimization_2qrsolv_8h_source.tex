\hypertarget{eigen_2unsupported_2_eigen_2src_2_non_linear_optimization_2qrsolv_8h_source}{}\section{eigen/unsupported/\+Eigen/src/\+Non\+Linear\+Optimization/qrsolv.h}
\label{eigen_2unsupported_2_eigen_2src_2_non_linear_optimization_2qrsolv_8h_source}\index{qrsolv.\+h@{qrsolv.\+h}}

\begin{DoxyCode}
00001 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00002 
00003 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00004 
00005 \textcolor{comment}{// TODO : once qrsolv2 is removed, use ColPivHouseholderQR or PermutationMatrix instead of ipvt}
00006 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00007 \textcolor{keywordtype}{void} qrsolv(
00008         \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, Dynamic >} &s,
00009         \textcolor{comment}{// TODO : use a PermutationMatrix once lmpar is no more:}
00010         \textcolor{keyword}{const} VectorXi &ipvt,
00011         \textcolor{keyword}{const} \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  &diag,
00012         \textcolor{keyword}{const} \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  &qtb,
00013         \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  &x,
00014         \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  &sdiag)
00015 
00016 \{
00017     \textcolor{keyword}{typedef} DenseIndex \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00018 
00019     \textcolor{comment}{/* Local variables */}
00020     Index i, j, k, l;
00021     Scalar temp;
00022     Index n = s.cols();
00023     \hyperlink{group___core___module}{Matrix< Scalar, Dynamic, 1 >}  wa(n);
00024     JacobiRotation<Scalar> givens;
00025 
00026     \textcolor{comment}{/* Function Body */}
00027     \textcolor{comment}{// the following will only change the lower triangular part of s, including}
00028     \textcolor{comment}{// the diagonal, though the diagonal is restored afterward}
00029 
00030     \textcolor{comment}{/*     copy r and (q transpose)*b to preserve input and initialize s. */}
00031     \textcolor{comment}{/*     in particular, save the diagonal elements of r in x. */}
00032     x = s.diagonal();
00033     wa = qtb;
00034 
00035     s.topLeftCorner(n,n).template triangularView<StrictlyLower>() = s.topLeftCorner(n,n).transpose();
00036 
00037     \textcolor{comment}{/*     eliminate the diagonal matrix d using a givens rotation. */}
00038     \textcolor{keywordflow}{for} (j = 0; j < n; ++j) \{
00039 
00040         \textcolor{comment}{/*        prepare the row of d to be eliminated, locating the */}
00041         \textcolor{comment}{/*        diagonal element using p from the qr factorization. */}
00042         l = ipvt[j];
00043         \textcolor{keywordflow}{if} (diag[l] == 0.)
00044             \textcolor{keywordflow}{break};
00045         sdiag.tail(n-j).\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00046         sdiag[j] = diag[l];
00047 
00048         \textcolor{comment}{/*        the transformations to eliminate the row of d */}
00049         \textcolor{comment}{/*        modify only a single element of (q transpose)*b */}
00050         \textcolor{comment}{/*        beyond the first n, which is initially zero. */}
00051         Scalar qtbpj = 0.;
00052         \textcolor{keywordflow}{for} (k = j; k < n; ++k) \{
00053             \textcolor{comment}{/*           determine a givens rotation which eliminates the */}
00054             \textcolor{comment}{/*           appropriate element in the current row of d. */}
00055             givens.makeGivens(-s(k,k), sdiag[k]);
00056 
00057             \textcolor{comment}{/*           compute the modified diagonal element of r and */}
00058             \textcolor{comment}{/*           the modified element of ((q transpose)*b,0). */}
00059             s(k,k) = givens.c() * s(k,k) + givens.s() * sdiag[k];
00060             temp = givens.c() * wa[k] + givens.s() * qtbpj;
00061             qtbpj = -givens.s() * wa[k] + givens.c() * qtbpj;
00062             wa[k] = temp;
00063 
00064             \textcolor{comment}{/*           accumulate the tranformation in the row of s. */}
00065             \textcolor{keywordflow}{for} (i = k+1; i<n; ++i) \{
00066                 temp = givens.c() * s(i,k) + givens.s() * sdiag[i];
00067                 sdiag[i] = -givens.s() * s(i,k) + givens.c() * sdiag[i];
00068                 s(i,k) = temp;
00069             \}
00070         \}
00071     \}
00072 
00073     \textcolor{comment}{/*     solve the triangular system for z. if the system is */}
00074     \textcolor{comment}{/*     singular, then obtain a least squares solution. */}
00075     Index nsing;
00076     \textcolor{keywordflow}{for}(nsing=0; nsing<n && sdiag[nsing]!=0; nsing++) \{\}
00077 
00078     wa.tail(n-nsing).\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00079     s.topLeftCorner(nsing, nsing).transpose().template triangularView<Upper>().solveInPlace(wa.head(nsing))
      ;
00080 
00081     \textcolor{comment}{// restore}
00082     sdiag = s.diagonal();
00083     s.diagonal() = x;
00084 
00085     \textcolor{comment}{/*     permute the components of z back to components of x. */}
00086     \textcolor{keywordflow}{for} (j = 0; j < n; ++j) x[ipvt[j]] = wa[j];
00087 \}
00088 
00089 \} \textcolor{comment}{// end namespace internal}
00090 
00091 \} \textcolor{comment}{// end namespace Eigen}
\end{DoxyCode}
