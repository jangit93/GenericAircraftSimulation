\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2products_2_general_matrix_matrix_triangular_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/products/\+General\+Matrix\+Matrix\+Triangular.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2products_2_general_matrix_matrix_triangular_8h_source}\index{General\+Matrix\+Matrix\+Triangular.\+h@{General\+Matrix\+Matrix\+Triangular.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_GENERAL\_MATRIX\_MATRIX\_TRIANGULAR\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_GENERAL\_MATRIX\_MATRIX\_TRIANGULAR\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} StorageOrder, \textcolor{keywordtype}{int} UpLo, \textcolor{keywordtype}{bool} ConjLhs, \textcolor{keywordtype}{bool} ConjRhs>
00016 \textcolor{keyword}{struct }selfadjoint\_rank1\_update;
00017 
00018 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00019 
00020 \textcolor{comment}{/**********************************************************************}
00021 \textcolor{comment}{* This file implements a general A * B product while}
00022 \textcolor{comment}{* evaluating only one triangular part of the product.}
00023 \textcolor{comment}{* This is a more general version of self adjoint product (C += A A^T)}
00024 \textcolor{comment}{* as the level 3 SYRK Blas routine.}
00025 \textcolor{comment}{**********************************************************************/}
00026 
00027 \textcolor{comment}{// forward declarations (defined at the end of this file)}
00028 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} mr, \textcolor{keywordtype}{int} nr, \textcolor{keywordtype}{bool} ConjLhs, \textcolor{keywordtype}{bool} ConjRhs
      , \textcolor{keywordtype}{int} UpLo>
00029 \textcolor{keyword}{struct }tribb\_kernel;
00030   
00031 \textcolor{comment}{/* Optimized matrix-matrix product evaluating only one triangular half */}
00032 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00033           \textcolor{keyword}{typename} LhsScalar, \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00034           \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs,
00035                               \textcolor{keywordtype}{int} ResStorageOrder, \textcolor{keywordtype}{int}  UpLo, \textcolor{keywordtype}{int} Version = Specialized>
00036 \textcolor{keyword}{struct }general\_matrix\_matrix\_triangular\_product;
00037 
00038 \textcolor{comment}{// as usual if the result is row major => we transpose the product}
00039 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keyword}{typename} LhsScalar, \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00040                           \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int}  UpLo, \textcolor{keywordtype}{int} 
      Version>
00041 \textcolor{keyword}{struct }general\_matrix\_matrix\_triangular\_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,
      RhsStorageOrder,ConjugateRhs,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},UpLo,Version>
00042 \{
00043   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;
00044   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Index size, Index depth,\textcolor{keyword}{const} LhsScalar* lhs, Index lhsStride,
00045                                       \textcolor{keyword}{const} RhsScalar* rhs, Index rhsStride, ResScalar* res, Index 
      resStride,
00046                                       \textcolor{keyword}{const} ResScalar& alpha, level3\_blocking<RhsScalar,LhsScalar>& 
      blocking)
00047   \{
00048     general\_matrix\_matrix\_triangular\_product<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00049         RhsScalar, RhsStorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor} : 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}, ConjugateRhs,
00050         LhsScalar, LhsStorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor} : 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}, ConjugateLhs,
00051         \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}, UpLo==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}?\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}:\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}>
00052       ::run(size,depth,rhs,rhsStride,lhs,lhsStride,res,resStride,alpha,blocking);
00053   \}
00054 \};
00055 
00056 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keyword}{typename} LhsScalar, \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00057                           \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int}  UpLo, \textcolor{keywordtype}{int} 
      Version>
00058 \textcolor{keyword}{struct }general\_matrix\_matrix\_triangular\_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,
      RhsStorageOrder,ConjugateRhs,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},UpLo,Version>
00059 \{
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;
00061   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Index size, Index depth,\textcolor{keyword}{const} LhsScalar* \_lhs, Index lhsStride,
00062                                       \textcolor{keyword}{const} RhsScalar* \_rhs, Index rhsStride, ResScalar* \_res, Index 
      resStride,
00063                                       \textcolor{keyword}{const} ResScalar& alpha, level3\_blocking<LhsScalar,RhsScalar>& 
      blocking)
00064   \{
00065     \textcolor{keyword}{typedef} gebp\_traits<LhsScalar,RhsScalar> Traits;
00066 
00067     \textcolor{keyword}{typedef} const\_blas\_data\_mapper<LhsScalar, Index, LhsStorageOrder> LhsMapper;
00068     \textcolor{keyword}{typedef} const\_blas\_data\_mapper<RhsScalar, Index, RhsStorageOrder> RhsMapper;
00069     \textcolor{keyword}{typedef} blas\_data\_mapper<typename Traits::ResScalar, Index, ColMajor> ResMapper;
00070     LhsMapper lhs(\_lhs,lhsStride);
00071     RhsMapper rhs(\_rhs,rhsStride);
00072     ResMapper res(\_res, resStride);
00073 
00074     Index kc = blocking.kc();
00075     Index mc = (std::min)(size,blocking.mc());
00076 
00077     \textcolor{comment}{// !!! mc must be a multiple of nr:}
00078     \textcolor{keywordflow}{if}(mc > Traits::nr)
00079       mc = (mc/Traits::nr)*Traits::nr;
00080 
00081     std::size\_t sizeA = kc*mc;
00082     std::size\_t sizeB = kc*size;
00083 
00084     ei\_declare\_aligned\_stack\_constructed\_variable(LhsScalar, blockA, sizeA, blocking.blockA());
00085     ei\_declare\_aligned\_stack\_constructed\_variable(RhsScalar, blockB, sizeB, blocking.blockB());
00086 
00087     gemm\_pack\_lhs<LhsScalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack\_lhs;
00088     gemm\_pack\_rhs<RhsScalar, Index, RhsMapper, Traits::nr, RhsStorageOrder> pack\_rhs;
00089     gebp\_kernel<LhsScalar, RhsScalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs>
       gebp;
00090     tribb\_kernel<LhsScalar, RhsScalar, Index, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs, UpLo> 
      sybb;
00091 
00092     \textcolor{keywordflow}{for}(Index k2=0; k2<depth; k2+=kc)
00093     \{
00094       \textcolor{keyword}{const} Index actual\_kc = (std::min)(k2+kc,depth)-k2;
00095 
00096       \textcolor{comment}{// note that the actual rhs is the transpose/adjoint of mat}
00097       pack\_rhs(blockB, rhs.getSubMapper(k2,0), actual\_kc, size);
00098 
00099       \textcolor{keywordflow}{for}(Index i2=0; i2<size; i2+=mc)
00100       \{
00101         \textcolor{keyword}{const} Index actual\_mc = (std::min)(i2+mc,size)-i2;
00102 
00103         pack\_lhs(blockA, lhs.getSubMapper(i2, k2), actual\_kc, actual\_mc);
00104 
00105         \textcolor{comment}{// the selected actual\_mc * size panel of res is split into three different part:}
00106         \textcolor{comment}{//  1 - before the diagonal => processed with gebp or skipped}
00107         \textcolor{comment}{//  2 - the actual\_mc x actual\_mc symmetric block => processed with a special kernel}
00108         \textcolor{comment}{//  3 - after the diagonal => processed with gebp or skipped}
00109         \textcolor{keywordflow}{if} (UpLo==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower})
00110           gebp(res.getSubMapper(i2, 0), blockA, blockB, actual\_mc, actual\_kc,
00111                (std::min)(size,i2), alpha, -1, -1, 0, 0);
00112 
00113 
00114         sybb(\_res+resStride*i2 + i2, resStride, blockA, blockB + actual\_kc*i2, actual\_mc, actual\_kc, alpha)
      ;
00115 
00116         \textcolor{keywordflow}{if} (UpLo==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper})
00117         \{
00118           Index j2 = i2+actual\_mc;
00119           gebp(res.getSubMapper(i2, j2), blockA, blockB+actual\_kc*j2, actual\_mc,
00120                actual\_kc, (std::max)(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(0), size-j2), alpha, -1, -1, 0, 0);
00121         \}
00122       \}
00123     \}
00124   \}
00125 \};
00126 
00127 \textcolor{comment}{// Optimized packed Block * packed Block product kernel evaluating only one given triangular part}
00128 \textcolor{comment}{// This kernel is built on top of the gebp kernel:}
00129 \textcolor{comment}{// - the current destination block is processed per panel of actual\_mc x BlockSize}
00130 \textcolor{comment}{//   where BlockSize is set to the minimal value allowing gebp to be as fast as possible}
00131 \textcolor{comment}{// - then, as usual, each panel is split into three parts along the diagonal,}
00132 \textcolor{comment}{//   the sub blocks above and below the diagonal are processed as usual,}
00133 \textcolor{comment}{//   while the triangular block overlapping the diagonal is evaluated into a}
00134 \textcolor{comment}{//   small temporary buffer which is then accumulated into the result using a}
00135 \textcolor{comment}{//   triangular traversal.}
00136 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} mr, \textcolor{keywordtype}{int} nr, \textcolor{keywordtype}{bool} ConjLhs, \textcolor{keywordtype}{bool} ConjRhs
      , \textcolor{keywordtype}{int} UpLo>
00137 \textcolor{keyword}{struct }tribb\_kernel
00138 \{
00139   \textcolor{keyword}{typedef} gebp\_traits<LhsScalar,RhsScalar,ConjLhs,ConjRhs> Traits;
00140   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Traits::ResScalar ResScalar;
00141 
00142   \textcolor{keyword}{enum} \{
00143     BlockSize  = meta\_least\_common\_multiple<EIGEN\_PLAIN\_ENUM\_MAX(mr,nr),EIGEN\_PLAIN\_ENUM\_MIN(mr,nr)>::ret
00144   \};
00145   \textcolor{keywordtype}{void} operator()(ResScalar* \_res, Index resStride, \textcolor{keyword}{const} LhsScalar* blockA, \textcolor{keyword}{const} RhsScalar* blockB, Index
       size, Index depth, \textcolor{keyword}{const} ResScalar& alpha)
00146   \{
00147     \textcolor{keyword}{typedef} blas\_data\_mapper<ResScalar, Index, ColMajor> ResMapper;
00148     ResMapper res(\_res, resStride);
00149     gebp\_kernel<LhsScalar, RhsScalar, Index, ResMapper, mr, nr, ConjLhs, ConjRhs> gebp\_kernel;
00150 
00151     Matrix<ResScalar,BlockSize,BlockSize,ColMajor> buffer((
      internal::constructor\_without\_unaligned\_array\_assert()));
00152 
00153     \textcolor{comment}{// let's process the block per panel of actual\_mc x BlockSize,}
00154     \textcolor{comment}{// again, each is split into three parts, etc.}
00155     \textcolor{keywordflow}{for} (Index j=0; j<size; j+=BlockSize)
00156     \{
00157       Index actualBlockSize = std::min<Index>(BlockSize,size - j);
00158       \textcolor{keyword}{const} RhsScalar* actual\_b = blockB+j*depth;
00159 
00160       \textcolor{keywordflow}{if}(UpLo==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper})
00161         gebp\_kernel(res.getSubMapper(0, j), blockA, actual\_b, j, depth, actualBlockSize, alpha,
00162                     -1, -1, 0, 0);
00163 
00164       \textcolor{comment}{// selfadjoint micro block}
00165       \{
00166         Index i = j;
00167         buffer.setZero();
00168         \textcolor{comment}{// 1 - apply the kernel on the temporary buffer}
00169         gebp\_kernel(ResMapper(buffer.data(), BlockSize), blockA+depth*i, actual\_b, actualBlockSize, depth, 
      actualBlockSize, alpha,
00170                     -1, -1, 0, 0);
00171         \textcolor{comment}{// 2 - triangular accumulation}
00172         \textcolor{keywordflow}{for}(Index j1=0; j1<actualBlockSize; ++j1)
00173         \{
00174           ResScalar* r = &res(i, j + j1);
00175           \textcolor{keywordflow}{for}(Index i1=UpLo==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} ? j1 : 0;
00176               UpLo==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} ? i1<actualBlockSize : i1<=j1; ++i1)
00177             r[i1] += buffer(i1,j1);
00178         \}
00179       \}
00180 
00181       \textcolor{keywordflow}{if}(UpLo==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower})
00182       \{
00183         Index i = j+actualBlockSize;
00184         gebp\_kernel(res.getSubMapper(i, j), blockA+depth*i, actual\_b, size-i, 
00185                     depth, actualBlockSize, alpha, -1, -1, 0, 0);
00186       \}
00187     \}
00188   \}
00189 \};
00190 
00191 \} \textcolor{comment}{// end namespace internal}
00192 
00193 \textcolor{comment}{// high level API}
00194 
00195 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ProductType, \textcolor{keywordtype}{int} UpLo, \textcolor{keywordtype}{bool} IsOuterProduct>
00196 \textcolor{keyword}{struct }general\_product\_to\_triangular\_selector;
00197 
00198 
00199 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ProductType, \textcolor{keywordtype}{int} UpLo>
00200 \textcolor{keyword}{struct }general\_product\_to\_triangular\_selector<MatrixType,ProductType,UpLo,true>
00201 \{
00202   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType& mat, \textcolor{keyword}{const} ProductType& prod, \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::Scalar& alpha, \textcolor{keywordtype}{bool} 
      beta)
00203   \{
00204     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00205     
00206     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<typename ProductType::LhsNested>::type Lhs;
00207     \textcolor{keyword}{typedef} internal::blas\_traits<Lhs> LhsBlasTraits;
00208     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsBlasTraits::DirectLinearAccessType ActualLhs;
00209     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ActualLhs>::type \_ActualLhs;
00210     \textcolor{keyword}{typename} internal::add\_const\_on\_value\_type<ActualLhs>::type actualLhs = LhsBlasTraits::extract(prod.lhs
      ());
00211     
00212     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<typename ProductType::RhsNested>::type Rhs;
00213     \textcolor{keyword}{typedef} internal::blas\_traits<Rhs> RhsBlasTraits;
00214     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsBlasTraits::DirectLinearAccessType ActualRhs;
00215     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ActualRhs>::type \_ActualRhs;
00216     \textcolor{keyword}{typename} internal::add\_const\_on\_value\_type<ActualRhs>::type actualRhs = RhsBlasTraits::extract(prod.rhs
      ());
00217 
00218     Scalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(prod.lhs().derived()) * 
      RhsBlasTraits::extractScalarFactor(prod.rhs().derived());
00219 
00220     \textcolor{keywordflow}{if}(!beta)
00221       mat.template triangularView<UpLo>().setZero();
00222 
00223     \textcolor{keyword}{enum} \{
00224       StorageOrder = (internal::traits<MatrixType>::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},
00225       UseLhsDirectly = \_ActualLhs::InnerStrideAtCompileTime==1,
00226       UseRhsDirectly = \_ActualRhs::InnerStrideAtCompileTime==1
00227     \};
00228     
00229     
      internal::gemv\_static\_vector\_if<Scalar,Lhs::SizeAtCompileTime,Lhs::MaxSizeAtCompileTime,!UseLhsDirectly> static\_lhs;
00230     ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, actualLhsPtr, actualLhs.size(),
00231       (UseLhsDirectly ? \textcolor{keyword}{const\_cast<}Scalar*\textcolor{keyword}{>}(actualLhs.data()) : static\_lhs.data()));
00232     \textcolor{keywordflow}{if}(!UseLhsDirectly) Map<typename \_ActualLhs::PlainObject>(actualLhsPtr, actualLhs.size()) = actualLhs;
00233     
00234     
      internal::gemv\_static\_vector\_if<Scalar,Rhs::SizeAtCompileTime,Rhs::MaxSizeAtCompileTime,!UseRhsDirectly> static\_rhs;
00235     ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, actualRhsPtr, actualRhs.size(),
00236       (UseRhsDirectly ? \textcolor{keyword}{const\_cast<}Scalar*\textcolor{keyword}{>}(actualRhs.data()) : static\_rhs.data()));
00237     \textcolor{keywordflow}{if}(!UseRhsDirectly) Map<typename \_ActualRhs::PlainObject>(actualRhsPtr, actualRhs.size()) = actualRhs;
00238     
00239     
00240     selfadjoint\_rank1\_update<Scalar,\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},StorageOrder,UpLo,
00241                               LhsBlasTraits::NeedToConjugate && NumTraits<Scalar>::IsComplex,
00242                               RhsBlasTraits::NeedToConjugate && NumTraits<Scalar>::IsComplex>
00243           ::run(actualLhs.size(), mat.data(), mat.outerStride(), actualLhsPtr, actualRhsPtr, actualAlpha);
00244   \}
00245 \};
00246 
00247 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} ProductType, \textcolor{keywordtype}{int} UpLo>
00248 \textcolor{keyword}{struct }general\_product\_to\_triangular\_selector<MatrixType,ProductType,UpLo,false>
00249 \{
00250   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(MatrixType& mat, \textcolor{keyword}{const} ProductType& prod, \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::Scalar& alpha, \textcolor{keywordtype}{bool} 
      beta)
00251   \{
00252     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<typename ProductType::LhsNested>::type Lhs;
00253     \textcolor{keyword}{typedef} internal::blas\_traits<Lhs> LhsBlasTraits;
00254     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsBlasTraits::DirectLinearAccessType ActualLhs;
00255     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ActualLhs>::type \_ActualLhs;
00256     \textcolor{keyword}{typename} internal::add\_const\_on\_value\_type<ActualLhs>::type actualLhs = LhsBlasTraits::extract(prod.lhs
      ());
00257     
00258     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<typename ProductType::RhsNested>::type Rhs;
00259     \textcolor{keyword}{typedef} internal::blas\_traits<Rhs> RhsBlasTraits;
00260     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsBlasTraits::DirectLinearAccessType ActualRhs;
00261     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ActualRhs>::type \_ActualRhs;
00262     \textcolor{keyword}{typename} internal::add\_const\_on\_value\_type<ActualRhs>::type actualRhs = RhsBlasTraits::extract(prod.rhs
      ());
00263 
00264     \textcolor{keyword}{typename} ProductType::Scalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(prod.lhs().
      derived()) * RhsBlasTraits::extractScalarFactor(prod.rhs().derived());
00265 
00266     \textcolor{keywordflow}{if}(!beta)
00267       mat.template triangularView<UpLo>().setZero();
00268 
00269     \textcolor{keyword}{enum} \{
00270       IsRowMajor = (internal::traits<MatrixType>::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? 1 : 0,
00271       LhsIsRowMajor = \_ActualLhs::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} ? 1 : 0,
00272       RhsIsRowMajor = \_ActualRhs::Flags&RowMajorBit ? 1 : 0,
00273       SkipDiag = (UpLo&(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaddb72f888ac85d5a1c52333e54f9374b}{UnitDiag}|\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda884ff7240392e85aa6e4b3c957e36483}{ZeroDiag}))!=0
00274     \};
00275 
00276     Index size = mat.cols();
00277     \textcolor{keywordflow}{if}(SkipDiag)
00278       size--;
00279     Index depth = actualLhs.cols();
00280 
00281     \textcolor{keyword}{typedef} internal::gemm\_blocking\_space<IsRowMajor ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},\textcolor{keyword}{typename} Lhs::Scalar,\textcolor{keyword}{typename} Rhs::Scalar,
00282           MatrixType::MaxColsAtCompileTime, MatrixType::MaxColsAtCompileTime, 
      \_ActualRhs::MaxColsAtCompileTime> BlockingType;
00283 
00284     BlockingType blocking(size, size, depth, 1, \textcolor{keyword}{false});
00285 
00286     internal::general\_matrix\_matrix\_triangular\_product<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00287       \textcolor{keyword}{typename} Lhs::Scalar, LhsIsRowMajor ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}, 
      LhsBlasTraits::NeedToConjugate,
00288       \textcolor{keyword}{typename} Rhs::Scalar, RhsIsRowMajor ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}, 
      RhsBlasTraits::NeedToConjugate,
00289       IsRowMajor ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}, UpLo&(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}|\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper})>
00290       ::run(size, depth,
00291             &actualLhs.coeffRef(SkipDiag&&(UpLo&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower})==Lower ? 1 : 0,0), actualLhs.outerStride(),
00292             &actualRhs.coeffRef(0,SkipDiag&&(UpLo&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper})==Upper ? 1 : 0), actualRhs.outerStride(),
00293             mat.data() + (SkipDiag ? (bool(IsRowMajor) != ((UpLo&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower})==Lower) ? 1 : mat.outerStride(
      ) ) : 0), mat.outerStride(), actualAlpha, blocking);
00294   \}
00295 \};
00296 
00297 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} UpLo>
00298 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ProductType>
00299 TriangularView<MatrixType,UpLo>& TriangularViewImpl<MatrixType,UpLo,Dense>::\_assignProduct(\textcolor{keyword}{const} 
      ProductType& prod, \textcolor{keyword}{const} Scalar& alpha, \textcolor{keywordtype}{bool} beta)
00300 \{
00301   EIGEN\_STATIC\_ASSERT((UpLo&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaddb72f888ac85d5a1c52333e54f9374b}{UnitDiag})==0, 
      WRITING\_TO\_TRIANGULAR\_PART\_WITH\_UNIT\_DIAGONAL\_IS\_NOT\_SUPPORTED);
00302   eigen\_assert(derived().nestedExpression().rows() == prod.rows() && derived().cols() == prod.cols());
00303   
00304   general\_product\_to\_triangular\_selector<MatrixType, ProductType, UpLo,
       internal::traits<ProductType>::InnerSize==1>::run(derived().nestedExpression().const\_cast\_derived(), prod, alpha, beta);
00305   
00306   \textcolor{keywordflow}{return} derived();
00307 \}
00308 
00309 \} \textcolor{comment}{// end namespace Eigen}
00310 
00311 \textcolor{preprocessor}{#endif // EIGEN\_GENERAL\_MATRIX\_MATRIX\_TRIANGULAR\_H}
\end{DoxyCode}
