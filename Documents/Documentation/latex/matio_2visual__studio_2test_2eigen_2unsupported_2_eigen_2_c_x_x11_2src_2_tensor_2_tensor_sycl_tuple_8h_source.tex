\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_sycl_tuple_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Sycl\+Tuple.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_sycl_tuple_8h_source}\index{Tensor\+Sycl\+Tuple.\+h@{Tensor\+Sycl\+Tuple.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Mehdi Goli    Codeplay Software Ltd.}
00005 \textcolor{comment}{// Ralph Potter  Codeplay Software Ltd.}
00006 \textcolor{comment}{// Luke Iwanski  Codeplay Software Ltd.}
00007 \textcolor{comment}{// Contact: <eigen@codeplay.com>}
00008 \textcolor{comment}{//}
00009 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00010 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00011 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00012 
00013 \textcolor{comment}{/*****************************************************************}
00014 \textcolor{comment}{ * TensroSyclTuple.h}
00015 \textcolor{comment}{ *}
00016 \textcolor{comment}{ * \(\backslash\)brief:}
00017 \textcolor{comment}{ *  Minimal implementation of std::tuple that can be used inside a SYCL kernel.}
00018 \textcolor{comment}{ *}
00019 \textcolor{comment}{*****************************************************************/}
00020 
00021 \textcolor{preprocessor}{#ifndef UNSUPPORTED\_EIGEN\_CXX11\_SRC\_TENSOR\_TENSORSYCL\_TUPLE\_HPP}
00022 \textcolor{preprocessor}{#define UNSUPPORTED\_EIGEN\_CXX11\_SRC\_TENSOR\_TENSORSYCL\_TUPLE\_HPP}
00023 \textcolor{keyword}{namespace }\hyperlink{namespaceutility}{utility} \{
00024 \textcolor{keyword}{namespace }tuple \{
00028 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool}, \textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}> \textcolor{keyword}{struct }StaticIf;
00030 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00031 \textcolor{keyword}{struct }StaticIf<true, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}> \{
00032   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type;
00033 \};
00034 
00039 \textcolor{keyword}{template} <\textcolor{keyword}{class}... Ts>
00040 \textcolor{keyword}{struct }Tuple \{\};
00041 
00046 \textcolor{keyword}{template} <\textcolor{keyword}{class }\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \textcolor{keyword}{class}... Ts>
00047 \textcolor{keyword}{struct }Tuple<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, Ts...> \{
00048   Tuple(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} t, Ts... ts) : head(t), tail(ts...) \{\}
00049   \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} head;
00050   Tuple<Ts...> tail;
00051 \};
00052 
00058 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t}, \textcolor{keyword}{class}>
00059 \textcolor{keyword}{struct }ElemTypeHolder;
00060 
00063 \textcolor{keyword}{template} <\textcolor{keyword}{class }\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, \textcolor{keyword}{class}... Ts>
00064 \textcolor{keyword}{struct }ElemTypeHolder<0, Tuple<T, Ts...> > \{
00065   \textcolor{keyword}{typedef} T type;
00066 \};
00067 
00074 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keyword}{class }T, \textcolor{keyword}{class}... Ts>
00075 \textcolor{keyword}{struct }ElemTypeHolder<k, Tuple<T, Ts...> > \{
00076   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ElemTypeHolder<k - 1, Tuple<Ts...> >::type type;
00077 \};
00078 
00085 
00086 \textcolor{preprocessor}{#define TERMINATE\_CONDS\_TUPLE\_GET(CVQual) \(\backslash\)}
00087 \textcolor{preprocessor}{template <size\_t k, class... Ts> \(\backslash\)}
00088 \textcolor{preprocessor}{typename StaticIf<k == 0, CVQual typename ElemTypeHolder<0, Tuple<Ts...> >::type &>::type \(\backslash\)}
00089 \textcolor{preprocessor}{get(CVQual Tuple<Ts...> &t) \{ \(\backslash\)}
00090 \textcolor{preprocessor}{  static\_assert(sizeof...(Ts)!=0, "The requseted value is bigger than the size of the tuple"); \(\backslash\)}
00091 \textcolor{preprocessor}{  return t.head; \(\backslash\)}
00092 \textcolor{preprocessor}{\}}
00093 
00094 TERMINATE\_CONDS\_TUPLE\_GET(\textcolor{keyword}{const})
00095 TERMINATE\_CONDS\_TUPLE\_GET()
00096 \textcolor{preprocessor}{#undef TERMINATE\_CONDS\_TUPLE\_GET}
00097 \textcolor{preprocessor}{#define RECURSIVE\_TUPLE\_GET(CVQual) \(\backslash\)}
00105 \textcolor{preprocessor}{template <size\_t k, class T, class... Ts> \(\backslash\)}
00106 \textcolor{preprocessor}{typename StaticIf<k != 0, CVQual typename ElemTypeHolder<k, Tuple<T, Ts...> >::type &>::type \(\backslash\)}
00107 \textcolor{preprocessor}{get(CVQual Tuple<T, Ts...> &t) \{ \(\backslash\)}
00108 \textcolor{preprocessor}{  return utility::tuple::get<k - 1>(t.tail); \(\backslash\)}
00109 \textcolor{preprocessor}{\}}
00110 RECURSIVE\_TUPLE\_GET(\textcolor{keyword}{const})
00111 RECURSIVE\_TUPLE\_GET()
00112 \textcolor{preprocessor}{#undef RECURSIVE\_TUPLE\_GET}
00113 
00120 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>
00121 Tuple<Args...> make\_tuple(Args... args) \{
00122   \textcolor{keywordflow}{return} Tuple<Args...>(args...);
00123 \}
00124 
00130 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>
00131 \textcolor{keyword}{static} constexpr \textcolor{keywordtype}{size\_t} size(Tuple<Args...> &) \{
00132   \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}...(Args);
00133 \}
00134 
00138 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t}... Is>
00139 \textcolor{keyword}{struct }IndexList \{\};
00140 
00147 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} MIN, \textcolor{keywordtype}{size\_t} N, \textcolor{keywordtype}{size\_t}... Is>
00148 \textcolor{keyword}{struct }RangeBuilder;
00149 
00154 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} MIN, \textcolor{keywordtype}{size\_t}... Is>
00155 \textcolor{keyword}{struct }RangeBuilder<MIN, MIN, Is...> \{
00156   \textcolor{keyword}{typedef} IndexList<Is...> type;
00157 \};
00158 
00165 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} MIN, \textcolor{keywordtype}{size\_t} N, \textcolor{keywordtype}{size\_t}... Is>
00166 \textcolor{keyword}{struct }RangeBuilder : \textcolor{keyword}{public} RangeBuilder<MIN, N - 1, N - 1, Is...> \{\};
00167 
00171 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} MIN, \textcolor{keywordtype}{size\_t} MAX>
00172 \textcolor{keyword}{struct }IndexRange: RangeBuilder<MIN, MAX>::type \{\};
00173 
00183 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args, \textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t}... I>
00184 Tuple<Args..., T> append\_base(Tuple<Args...> t, T a,IndexList<I...>) \{
00185   \textcolor{keywordflow}{return} utility::tuple::make\_tuple(get<I>(t)..., a);
00186 \}
00187 
00196 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args, \textcolor{keyword}{typename} T>
00197 Tuple<Args..., T> append(Tuple<Args...> t, T a) \{
00198   \textcolor{keywordflow}{return} utility::tuple::append\_base(t, a,  IndexRange<0, \textcolor{keyword}{sizeof}...(Args)>());
00199 \}
00200 
00214 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args1, \textcolor{keyword}{typename}... Args2, \textcolor{keywordtype}{size\_t}... I1, \textcolor{keywordtype}{size\_t}... I2>
00215 Tuple<Args1..., Args2...> append\_base(Tuple<Args1...> t1, Tuple<Args2...> t2, IndexList<I1...>, 
      IndexList<I2...>) \{
00216   \textcolor{keywordflow}{return} utility::tuple::make\_tuple(get<I1>(t1)...,get<I2>(t2)...);
00217 \}
00218 
00228 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args1, \textcolor{keyword}{typename}... Args2>
00229 Tuple<Args1..., Args2...> append(Tuple<Args1...> t1,Tuple<Args2...> t2) \{
00230   \textcolor{keywordflow}{return} utility::tuple::append\_base(t1, t2, IndexRange<0, \textcolor{keyword}{sizeof}...(Args1)>(), IndexRange<0, \textcolor{keyword}{sizeof}...(
      Args2)>());
00231 \}
00232 \}  \textcolor{comment}{// tuple}
00233 \}  \textcolor{comment}{// utility}
00234 \textcolor{preprocessor}{#endif  // UNSUPPORTED\_EIGEN\_CXX11\_SRC\_TENSOR\_TENSORSYCL\_TUPLE\_HPP}
\end{DoxyCode}
