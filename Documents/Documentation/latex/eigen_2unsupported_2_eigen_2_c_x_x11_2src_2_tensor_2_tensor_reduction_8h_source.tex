\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Reduction.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source}\index{Tensor\+Reduction.\+h@{Tensor\+Reduction.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2016 Mehdi Goli, Codeplay Software Ltd <eigen@codeplay.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_REDUCTION\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_REDUCTION\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 
00023 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00024   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} Dims, \textcolor{keyword}{typename} XprType,\textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_ >
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00025}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_xpr_type_00_01_make_pointer___01_4_01_4}{00025}   \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_reduction_op}{TensorReductionOp}<Op, Dims, XprType, MakePointer\_> >
00026  : \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<XprType>
00027 \{
00028   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>} \hyperlink{struct_eigen_1_1internal_1_1traits}{XprTraits};
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Scalar Scalar;
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00032   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions - 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size<Dims>::value};
00034   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00035 
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00036}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_xpr_type_00c39382462f4a2e2ae6af6fe0f8aab669}{00036}   \textcolor{keyword}{template} <\textcolor{keyword}{class} T> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_make_pointer}{MakePointer} \{
00037     \textcolor{comment}{// Intermediate typedef to workaround MSVC issue.}
00038     \textcolor{keyword}{typedef} MakePointer\_<T> MakePointerT;
00039     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MakePointerT::Type Type;
00040   \};
00041 \};
00042 
00043 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} Dims, \textcolor{keyword}{typename} XprType, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00044}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_xpr_type_00_00c091111a76ab7a3f6cf062dd12dd3c4}{00044} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_reduction_op}{TensorReductionOp}<Op, Dims, XprType, MakePointer\_>, 
      \hyperlink{namespace_eigen}{Eigen}::\hyperlink{struct_eigen_1_1_dense}{Dense}>
00045 \{
00046   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_reduction_op}{TensorReductionOp<Op, Dims, XprType, MakePointer\_>}
      & \hyperlink{class_eigen_1_1_tensor_reduction_op}{type};
00047 \};
00048 
00049 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} Dims, \textcolor{keyword}{typename} XprType, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00050}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_xpr_type_003b0e9bfd65794f3be6d0916aaf050d6d}{00050} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_reduction_op}{TensorReductionOp}<Op, Dims, XprType, MakePointer\_>, 1, typename 
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_reduction_op}{TensorReductionOp}<Op, Dims, XprType, MakePointer\_> >::
      \hyperlink{class_eigen_1_1_tensor_reduction_op}{type}>
00051 \{
00052   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_reduction_op}{TensorReductionOp<Op, Dims, XprType, MakePointer\_>}
       \hyperlink{class_eigen_1_1_tensor_reduction_op}{type};
00053 \};
00054 
00055 
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00056}\hyperlink{struct_eigen_1_1internal_1_1_dim_initializer}{00056} \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputDims> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_dim_initializer}{DimInitializer} \{
00057   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputDims, \textcolor{keyword}{typename} ReducedDims> EIGEN\_DEVICE\_FUNC
00058   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} InputDims& input\_dims,
00059                   \textcolor{keyword}{const} \hyperlink{class_eigen_1_1array}{array}<\textcolor{keywordtype}{bool}, \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<InputDims>::value}
      >& reduced,
00060                   OutputDims* output\_dims, ReducedDims* reduced\_dims) \{
00061     \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumInputDims = \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<InputDims>::value};
00062     \textcolor{keywordtype}{int} outputIndex = 0;
00063     \textcolor{keywordtype}{int} reduceIndex = 0;
00064     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumInputDims; ++i) \{
00065       \textcolor{keywordflow}{if} (reduced[i]) \{
00066         (*reduced\_dims)[reduceIndex] = input\_dims[i];
00067         ++reduceIndex;
00068       \} \textcolor{keywordflow}{else} \{
00069         (*output\_dims)[outputIndex] = input\_dims[i];
00070         ++outputIndex;
00071       \}
00072     \}
00073   \}
00074 \};
00075 
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00076}\hyperlink{struct_eigen_1_1internal_1_1_dim_initializer_3_01_sizes_3_4_01_4}{00076} \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_dim_initializer}{DimInitializer}<\hyperlink{struct_eigen_1_1_sizes}{Sizes}<> > \{
00077   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputDims, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{size\_t} Rank> EIGEN\_DEVICE\_FUNC
00078   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} InputDims& input\_dims, \textcolor{keyword}{const} \hyperlink{class_eigen_1_1array}{array<bool, Rank>}&,
00079                   \hyperlink{struct_eigen_1_1_sizes}{Sizes<>}*, \hyperlink{class_eigen_1_1array}{array<Index, Rank>}* reduced\_dims) \{
00080     \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumInputDims = \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<InputDims>::value};
00081     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumInputDims; ++i) \{
00082       (*reduced\_dims)[i] = input\_dims[i];
00083     \}
00084   \}
00085 \};
00086 
00087 
00088 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ReducedDims, \textcolor{keywordtype}{int} NumTensorDims, \textcolor{keywordtype}{int} Layout>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00089}\hyperlink{struct_eigen_1_1internal_1_1are__inner__most__dims}{00089} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1are__inner__most__dims}{are\_inner\_most\_dims} \{
00090   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false};
00091 \};
00092 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ReducedDims, \textcolor{keywordtype}{int} NumTensorDims, \textcolor{keywordtype}{int} Layout>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00093}\hyperlink{struct_eigen_1_1internal_1_1preserve__inner__most__dims}{00093} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1preserve__inner__most__dims}{preserve\_inner\_most\_dims} \{
00094   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false};
00095 \};
00096 
00097 \textcolor{preprocessor}{#if EIGEN\_HAS\_CONSTEXPR && EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00098 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ReducedDims, \textcolor{keywordtype}{int} NumTensorDims>
00099 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1are__inner__most__dims}{are\_inner\_most\_dims}<ReducedDims, NumTensorDims, ColMajor>\{
00100   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} tmp1 = indices\_statically\_known\_to\_increase<ReducedDims>();
00101   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} tmp2 = index\_statically\_eq<ReducedDims>(0, 0);
00102   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} tmp3 = index\_statically\_eq<ReducedDims>(
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size<ReducedDims>::value}-1, array\_size<ReducedDims>::value-1);
00103   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = tmp1 & tmp2 & tmp3;
00104 \};
00105 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ReducedDims, \textcolor{keywordtype}{int} NumTensorDims>
00106 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1are__inner__most__dims}{are\_inner\_most\_dims}<ReducedDims, NumTensorDims, RowMajor>\{
00107   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} tmp1 = indices\_statically\_known\_to\_increase<ReducedDims>();
00108   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} tmp2 = index\_statically\_eq<ReducedDims>(0, NumTensorDims - 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size<ReducedDims>::value});
00109   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} tmp3 = index\_statically\_eq<ReducedDims>(
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size<ReducedDims>::value} - 1, NumTensorDims - 1);
00110   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = tmp1 & tmp2 & tmp3;
00111 
00112 \};
00113 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ReducedDims, \textcolor{keywordtype}{int} NumTensorDims>
00114 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1preserve__inner__most__dims}{preserve\_inner\_most\_dims}<ReducedDims, NumTensorDims, ColMajor>\{
00115   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} tmp1 = indices\_statically\_known\_to\_increase<ReducedDims>();
00116   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} tmp2 = index\_statically\_gt<ReducedDims>(0, 0);
00117   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = tmp1 & tmp2;
00118 
00119 \};
00120 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ReducedDims, \textcolor{keywordtype}{int} NumTensorDims>
00121 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1preserve__inner__most__dims}{preserve\_inner\_most\_dims}<ReducedDims, NumTensorDims, RowMajor>\{
00122   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} tmp1 = indices\_statically\_known\_to\_increase<ReducedDims>();
00123   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} tmp2 = index\_statically\_lt<ReducedDims>(
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{array\_size<ReducedDims>::value} - 1, NumTensorDims - 1);
00124   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = tmp1 & tmp2;
00125 \};
00126 \textcolor{preprocessor}{#endif}
00127 
00128 
00129 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} DimIndex, \textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00130}\hyperlink{struct_eigen_1_1internal_1_1_generic_dim_reducer}{00130} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_generic_dim_reducer}{GenericDimReducer} \{
00131   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} reduce(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, \textcolor{keyword}{typename} Self::Index 
      firstIndex, Op& reducer, \textcolor{keyword}{typename} Self::CoeffReturnType* accum) \{
00132     EIGEN\_STATIC\_ASSERT((DimIndex > 0), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00133     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < \textcolor{keyword}{self}.m\_reducedDims[DimIndex]; ++j) \{
00134       \textcolor{keyword}{const} \textcolor{keyword}{typename} Self::Index input = firstIndex + j * \textcolor{keyword}{self}.m\_reducedStrides[DimIndex];
00135       \hyperlink{struct_eigen_1_1internal_1_1_generic_dim_reducer}{GenericDimReducer<DimIndex-1, Self, Op>::reduce}(\textcolor{keyword}{self}, 
      input, reducer, accum);
00136     \}
00137   \}
00138 \};
00139 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00140}\hyperlink{struct_eigen_1_1internal_1_1_generic_dim_reducer_3_010_00_01_self_00_01_op_01_4}{00140} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_generic_dim_reducer}{GenericDimReducer}<0, Self, Op> \{
00141   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} reduce(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, \textcolor{keyword}{typename} Self::Index 
      firstIndex, Op& reducer, \textcolor{keyword}{typename} Self::CoeffReturnType* accum) \{
00142     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < \textcolor{keyword}{self}.m\_reducedDims[0]; ++j) \{
00143       \textcolor{keyword}{const} \textcolor{keyword}{typename} Self::Index input = firstIndex + j * \textcolor{keyword}{self}.m\_reducedStrides[0];
00144       reducer.reduce(\textcolor{keyword}{self}.m\_impl.coeff(input), accum);
00145     \}
00146   \}
00147 \};
00148 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00149}\hyperlink{struct_eigen_1_1internal_1_1_generic_dim_reducer_3-1_00_01_self_00_01_op_01_4}{00149} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_generic_dim_reducer}{GenericDimReducer}<-1, Self, Op> \{
00150   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} reduce(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, \textcolor{keyword}{typename} Self::Index index, Op
      & reducer, \textcolor{keyword}{typename} Self::CoeffReturnType* accum) \{
00151     reducer.reduce(\textcolor{keyword}{self}.m\_impl.coeff(index), accum);
00152   \}
00153 \};
00154 
00155 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op, \textcolor{keywordtype}{bool} Vectorizable = (Self::InputPacketAccess & Op::PacketAccess)>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00156}\hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer}{00156} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer}{InnerMostDimReducer} \{
00157   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} Self::CoeffReturnType reduce(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, \textcolor{keyword}{
      typename} Self::Index firstIndex, \textcolor{keyword}{typename} Self::Index numValuesToReduce, Op& reducer) \{
00158     \textcolor{keyword}{typename} Self::CoeffReturnType accum = reducer.initialize();
00159     \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} Self::Index j = 0; j < numValuesToReduce; ++j) \{
00160       reducer.reduce(\textcolor{keyword}{self}.m\_impl.coeff(firstIndex + j), &accum);
00161     \}
00162     \textcolor{keywordflow}{return} reducer.finalize(accum);
00163   \}
00164 \};
00165 
00166 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00167}\hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer_3_01_self_00_01_op_00_01true_01_4}{00167} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer}{InnerMostDimReducer}<Self, Op, true> \{
00168   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} Self::CoeffReturnType reduce(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, \textcolor{keyword}{
      typename} Self::Index firstIndex, \textcolor{keyword}{typename} Self::Index numValuesToReduce, Op& reducer) \{
00169     \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<typename Self::PacketReturnType>::size}
      ;
00170     \textcolor{keyword}{const} \textcolor{keyword}{typename} Self::Index VectorizedSize = (numValuesToReduce / packetSize) * packetSize;
00171     \textcolor{keyword}{typename} Self::PacketReturnType p = reducer.template initializePacket<typename Self::PacketReturnType>(
      );
00172     \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} Self::Index j = 0; j < VectorizedSize; j += packetSize) \{
00173       reducer.reducePacket(\textcolor{keyword}{self}.m\_impl.template packet<Unaligned>(firstIndex + j), &p);
00174     \}
00175     \textcolor{keyword}{typename} Self::CoeffReturnType accum = reducer.initialize();
00176     \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} Self::Index j = VectorizedSize; j < numValuesToReduce; ++j) \{
00177       reducer.reduce(\textcolor{keyword}{self}.m\_impl.coeff(firstIndex + j), &accum);
00178     \}
00179     \textcolor{keywordflow}{return} reducer.finalizeBoth(accum, p);
00180   \}
00181 \};
00182 
00183 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} DimIndex, \textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op, \textcolor{keywordtype}{bool} vectorizable = (Self::InputPacketAccess & Op::Pack
      etAccess)>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00184}\hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_preserver}{00184} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_preserver}{InnerMostDimPreserver} \{
00185   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} reduce(\textcolor{keyword}{const} Self&, \textcolor{keyword}{typename} Self::Index, Op&, \textcolor{keyword}{typename}
       Self::PacketReturnType*) \{
00186     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"should never be called"});
00187   \}
00188 \};
00189 
00190 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} DimIndex, \textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00191}\hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_preserver_3_01_dim_index_00_01_self_00_01_op_00_01true_01_4}{00191} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_preserver}{InnerMostDimPreserver}<DimIndex, Self, Op, true> \{
00192   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} reduce(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, \textcolor{keyword}{typename} Self::Index 
      firstIndex, Op& reducer, \textcolor{keyword}{typename} Self::PacketReturnType* accum) \{
00193     EIGEN\_STATIC\_ASSERT((DimIndex > 0), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00194     \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} Self::Index j = 0; j < \textcolor{keyword}{self}.m\_reducedDims[DimIndex]; ++j) \{
00195       \textcolor{keyword}{const} \textcolor{keyword}{typename} Self::Index input = firstIndex + j * \textcolor{keyword}{self}.m\_reducedStrides[DimIndex];
00196       \hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_preserver}{InnerMostDimPreserver<DimIndex-1, Self, Op>::reduce}
      (\textcolor{keyword}{self}, input, reducer, accum);
00197     \}
00198   \}
00199 \};
00200 
00201 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00202}\hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_preserver_3_010_00_01_self_00_01_op_00_01true_01_4}{00202} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_preserver}{InnerMostDimPreserver}<0, Self, Op, true> \{
00203   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} reduce(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, \textcolor{keyword}{typename} Self::Index 
      firstIndex, Op& reducer, \textcolor{keyword}{typename} Self::PacketReturnType* accum) \{
00204     \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} Self::Index j = 0; j < \textcolor{keyword}{self}.m\_reducedDims[0]; ++j) \{
00205       \textcolor{keyword}{const} \textcolor{keyword}{typename} Self::Index input = firstIndex + j * \textcolor{keyword}{self}.m\_reducedStrides[0];
00206       reducer.reducePacket(\textcolor{keyword}{self}.m\_impl.template packet<Unaligned>(input), accum);
00207     \}
00208   \}
00209 \};
00210 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00211}\hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_preserver_3-1_00_01_self_00_01_op_00_01true_01_4}{00211} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_preserver}{InnerMostDimPreserver}<-1, Self, Op, true> \{
00212   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} reduce(\textcolor{keyword}{const} Self&, \textcolor{keyword}{typename} Self::Index, Op&, \textcolor{keyword}{typename}
       Self::PacketReturnType*) \{
00213     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"should never be called"});
00214   \}
00215 \};
00216 
00217 \textcolor{comment}{// Default full reducer}
00218 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} Device, \textcolor{keywordtype}{bool} Vectorizable = (Self::InputPacketAccess & Op::P
      acketAccess)>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00219}\hyperlink{struct_eigen_1_1internal_1_1_full_reducer}{00219} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_full_reducer}{FullReducer} \{
00220   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} HasOptimizedImplementation = \textcolor{keyword}{false};
00221 
00222   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, Op& reducer, \textcolor{keyword}{const} Device&, \textcolor{keyword}{typename} 
      Self::CoeffReturnType* output) \{
00223     \textcolor{keyword}{const} \textcolor{keyword}{typename} Self::Index num\_coeffs = array\_prod(\textcolor{keyword}{self}.m\_impl.dimensions());
00224     *output = \hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer}{InnerMostDimReducer<Self, Op, Vectorizable>::reduce}
      (\textcolor{keyword}{self}, 0, num\_coeffs, reducer);
00225   \}
00226 \};
00227 
00228 
00229 \textcolor{preprocessor}{#ifdef EIGEN\_USE\_THREADS}
00230 \textcolor{comment}{// Multithreaded full reducers}
00231 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op,
00232           \textcolor{keywordtype}{bool} Vectorizable = (Self::InputPacketAccess & Op::PacketAccess)>
00233 \textcolor{keyword}{struct} FullReducerShard \{
00234   \textcolor{keyword}{static} EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, \textcolor{keyword}{typename} Self::Index firstIndex,
00235                   \textcolor{keyword}{typename} Self::Index numValuesToReduce, Op& reducer,
00236                   \textcolor{keyword}{typename} Self::CoeffReturnType* output) \{
00237     *output = \hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer}{InnerMostDimReducer<Self, Op, Vectorizable>::reduce}
      (
00238         \textcolor{keyword}{self}, firstIndex, numValuesToReduce, reducer);
00239   \}
00240 \};
00241 
00242 \textcolor{comment}{// Multithreaded full reducer}
00243 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op, \textcolor{keywordtype}{bool} Vectorizable>
00244 \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_full_reducer}{FullReducer<Self, Op, ThreadPoolDevice, Vectorizable>}
       \{
00245   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} HasOptimizedImplementation = !Op::IsStateful;
00246   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize =
00247       \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{unpacket\_traits<typename Self::PacketReturnType>::size}
      ;
00248 
00249   \textcolor{comment}{// launch one reducer per thread and accumulate the result.}
00250   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Self& \textcolor{keyword}{self}, Op& reducer, \textcolor{keyword}{const} ThreadPoolDevice& device,
00251                   \textcolor{keyword}{typename} Self::CoeffReturnType* output) \{
00252     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Self::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00253     \textcolor{keyword}{const} Index num\_coeffs = array\_prod(\textcolor{keyword}{self}.m\_impl.dimensions());
00254     \textcolor{keywordflow}{if} (num\_coeffs == 0) \{
00255       *output = reducer.finalize(reducer.initialize());
00256       \textcolor{keywordflow}{return};
00257     \}
00258     \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost} cost =
00259         \textcolor{keyword}{self}.m\_impl.costPerCoeff(Vectorizable) +
00260         \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, \hyperlink{struct_eigen_1_1internal_1_1functor__traits}{internal::functor\_traits<Op>::Cost}
      , Vectorizable,
00261                      PacketSize);
00262     \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_threads = \hyperlink{class_eigen_1_1_tensor_cost_model}{TensorCostModel<ThreadPoolDevice>::numThreads}
      (
00263         num\_coeffs, cost, device.numThreads());
00264     \textcolor{keywordflow}{if} (num\_threads == 1) \{
00265       *output =
00266           \hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer}{InnerMostDimReducer<Self, Op, Vectorizable>::reduce}
      (\textcolor{keyword}{self}, 0, num\_coeffs, reducer);
00267       \textcolor{keywordflow}{return};
00268     \}
00269     \textcolor{keyword}{const} Index blocksize =
00270         std::floor<Index>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(num\_coeffs) / num\_threads);
00271     \textcolor{keyword}{const} Index numblocks = blocksize > 0 ? num\_coeffs / blocksize : 0;
00272     eigen\_assert(num\_coeffs >= numblocks * blocksize);
00273 
00274     Barrier barrier(internal::convert\_index<unsigned int>(numblocks));
00275     \hyperlink{class_eigen_1_1_max_size_vector}{MaxSizeVector<typename Self::CoeffReturnType>} shards(
      numblocks, reducer.initialize());
00276     \textcolor{keywordflow}{for} (Index i = 0; i < numblocks; ++i) \{
00277       device.enqueue\_with\_barrier(&barrier, &FullReducerShard<Self, Op, Vectorizable>::run,
00278                                   \textcolor{keyword}{self}, i * blocksize, blocksize, reducer,
00279                                   &shards[i]);
00280     \}
00281     \textcolor{keyword}{typename} Self::CoeffReturnType finalShard;
00282     \textcolor{keywordflow}{if} (numblocks * blocksize < num\_coeffs) \{
00283       finalShard = \hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer}{InnerMostDimReducer<Self, Op, Vectorizable>::reduce}
      (
00284           \textcolor{keyword}{self}, numblocks * blocksize, num\_coeffs - numblocks * blocksize,
00285           reducer);
00286     \} \textcolor{keywordflow}{else} \{
00287       finalShard = reducer.initialize();
00288     \}
00289     barrier.Wait();
00290 
00291     \textcolor{keywordflow}{for} (Index i = 0; i < numblocks; ++i) \{
00292       reducer.reduce(shards[i], &finalShard);
00293     \}
00294     *output = reducer.finalize(finalShard);
00295   \}
00296 \};
00297 
00298 \textcolor{preprocessor}{#endif}
00299 
00300 
00301 \textcolor{comment}{// Default inner reducer}
00302 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00303}\hyperlink{struct_eigen_1_1internal_1_1_inner_reducer}{00303} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_inner_reducer}{InnerReducer} \{
00304   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} HasOptimizedImplementation = \textcolor{keyword}{false};
00305 
00306   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} \textcolor{keywordtype}{bool} run(\textcolor{keyword}{const} Self&, Op&, \textcolor{keyword}{const} Device&, \textcolor{keyword}{typename} Self::CoeffReturnType*, \textcolor{keyword}{
      typename} Self::Index, \textcolor{keyword}{typename} Self::Index) \{
00307     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Not implemented"});
00308     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00309   \}
00310 \};
00311 
00312 \textcolor{comment}{// Default outer reducer}
00313 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Self, \textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00314}\hyperlink{struct_eigen_1_1internal_1_1_outer_reducer}{00314} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_outer_reducer}{OuterReducer} \{
00315   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} HasOptimizedImplementation = \textcolor{keyword}{false};
00316 
00317   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} \textcolor{keywordtype}{bool} run(\textcolor{keyword}{const} Self&, Op&, \textcolor{keyword}{const} Device&, \textcolor{keyword}{typename} Self::CoeffReturnType*, \textcolor{keyword}{
      typename} Self::Index, \textcolor{keyword}{typename} Self::Index) \{
00318     eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"Not implemented"});
00319     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00320   \}
00321 \};
00322 
00323 
00324 \textcolor{preprocessor}{#if defined(EIGEN\_USE\_GPU) && defined(\_\_CUDACC\_\_)}
00325 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} B, \textcolor{keywordtype}{int} N, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} I>
00326 \_\_global\_\_ \textcolor{keywordtype}{void} FullReductionKernel(R, \textcolor{keyword}{const} S, I, \textcolor{keyword}{typename} S::CoeffReturnType*, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}*);
00327 
00328 
00329 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_CUDA\_FP16}
00330 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} I>
00331 \_\_global\_\_ \textcolor{keywordtype}{void} ReductionInitFullReduxKernelHalfFloat(R, \textcolor{keyword}{const} S, I, half2*);
00332 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} B, \textcolor{keywordtype}{int} N, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} I>
00333 \_\_global\_\_ \textcolor{keywordtype}{void} FullReductionKernelHalfFloat(R, \textcolor{keyword}{const} S, I, \hyperlink{struct_eigen_1_1half}{half}*, half2*);
00334 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} NPT, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} I>
00335 \_\_global\_\_ \textcolor{keywordtype}{void} InnerReductionKernelHalfFloat(R, \textcolor{keyword}{const} S, I, I, \hyperlink{struct_eigen_1_1half}{half}*);
00336 
00337 \textcolor{preprocessor}{#endif}
00338 
00339 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} NPT, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} I>
00340 \_\_global\_\_ \textcolor{keywordtype}{void} InnerReductionKernel(R, \textcolor{keyword}{const} S, I, I, \textcolor{keyword}{typename} S::CoeffReturnType*);
00341 
00342 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} NPT, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} I>
00343 \_\_global\_\_ \textcolor{keywordtype}{void} OuterReductionKernel(R, \textcolor{keyword}{const} S, I, I, \textcolor{keyword}{typename} S::CoeffReturnType*);
00344 \textcolor{preprocessor}{#endif}
00345 
00346 \}  \textcolor{comment}{// end namespace internal}
00347 
00348 
00349 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} Dims, \textcolor{keyword}{typename} XprType,  \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_>
00350 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_reduction_op}{TensorReductionOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorReductionOp<Op, Dims, XprType,
       MakePointer\_>, ReadOnlyAccessors> \{
00351   \textcolor{keyword}{public}:
00352     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorReductionOp>::Scalar}
       Scalar;
00353     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00354     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___sparse_core___module}{internal::remove\_const<typename XprType::CoeffReturnType>::type}
       CoeffReturnType;
00355     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorReductionOp>::type}
       Nested;
00356     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorReductionOp>::StorageKind}
       StorageKind;
00357     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorReductionOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00358 
00359     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00360     \hyperlink{class_eigen_1_1_tensor_reduction_op}{TensorReductionOp}(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} Dims& dims) : m\_expr(expr), m\_dims(dims)
00361     \{ \}
00362     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00363     TensorReductionOp(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} Dims& dims, \textcolor{keyword}{const} Op& reducer) : m\_expr(expr), m\_dims(dims
      ), m\_reducer(reducer)
00364     \{ \}
00365 
00366     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00367     \textcolor{keyword}{const} XprType& expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_expr; \}
00368     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00369     \textcolor{keyword}{const} Dims& dims()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dims; \}
00370     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00371     \textcolor{keyword}{const} Op& reducer()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_reducer; \}
00372 
00373   \textcolor{keyword}{protected}:
00374     \textcolor{keyword}{typename} XprType::Nested m\_expr;
00375     \textcolor{keyword}{const} Dims m\_dims;
00376     \textcolor{keyword}{const} Op m\_reducer;
00377 \};
00378 
00379 
00380 \textcolor{comment}{// Eval as rvalue}
00381 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Op, \textcolor{keyword}{typename} Dims, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_, \textcolor{keyword}{typename} Device
      >
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00382}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_arg_4fdf2ec1445de4704eb590bc98040dc6}{00382} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_reduction_op}{TensorReductionOp}<Op, Dims, ArgType, 
      MakePointer\_>, Device>
00383 \{
00384   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_reduction_op}{TensorReductionOp<Op, Dims, ArgType, MakePointer\_>}
       \hyperlink{class_eigen_1_1_tensor_reduction_op}{XprType};
00385   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00386   \textcolor{keyword}{typedef} ArgType ChildType;
00387   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Dimensions}
       InputDimensions;
00388   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumInputDims = \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<InputDimensions>::value}
      ;
00389   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumReducedDims = \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<Dims>::value};
00390   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumOutputDims = NumInputDims - NumReducedDims;
00391   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{internal::conditional<NumOutputDims==0, Sizes<>}
      , \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumOutputDims>} >::type \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Dimensions};
00392   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00393   \textcolor{keyword}{typedef} 
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<const TensorReductionOp<Op, Dims, ArgType, MakePointer\_>}
      , Device> \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_arg_4fdf2ec1445de4704eb590bc98040dc6}{Self};
00394   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} InputPacketAccess = 
      \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::PacketAccess};
00395   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{group___sparse_core___module}{internal::remove\_const<typename XprType::CoeffReturnType>::type}
       \hyperlink{group___sparse_core___module}{CoeffReturnType};
00396   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00397   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size};
00398 
00399   \textcolor{keyword}{enum} \{
00400     IsAligned = \textcolor{keyword}{false},
00401     PacketAccess = Self::InputPacketAccess && Op::PacketAccess,
00402     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Layout},
00403     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00404     RawAccess = \textcolor{keyword}{false}
00405   \};
00406 
00407   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} ReducingInnerMostDims = 
      \hyperlink{struct_eigen_1_1internal_1_1are__inner__most__dims}{internal::are\_inner\_most\_dims<Dims, NumInputDims, Layout>::value}
      ;
00408   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} PreservingInnerMostDims = 
      \hyperlink{struct_eigen_1_1internal_1_1preserve__inner__most__dims}{internal::preserve\_inner\_most\_dims<Dims, NumInputDims, Layout>::value}
      ;
00409   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} RunningFullReduction = (NumOutputDims==0);
00410 
00411   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00412       : m\_impl(op.expression(), device), m\_reducer(op.reducer()), m\_result(NULL), m\_device(device), 
      m\_xpr\_dims(op.dims())
00413   \{
00414     EIGEN\_STATIC\_ASSERT((NumInputDims >= NumReducedDims), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00415     EIGEN\_STATIC\_ASSERT((!ReducingInnerMostDims | !PreservingInnerMostDims | (NumReducedDims == 
      NumInputDims)),
00416                         YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00417 
00418     \textcolor{comment}{// Build the bitmap indicating if an input dimension is reduced or not.}
00419     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumInputDims; ++i) \{
00420       m\_reduced[i] = \textcolor{keyword}{false};
00421     \}
00422     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumReducedDims; ++i) \{
00423       eigen\_assert(op.dims()[i] >= 0);
00424       eigen\_assert(op.dims()[i] < NumInputDims);
00425       m\_reduced[op.dims()[i]] = \textcolor{keyword}{true};
00426     \}
00427 
00428     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Dimensions}
      & input\_dims = m\_impl.dimensions();
00429     \hyperlink{struct_eigen_1_1internal_1_1_dim_initializer}{internal::DimInitializer<Dimensions>::run}(input\_dims, 
      m\_reduced, &m\_dimensions, &m\_reducedDims);
00430 
00431     \textcolor{comment}{// Precompute output strides.}
00432     \textcolor{keywordflow}{if} (NumOutputDims > 0) \{
00433       \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00434         m\_outputStrides[0] = 1;
00435         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumOutputDims; ++i) \{
00436           m\_outputStrides[i] = m\_outputStrides[i - 1] * m\_dimensions[i - 1];
00437         \}
00438       \} \textcolor{keywordflow}{else} \{
00439         m\_outputStrides.back() = 1;
00440         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumOutputDims - 2; i >= 0; --i) \{
00441           m\_outputStrides[i] = m\_outputStrides[i + 1] * m\_dimensions[i + 1];
00442         \}
00443       \}
00444     \}
00445 
00446     \textcolor{comment}{// Precompute input strides.}
00447     \textcolor{keywordflow}{if} (NumInputDims > 0) \{
00448       \hyperlink{class_eigen_1_1array}{array<Index, NumInputDims>} input\_strides;
00449       \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00450         input\_strides[0] = 1;
00451         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumInputDims; ++i) \{
00452           input\_strides[i] = input\_strides[i-1] * input\_dims[i-1];
00453         \}
00454       \} \textcolor{keywordflow}{else} \{
00455         input\_strides.back() = 1;
00456         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumInputDims - 2; i >= 0; --i) \{
00457           input\_strides[i] = input\_strides[i + 1] * input\_dims[i + 1];
00458         \}
00459       \}
00460 
00461       \textcolor{keywordtype}{int} outputIndex = 0;
00462       \textcolor{keywordtype}{int} reduceIndex = 0;
00463       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumInputDims; ++i) \{
00464         \textcolor{keywordflow}{if} (m\_reduced[i]) \{
00465           m\_reducedStrides[reduceIndex] = input\_strides[i];
00466           ++reduceIndex;
00467         \} \textcolor{keywordflow}{else} \{
00468           m\_preservedStrides[outputIndex] = input\_strides[i];
00469           ++outputIndex;
00470         \}
00471       \}
00472     \}
00473 
00474     \textcolor{comment}{// Special case for full reductions}
00475     \textcolor{keywordflow}{if} (NumOutputDims == 0) \{
00476       m\_preservedStrides[0] = internal::array\_prod(input\_dims);
00477     \}
00478   \}
00479 
00480   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00481 
00482   EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(\textcolor{keyword}{typename} 
      MakePointer\_<CoeffReturnType>::Type data) \{
00483     m\_impl.evalSubExprsIfNeeded(NULL);
00484 
00485     \textcolor{comment}{// Use the FullReducer if possible.}
00486     \textcolor{keywordflow}{if} ((RunningFullReduction && RunningOnSycl) ||(RunningFullReduction &&
00487         \hyperlink{struct_eigen_1_1internal_1_1_full_reducer}{internal::FullReducer<Self, Op, Device>::HasOptimizedImplementation}
       &&
00488         ((RunningOnGPU && (m\_device.majorDeviceVersion() >= 3)) ||
00489          !RunningOnGPU))) \{
00490       \textcolor{keywordtype}{bool} need\_assign = \textcolor{keyword}{false};
00491       \textcolor{keywordflow}{if} (!data) \{
00492         m\_result = \textcolor{keyword}{static\_cast<}CoeffReturnType*\textcolor{keyword}{>}(m\_device.allocate(\textcolor{keyword}{sizeof}(CoeffReturnType)));
00493         data = m\_result;
00494         need\_assign = \textcolor{keyword}{true};
00495       \}
00496       Op reducer(m\_reducer);
00497       \hyperlink{struct_eigen_1_1internal_1_1_full_reducer}{internal::FullReducer<Self, Op, Device>::run}(*\textcolor{keyword}{this}, 
      reducer, m\_device, data);
00498       \textcolor{keywordflow}{return} need\_assign;
00499     \}
00500     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(RunningOnSycl)\{
00501       \textcolor{keyword}{const} Index num\_values\_to\_reduce = internal::array\_prod(m\_reducedDims);
00502       \textcolor{keyword}{const} Index num\_coeffs\_to\_preserve = internal::array\_prod(m\_dimensions);
00503       \textcolor{keywordflow}{if} (!data) \{
00504         data = \textcolor{keyword}{static\_cast<}CoeffReturnType*\textcolor{keyword}{>}(m\_device.allocate(\textcolor{keyword}{sizeof}(CoeffReturnType) * 
      num\_coeffs\_to\_preserve));
00505         m\_result = data;
00506       \}
00507       Op reducer(m\_reducer);
00508       \hyperlink{struct_eigen_1_1internal_1_1_inner_reducer}{internal::InnerReducer<Self, Op, Device>::run}(*\textcolor{keyword}{this}, 
      reducer, m\_device, data, num\_values\_to\_reduce, num\_coeffs\_to\_preserve);
00509       \textcolor{keywordflow}{return} (m\_result != NULL);
00510     \}
00511 
00512     \textcolor{comment}{// Attempt to use an optimized reduction.}
00513     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (RunningOnGPU && (m\_device.majorDeviceVersion() >= 3)) \{
00514       \textcolor{keywordtype}{bool} reducing\_inner\_dims = \textcolor{keyword}{true};
00515       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumReducedDims; ++i) \{
00516         \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00517           reducing\_inner\_dims &= m\_reduced[i];
00518         \} \textcolor{keywordflow}{else} \{
00519           reducing\_inner\_dims &= m\_reduced[NumInputDims - 1 - i];
00520         \}
00521       \}
00522       \textcolor{keywordflow}{if} (\hyperlink{struct_eigen_1_1internal_1_1_inner_reducer}{internal::InnerReducer<Self, Op, Device>::HasOptimizedImplementation}
       &&
00523           (reducing\_inner\_dims || ReducingInnerMostDims)) \{
00524         \textcolor{keyword}{const} Index num\_values\_to\_reduce = internal::array\_prod(m\_reducedDims);
00525         \textcolor{keyword}{const} Index num\_coeffs\_to\_preserve = internal::array\_prod(m\_dimensions);
00526         \textcolor{keywordflow}{if} (!data) \{
00527           \textcolor{keywordflow}{if} (num\_coeffs\_to\_preserve < 1024 && num\_values\_to\_reduce > num\_coeffs\_to\_preserve && 
      num\_values\_to\_reduce > 128) \{
00528             data = \textcolor{keyword}{static\_cast<}CoeffReturnType*\textcolor{keyword}{>}(m\_device.allocate(\textcolor{keyword}{sizeof}(CoeffReturnType) * 
      num\_coeffs\_to\_preserve));
00529             m\_result = data;
00530           \}
00531           \textcolor{keywordflow}{else} \{
00532             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00533           \}
00534         \}
00535         Op reducer(m\_reducer);
00536         \textcolor{keywordflow}{if} (\hyperlink{struct_eigen_1_1internal_1_1_inner_reducer}{internal::InnerReducer<Self, Op, Device>::run}(*\textcolor{keyword}{
      this}, reducer, m\_device, data, num\_values\_to\_reduce, num\_coeffs\_to\_preserve)) \{
00537           \textcolor{keywordflow}{if} (m\_result) \{
00538             m\_device.deallocate(m\_result);
00539             m\_result = NULL;
00540           \}
00541           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00542         \} \textcolor{keywordflow}{else} \{
00543           \textcolor{keywordflow}{return} (m\_result != NULL);
00544         \}
00545       \}
00546 
00547       \textcolor{keywordtype}{bool} preserving\_inner\_dims = \textcolor{keyword}{true};
00548       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumReducedDims; ++i) \{
00549         \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00550           preserving\_inner\_dims &= m\_reduced[NumInputDims - 1 - i];
00551         \} \textcolor{keywordflow}{else} \{
00552           preserving\_inner\_dims &= m\_reduced[i];
00553         \}
00554       \}
00555       \textcolor{keywordflow}{if} (\hyperlink{struct_eigen_1_1internal_1_1_outer_reducer}{internal::OuterReducer<Self, Op, Device>::HasOptimizedImplementation}
       &&
00556           preserving\_inner\_dims) \{
00557         \textcolor{keyword}{const} Index num\_values\_to\_reduce = internal::array\_prod(m\_reducedDims);
00558         \textcolor{keyword}{const} Index num\_coeffs\_to\_preserve = internal::array\_prod(m\_dimensions);
00559         \textcolor{keywordflow}{if} (!data) \{
00560           \textcolor{keywordflow}{if} (num\_coeffs\_to\_preserve < 1024 && num\_values\_to\_reduce > num\_coeffs\_to\_preserve && 
      num\_values\_to\_reduce > 32) \{
00561             data = \textcolor{keyword}{static\_cast<}CoeffReturnType*\textcolor{keyword}{>}(m\_device.allocate(\textcolor{keyword}{sizeof}(CoeffReturnType) * 
      num\_coeffs\_to\_preserve));
00562             m\_result = data;
00563           \}
00564           \textcolor{keywordflow}{else} \{
00565             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00566           \}
00567         \}
00568         Op reducer(m\_reducer);
00569         \textcolor{keywordflow}{if} (\hyperlink{struct_eigen_1_1internal_1_1_outer_reducer}{internal::OuterReducer<Self, Op, Device>::run}(*\textcolor{keyword}{
      this}, reducer, m\_device, data, num\_values\_to\_reduce, num\_coeffs\_to\_preserve)) \{
00570           \textcolor{keywordflow}{if} (m\_result) \{
00571             m\_device.deallocate(m\_result);
00572             m\_result = NULL;
00573           \}
00574           \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00575         \} \textcolor{keywordflow}{else} \{
00576           \textcolor{keywordflow}{return} (m\_result != NULL);
00577         \}
00578       \}
00579     \}
00580     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00581   \}
00582 
00583   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00584     m\_impl.cleanup();
00585     \textcolor{keywordflow}{if} (m\_result) \{
00586       m\_device.deallocate(m\_result);
00587       m\_result = NULL;
00588     \}
00589   \}
00590 
00591   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00592 \textcolor{keyword}{  }\{
00593     \textcolor{keywordflow}{if} ((RunningOnSycl || RunningFullReduction || RunningOnGPU) && m\_result) \{
00594       \textcolor{keywordflow}{return} *(m\_result + index);
00595     \}
00596     Op reducer(m\_reducer);
00597     \textcolor{keywordflow}{if} (ReducingInnerMostDims || RunningFullReduction) \{
00598       \textcolor{keyword}{const} Index num\_values\_to\_reduce =
00599         (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) ? m\_preservedStrides[0] : 
      m\_preservedStrides[NumPreservedStrides - 1];
00600       \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer}{internal::InnerMostDimReducer<Self, Op>::reduce}
      (*\textcolor{keyword}{this}, firstInput(index),
00601                                                              num\_values\_to\_reduce, reducer);
00602     \} \textcolor{keywordflow}{else} \{
00603       \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Self::CoeffReturnType} accum = reducer.initialize();
00604       \hyperlink{struct_eigen_1_1internal_1_1_generic_dim_reducer}{internal::GenericDimReducer<NumReducedDims-1, Self, Op>::reduce}
      (*\textcolor{keyword}{this}, firstInput(index), reducer, &accum);
00605       \textcolor{keywordflow}{return} reducer.finalize(accum);
00606     \}
00607   \}
00608 
00609   \textcolor{comment}{// TODO(bsteiner): provide a more efficient implementation.}
00610   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00611   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00612 \textcolor{keyword}{  }\{
00613     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00614     eigen\_assert(index + PacketSize - 1 < \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(internal::array\_prod(dimensions())));
00615 
00616     \textcolor{keywordflow}{if} (RunningOnGPU && m\_result) \{
00617       \textcolor{keywordflow}{return} internal::pload<PacketReturnType>(m\_result + index);
00618     \}
00619 
00620     EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<CoeffReturnType>::type}
       values[PacketSize];
00621     \textcolor{keywordflow}{if} (ReducingInnerMostDims) \{
00622       \textcolor{keyword}{const} Index num\_values\_to\_reduce =
00623         (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) ? m\_preservedStrides[0] : 
      m\_preservedStrides[NumPreservedStrides - 1];
00624       \textcolor{keyword}{const} Index firstIndex = firstInput(index);
00625       \textcolor{keywordflow}{for} (Index i = 0; i < PacketSize; ++i) \{
00626         Op reducer(m\_reducer);
00627         values[i] = \hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer}{internal::InnerMostDimReducer<Self, Op>::reduce}
      (*\textcolor{keyword}{this}, firstIndex + i * num\_values\_to\_reduce,
00628                                                                     num\_values\_to\_reduce, reducer);
00629       \}
00630     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (PreservingInnerMostDims) \{
00631       \textcolor{keyword}{const} Index firstIndex = firstInput(index);
00632       \textcolor{keyword}{const} \textcolor{keywordtype}{int} innermost\_dim = (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) ? 0 : NumOutputDims - 1;
00633       \textcolor{comment}{// TBD: extend this the the n innermost dimensions that we preserve.}
00634       \textcolor{keywordflow}{if} (((firstIndex % m\_dimensions[innermost\_dim]) + PacketSize - 1) < m\_dimensions[innermost\_dim]) \{
00635         Op reducer(m\_reducer);
00636         \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Self::PacketReturnType} accum = reducer.template 
      initializePacket<typename Self::PacketReturnType>();
00637         \hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_preserver}{internal::InnerMostDimPreserver<NumReducedDims-1, Self, Op>::reduce}
      (*\textcolor{keyword}{this}, firstIndex, reducer, &accum);
00638         \textcolor{keywordflow}{return} reducer.finalizePacket(accum);
00639       \} \textcolor{keywordflow}{else} \{
00640         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00641           values[i] = coeff(index + i);
00642         \}
00643       \}
00644     \} \textcolor{keywordflow}{else} \{
00645       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00646         values[i] = coeff(index + i);
00647       \}
00648     \}
00649     PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00650     \textcolor{keywordflow}{return} rslt;
00651   \}
00652 
00653   \textcolor{comment}{// Must be called after evalSubExprsIfNeeded().}
00654   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost} costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00655     \textcolor{keywordflow}{if} (RunningFullReduction && m\_result) \{
00656       \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(\textcolor{keyword}{sizeof}(CoeffReturnType), 0, 0, vectorized, PacketSize);
00657     \} \textcolor{keywordflow}{else} \{
00658       \textcolor{keyword}{const} Index num\_values\_to\_reduce = internal::array\_prod(m\_reducedDims);
00659       \textcolor{keyword}{const} \textcolor{keywordtype}{double} compute\_cost = num\_values\_to\_reduce * 
      \hyperlink{struct_eigen_1_1internal_1_1functor__traits}{internal::functor\_traits<Op>::Cost};
00660       \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) * num\_values\_to\_reduce +
00661           \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, compute\_cost, vectorized, PacketSize);
00662     \}
00663   \}
00664 
00665   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{typename} MakePointer\_<Scalar>::Type data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_result; \}
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00667}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_arg_4fdf2ec1445de4704eb590bc98040dc6_a022a83b1c7a0ae214bb767317a5f11f3}{00667}   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>}& \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_arg_4fdf2ec1445de4704eb590bc98040dc6_a022a83b1c7a0ae214bb767317a5f11f3}{impl}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_impl;
       \}
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00669}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_arg_4fdf2ec1445de4704eb590bc98040dc6_a2bada0128bde434694b50ebdce17366c}{00669}   \textcolor{keyword}{const} Device& \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_arg_4fdf2ec1445de4704eb590bc98040dc6_a2bada0128bde434694b50ebdce17366c}{device}()\textcolor{keyword}{ const}\{\textcolor{keywordflow}{return} m\_device;\}
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_reduction_8h_source_l00671}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_arg_4fdf2ec1445de4704eb590bc98040dc6_af792d6b76a129fcd1b070d1d893299d3}{00671}   \textcolor{keyword}{const} Dims& \hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_arg_4fdf2ec1445de4704eb590bc98040dc6_af792d6b76a129fcd1b070d1d893299d3}{xprDims}()\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} m\_xpr\_dims;\}
00672 
00673 
00674   \textcolor{keyword}{private}:
00675   \textcolor{keyword}{template} <\textcolor{keywordtype}{int}, \textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{friend} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_generic_dim_reducer}{internal::GenericDimReducer};
00676   \textcolor{keyword}{template} <\textcolor{keyword}{typename}, \textcolor{keyword}{typename}, \textcolor{keywordtype}{bool}> \textcolor{keyword}{friend} \textcolor{keyword}{struct }
      \hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_reducer}{internal::InnerMostDimReducer};
00677   \textcolor{keyword}{template} <\textcolor{keywordtype}{int}, \textcolor{keyword}{typename}, \textcolor{keyword}{typename}, \textcolor{keywordtype}{bool}> \textcolor{keyword}{friend} \textcolor{keyword}{struct }
      \hyperlink{struct_eigen_1_1internal_1_1_inner_most_dim_preserver}{internal::InnerMostDimPreserver};
00678   \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename} O, \textcolor{keyword}{typename} D, \textcolor{keywordtype}{bool} V> \textcolor{keyword}{friend} \textcolor{keyword}{struct }
      \hyperlink{struct_eigen_1_1internal_1_1_full_reducer}{internal::FullReducer};
00679 \textcolor{preprocessor}{#ifdef EIGEN\_USE\_THREADS}
00680   \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename} O, \textcolor{keywordtype}{bool} V> \textcolor{keyword}{friend} \textcolor{keyword}{struct }internal::FullReducerShard;
00681 \textcolor{preprocessor}{#endif}
00682 \textcolor{preprocessor}{#if defined(EIGEN\_USE\_GPU) && defined(\_\_CUDACC\_\_)}
00683   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} B, \textcolor{keywordtype}{int} N, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} I> \textcolor{keyword}{friend} \textcolor{keywordtype}{void} internal::FullReductionKernel(R, \textcolor{keyword}{
      const} S, I, \textcolor{keyword}{typename} S::CoeffReturnType*, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}*);
00684 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_CUDA\_FP16}
00685   \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} I> \textcolor{keyword}{friend} \textcolor{keywordtype}{void} internal::ReductionInitFullReduxKernelHalfFloat
      (R, \textcolor{keyword}{const} S, I, half2*);
00686   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} B, \textcolor{keywordtype}{int} N, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} I> \textcolor{keyword}{friend} \textcolor{keywordtype}{void} 
      internal::FullReductionKernelHalfFloat(R, \textcolor{keyword}{const} S, I, \hyperlink{struct_eigen_1_1half}{half}*, half2*);
00687   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} NPT, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} I> \textcolor{keyword}{friend} \textcolor{keywordtype}{void} 
      internal::InnerReductionKernelHalfFloat(R, \textcolor{keyword}{const} S, I, I, \hyperlink{struct_eigen_1_1half}{half}*);
00688 \textcolor{preprocessor}{#endif}
00689   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} NPT, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} I> \textcolor{keyword}{friend} \textcolor{keywordtype}{void} internal::InnerReductionKernel(R, \textcolor{keyword}{
      const} S, I, I, \textcolor{keyword}{typename} S::CoeffReturnType*);
00690 
00691   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} NPT, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} I> \textcolor{keyword}{friend} \textcolor{keywordtype}{void} internal::OuterReductionKernel(R, \textcolor{keyword}{
      const} S, I, I, \textcolor{keyword}{typename} S::CoeffReturnType*);
00692 \textcolor{preprocessor}{#endif}
00693 
00694   \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename} O, \textcolor{keyword}{typename} D> \textcolor{keyword}{friend} \textcolor{keyword}{struct }
      \hyperlink{struct_eigen_1_1internal_1_1_inner_reducer}{internal::InnerReducer};
00695 
00696   \textcolor{comment}{// Returns the Index in the input tensor of the first value that needs to be}
00697   \textcolor{comment}{// used to compute the reduction at output index "index".}
00698   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index firstInput(Index index)\textcolor{keyword}{ const }\{
00699     \textcolor{keywordflow}{if} (ReducingInnerMostDims) \{
00700       \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00701         \textcolor{keywordflow}{return} index * m\_preservedStrides[0];
00702       \} \textcolor{keywordflow}{else} \{
00703         \textcolor{keywordflow}{return} index * m\_preservedStrides[NumPreservedStrides - 1];
00704       \}
00705     \}
00706     \textcolor{comment}{// TBD: optimize the case where we preserve the innermost dimensions.}
00707     Index startInput = 0;
00708     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00709       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumOutputDims - 1; i > 0; --i) \{
00710         \textcolor{comment}{// This is index\_i in the output tensor.}
00711         \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00712         startInput += idx * m\_preservedStrides[i];
00713         index -= idx * m\_outputStrides[i];
00714       \}
00715       \textcolor{keywordflow}{if} (PreservingInnerMostDims) \{
00716         eigen\_assert(m\_preservedStrides[0] == 1);
00717         startInput += index;
00718       \} \textcolor{keywordflow}{else} \{
00719         startInput += index * m\_preservedStrides[0];
00720       \}
00721     \} \textcolor{keywordflow}{else} \{
00722       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumOutputDims - 1; ++i) \{
00723         \textcolor{comment}{// This is index\_i in the output tensor.}
00724         \textcolor{keyword}{const} Index idx = index / m\_outputStrides[i];
00725         startInput += idx * m\_preservedStrides[i];
00726         index -= idx * m\_outputStrides[i];
00727       \}
00728       \textcolor{keywordflow}{if} (PreservingInnerMostDims) \{
00729         eigen\_assert(m\_preservedStrides[NumPreservedStrides - 1] == 1);
00730         startInput += index;
00731       \} \textcolor{keywordflow}{else} \{
00732         startInput += index * m\_preservedStrides[NumPreservedStrides - 1];
00733       \}
00734     \}
00735     \textcolor{keywordflow}{return} startInput;
00736   \}
00737 
00738   \textcolor{comment}{// Bitmap indicating if an input dimension is reduced or not.}
00739   \hyperlink{class_eigen_1_1array}{array<bool, NumInputDims>} m\_reduced;
00740   \textcolor{comment}{// Dimensions of the output of the operation.}
00741   Dimensions m\_dimensions;
00742   \textcolor{comment}{// Precomputed strides for the output tensor.}
00743   \hyperlink{class_eigen_1_1array}{array<Index, NumOutputDims>} m\_outputStrides;
00744   \textcolor{comment}{// Subset of strides of the input tensor for the non-reduced dimensions.}
00745   \textcolor{comment}{// Indexed by output dimensions.}
00746   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumPreservedStrides = \hyperlink{struct_eigen_1_1max__n__1}{max\_n\_1<NumOutputDims>::size};
00747   \hyperlink{class_eigen_1_1array}{array<Index, NumPreservedStrides>} m\_preservedStrides;
00748 
00749   \textcolor{comment}{// Subset of strides of the input tensor for the reduced dimensions.}
00750   \textcolor{comment}{// Indexed by reduced dimensions.}
00751   \hyperlink{class_eigen_1_1array}{array<Index, NumReducedDims>} m\_reducedStrides;
00752   \textcolor{comment}{// Size of the input dimensions that are reduced.}
00753   \textcolor{comment}{// Indexed by reduced dimensions.}
00754   \hyperlink{class_eigen_1_1array}{array<Index, NumReducedDims>} m\_reducedDims;
00755 
00756   \textcolor{comment}{// Evaluator for the input expression.}
00757   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} m\_impl;
00758 
00759   \textcolor{comment}{// Operation to apply for computing the reduction.}
00760   Op m\_reducer;
00761 
00762   \textcolor{comment}{// For full reductions}
00763 \textcolor{preprocessor}{#if defined(EIGEN\_USE\_GPU) && defined(\_\_CUDACC\_\_)}
00764   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} RunningOnGPU = 
      \hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Device, Eigen::GpuDevice>::value};
00765   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} RunningOnSycl = \textcolor{keyword}{false};
00766 \textcolor{preprocessor}{#elif defined(EIGEN\_USE\_SYCL)}
00767 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} RunningOnSycl = 
      \hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<typename internal::remove\_all<Device>::type}
      , Eigen::SyclDevice>::value;
00768 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} RunningOnGPU = \textcolor{keyword}{false};
00769 \textcolor{preprocessor}{#else}
00770   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} RunningOnGPU = \textcolor{keyword}{false};
00771   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} RunningOnSycl = \textcolor{keyword}{false};
00772 \textcolor{preprocessor}{#endif}
00773   \textcolor{keyword}{typename} MakePointer\_<CoeffReturnType>::Type m\_result;
00774 
00775   \textcolor{keyword}{const} Device& m\_device;
00776   \textcolor{keyword}{const} Dims& m\_xpr\_dims;
00777 \};
00778 
00779 \} \textcolor{comment}{// end namespace Eigen}
00780 
00781 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_REDUCTION\_H}
\end{DoxyCode}
