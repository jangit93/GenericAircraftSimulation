\hypertarget{eigen_2_eigen_2src_2_core_2products_2_general_matrix_vector_8h_source}{}\section{eigen/\+Eigen/src/\+Core/products/\+General\+Matrix\+Vector.h}
\label{eigen_2_eigen_2src_2_core_2products_2_general_matrix_vector_8h_source}\index{General\+Matrix\+Vector.\+h@{General\+Matrix\+Vector.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_GENERAL\_MATRIX\_VECTOR\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_GENERAL\_MATRIX\_VECTOR\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{comment}{/* Optimized col-major matrix * vector product:}
00018 \textcolor{comment}{ * This algorithm processes 4 columns at onces that allows to both reduce}
00019 \textcolor{comment}{ * the number of load/stores of the result by a factor 4 and to reduce}
00020 \textcolor{comment}{ * the instruction dependency. Moreover, we know that all bands have the}
00021 \textcolor{comment}{ * same alignment pattern.}
00022 \textcolor{comment}{ *}
00023 \textcolor{comment}{ * Mixing type logic: C += alpha * A * B}
00024 \textcolor{comment}{ *  |  A  |  B  |alpha| comments}
00025 \textcolor{comment}{ *  |real |cplx |cplx | no vectorization}
00026 \textcolor{comment}{ *  |real |cplx |real | alpha is converted to a cplx when calling the run function, no vectorization}
00027 \textcolor{comment}{ *  |cplx |real |cplx | invalid, the caller has to do tmp: = A * B; C += alpha*tmp}
00028 \textcolor{comment}{ *  |cplx |real |real | optimal case, vectorization possible via real-cplx mul}
00029 \textcolor{comment}{ *}
00030 \textcolor{comment}{ * Accesses to the matrix coefficients follow the following logic:}
00031 \textcolor{comment}{ *}
00032 \textcolor{comment}{ * - if all columns have the same alignment then}
00033 \textcolor{comment}{ *   - if the columns have the same alignment as the result vector, then easy! (-> AllAligned case)}
00034 \textcolor{comment}{ *   - otherwise perform unaligned loads only (-> NoneAligned case)}
00035 \textcolor{comment}{ * - otherwise}
00036 \textcolor{comment}{ *   - if even columns have the same alignment then}
00037 \textcolor{comment}{ *     // odd columns are guaranteed to have the same alignment too}
00038 \textcolor{comment}{ *     - if even or odd columns have the same alignment as the result, then}
00039 \textcolor{comment}{ *       // for a register size of 2 scalars, this is guarantee to be the case (e.g., SSE with double)}
00040 \textcolor{comment}{ *       - perform half aligned and half unaligned loads (-> EvenAligned case)}
00041 \textcolor{comment}{ *     - otherwise perform unaligned loads only (-> NoneAligned case)}
00042 \textcolor{comment}{ *   - otherwise, if the register size is 4 scalars (e.g., SSE with float) then}
00043 \textcolor{comment}{ *     - one over 4 consecutive columns is guaranteed to be aligned with the result vector,}
00044 \textcolor{comment}{ *       perform simple aligned loads for this column and aligned loads plus re-alignment for the other.
       (-> FirstAligned case)}
00045 \textcolor{comment}{ *       // this re-alignment is done by the palign function implemented for SSE in Eigen/src/Core/arch/SSE
      /PacketMath.h}
00046 \textcolor{comment}{ *   - otherwise,}
00047 \textcolor{comment}{ *     // if we get here, this means the register size is greater than 4 (e.g., AVX with floats),}
00048 \textcolor{comment}{ *     // we currently fall back to the NoneAligned case}
00049 \textcolor{comment}{ *}
00050 \textcolor{comment}{ * The same reasoning apply for the transposed case.}
00051 \textcolor{comment}{ *}
00052 \textcolor{comment}{ * The last case (PacketSize>4) could probably be improved by generalizing the FirstAligned case, but since
       we do not support AVX yet...}
00053 \textcolor{comment}{ * One might also wonder why in the EvenAligned case we perform unaligned loads instead of using the
       aligned-loads plus re-alignment}
00054 \textcolor{comment}{ * strategy as in the FirstAligned case. The reason is that we observed that unaligned loads on a 8 byte
       boundary are not too slow}
00055 \textcolor{comment}{ * compared to unaligned loads on a 4 byte boundary.}
00056 \textcolor{comment}{ *}
00057 \textcolor{comment}{ */}
00058 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} LhsMapper, \textcolor{keywordtype}{bool} ConjugateLhs, \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{
      typename} RhsMapper, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int} Version>
\Hypertarget{eigen_2_eigen_2src_2_core_2products_2_general_matrix_vector_8h_source_l00059}\hyperlink{struct_eigen_1_1internal_1_1general__matrix__vector__product_3_01_index_00_01_lhs_scalar_00_01_l2767aff966c7bf3a7d425c9d340a95e8}{00059} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1general__matrix__vector__product}{general\_matrix\_vector\_product}<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},LhsScalar,LhsMapper,
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>
00060 \{
00061   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType}
       ResScalar;
00062 
00063 \textcolor{keyword}{enum} \{
00064   Vectorizable = \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::Vectorizable} && 
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<RhsScalar>::Vectorizable}
00065               && int(\hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::size})==int(
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<RhsScalar>::size}),
00066   LhsPacketSize = Vectorizable ? \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::size} : 1,
00067   RhsPacketSize = Vectorizable ? \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<RhsScalar>::size} : 1,
00068   ResPacketSize = Vectorizable ? \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<ResScalar>::size} : 1
00069 \};
00070 
00071 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{packet\_traits<LhsScalar>::type}  
      \hyperlink{group___sparse_core___module}{\_LhsPacket};
00072 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{packet\_traits<RhsScalar>::type}  
      \hyperlink{group___sparse_core___module}{\_RhsPacket};
00073 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{packet\_traits<ResScalar>::type}  
      \hyperlink{group___sparse_core___module}{\_ResPacket};
00074 
00075 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{conditional<Vectorizable,\_LhsPacket,LhsScalar>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{LhsPacket};
00076 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{conditional<Vectorizable,\_RhsPacket,RhsScalar>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{RhsPacket};
00077 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{conditional<Vectorizable,\_ResPacket,ResScalar>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{ResPacket};
00078 
00079 EIGEN\_DONT\_INLINE \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(
00080   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols,
00081   \textcolor{keyword}{const} LhsMapper& lhs,
00082   \textcolor{keyword}{const} RhsMapper& rhs,
00083         ResScalar* res, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} resIncr,
00084   RhsScalar alpha);
00085 \};
00086 
00087 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} LhsMapper, \textcolor{keywordtype}{bool} ConjugateLhs, \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{
      typename} RhsMapper, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int} Version>
00088 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} 
      \hyperlink{struct_eigen_1_1internal_1_1general__matrix__vector__product}{
      general\_matrix\_vector\_product<Index,LhsScalar,LhsMapper,ColMajor,ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>::run}
      (
00089   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols,
00090   \textcolor{keyword}{const} LhsMapper& lhs,
00091   \textcolor{keyword}{const} RhsMapper& rhs,
00092         ResScalar* res, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} resIncr,
00093   RhsScalar alpha)
00094 \{
00095   EIGEN\_UNUSED\_VARIABLE(resIncr);
00096   eigen\_internal\_assert(resIncr==1);
00097 \textcolor{preprocessor}{  #ifdef \_EIGEN\_ACCUMULATE\_PACKETS}
00098 \textcolor{preprocessor}{  #error \_EIGEN\_ACCUMULATE\_PACKETS has already been defined}
00099 \textcolor{preprocessor}{  #endif}
00100 \textcolor{preprocessor}{  #define \_EIGEN\_ACCUMULATE\_PACKETS(Alignment0,Alignment13,Alignment2) \(\backslash\)}
00101 \textcolor{preprocessor}{    pstore(&res[j], \(\backslash\)}
00102 \textcolor{preprocessor}{      padd(pload<ResPacket>(&res[j]), \(\backslash\)}
00103 \textcolor{preprocessor}{        padd( \(\backslash\)}
00104 \textcolor{preprocessor}{      padd(pcj.pmul(lhs0.template load<LhsPacket, Alignment0>(j),    ptmp0), \(\backslash\)}
00105 \textcolor{preprocessor}{      pcj.pmul(lhs1.template load<LhsPacket, Alignment13>(j),   ptmp1)),   \(\backslash\)}
00106 \textcolor{preprocessor}{      padd(pcj.pmul(lhs2.template load<LhsPacket, Alignment2>(j),    ptmp2), \(\backslash\)}
00107 \textcolor{preprocessor}{      pcj.pmul(lhs3.template load<LhsPacket, Alignment13>(j),   ptmp3)) )))}
00108 
00109   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsMapper::VectorMapper LhsScalars;
00110 
00111   \hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs>}
       cj;
00112   \hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper<LhsPacket,RhsPacket,ConjugateLhs,ConjugateRhs>}
       pcj;
00113   \textcolor{keywordflow}{if}(ConjugateRhs)
00114     alpha = numext::conj(alpha);
00115 
00116   \textcolor{keyword}{enum} \{ AllAligned = 0, EvenAligned, FirstAligned, NoneAligned \};
00117   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} columnsAtOnce = 4;
00118   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peels = 2;
00119   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} LhsPacketAlignedMask = LhsPacketSize-1;
00120   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} ResPacketAlignedMask = ResPacketSize-1;
00121 \textcolor{comment}{//  const Index PeelAlignedMask = ResPacketSize*peels-1;}
00122   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = rows;
00123 
00124   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lhsStride = lhs.stride();
00125 
00126   \textcolor{comment}{// How many coeffs of the result do we have to skip to be aligned.}
00127   \textcolor{comment}{// Here we assume data are at least aligned on the base scalar type.}
00128   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedStart = internal::first\_default\_aligned(res,size);
00129   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedSize = ResPacketSize>1 ? alignedStart + ((size-alignedStart) & ~ResPacketAlignedMask) :
       0;
00130   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeledSize = alignedSize - RhsPacketSize*peels - RhsPacketSize + 1;
00131 
00132   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignmentStep = LhsPacketSize>1 ? (LhsPacketSize - lhsStride % LhsPacketSize) & 
      LhsPacketAlignedMask : 0;
00133   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignmentPattern = alignmentStep==0 ? AllAligned
00134                        : alignmentStep==(LhsPacketSize/2) ? EvenAligned
00135                        : FirstAligned;
00136 
00137   \textcolor{comment}{// we cannot assume the first element is aligned because of sub-matrices}
00138   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lhsAlignmentOffset = lhs.firstAligned(size);
00139 
00140   \textcolor{comment}{// find how many columns do we have to skip to be aligned with the result (if possible)}
00141   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} skipColumns = 0;
00142   \textcolor{comment}{// if the data cannot be aligned (TODO add some compile time tests when possible, e.g. for floats)}
00143   \textcolor{keywordflow}{if}( (lhsAlignmentOffset < 0) || (lhsAlignmentOffset == size) || (UIntPtr(res)%\textcolor{keyword}{sizeof}(ResScalar)) )
00144   \{
00145     alignedSize = 0;
00146     alignedStart = 0;
00147     alignmentPattern = NoneAligned;
00148   \}
00149   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(LhsPacketSize > 4)
00150   \{
00151     \textcolor{comment}{// TODO: extend the code to support aligned loads whenever possible when LhsPacketSize > 4.}
00152     \textcolor{comment}{// Currently, it seems to be better to perform unaligned loads anyway}
00153     alignmentPattern = NoneAligned;
00154   \}
00155   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (LhsPacketSize>1)
00156   \{
00157   \textcolor{comment}{//    eigen\_internal\_assert(size\_t(firstLhs+lhsAlignmentOffset)%sizeof(LhsPacket)==0 ||
       size<LhsPacketSize);}
00158 
00159     \textcolor{keywordflow}{while} (skipColumns<LhsPacketSize &&
00160           alignedStart != ((lhsAlignmentOffset + alignmentStep*skipColumns)%LhsPacketSize))
00161       ++skipColumns;
00162     \textcolor{keywordflow}{if} (skipColumns==LhsPacketSize)
00163     \{
00164       \textcolor{comment}{// nothing can be aligned, no need to skip any column}
00165       alignmentPattern = NoneAligned;
00166       skipColumns = 0;
00167     \}
00168     \textcolor{keywordflow}{else}
00169     \{
00170       skipColumns = (std::min)(skipColumns,cols);
00171       \textcolor{comment}{// note that the skiped columns are processed later.}
00172     \}
00173 
00174     \textcolor{comment}{/*    eigen\_internal\_assert(  (alignmentPattern==NoneAligned)}
00175 \textcolor{comment}{                      || (skipColumns + columnsAtOnce >= cols)}
00176 \textcolor{comment}{                      || LhsPacketSize > size}
00177 \textcolor{comment}{                      || (size\_t(firstLhs+alignedStart+lhsStride*skipColumns)%sizeof(LhsPacket))==0);*/}
00178   \}
00179   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(Vectorizable)
00180   \{
00181     alignedStart = 0;
00182     alignedSize = size;
00183     alignmentPattern = AllAligned;
00184   \}
00185 
00186   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset1 = (FirstAligned && alignmentStep==1)?3:1;
00187   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset3 = (FirstAligned && alignmentStep==1)?1:3;
00188 
00189   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} columnBound = ((cols-skipColumns)/columnsAtOnce)*columnsAtOnce + skipColumns;
00190   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=skipColumns; i<columnBound; i+=columnsAtOnce)
00191   \{
00192     \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{RhsPacket} ptmp0 = pset1<RhsPacket>(alpha*rhs(i, 0)),
00193               ptmp1 = pset1<RhsPacket>(alpha*rhs(i+offset1, 0)),
00194               ptmp2 = pset1<RhsPacket>(alpha*rhs(i+2, 0)),
00195               ptmp3 = pset1<RhsPacket>(alpha*rhs(i+offset3, 0));
00196 
00197     \textcolor{comment}{// this helps a lot generating better binary code}
00198     \textcolor{keyword}{const} LhsScalars lhs0 = lhs.getVectorMapper(0, i+0),   lhs1 = lhs.getVectorMapper(0, i+offset1),
00199                      lhs2 = lhs.getVectorMapper(0, i+2),   lhs3 = lhs.getVectorMapper(0, i+offset3);
00200 
00201     \textcolor{keywordflow}{if} (Vectorizable)
00202     \{
00203       \textcolor{comment}{/* explicit vectorization */}
00204       \textcolor{comment}{// process initial unaligned coeffs}
00205       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<alignedStart; ++j)
00206       \{
00207         res[j] = cj.pmadd(lhs0(j), pfirst(ptmp0), res[j]);
00208         res[j] = cj.pmadd(lhs1(j), pfirst(ptmp1), res[j]);
00209         res[j] = cj.pmadd(lhs2(j), pfirst(ptmp2), res[j]);
00210         res[j] = cj.pmadd(lhs3(j), pfirst(ptmp3), res[j]);
00211       \}
00212 
00213       \textcolor{keywordflow}{if} (alignedSize>alignedStart)
00214       \{
00215         \textcolor{keywordflow}{switch}(alignmentPattern)
00216         \{
00217           \textcolor{keywordflow}{case} AllAligned:
00218             \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = alignedStart; j<alignedSize; j+=ResPacketSize)
00219               \_EIGEN\_ACCUMULATE\_PACKETS(\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned},\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned},\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned});
00220             \textcolor{keywordflow}{break};
00221           \textcolor{keywordflow}{case} EvenAligned:
00222             \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = alignedStart; j<alignedSize; j+=ResPacketSize)
00223               \_EIGEN\_ACCUMULATE\_PACKETS(\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned},\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned},
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned});
00224             \textcolor{keywordflow}{break};
00225           \textcolor{keywordflow}{case} FirstAligned:
00226           \{
00227             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = alignedStart;
00228             \textcolor{keywordflow}{if}(peels>1)
00229             \{
00230               \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{LhsPacket} A00, A01, A02, A03, A10, A11, A12, A13;
00231               \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{ResPacket} T0, T1;
00232 
00233               A01 = lhs1.template load<LhsPacket, Aligned>(alignedStart-1);
00234               A02 = lhs2.template load<LhsPacket, Aligned>(alignedStart-2);
00235               A03 = lhs3.template load<LhsPacket, Aligned>(alignedStart-3);
00236 
00237               \textcolor{keywordflow}{for} (; j<peeledSize; j+=peels*ResPacketSize)
00238               \{
00239                 A11 = lhs1.template load<LhsPacket, Aligned>(j-1+LhsPacketSize);  palign<1>(A01,A11);
00240                 A12 = lhs2.template load<LhsPacket, Aligned>(j-2+LhsPacketSize);  palign<2>(A02,A12);
00241                 A13 = lhs3.template load<LhsPacket, Aligned>(j-3+LhsPacketSize);  palign<3>(A03,A13);
00242 
00243                 A00 = lhs0.template load<LhsPacket, Aligned>(j);
00244                 A10 = lhs0.template load<LhsPacket, Aligned>(j+LhsPacketSize);
00245                 T0  = pcj.pmadd(A00, ptmp0, pload<ResPacket>(&res[j]));
00246                 T1  = pcj.pmadd(A10, ptmp0, pload<ResPacket>(&res[j+ResPacketSize]));
00247 
00248                 T0  = pcj.pmadd(A01, ptmp1, T0);
00249                 A01 = lhs1.template load<LhsPacket, Aligned>(j-1+2*LhsPacketSize);  palign<1>(A11,A01);
00250                 T0  = pcj.pmadd(A02, ptmp2, T0);
00251                 A02 = lhs2.template load<LhsPacket, Aligned>(j-2+2*LhsPacketSize);  palign<2>(A12,A02);
00252                 T0  = pcj.pmadd(A03, ptmp3, T0);
00253                 pstore(&res[j],T0);
00254                 A03 = lhs3.template load<LhsPacket, Aligned>(j-3+2*LhsPacketSize);  palign<3>(A13,A03);
00255                 T1  = pcj.pmadd(A11, ptmp1, T1);
00256                 T1  = pcj.pmadd(A12, ptmp2, T1);
00257                 T1  = pcj.pmadd(A13, ptmp3, T1);
00258                 pstore(&res[j+ResPacketSize],T1);
00259               \}
00260             \}
00261             \textcolor{keywordflow}{for} (; j<alignedSize; j+=ResPacketSize)
00262               \_EIGEN\_ACCUMULATE\_PACKETS(\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned},\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned},
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned});
00263             \textcolor{keywordflow}{break};
00264           \}
00265           \textcolor{keywordflow}{default}:
00266             \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = alignedStart; j<alignedSize; j+=ResPacketSize)
00267               \_EIGEN\_ACCUMULATE\_PACKETS(\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned},\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned},
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned});
00268             \textcolor{keywordflow}{break};
00269         \}
00270       \}
00271     \} \textcolor{comment}{// end explicit vectorization}
00272 
00273     \textcolor{comment}{/* process remaining coeffs (or all if there is no explicit vectorization) */}
00274     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=alignedSize; j<size; ++j)
00275     \{
00276       res[j] = cj.pmadd(lhs0(j), pfirst(ptmp0), res[j]);
00277       res[j] = cj.pmadd(lhs1(j), pfirst(ptmp1), res[j]);
00278       res[j] = cj.pmadd(lhs2(j), pfirst(ptmp2), res[j]);
00279       res[j] = cj.pmadd(lhs3(j), pfirst(ptmp3), res[j]);
00280     \}
00281   \}
00282 
00283   \textcolor{comment}{// process remaining first and last columns (at most columnsAtOnce-1)}
00284   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} end = cols;
00285   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} start = columnBound;
00286   \textcolor{keywordflow}{do}
00287   \{
00288     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=start; k<end; ++k)
00289     \{
00290       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{RhsPacket} ptmp0 = pset1<RhsPacket>(alpha*rhs(k, 0));
00291       \textcolor{keyword}{const} LhsScalars lhs0 = lhs.getVectorMapper(0, k);
00292 
00293       \textcolor{keywordflow}{if} (Vectorizable)
00294       \{
00295         \textcolor{comment}{/* explicit vectorization */}
00296         \textcolor{comment}{// process first unaligned result's coeffs}
00297         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<alignedStart; ++j)
00298           res[j] += cj.pmul(lhs0(j), pfirst(ptmp0));
00299         \textcolor{comment}{// process aligned result's coeffs}
00300         \textcolor{keywordflow}{if} (lhs0.template aligned<LhsPacket>(alignedStart))
00301           \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = alignedStart;i<alignedSize;i+=ResPacketSize)
00302             pstore(&res[i], pcj.pmadd(lhs0.template load<LhsPacket, Aligned>(i), ptmp0, pload<ResPacket>(&
      res[i])));
00303         \textcolor{keywordflow}{else}
00304           \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = alignedStart;i<alignedSize;i+=ResPacketSize)
00305             pstore(&res[i], pcj.pmadd(lhs0.template load<LhsPacket, Unaligned>(i), ptmp0, pload<ResPacket>(
      &res[i])));
00306       \}
00307 
00308       \textcolor{comment}{// process remaining scalars (or all if no explicit vectorization)}
00309       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=alignedSize; i<size; ++i)
00310         res[i] += cj.pmul(lhs0(i), pfirst(ptmp0));
00311     \}
00312     \textcolor{keywordflow}{if} (skipColumns)
00313     \{
00314       start = 0;
00315       end = skipColumns;
00316       skipColumns = 0;
00317     \}
00318     \textcolor{keywordflow}{else}
00319       \textcolor{keywordflow}{break};
00320   \} \textcolor{keywordflow}{while}(Vectorizable);
00321 \textcolor{preprocessor}{  #undef \_EIGEN\_ACCUMULATE\_PACKETS}
00322 \}
00323 
00324 \textcolor{comment}{/* Optimized row-major matrix * vector product:}
00325 \textcolor{comment}{ * This algorithm processes 4 rows at onces that allows to both reduce}
00326 \textcolor{comment}{ * the number of load/stores of the result by a factor 4 and to reduce}
00327 \textcolor{comment}{ * the instruction dependency. Moreover, we know that all bands have the}
00328 \textcolor{comment}{ * same alignment pattern.}
00329 \textcolor{comment}{ *}
00330 \textcolor{comment}{ * Mixing type logic:}
00331 \textcolor{comment}{ *  - alpha is always a complex (or converted to a complex)}
00332 \textcolor{comment}{ *  - no vectorization}
00333 \textcolor{comment}{ */}
00334 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} LhsMapper, \textcolor{keywordtype}{bool} ConjugateLhs, \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{
      typename} RhsMapper, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int} Version>
\Hypertarget{eigen_2_eigen_2src_2_core_2products_2_general_matrix_vector_8h_source_l00335}\hyperlink{struct_eigen_1_1internal_1_1general__matrix__vector__product_3_01_index_00_01_lhs_scalar_00_01_l24320a1e63993864008333cadda60258}{00335} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1general__matrix__vector__product}{general\_matrix\_vector\_product}<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},LhsScalar,LhsMapper,
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>
00336 \{
00337 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType}
       ResScalar;
00338 
00339 \textcolor{keyword}{enum} \{
00340   Vectorizable = \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::Vectorizable} && 
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<RhsScalar>::Vectorizable}
00341               && int(\hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::size})==int(
      \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<RhsScalar>::size}),
00342   LhsPacketSize = Vectorizable ? \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<LhsScalar>::size} : 1,
00343   RhsPacketSize = Vectorizable ? \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<RhsScalar>::size} : 1,
00344   ResPacketSize = Vectorizable ? \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<ResScalar>::size} : 1
00345 \};
00346 
00347 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{packet\_traits<LhsScalar>::type}  
      \hyperlink{group___sparse_core___module}{\_LhsPacket};
00348 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{packet\_traits<RhsScalar>::type}  
      \hyperlink{group___sparse_core___module}{\_RhsPacket};
00349 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{packet\_traits<ResScalar>::type}  
      \hyperlink{group___sparse_core___module}{\_ResPacket};
00350 
00351 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{conditional<Vectorizable,\_LhsPacket,LhsScalar>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{LhsPacket};
00352 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{conditional<Vectorizable,\_RhsPacket,RhsScalar>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{RhsPacket};
00353 \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{conditional<Vectorizable,\_ResPacket,ResScalar>::type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{ResPacket};
00354 
00355 EIGEN\_DONT\_INLINE \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(
00356   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols,
00357   \textcolor{keyword}{const} LhsMapper& lhs,
00358   \textcolor{keyword}{const} RhsMapper& rhs,
00359         ResScalar* res, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} resIncr,
00360   ResScalar alpha);
00361 \};
00362 
00363 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} LhsMapper, \textcolor{keywordtype}{bool} ConjugateLhs, \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{
      typename} RhsMapper, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int} Version>
00364 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} 
      \hyperlink{struct_eigen_1_1internal_1_1general__matrix__vector__product}{
      general\_matrix\_vector\_product<Index,LhsScalar,LhsMapper,RowMajor,ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>::run}
      (
00365   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols,
00366   \textcolor{keyword}{const} LhsMapper& lhs,
00367   \textcolor{keyword}{const} RhsMapper& rhs,
00368   ResScalar* res, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} resIncr,
00369   ResScalar alpha)
00370 \{
00371   eigen\_internal\_assert(rhs.stride()==1);
00372 
00373 \textcolor{preprocessor}{  #ifdef \_EIGEN\_ACCUMULATE\_PACKETS}
00374 \textcolor{preprocessor}{  #error \_EIGEN\_ACCUMULATE\_PACKETS has already been defined}
00375 \textcolor{preprocessor}{  #endif}
00376 
00377 \textcolor{preprocessor}{  #define \_EIGEN\_ACCUMULATE\_PACKETS(Alignment0,Alignment13,Alignment2) \{\(\backslash\)}
00378 \textcolor{preprocessor}{    RhsPacket b = rhs.getVectorMapper(j, 0).template load<RhsPacket, Aligned>(0);  \(\backslash\)}
00379 \textcolor{preprocessor}{    ptmp0 = pcj.pmadd(lhs0.template load<LhsPacket, Alignment0>(j), b, ptmp0); \(\backslash\)}
00380 \textcolor{preprocessor}{    ptmp1 = pcj.pmadd(lhs1.template load<LhsPacket, Alignment13>(j), b, ptmp1); \(\backslash\)}
00381 \textcolor{preprocessor}{    ptmp2 = pcj.pmadd(lhs2.template load<LhsPacket, Alignment2>(j), b, ptmp2); \(\backslash\)}
00382 \textcolor{preprocessor}{    ptmp3 = pcj.pmadd(lhs3.template load<LhsPacket, Alignment13>(j), b, ptmp3); \}}
00383 
00384   \hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs>}
       cj;
00385   \hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper<LhsPacket,RhsPacket,ConjugateLhs,ConjugateRhs>}
       pcj;
00386 
00387   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsMapper::VectorMapper LhsScalars;
00388 
00389   \textcolor{keyword}{enum} \{ AllAligned=0, EvenAligned=1, FirstAligned=2, NoneAligned=3 \};
00390   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rowsAtOnce = 4;
00391   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peels = 2;
00392   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} RhsPacketAlignedMask = RhsPacketSize-1;
00393   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} LhsPacketAlignedMask = LhsPacketSize-1;
00394   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth = cols;
00395   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lhsStride = lhs.stride();
00396 
00397   \textcolor{comment}{// How many coeffs of the result do we have to skip to be aligned.}
00398   \textcolor{comment}{// Here we assume data are at least aligned on the base scalar type}
00399   \textcolor{comment}{// if that's not the case then vectorization is discarded, see below.}
00400   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedStart = rhs.firstAligned(depth);
00401   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignedSize = RhsPacketSize>1 ? alignedStart + ((depth-alignedStart) & ~RhsPacketAlignedMask) 
      : 0;
00402   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeledSize = alignedSize - RhsPacketSize*peels - RhsPacketSize + 1;
00403 
00404   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignmentStep = LhsPacketSize>1 ? (LhsPacketSize - lhsStride % LhsPacketSize) & 
      LhsPacketAlignedMask : 0;
00405   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} alignmentPattern = alignmentStep==0 ? AllAligned
00406                            : alignmentStep==(LhsPacketSize/2) ? EvenAligned
00407                            : FirstAligned;
00408 
00409   \textcolor{comment}{// we cannot assume the first element is aligned because of sub-matrices}
00410   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lhsAlignmentOffset = lhs.firstAligned(depth);
00411   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rhsAlignmentOffset = rhs.firstAligned(rows);
00412 
00413   \textcolor{comment}{// find how many rows do we have to skip to be aligned with rhs (if possible)}
00414   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} skipRows = 0;
00415   \textcolor{comment}{// if the data cannot be aligned (TODO add some compile time tests when possible, e.g. for floats)}
00416   \textcolor{keywordflow}{if}( (\textcolor{keyword}{sizeof}(LhsScalar)!=\textcolor{keyword}{sizeof}(RhsScalar)) ||
00417       (lhsAlignmentOffset < 0) || (lhsAlignmentOffset == depth) ||
00418       (rhsAlignmentOffset < 0) || (rhsAlignmentOffset == rows) )
00419   \{
00420     alignedSize = 0;
00421     alignedStart = 0;
00422     alignmentPattern = NoneAligned;
00423   \}
00424   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(LhsPacketSize > 4)
00425   \{
00426     \textcolor{comment}{// TODO: extend the code to support aligned loads whenever possible when LhsPacketSize > 4.}
00427     alignmentPattern = NoneAligned;
00428   \}
00429   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (LhsPacketSize>1)
00430   \{
00431   \textcolor{comment}{//    eigen\_internal\_assert(size\_t(firstLhs+lhsAlignmentOffset)%sizeof(LhsPacket)==0  ||
       depth<LhsPacketSize);}
00432 
00433     \textcolor{keywordflow}{while} (skipRows<LhsPacketSize &&
00434            alignedStart != ((lhsAlignmentOffset + alignmentStep*skipRows)%LhsPacketSize))
00435       ++skipRows;
00436     \textcolor{keywordflow}{if} (skipRows==LhsPacketSize)
00437     \{
00438       \textcolor{comment}{// nothing can be aligned, no need to skip any column}
00439       alignmentPattern = NoneAligned;
00440       skipRows = 0;
00441     \}
00442     \textcolor{keywordflow}{else}
00443     \{
00444       skipRows = (std::min)(skipRows,\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(rows));
00445       \textcolor{comment}{// note that the skiped columns are processed later.}
00446     \}
00447     \textcolor{comment}{/*    eigen\_internal\_assert(  alignmentPattern==NoneAligned}
00448 \textcolor{comment}{                      || LhsPacketSize==1}
00449 \textcolor{comment}{                      || (skipRows + rowsAtOnce >= rows)}
00450 \textcolor{comment}{                      || LhsPacketSize > depth}
00451 \textcolor{comment}{                      || (size\_t(firstLhs+alignedStart+lhsStride*skipRows)%sizeof(LhsPacket))==0);*/}
00452   \}
00453   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(Vectorizable)
00454   \{
00455     alignedStart = 0;
00456     alignedSize = depth;
00457     alignmentPattern = AllAligned;
00458   \}
00459 
00460   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset1 = (FirstAligned && alignmentStep==1)?3:1;
00461   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset3 = (FirstAligned && alignmentStep==1)?1:3;
00462 
00463   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rowBound = ((rows-skipRows)/rowsAtOnce)*rowsAtOnce + skipRows;
00464   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=skipRows; i<rowBound; i+=rowsAtOnce)
00465   \{
00466     \textcolor{comment}{// FIXME: what is the purpose of this EIGEN\_ALIGN\_DEFAULT ??}
00467     EIGEN\_ALIGN\_MAX ResScalar tmp0 = ResScalar(0);
00468     ResScalar tmp1 = ResScalar(0), tmp2 = ResScalar(0), tmp3 = ResScalar(0);
00469 
00470     \textcolor{comment}{// this helps the compiler generating good binary code}
00471     \textcolor{keyword}{const} LhsScalars lhs0 = lhs.getVectorMapper(i+0, 0),    lhs1 = lhs.getVectorMapper(i+offset1, 0),
00472                      lhs2 = lhs.getVectorMapper(i+2, 0),    lhs3 = lhs.getVectorMapper(i+offset3, 0);
00473 
00474     \textcolor{keywordflow}{if} (Vectorizable)
00475     \{
00476       \textcolor{comment}{/* explicit vectorization */}
00477       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{ResPacket} ptmp0 = pset1<ResPacket>(ResScalar(0)), ptmp1 = pset1<ResPacket>(ResScalar(0)),
00478                 ptmp2 = pset1<ResPacket>(ResScalar(0)), ptmp3 = pset1<ResPacket>(ResScalar(0));
00479 
00480       \textcolor{comment}{// process initial unaligned coeffs}
00481       \textcolor{comment}{// FIXME this loop get vectorized by the compiler !}
00482       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<alignedStart; ++j)
00483       \{
00484         RhsScalar b = rhs(j, 0);
00485         tmp0 += cj.pmul(lhs0(j),b); tmp1 += cj.pmul(lhs1(j),b);
00486         tmp2 += cj.pmul(lhs2(j),b); tmp3 += cj.pmul(lhs3(j),b);
00487       \}
00488 
00489       \textcolor{keywordflow}{if} (alignedSize>alignedStart)
00490       \{
00491         \textcolor{keywordflow}{switch}(alignmentPattern)
00492         \{
00493           \textcolor{keywordflow}{case} AllAligned:
00494             \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = alignedStart; j<alignedSize; j+=RhsPacketSize)
00495               \_EIGEN\_ACCUMULATE\_PACKETS(\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned},\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned},\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned});
00496             \textcolor{keywordflow}{break};
00497           \textcolor{keywordflow}{case} EvenAligned:
00498             \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = alignedStart; j<alignedSize; j+=RhsPacketSize)
00499               \_EIGEN\_ACCUMULATE\_PACKETS(\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned},\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned},
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned});
00500             \textcolor{keywordflow}{break};
00501           \textcolor{keywordflow}{case} FirstAligned:
00502           \{
00503             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = alignedStart;
00504             \textcolor{keywordflow}{if} (peels>1)
00505             \{
00506               \textcolor{comment}{/* Here we proccess 4 rows with with two peeled iterations to hide}
00507 \textcolor{comment}{               * the overhead of unaligned loads. Moreover unaligned loads are handled}
00508 \textcolor{comment}{               * using special shift/move operations between the two aligned packets}
00509 \textcolor{comment}{               * overlaping the desired unaligned packet. This is *much* more efficient}
00510 \textcolor{comment}{               * than basic unaligned loads.}
00511 \textcolor{comment}{               */}
00512               \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{LhsPacket} A01, A02, A03, A11, A12, A13;
00513               A01 = lhs1.template load<LhsPacket, Aligned>(alignedStart-1);
00514               A02 = lhs2.template load<LhsPacket, Aligned>(alignedStart-2);
00515               A03 = lhs3.template load<LhsPacket, Aligned>(alignedStart-3);
00516 
00517               \textcolor{keywordflow}{for} (; j<peeledSize; j+=peels*RhsPacketSize)
00518               \{
00519                 \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{RhsPacket} b = rhs.getVectorMapper(j, 0).template load<RhsPacket, Aligned>(0);
00520                 A11 = lhs1.template load<LhsPacket, Aligned>(j-1+LhsPacketSize);  palign<1>(A01,A11);
00521                 A12 = lhs2.template load<LhsPacket, Aligned>(j-2+LhsPacketSize);  palign<2>(A02,A12);
00522                 A13 = lhs3.template load<LhsPacket, Aligned>(j-3+LhsPacketSize);  palign<3>(A03,A13);
00523 
00524                 ptmp0 = pcj.pmadd(lhs0.template load<LhsPacket, Aligned>(j), b, ptmp0);
00525                 ptmp1 = pcj.pmadd(A01, b, ptmp1);
00526                 A01 = lhs1.template load<LhsPacket, Aligned>(j-1+2*LhsPacketSize);  palign<1>(A11,A01);
00527                 ptmp2 = pcj.pmadd(A02, b, ptmp2);
00528                 A02 = lhs2.template load<LhsPacket, Aligned>(j-2+2*LhsPacketSize);  palign<2>(A12,A02);
00529                 ptmp3 = pcj.pmadd(A03, b, ptmp3);
00530                 A03 = lhs3.template load<LhsPacket, Aligned>(j-3+2*LhsPacketSize);  palign<3>(A13,A03);
00531 
00532                 b = rhs.getVectorMapper(j+RhsPacketSize, 0).template load<RhsPacket, Aligned>(0);
00533                 ptmp0 = pcj.pmadd(lhs0.template load<LhsPacket, Aligned>(j+LhsPacketSize), b, ptmp0);
00534                 ptmp1 = pcj.pmadd(A11, b, ptmp1);
00535                 ptmp2 = pcj.pmadd(A12, b, ptmp2);
00536                 ptmp3 = pcj.pmadd(A13, b, ptmp3);
00537               \}
00538             \}
00539             \textcolor{keywordflow}{for} (; j<alignedSize; j+=RhsPacketSize)
00540               \_EIGEN\_ACCUMULATE\_PACKETS(\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned},\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned},
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned});
00541             \textcolor{keywordflow}{break};
00542           \}
00543           \textcolor{keywordflow}{default}:
00544             \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = alignedStart; j<alignedSize; j+=RhsPacketSize)
00545               \_EIGEN\_ACCUMULATE\_PACKETS(\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned},\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned},
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204}{Unaligned});
00546             \textcolor{keywordflow}{break};
00547         \}
00548         tmp0 += predux(ptmp0);
00549         tmp1 += predux(ptmp1);
00550         tmp2 += predux(ptmp2);
00551         tmp3 += predux(ptmp3);
00552       \}
00553     \} \textcolor{comment}{// end explicit vectorization}
00554 
00555     \textcolor{comment}{// process remaining coeffs (or all if no explicit vectorization)}
00556     \textcolor{comment}{// FIXME this loop get vectorized by the compiler !}
00557     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=alignedSize; j<depth; ++j)
00558     \{
00559       RhsScalar b = rhs(j, 0);
00560       tmp0 += cj.pmul(lhs0(j),b); tmp1 += cj.pmul(lhs1(j),b);
00561       tmp2 += cj.pmul(lhs2(j),b); tmp3 += cj.pmul(lhs3(j),b);
00562     \}
00563     res[i*resIncr]            += alpha*tmp0;
00564     res[(i+offset1)*resIncr]  += alpha*tmp1;
00565     res[(i+2)*resIncr]        += alpha*tmp2;
00566     res[(i+offset3)*resIncr]  += alpha*tmp3;
00567   \}
00568 
00569   \textcolor{comment}{// process remaining first and last rows (at most columnsAtOnce-1)}
00570   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} end = rows;
00571   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} start = rowBound;
00572   \textcolor{keywordflow}{do}
00573   \{
00574     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=start; i<end; ++i)
00575     \{
00576       EIGEN\_ALIGN\_MAX ResScalar tmp0 = ResScalar(0);
00577       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{ResPacket} ptmp0 = pset1<ResPacket>(tmp0);
00578       \textcolor{keyword}{const} LhsScalars lhs0 = lhs.getVectorMapper(i, 0);
00579       \textcolor{comment}{// process first unaligned result's coeffs}
00580       \textcolor{comment}{// FIXME this loop get vectorized by the compiler !}
00581       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<alignedStart; ++j)
00582         tmp0 += cj.pmul(lhs0(j), rhs(j, 0));
00583 
00584       \textcolor{keywordflow}{if} (alignedSize>alignedStart)
00585       \{
00586         \textcolor{comment}{// process aligned rhs coeffs}
00587         \textcolor{keywordflow}{if} (lhs0.template aligned<LhsPacket>(alignedStart))
00588           \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = alignedStart;j<alignedSize;j+=RhsPacketSize)
00589             ptmp0 = pcj.pmadd(lhs0.template load<LhsPacket, Aligned>(j), rhs.getVectorMapper(j, 0).template
       load<RhsPacket, Aligned>(0), ptmp0);
00590         \textcolor{keywordflow}{else}
00591           \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = alignedStart;j<alignedSize;j+=RhsPacketSize)
00592             ptmp0 = pcj.pmadd(lhs0.template load<LhsPacket, Unaligned>(j), rhs.getVectorMapper(j, 0).
      template load<RhsPacket, Aligned>(0), ptmp0);
00593         tmp0 += predux(ptmp0);
00594       \}
00595 
00596       \textcolor{comment}{// process remaining scalars}
00597       \textcolor{comment}{// FIXME this loop get vectorized by the compiler !}
00598       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=alignedSize; j<depth; ++j)
00599         tmp0 += cj.pmul(lhs0(j), rhs(j, 0));
00600       res[i*resIncr] += alpha*tmp0;
00601     \}
00602     \textcolor{keywordflow}{if} (skipRows)
00603     \{
00604       start = 0;
00605       end = skipRows;
00606       skipRows = 0;
00607     \}
00608     \textcolor{keywordflow}{else}
00609       \textcolor{keywordflow}{break};
00610   \} \textcolor{keywordflow}{while}(Vectorizable);
00611 
00612 \textcolor{preprocessor}{  #undef \_EIGEN\_ACCUMULATE\_PACKETS}
00613 \}
00614 
00615 \} \textcolor{comment}{// end namespace internal}
00616 
00617 \} \textcolor{comment}{// end namespace Eigen}
00618 
00619 \textcolor{preprocessor}{#endif // EIGEN\_GENERAL\_MATRIX\_VECTOR\_H}
\end{DoxyCode}
