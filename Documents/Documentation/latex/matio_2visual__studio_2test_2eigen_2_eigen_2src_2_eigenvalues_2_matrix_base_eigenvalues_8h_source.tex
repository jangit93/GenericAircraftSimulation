\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_matrix_base_eigenvalues_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Eigenvalues/\+Matrix\+Base\+Eigenvalues.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_eigenvalues_2_matrix_base_eigenvalues_8h_source}\index{Matrix\+Base\+Eigenvalues.\+h@{Matrix\+Base\+Eigenvalues.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2010 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_MATRIXBASEEIGENVALUES\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_MATRIXBASEEIGENVALUES\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00017 
00018 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keywordtype}{bool} IsComplex>
00019 \textcolor{keyword}{struct }eigenvalues\_selector
00020 \{
00021   \textcolor{comment}{// this is the implementation for the case IsComplex = true}
00022   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{typename} MatrixBase<Derived>::EigenvaluesReturnType \textcolor{keyword}{const}
00023   run(\textcolor{keyword}{const} MatrixBase<Derived>& m)
00024   \{
00025     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::PlainObject PlainObject;
00026     PlainObject m\_eval(m);
00027     \textcolor{keywordflow}{return} ComplexEigenSolver<PlainObject>(m\_eval, \textcolor{keyword}{false}).eigenvalues();
00028   \}
00029 \};
00030 
00031 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00032 \textcolor{keyword}{struct }eigenvalues\_selector<Derived, false>
00033 \{
00034   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{typename} MatrixBase<Derived>::EigenvaluesReturnType \textcolor{keyword}{const}
00035   run(\textcolor{keyword}{const} MatrixBase<Derived>& m)
00036   \{
00037     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::PlainObject PlainObject;
00038     PlainObject m\_eval(m);
00039     \textcolor{keywordflow}{return} EigenSolver<PlainObject>(m\_eval, \textcolor{keyword}{false}).eigenvalues();
00040   \}
00041 \};
00042 
00043 \} \textcolor{comment}{// end namespace internal}
00044 
00065 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00066 \textcolor{keyword}{inline} \textcolor{keyword}{typename} MatrixBase<Derived>::EigenvaluesReturnType
00067 \hyperlink{group___core___module_a30430fa3d5b4e74d312fd4f502ac984d}{MatrixBase<Derived>::eigenvalues}()\textcolor{keyword}{ const}
00068 \textcolor{keyword}{}\{
00069   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<Derived>::Scalar Scalar;
00070   \textcolor{keywordflow}{return} internal::eigenvalues\_selector<Derived, NumTraits<Scalar>::IsComplex>::run(derived());
00071 \}
00072 
00087 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} UpLo> 
00088 \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___core___module_a8ae92703d920130b38a383f8b165146c}{SelfAdjointView<MatrixType, UpLo>::EigenvaluesReturnType}
00089 \hyperlink{group___core___module_ad4f34424b4ea12de9bbc5623cb938b4f}{SelfAdjointView<MatrixType, UpLo>::eigenvalues}()\textcolor{keyword}{ const}
00090 \textcolor{keyword}{}\{
00091   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SelfAdjointView<MatrixType, UpLo>::PlainObject PlainObject;
00092   PlainObject thisAsMatrix(*\textcolor{keyword}{this});
00093   \textcolor{keywordflow}{return} SelfAdjointEigenSolver<PlainObject>(thisAsMatrix, \textcolor{keyword}{false}).eigenvalues();
00094 \}
00095 
00096 
00097 
00120 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00121 \textcolor{keyword}{inline} \textcolor{keyword}{typename} MatrixBase<Derived>::RealScalar
00122 \hyperlink{group___core___module_a0ff9bc0b9bea2d0822a2bf3192783102}{MatrixBase<Derived>::operatorNorm}()\textcolor{keyword}{ const}
00123 \textcolor{keyword}{}\{
00124   \textcolor{keyword}{using} std::sqrt;
00125   \textcolor{keyword}{typename} Derived::PlainObject m\_eval(derived());
00126   \textcolor{comment}{// FIXME if it is really guaranteed that the eigenvalues are already sorted,}
00127   \textcolor{comment}{// then we don't need to compute a maxCoeff() here, comparing the 1st and last ones is enough.}
00128   \textcolor{keywordflow}{return} sqrt((m\_eval*m\_eval.adjoint())
00129                  .eval()
00130          .template selfadjointView<Lower>()
00131          .eigenvalues()
00132          .maxCoeff()
00133          );
00134 \}
00135 
00151 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} UpLo>
00152 \textcolor{keyword}{inline} \textcolor{keyword}{typename} \hyperlink{group___core___module_af9f0234ebeae4c4ca512bcd5fb5e8bb1}{SelfAdjointView<MatrixType, UpLo>::RealScalar}
00153 \hyperlink{group___core___module_a12a7da482e31ec9c517dca92dd7bae61}{SelfAdjointView<MatrixType, UpLo>::operatorNorm}()\textcolor{keyword}{ const}
00154 \textcolor{keyword}{}\{
00155   \textcolor{keywordflow}{return} eigenvalues().cwiseAbs().maxCoeff();
00156 \}
00157 
00158 \} \textcolor{comment}{// end namespace Eigen}
00159 
00160 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
