\hypertarget{eigen_2_eigen_2src_2_sparse_core_2_ambi_vector_8h_source}{}\section{eigen/\+Eigen/src/\+Sparse\+Core/\+Ambi\+Vector.h}
\label{eigen_2_eigen_2src_2_sparse_core_2_ambi_vector_8h_source}\index{Ambi\+Vector.\+h@{Ambi\+Vector.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_AMBIVECTOR\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_AMBIVECTOR\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keyword}{typename} \_StorageIndex>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_ambi_vector_8h_source_l00023}\hyperlink{class_eigen_1_1internal_1_1_ambi_vector}{00023} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1_ambi_vector}{AmbiVector}
00024 \{
00025   \textcolor{keyword}{public}:
00026     \textcolor{keyword}{typedef} \_Scalar Scalar;
00027     \textcolor{keyword}{typedef} \_StorageIndex StorageIndex;
00028     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00029 
00030     \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector}{AmbiVector}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size)
00031       : m\_buffer(0), m\_zero(0), m\_size(0), m\_allocatedSize(0), m\_allocatedElements(0), m\_mode(-1)
00032     \{
00033       resize(size);
00034     \}
00035 
00036     \textcolor{keywordtype}{void} \hyperlink{structinit}{init}(\textcolor{keywordtype}{double} estimatedDensity);
00037     \textcolor{keywordtype}{void} init(\textcolor{keywordtype}{int} mode);
00038 
00039     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector_ae0b137e95f52dea2320c16c379d27e74}{nonZeros}() \textcolor{keyword}{const};
00040 
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_ambi_vector_8h_source_l00042}\hyperlink{class_eigen_1_1internal_1_1_ambi_vector_a8a37e06682a29a63239d914de342096c}{00042}     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector_a8a37e06682a29a63239d914de342096c}{setBounds}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} start, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} end) \{ m\_start = convert\_index(start); m\_end = 
      convert\_index(end); \}
00043 
00044     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector_af472b476758307bcc1621d9eb4018f6a}{setZero}();
00045 
00046     \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector_a518fc22cdfa37e5340350e2a69fa8f1a}{restart}();
00047     Scalar& coeffRef(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i);
00048     Scalar& coeff(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i);
00049 
00050     \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1_ambi_vector_1_1_iterator}{Iterator};
00051 
00052     ~\hyperlink{class_eigen_1_1internal_1_1_ambi_vector}{AmbiVector}() \{ \textcolor{keyword}{delete}[] m\_buffer; \}
00053 
00054     \textcolor{keywordtype}{void} resize(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size)
00055     \{
00056       \textcolor{keywordflow}{if} (m\_allocatedSize < size)
00057         reallocate(size);
00058       m\_size = convert\_index(size);
00059     \}
00060 
00061     StorageIndex size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_size; \}
00062 
00063   \textcolor{keyword}{protected}:
00064     StorageIndex convert\_index(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} idx)
00065     \{
00066       \textcolor{keywordflow}{return} internal::convert\_index<StorageIndex>(idx);
00067     \}
00068 
00069     \textcolor{keywordtype}{void} reallocate(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size)
00070     \{
00071       \textcolor{comment}{// if the size of the matrix is not too large, let's allocate a bit more than needed such}
00072       \textcolor{comment}{// that we can handle dense vector even in sparse mode.}
00073       \textcolor{keyword}{delete}[] m\_buffer;
00074       \textcolor{keywordflow}{if} (size<1000)
00075       \{
00076         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} allocSize = (size * \textcolor{keyword}{sizeof}(\hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}) + \textcolor{keyword}{sizeof}(Scalar) - 1)/\textcolor{keyword}{sizeof}(Scalar);
00077         m\_allocatedElements = convert\_index((allocSize*\textcolor{keyword}{sizeof}(Scalar))/\textcolor{keyword}{sizeof}(
      \hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}));
00078         m\_buffer = \textcolor{keyword}{new} Scalar[allocSize];
00079       \}
00080       \textcolor{keywordflow}{else}
00081       \{
00082         m\_allocatedElements = convert\_index((size*\textcolor{keyword}{sizeof}(Scalar))/\textcolor{keyword}{sizeof}(\hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}));
00083         m\_buffer = \textcolor{keyword}{new} Scalar[size];
00084       \}
00085       m\_size = convert\_index(size);
00086       m\_start = 0;
00087       m\_end = m\_size;
00088     \}
00089 
00090     \textcolor{keywordtype}{void} reallocateSparse()
00091     \{
00092       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} copyElements = m\_allocatedElements;
00093       m\_allocatedElements = (std::min)(StorageIndex(m\_allocatedElements*1.5),m\_size);
00094       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} allocSize = m\_allocatedElements * \textcolor{keyword}{sizeof}(\hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl});
00095       allocSize = (allocSize + \textcolor{keyword}{sizeof}(Scalar) - 1)/\textcolor{keyword}{sizeof}(Scalar);
00096       Scalar* newBuffer = \textcolor{keyword}{new} Scalar[allocSize];
00097       memcpy(newBuffer,  m\_buffer,  copyElements * \textcolor{keyword}{sizeof}(\hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}));
00098       \textcolor{keyword}{delete}[] m\_buffer;
00099       m\_buffer = newBuffer;
00100     \}
00101 
00102   \textcolor{keyword}{protected}:
00103     \textcolor{comment}{// element type of the linked list}
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_ambi_vector_8h_source_l00104}\hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{00104}     \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}
00105     \{
00106       StorageIndex next;
00107       StorageIndex index;
00108       Scalar value;
00109     \};
00110 
00111     \textcolor{comment}{// used to store data in both mode}
00112     Scalar* m\_buffer;
00113     Scalar m\_zero;
00114     StorageIndex m\_size;
00115     StorageIndex m\_start;
00116     StorageIndex m\_end;
00117     StorageIndex m\_allocatedSize;
00118     StorageIndex m\_allocatedElements;
00119     StorageIndex m\_mode;
00120 
00121     \textcolor{comment}{// linked list mode}
00122     StorageIndex m\_llStart;
00123     StorageIndex m\_llCurrent;
00124     StorageIndex m\_llSize;
00125 \};
00126 
00128 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar,\textcolor{keyword}{typename} \_StorageIndex>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_ambi_vector_8h_source_l00129}\hyperlink{class_eigen_1_1internal_1_1_ambi_vector_ae0b137e95f52dea2320c16c379d27e74}{00129} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector_ae0b137e95f52dea2320c16c379d27e74}{AmbiVector<\_Scalar,\_StorageIndex>::nonZeros}()\textcolor{keyword}{ const}
00130 \textcolor{keyword}{}\{
00131   \textcolor{keywordflow}{if} (m\_mode==IsSparse)
00132     \textcolor{keywordflow}{return} m\_llSize;
00133   \textcolor{keywordflow}{else}
00134     \textcolor{keywordflow}{return} m\_end - m\_start;
00135 \}
00136 
00137 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar,\textcolor{keyword}{typename} \_StorageIndex>
00138 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector}{AmbiVector<\_Scalar,\_StorageIndex>::init}(\textcolor{keywordtype}{double} estimatedDensity
      )
00139 \{
00140   \textcolor{keywordflow}{if} (estimatedDensity>0.1)
00141     \hyperlink{structinit}{init}(IsDense);
00142   \textcolor{keywordflow}{else}
00143     \hyperlink{structinit}{init}(IsSparse);
00144 \}
00145 
00146 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar,\textcolor{keyword}{typename} \_StorageIndex>
00147 \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector}{AmbiVector<\_Scalar,\_StorageIndex>::init}(\textcolor{keywordtype}{int} mode)
00148 \{
00149   m\_mode = mode;
00150   \textcolor{keywordflow}{if} (m\_mode==IsSparse)
00151   \{
00152     m\_llSize = 0;
00153     m\_llStart = -1;
00154   \}
00155 \}
00156 
00162 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar,\textcolor{keyword}{typename} \_StorageIndex>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_ambi_vector_8h_source_l00163}\hyperlink{class_eigen_1_1internal_1_1_ambi_vector_a518fc22cdfa37e5340350e2a69fa8f1a}{00163} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector_a518fc22cdfa37e5340350e2a69fa8f1a}{AmbiVector<\_Scalar,\_StorageIndex>::restart}()
00164 \{
00165   m\_llCurrent = m\_llStart;
00166 \}
00167 
00169 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar,\textcolor{keyword}{typename} \_StorageIndex>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_ambi_vector_8h_source_l00170}\hyperlink{class_eigen_1_1internal_1_1_ambi_vector_af472b476758307bcc1621d9eb4018f6a}{00170} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector_af472b476758307bcc1621d9eb4018f6a}{AmbiVector<\_Scalar,\_StorageIndex>::setZero}()
00171 \{
00172   \textcolor{keywordflow}{if} (m\_mode==IsDense)
00173   \{
00174     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=m\_start; i<m\_end; ++i)
00175       m\_buffer[i] = Scalar(0);
00176   \}
00177   \textcolor{keywordflow}{else}
00178   \{
00179     eigen\_assert(m\_mode==IsSparse);
00180     m\_llSize = 0;
00181     m\_llStart = -1;
00182   \}
00183 \}
00184 
00185 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar,\textcolor{keyword}{typename} \_StorageIndex>
00186 \_Scalar& \hyperlink{class_eigen_1_1internal_1_1_ambi_vector}{AmbiVector<\_Scalar,\_StorageIndex>::coeffRef}(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i)
00187 \{
00188   \textcolor{keywordflow}{if} (m\_mode==IsDense)
00189     \textcolor{keywordflow}{return} m\_buffer[i];
00190   \textcolor{keywordflow}{else}
00191   \{
00192     \hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}* EIGEN\_RESTRICT llElements = \textcolor{keyword}{reinterpret\_cast<}\hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}*\textcolor{keyword}{>}(m\_buffer);
00193     \textcolor{comment}{// TODO factorize the following code to reduce code generation}
00194     eigen\_assert(m\_mode==IsSparse);
00195     \textcolor{keywordflow}{if} (m\_llSize==0)
00196     \{
00197       \textcolor{comment}{// this is the first element}
00198       m\_llStart = 0;
00199       m\_llCurrent = 0;
00200       ++m\_llSize;
00201       llElements[0].value = Scalar(0);
00202       llElements[0].index = convert\_index(i);
00203       llElements[0].next = -1;
00204       \textcolor{keywordflow}{return} llElements[0].value;
00205     \}
00206     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (i<llElements[m\_llStart].index)
00207     \{
00208       \textcolor{comment}{// this is going to be the new first element of the list}
00209       \hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}& el = llElements[m\_llSize];
00210       el.value = Scalar(0);
00211       el.index = convert\_index(i);
00212       el.next = m\_llStart;
00213       m\_llStart = m\_llSize;
00214       ++m\_llSize;
00215       m\_llCurrent = m\_llStart;
00216       \textcolor{keywordflow}{return} el.value;
00217     \}
00218     \textcolor{keywordflow}{else}
00219     \{
00220       StorageIndex nextel = llElements[m\_llCurrent].next;
00221       eigen\_assert(i>=llElements[m\_llCurrent].index && \textcolor{stringliteral}{"you must call restart() before inserting an element
       with lower or equal index"});
00222       \textcolor{keywordflow}{while} (nextel >= 0 && llElements[nextel].index<=i)
00223       \{
00224         m\_llCurrent = nextel;
00225         nextel = llElements[nextel].next;
00226       \}
00227 
00228       \textcolor{keywordflow}{if} (llElements[m\_llCurrent].index==i)
00229       \{
00230         \textcolor{comment}{// the coefficient already exists and we found it !}
00231         \textcolor{keywordflow}{return} llElements[m\_llCurrent].value;
00232       \}
00233       \textcolor{keywordflow}{else}
00234       \{
00235         \textcolor{keywordflow}{if} (m\_llSize>=m\_allocatedElements)
00236         \{
00237           reallocateSparse();
00238           llElements = \textcolor{keyword}{reinterpret\_cast<}\hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}*\textcolor{keyword}{>}(m\_buffer);
00239         \}
00240         eigen\_internal\_assert(m\_llSize<m\_allocatedElements && \textcolor{stringliteral}{"internal error: overflow in sparse mode"});
00241         \textcolor{comment}{// let's insert a new coefficient}
00242         \hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}& el = llElements[m\_llSize];
00243         el.value = Scalar(0);
00244         el.index = convert\_index(i);
00245         el.next = llElements[m\_llCurrent].next;
00246         llElements[m\_llCurrent].next = m\_llSize;
00247         ++m\_llSize;
00248         \textcolor{keywordflow}{return} el.value;
00249       \}
00250     \}
00251   \}
00252 \}
00253 
00254 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar,\textcolor{keyword}{typename} \_StorageIndex>
00255 \_Scalar& \hyperlink{class_eigen_1_1internal_1_1_ambi_vector}{AmbiVector<\_Scalar,\_StorageIndex>::coeff}(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i)
00256 \{
00257   \textcolor{keywordflow}{if} (m\_mode==IsDense)
00258     \textcolor{keywordflow}{return} m\_buffer[i];
00259   \textcolor{keywordflow}{else}
00260   \{
00261     \hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}* EIGEN\_RESTRICT llElements = \textcolor{keyword}{reinterpret\_cast<}\hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}*\textcolor{keyword}{>}(m\_buffer);
00262     eigen\_assert(m\_mode==IsSparse);
00263     \textcolor{keywordflow}{if} ((m\_llSize==0) || (i<llElements[m\_llStart].index))
00264     \{
00265       \textcolor{keywordflow}{return} m\_zero;
00266     \}
00267     \textcolor{keywordflow}{else}
00268     \{
00269       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} elid = m\_llStart;
00270       \textcolor{keywordflow}{while} (elid >= 0 && llElements[elid].index<i)
00271         elid = llElements[elid].next;
00272 
00273       \textcolor{keywordflow}{if} (llElements[elid].index==i)
00274         \textcolor{keywordflow}{return} llElements[m\_llCurrent].value;
00275       \textcolor{keywordflow}{else}
00276         \textcolor{keywordflow}{return} m\_zero;
00277     \}
00278   \}
00279 \}
00280 
00282 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar,\textcolor{keyword}{typename} \_StorageIndex>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_ambi_vector_8h_source_l00283}\hyperlink{class_eigen_1_1internal_1_1_ambi_vector_1_1_iterator}{00283} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1_ambi_vector}{AmbiVector}<\_Scalar,\_StorageIndex>::\hyperlink{class_eigen_1_1internal_1_1_ambi_vector_1_1_iterator}{Iterator}
00284 \{
00285   \textcolor{keyword}{public}:
00286     \textcolor{keyword}{typedef} \_Scalar Scalar;
00287     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00288 
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_ambi_vector_8h_source_l00295}\hyperlink{class_eigen_1_1internal_1_1_ambi_vector_1_1_iterator_a2201eecfa8e104d9f2017e47c5f24583}{00295}     \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector_1_1_iterator_a2201eecfa8e104d9f2017e47c5f24583}{Iterator}(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector}{AmbiVector}& vec, \textcolor{keyword}{const} RealScalar& epsilon = 0)
00296       : m\_vector(vec)
00297     \{
00298       \textcolor{keyword}{using} std::abs;
00299       m\_epsilon = epsilon;
00300       m\_isDense = m\_vector.m\_mode==IsDense;
00301       \textcolor{keywordflow}{if} (m\_isDense)
00302       \{
00303         m\_currentEl = 0;   \textcolor{comment}{// this is to avoid a compilation warning}
00304         m\_cachedValue = 0; \textcolor{comment}{// this is to avoid a compilation warning}
00305         m\_cachedIndex = m\_vector.m\_start-1;
00306         ++(*this);
00307       \}
00308       \textcolor{keywordflow}{else}
00309       \{
00310         \hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}* EIGEN\_RESTRICT llElements = \textcolor{keyword}{reinterpret\_cast<}\hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}*\textcolor{keyword}{>}(m\_vector.m\_buffer);
00311         m\_currentEl = m\_vector.m\_llStart;
00312         \textcolor{keywordflow}{while} (m\_currentEl>=0 && abs(llElements[m\_currentEl].value)<=m\_epsilon)
00313           m\_currentEl = llElements[m\_currentEl].next;
00314         \textcolor{keywordflow}{if} (m\_currentEl<0)
00315         \{
00316           m\_cachedValue = 0; \textcolor{comment}{// this is to avoid a compilation warning}
00317           m\_cachedIndex = -1;
00318         \}
00319         \textcolor{keywordflow}{else}
00320         \{
00321           m\_cachedIndex = llElements[m\_currentEl].index;
00322           m\_cachedValue = llElements[m\_currentEl].value;
00323         \}
00324       \}
00325     \}
00326 
00327     StorageIndex index()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_cachedIndex; \}
00328     Scalar value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_cachedValue; \}
00329 
00330     \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_cachedIndex>=0; \}
00331 
00332     \hyperlink{class_eigen_1_1internal_1_1_ambi_vector_1_1_iterator}{Iterator}& operator++()
00333     \{
00334       \textcolor{keyword}{using} std::abs;
00335       \textcolor{keywordflow}{if} (m\_isDense)
00336       \{
00337         \textcolor{keywordflow}{do} \{
00338           ++m\_cachedIndex;
00339         \} \textcolor{keywordflow}{while} (m\_cachedIndex<m\_vector.m\_end && abs(m\_vector.m\_buffer[m\_cachedIndex])<=m\_epsilon);
00340         \textcolor{keywordflow}{if} (m\_cachedIndex<m\_vector.m\_end)
00341           m\_cachedValue = m\_vector.m\_buffer[m\_cachedIndex];
00342         \textcolor{keywordflow}{else}
00343           m\_cachedIndex=-1;
00344       \}
00345       \textcolor{keywordflow}{else}
00346       \{
00347         \hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}* EIGEN\_RESTRICT llElements = \textcolor{keyword}{reinterpret\_cast<}\hyperlink{struct_eigen_1_1internal_1_1_ambi_vector_1_1_list_el}{ListEl}*\textcolor{keyword}{>}(m\_vector.m\_buffer);
00348         \textcolor{keywordflow}{do} \{
00349           m\_currentEl = llElements[m\_currentEl].next;
00350         \} \textcolor{keywordflow}{while} (m\_currentEl>=0 && abs(llElements[m\_currentEl].value)<=m\_epsilon);
00351         \textcolor{keywordflow}{if} (m\_currentEl<0)
00352         \{
00353           m\_cachedIndex = -1;
00354         \}
00355         \textcolor{keywordflow}{else}
00356         \{
00357           m\_cachedIndex = llElements[m\_currentEl].index;
00358           m\_cachedValue = llElements[m\_currentEl].value;
00359         \}
00360       \}
00361       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00362     \}
00363 
00364   \textcolor{keyword}{protected}:
00365     \textcolor{keyword}{const} \hyperlink{class_eigen_1_1internal_1_1_ambi_vector}{AmbiVector}& m\_vector; \textcolor{comment}{// the target vector}
00366     StorageIndex m\_currentEl;   \textcolor{comment}{// the current element in sparse/linked-list mode}
00367     RealScalar m\_epsilon;       \textcolor{comment}{// epsilon used to prune zero coefficients}
00368     StorageIndex m\_cachedIndex; \textcolor{comment}{// current coordinate}
00369     Scalar m\_cachedValue;       \textcolor{comment}{// current value}
00370     \textcolor{keywordtype}{bool} m\_isDense;             \textcolor{comment}{// mode of the vector}
00371 \};
00372 
00373 \} \textcolor{comment}{// end namespace internal}
00374 
00375 \} \textcolor{comment}{// end namespace Eigen}
00376 
00377 \textcolor{preprocessor}{#endif // EIGEN\_AMBIVECTOR\_H}
\end{DoxyCode}
