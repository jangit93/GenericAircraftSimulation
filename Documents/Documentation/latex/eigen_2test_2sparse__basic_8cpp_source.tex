\hypertarget{eigen_2test_2sparse__basic_8cpp_source}{}\section{eigen/test/sparse\+\_\+basic.cpp}
\label{eigen_2test_2sparse__basic_8cpp_source}\index{sparse\+\_\+basic.\+cpp@{sparse\+\_\+basic.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2011 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2008 Daniel Gomez Ferro <dgomezferro@gmail.com>}
00006 \textcolor{comment}{// Copyright (C) 2013 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00007 \textcolor{comment}{//}
00008 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00009 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00010 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00011 
00012 \textcolor{keyword}{static} \textcolor{keywordtype}{long} g\_realloc\_count = 0;
00013 \textcolor{preprocessor}{#define EIGEN\_SPARSE\_COMPRESSED\_STORAGE\_REALLOCATE\_PLUGIN g\_realloc\_count++;}
00014 
00015 \textcolor{preprocessor}{#include "sparse.h"}
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseMatrixType> \textcolor{keywordtype}{void} sparse\_basic(\textcolor{keyword}{const} SparseMatrixType& ref)
00018 \{
00019   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::StorageIndex StorageIndex;
00020   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<StorageIndex,2,1>} Vector2;
00021   
00022   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows = ref.rows();
00023   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols = ref.cols();
00024   \textcolor{comment}{//const Index inner = ref.innerSize();}
00025   \textcolor{comment}{//const Index outer = ref.outerSize();}
00026 
00027   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::Scalar Scalar;
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::RealScalar RealScalar;
00029   \textcolor{keyword}{enum} \{ Flags = SparseMatrixType::Flags \};
00030 
00031   \textcolor{keywordtype}{double} density = (std::max)(8./(rows*cols), 0.01);
00032   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} 
      \hyperlink{group___core___module}{DenseMatrix};
00033   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} \hyperlink{group___core___module}{DenseVector};
00034   Scalar eps = 1e-6;
00035 
00036   Scalar s1 = internal::random<Scalar>();
00037   \{
00038     SparseMatrixType m(rows, cols);
00039     DenseMatrix refMat = DenseMatrix::Zero(rows, cols);
00040     DenseVector vec1 = DenseVector::Random(rows);
00041 
00042     std::vector<Vector2> zeroCoords;
00043     std::vector<Vector2> nonzeroCoords;
00044     initSparse<Scalar>(density, refMat, m, 0, &zeroCoords, &nonzeroCoords);
00045 
00046     \textcolor{comment}{// test coeff and coeffRef}
00047     \textcolor{keywordflow}{for} (std::size\_t i=0; i<zeroCoords.size(); ++i)
00048     \{
00049       VERIFY\_IS\_MUCH\_SMALLER\_THAN( m.coeff(zeroCoords[i].x(),zeroCoords[i].y()), eps );
00050       \textcolor{keywordflow}{if}(internal::is\_same<SparseMatrixType,\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar,Flags>} >::value)
00051         VERIFY\_RAISES\_ASSERT( m.coeffRef(zeroCoords[i].x(),zeroCoords[i].y()) = 5 );
00052     \}
00053     VERIFY\_IS\_APPROX(m, refMat);
00054 
00055     \textcolor{keywordflow}{if}(!nonzeroCoords.empty()) \{
00056       m.coeffRef(nonzeroCoords[0].x(), nonzeroCoords[0].y()) = Scalar(5);
00057       refMat.coeffRef(nonzeroCoords[0].x(), nonzeroCoords[0].y()) = Scalar(5);
00058     \}
00059 
00060     VERIFY\_IS\_APPROX(m, refMat);
00061 
00062       \textcolor{comment}{// test assertion}
00063       VERIFY\_RAISES\_ASSERT( m.coeffRef(-1,1) = 0 );
00064       VERIFY\_RAISES\_ASSERT( m.coeffRef(0,m.cols()) = 0 );
00065     \}
00066 
00067     \textcolor{comment}{// test insert (inner random)}
00068     \{
00069       DenseMatrix m1(rows,cols);
00070       m1.setZero();
00071       SparseMatrixType m2(rows,cols);
00072       \textcolor{keywordtype}{bool} call\_reserve = internal::random<int>()%2;
00073       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nnz = internal::random<int>(1,int(rows)/2);
00074       \textcolor{keywordflow}{if}(call\_reserve)
00075       \{
00076         \textcolor{keywordflow}{if}(internal::random<int>()%2)
00077           m2.reserve(VectorXi::Constant(m2.outerSize(), int(nnz)));
00078         \textcolor{keywordflow}{else}
00079           m2.reserve(m2.outerSize() * nnz);
00080       \}
00081       g\_realloc\_count = 0;
00082       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<cols; ++j)
00083       \{
00084         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<nnz; ++k)
00085         \{
00086           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = internal::random<Index>(0,rows-1);
00087           \textcolor{keywordflow}{if} (m1.coeff(i,j)==Scalar(0))
00088             m2.insert(i,j) = m1(i,j) = internal::random<Scalar>();
00089         \}
00090       \}
00091       
00092       \textcolor{keywordflow}{if}(call\_reserve && !SparseMatrixType::IsRowMajor)
00093       \{
00094         VERIFY(g\_realloc\_count==0);
00095       \}
00096       
00097       m2.finalize();
00098       VERIFY\_IS\_APPROX(m2,m1);
00099     \}
00100 
00101     \textcolor{comment}{// test insert (fully random)}
00102     \{
00103       DenseMatrix m1(rows,cols);
00104       m1.setZero();
00105       SparseMatrixType m2(rows,cols);
00106       \textcolor{keywordflow}{if}(internal::random<int>()%2)
00107         m2.reserve(VectorXi::Constant(m2.outerSize(), 2));
00108       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<rows*cols; ++k)
00109       \{
00110         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = internal::random<Index>(0,rows-1);
00111         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = internal::random<Index>(0,cols-1);
00112         \textcolor{keywordflow}{if} ((m1.coeff(i,j)==Scalar(0)) && (internal::random<int>()%2))
00113           m2.insert(i,j) = m1(i,j) = internal::random<Scalar>();
00114         \textcolor{keywordflow}{else}
00115         \{
00116           Scalar v = internal::random<Scalar>();
00117           m2.coeffRef(i,j) += v;
00118           m1(i,j) += v;
00119         \}
00120       \}
00121       VERIFY\_IS\_APPROX(m2,m1);
00122     \}
00123     
00124     \textcolor{comment}{// test insert (un-compressed)}
00125     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} mode=0;mode<4;++mode)
00126     \{
00127       DenseMatrix m1(rows,cols);
00128       m1.setZero();
00129       SparseMatrixType m2(rows,cols);
00130       VectorXi r(VectorXi::Constant(m2.outerSize(), ((mode%2)==0) ? int(m2.innerSize()) : std::max<int>(1,\textcolor{keywordtype}{
      int}(m2.innerSize())/8)));
00131       m2.reserve(r);
00132       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<rows*cols; ++k)
00133       \{
00134         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = internal::random<Index>(0,rows-1);
00135         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = internal::random<Index>(0,cols-1);
00136         \textcolor{keywordflow}{if} (m1.coeff(i,j)==Scalar(0))
00137           m2.insert(i,j) = m1(i,j) = internal::random<Scalar>();
00138         \textcolor{keywordflow}{if}(mode==3)
00139           m2.reserve(r);
00140       \}
00141       \textcolor{keywordflow}{if}(internal::random<int>()%2)
00142         m2.makeCompressed();
00143       VERIFY\_IS\_APPROX(m2,m1);
00144     \}
00145 
00146   \textcolor{comment}{// test basic computations}
00147   \{
00148     DenseMatrix refM1 = DenseMatrix::Zero(rows, cols);
00149     DenseMatrix refM2 = DenseMatrix::Zero(rows, cols);
00150     DenseMatrix refM3 = DenseMatrix::Zero(rows, cols);
00151     DenseMatrix refM4 = DenseMatrix::Zero(rows, cols);
00152     SparseMatrixType m1(rows, cols);
00153     SparseMatrixType m2(rows, cols);
00154     SparseMatrixType m3(rows, cols);
00155     SparseMatrixType m4(rows, cols);
00156     initSparse<Scalar>(density, refM1, m1);
00157     initSparse<Scalar>(density, refM2, m2);
00158     initSparse<Scalar>(density, refM3, m3);
00159     initSparse<Scalar>(density, refM4, m4);
00160 
00161     \textcolor{keywordflow}{if}(internal::random<bool>())
00162       m1.makeCompressed();
00163 
00164     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m1\_nnz = m1.nonZeros();
00165 
00166     VERIFY\_IS\_APPROX(m1*s1, refM1*s1);
00167     VERIFY\_IS\_APPROX(m1+m2, refM1+refM2);
00168     VERIFY\_IS\_APPROX(m1+m2+m3, refM1+refM2+refM3);
00169     VERIFY\_IS\_APPROX(m3.cwiseProduct(m1+m2), refM3.cwiseProduct(refM1+refM2));
00170     VERIFY\_IS\_APPROX(m1*s1-m2, refM1*s1-refM2);
00171     VERIFY\_IS\_APPROX(m4=m1/s1, refM1/s1);
00172     VERIFY\_IS\_EQUAL(m4.nonZeros(), m1\_nnz);
00173 
00174     \textcolor{keywordflow}{if}(SparseMatrixType::IsRowMajor)
00175       VERIFY\_IS\_APPROX(m1.innerVector(0).dot(refM2.row(0)), refM1.row(0).dot(refM2.row(0)));
00176     \textcolor{keywordflow}{else}
00177       VERIFY\_IS\_APPROX(m1.innerVector(0).dot(refM2.col(0)), refM1.col(0).dot(refM2.col(0)));
00178 
00179     DenseVector rv = DenseVector::Random(m1.cols());
00180     DenseVector cv = DenseVector::Random(m1.rows());
00181     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} r = internal::random<Index>(0,m1.rows()-2);
00182     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} c = internal::random<Index>(0,m1.cols()-1);
00183     VERIFY\_IS\_APPROX(( m1.template block<1,Dynamic>(r,0,1,m1.cols()).dot(rv)) , refM1.row(r).dot(rv));
00184     VERIFY\_IS\_APPROX(m1.row(r).dot(rv), refM1.row(r).dot(rv));
00185     VERIFY\_IS\_APPROX(m1.col(c).dot(cv), refM1.col(c).dot(cv));
00186 
00187     VERIFY\_IS\_APPROX(m1.conjugate(), refM1.conjugate());
00188     VERIFY\_IS\_APPROX(m1.real(), refM1.real());
00189 
00190     refM4.setRandom();
00191     \textcolor{comment}{// sparse cwise* dense}
00192     VERIFY\_IS\_APPROX(m3.cwiseProduct(refM4), refM3.cwiseProduct(refM4));
00193     \textcolor{comment}{// dense cwise* sparse}
00194     VERIFY\_IS\_APPROX(refM4.cwiseProduct(m3), refM4.cwiseProduct(refM3));
00195 \textcolor{comment}{//     VERIFY\_IS\_APPROX(m3.cwise()/refM4, refM3.cwise()/refM4);}
00196 
00197     VERIFY\_IS\_APPROX(refM4 + m3, refM4 + refM3);
00198     VERIFY\_IS\_APPROX(m3 + refM4, refM3 + refM4);
00199     VERIFY\_IS\_APPROX(refM4 - m3, refM4 - refM3);
00200     VERIFY\_IS\_APPROX(m3 - refM4, refM3 - refM4);
00201     VERIFY\_IS\_APPROX((RealScalar(0.5)*refM4 + RealScalar(0.5)*m3).eval(), RealScalar(0.5)*refM4 + 
      RealScalar(0.5)*refM3);
00202     VERIFY\_IS\_APPROX((RealScalar(0.5)*refM4 + m3*RealScalar(0.5)).eval(), RealScalar(0.5)*refM4 + 
      RealScalar(0.5)*refM3);
00203     VERIFY\_IS\_APPROX((RealScalar(0.5)*refM4 + m3.cwiseProduct(m3)).eval(), RealScalar(0.5)*refM4 + refM3.
      cwiseProduct(refM3));
00204 
00205     VERIFY\_IS\_APPROX((RealScalar(0.5)*refM4 + RealScalar(0.5)*m3).eval(), RealScalar(0.5)*refM4 + 
      RealScalar(0.5)*refM3);
00206     VERIFY\_IS\_APPROX((RealScalar(0.5)*refM4 + m3*RealScalar(0.5)).eval(), RealScalar(0.5)*refM4 + 
      RealScalar(0.5)*refM3);
00207     VERIFY\_IS\_APPROX((RealScalar(0.5)*refM4 + (m3+m3)).eval(), RealScalar(0.5)*refM4 + (refM3+refM3));
00208     VERIFY\_IS\_APPROX(((refM3+m3)+RealScalar(0.5)*m3).eval(), RealScalar(0.5)*refM3 + (refM3+refM3));
00209     VERIFY\_IS\_APPROX((RealScalar(0.5)*refM4 + (refM3+m3)).eval(), RealScalar(0.5)*refM4 + (refM3+refM3));
00210     VERIFY\_IS\_APPROX((RealScalar(0.5)*refM4 + (m3+refM3)).eval(), RealScalar(0.5)*refM4 + (refM3+refM3));
00211 
00212 
00213     VERIFY\_IS\_APPROX(m1.sum(), refM1.sum());
00214 
00215     m4 = m1; refM4 = m4;
00216 
00217     VERIFY\_IS\_APPROX(m1*=s1, refM1*=s1);
00218     VERIFY\_IS\_EQUAL(m1.nonZeros(), m1\_nnz);
00219     VERIFY\_IS\_APPROX(m1/=s1, refM1/=s1);
00220     VERIFY\_IS\_EQUAL(m1.nonZeros(), m1\_nnz);
00221 
00222     VERIFY\_IS\_APPROX(m1+=m2, refM1+=refM2);
00223     VERIFY\_IS\_APPROX(m1-=m2, refM1-=refM2);
00224 
00225     \textcolor{keywordflow}{if} (rows>=2 && cols>=2)
00226     \{
00227       VERIFY\_RAISES\_ASSERT( m1 += m1.innerVector(0) );
00228       VERIFY\_RAISES\_ASSERT( m1 -= m1.innerVector(0) );
00229       VERIFY\_RAISES\_ASSERT( refM1 -= m1.innerVector(0) );
00230       VERIFY\_RAISES\_ASSERT( refM1 += m1.innerVector(0) );
00231       m1 = m4; refM1 = refM4;
00232     \}
00233 
00234     \textcolor{comment}{// test aliasing}
00235     VERIFY\_IS\_APPROX((m1 = -m1), (refM1 = -refM1));
00236     VERIFY\_IS\_EQUAL(m1.nonZeros(), m1\_nnz);
00237     m1 = m4; refM1 = refM4;
00238     VERIFY\_IS\_APPROX((m1 = m1.transpose()), (refM1 = refM1.transpose().eval()));
00239     VERIFY\_IS\_EQUAL(m1.nonZeros(), m1\_nnz);
00240     m1 = m4; refM1 = refM4;
00241     VERIFY\_IS\_APPROX((m1 = -m1.transpose()), (refM1 = -refM1.transpose().eval()));
00242     VERIFY\_IS\_EQUAL(m1.nonZeros(), m1\_nnz);
00243     m1 = m4; refM1 = refM4;
00244     VERIFY\_IS\_APPROX((m1 += -m1), (refM1 += -refM1));
00245     VERIFY\_IS\_EQUAL(m1.nonZeros(), m1\_nnz);
00246     m1 = m4; refM1 = refM4;
00247 
00248     \textcolor{keywordflow}{if}(m1.isCompressed())
00249     \{
00250       VERIFY\_IS\_APPROX(m1.coeffs().sum(), m1.sum());
00251       m1.coeffs() += s1;
00252       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j<m1.outerSize(); ++j)
00253         \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} SparseMatrixType::InnerIterator it(m1,j); it; ++it)
00254           refM1(it.row(), it.col()) += s1;
00255       VERIFY\_IS\_APPROX(m1, refM1);
00256     \}
00257 
00258     \textcolor{comment}{// and/or}
00259     \{
00260       \textcolor{keyword}{typedef} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<bool, SparseMatrixType::Options, typename SparseMatrixType::StorageIndex>}
       SpBool;
00261       SpBool mb1 = m1.\hyperlink{group___sparse_core___module_a8a21aa3017e094f1c07be866d47d7539}{real}().template cast<bool>();
00262       SpBool mb2 = m2.real().template cast<bool>();
00263       VERIFY\_IS\_EQUAL(mb1.template cast<int>().sum(), refM1.real().template cast<bool>().count());
00264       VERIFY\_IS\_EQUAL((mb1 && mb2).\textcolor{keyword}{template} cast<int>().sum(), (refM1.real().template cast<bool>() && refM2
      .real().template cast<bool>()).count());
00265       VERIFY\_IS\_EQUAL((mb1 || mb2).\textcolor{keyword}{template} cast<int>().sum(), (refM1.real().template cast<bool>() || refM2
      .real().template cast<bool>()).count());
00266       SpBool mb3 = mb1 && mb2;
00267       \textcolor{keywordflow}{if}(mb1.coeffs().all() && mb2.coeffs().all())
00268       \{
00269         VERIFY\_IS\_EQUAL(mb3.nonZeros(), (refM1.real().template cast<bool>() && refM2.real().template 
      cast<bool>()).count());
00270       \}
00271     \}
00272   \}
00273 
00274   \textcolor{comment}{// test reverse iterators}
00275   \{
00276     DenseMatrix refMat2 = DenseMatrix::Zero(rows, cols);
00277     SparseMatrixType m2(rows, cols);
00278     initSparse<Scalar>(density, refMat2, m2);
00279     std::vector<Scalar> ref\_value(m2.innerSize());
00280     std::vector<Index> ref\_index(m2.innerSize());
00281     \textcolor{keywordflow}{if}(internal::random<bool>())
00282       m2.makeCompressed();
00283     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j<m2.outerSize(); ++j)
00284     \{
00285       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} count\_forward = 0;
00286 
00287       \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} SparseMatrixType::InnerIterator it(m2,j); it; ++it)
00288       \{
00289         ref\_value[ref\_value.size()-1-count\_forward] = it.value();
00290         ref\_index[ref\_index.size()-1-count\_forward] = it.index();
00291         count\_forward++;
00292       \}
00293       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} count\_reverse = 0;
00294       \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} SparseMatrixType::ReverseInnerIterator it(m2,j); it; --it)
00295       \{
00296         VERIFY\_IS\_APPROX( std::abs(ref\_value[ref\_value.size()-count\_forward+count\_reverse])+1, std::abs(it.
      value())+1);
00297         VERIFY\_IS\_EQUAL( ref\_index[ref\_index.size()-count\_forward+count\_reverse] , it.index());
00298         count\_reverse++;
00299       \}
00300       VERIFY\_IS\_EQUAL(count\_forward, count\_reverse);
00301     \}
00302   \}
00303 
00304   \textcolor{comment}{// test transpose}
00305   \{
00306     DenseMatrix refMat2 = DenseMatrix::Zero(rows, cols);
00307     SparseMatrixType m2(rows, cols);
00308     initSparse<Scalar>(density, refMat2, m2);
00309     VERIFY\_IS\_APPROX(m2.transpose().eval(), refMat2.transpose().eval());
00310     VERIFY\_IS\_APPROX(m2.transpose(), refMat2.transpose());
00311 
00312     VERIFY\_IS\_APPROX(SparseMatrixType(m2.adjoint()), refMat2.adjoint());
00313     
00314     \textcolor{comment}{// check isApprox handles opposite storage order}
00315     \textcolor{keyword}{typename} \hyperlink{group___core___module_class_eigen_1_1_transpose}{Transpose<SparseMatrixType>::PlainObject} m3(m2);
00316     VERIFY(m2.isApprox(m3));
00317   \}
00318 
00319   \textcolor{comment}{// test prune}
00320   \{
00321     SparseMatrixType m2(rows, cols);
00322     DenseMatrix refM2(rows, cols);
00323     refM2.setZero();
00324     \textcolor{keywordtype}{int} countFalseNonZero = 0;
00325     \textcolor{keywordtype}{int} countTrueNonZero = 0;
00326     m2.reserve(VectorXi::Constant(m2.outerSize(), int(m2.innerSize())));
00327     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<m2.cols(); ++j)
00328     \{
00329       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<m2.rows(); ++i)
00330       \{
00331         \textcolor{keywordtype}{float} x = internal::random<float>(0,1);
00332         \textcolor{keywordflow}{if} (x<0.1f)
00333         \{
00334           \textcolor{comment}{// do nothing}
00335         \}
00336         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x<0.5f)
00337         \{
00338           countFalseNonZero++;
00339           m2.insert(i,j) = Scalar(0);
00340         \}
00341         \textcolor{keywordflow}{else}
00342         \{
00343           countTrueNonZero++;
00344           m2.insert(i,j) = Scalar(1);
00345           refM2(i,j) = Scalar(1);
00346         \}
00347       \}
00348     \}
00349     \textcolor{keywordflow}{if}(internal::random<bool>())
00350       m2.makeCompressed();
00351     VERIFY(countFalseNonZero+countTrueNonZero == m2.nonZeros());
00352     \textcolor{keywordflow}{if}(countTrueNonZero>0)
00353       VERIFY\_IS\_APPROX(m2, refM2);
00354     m2.prune(Scalar(1));
00355     VERIFY(countTrueNonZero==m2.nonZeros());
00356     VERIFY\_IS\_APPROX(m2, refM2);
00357   \}
00358 
00359   \textcolor{comment}{// test setFromTriplets}
00360   \{
00361     \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{Triplet<Scalar,StorageIndex>} TripletType;
00362     std::vector<TripletType> triplets;
00363     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} ntriplets = rows*cols;
00364     triplets.reserve(ntriplets);
00365     DenseMatrix refMat\_sum  = DenseMatrix::Zero(rows,cols);
00366     DenseMatrix refMat\_prod = DenseMatrix::Zero(rows,cols);
00367     DenseMatrix refMat\_last = DenseMatrix::Zero(rows,cols);
00368 
00369     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0;i<ntriplets;++i)
00370     \{
00371       StorageIndex r = internal::random<StorageIndex>(0,StorageIndex(rows-1));
00372       StorageIndex c = internal::random<StorageIndex>(0,StorageIndex(cols-1));
00373       Scalar v = internal::random<Scalar>();
00374       triplets.push\_back(TripletType(r,c,v));
00375       refMat\_sum(r,c) += v;
00376       \textcolor{keywordflow}{if}(std::abs(refMat\_prod(r,c))==0)
00377         refMat\_prod(r,c) = v;
00378       \textcolor{keywordflow}{else}
00379         refMat\_prod(r,c) *= v;
00380       refMat\_last(r,c) = v;
00381     \}
00382     SparseMatrixType m(rows,cols);
00383     m.setFromTriplets(triplets.begin(), triplets.end());
00384     VERIFY\_IS\_APPROX(m, refMat\_sum);
00385 
00386     m.setFromTriplets(triplets.begin(), triplets.end(), std::multiplies<Scalar>());
00387     VERIFY\_IS\_APPROX(m, refMat\_prod);
00388 \textcolor{preprocessor}{#if (defined(\_\_cplusplus) && \_\_cplusplus >= 201103L)}
00389     m.setFromTriplets(triplets.begin(), triplets.end(), [] (Scalar,Scalar b) \{ \textcolor{keywordflow}{return} b; \});
00390     VERIFY\_IS\_APPROX(m, refMat\_last);
00391 \textcolor{preprocessor}{#endif}
00392   \}
00393   
00394   \textcolor{comment}{// test Map}
00395   \{
00396     DenseMatrix refMat2(rows, cols), refMat3(rows, cols);
00397     SparseMatrixType m2(rows, cols), m3(rows, cols);
00398     initSparse<Scalar>(density, refMat2, m2);
00399     initSparse<Scalar>(density, refMat3, m3);
00400     \{
00401       \hyperlink{group___core___module_class_eigen_1_1_map}{Map<SparseMatrixType>} mapMat2(m2.rows(), m2.cols(), m2.nonZeros(), m2.
      outerIndexPtr(), m2.innerIndexPtr(), m2.valuePtr(), m2.innerNonZeroPtr());
00402       \hyperlink{group___core___module_class_eigen_1_1_map}{Map<SparseMatrixType>} mapMat3(m3.rows(), m3.cols(), m3.nonZeros(), m3.
      outerIndexPtr(), m3.innerIndexPtr(), m3.valuePtr(), m3.innerNonZeroPtr());
00403       VERIFY\_IS\_APPROX(mapMat2+mapMat3, refMat2+refMat3);
00404       VERIFY\_IS\_APPROX(mapMat2+mapMat3, refMat2+refMat3);
00405     \}
00406     \{
00407       \hyperlink{class_eigen_1_1_mapped_sparse_matrix}{MappedSparseMatrix<Scalar,SparseMatrixType::Options,StorageIndex>}
       mapMat2(m2.rows(), m2.cols(), m2.nonZeros(), m2.outerIndexPtr(), m2.innerIndexPtr(), m2.valuePtr(), m2.
      innerNonZeroPtr());
00408       \hyperlink{class_eigen_1_1_mapped_sparse_matrix}{MappedSparseMatrix<Scalar,SparseMatrixType::Options,StorageIndex>}
       mapMat3(m3.rows(), m3.cols(), m3.nonZeros(), m3.outerIndexPtr(), m3.innerIndexPtr(), m3.valuePtr(), m3.
      innerNonZeroPtr());
00409       VERIFY\_IS\_APPROX(mapMat2+mapMat3, refMat2+refMat3);
00410       VERIFY\_IS\_APPROX(mapMat2+mapMat3, refMat2+refMat3);
00411     \}
00412 
00413     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = internal::random<Index>(0,rows-1);
00414     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = internal::random<Index>(0,cols-1);
00415     m2.coeffRef(i,j) = 123;
00416     \textcolor{keywordflow}{if}(internal::random<bool>())
00417       m2.makeCompressed();
00418     \hyperlink{group___core___module_class_eigen_1_1_map}{Map<SparseMatrixType>} mapMat2(rows, cols, m2.nonZeros(), m2.outerIndexPtr(), m2.
      innerIndexPtr(), m2.valuePtr(),  m2.innerNonZeroPtr());
00419     VERIFY\_IS\_EQUAL(m2.coeff(i,j),Scalar(123));
00420     VERIFY\_IS\_EQUAL(mapMat2.coeff(i,j),Scalar(123));
00421     mapMat2.coeffRef(i,j) = -123;
00422     VERIFY\_IS\_EQUAL(m2.coeff(i,j),Scalar(-123));
00423   \}
00424 
00425   \textcolor{comment}{// test triangularView}
00426   \{
00427     DenseMatrix refMat2(rows, cols), refMat3(rows, cols);
00428     SparseMatrixType m2(rows, cols), m3(rows, cols);
00429     initSparse<Scalar>(density, refMat2, m2);
00430     refMat3 = refMat2.template triangularView<Lower>();
00431     m3 = m2.template triangularView<Lower>();
00432     VERIFY\_IS\_APPROX(m3, refMat3);
00433 
00434     refMat3 = refMat2.template triangularView<Upper>();
00435     m3 = m2.template triangularView<Upper>();
00436     VERIFY\_IS\_APPROX(m3, refMat3);
00437 
00438     \{
00439       refMat3 = refMat2.template triangularView<UnitUpper>();
00440       m3 = m2.template triangularView<UnitUpper>();
00441       VERIFY\_IS\_APPROX(m3, refMat3);
00442 
00443       refMat3 = refMat2.template triangularView<UnitLower>();
00444       m3 = m2.template triangularView<UnitLower>();
00445       VERIFY\_IS\_APPROX(m3, refMat3);
00446     \}
00447 
00448     refMat3 = refMat2.template triangularView<StrictlyUpper>();
00449     m3 = m2.template triangularView<StrictlyUpper>();
00450     VERIFY\_IS\_APPROX(m3, refMat3);
00451 
00452     refMat3 = refMat2.template triangularView<StrictlyLower>();
00453     m3 = m2.template triangularView<StrictlyLower>();
00454     VERIFY\_IS\_APPROX(m3, refMat3);
00455 
00456     \textcolor{comment}{// check sparse-triangular to dense}
00457     refMat3 = m2.template triangularView<StrictlyUpper>();
00458     VERIFY\_IS\_APPROX(refMat3, DenseMatrix(refMat2.template triangularView<StrictlyUpper>()));
00459   \}
00460   
00461   \textcolor{comment}{// test selfadjointView}
00462   \textcolor{keywordflow}{if}(!SparseMatrixType::IsRowMajor)
00463   \{
00464     DenseMatrix refMat2(rows, rows), refMat3(rows, rows);
00465     SparseMatrixType m2(rows, rows), m3(rows, rows);
00466     initSparse<Scalar>(density, refMat2, m2);
00467     refMat3 = refMat2.template selfadjointView<Lower>();
00468     m3 = m2.template selfadjointView<Lower>();
00469     VERIFY\_IS\_APPROX(m3, refMat3);
00470 
00471     refMat3 += refMat2.template selfadjointView<Lower>();
00472     m3 += m2.template selfadjointView<Lower>();
00473     VERIFY\_IS\_APPROX(m3, refMat3);
00474 
00475     refMat3 -= refMat2.template selfadjointView<Lower>();
00476     m3 -= m2.template selfadjointView<Lower>();
00477     VERIFY\_IS\_APPROX(m3, refMat3);
00478 
00479     \textcolor{comment}{// selfadjointView only works for square matrices:}
00480     SparseMatrixType m4(rows, rows+1);
00481     VERIFY\_RAISES\_ASSERT(m4.template selfadjointView<Lower>());
00482     VERIFY\_RAISES\_ASSERT(m4.template selfadjointView<Upper>());
00483   \}
00484   
00485   \textcolor{comment}{// test sparseView}
00486   \{
00487     DenseMatrix refMat2 = DenseMatrix::Zero(rows, rows);
00488     SparseMatrixType m2(rows, rows);
00489     initSparse<Scalar>(density, refMat2, m2);
00490     VERIFY\_IS\_APPROX(m2.eval(), refMat2.sparseView().eval());
00491 
00492     \textcolor{comment}{// sparse view on expressions:}
00493     VERIFY\_IS\_APPROX((s1*m2).eval(), (s1*refMat2).sparseView().eval());
00494     VERIFY\_IS\_APPROX((m2+m2).eval(), (refMat2+refMat2).sparseView().eval());
00495     VERIFY\_IS\_APPROX((m2*m2).eval(), (refMat2.lazyProduct(refMat2)).sparseView().eval());
00496     VERIFY\_IS\_APPROX((m2*m2).eval(), (refMat2*refMat2).sparseView().eval());
00497   \}
00498 
00499   \textcolor{comment}{// test diagonal}
00500   \{
00501     DenseMatrix refMat2 = DenseMatrix::Zero(rows, cols);
00502     SparseMatrixType m2(rows, cols);
00503     initSparse<Scalar>(density, refMat2, m2);
00504     VERIFY\_IS\_APPROX(m2.diagonal(), refMat2.diagonal().eval());
00505     DenseVector d = m2.diagonal();
00506     VERIFY\_IS\_APPROX(d, refMat2.diagonal().eval());
00507     d = m2.diagonal().array();
00508     VERIFY\_IS\_APPROX(d, refMat2.diagonal().eval());
00509     VERIFY\_IS\_APPROX(const\_cast<const SparseMatrixType&>(m2).diagonal(), refMat2.diagonal().eval());
00510     
00511     initSparse<Scalar>(density, refMat2, m2, ForceNonZeroDiag);
00512     m2.diagonal()      += refMat2.diagonal();
00513     refMat2.diagonal() += refMat2.diagonal();
00514     VERIFY\_IS\_APPROX(m2, refMat2);
00515   \}
00516   
00517   \textcolor{comment}{// test diagonal to sparse}
00518   \{
00519     DenseVector d = DenseVector::Random(rows);
00520     DenseMatrix refMat2 = d.asDiagonal();
00521     SparseMatrixType m2(rows, rows);
00522     m2 = d.asDiagonal();
00523     VERIFY\_IS\_APPROX(m2, refMat2);
00524     SparseMatrixType m3(d.asDiagonal());
00525     VERIFY\_IS\_APPROX(m3, refMat2);
00526     refMat2 += d.asDiagonal();
00527     m2 += d.asDiagonal();
00528     VERIFY\_IS\_APPROX(m2, refMat2);
00529   \}
00530   
00531   \textcolor{comment}{// test conservative resize}
00532   \{
00533       std::vector< std::pair<StorageIndex,StorageIndex> > inc;
00534       \textcolor{keywordflow}{if}(rows > 3 && cols > 2)
00535         inc.push\_back(std::pair<StorageIndex,StorageIndex>(-3,-2));
00536       inc.push\_back(std::pair<StorageIndex,StorageIndex>(0,0));
00537       inc.push\_back(std::pair<StorageIndex,StorageIndex>(3,2));
00538       inc.push\_back(std::pair<StorageIndex,StorageIndex>(3,0));
00539       inc.push\_back(std::pair<StorageIndex,StorageIndex>(0,3));
00540       
00541       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i< inc.size(); i++) \{
00542         StorageIndex incRows = inc[i].first;
00543         StorageIndex incCols = inc[i].second;
00544         SparseMatrixType m1(rows, cols);
00545         DenseMatrix refMat1 = DenseMatrix::Zero(rows, cols);
00546         initSparse<Scalar>(density, refMat1, m1);
00547         
00548         m1.conservativeResize(rows+incRows, cols+incCols);
00549         refMat1.conservativeResize(rows+incRows, cols+incCols);
00550         \textcolor{keywordflow}{if} (incRows > 0) refMat1.bottomRows(incRows).setZero();
00551         \textcolor{keywordflow}{if} (incCols > 0) refMat1.rightCols(incCols).setZero();
00552         
00553         VERIFY\_IS\_APPROX(m1, refMat1);
00554         
00555         \textcolor{comment}{// Insert new values}
00556         \textcolor{keywordflow}{if} (incRows > 0) 
00557           m1.insert(m1.rows()-1, 0) = refMat1(refMat1.rows()-1, 0) = 1;
00558         \textcolor{keywordflow}{if} (incCols > 0) 
00559           m1.insert(0, m1.cols()-1) = refMat1(0, refMat1.cols()-1) = 1;
00560           
00561         VERIFY\_IS\_APPROX(m1, refMat1);
00562           
00563           
00564       \}
00565   \}
00566 
00567   \textcolor{comment}{// test Identity matrix}
00568   \{
00569     DenseMatrix refMat1 = DenseMatrix::Identity(rows, rows);
00570     SparseMatrixType m1(rows, rows);
00571     m1.setIdentity();
00572     VERIFY\_IS\_APPROX(m1, refMat1);
00573     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<rows*rows/4; ++k)
00574     \{
00575       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = internal::random<Index>(0,rows-1);
00576       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = internal::random<Index>(0,rows-1);
00577       Scalar v = internal::random<Scalar>();
00578       m1.coeffRef(i,j) = v;
00579       refMat1.\hyperlink{class_eigen_1_1_plain_object_base_a25626a55b26a4323565f79d1b7c48ea8}{coeffRef}(i,j) = v;
00580       VERIFY\_IS\_APPROX(m1, refMat1);
00581       \textcolor{keywordflow}{if}(internal::random<Index>(0,10)<2)
00582         m1.makeCompressed();
00583     \}
00584     m1.setIdentity();
00585     refMat1.setIdentity();
00586     VERIFY\_IS\_APPROX(m1, refMat1);
00587   \}
00588 
00589   \textcolor{comment}{// test array/vector of InnerIterator}
00590   \{
00591     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::InnerIterator IteratorType;
00592 
00593     DenseMatrix refMat2 = DenseMatrix::Zero(rows, cols);
00594     SparseMatrixType m2(rows, cols);
00595     initSparse<Scalar>(density, refMat2, m2);
00596     IteratorType static\_array[2];
00597     static\_array[0] = IteratorType(m2,0);
00598     static\_array[1] = IteratorType(m2,m2.outerSize()-1);
00599     VERIFY( static\_array[0] || m2.innerVector(static\_array[0].outer()).nonZeros() == 0 );
00600     VERIFY( static\_array[1] || m2.innerVector(static\_array[1].outer()).nonZeros() == 0 );
00601     \textcolor{keywordflow}{if}(static\_array[0] && static\_array[1])
00602     \{
00603       ++(static\_array[1]);
00604       static\_array[1] = IteratorType(m2,0);
00605       VERIFY( static\_array[1] );
00606       VERIFY( static\_array[1].index() == static\_array[0].index() );
00607       VERIFY( static\_array[1].outer() == static\_array[0].outer() );
00608       VERIFY( static\_array[1].value() == static\_array[0].value() );
00609     \}
00610 
00611     std::vector<IteratorType> iters(2);
00612     iters[0] = IteratorType(m2,0);
00613     iters[1] = IteratorType(m2,m2.outerSize()-1);
00614   \}
00615 \}
00616 
00617 
00618 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseMatrixType>
00619 \textcolor{keywordtype}{void} big\_sparse\_triplet(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, \textcolor{keywordtype}{double} density) \{
00620   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::StorageIndex StorageIndex;
00621   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::Scalar Scalar;
00622   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{Triplet<Scalar,Index>} TripletType;
00623   std::vector<TripletType> triplets;
00624   \textcolor{keywordtype}{double} nelements = density * rows*cols;
00625   VERIFY(nelements>=0 && nelements <  \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<StorageIndex>::highest}());
00626   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} ntriplets = \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(nelements);
00627   triplets.reserve(ntriplets);
00628   Scalar sum = Scalar(0);
00629   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0;i<ntriplets;++i)
00630   \{
00631     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} r = internal::random<Index>(0,rows-1);
00632     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} c = internal::random<Index>(0,cols-1);
00633     Scalar v = internal::random<Scalar>();
00634     triplets.push\_back(TripletType(r,c,v));
00635     sum += v;
00636   \}
00637   SparseMatrixType m(rows,cols);
00638   m.setFromTriplets(triplets.begin(), triplets.end());
00639   VERIFY(m.nonZeros() <= ntriplets);
00640   VERIFY\_IS\_APPROX(sum, m.sum());
00641 \}
00642 
00643 
00644 \textcolor{keywordtype}{void} test\_sparse\_basic()
00645 \{
00646   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00647     \textcolor{keywordtype}{int} r = Eigen::internal::random<int>(1,200), c = Eigen::internal::random<int>(1,200);
00648     \textcolor{keywordflow}{if}(Eigen::internal::random<int>(0,4) == 0) \{
00649       r = c; \textcolor{comment}{// check square matrices in 25% of tries}
00650     \}
00651     EIGEN\_UNUSED\_VARIABLE(r+c);
00652     CALL\_SUBTEST\_1(( sparse\_basic(\hyperlink{group___sparse_core___module}{SparseMatrix<double>}(1, 1)) ));
00653     CALL\_SUBTEST\_1(( sparse\_basic(\hyperlink{group___sparse_core___module}{SparseMatrix<double>}(8, 8)) ));
00654     CALL\_SUBTEST\_2(( sparse\_basic(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix}<std::complex<double>, 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}>(r, c)) ));
00655     CALL\_SUBTEST\_2(( sparse\_basic(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix}<std::complex<double>, 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}>(r, c)) ));
00656     CALL\_SUBTEST\_1(( sparse\_basic(\hyperlink{group___sparse_core___module}{SparseMatrix<double>}(r, c)) ));
00657     CALL\_SUBTEST\_5(( sparse\_basic(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double,ColMajor,long int>}
      (r, c)) ));
00658     CALL\_SUBTEST\_5(( sparse\_basic(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double,RowMajor,long int>}
      (r, c)) ));
00659     
00660     r = Eigen::internal::random<int>(1,100);
00661     c = Eigen::internal::random<int>(1,100);
00662     \textcolor{keywordflow}{if}(Eigen::internal::random<int>(0,4) == 0) \{
00663       r = c; \textcolor{comment}{// check square matrices in 25% of tries}
00664     \}
00665     
00666     CALL\_SUBTEST\_6(( sparse\_basic(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double,ColMajor,short int>}
      (\textcolor{keywordtype}{short}(r), \textcolor{keywordtype}{short}(c))) ));
00667     CALL\_SUBTEST\_6(( sparse\_basic(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double,RowMajor,short int>}
      (\textcolor{keywordtype}{short}(r), \textcolor{keywordtype}{short}(c))) ));
00668   \}
00669 
00670   \textcolor{comment}{// Regression test for bug 900: (manually insert higher values here, if you have enough RAM):}
00671   CALL\_SUBTEST\_3((big\_sparse\_triplet<\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<float, RowMajor, int>} >
      (10000, 10000, 0.125)));
00672   CALL\_SUBTEST\_4((big\_sparse\_triplet<\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<double, ColMajor, long int>}
       >(10000, 10000, 0.125)));
00673 
00674   \textcolor{comment}{// Regression test for bug 1105}
00675 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_7}
00676   \{
00677     \textcolor{keywordtype}{int} n = Eigen::internal::random<int>(200,600);
00678     \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<std::complex<double>},0, \textcolor{keywordtype}{long}> mat(n, n);
00679     std::complex<double> val;
00680 
00681     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<n; ++i)
00682     \{
00683       mat.coeffRef(i, i%(n/10)) = val;
00684       VERIFY(mat.data().allocatedSize()<20*n);
00685     \}
00686   \}
00687 \textcolor{preprocessor}{#endif}
00688 \}
\end{DoxyCode}
