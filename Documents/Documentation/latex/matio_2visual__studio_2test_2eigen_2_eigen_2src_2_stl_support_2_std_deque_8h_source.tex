\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_stl_support_2_std_deque_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Stl\+Support/\+Std\+Deque.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_stl_support_2_std_deque_8h_source}\index{Std\+Deque.\+h@{Std\+Deque.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2009 Hauke Heibel <hauke.heibel@googlemail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_STDDEQUE\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_STDDEQUE\_H}
00013 
00014 \textcolor{preprocessor}{#include "details.h"}
00015 
00021 \textcolor{preprocessor}{#define EIGEN\_DEFINE\_STL\_DEQUE\_SPECIALIZATION(...) \(\backslash\)}
00022 \textcolor{preprocessor}{namespace std \(\backslash\)}
00023 \textcolor{preprocessor}{\{ \(\backslash\)}
00024 \textcolor{preprocessor}{  template<> \(\backslash\)}
00025 \textcolor{preprocessor}{  class deque<\_\_VA\_ARGS\_\_, std::allocator<\_\_VA\_ARGS\_\_> >           \(\backslash\)}
00026 \textcolor{preprocessor}{    : public deque<\_\_VA\_ARGS\_\_, EIGEN\_ALIGNED\_ALLOCATOR<\_\_VA\_ARGS\_\_> > \(\backslash\)}
00027 \textcolor{preprocessor}{  \{ \(\backslash\)}
00028 \textcolor{preprocessor}{    typedef deque<\_\_VA\_ARGS\_\_, EIGEN\_ALIGNED\_ALLOCATOR<\_\_VA\_ARGS\_\_> > deque\_base; \(\backslash\)}
00029 \textcolor{preprocessor}{  public: \(\backslash\)}
00030 \textcolor{preprocessor}{    typedef \_\_VA\_ARGS\_\_ value\_type; \(\backslash\)}
00031 \textcolor{preprocessor}{    typedef deque\_base::allocator\_type allocator\_type; \(\backslash\)}
00032 \textcolor{preprocessor}{    typedef deque\_base::size\_type size\_type;  \(\backslash\)}
00033 \textcolor{preprocessor}{    typedef deque\_base::iterator iterator;  \(\backslash\)}
00034 \textcolor{preprocessor}{    explicit deque(const allocator\_type& a = allocator\_type()) : deque\_base(a) \{\}  \(\backslash\)}
00035 \textcolor{preprocessor}{    template<typename InputIterator> \(\backslash\)}
00036 \textcolor{preprocessor}{    deque(InputIterator first, InputIterator last, const allocator\_type& a = allocator\_type()) :
       deque\_base(first, last, a) \{\} \(\backslash\)}
00037 \textcolor{preprocessor}{    deque(const deque& c) : deque\_base(c) \{\}  \(\backslash\)}
00038 \textcolor{preprocessor}{    explicit deque(size\_type num, const value\_type& val = value\_type()) : deque\_base(num, val) \{\} \(\backslash\)}
00039 \textcolor{preprocessor}{    deque(iterator start, iterator end) : deque\_base(start, end) \{\}  \(\backslash\)}
00040 \textcolor{preprocessor}{    deque& operator=(const deque& x) \{  \(\backslash\)}
00041 \textcolor{preprocessor}{      deque\_base::operator=(x);  \(\backslash\)}
00042 \textcolor{preprocessor}{      return *this;  \(\backslash\)}
00043 \textcolor{preprocessor}{    \} \(\backslash\)}
00044 \textcolor{preprocessor}{  \}; \(\backslash\)}
00045 \textcolor{preprocessor}{\}}
00046 
00047 \textcolor{comment}{// check whether we really need the std::deque specialization}
00048 \textcolor{preprocessor}{#if !EIGEN\_HAS\_CXX11\_CONTAINERS && !(defined(\_GLIBCXX\_DEQUE) && (!EIGEN\_GNUC\_AT\_LEAST(4,1))) }\textcolor{comment}{/* Note that
       before gcc-4.1 we already have: std::deque::resize(size\_type,const T&). */}\textcolor{preprocessor}{}
00049 
00050 \textcolor{keyword}{namespace }\hyperlink{namespacestd}{std} \{
00051 
00052 \textcolor{preprocessor}{#define EIGEN\_STD\_DEQUE\_SPECIALIZATION\_BODY \(\backslash\)}
00053 \textcolor{preprocessor}{  public:  \(\backslash\)}
00054 \textcolor{preprocessor}{    typedef T value\_type; \(\backslash\)}
00055 \textcolor{preprocessor}{    typedef typename deque\_base::allocator\_type allocator\_type; \(\backslash\)}
00056 \textcolor{preprocessor}{    typedef typename deque\_base::size\_type size\_type;  \(\backslash\)}
00057 \textcolor{preprocessor}{    typedef typename deque\_base::iterator iterator;  \(\backslash\)}
00058 \textcolor{preprocessor}{    typedef typename deque\_base::const\_iterator const\_iterator;  \(\backslash\)}
00059 \textcolor{preprocessor}{    explicit deque(const allocator\_type& a = allocator\_type()) : deque\_base(a) \{\}  \(\backslash\)}
00060 \textcolor{preprocessor}{    template<typename InputIterator> \(\backslash\)}
00061 \textcolor{preprocessor}{    deque(InputIterator first, InputIterator last, const allocator\_type& a = allocator\_type()) \(\backslash\)}
00062 \textcolor{preprocessor}{    : deque\_base(first, last, a) \{\} \(\backslash\)}
00063 \textcolor{preprocessor}{    deque(const deque& c) : deque\_base(c) \{\}  \(\backslash\)}
00064 \textcolor{preprocessor}{    explicit deque(size\_type num, const value\_type& val = value\_type()) : deque\_base(num, val) \{\} \(\backslash\)}
00065 \textcolor{preprocessor}{    deque(iterator start, iterator end) : deque\_base(start, end) \{\}  \(\backslash\)}
00066 \textcolor{preprocessor}{    deque& operator=(const deque& x) \{  \(\backslash\)}
00067 \textcolor{preprocessor}{      deque\_base::operator=(x);  \(\backslash\)}
00068 \textcolor{preprocessor}{      return *this;  \(\backslash\)}
00069 \textcolor{preprocessor}{    \}}
00070 
00071   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00072   \textcolor{keyword}{class }deque<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T},EIGEN\_ALIGNED\_ALLOCATOR<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}> >
00073     : \textcolor{keyword}{public} deque<EIGEN\_WORKAROUND\_MSVC\_STL\_SUPPORT(T),
00074                    Eigen::aligned\_allocator\_indirection<EIGEN\_WORKAROUND\_MSVC\_STL\_SUPPORT(T)> >
00075 \{
00076   \textcolor{keyword}{typedef} deque<EIGEN\_WORKAROUND\_MSVC\_STL\_SUPPORT(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}),
00077                 
      \hyperlink{class_eigen_1_1aligned__allocator__indirection}{Eigen::aligned\_allocator\_indirection<EIGEN\_WORKAROUND\_MSVC\_STL\_SUPPORT(T)>}
       > deque\_base;
00078   EIGEN\_STD\_DEQUE\_SPECIALIZATION\_BODY
00079 
00080   \textcolor{keywordtype}{void} resize(size\_type new\_size)
00081   \{ resize(new\_size, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}()); \}
00082 
00083 \textcolor{preprocessor}{#if defined(\_DEQUE\_)}
00084   \textcolor{comment}{// workaround MSVC std::deque implementation}
00085   \textcolor{keywordtype}{void} resize(size\_type new\_size, \textcolor{keyword}{const} value\_type& x)
00086   \{
00087     \textcolor{keywordflow}{if} (deque\_base::size() < new\_size)
00088       deque\_base::\_Insert\_n(deque\_base::end(), new\_size - deque\_base::size(), x);
00089     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (new\_size < deque\_base::size())
00090       deque\_base::erase(deque\_base::begin() + new\_size, deque\_base::end());
00091   \}
00092   \textcolor{keywordtype}{void} push\_back(\textcolor{keyword}{const} value\_type& x)
00093   \{ deque\_base::push\_back(x); \} 
00094   \textcolor{keywordtype}{void} push\_front(\textcolor{keyword}{const} value\_type& x)
00095   \{ deque\_base::push\_front(x); \}
00096   \textcolor{keyword}{using} deque\_base::insert;  
00097   iterator insert(const\_iterator position, \textcolor{keyword}{const} value\_type& x)
00098   \{ \textcolor{keywordflow}{return} deque\_base::insert(position,x); \}
00099   \textcolor{keywordtype}{void} insert(const\_iterator position, size\_type new\_size, \textcolor{keyword}{const} value\_type& x)
00100   \{ deque\_base::insert(position, new\_size, x); \}
00101 \textcolor{preprocessor}{#elif defined(\_GLIBCXX\_DEQUE) && EIGEN\_GNUC\_AT\_LEAST(4,2)}
00102   \textcolor{comment}{// workaround GCC std::deque implementation}
00103   \textcolor{keywordtype}{void} resize(size\_type new\_size, \textcolor{keyword}{const} value\_type& x)
00104   \{
00105     \textcolor{keywordflow}{if} (new\_size < deque\_base::size())
00106       deque\_base::\_M\_erase\_at\_end(this->\_M\_impl.\_M\_start + new\_size);
00107     \textcolor{keywordflow}{else}
00108       deque\_base::insert(deque\_base::end(), new\_size - deque\_base::size(), x);
00109   \}
00110 \textcolor{preprocessor}{#else}
00111   \textcolor{comment}{// either GCC 4.1 or non-GCC}
00112   \textcolor{comment}{// default implementation which should always work.}
00113   \textcolor{keywordtype}{void} resize(size\_type new\_size, \textcolor{keyword}{const} value\_type& x)
00114   \{
00115     \textcolor{keywordflow}{if} (new\_size < deque\_base::size())
00116       deque\_base::erase(deque\_base::begin() + new\_size, deque\_base::end());
00117     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (new\_size > deque\_base::size())
00118       deque\_base::insert(deque\_base::end(), new\_size - deque\_base::size(), x);
00119   \}
00120 \textcolor{preprocessor}{#endif}
00121   \};
00122 \}
00123 
00124 \textcolor{preprocessor}{#endif // check whether specialization is actually required}
00125 
00126 \textcolor{preprocessor}{#endif // EIGEN\_STDDEQUE\_H}
\end{DoxyCode}
