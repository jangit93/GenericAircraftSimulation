\hypertarget{zlib_2contrib_2masmx64_2inffas8664_8c_source}{}\section{zlib/contrib/masmx64/inffas8664.c}
\label{zlib_2contrib_2masmx64_2inffas8664_8c_source}\index{inffas8664.\+c@{inffas8664.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* inffas8664.c is a hand tuned assembler version of inffast.c - fast decoding}
00002 \textcolor{comment}{ * version for AMD64 on Windows using Microsoft C compiler}
00003 \textcolor{comment}{ *}
00004 \textcolor{comment}{ * Copyright (C) 1995-2003 Mark Adler}
00005 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00006 \textcolor{comment}{ *}
00007 \textcolor{comment}{ * Copyright (C) 2003 Chris Anderson <christop@charm.net>}
00008 \textcolor{comment}{ * Please use the copyright conditions above.}
00009 \textcolor{comment}{ *}
00010 \textcolor{comment}{ * 2005 - Adaptation to Microsoft C Compiler for AMD64 by Gilles Vollant}
00011 \textcolor{comment}{ *}
00012 \textcolor{comment}{ * inffas8664.c call function inffas8664fnc in inffasx64.asm}
00013 \textcolor{comment}{ *  inffasx64.asm is automatically convert from AMD64 portion of inffas86.c}
00014 \textcolor{comment}{ *}
00015 \textcolor{comment}{ * Dec-29-2003 -- I added AMD64 inflate asm support.  This version is also}
00016 \textcolor{comment}{ * slightly quicker on x86 systems because, instead of using rep movsb to copy}
00017 \textcolor{comment}{ * data, it uses rep movsw, which moves data in 2-byte chunks instead of single}
00018 \textcolor{comment}{ * bytes.  I've tested the AMD64 code on a Fedora Core 1 + the x86\_64 updates}
00019 \textcolor{comment}{ * from http://fedora.linux.duke.edu/fc1\_x86\_64}
00020 \textcolor{comment}{ * which is running on an Athlon 64 3000+ / Gigabyte GA-K8VT800M system with}
00021 \textcolor{comment}{ * 1GB ram.  The 64-bit version is about 4% faster than the 32-bit version,}
00022 \textcolor{comment}{ * when decompressing mozilla-source-1.3.tar.gz.}
00023 \textcolor{comment}{ *}
00024 \textcolor{comment}{ * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from}
00025 \textcolor{comment}{ * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at}
00026 \textcolor{comment}{ * the moment.  I have successfully compiled and tested this code with gcc2.96,}
00027 \textcolor{comment}{ * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S}
00028 \textcolor{comment}{ * compiled with gcc -DNO\_MMX, but inffast.S is still faster on the P3 with MMX}
00029 \textcolor{comment}{ * enabled.  I will attempt to merge the MMX code into this version.  Newer}
00030 \textcolor{comment}{ * versions of this and inffast.S can be found at}
00031 \textcolor{comment}{ * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/}
00032 \textcolor{comment}{ *}
00033 \textcolor{comment}{ */}
00034 
00035 \textcolor{preprocessor}{#include <stdio.h>}
00036 \textcolor{preprocessor}{#include "zutil.h"}
00037 \textcolor{preprocessor}{#include "inftrees.h"}
00038 \textcolor{preprocessor}{#include "inflate.h"}
00039 \textcolor{preprocessor}{#include "inffast.h"}
00040 
00041 \textcolor{comment}{/* Mark Adler's comments from inffast.c: */}
00042 
00043 \textcolor{comment}{/*}
00044 \textcolor{comment}{   Decode literal, length, and distance codes and write out the resulting}
00045 \textcolor{comment}{   literal and match bytes until either not enough input or output is}
00046 \textcolor{comment}{   available, an end-of-block is encountered, or a data error is encountered.}
00047 \textcolor{comment}{   When large enough input and output buffers are supplied to inflate(), for}
00048 \textcolor{comment}{   example, a 16K input buffer and a 64K output buffer, more than 95% of the}
00049 \textcolor{comment}{   inflate execution time is spent in this routine.}
00050 \textcolor{comment}{}
00051 \textcolor{comment}{   Entry assumptions:}
00052 \textcolor{comment}{}
00053 \textcolor{comment}{        state->mode == LEN}
00054 \textcolor{comment}{        strm->avail\_in >= 6}
00055 \textcolor{comment}{        strm->avail\_out >= 258}
00056 \textcolor{comment}{        start >= strm->avail\_out}
00057 \textcolor{comment}{        state->bits < 8}
00058 \textcolor{comment}{}
00059 \textcolor{comment}{   On return, state->mode is one of:}
00060 \textcolor{comment}{}
00061 \textcolor{comment}{        LEN -- ran out of enough output space or enough available input}
00062 \textcolor{comment}{        TYPE -- reached end of block code, inflate() to interpret next block}
00063 \textcolor{comment}{        BAD -- error in block data}
00064 \textcolor{comment}{}
00065 \textcolor{comment}{   Notes:}
00066 \textcolor{comment}{}
00067 \textcolor{comment}{    - The maximum input bits used by a length/distance pair is 15 bits for the}
00068 \textcolor{comment}{      length code, 5 bits for the length extra, 15 bits for the distance code,}
00069 \textcolor{comment}{      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.}
00070 \textcolor{comment}{      Therefore if strm->avail\_in >= 6, then there is enough input to avoid}
00071 \textcolor{comment}{      checking for available input while decoding.}
00072 \textcolor{comment}{}
00073 \textcolor{comment}{    - The maximum bytes that a single length/distance pair can output is 258}
00074 \textcolor{comment}{      bytes, which is the maximum length that can be coded.  inflate\_fast()}
00075 \textcolor{comment}{      requires strm->avail\_out >= 258 for each loop to avoid checking for}
00076 \textcolor{comment}{      output space.}
00077 \textcolor{comment}{ */}
00078 
00079 
00080 
00081     \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structinffast__ar}{inffast\_ar} \{
00082 \textcolor{comment}{/* 64   32                               x86  x86\_64 */}
00083 \textcolor{comment}{/* ar offset                              register */}
00084 \textcolor{comment}{/*  0    0 */} \textcolor{keywordtype}{void} *esp;                \textcolor{comment}{/* esp save */}
00085 \textcolor{comment}{/*  8    4 */} \textcolor{keywordtype}{void} *ebp;                \textcolor{comment}{/* ebp save */}
00086 \textcolor{comment}{/* 16    8 */} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *in;    \textcolor{comment}{/* esi rsi  local strm->next\_in */}
00087 \textcolor{comment}{/* 24   12 */} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *last;  \textcolor{comment}{/*     r9   while in < last */}
00088 \textcolor{comment}{/* 32   16 */} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *out;   \textcolor{comment}{/* edi rdi  local strm->next\_out */}
00089 \textcolor{comment}{/* 40   20 */} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *beg;   \textcolor{comment}{/*          inflate()'s init next\_out */}
00090 \textcolor{comment}{/* 48   24 */} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *end;   \textcolor{comment}{/*     r10  while out < end */}
00091 \textcolor{comment}{/* 56   28 */} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *window;\textcolor{comment}{/*          size of window, wsize!=0 */}
00092 \textcolor{comment}{/* 64   32 */} \hyperlink{structcode}{code} \textcolor{keyword}{const} FAR *lcode;    \textcolor{comment}{/* ebp rbp  local strm->lencode */}
00093 \textcolor{comment}{/* 72   36 */} \hyperlink{structcode}{code} \textcolor{keyword}{const} FAR *dcode;    \textcolor{comment}{/*     r11  local strm->distcode */}
00094 \textcolor{comment}{/* 80   40 */} \textcolor{keywordtype}{size\_t} \textcolor{comment}{/*unsigned long */}hold;       \textcolor{comment}{/* edx rdx  local strm->hold */}
00095 \textcolor{comment}{/* 88   44 */} \textcolor{keywordtype}{unsigned} bits;            \textcolor{comment}{/* ebx rbx  local strm->bits */}
00096 \textcolor{comment}{/* 92   48 */} \textcolor{keywordtype}{unsigned} wsize;           \textcolor{comment}{/*          window size */}
00097 \textcolor{comment}{/* 96   52 */} \textcolor{keywordtype}{unsigned} write;           \textcolor{comment}{/*          window write index */}
00098 \textcolor{comment}{/*100   56 */} \textcolor{keywordtype}{unsigned} lmask;           \textcolor{comment}{/*     r12  mask for lcode */}
00099 \textcolor{comment}{/*104   60 */} \textcolor{keywordtype}{unsigned} dmask;           \textcolor{comment}{/*     r13  mask for dcode */}
00100 \textcolor{comment}{/*108   64 */} \textcolor{keywordtype}{unsigned} len;             \textcolor{comment}{/*     r14  match length */}
00101 \textcolor{comment}{/*112   68 */} \textcolor{keywordtype}{unsigned} dist;            \textcolor{comment}{/*     r15  match distance */}
00102 \textcolor{comment}{/*116   72 */} \textcolor{keywordtype}{unsigned} status;          \textcolor{comment}{/*          set when state chng*/}
00103     \} \hyperlink{structinffast__ar}{type\_ar};
00104 \textcolor{preprocessor}{#ifdef ASMINF}
00105 
00106 \textcolor{keywordtype}{void} inflate\_fast(strm, start)
00107 z\_streamp strm;
00108 \textcolor{keywordtype}{unsigned} start;         \textcolor{comment}{/* inflate()'s starting value for strm->avail\_out */}
00109 \{
00110     \textcolor{keyword}{struct }\hyperlink{structinflate__state}{inflate\_state} FAR *\hyperlink{structstate}{state};
00111     \hyperlink{structinffast__ar}{type\_ar} ar;
00112     \textcolor{keywordtype}{void} inffas8664fnc(\textcolor{keyword}{struct} \hyperlink{structinffast__ar}{inffast\_ar} * par);
00113 
00114 
00115 
00116 \textcolor{preprocessor}{#if (defined( \_\_GNUC\_\_ ) && defined( \_\_amd64\_\_ ) && ! defined( \_\_i386 )) || (defined(\_MSC\_VER) &&
       defined(\_M\_AMD64))}
00117 \textcolor{preprocessor}{#define PAD\_AVAIL\_IN 6}
00118 \textcolor{preprocessor}{#define PAD\_AVAIL\_OUT 258}
00119 \textcolor{preprocessor}{#else}
00120 \textcolor{preprocessor}{#define PAD\_AVAIL\_IN 5}
00121 \textcolor{preprocessor}{#define PAD\_AVAIL\_OUT 257}
00122 \textcolor{preprocessor}{#endif}
00123 
00124     \textcolor{comment}{/* copy state to local variables */}
00125     state = (\textcolor{keyword}{struct }\hyperlink{structinflate__state}{inflate\_state} FAR *)strm->state;
00126 
00127     ar.in = strm->next\_in;
00128     ar.last = ar.in + (strm->avail\_in - PAD\_AVAIL\_IN);
00129     ar.out = strm->next\_out;
00130     ar.beg = ar.out - (start - strm->avail\_out);
00131     ar.end = ar.out + (strm->avail\_out - PAD\_AVAIL\_OUT);
00132     ar.wsize = state->wsize;
00133     ar.write = state->wnext;
00134     ar.window = state->window;
00135     ar.hold = state->hold;
00136     ar.bits = state->bits;
00137     ar.lcode = state->lencode;
00138     ar.dcode = state->distcode;
00139     ar.lmask = (1U << state->lenbits) - 1;
00140     ar.dmask = (1U << state->distbits) - 1;
00141 
00142     \textcolor{comment}{/* decode literals and length/distances until end-of-block or not enough}
00143 \textcolor{comment}{       input data or output space */}
00144 
00145     \textcolor{comment}{/* align in on 1/2 hold size boundary */}
00146     \textcolor{keywordflow}{while} (((\textcolor{keywordtype}{size\_t})(\textcolor{keywordtype}{void} *)ar.in & (\textcolor{keyword}{sizeof}(ar.hold) / 2 - 1)) != 0) \{
00147         ar.hold += (\textcolor{keywordtype}{unsigned} long)*ar.in++ << ar.bits;
00148         ar.bits += 8;
00149     \}
00150 
00151     inffas8664fnc(&ar);
00152 
00153     \textcolor{keywordflow}{if} (ar.status > 1) \{
00154         \textcolor{keywordflow}{if} (ar.status == 2)
00155             strm->msg = \textcolor{stringliteral}{"invalid literal/length code"};
00156         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ar.status == 3)
00157             strm->msg = \textcolor{stringliteral}{"invalid distance code"};
00158         \textcolor{keywordflow}{else}
00159             strm->msg = \textcolor{stringliteral}{"invalid distance too far back"};
00160         state->mode = BAD;
00161     \}
00162     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( ar.status == 1 ) \{
00163         state->mode = TYPE;
00164     \}
00165 
00166     \textcolor{comment}{/* return unused bytes (on entry, bits < 8, so in won't go too far back) */}
00167     ar.len = ar.bits >> 3;
00168     ar.in -= ar.len;
00169     ar.bits -= ar.len << 3;
00170     ar.hold &= (1U << ar.bits) - 1;
00171 
00172     \textcolor{comment}{/* update state and return */}
00173     strm->next\_in = ar.in;
00174     strm->next\_out = ar.out;
00175     strm->avail\_in = (unsigned)(ar.in < ar.last ?
00176                                 PAD\_AVAIL\_IN + (ar.last - ar.in) :
00177                                 PAD\_AVAIL\_IN - (ar.in - ar.last));
00178     strm->avail\_out = (unsigned)(ar.out < ar.end ?
00179                                  PAD\_AVAIL\_OUT + (ar.end - ar.out) :
00180                                  PAD\_AVAIL\_OUT - (ar.out - ar.end));
00181     state->hold = (\textcolor{keywordtype}{unsigned} long)ar.hold;
00182     state->bits = ar.bits;
00183     \textcolor{keywordflow}{return};
00184 \}
00185 
00186 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
