\hypertarget{eigen_2unsupported_2test_2cxx11__tensor__intdiv_8cpp_source}{}\section{eigen/unsupported/test/cxx11\+\_\+tensor\+\_\+intdiv.cpp}
\label{eigen_2unsupported_2test_2cxx11__tensor__intdiv_8cpp_source}\index{cxx11\+\_\+tensor\+\_\+intdiv.\+cpp@{cxx11\+\_\+tensor\+\_\+intdiv.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014-2015 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{preprocessor}{#include <Eigen/CXX11/Tensor>}
00013 
00014 
00015 \textcolor{keywordtype}{void} test\_signed\_32bit()
00016 \{
00017   \textcolor{comment}{// Divide by one}
00018   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{Eigen::internal::TensorIntDivisor<int32\_t, false>} 
      div\_by\_one(1);
00019 
00020   \textcolor{keywordflow}{for} (int32\_t j = 0; j < 25000; ++j) \{
00021     \textcolor{keyword}{const} int32\_t fast\_div = j / div\_by\_one;
00022     \textcolor{keyword}{const} int32\_t slow\_div = j / 1;
00023     VERIFY\_IS\_EQUAL(fast\_div, slow\_div);
00024   \}
00025 
00026   \textcolor{comment}{// Standard divide by 2 or more}
00027   \textcolor{keywordflow}{for} (int32\_t i = 2; i < 25000; ++i) \{
00028     \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{Eigen::internal::TensorIntDivisor<int32\_t, false>}
       div(i);
00029 
00030     \textcolor{keywordflow}{for} (int32\_t j = 0; j < 25000; ++j) \{
00031       \textcolor{keyword}{const} int32\_t fast\_div = j / div;
00032       \textcolor{keyword}{const} int32\_t slow\_div = j / i;
00033       VERIFY\_IS\_EQUAL(fast\_div, slow\_div);
00034     \}
00035   \}
00036 
00037   \textcolor{comment}{// Optimized divide by 2 or more}
00038   \textcolor{keywordflow}{for} (int32\_t i = 2; i < 25000; ++i) \{
00039     \textcolor{keyword}{const} \hyperlink{class_eigen_1_1internal_1_1_tensor_int_divisor_3_01int32__t_00_01true_01_4}{Eigen::internal::TensorIntDivisor<int32\_t, true>} 
      div(i);
00040 
00041     \textcolor{keywordflow}{for} (int32\_t j = 0; j < 25000; ++j) \{
00042       \textcolor{keyword}{const} int32\_t fast\_div = j / div;
00043       \textcolor{keyword}{const} int32\_t slow\_div = j / i;
00044       VERIFY\_IS\_EQUAL(fast\_div, slow\_div);
00045     \}
00046   \}
00047 \}
00048 
00049 
00050 \textcolor{keywordtype}{void} test\_unsigned\_32bit()
00051 \{
00052   \textcolor{keywordflow}{for} (uint32\_t i = 1; i < 25000; ++i) \{
00053     \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{Eigen::internal::TensorIntDivisor<uint32\_t>} div(i);
00054 
00055     \textcolor{keywordflow}{for} (uint32\_t j = 0; j < 25000; ++j) \{
00056       \textcolor{keyword}{const} uint32\_t fast\_div = j / div;
00057       \textcolor{keyword}{const} uint32\_t slow\_div = j / i;
00058       VERIFY\_IS\_EQUAL(fast\_div, slow\_div);
00059     \}
00060   \}
00061 \}
00062 
00063 
00064 \textcolor{keywordtype}{void} test\_signed\_64bit()
00065 \{
00066   \textcolor{keywordflow}{for} (int64\_t i = 1; i < 25000; ++i) \{
00067     \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{Eigen::internal::TensorIntDivisor<int64\_t>} div(i);
00068 
00069     \textcolor{keywordflow}{for} (int64\_t j = 0; j < 25000; ++j) \{
00070       \textcolor{keyword}{const} int64\_t fast\_div = j / div;
00071       \textcolor{keyword}{const} int64\_t slow\_div = j / i;
00072       VERIFY\_IS\_EQUAL(fast\_div, slow\_div);
00073     \}
00074   \}
00075 \}
00076 
00077 
00078 \textcolor{keywordtype}{void} test\_unsigned\_64bit()
00079 \{
00080   \textcolor{keywordflow}{for} (uint64\_t i = 1; i < 25000; ++i) \{
00081     \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{Eigen::internal::TensorIntDivisor<uint64\_t>} div(i);
00082 
00083     \textcolor{keywordflow}{for} (uint64\_t j = 0; j < 25000; ++j) \{
00084       \textcolor{keyword}{const} uint64\_t fast\_div = j / div;
00085       \textcolor{keyword}{const} uint64\_t slow\_div = j / i;
00086       VERIFY\_IS\_EQUAL(fast\_div, slow\_div);
00087     \}
00088   \}
00089 \}
00090 
00091 \textcolor{keywordtype}{void} test\_powers\_32bit() \{
00092   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} expon = 1; expon < 31; expon++) \{
00093     int32\_t div = (1 << expon);
00094     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} num\_expon = 0; num\_expon < 32; num\_expon++) \{
00095       int32\_t start\_num = (1 << num\_expon) - 100;
00096       int32\_t end\_num = (1 << num\_expon) + 100;
00097       \textcolor{keywordflow}{if} (start\_num < 0)
00098         start\_num = 0;
00099       \textcolor{keywordflow}{for} (int32\_t num = start\_num; num < end\_num; num++) \{
00100         \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{Eigen::internal::TensorIntDivisor<int32\_t>} divider =
00101           \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{Eigen::internal::TensorIntDivisor<int32\_t>}(div);
00102         int32\_t result = num/div;
00103         int32\_t result\_op = divider.divide(num);
00104         VERIFY\_IS\_EQUAL(result\_op, result);
00105       \}
00106     \}
00107   \}
00108 \}
00109 
00110 \textcolor{keywordtype}{void} test\_powers\_64bit() \{
00111   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} expon = 0; expon < 63; expon++) \{
00112     int64\_t div = (1ull << expon);
00113     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} num\_expon = 0; num\_expon < 63; num\_expon++) \{
00114       int64\_t start\_num = (1ull << num\_expon) - 10;
00115       int64\_t end\_num = (1ull << num\_expon) + 10;
00116       \textcolor{keywordflow}{if} (start\_num < 0)
00117         start\_num = 0;
00118       \textcolor{keywordflow}{for} (int64\_t num = start\_num; num < end\_num; num++) \{
00119         \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{Eigen::internal::TensorIntDivisor<int64\_t>} divider(div);
00120         int64\_t result = num/div;
00121         int64\_t result\_op = divider.divide(num);
00122         VERIFY\_IS\_EQUAL(result\_op, result);
00123       \}
00124     \}
00125   \}
00126 \}
00127 
00128 \textcolor{keywordtype}{void} test\_specific() \{
00129   \textcolor{comment}{// A particular combination that was previously failing}
00130   int64\_t div = 209715200;
00131   int64\_t num = 3238002688ll;
00132   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{Eigen::internal::TensorIntDivisor<int64\_t>} divider(div);
00133   int64\_t result = num/div;
00134   int64\_t result\_op = divider.divide(num);
00135   VERIFY\_IS\_EQUAL(result, result\_op);
00136 \}
00137 
00138 \textcolor{keywordtype}{void} test\_cxx11\_tensor\_intdiv()
00139 \{
00140   CALL\_SUBTEST\_1(test\_signed\_32bit());
00141   CALL\_SUBTEST\_2(test\_unsigned\_32bit());
00142   CALL\_SUBTEST\_3(test\_signed\_64bit());
00143   CALL\_SUBTEST\_4(test\_unsigned\_64bit());
00144   CALL\_SUBTEST\_5(test\_powers\_32bit());
00145   CALL\_SUBTEST\_6(test\_powers\_64bit());
00146   CALL\_SUBTEST\_7(test\_specific());
00147 \}
\end{DoxyCode}
