\hypertarget{visual__studio_2zlib_2crc32_8c_source}{}\section{visual\+\_\+studio/zlib/crc32.c}
\label{visual__studio_2zlib_2crc32_8c_source}\index{crc32.\+c@{crc32.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* crc32.c -- compute the CRC-32 of a data stream}
00002 \textcolor{comment}{ * Copyright (C) 1995-2006, 2010, 2011, 2012, 2016 Mark Adler}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster}
00006 \textcolor{comment}{ * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing}
00007 \textcolor{comment}{ * tables for updating the shift register in one step with three exclusive-ors}
00008 \textcolor{comment}{ * instead of four steps with four exclusive-ors.  This results in about a}
00009 \textcolor{comment}{ * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.}
00010 \textcolor{comment}{ */}
00011 
00012 \textcolor{comment}{/* @(#) $Id$ */}
00013 
00014 \textcolor{comment}{/*}
00015 \textcolor{comment}{  Note on the use of DYNAMIC\_CRC\_TABLE: there is no mutex or semaphore}
00016 \textcolor{comment}{  protection on the static variables used to control the first-use generation}
00017 \textcolor{comment}{  of the crc tables.  Therefore, if you #define DYNAMIC\_CRC\_TABLE, you should}
00018 \textcolor{comment}{  first call get\_crc\_table() to initialize the tables before allowing more than}
00019 \textcolor{comment}{  one thread to use crc32().}
00020 \textcolor{comment}{}
00021 \textcolor{comment}{  DYNAMIC\_CRC\_TABLE and MAKECRCH can be #defined to write out crc32.h.}
00022 \textcolor{comment}{ */}
00023 
00024 \textcolor{preprocessor}{#ifdef MAKECRCH}
00025 \textcolor{preprocessor}{#  include <stdio.h>}
00026 \textcolor{preprocessor}{#  ifndef DYNAMIC\_CRC\_TABLE}
00027 \textcolor{preprocessor}{#    define DYNAMIC\_CRC\_TABLE}
00028 \textcolor{preprocessor}{#  endif }\textcolor{comment}{/* !DYNAMIC\_CRC\_TABLE */}\textcolor{preprocessor}{}
00029 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* MAKECRCH */}\textcolor{preprocessor}{}
00030 
00031 \textcolor{preprocessor}{#include "zutil.h"}      \textcolor{comment}{/* for STDC and FAR definitions */}
00032 
00033 \textcolor{comment}{/* Definitions for doing the crc four data bytes at a time. */}
00034 \textcolor{preprocessor}{#if !defined(NOBYFOUR) && defined(Z\_U4)}
00035 \textcolor{preprocessor}{#  define BYFOUR}
00036 \textcolor{preprocessor}{#endif}
00037 \textcolor{preprocessor}{#ifdef BYFOUR}
00038    local \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} crc32\_little OF((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long},
00039                         \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *, z\_size\_t));
00040    local \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} crc32\_big OF((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long},
00041                         \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *, z\_size\_t));
00042 \textcolor{preprocessor}{#  define TBLS 8}
00043 \textcolor{preprocessor}{#else}
00044 \textcolor{preprocessor}{#  define TBLS 1}
00045 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* BYFOUR */}\textcolor{preprocessor}{}
00046 
00047 \textcolor{comment}{/* Local functions for crc concatenation */}
00048 local \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} gf2\_matrix\_times OF((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *mat,
00049                                          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} vec));
00050 local \textcolor{keywordtype}{void} gf2\_matrix\_square OF((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *square, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *mat));
00051 local uLong crc32\_combine\_ OF((uLong crc1, uLong crc2, z\_off64\_t len2));
00052 
00053 
00054 \textcolor{preprocessor}{#ifdef DYNAMIC\_CRC\_TABLE}
00055 
00056 local \textcolor{keyword}{volatile} \textcolor{keywordtype}{int} crc\_table\_empty = 1;
00057 local z\_crc\_t FAR crc\_table[TBLS][256];
00058 local \textcolor{keywordtype}{void} make\_crc\_table OF((\textcolor{keywordtype}{void}));
00059 \textcolor{preprocessor}{#ifdef MAKECRCH}
00060    local \textcolor{keywordtype}{void} write\_table OF((FILE *, \textcolor{keyword}{const} z\_crc\_t FAR *));
00061 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* MAKECRCH */}\textcolor{preprocessor}{}
00062 \textcolor{comment}{/*}
00063 \textcolor{comment}{  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:}
00064 \textcolor{comment}{  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.}
00065 \textcolor{comment}{}
00066 \textcolor{comment}{  Polynomials over GF(2) are represented in binary, one bit per coefficient,}
00067 \textcolor{comment}{  with the lowest powers in the most significant bit.  Then adding polynomials}
00068 \textcolor{comment}{  is just exclusive-or, and multiplying a polynomial by x is a right shift by}
00069 \textcolor{comment}{  one.  If we call the above polynomial p, and represent a byte as the}
00070 \textcolor{comment}{  polynomial q, also with the lowest power in the most significant bit (so the}
00071 \textcolor{comment}{  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,}
00072 \textcolor{comment}{  where a mod b means the remainder after dividing a by b.}
00073 \textcolor{comment}{}
00074 \textcolor{comment}{  This calculation is done using the shift-register method of multiplying and}
00075 \textcolor{comment}{  taking the remainder.  The register is initialized to zero, and for each}
00076 \textcolor{comment}{  incoming bit, x^32 is added mod p to the register if the bit is a one (where}
00077 \textcolor{comment}{  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by}
00078 \textcolor{comment}{  x (which is shifting right by one and adding x^32 mod p if the bit shifted}
00079 \textcolor{comment}{  out is a one).  We start with the highest power (least significant bit) of}
00080 \textcolor{comment}{  q and repeat for all eight bits of q.}
00081 \textcolor{comment}{}
00082 \textcolor{comment}{  The first table is simply the CRC of all possible eight bit values.  This is}
00083 \textcolor{comment}{  all the information needed to generate CRCs on data a byte at a time for all}
00084 \textcolor{comment}{  combinations of CRC register values and incoming bytes.  The remaining tables}
00085 \textcolor{comment}{  allow for word-at-a-time CRC calculation for both big-endian and little-}
00086 \textcolor{comment}{  endian machines, where a word is four bytes.}
00087 \textcolor{comment}{*/}
00088 local \textcolor{keywordtype}{void} make\_crc\_table()
00089 \{
00090     z\_crc\_t c;
00091     \textcolor{keywordtype}{int} n, k;
00092     z\_crc\_t poly;                       \textcolor{comment}{/* polynomial exclusive-or pattern */}
00093     \textcolor{comment}{/* terms of polynomial defining this crc (except x^32): */}
00094     \textcolor{keyword}{static} \textcolor{keyword}{volatile} \textcolor{keywordtype}{int} first = 1;      \textcolor{comment}{/* flag to limit concurrent making */}
00095     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} p[] = \{0,1,2,4,5,7,8,10,11,12,16,22,23,26\};
00096 
00097     \textcolor{comment}{/* See if another task is already doing this (not thread-safe, but better}
00098 \textcolor{comment}{       than nothing -- significantly reduces duration of vulnerability in}
00099 \textcolor{comment}{       case the advice about DYNAMIC\_CRC\_TABLE is ignored) */}
00100     \textcolor{keywordflow}{if} (first) \{
00101         first = 0;
00102 
00103         \textcolor{comment}{/* make exclusive-or pattern from polynomial (0xedb88320UL) */}
00104         poly = 0;
00105         \textcolor{keywordflow}{for} (n = 0; n < (int)(\textcolor{keyword}{sizeof}(p)/\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char})); n++)
00106             poly |= (z\_crc\_t)1 << (31 - p[n]);
00107 
00108         \textcolor{comment}{/* generate a crc for every 8-bit value */}
00109         \textcolor{keywordflow}{for} (n = 0; n < 256; n++) \{
00110             c = (z\_crc\_t)n;
00111             \textcolor{keywordflow}{for} (k = 0; k < 8; k++)
00112                 c = c & 1 ? poly ^ (c >> 1) : c >> 1;
00113             crc\_table[0][n] = c;
00114         \}
00115 
00116 \textcolor{preprocessor}{#ifdef BYFOUR}
00117         \textcolor{comment}{/* generate crc for each value followed by one, two, and three zeros,}
00118 \textcolor{comment}{           and then the byte reversal of those as well as the first table */}
00119         \textcolor{keywordflow}{for} (n = 0; n < 256; n++) \{
00120             c = crc\_table[0][n];
00121             crc\_table[4][n] = ZSWAP32(c);
00122             \textcolor{keywordflow}{for} (k = 1; k < 4; k++) \{
00123                 c = crc\_table[0][c & 0xff] ^ (c >> 8);
00124                 crc\_table[k][n] = c;
00125                 crc\_table[k + 4][n] = ZSWAP32(c);
00126             \}
00127         \}
00128 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* BYFOUR */}\textcolor{preprocessor}{}
00129 
00130         crc\_table\_empty = 0;
00131     \}
00132     \textcolor{keywordflow}{else} \{      \textcolor{comment}{/* not first */}
00133         \textcolor{comment}{/* wait for the other guy to finish (not efficient, but rare) */}
00134         \textcolor{keywordflow}{while} (crc\_table\_empty)
00135             ;
00136     \}
00137 
00138 \textcolor{preprocessor}{#ifdef MAKECRCH}
00139     \textcolor{comment}{/* write out CRC tables to crc32.h */}
00140     \{
00141         FILE *out;
00142 
00143         out = fopen(\textcolor{stringliteral}{"crc32.h"}, \textcolor{stringliteral}{"w"});
00144         \textcolor{keywordflow}{if} (out == NULL) \textcolor{keywordflow}{return};
00145         fprintf(out, \textcolor{stringliteral}{"/* crc32.h -- tables for rapid CRC calculation\(\backslash\)n"});
00146         fprintf(out, \textcolor{stringliteral}{" * Generated automatically by crc32.c\(\backslash\)n */\(\backslash\)n\(\backslash\)n"});
00147         fprintf(out, \textcolor{stringliteral}{"local const z\_crc\_t FAR "});
00148         fprintf(out, \textcolor{stringliteral}{"crc\_table[TBLS][256] =\(\backslash\)n\{\(\backslash\)n  \{\(\backslash\)n"});
00149         write\_table(out, crc\_table[0]);
00150 \textcolor{preprocessor}{#  ifdef BYFOUR}
00151         fprintf(out, \textcolor{stringliteral}{"#ifdef BYFOUR\(\backslash\)n"});
00152         \textcolor{keywordflow}{for} (k = 1; k < 8; k++) \{
00153             fprintf(out, \textcolor{stringliteral}{"  \},\(\backslash\)n  \{\(\backslash\)n"});
00154             write\_table(out, crc\_table[k]);
00155         \}
00156         fprintf(out, \textcolor{stringliteral}{"#endif\(\backslash\)n"});
00157 \textcolor{preprocessor}{#  endif }\textcolor{comment}{/* BYFOUR */}\textcolor{preprocessor}{}
00158         fprintf(out, \textcolor{stringliteral}{"  \}\(\backslash\)n\};\(\backslash\)n"});
00159         fclose(out);
00160     \}
00161 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* MAKECRCH */}\textcolor{preprocessor}{}
00162 \}
00163 
00164 \textcolor{preprocessor}{#ifdef MAKECRCH}
00165 local \textcolor{keywordtype}{void} write\_table(out, table)
00166     FILE *out;
00167     \textcolor{keyword}{const} z\_crc\_t FAR *table;
00168 \{
00169     \textcolor{keywordtype}{int} n;
00170 
00171     \textcolor{keywordflow}{for} (n = 0; n < 256; n++)
00172         fprintf(out, \textcolor{stringliteral}{"%s0x%08lxUL%s"}, n % 5 ? \textcolor{stringliteral}{""} : \textcolor{stringliteral}{"    "},
00173                 (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})(table[n]),
00174                 n == 255 ? \textcolor{stringliteral}{"\(\backslash\)n"} : (n % 5 == 4 ? \textcolor{stringliteral}{",\(\backslash\)n"} : \textcolor{stringliteral}{", "}));
00175 \}
00176 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* MAKECRCH */}\textcolor{preprocessor}{}
00177 
00178 \textcolor{preprocessor}{#else }\textcolor{comment}{/* !DYNAMIC\_CRC\_TABLE */}\textcolor{preprocessor}{}
00179 \textcolor{comment}{/* ========================================================================}
00180 \textcolor{comment}{ * Tables of CRC-32s of all single-byte values, made by make\_crc\_table().}
00181 \textcolor{comment}{ */}
00182 \textcolor{preprocessor}{#include "crc32.h"}
00183 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* DYNAMIC\_CRC\_TABLE */}\textcolor{preprocessor}{}
00184 
00185 \textcolor{comment}{/* =========================================================================}
00186 \textcolor{comment}{ * This function can be used by asm versions of crc32()}
00187 \textcolor{comment}{ */}
00188 \textcolor{keyword}{const} z\_crc\_t FAR * ZEXPORT get\_crc\_table()
00189 \{
00190 \textcolor{preprocessor}{#ifdef DYNAMIC\_CRC\_TABLE}
00191     \textcolor{keywordflow}{if} (crc\_table\_empty)
00192         make\_crc\_table();
00193 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* DYNAMIC\_CRC\_TABLE */}\textcolor{preprocessor}{}
00194     \textcolor{keywordflow}{return} (\textcolor{keyword}{const} z\_crc\_t FAR *)crc\_table;
00195 \}
00196 
00197 \textcolor{comment}{/* ========================================================================= */}
00198 \textcolor{preprocessor}{#define DO1 crc = crc\_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)}
00199 \textcolor{preprocessor}{#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1}
00200 
00201 \textcolor{comment}{/* ========================================================================= */}
00202 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} ZEXPORT crc32\_z(crc, buf, len)
00203     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} crc;
00204     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *buf;
00205     z\_size\_t len;
00206 \{
00207     \textcolor{keywordflow}{if} (buf == Z\_NULL) \textcolor{keywordflow}{return} 0UL;
00208 
00209 \textcolor{preprocessor}{#ifdef DYNAMIC\_CRC\_TABLE}
00210     \textcolor{keywordflow}{if} (crc\_table\_empty)
00211         make\_crc\_table();
00212 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* DYNAMIC\_CRC\_TABLE */}\textcolor{preprocessor}{}
00213 
00214 \textcolor{preprocessor}{#ifdef BYFOUR}
00215     \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void} *) == \textcolor{keyword}{sizeof}(ptrdiff\_t)) \{
00216         z\_crc\_t endian;
00217 
00218         endian = 1;
00219         \textcolor{keywordflow}{if} (*((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)(&endian)))
00220             \textcolor{keywordflow}{return} crc32\_little(crc, buf, len);
00221         \textcolor{keywordflow}{else}
00222             \textcolor{keywordflow}{return} crc32\_big(crc, buf, len);
00223     \}
00224 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* BYFOUR */}\textcolor{preprocessor}{}
00225     crc = crc ^ 0xffffffffUL;
00226     \textcolor{keywordflow}{while} (len >= 8) \{
00227         DO8;
00228         len -= 8;
00229     \}
00230     \textcolor{keywordflow}{if} (len) \textcolor{keywordflow}{do} \{
00231         DO1;
00232     \} \textcolor{keywordflow}{while} (--len);
00233     \textcolor{keywordflow}{return} crc ^ 0xffffffffUL;
00234 \}
00235 
00236 \textcolor{comment}{/* ========================================================================= */}
00237 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} ZEXPORT crc32(crc, buf, len)
00238     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} crc;
00239     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *buf;
00240     uInt len;
00241 \{
00242     \textcolor{keywordflow}{return} crc32\_z(crc, buf, len);
00243 \}
00244 
00245 \textcolor{preprocessor}{#ifdef BYFOUR}
00246 
00247 \textcolor{comment}{/*}
00248 \textcolor{comment}{   This BYFOUR code accesses the passed unsigned char * buffer with a 32-bit}
00249 \textcolor{comment}{   integer pointer type. This violates the strict aliasing rule, where a}
00250 \textcolor{comment}{   compiler can assume, for optimization purposes, that two pointers to}
00251 \textcolor{comment}{   fundamentally different types won't ever point to the same memory. This can}
00252 \textcolor{comment}{   manifest as a problem only if one of the pointers is written to. This code}
00253 \textcolor{comment}{   only reads from those pointers. So long as this code remains isolated in}
00254 \textcolor{comment}{   this compilation unit, there won't be a problem. For this reason, this code}
00255 \textcolor{comment}{   should not be copied and pasted into a compilation unit in which other code}
00256 \textcolor{comment}{   writes to the buffer that is passed to these routines.}
00257 \textcolor{comment}{ */}
00258 
00259 \textcolor{comment}{/* ========================================================================= */}
00260 \textcolor{preprocessor}{#define DOLIT4 c ^= *buf4++; \(\backslash\)}
00261 \textcolor{preprocessor}{        c = crc\_table[3][c & 0xff] ^ crc\_table[2][(c >> 8) & 0xff] ^ \(\backslash\)}
00262 \textcolor{preprocessor}{            crc\_table[1][(c >> 16) & 0xff] ^ crc\_table[0][c >> 24]}
00263 \textcolor{preprocessor}{#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4}
00264 
00265 \textcolor{comment}{/* ========================================================================= */}
00266 local \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} crc32\_little(crc, buf, len)
00267     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} crc;
00268     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *buf;
00269     z\_size\_t len;
00270 \{
00271     \textcolor{keyword}{register} z\_crc\_t c;
00272     \textcolor{keyword}{register} \textcolor{keyword}{const} z\_crc\_t FAR *buf4;
00273 
00274     c = (z\_crc\_t)crc;
00275     c = ~c;
00276     \textcolor{keywordflow}{while} (len && ((ptrdiff\_t)buf & 3)) \{
00277         c = crc\_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
00278         len--;
00279     \}
00280 
00281     buf4 = (\textcolor{keyword}{const} z\_crc\_t FAR *)(\textcolor{keyword}{const} \textcolor{keywordtype}{void} FAR *)buf;
00282     \textcolor{keywordflow}{while} (len >= 32) \{
00283         DOLIT32;
00284         len -= 32;
00285     \}
00286     \textcolor{keywordflow}{while} (len >= 4) \{
00287         DOLIT4;
00288         len -= 4;
00289     \}
00290     buf = (\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *)buf4;
00291 
00292     \textcolor{keywordflow}{if} (len) \textcolor{keywordflow}{do} \{
00293         c = crc\_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
00294     \} \textcolor{keywordflow}{while} (--len);
00295     c = ~c;
00296     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})c;
00297 \}
00298 
00299 \textcolor{comment}{/* ========================================================================= */}
00300 \textcolor{preprocessor}{#define DOBIG4 c ^= *buf4++; \(\backslash\)}
00301 \textcolor{preprocessor}{        c = crc\_table[4][c & 0xff] ^ crc\_table[5][(c >> 8) & 0xff] ^ \(\backslash\)}
00302 \textcolor{preprocessor}{            crc\_table[6][(c >> 16) & 0xff] ^ crc\_table[7][c >> 24]}
00303 \textcolor{preprocessor}{#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4}
00304 
00305 \textcolor{comment}{/* ========================================================================= */}
00306 local \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} crc32\_big(crc, buf, len)
00307     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} crc;
00308     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *buf;
00309     z\_size\_t len;
00310 \{
00311     \textcolor{keyword}{register} z\_crc\_t c;
00312     \textcolor{keyword}{register} \textcolor{keyword}{const} z\_crc\_t FAR *buf4;
00313 
00314     c = ZSWAP32((z\_crc\_t)crc);
00315     c = ~c;
00316     \textcolor{keywordflow}{while} (len && ((ptrdiff\_t)buf & 3)) \{
00317         c = crc\_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
00318         len--;
00319     \}
00320 
00321     buf4 = (\textcolor{keyword}{const} z\_crc\_t FAR *)(\textcolor{keyword}{const} \textcolor{keywordtype}{void} FAR *)buf;
00322     \textcolor{keywordflow}{while} (len >= 32) \{
00323         DOBIG32;
00324         len -= 32;
00325     \}
00326     \textcolor{keywordflow}{while} (len >= 4) \{
00327         DOBIG4;
00328         len -= 4;
00329     \}
00330     buf = (\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} FAR *)buf4;
00331 
00332     \textcolor{keywordflow}{if} (len) \textcolor{keywordflow}{do} \{
00333         c = crc\_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
00334     \} \textcolor{keywordflow}{while} (--len);
00335     c = ~c;
00336     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})(ZSWAP32(c));
00337 \}
00338 
00339 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* BYFOUR */}\textcolor{preprocessor}{}
00340 
00341 \textcolor{preprocessor}{#define GF2\_DIM 32      }\textcolor{comment}{/* dimension of GF(2) vectors (length of CRC) */}\textcolor{preprocessor}{}
00342 
00343 \textcolor{comment}{/* ========================================================================= */}
00344 local \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} gf2\_matrix\_times(mat, vec)
00345     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *mat;
00346     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} vec;
00347 \{
00348     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} sum;
00349 
00350     sum = 0;
00351     \textcolor{keywordflow}{while} (vec) \{
00352         \textcolor{keywordflow}{if} (vec & 1)
00353             sum ^= *mat;
00354         vec >>= 1;
00355         mat++;
00356     \}
00357     \textcolor{keywordflow}{return} sum;
00358 \}
00359 
00360 \textcolor{comment}{/* ========================================================================= */}
00361 local \textcolor{keywordtype}{void} gf2\_matrix\_square(square, mat)
00362     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *square;
00363     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *mat;
00364 \{
00365     \textcolor{keywordtype}{int} n;
00366 
00367     \textcolor{keywordflow}{for} (n = 0; n < GF2\_DIM; n++)
00368         square[n] = gf2\_matrix\_times(mat, mat[n]);
00369 \}
00370 
00371 \textcolor{comment}{/* ========================================================================= */}
00372 local uLong crc32\_combine\_(crc1, crc2, len2)
00373     uLong crc1;
00374     uLong crc2;
00375     z\_off64\_t len2;
00376 \{
00377     \textcolor{keywordtype}{int} n;
00378     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} row;
00379     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} even[GF2\_DIM];    \textcolor{comment}{/* even-power-of-two zeros operator */}
00380     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} odd[GF2\_DIM];     \textcolor{comment}{/* odd-power-of-two zeros operator */}
00381 
00382     \textcolor{comment}{/* degenerate case (also disallow negative lengths) */}
00383     \textcolor{keywordflow}{if} (len2 <= 0)
00384         \textcolor{keywordflow}{return} crc1;
00385 
00386     \textcolor{comment}{/* put operator for one zero bit in odd */}
00387     odd[0] = 0xedb88320UL;          \textcolor{comment}{/* CRC-32 polynomial */}
00388     row = 1;
00389     \textcolor{keywordflow}{for} (n = 1; n < GF2\_DIM; n++) \{
00390         odd[n] = row;
00391         row <<= 1;
00392     \}
00393 
00394     \textcolor{comment}{/* put operator for two zero bits in even */}
00395     gf2\_matrix\_square(even, odd);
00396 
00397     \textcolor{comment}{/* put operator for four zero bits in odd */}
00398     gf2\_matrix\_square(odd, even);
00399 
00400     \textcolor{comment}{/* apply len2 zeros to crc1 (first square will put the operator for one}
00401 \textcolor{comment}{       zero byte, eight zero bits, in even) */}
00402     \textcolor{keywordflow}{do} \{
00403         \textcolor{comment}{/* apply zeros operator for this bit of len2 */}
00404         gf2\_matrix\_square(even, odd);
00405         \textcolor{keywordflow}{if} (len2 & 1)
00406             crc1 = gf2\_matrix\_times(even, crc1);
00407         len2 >>= 1;
00408 
00409         \textcolor{comment}{/* if no more bits set, then done */}
00410         \textcolor{keywordflow}{if} (len2 == 0)
00411             \textcolor{keywordflow}{break};
00412 
00413         \textcolor{comment}{/* another iteration of the loop with odd and even swapped */}
00414         gf2\_matrix\_square(odd, even);
00415         \textcolor{keywordflow}{if} (len2 & 1)
00416             crc1 = gf2\_matrix\_times(odd, crc1);
00417         len2 >>= 1;
00418 
00419         \textcolor{comment}{/* if no more bits set, then done */}
00420     \} \textcolor{keywordflow}{while} (len2 != 0);
00421 
00422     \textcolor{comment}{/* return combined crc */}
00423     crc1 ^= crc2;
00424     \textcolor{keywordflow}{return} crc1;
00425 \}
00426 
00427 \textcolor{comment}{/* ========================================================================= */}
00428 uLong ZEXPORT crc32\_combine(crc1, crc2, len2)
00429     uLong crc1;
00430     uLong crc2;
00431     z\_off\_t len2;
00432 \{
00433     \textcolor{keywordflow}{return} crc32\_combine\_(crc1, crc2, len2);
00434 \}
00435 
00436 uLong ZEXPORT crc32\_combine64(crc1, crc2, len2)
00437     uLong crc1;
00438     uLong crc2;
00439     z\_off64\_t len2;
00440 \{
00441     \textcolor{keywordflow}{return} crc32\_combine\_(crc1, crc2, len2);
00442 \}
\end{DoxyCode}
