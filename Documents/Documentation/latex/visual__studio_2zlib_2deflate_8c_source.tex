\hypertarget{visual__studio_2zlib_2deflate_8c_source}{}\section{visual\+\_\+studio/zlib/deflate.c}
\label{visual__studio_2zlib_2deflate_8c_source}\index{deflate.\+c@{deflate.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* deflate.c -- compress data using the deflation algorithm}
00002 \textcolor{comment}{ * Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ */}
00005 
00006 \textcolor{comment}{/*}
00007 \textcolor{comment}{ *  ALGORITHM}
00008 \textcolor{comment}{ *}
00009 \textcolor{comment}{ *      The "deflation" process depends on being able to identify portions}
00010 \textcolor{comment}{ *      of the input text which are identical to earlier input (within a}
00011 \textcolor{comment}{ *      sliding window trailing behind the input currently being processed).}
00012 \textcolor{comment}{ *}
00013 \textcolor{comment}{ *      The most straightforward technique turns out to be the fastest for}
00014 \textcolor{comment}{ *      most input files: try all possible matches and select the longest.}
00015 \textcolor{comment}{ *      The key feature of this algorithm is that insertions into the string}
00016 \textcolor{comment}{ *      dictionary are very simple and thus fast, and deletions are avoided}
00017 \textcolor{comment}{ *      completely. Insertions are performed at each input character, whereas}
00018 \textcolor{comment}{ *      string matches are performed only when the previous match ends. So it}
00019 \textcolor{comment}{ *      is preferable to spend more time in matches to allow very fast string}
00020 \textcolor{comment}{ *      insertions and avoid deletions. The matching algorithm for small}
00021 \textcolor{comment}{ *      strings is inspired from that of Rabin & Karp. A brute force approach}
00022 \textcolor{comment}{ *      is used to find longer strings when a small match has been found.}
00023 \textcolor{comment}{ *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze}
00024 \textcolor{comment}{ *      (by Leonid Broukhis).}
00025 \textcolor{comment}{ *         A previous version of this file used a more sophisticated algorithm}
00026 \textcolor{comment}{ *      (by Fiala and Greene) which is guaranteed to run in linear amortized}
00027 \textcolor{comment}{ *      time, but has a larger average cost, uses more memory and is patented.}
00028 \textcolor{comment}{ *      However the F&G algorithm may be faster for some highly redundant}
00029 \textcolor{comment}{ *      files if the parameter max\_chain\_length (described below) is too large.}
00030 \textcolor{comment}{ *}
00031 \textcolor{comment}{ *  ACKNOWLEDGEMENTS}
00032 \textcolor{comment}{ *}
00033 \textcolor{comment}{ *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and}
00034 \textcolor{comment}{ *      I found it in 'freeze' written by Leonid Broukhis.}
00035 \textcolor{comment}{ *      Thanks to many people for bug reports and testing.}
00036 \textcolor{comment}{ *}
00037 \textcolor{comment}{ *  REFERENCES}
00038 \textcolor{comment}{ *}
00039 \textcolor{comment}{ *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".}
00040 \textcolor{comment}{ *      Available in http://tools.ietf.org/html/rfc1951}
00041 \textcolor{comment}{ *}
00042 \textcolor{comment}{ *      A description of the Rabin and Karp algorithm is given in the book}
00043 \textcolor{comment}{ *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.}
00044 \textcolor{comment}{ *}
00045 \textcolor{comment}{ *      Fiala,E.R., and Greene,D.H.}
00046 \textcolor{comment}{ *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595}
00047 \textcolor{comment}{ *}
00048 \textcolor{comment}{ */}
00049 
00050 \textcolor{comment}{/* @(#) $Id$ */}
00051 
00052 \textcolor{preprocessor}{#include "deflate.h"}
00053 
00054 \textcolor{keyword}{const} \textcolor{keywordtype}{char} deflate\_copyright[] =
00055    \textcolor{stringliteral}{" deflate 1.2.11 Copyright 1995-2017 Jean-loup Gailly and Mark Adler "};
00056 \textcolor{comment}{/*}
00057 \textcolor{comment}{  If you use the zlib library in a product, an acknowledgment is welcome}
00058 \textcolor{comment}{  in the documentation of your product. If for some reason you cannot}
00059 \textcolor{comment}{  include such an acknowledgment, I would appreciate that you keep this}
00060 \textcolor{comment}{  copyright string in the executable of your product.}
00061 \textcolor{comment}{ */}
00062 
00063 \textcolor{comment}{/* ===========================================================================}
00064 \textcolor{comment}{ *  Function prototypes.}
00065 \textcolor{comment}{ */}
00066 \textcolor{keyword}{typedef} \textcolor{keyword}{enum} \{
00067     need\_more,      \textcolor{comment}{/* block not completed, need more input or more output */}
00068     block\_done,     \textcolor{comment}{/* block flush performed */}
00069     finish\_started, \textcolor{comment}{/* finish started, need only more output at next deflate */}
00070     finish\_done     \textcolor{comment}{/* finish done, accept no more input or output */}
00071 \} block\_state;
00072 
00073 \textcolor{keyword}{typedef} block\_state (*compress\_func) OF((\hyperlink{structinternal__state}{deflate\_state} *s, \textcolor{keywordtype}{int} flush));
00074 \textcolor{comment}{/* Compression function. Returns the block state after the call. */}
00075 
00076 local \textcolor{keywordtype}{int} deflateStateCheck      OF((z\_streamp strm));
00077 local \textcolor{keywordtype}{void} slide\_hash     OF((\hyperlink{structinternal__state}{deflate\_state} *s));
00078 local \textcolor{keywordtype}{void} fill\_window    OF((\hyperlink{structinternal__state}{deflate\_state} *s));
00079 local block\_state deflate\_stored OF((\hyperlink{structinternal__state}{deflate\_state} *s, \textcolor{keywordtype}{int} flush));
00080 local block\_state deflate\_fast   OF((\hyperlink{structinternal__state}{deflate\_state} *s, \textcolor{keywordtype}{int} flush));
00081 \textcolor{preprocessor}{#ifndef FASTEST}
00082 local block\_state deflate\_slow   OF((\hyperlink{structinternal__state}{deflate\_state} *s, \textcolor{keywordtype}{int} flush));
00083 \textcolor{preprocessor}{#endif}
00084 local block\_state deflate\_rle    OF((\hyperlink{structinternal__state}{deflate\_state} *s, \textcolor{keywordtype}{int} flush));
00085 local block\_state deflate\_huff   OF((\hyperlink{structinternal__state}{deflate\_state} *s, \textcolor{keywordtype}{int} flush));
00086 local \textcolor{keywordtype}{void} lm\_init        OF((\hyperlink{structinternal__state}{deflate\_state} *s));
00087 local \textcolor{keywordtype}{void} putShortMSB    OF((\hyperlink{structinternal__state}{deflate\_state} *s, uInt b));
00088 local \textcolor{keywordtype}{void} flush\_pending  OF((z\_streamp strm));
00089 local \textcolor{keywordtype}{unsigned} read\_buf   OF((z\_streamp strm, Bytef *buf, \textcolor{keywordtype}{unsigned} size));
00090 \textcolor{preprocessor}{#ifdef ASMV}
00091 \textcolor{preprocessor}{#  pragma message("Assembler code may have bugs -- use at your own risk")}
00092       \textcolor{keywordtype}{void} match\_init OF((\textcolor{keywordtype}{void})); \textcolor{comment}{/* asm code initialization */}
00093       uInt longest\_match  OF((\hyperlink{structinternal__state}{deflate\_state} *s, IPos cur\_match));
00094 \textcolor{preprocessor}{#else}
00095 local uInt longest\_match  OF((\hyperlink{structinternal__state}{deflate\_state} *s, IPos cur\_match));
00096 \textcolor{preprocessor}{#endif}
00097 
00098 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
00099 local  \textcolor{keywordtype}{void} check\_match OF((\hyperlink{structinternal__state}{deflate\_state} *s, IPos start, IPos match,
00100                             \textcolor{keywordtype}{int} length));
00101 \textcolor{preprocessor}{#endif}
00102 
00103 \textcolor{comment}{/* ===========================================================================}
00104 \textcolor{comment}{ * Local data}
00105 \textcolor{comment}{ */}
00106 
00107 \textcolor{preprocessor}{#define NIL 0}
00108 \textcolor{comment}{/* Tail of hash chains */}
00109 
00110 \textcolor{preprocessor}{#ifndef TOO\_FAR}
00111 \textcolor{preprocessor}{#  define TOO\_FAR 4096}
00112 \textcolor{preprocessor}{#endif}
00113 \textcolor{comment}{/* Matches of length 3 are discarded if their distance exceeds TOO\_FAR */}
00114 
00115 \textcolor{comment}{/* Values for max\_lazy\_match, good\_match and max\_chain\_length, depending on}
00116 \textcolor{comment}{ * the desired pack level (0..9). The values given below have been tuned to}
00117 \textcolor{comment}{ * exclude worst case performance for pathological files. Better values may be}
00118 \textcolor{comment}{ * found for specific files.}
00119 \textcolor{comment}{ */}
\Hypertarget{visual__studio_2zlib_2deflate_8c_source_l00120}\hyperlink{structconfig__s}{00120} \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\hyperlink{structconfig__s}{config\_s} \{
00121    ush good\_length; \textcolor{comment}{/* reduce lazy search above this match length */}
00122    ush max\_lazy;    \textcolor{comment}{/* do not perform lazy search above this match length */}
00123    ush nice\_length; \textcolor{comment}{/* quit search above this match length */}
00124    ush max\_chain;
00125    compress\_func \hyperlink{structfunc}{func};
00126 \} \hyperlink{structconfig__s}{config};
00127 
00128 \textcolor{preprocessor}{#ifdef FASTEST}
00129 local \textcolor{keyword}{const} \hyperlink{structconfig__s}{config} configuration\_table[2] = \{
00130 \textcolor{comment}{/*      good lazy nice chain */}
00131 \textcolor{comment}{/* 0 */} \{0,    0,  0,    0, deflate\_stored\},  \textcolor{comment}{/* store only */}
00132 \textcolor{comment}{/* 1 */} \{4,    4,  8,    4, deflate\_fast\}\}; \textcolor{comment}{/* max speed, no lazy matches */}
00133 \textcolor{preprocessor}{#else}
00134 local \textcolor{keyword}{const} \hyperlink{structconfig__s}{config} configuration\_table[10] = \{
00135 \textcolor{comment}{/*      good lazy nice chain */}
00136 \textcolor{comment}{/* 0 */} \{0,    0,  0,    0, deflate\_stored\},  \textcolor{comment}{/* store only */}
00137 \textcolor{comment}{/* 1 */} \{4,    4,  8,    4, deflate\_fast\}, \textcolor{comment}{/* max speed, no lazy matches */}
00138 \textcolor{comment}{/* 2 */} \{4,    5, 16,    8, deflate\_fast\},
00139 \textcolor{comment}{/* 3 */} \{4,    6, 32,   32, deflate\_fast\},
00140 
00141 \textcolor{comment}{/* 4 */} \{4,    4, 16,   16, deflate\_slow\},  \textcolor{comment}{/* lazy matches */}
00142 \textcolor{comment}{/* 5 */} \{8,   16, 32,   32, deflate\_slow\},
00143 \textcolor{comment}{/* 6 */} \{8,   16, 128, 128, deflate\_slow\},
00144 \textcolor{comment}{/* 7 */} \{8,   32, 128, 256, deflate\_slow\},
00145 \textcolor{comment}{/* 8 */} \{32, 128, 258, 1024, deflate\_slow\},
00146 \textcolor{comment}{/* 9 */} \{32, 258, 258, 4096, deflate\_slow\}\}; \textcolor{comment}{/* max compression */}
00147 \textcolor{preprocessor}{#endif}
00148 
00149 \textcolor{comment}{/* Note: the deflate() code requires max\_lazy >= MIN\_MATCH and max\_chain >= 4}
00150 \textcolor{comment}{ * For deflate\_fast() (levels <= 3) good is ignored and lazy has a different}
00151 \textcolor{comment}{ * meaning.}
00152 \textcolor{comment}{ */}
00153 
00154 \textcolor{comment}{/* rank Z\_BLOCK between Z\_NO\_FLUSH and Z\_PARTIAL\_FLUSH */}
00155 \textcolor{preprocessor}{#define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))}
00156 
00157 \textcolor{comment}{/* ===========================================================================}
00158 \textcolor{comment}{ * Update a hash value with the given input byte}
00159 \textcolor{comment}{ * IN  assertion: all calls to UPDATE\_HASH are made with consecutive input}
00160 \textcolor{comment}{ *    characters, so that a running hash key can be computed from the previous}
00161 \textcolor{comment}{ *    key instead of complete recalculation each time.}
00162 \textcolor{comment}{ */}
00163 \textcolor{preprocessor}{#define UPDATE\_HASH(s,h,c) (h = (((h)<<s->hash\_shift) ^ (c)) & s->hash\_mask)}
00164 
00165 
00166 \textcolor{comment}{/* ===========================================================================}
00167 \textcolor{comment}{ * Insert string str in the dictionary and set match\_head to the previous head}
00168 \textcolor{comment}{ * of the hash chain (the most recent string with same hash key). Return}
00169 \textcolor{comment}{ * the previous length of the hash chain.}
00170 \textcolor{comment}{ * If this file is compiled with -DFASTEST, the compression level is forced}
00171 \textcolor{comment}{ * to 1, and no hash chains are maintained.}
00172 \textcolor{comment}{ * IN  assertion: all calls to INSERT\_STRING are made with consecutive input}
00173 \textcolor{comment}{ *    characters and the first MIN\_MATCH bytes of str are valid (except for}
00174 \textcolor{comment}{ *    the last MIN\_MATCH-1 bytes of the input file).}
00175 \textcolor{comment}{ */}
00176 \textcolor{preprocessor}{#ifdef FASTEST}
00177 \textcolor{preprocessor}{#define INSERT\_STRING(s, str, match\_head) \(\backslash\)}
00178 \textcolor{preprocessor}{   (UPDATE\_HASH(s, s->ins\_h, s->window[(str) + (MIN\_MATCH-1)]), \(\backslash\)}
00179 \textcolor{preprocessor}{    match\_head = s->head[s->ins\_h], \(\backslash\)}
00180 \textcolor{preprocessor}{    s->head[s->ins\_h] = (Pos)(str))}
00181 \textcolor{preprocessor}{#else}
00182 \textcolor{preprocessor}{#define INSERT\_STRING(s, str, match\_head) \(\backslash\)}
00183 \textcolor{preprocessor}{   (UPDATE\_HASH(s, s->ins\_h, s->window[(str) + (MIN\_MATCH-1)]), \(\backslash\)}
00184 \textcolor{preprocessor}{    match\_head = s->prev[(str) & s->w\_mask] = s->head[s->ins\_h], \(\backslash\)}
00185 \textcolor{preprocessor}{    s->head[s->ins\_h] = (Pos)(str))}
00186 \textcolor{preprocessor}{#endif}
00187 
00188 \textcolor{comment}{/* ===========================================================================}
00189 \textcolor{comment}{ * Initialize the hash table (avoiding 64K overflow for 16 bit systems).}
00190 \textcolor{comment}{ * prev[] will be initialized on the fly.}
00191 \textcolor{comment}{ */}
00192 \textcolor{preprocessor}{#define CLEAR\_HASH(s) \(\backslash\)}
00193 \textcolor{preprocessor}{    s->head[s->hash\_size-1] = NIL; \(\backslash\)}
00194 \textcolor{preprocessor}{    zmemzero((Bytef *)s->head, (unsigned)(s->hash\_size-1)*sizeof(*s->head));}
00195 
00196 \textcolor{comment}{/* ===========================================================================}
00197 \textcolor{comment}{ * Slide the hash table when sliding the window down (could be avoided with 32}
00198 \textcolor{comment}{ * bit values at the expense of memory usage). We slide even when level == 0 to}
00199 \textcolor{comment}{ * keep the hash table consistent if we switch back to level > 0 later.}
00200 \textcolor{comment}{ */}
00201 local \textcolor{keywordtype}{void} slide\_hash(s)
00202     \hyperlink{structinternal__state}{deflate\_state} *s;
00203 \{
00204     \textcolor{keywordtype}{unsigned} n, m;
00205     Posf *p;
00206     uInt wsize = s->w\_size;
00207 
00208     n = s->hash\_size;
00209     p = &s->head[n];
00210     \textcolor{keywordflow}{do} \{
00211         m = *--p;
00212         *p = (Pos)(m >= wsize ? m - wsize : NIL);
00213     \} \textcolor{keywordflow}{while} (--n);
00214     n = wsize;
00215 \textcolor{preprocessor}{#ifndef FASTEST}
00216     p = &s->prev[n];
00217     \textcolor{keywordflow}{do} \{
00218         m = *--p;
00219         *p = (Pos)(m >= wsize ? m - wsize : NIL);
00220         \textcolor{comment}{/* If n is not on any hash chain, prev[n] is garbage but}
00221 \textcolor{comment}{         * its value will never be used.}
00222 \textcolor{comment}{         */}
00223     \} \textcolor{keywordflow}{while} (--n);
00224 \textcolor{preprocessor}{#endif}
00225 \}
00226 
00227 \textcolor{comment}{/* ========================================================================= */}
00228 \textcolor{keywordtype}{int} ZEXPORT deflateInit\_(strm, level, version, stream\_size)
00229     z\_streamp strm;
00230     \textcolor{keywordtype}{int} level;
00231     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version;
00232     \textcolor{keywordtype}{int} stream\_size;
00233 \{
00234     \textcolor{keywordflow}{return} deflateInit2\_(strm, level, Z\_DEFLATED, MAX\_WBITS, DEF\_MEM\_LEVEL,
00235                          Z\_DEFAULT\_STRATEGY, version, stream\_size);
00236     \textcolor{comment}{/* To do: ignore strm->next\_in if we use it as window */}
00237 \}
00238 
00239 \textcolor{comment}{/* ========================================================================= */}
00240 \textcolor{keywordtype}{int} ZEXPORT deflateInit2\_(strm, level, method, windowBits, memLevel, strategy,
00241                   version, stream\_size)
00242     z\_streamp strm;
00243     \textcolor{keywordtype}{int}  level;
00244     \textcolor{keywordtype}{int}  method;
00245     \textcolor{keywordtype}{int}  windowBits;
00246     \textcolor{keywordtype}{int}  memLevel;
00247     \textcolor{keywordtype}{int}  strategy;
00248     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *version;
00249     \textcolor{keywordtype}{int} stream\_size;
00250 \{
00251     \hyperlink{structinternal__state}{deflate\_state} *s;
00252     \textcolor{keywordtype}{int} wrap = 1;
00253     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} my\_version[] = ZLIB\_VERSION;
00254 
00255     ushf *overlay;
00256     \textcolor{comment}{/* We overlay pending\_buf and d\_buf+l\_buf. This works since the average}
00257 \textcolor{comment}{     * output size for (length,distance) codes is <= 24 bits.}
00258 \textcolor{comment}{     */}
00259 
00260     \textcolor{keywordflow}{if} (version == Z\_NULL || version[0] != my\_version[0] ||
00261         stream\_size != \textcolor{keyword}{sizeof}(\hyperlink{structz__stream__s}{z\_stream})) \{
00262         \textcolor{keywordflow}{return} Z\_VERSION\_ERROR;
00263     \}
00264     \textcolor{keywordflow}{if} (strm == Z\_NULL) \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00265 
00266     strm->msg = Z\_NULL;
00267     \textcolor{keywordflow}{if} (strm->zalloc == (alloc\_func)0) \{
00268 \textcolor{preprocessor}{#ifdef Z\_SOLO}
00269         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00270 \textcolor{preprocessor}{#else}
00271         strm->zalloc = zcalloc;
00272         strm->opaque = (voidpf)0;
00273 \textcolor{preprocessor}{#endif}
00274     \}
00275     \textcolor{keywordflow}{if} (strm->zfree == (free\_func)0)
00276 #ifdef Z\_SOLO
00277         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00278 \textcolor{preprocessor}{#else}
00279         strm->zfree = zcfree;
00280 \textcolor{preprocessor}{#endif}
00281 
00282 \textcolor{preprocessor}{#ifdef FASTEST}
00283     \textcolor{keywordflow}{if} (level != 0) level = 1;
00284 \textcolor{preprocessor}{#else}
00285     \textcolor{keywordflow}{if} (level == Z\_DEFAULT\_COMPRESSION) level = 6;
00286 \textcolor{preprocessor}{#endif}
00287 
00288     \textcolor{keywordflow}{if} (windowBits < 0) \{ \textcolor{comment}{/* suppress zlib wrapper */}
00289         wrap = 0;
00290         windowBits = -windowBits;
00291     \}
00292 \textcolor{preprocessor}{#ifdef GZIP}
00293     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (windowBits > 15) \{
00294         wrap = 2;       \textcolor{comment}{/* write gzip wrapper instead */}
00295         windowBits -= 16;
00296     \}
00297 \textcolor{preprocessor}{#endif}
00298     \textcolor{keywordflow}{if} (memLevel < 1 || memLevel > MAX\_MEM\_LEVEL || method != Z\_DEFLATED ||
00299         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
00300         strategy < 0 || strategy > Z\_FIXED || (windowBits == 8 && wrap != 1)) \{
00301         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00302     \}
00303     \textcolor{keywordflow}{if} (windowBits == 8) windowBits = 9;  \textcolor{comment}{/* until 256-byte window bug fixed */}
00304     s = (\hyperlink{structinternal__state}{deflate\_state} *) ZALLOC(strm, 1, \textcolor{keyword}{sizeof}(\hyperlink{structinternal__state}{deflate\_state}));
00305     \textcolor{keywordflow}{if} (s == Z\_NULL) \textcolor{keywordflow}{return} Z\_MEM\_ERROR;
00306     strm->state = (\textcolor{keyword}{struct }\hyperlink{structinternal__state}{internal\_state} FAR *)s;
00307     s->strm = strm;
00308     s->status = INIT\_STATE;     \textcolor{comment}{/* to pass state test in deflateReset() */}
00309 
00310     s->wrap = wrap;
00311     s->gzhead = Z\_NULL;
00312     s->w\_bits = (uInt)windowBits;
00313     s->w\_size = 1 << s->w\_bits;
00314     s->w\_mask = s->w\_size - 1;
00315 
00316     s->hash\_bits = (uInt)memLevel + 7;
00317     s->hash\_size = 1 << s->hash\_bits;
00318     s->hash\_mask = s->hash\_size - 1;
00319     s->hash\_shift =  ((s->hash\_bits+MIN\_MATCH-1)/MIN\_MATCH);
00320 
00321     s->window = (Bytef *) ZALLOC(strm, s->w\_size, 2*\textcolor{keyword}{sizeof}(Byte));
00322     s->prev   = (Posf *)  ZALLOC(strm, s->w\_size, \textcolor{keyword}{sizeof}(Pos));
00323     s->head   = (Posf *)  ZALLOC(strm, s->hash\_size, \textcolor{keyword}{sizeof}(Pos));
00324 
00325     s->high\_water = 0;      \textcolor{comment}{/* nothing written to s->window yet */}
00326 
00327     s->lit\_bufsize = 1 << (memLevel + 6); \textcolor{comment}{/* 16K elements by default */}
00328 
00329     overlay = (ushf *) ZALLOC(strm, s->lit\_bufsize, \textcolor{keyword}{sizeof}(ush)+2);
00330     s->pending\_buf = (uchf *) overlay;
00331     s->pending\_buf\_size = (ulg)s->lit\_bufsize * (\textcolor{keyword}{sizeof}(ush)+2L);
00332 
00333     \textcolor{keywordflow}{if} (s->window == Z\_NULL || s->prev == Z\_NULL || s->head == Z\_NULL ||
00334         s->pending\_buf == Z\_NULL) \{
00335         s->status = FINISH\_STATE;
00336         strm->msg = ERR\_MSG(Z\_MEM\_ERROR);
00337         deflateEnd (strm);
00338         \textcolor{keywordflow}{return} Z\_MEM\_ERROR;
00339     \}
00340     s->d\_buf = overlay + s->lit\_bufsize/\textcolor{keyword}{sizeof}(ush);
00341     s->l\_buf = s->pending\_buf + (1+\textcolor{keyword}{sizeof}(ush))*s->lit\_bufsize;
00342 
00343     s->level = level;
00344     s->strategy = strategy;
00345     s->method = (Byte)method;
00346 
00347     \textcolor{keywordflow}{return} deflateReset(strm);
00348 \}
00349 
00350 \textcolor{comment}{/* =========================================================================}
00351 \textcolor{comment}{ * Check for a valid deflate stream state. Return 0 if ok, 1 if not.}
00352 \textcolor{comment}{ */}
00353 local \textcolor{keywordtype}{int} deflateStateCheck (strm)
00354     z\_streamp strm;
00355 \{
00356     \hyperlink{structinternal__state}{deflate\_state} *s;
00357     \textcolor{keywordflow}{if} (strm == Z\_NULL ||
00358         strm->zalloc == (alloc\_func)0 || strm->zfree == (free\_func)0)
00359         \textcolor{keywordflow}{return} 1;
00360     s = strm->state;
00361     \textcolor{keywordflow}{if} (s == Z\_NULL || s->strm != strm || (s->status != INIT\_STATE &&
00362 #ifdef GZIP
00363                                            s->status != GZIP\_STATE &&
00364 #endif
00365                                            s->status != EXTRA\_STATE &&
00366                                            s->status != NAME\_STATE &&
00367                                            s->status != COMMENT\_STATE &&
00368                                            s->status != HCRC\_STATE &&
00369                                            s->status != BUSY\_STATE &&
00370                                            s->status != FINISH\_STATE))
00371         \textcolor{keywordflow}{return} 1;
00372     \textcolor{keywordflow}{return} 0;
00373 \}
00374 
00375 \textcolor{comment}{/* ========================================================================= */}
00376 \textcolor{keywordtype}{int} ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
00377     z\_streamp strm;
00378     \textcolor{keyword}{const} Bytef *dictionary;
00379     uInt  dictLength;
00380 \{
00381     \hyperlink{structinternal__state}{deflate\_state} *s;
00382     uInt str, n;
00383     \textcolor{keywordtype}{int} wrap;
00384     \textcolor{keywordtype}{unsigned} avail;
00385     z\_const \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *next;
00386 
00387     \textcolor{keywordflow}{if} (deflateStateCheck(strm) || dictionary == Z\_NULL)
00388         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00389     s = strm->state;
00390     wrap = s->wrap;
00391     \textcolor{keywordflow}{if} (wrap == 2 || (wrap == 1 && s->status != INIT\_STATE) || s->lookahead)
00392         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00393 
00394     \textcolor{comment}{/* when using zlib wrappers, compute Adler-32 for provided dictionary */}
00395     \textcolor{keywordflow}{if} (wrap == 1)
00396         strm->adler = adler32(strm->adler, dictionary, dictLength);
00397     s->wrap = 0;                    \textcolor{comment}{/* avoid computing Adler-32 in read\_buf */}
00398 
00399     \textcolor{comment}{/* if dictionary would fill window, just replace the history */}
00400     \textcolor{keywordflow}{if} (dictLength >= s->w\_size) \{
00401         \textcolor{keywordflow}{if} (wrap == 0) \{            \textcolor{comment}{/* already empty otherwise */}
00402             CLEAR\_HASH(s);
00403             s->strstart = 0;
00404             s->block\_start = 0L;
00405             s->insert = 0;
00406         \}
00407         dictionary += dictLength - s->w\_size;  \textcolor{comment}{/* use the tail */}
00408         dictLength = s->w\_size;
00409     \}
00410 
00411     \textcolor{comment}{/* insert dictionary into window and hash */}
00412     avail = strm->avail\_in;
00413     next = strm->next\_in;
00414     strm->avail\_in = dictLength;
00415     strm->next\_in = (z\_const Bytef *)dictionary;
00416     fill\_window(s);
00417     \textcolor{keywordflow}{while} (s->lookahead >= MIN\_MATCH) \{
00418         str = s->strstart;
00419         n = s->lookahead - (MIN\_MATCH-1);
00420         \textcolor{keywordflow}{do} \{
00421             UPDATE\_HASH(s, s->ins\_h, s->window[str + MIN\_MATCH-1]);
00422 \textcolor{preprocessor}{#ifndef FASTEST}
00423             s->prev[str & s->w\_mask] = s->head[s->ins\_h];
00424 \textcolor{preprocessor}{#endif}
00425             s->head[s->ins\_h] = (Pos)str;
00426             str++;
00427         \} \textcolor{keywordflow}{while} (--n);
00428         s->strstart = str;
00429         s->lookahead = MIN\_MATCH-1;
00430         fill\_window(s);
00431     \}
00432     s->strstart += s->lookahead;
00433     s->block\_start = (long)s->strstart;
00434     s->insert = s->lookahead;
00435     s->lookahead = 0;
00436     s->match\_length = s->prev\_length = MIN\_MATCH-1;
00437     s->match\_available = 0;
00438     strm->next\_in = next;
00439     strm->avail\_in = avail;
00440     s->wrap = wrap;
00441     \textcolor{keywordflow}{return} Z\_OK;
00442 \}
00443 
00444 \textcolor{comment}{/* ========================================================================= */}
00445 \textcolor{keywordtype}{int} ZEXPORT deflateGetDictionary (strm, dictionary, dictLength)
00446     z\_streamp strm;
00447     Bytef *dictionary;
00448     uInt  *dictLength;
00449 \{
00450     \hyperlink{structinternal__state}{deflate\_state} *s;
00451     uInt len;
00452 
00453     \textcolor{keywordflow}{if} (deflateStateCheck(strm))
00454         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00455     s = strm->state;
00456     len = s->strstart + s->lookahead;
00457     \textcolor{keywordflow}{if} (len > s->w\_size)
00458         len = s->w\_size;
00459     \textcolor{keywordflow}{if} (dictionary != Z\_NULL && len)
00460         zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);
00461     \textcolor{keywordflow}{if} (dictLength != Z\_NULL)
00462         *dictLength = len;
00463     \textcolor{keywordflow}{return} Z\_OK;
00464 \}
00465 
00466 \textcolor{comment}{/* ========================================================================= */}
00467 \textcolor{keywordtype}{int} ZEXPORT deflateResetKeep (strm)
00468     z\_streamp strm;
00469 \{
00470     \hyperlink{structinternal__state}{deflate\_state} *s;
00471 
00472     \textcolor{keywordflow}{if} (deflateStateCheck(strm)) \{
00473         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00474     \}
00475 
00476     strm->total\_in = strm->total\_out = 0;
00477     strm->msg = Z\_NULL; \textcolor{comment}{/* use zfree if we ever allocate msg dynamically */}
00478     strm->data\_type = Z\_UNKNOWN;
00479 
00480     s = (\hyperlink{structinternal__state}{deflate\_state} *)strm->state;
00481     s->pending = 0;
00482     s->pending\_out = s->pending\_buf;
00483 
00484     if (s->wrap < 0) \{
00485         s->wrap = -s->wrap; \textcolor{comment}{/* was made negative by deflate(..., Z\_FINISH); */}
00486     \}
00487     s->status =
00488 \textcolor{preprocessor}{#ifdef GZIP}
00489         s->wrap == 2 ? GZIP\_STATE :
00490 \textcolor{preprocessor}{#endif}
00491         s->wrap ? INIT\_STATE : BUSY\_STATE;
00492     strm->adler =
00493 \textcolor{preprocessor}{#ifdef GZIP}
00494         s->wrap == 2 ? crc32(0L, Z\_NULL, 0) :
00495 \textcolor{preprocessor}{#endif}
00496         adler32(0L, Z\_NULL, 0);
00497     s->last\_flush = Z\_NO\_FLUSH;
00498 
00499     \_tr\_init(s);
00500 
00501     \textcolor{keywordflow}{return} Z\_OK;
00502 \}
00503 
00504 \textcolor{comment}{/* ========================================================================= */}
00505 \textcolor{keywordtype}{int} ZEXPORT deflateReset (strm)
00506     z\_streamp strm;
00507 \{
00508     \textcolor{keywordtype}{int} ret;
00509 
00510     ret = deflateResetKeep(strm);
00511     \textcolor{keywordflow}{if} (ret == Z\_OK)
00512         lm\_init(strm->state);
00513     \textcolor{keywordflow}{return} ret;
00514 \}
00515 
00516 \textcolor{comment}{/* ========================================================================= */}
00517 \textcolor{keywordtype}{int} ZEXPORT deflateSetHeader (strm, head)
00518     z\_streamp strm;
00519     gz\_headerp head;
00520 \{
00521     \textcolor{keywordflow}{if} (deflateStateCheck(strm) || strm->state->wrap != 2)
00522         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00523     strm->state->gzhead = head;
00524     \textcolor{keywordflow}{return} Z\_OK;
00525 \}
00526 
00527 \textcolor{comment}{/* ========================================================================= */}
00528 \textcolor{keywordtype}{int} ZEXPORT deflatePending (strm, pending, bits)
00529     \textcolor{keywordtype}{unsigned} *pending;
00530     \textcolor{keywordtype}{int} *bits;
00531     z\_streamp strm;
00532 \{
00533     \textcolor{keywordflow}{if} (deflateStateCheck(strm)) \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00534     \textcolor{keywordflow}{if} (pending != Z\_NULL)
00535         *pending = strm->state->pending;
00536     \textcolor{keywordflow}{if} (bits != Z\_NULL)
00537         *bits = strm->state->bi\_valid;
00538     \textcolor{keywordflow}{return} Z\_OK;
00539 \}
00540 
00541 \textcolor{comment}{/* ========================================================================= */}
00542 \textcolor{keywordtype}{int} ZEXPORT deflatePrime (strm, bits, value)
00543     z\_streamp strm;
00544     \textcolor{keywordtype}{int} bits;
00545     \textcolor{keywordtype}{int} value;
00546 \{
00547     \hyperlink{structinternal__state}{deflate\_state} *s;
00548     \textcolor{keywordtype}{int} put;
00549 
00550     \textcolor{keywordflow}{if} (deflateStateCheck(strm)) \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00551     s = strm->state;
00552     \textcolor{keywordflow}{if} ((Bytef *)(s->d\_buf) < s->pending\_out + ((Buf\_size + 7) >> 3))
00553         \textcolor{keywordflow}{return} Z\_BUF\_ERROR;
00554     \textcolor{keywordflow}{do} \{
00555         put = Buf\_size - s->bi\_valid;
00556         \textcolor{keywordflow}{if} (put > bits)
00557             put = bits;
00558         s->bi\_buf |= (ush)((value & ((1 << put) - 1)) << s->bi\_valid);
00559         s->bi\_valid += put;
00560         \_tr\_flush\_bits(s);
00561         value >>= put;
00562         bits -= put;
00563     \} \textcolor{keywordflow}{while} (bits);
00564     \textcolor{keywordflow}{return} Z\_OK;
00565 \}
00566 
00567 \textcolor{comment}{/* ========================================================================= */}
00568 \textcolor{keywordtype}{int} ZEXPORT deflateParams(strm, level, strategy)
00569     z\_streamp strm;
00570     \textcolor{keywordtype}{int} level;
00571     \textcolor{keywordtype}{int} strategy;
00572 \{
00573     \hyperlink{structinternal__state}{deflate\_state} *s;
00574     compress\_func \hyperlink{structfunc}{func};
00575 
00576     \textcolor{keywordflow}{if} (deflateStateCheck(strm)) \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00577     s = strm->state;
00578 
00579 \textcolor{preprocessor}{#ifdef FASTEST}
00580     \textcolor{keywordflow}{if} (level != 0) level = 1;
00581 \textcolor{preprocessor}{#else}
00582     \textcolor{keywordflow}{if} (level == Z\_DEFAULT\_COMPRESSION) level = 6;
00583 \textcolor{preprocessor}{#endif}
00584     \textcolor{keywordflow}{if} (level < 0 || level > 9 || strategy < 0 || strategy > Z\_FIXED) \{
00585         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00586     \}
00587     func = configuration\_table[s->level].func;
00588 
00589     \textcolor{keywordflow}{if} ((strategy != s->strategy || func != configuration\_table[level].func) &&
00590         s->high\_water) \{
00591         \textcolor{comment}{/* Flush the last buffer: */}
00592         \textcolor{keywordtype}{int} err = deflate(strm, Z\_BLOCK);
00593         \textcolor{keywordflow}{if} (err == Z\_STREAM\_ERROR)
00594             \textcolor{keywordflow}{return} err;
00595         \textcolor{keywordflow}{if} (strm->avail\_out == 0)
00596             \textcolor{keywordflow}{return} Z\_BUF\_ERROR;
00597     \}
00598     \textcolor{keywordflow}{if} (s->level != level) \{
00599         \textcolor{keywordflow}{if} (s->level == 0 && s->matches != 0) \{
00600             \textcolor{keywordflow}{if} (s->matches == 1)
00601                 slide\_hash(s);
00602             \textcolor{keywordflow}{else}
00603                 CLEAR\_HASH(s);
00604             s->matches = 0;
00605         \}
00606         s->level = level;
00607         s->max\_lazy\_match   = configuration\_table[level].max\_lazy;
00608         s->good\_match       = configuration\_table[level].good\_length;
00609         s->nice\_match       = configuration\_table[level].nice\_length;
00610         s->max\_chain\_length = configuration\_table[level].max\_chain;
00611     \}
00612     s->strategy = strategy;
00613     \textcolor{keywordflow}{return} Z\_OK;
00614 \}
00615 
00616 \textcolor{comment}{/* ========================================================================= */}
00617 \textcolor{keywordtype}{int} ZEXPORT deflateTune(strm, good\_length, max\_lazy, nice\_length, max\_chain)
00618     z\_streamp strm;
00619     \textcolor{keywordtype}{int} good\_length;
00620     \textcolor{keywordtype}{int} max\_lazy;
00621     \textcolor{keywordtype}{int} nice\_length;
00622     \textcolor{keywordtype}{int} max\_chain;
00623 \{
00624     \hyperlink{structinternal__state}{deflate\_state} *s;
00625 
00626     \textcolor{keywordflow}{if} (deflateStateCheck(strm)) \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00627     s = strm->state;
00628     s->good\_match = (uInt)good\_length;
00629     s->max\_lazy\_match = (uInt)max\_lazy;
00630     s->nice\_match = nice\_length;
00631     s->max\_chain\_length = (uInt)max\_chain;
00632     \textcolor{keywordflow}{return} Z\_OK;
00633 \}
00634 
00635 \textcolor{comment}{/* =========================================================================}
00636 \textcolor{comment}{ * For the default windowBits of 15 and memLevel of 8, this function returns}
00637 \textcolor{comment}{ * a close to exact, as well as small, upper bound on the compressed size.}
00638 \textcolor{comment}{ * They are coded as constants here for a reason--if the #define's are}
00639 \textcolor{comment}{ * changed, then this function needs to be changed as well.  The return}
00640 \textcolor{comment}{ * value for 15 and 8 only works for those exact settings.}
00641 \textcolor{comment}{ *}
00642 \textcolor{comment}{ * For any setting other than those defaults for windowBits and memLevel,}
00643 \textcolor{comment}{ * the value returned is a conservative worst case for the maximum expansion}
00644 \textcolor{comment}{ * resulting from using fixed blocks instead of stored blocks, which deflate}
00645 \textcolor{comment}{ * can emit on compressed data for some combinations of the parameters.}
00646 \textcolor{comment}{ *}
00647 \textcolor{comment}{ * This function could be more sophisticated to provide closer upper bounds for}
00648 \textcolor{comment}{ * every combination of windowBits and memLevel.  But even the conservative}
00649 \textcolor{comment}{ * upper bound of about 14% expansion does not seem onerous for output buffer}
00650 \textcolor{comment}{ * allocation.}
00651 \textcolor{comment}{ */}
00652 uLong ZEXPORT deflateBound(strm, sourceLen)
00653     z\_streamp strm;
00654     uLong sourceLen;
00655 \{
00656     \hyperlink{structinternal__state}{deflate\_state} *s;
00657     uLong complen, wraplen;
00658 
00659     \textcolor{comment}{/* conservative upper bound for compressed data */}
00660     complen = sourceLen +
00661               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
00662 
00663     \textcolor{comment}{/* if can't get parameters, return conservative bound plus zlib wrapper */}
00664     \textcolor{keywordflow}{if} (deflateStateCheck(strm))
00665         \textcolor{keywordflow}{return} complen + 6;
00666 
00667     \textcolor{comment}{/* compute wrapper length */}
00668     s = strm->state;
00669     \textcolor{keywordflow}{switch} (s->wrap) \{
00670     \textcolor{keywordflow}{case} 0:                                 \textcolor{comment}{/* raw deflate */}
00671         wraplen = 0;
00672         \textcolor{keywordflow}{break};
00673     \textcolor{keywordflow}{case} 1:                                 \textcolor{comment}{/* zlib wrapper */}
00674         wraplen = 6 + (s->strstart ? 4 : 0);
00675         \textcolor{keywordflow}{break};
00676 \textcolor{preprocessor}{#ifdef GZIP}
00677     \textcolor{keywordflow}{case} 2:                                 \textcolor{comment}{/* gzip wrapper */}
00678         wraplen = 18;
00679         \textcolor{keywordflow}{if} (s->gzhead != Z\_NULL) \{          \textcolor{comment}{/* user-supplied gzip header */}
00680             Bytef *str;
00681             \textcolor{keywordflow}{if} (s->gzhead->extra != Z\_NULL)
00682                 wraplen += 2 + s->gzhead->extra\_len;
00683             str = s->gzhead->name;
00684             \textcolor{keywordflow}{if} (str != Z\_NULL)
00685                 \textcolor{keywordflow}{do} \{
00686                     wraplen++;
00687                 \} \textcolor{keywordflow}{while} (*str++);
00688             str = s->gzhead->comment;
00689             \textcolor{keywordflow}{if} (str != Z\_NULL)
00690                 \textcolor{keywordflow}{do} \{
00691                     wraplen++;
00692                 \} \textcolor{keywordflow}{while} (*str++);
00693             \textcolor{keywordflow}{if} (s->gzhead->hcrc)
00694                 wraplen += 2;
00695         \}
00696         \textcolor{keywordflow}{break};
00697 \textcolor{preprocessor}{#endif}
00698     \textcolor{keywordflow}{default}:                                \textcolor{comment}{/* for compiler happiness */}
00699         wraplen = 6;
00700     \}
00701 
00702     \textcolor{comment}{/* if not default parameters, return conservative bound */}
00703     \textcolor{keywordflow}{if} (s->w\_bits != 15 || s->hash\_bits != 8 + 7)
00704         \textcolor{keywordflow}{return} complen + wraplen;
00705 
00706     \textcolor{comment}{/* default settings: return tight bound for that case */}
00707     \textcolor{keywordflow}{return} sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
00708            (sourceLen >> 25) + 13 - 6 + wraplen;
00709 \}
00710 
00711 \textcolor{comment}{/* =========================================================================}
00712 \textcolor{comment}{ * Put a short in the pending buffer. The 16-bit value is put in MSB order.}
00713 \textcolor{comment}{ * IN assertion: the stream state is correct and there is enough room in}
00714 \textcolor{comment}{ * pending\_buf.}
00715 \textcolor{comment}{ */}
00716 local \textcolor{keywordtype}{void} putShortMSB (s, b)
00717     \hyperlink{structinternal__state}{deflate\_state} *s;
00718     uInt b;
00719 \{
00720     put\_byte(s, (Byte)(b >> 8));
00721     put\_byte(s, (Byte)(b & 0xff));
00722 \}
00723 
00724 \textcolor{comment}{/* =========================================================================}
00725 \textcolor{comment}{ * Flush as much pending output as possible. All deflate() output, except for}
00726 \textcolor{comment}{ * some deflate\_stored() output, goes through this function so some}
00727 \textcolor{comment}{ * applications may wish to modify it to avoid allocating a large}
00728 \textcolor{comment}{ * strm->next\_out buffer and copying into it. (See also read\_buf()).}
00729 \textcolor{comment}{ */}
00730 local \textcolor{keywordtype}{void} flush\_pending(strm)
00731     z\_streamp strm;
00732 \{
00733     \textcolor{keywordtype}{unsigned} len;
00734     \hyperlink{structinternal__state}{deflate\_state} *s = strm->state;
00735 
00736     \_tr\_flush\_bits(s);
00737     len = s->pending;
00738     \textcolor{keywordflow}{if} (len > strm->avail\_out) len = strm->avail\_out;
00739     \textcolor{keywordflow}{if} (len == 0) \textcolor{keywordflow}{return};
00740 
00741     zmemcpy(strm->next\_out, s->pending\_out, len);
00742     strm->next\_out  += len;
00743     s->pending\_out  += len;
00744     strm->total\_out += len;
00745     strm->avail\_out -= len;
00746     s->pending      -= len;
00747     \textcolor{keywordflow}{if} (s->pending == 0) \{
00748         s->pending\_out = s->pending\_buf;
00749     \}
00750 \}
00751 
00752 \textcolor{comment}{/* ===========================================================================}
00753 \textcolor{comment}{ * Update the header CRC with the bytes s->pending\_buf[beg..s->pending - 1].}
00754 \textcolor{comment}{ */}
00755 \textcolor{preprocessor}{#define HCRC\_UPDATE(beg) \(\backslash\)}
00756 \textcolor{preprocessor}{    do \{ \(\backslash\)}
00757 \textcolor{preprocessor}{        if (s->gzhead->hcrc && s->pending > (beg)) \(\backslash\)}
00758 \textcolor{preprocessor}{            strm->adler = crc32(strm->adler, s->pending\_buf + (beg), \(\backslash\)}
00759 \textcolor{preprocessor}{                                s->pending - (beg)); \(\backslash\)}
00760 \textcolor{preprocessor}{    \} while (0)}
00761 
00762 \textcolor{comment}{/* ========================================================================= */}
00763 \textcolor{keywordtype}{int} ZEXPORT deflate (strm, flush)
00764     z\_streamp strm;
00765     \textcolor{keywordtype}{int} flush;
00766 \{
00767     \textcolor{keywordtype}{int} old\_flush; \textcolor{comment}{/* value of flush param for previous deflate call */}
00768     \hyperlink{structinternal__state}{deflate\_state} *s;
00769 
00770     \textcolor{keywordflow}{if} (deflateStateCheck(strm) || flush > Z\_BLOCK || flush < 0) \{
00771         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
00772     \}
00773     s = strm->state;
00774 
00775     \textcolor{keywordflow}{if} (strm->next\_out == Z\_NULL ||
00776         (strm->avail\_in != 0 && strm->next\_in == Z\_NULL) ||
00777         (s->status == FINISH\_STATE && flush != Z\_FINISH)) \{
00778         ERR\_RETURN(strm, Z\_STREAM\_ERROR);
00779     \}
00780     \textcolor{keywordflow}{if} (strm->avail\_out == 0) ERR\_RETURN(strm, Z\_BUF\_ERROR);
00781 
00782     old\_flush = s->last\_flush;
00783     s->last\_flush = flush;
00784 
00785     \textcolor{comment}{/* Flush as much pending output as possible */}
00786     \textcolor{keywordflow}{if} (s->pending != 0) \{
00787         flush\_pending(strm);
00788         \textcolor{keywordflow}{if} (strm->avail\_out == 0) \{
00789             \textcolor{comment}{/* Since avail\_out is 0, deflate will be called again with}
00790 \textcolor{comment}{             * more output space, but possibly with both pending and}
00791 \textcolor{comment}{             * avail\_in equal to zero. There won't be anything to do,}
00792 \textcolor{comment}{             * but this is not an error situation so make sure we}
00793 \textcolor{comment}{             * return OK instead of BUF\_ERROR at next call of deflate:}
00794 \textcolor{comment}{             */}
00795             s->last\_flush = -1;
00796             \textcolor{keywordflow}{return} Z\_OK;
00797         \}
00798 
00799     \textcolor{comment}{/* Make sure there is something to do and avoid duplicate consecutive}
00800 \textcolor{comment}{     * flushes. For repeated and useless calls with Z\_FINISH, we keep}
00801 \textcolor{comment}{     * returning Z\_STREAM\_END instead of Z\_BUF\_ERROR.}
00802 \textcolor{comment}{     */}
00803     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (strm->avail\_in == 0 && RANK(flush) <= RANK(old\_flush) &&
00804                flush != Z\_FINISH) \{
00805         ERR\_RETURN(strm, Z\_BUF\_ERROR);
00806     \}
00807 
00808     \textcolor{comment}{/* User must not provide more input after the first FINISH: */}
00809     \textcolor{keywordflow}{if} (s->status == FINISH\_STATE && strm->avail\_in != 0) \{
00810         ERR\_RETURN(strm, Z\_BUF\_ERROR);
00811     \}
00812 
00813     \textcolor{comment}{/* Write the header */}
00814     \textcolor{keywordflow}{if} (s->status == INIT\_STATE) \{
00815         \textcolor{comment}{/* zlib header */}
00816         uInt header = (Z\_DEFLATED + ((s->w\_bits-8)<<4)) << 8;
00817         uInt level\_flags;
00818 
00819         \textcolor{keywordflow}{if} (s->strategy >= Z\_HUFFMAN\_ONLY || s->level < 2)
00820             level\_flags = 0;
00821         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (s->level < 6)
00822             level\_flags = 1;
00823         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (s->level == 6)
00824             level\_flags = 2;
00825         \textcolor{keywordflow}{else}
00826             level\_flags = 3;
00827         header |= (level\_flags << 6);
00828         \textcolor{keywordflow}{if} (s->strstart != 0) header |= PRESET\_DICT;
00829         header += 31 - (header % 31);
00830 
00831         putShortMSB(s, header);
00832 
00833         \textcolor{comment}{/* Save the adler32 of the preset dictionary: */}
00834         \textcolor{keywordflow}{if} (s->strstart != 0) \{
00835             putShortMSB(s, (uInt)(strm->adler >> 16));
00836             putShortMSB(s, (uInt)(strm->adler & 0xffff));
00837         \}
00838         strm->adler = adler32(0L, Z\_NULL, 0);
00839         s->status = BUSY\_STATE;
00840 
00841         \textcolor{comment}{/* Compression must start with an empty pending buffer */}
00842         flush\_pending(strm);
00843         \textcolor{keywordflow}{if} (s->pending != 0) \{
00844             s->last\_flush = -1;
00845             \textcolor{keywordflow}{return} Z\_OK;
00846         \}
00847     \}
00848 \textcolor{preprocessor}{#ifdef GZIP}
00849     \textcolor{keywordflow}{if} (s->status == GZIP\_STATE) \{
00850         \textcolor{comment}{/* gzip header */}
00851         strm->adler = crc32(0L, Z\_NULL, 0);
00852         put\_byte(s, 31);
00853         put\_byte(s, 139);
00854         put\_byte(s, 8);
00855         \textcolor{keywordflow}{if} (s->gzhead == Z\_NULL) \{
00856             put\_byte(s, 0);
00857             put\_byte(s, 0);
00858             put\_byte(s, 0);
00859             put\_byte(s, 0);
00860             put\_byte(s, 0);
00861             put\_byte(s, s->level == 9 ? 2 :
00862                      (s->strategy >= Z\_HUFFMAN\_ONLY || s->level < 2 ?
00863                       4 : 0));
00864             put\_byte(s, OS\_CODE);
00865             s->status = BUSY\_STATE;
00866 
00867             \textcolor{comment}{/* Compression must start with an empty pending buffer */}
00868             flush\_pending(strm);
00869             \textcolor{keywordflow}{if} (s->pending != 0) \{
00870                 s->last\_flush = -1;
00871                 \textcolor{keywordflow}{return} Z\_OK;
00872             \}
00873         \}
00874         \textcolor{keywordflow}{else} \{
00875             put\_byte(s, (s->gzhead->text ? 1 : 0) +
00876                      (s->gzhead->hcrc ? 2 : 0) +
00877                      (s->gzhead->extra == Z\_NULL ? 0 : 4) +
00878                      (s->gzhead->name == Z\_NULL ? 0 : 8) +
00879                      (s->gzhead->comment == Z\_NULL ? 0 : 16)
00880                      );
00881             put\_byte(s, (Byte)(s->gzhead->time & 0xff));
00882             put\_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
00883             put\_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
00884             put\_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
00885             put\_byte(s, s->level == 9 ? 2 :
00886                      (s->strategy >= Z\_HUFFMAN\_ONLY || s->level < 2 ?
00887                       4 : 0));
00888             put\_byte(s, s->gzhead->os & 0xff);
00889             \textcolor{keywordflow}{if} (s->gzhead->extra != Z\_NULL) \{
00890                 put\_byte(s, s->gzhead->extra\_len & 0xff);
00891                 put\_byte(s, (s->gzhead->extra\_len >> 8) & 0xff);
00892             \}
00893             \textcolor{keywordflow}{if} (s->gzhead->hcrc)
00894                 strm->adler = crc32(strm->adler, s->pending\_buf,
00895                                     s->pending);
00896             s->gzindex = 0;
00897             s->status = EXTRA\_STATE;
00898         \}
00899     \}
00900     \textcolor{keywordflow}{if} (s->status == EXTRA\_STATE) \{
00901         \textcolor{keywordflow}{if} (s->gzhead->extra != Z\_NULL) \{
00902             ulg beg = s->pending;   \textcolor{comment}{/* start of bytes to update crc */}
00903             uInt left = (s->gzhead->extra\_len & 0xffff) - s->gzindex;
00904             while (s->pending + left > s->pending\_buf\_size) \{
00905                 uInt copy = s->pending\_buf\_size - s->pending;
00906                 zmemcpy(s->pending\_buf + s->pending,
00907                         s->gzhead->extra + s->gzindex, copy);
00908                 s->pending = s->pending\_buf\_size;
00909                 HCRC\_UPDATE(beg);
00910                 s->gzindex += copy;
00911                 flush\_pending(strm);
00912                 \textcolor{keywordflow}{if} (s->pending != 0) \{
00913                     s->last\_flush = -1;
00914                     \textcolor{keywordflow}{return} Z\_OK;
00915                 \}
00916                 beg = 0;
00917                 left -= copy;
00918             \}
00919             zmemcpy(s->pending\_buf + s->pending,
00920                     s->gzhead->extra + s->gzindex, left);
00921             s->pending += left;
00922             HCRC\_UPDATE(beg);
00923             s->gzindex = 0;
00924         \}
00925         s->status = NAME\_STATE;
00926     \}
00927     \textcolor{keywordflow}{if} (s->status == NAME\_STATE) \{
00928         \textcolor{keywordflow}{if} (s->gzhead->name != Z\_NULL) \{
00929             ulg beg = s->pending;   \textcolor{comment}{/* start of bytes to update crc */}
00930             \textcolor{keywordtype}{int} val;
00931             \textcolor{keywordflow}{do} \{
00932                 \textcolor{keywordflow}{if} (s->pending == s->pending\_buf\_size) \{
00933                     HCRC\_UPDATE(beg);
00934                     flush\_pending(strm);
00935                     \textcolor{keywordflow}{if} (s->pending != 0) \{
00936                         s->last\_flush = -1;
00937                         \textcolor{keywordflow}{return} Z\_OK;
00938                     \}
00939                     beg = 0;
00940                 \}
00941                 val = s->gzhead->name[s->gzindex++];
00942                 put\_byte(s, val);
00943             \} \textcolor{keywordflow}{while} (val != 0);
00944             HCRC\_UPDATE(beg);
00945             s->gzindex = 0;
00946         \}
00947         s->status = COMMENT\_STATE;
00948     \}
00949     \textcolor{keywordflow}{if} (s->status == COMMENT\_STATE) \{
00950         \textcolor{keywordflow}{if} (s->gzhead->comment != Z\_NULL) \{
00951             ulg beg = s->pending;   \textcolor{comment}{/* start of bytes to update crc */}
00952             \textcolor{keywordtype}{int} val;
00953             \textcolor{keywordflow}{do} \{
00954                 \textcolor{keywordflow}{if} (s->pending == s->pending\_buf\_size) \{
00955                     HCRC\_UPDATE(beg);
00956                     flush\_pending(strm);
00957                     \textcolor{keywordflow}{if} (s->pending != 0) \{
00958                         s->last\_flush = -1;
00959                         \textcolor{keywordflow}{return} Z\_OK;
00960                     \}
00961                     beg = 0;
00962                 \}
00963                 val = s->gzhead->comment[s->gzindex++];
00964                 put\_byte(s, val);
00965             \} \textcolor{keywordflow}{while} (val != 0);
00966             HCRC\_UPDATE(beg);
00967         \}
00968         s->status = HCRC\_STATE;
00969     \}
00970     \textcolor{keywordflow}{if} (s->status == HCRC\_STATE) \{
00971         \textcolor{keywordflow}{if} (s->gzhead->hcrc) \{
00972             \textcolor{keywordflow}{if} (s->pending + 2 > s->pending\_buf\_size) \{
00973                 flush\_pending(strm);
00974                 \textcolor{keywordflow}{if} (s->pending != 0) \{
00975                     s->last\_flush = -1;
00976                     \textcolor{keywordflow}{return} Z\_OK;
00977                 \}
00978             \}
00979             put\_byte(s, (Byte)(strm->adler & 0xff));
00980             put\_byte(s, (Byte)((strm->adler >> 8) & 0xff));
00981             strm->adler = crc32(0L, Z\_NULL, 0);
00982         \}
00983         s->status = BUSY\_STATE;
00984 
00985         \textcolor{comment}{/* Compression must start with an empty pending buffer */}
00986         flush\_pending(strm);
00987         \textcolor{keywordflow}{if} (s->pending != 0) \{
00988             s->last\_flush = -1;
00989             \textcolor{keywordflow}{return} Z\_OK;
00990         \}
00991     \}
00992 \textcolor{preprocessor}{#endif}
00993 
00994     \textcolor{comment}{/* Start a new block or continue the current one.}
00995 \textcolor{comment}{     */}
00996     \textcolor{keywordflow}{if} (strm->avail\_in != 0 || s->lookahead != 0 ||
00997         (flush != Z\_NO\_FLUSH && s->status != FINISH\_STATE)) \{
00998         block\_state bstate;
00999 
01000         bstate = s->level == 0 ? deflate\_stored(s, flush) :
01001                  s->strategy == Z\_HUFFMAN\_ONLY ? deflate\_huff(s, flush) :
01002                  s->strategy == Z\_RLE ? deflate\_rle(s, flush) :
01003                  (*(configuration\_table[s->level].func))(s, flush);
01004 
01005         \textcolor{keywordflow}{if} (bstate == finish\_started || bstate == finish\_done) \{
01006             s->status = FINISH\_STATE;
01007         \}
01008         \textcolor{keywordflow}{if} (bstate == need\_more || bstate == finish\_started) \{
01009             \textcolor{keywordflow}{if} (strm->avail\_out == 0) \{
01010                 s->last\_flush = -1; \textcolor{comment}{/* avoid BUF\_ERROR next call, see above */}
01011             \}
01012             \textcolor{keywordflow}{return} Z\_OK;
01013             \textcolor{comment}{/* If flush != Z\_NO\_FLUSH && avail\_out == 0, the next call}
01014 \textcolor{comment}{             * of deflate should use the same flush parameter to make sure}
01015 \textcolor{comment}{             * that the flush is complete. So we don't have to output an}
01016 \textcolor{comment}{             * empty block here, this will be done at next call. This also}
01017 \textcolor{comment}{             * ensures that for a very small output buffer, we emit at most}
01018 \textcolor{comment}{             * one empty block.}
01019 \textcolor{comment}{             */}
01020         \}
01021         \textcolor{keywordflow}{if} (bstate == block\_done) \{
01022             \textcolor{keywordflow}{if} (flush == Z\_PARTIAL\_FLUSH) \{
01023                 \_tr\_align(s);
01024             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (flush != Z\_BLOCK) \{ \textcolor{comment}{/* FULL\_FLUSH or SYNC\_FLUSH */}
01025                 \_tr\_stored\_block(s, (\textcolor{keywordtype}{char}*)0, 0L, 0);
01026                 \textcolor{comment}{/* For a full flush, this empty block will be recognized}
01027 \textcolor{comment}{                 * as a special marker by inflate\_sync().}
01028 \textcolor{comment}{                 */}
01029                 \textcolor{keywordflow}{if} (flush == Z\_FULL\_FLUSH) \{
01030                     CLEAR\_HASH(s);             \textcolor{comment}{/* forget history */}
01031                     \textcolor{keywordflow}{if} (s->lookahead == 0) \{
01032                         s->strstart = 0;
01033                         s->block\_start = 0L;
01034                         s->insert = 0;
01035                     \}
01036                 \}
01037             \}
01038             flush\_pending(strm);
01039             \textcolor{keywordflow}{if} (strm->avail\_out == 0) \{
01040               s->last\_flush = -1; \textcolor{comment}{/* avoid BUF\_ERROR at next call, see above */}
01041               \textcolor{keywordflow}{return} Z\_OK;
01042             \}
01043         \}
01044     \}
01045 
01046     \textcolor{keywordflow}{if} (flush != Z\_FINISH) \textcolor{keywordflow}{return} Z\_OK;
01047     \textcolor{keywordflow}{if} (s->wrap <= 0) \textcolor{keywordflow}{return} Z\_STREAM\_END;
01048 
01049     \textcolor{comment}{/* Write the trailer */}
01050 \textcolor{preprocessor}{#ifdef GZIP}
01051     \textcolor{keywordflow}{if} (s->wrap == 2) \{
01052         put\_byte(s, (Byte)(strm->adler & 0xff));
01053         put\_byte(s, (Byte)((strm->adler >> 8) & 0xff));
01054         put\_byte(s, (Byte)((strm->adler >> 16) & 0xff));
01055         put\_byte(s, (Byte)((strm->adler >> 24) & 0xff));
01056         put\_byte(s, (Byte)(strm->total\_in & 0xff));
01057         put\_byte(s, (Byte)((strm->total\_in >> 8) & 0xff));
01058         put\_byte(s, (Byte)((strm->total\_in >> 16) & 0xff));
01059         put\_byte(s, (Byte)((strm->total\_in >> 24) & 0xff));
01060     \}
01061     \textcolor{keywordflow}{else}
01062 \textcolor{preprocessor}{#endif}
01063     \{
01064         putShortMSB(s, (uInt)(strm->adler >> 16));
01065         putShortMSB(s, (uInt)(strm->adler & 0xffff));
01066     \}
01067     flush\_pending(strm);
01068     \textcolor{comment}{/* If avail\_out is zero, the application will call deflate again}
01069 \textcolor{comment}{     * to flush the rest.}
01070 \textcolor{comment}{     */}
01071     \textcolor{keywordflow}{if} (s->wrap > 0) s->wrap = -s->wrap; \textcolor{comment}{/* write the trailer only once! */}
01072     \textcolor{keywordflow}{return} s->pending != 0 ? Z\_OK : Z\_STREAM\_END;
01073 \}
01074 
01075 \textcolor{comment}{/* ========================================================================= */}
01076 \textcolor{keywordtype}{int} ZEXPORT deflateEnd (strm)
01077     z\_streamp strm;
01078 \{
01079     \textcolor{keywordtype}{int} status;
01080 
01081     \textcolor{keywordflow}{if} (deflateStateCheck(strm)) \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
01082 
01083     status = strm->state->status;
01084 
01085     \textcolor{comment}{/* Deallocate in reverse order of allocations: */}
01086     TRY\_FREE(strm, strm->state->pending\_buf);
01087     TRY\_FREE(strm, strm->state->head);
01088     TRY\_FREE(strm, strm->state->prev);
01089     TRY\_FREE(strm, strm->state->window);
01090 
01091     ZFREE(strm, strm->state);
01092     strm->state = Z\_NULL;
01093 
01094     \textcolor{keywordflow}{return} status == BUSY\_STATE ? Z\_DATA\_ERROR : Z\_OK;
01095 \}
01096 
01097 \textcolor{comment}{/* =========================================================================}
01098 \textcolor{comment}{ * Copy the source state to the destination state.}
01099 \textcolor{comment}{ * To simplify the source, this is not supported for 16-bit MSDOS (which}
01100 \textcolor{comment}{ * doesn't have enough memory anyway to duplicate compression states).}
01101 \textcolor{comment}{ */}
01102 \textcolor{keywordtype}{int} ZEXPORT deflateCopy (dest, source)
01103     z\_streamp dest;
01104     z\_streamp source;
01105 \{
01106 \textcolor{preprocessor}{#ifdef MAXSEG\_64K}
01107     \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
01108 \textcolor{preprocessor}{#else}
01109     \hyperlink{structinternal__state}{deflate\_state} *ds;
01110     \hyperlink{structinternal__state}{deflate\_state} *ss;
01111     ushf *overlay;
01112 
01113 
01114     \textcolor{keywordflow}{if} (deflateStateCheck(source) || dest == Z\_NULL) \{
01115         \textcolor{keywordflow}{return} Z\_STREAM\_ERROR;
01116     \}
01117 
01118     ss = source->state;
01119 
01120     zmemcpy((voidpf)dest, (voidpf)source, \textcolor{keyword}{sizeof}(\hyperlink{structz__stream__s}{z\_stream}));
01121 
01122     ds = (\hyperlink{structinternal__state}{deflate\_state} *) ZALLOC(dest, 1, \textcolor{keyword}{sizeof}(\hyperlink{structinternal__state}{deflate\_state}));
01123     \textcolor{keywordflow}{if} (ds == Z\_NULL) \textcolor{keywordflow}{return} Z\_MEM\_ERROR;
01124     dest->state = (\textcolor{keyword}{struct }\hyperlink{structinternal__state}{internal\_state} FAR *) ds;
01125     zmemcpy((voidpf)ds, (voidpf)ss, \textcolor{keyword}{sizeof}(\hyperlink{structinternal__state}{deflate\_state}));
01126     ds->strm = dest;
01127 
01128     ds->window = (Bytef *) ZALLOC(dest, ds->w\_size, 2*\textcolor{keyword}{sizeof}(Byte));
01129     ds->prev   = (Posf *)  ZALLOC(dest, ds->w\_size, \textcolor{keyword}{sizeof}(Pos));
01130     ds->head   = (Posf *)  ZALLOC(dest, ds->hash\_size, \textcolor{keyword}{sizeof}(Pos));
01131     overlay = (ushf *) ZALLOC(dest, ds->lit\_bufsize, \textcolor{keyword}{sizeof}(ush)+2);
01132     ds->pending\_buf = (uchf *) overlay;
01133 
01134     \textcolor{keywordflow}{if} (ds->window == Z\_NULL || ds->prev == Z\_NULL || ds->head == Z\_NULL ||
01135         ds->pending\_buf == Z\_NULL) \{
01136         deflateEnd (dest);
01137         \textcolor{keywordflow}{return} Z\_MEM\_ERROR;
01138     \}
01139     \textcolor{comment}{/* following zmemcpy do not work for 16-bit MSDOS */}
01140     zmemcpy(ds->window, ss->window, ds->w\_size * 2 * \textcolor{keyword}{sizeof}(Byte));
01141     zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w\_size * \textcolor{keyword}{sizeof}(Pos));
01142     zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash\_size * \textcolor{keyword}{sizeof}(Pos));
01143     zmemcpy(ds->pending\_buf, ss->pending\_buf, (uInt)ds->pending\_buf\_size);
01144 
01145     ds->pending\_out = ds->pending\_buf + (ss->pending\_out - ss->pending\_buf);
01146     ds->d\_buf = overlay + ds->lit\_bufsize/\textcolor{keyword}{sizeof}(ush);
01147     ds->l\_buf = ds->pending\_buf + (1+\textcolor{keyword}{sizeof}(ush))*ds->lit\_bufsize;
01148 
01149     ds->l\_desc.dyn\_tree = ds->dyn\_ltree;
01150     ds->d\_desc.dyn\_tree = ds->dyn\_dtree;
01151     ds->bl\_desc.dyn\_tree = ds->bl\_tree;
01152 
01153     \textcolor{keywordflow}{return} Z\_OK;
01154 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* MAXSEG\_64K */}\textcolor{preprocessor}{}
01155 \}
01156 
01157 \textcolor{comment}{/* ===========================================================================}
01158 \textcolor{comment}{ * Read a new buffer from the current input stream, update the adler32}
01159 \textcolor{comment}{ * and total number of bytes read.  All deflate() input goes through}
01160 \textcolor{comment}{ * this function so some applications may wish to modify it to avoid}
01161 \textcolor{comment}{ * allocating a large strm->next\_in buffer and copying from it.}
01162 \textcolor{comment}{ * (See also flush\_pending()).}
01163 \textcolor{comment}{ */}
01164 local \textcolor{keywordtype}{unsigned} read\_buf(strm, buf, size)
01165     z\_streamp strm;
01166     Bytef *buf;
01167     \textcolor{keywordtype}{unsigned} size;
01168 \{
01169     \textcolor{keywordtype}{unsigned} len = strm->avail\_in;
01170 
01171     \textcolor{keywordflow}{if} (len > size) len = size;
01172     \textcolor{keywordflow}{if} (len == 0) \textcolor{keywordflow}{return} 0;
01173 
01174     strm->avail\_in  -= len;
01175 
01176     zmemcpy(buf, strm->next\_in, len);
01177     \textcolor{keywordflow}{if} (strm->state->wrap == 1) \{
01178         strm->adler = adler32(strm->adler, buf, len);
01179     \}
01180 \textcolor{preprocessor}{#ifdef GZIP}
01181     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (strm->state->wrap == 2) \{
01182         strm->adler = crc32(strm->adler, buf, len);
01183     \}
01184 \textcolor{preprocessor}{#endif}
01185     strm->next\_in  += len;
01186     strm->total\_in += len;
01187 
01188     \textcolor{keywordflow}{return} len;
01189 \}
01190 
01191 \textcolor{comment}{/* ===========================================================================}
01192 \textcolor{comment}{ * Initialize the "longest match" routines for a new zlib stream}
01193 \textcolor{comment}{ */}
01194 local \textcolor{keywordtype}{void} lm\_init (s)
01195     \hyperlink{structinternal__state}{deflate\_state} *s;
01196 \{
01197     s->window\_size = (ulg)2L*s->w\_size;
01198 
01199     CLEAR\_HASH(s);
01200 
01201     \textcolor{comment}{/* Set the default configuration parameters:}
01202 \textcolor{comment}{     */}
01203     s->max\_lazy\_match   = configuration\_table[s->level].max\_lazy;
01204     s->good\_match       = configuration\_table[s->level].good\_length;
01205     s->nice\_match       = configuration\_table[s->level].nice\_length;
01206     s->max\_chain\_length = configuration\_table[s->level].max\_chain;
01207 
01208     s->strstart = 0;
01209     s->block\_start = 0L;
01210     s->lookahead = 0;
01211     s->insert = 0;
01212     s->match\_length = s->prev\_length = MIN\_MATCH-1;
01213     s->match\_available = 0;
01214     s->ins\_h = 0;
01215 \textcolor{preprocessor}{#ifndef FASTEST}
01216 \textcolor{preprocessor}{#ifdef ASMV}
01217     match\_init(); \textcolor{comment}{/* initialize the asm code */}
01218 \textcolor{preprocessor}{#endif}
01219 \textcolor{preprocessor}{#endif}
01220 \}
01221 
01222 \textcolor{preprocessor}{#ifndef FASTEST}
01223 \textcolor{comment}{/* ===========================================================================}
01224 \textcolor{comment}{ * Set match\_start to the longest match starting at the given string and}
01225 \textcolor{comment}{ * return its length. Matches shorter or equal to prev\_length are discarded,}
01226 \textcolor{comment}{ * in which case the result is equal to prev\_length and match\_start is}
01227 \textcolor{comment}{ * garbage.}
01228 \textcolor{comment}{ * IN assertions: cur\_match is the head of the hash chain for the current}
01229 \textcolor{comment}{ *   string (strstart) and its distance is <= MAX\_DIST, and prev\_length >= 1}
01230 \textcolor{comment}{ * OUT assertion: the match length is not greater than s->lookahead.}
01231 \textcolor{comment}{ */}
01232 \textcolor{preprocessor}{#ifndef ASMV}
01233 \textcolor{comment}{/* For 80x86 and 680x0, an optimized version will be provided in match.asm or}
01234 \textcolor{comment}{ * match.S. The code will be functionally equivalent.}
01235 \textcolor{comment}{ */}
01236 local uInt longest\_match(s, cur\_match)
01237     \hyperlink{structinternal__state}{deflate\_state} *s;
01238     IPos cur\_match;                             \textcolor{comment}{/* current match */}
01239 \{
01240     \textcolor{keywordtype}{unsigned} chain\_length = s->max\_chain\_length;\textcolor{comment}{/* max hash chain length */}
01241     \textcolor{keyword}{register} Bytef *scan = s->window + s->strstart; \textcolor{comment}{/* current string */}
01242     \textcolor{keyword}{register} Bytef *match;                      \textcolor{comment}{/* matched string */}
01243     \textcolor{keyword}{register} \textcolor{keywordtype}{int} len;                           \textcolor{comment}{/* length of current match */}
01244     \textcolor{keywordtype}{int} best\_len = (int)s->prev\_length;         \textcolor{comment}{/* best match length so far */}
01245     \textcolor{keywordtype}{int} nice\_match = s->nice\_match;             \textcolor{comment}{/* stop if match long enough */}
01246     IPos limit = s->strstart > (IPos)MAX\_DIST(s) ?
01247         s->strstart - (IPos)MAX\_DIST(s) : NIL;
01248     \textcolor{comment}{/* Stop when cur\_match becomes <= limit. To simplify the code,}
01249 \textcolor{comment}{     * we prevent matches with the string of window index 0.}
01250 \textcolor{comment}{     */}
01251     Posf *prev = s->prev;
01252     uInt wmask = s->w\_mask;
01253 
01254 \textcolor{preprocessor}{#ifdef UNALIGNED\_OK}
01255     \textcolor{comment}{/* Compare two bytes at a time. Note: this is not always beneficial.}
01256 \textcolor{comment}{     * Try with and without -DUNALIGNED\_OK to check.}
01257 \textcolor{comment}{     */}
01258     \textcolor{keyword}{register} Bytef *strend = s->window + s->strstart + MAX\_MATCH - 1;
01259     \textcolor{keyword}{register} ush scan\_start = *(ushf*)scan;
01260     \textcolor{keyword}{register} ush scan\_end   = *(ushf*)(scan+best\_len-1);
01261 \textcolor{preprocessor}{#else}
01262     \textcolor{keyword}{register} Bytef *strend = s->window + s->strstart + MAX\_MATCH;
01263     \textcolor{keyword}{register} Byte scan\_end1  = scan[best\_len-1];
01264     \textcolor{keyword}{register} Byte scan\_end   = scan[best\_len];
01265 \textcolor{preprocessor}{#endif}
01266 
01267     \textcolor{comment}{/* The code is optimized for HASH\_BITS >= 8 and MAX\_MATCH-2 multiple of 16.}
01268 \textcolor{comment}{     * It is easy to get rid of this optimization if necessary.}
01269 \textcolor{comment}{     */}
01270     Assert(s->hash\_bits >= 8 && MAX\_MATCH == 258, \textcolor{stringliteral}{"Code too clever"});
01271 
01272     \textcolor{comment}{/* Do not waste too much time if we already have a good match: */}
01273     \textcolor{keywordflow}{if} (s->prev\_length >= s->good\_match) \{
01274         chain\_length >>= 2;
01275     \}
01276     \textcolor{comment}{/* Do not look for matches beyond the end of the input. This is necessary}
01277 \textcolor{comment}{     * to make deflate deterministic.}
01278 \textcolor{comment}{     */}
01279     \textcolor{keywordflow}{if} ((uInt)nice\_match > s->lookahead) nice\_match = (int)s->lookahead;
01280 
01281     Assert((ulg)s->strstart <= s->window\_size-MIN\_LOOKAHEAD, \textcolor{stringliteral}{"need lookahead"});
01282 
01283     \textcolor{keywordflow}{do} \{
01284         Assert(cur\_match < s->strstart, \textcolor{stringliteral}{"no future"});
01285         match = s->window + cur\_match;
01286 
01287         \textcolor{comment}{/* Skip to next match if the match length cannot increase}
01288 \textcolor{comment}{         * or if the match length is less than 2.  Note that the checks below}
01289 \textcolor{comment}{         * for insufficient lookahead only occur occasionally for performance}
01290 \textcolor{comment}{         * reasons.  Therefore uninitialized memory will be accessed, and}
01291 \textcolor{comment}{         * conditional jumps will be made that depend on those values.}
01292 \textcolor{comment}{         * However the length of the match is limited to the lookahead, so}
01293 \textcolor{comment}{         * the output of deflate is not affected by the uninitialized values.}
01294 \textcolor{comment}{         */}
01295 \textcolor{preprocessor}{#if (defined(UNALIGNED\_OK) && MAX\_MATCH == 258)}
01296         \textcolor{comment}{/* This code assumes sizeof(unsigned short) == 2. Do not use}
01297 \textcolor{comment}{         * UNALIGNED\_OK if your compiler uses a different size.}
01298 \textcolor{comment}{         */}
01299         \textcolor{keywordflow}{if} (*(ushf*)(match+best\_len-1) != scan\_end ||
01300             *(ushf*)match != scan\_start) \textcolor{keywordflow}{continue};
01301 
01302         \textcolor{comment}{/* It is not necessary to compare scan[2] and match[2] since they are}
01303 \textcolor{comment}{         * always equal when the other bytes match, given that the hash keys}
01304 \textcolor{comment}{         * are equal and that HASH\_BITS >= 8. Compare 2 bytes at a time at}
01305 \textcolor{comment}{         * strstart+3, +5, ... up to strstart+257. We check for insufficient}
01306 \textcolor{comment}{         * lookahead only every 4th comparison; the 128th check will be made}
01307 \textcolor{comment}{         * at strstart+257. If MAX\_MATCH-2 is not a multiple of 8, it is}
01308 \textcolor{comment}{         * necessary to put more guard bytes at the end of the window, or}
01309 \textcolor{comment}{         * to check more often for insufficient lookahead.}
01310 \textcolor{comment}{         */}
01311         Assert(scan[2] == match[2], \textcolor{stringliteral}{"scan[2]?"});
01312         scan++, match++;
01313         \textcolor{keywordflow}{do} \{
01314         \} \textcolor{keywordflow}{while} (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
01315                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
01316                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
01317                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
01318                  scan < strend);
01319         \textcolor{comment}{/* The funny "do \{\}" generates better code on most compilers */}
01320 
01321         \textcolor{comment}{/* Here, scan <= window+strstart+257 */}
01322         Assert(scan <= s->window+(\textcolor{keywordtype}{unsigned})(s->window\_size-1), \textcolor{stringliteral}{"wild scan"});
01323         \textcolor{keywordflow}{if} (*scan == *match) scan++;
01324 
01325         len = (MAX\_MATCH - 1) - (\textcolor{keywordtype}{int})(strend-scan);
01326         scan = strend - (MAX\_MATCH-1);
01327 
01328 \textcolor{preprocessor}{#else }\textcolor{comment}{/* UNALIGNED\_OK */}\textcolor{preprocessor}{}
01329 
01330         \textcolor{keywordflow}{if} (match[best\_len]   != scan\_end  ||
01331             match[best\_len-1] != scan\_end1 ||
01332             *match            != *scan     ||
01333             *++match          != scan[1])      \textcolor{keywordflow}{continue};
01334 
01335         \textcolor{comment}{/* The check at best\_len-1 can be removed because it will be made}
01336 \textcolor{comment}{         * again later. (This heuristic is not always a win.)}
01337 \textcolor{comment}{         * It is not necessary to compare scan[2] and match[2] since they}
01338 \textcolor{comment}{         * are always equal when the other bytes match, given that}
01339 \textcolor{comment}{         * the hash keys are equal and that HASH\_BITS >= 8.}
01340 \textcolor{comment}{         */}
01341         scan += 2, match++;
01342         Assert(*scan == *match, \textcolor{stringliteral}{"match[2]?"});
01343 
01344         \textcolor{comment}{/* We check for insufficient lookahead only every 8th comparison;}
01345 \textcolor{comment}{         * the 256th check will be made at strstart+258.}
01346 \textcolor{comment}{         */}
01347         \textcolor{keywordflow}{do} \{
01348         \} \textcolor{keywordflow}{while} (*++scan == *++match && *++scan == *++match &&
01349                  *++scan == *++match && *++scan == *++match &&
01350                  *++scan == *++match && *++scan == *++match &&
01351                  *++scan == *++match && *++scan == *++match &&
01352                  scan < strend);
01353 
01354         Assert(scan <= s->window+(\textcolor{keywordtype}{unsigned})(s->window\_size-1), \textcolor{stringliteral}{"wild scan"});
01355 
01356         len = MAX\_MATCH - (int)(strend - scan);
01357         scan = strend - MAX\_MATCH;
01358 
01359 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* UNALIGNED\_OK */}\textcolor{preprocessor}{}
01360 
01361         \textcolor{keywordflow}{if} (len > best\_len) \{
01362             s->match\_start = cur\_match;
01363             best\_len = len;
01364             \textcolor{keywordflow}{if} (len >= nice\_match) \textcolor{keywordflow}{break};
01365 \textcolor{preprocessor}{#ifdef UNALIGNED\_OK}
01366             scan\_end = *(ushf*)(scan+best\_len-1);
01367 \textcolor{preprocessor}{#else}
01368             scan\_end1  = scan[best\_len-1];
01369             scan\_end   = scan[best\_len];
01370 \textcolor{preprocessor}{#endif}
01371         \}
01372     \} \textcolor{keywordflow}{while} ((cur\_match = prev[cur\_match & wmask]) > limit
01373              && --chain\_length != 0);
01374 
01375     \textcolor{keywordflow}{if} ((uInt)best\_len <= s->lookahead) \textcolor{keywordflow}{return} (uInt)best\_len;
01376     \textcolor{keywordflow}{return} s->lookahead;
01377 \}
01378 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* ASMV */}\textcolor{preprocessor}{}
01379 
01380 \textcolor{preprocessor}{#else }\textcolor{comment}{/* FASTEST */}\textcolor{preprocessor}{}
01381 
01382 \textcolor{comment}{/* ---------------------------------------------------------------------------}
01383 \textcolor{comment}{ * Optimized version for FASTEST only}
01384 \textcolor{comment}{ */}
01385 local uInt longest\_match(s, cur\_match)
01386     \hyperlink{structinternal__state}{deflate\_state} *s;
01387     IPos cur\_match;                             \textcolor{comment}{/* current match */}
01388 \{
01389     \textcolor{keyword}{register} Bytef *scan = s->window + s->strstart; \textcolor{comment}{/* current string */}
01390     \textcolor{keyword}{register} Bytef *match;                       \textcolor{comment}{/* matched string */}
01391     \textcolor{keyword}{register} \textcolor{keywordtype}{int} len;                           \textcolor{comment}{/* length of current match */}
01392     \textcolor{keyword}{register} Bytef *strend = s->window + s->strstart + MAX\_MATCH;
01393 
01394     \textcolor{comment}{/* The code is optimized for HASH\_BITS >= 8 and MAX\_MATCH-2 multiple of 16.}
01395 \textcolor{comment}{     * It is easy to get rid of this optimization if necessary.}
01396 \textcolor{comment}{     */}
01397     Assert(s->hash\_bits >= 8 && MAX\_MATCH == 258, \textcolor{stringliteral}{"Code too clever"});
01398 
01399     Assert((ulg)s->strstart <= s->window\_size-MIN\_LOOKAHEAD, \textcolor{stringliteral}{"need lookahead"});
01400 
01401     Assert(cur\_match < s->strstart, \textcolor{stringliteral}{"no future"});
01402 
01403     match = s->window + cur\_match;
01404 
01405     \textcolor{comment}{/* Return failure if the match length is less than 2:}
01406 \textcolor{comment}{     */}
01407     \textcolor{keywordflow}{if} (match[0] != scan[0] || match[1] != scan[1]) \textcolor{keywordflow}{return} MIN\_MATCH-1;
01408 
01409     \textcolor{comment}{/* The check at best\_len-1 can be removed because it will be made}
01410 \textcolor{comment}{     * again later. (This heuristic is not always a win.)}
01411 \textcolor{comment}{     * It is not necessary to compare scan[2] and match[2] since they}
01412 \textcolor{comment}{     * are always equal when the other bytes match, given that}
01413 \textcolor{comment}{     * the hash keys are equal and that HASH\_BITS >= 8.}
01414 \textcolor{comment}{     */}
01415     scan += 2, match += 2;
01416     Assert(*scan == *match, \textcolor{stringliteral}{"match[2]?"});
01417 
01418     \textcolor{comment}{/* We check for insufficient lookahead only every 8th comparison;}
01419 \textcolor{comment}{     * the 256th check will be made at strstart+258.}
01420 \textcolor{comment}{     */}
01421     \textcolor{keywordflow}{do} \{
01422     \} \textcolor{keywordflow}{while} (*++scan == *++match && *++scan == *++match &&
01423              *++scan == *++match && *++scan == *++match &&
01424              *++scan == *++match && *++scan == *++match &&
01425              *++scan == *++match && *++scan == *++match &&
01426              scan < strend);
01427 
01428     Assert(scan <= s->window+(\textcolor{keywordtype}{unsigned})(s->window\_size-1), \textcolor{stringliteral}{"wild scan"});
01429 
01430     len = MAX\_MATCH - (int)(strend - scan);
01431 
01432     \textcolor{keywordflow}{if} (len < MIN\_MATCH) \textcolor{keywordflow}{return} MIN\_MATCH - 1;
01433 
01434     s->match\_start = cur\_match;
01435     \textcolor{keywordflow}{return} (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
01436 \}
01437 
01438 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* FASTEST */}\textcolor{preprocessor}{}
01439 
01440 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
01441 
01442 \textcolor{preprocessor}{#define EQUAL 0}
01443 \textcolor{comment}{/* result of memcmp for equal strings */}
01444 
01445 \textcolor{comment}{/* ===========================================================================}
01446 \textcolor{comment}{ * Check that the match at match\_start is indeed a match.}
01447 \textcolor{comment}{ */}
01448 local \textcolor{keywordtype}{void} check\_match(s, start, match, length)
01449     \hyperlink{structinternal__state}{deflate\_state} *s;
01450     IPos start, match;
01451     \textcolor{keywordtype}{int} length;
01452 \{
01453     \textcolor{comment}{/* check that the match is indeed a match */}
01454     \textcolor{keywordflow}{if} (zmemcmp(s->window + match,
01455                 s->window + start, length) != EQUAL) \{
01456         fprintf(stderr, \textcolor{stringliteral}{" start %u, match %u, length %d\(\backslash\)n"},
01457                 start, match, length);
01458         \textcolor{keywordflow}{do} \{
01459             fprintf(stderr, \textcolor{stringliteral}{"%c%c"}, s->window[match++], s->window[start++]);
01460         \} \textcolor{keywordflow}{while} (--length != 0);
01461         z\_error(\textcolor{stringliteral}{"invalid match"});
01462     \}
01463     \textcolor{keywordflow}{if} (z\_verbose > 1) \{
01464         fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)[%d,%d]"}, start-match, length);
01465         \textcolor{keywordflow}{do} \{ putc(s->window[start++], stderr); \} \textcolor{keywordflow}{while} (--length != 0);
01466     \}
01467 \}
01468 \textcolor{preprocessor}{#else}
01469 \textcolor{preprocessor}{#  define check\_match(s, start, match, length)}
01470 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* ZLIB\_DEBUG */}\textcolor{preprocessor}{}
01471 
01472 \textcolor{comment}{/* ===========================================================================}
01473 \textcolor{comment}{ * Fill the window when the lookahead becomes insufficient.}
01474 \textcolor{comment}{ * Updates strstart and lookahead.}
01475 \textcolor{comment}{ *}
01476 \textcolor{comment}{ * IN assertion: lookahead < MIN\_LOOKAHEAD}
01477 \textcolor{comment}{ * OUT assertions: strstart <= window\_size-MIN\_LOOKAHEAD}
01478 \textcolor{comment}{ *    At least one byte has been read, or avail\_in == 0; reads are}
01479 \textcolor{comment}{ *    performed for at least two bytes (required for the zip translate\_eol}
01480 \textcolor{comment}{ *    option -- not supported here).}
01481 \textcolor{comment}{ */}
01482 local \textcolor{keywordtype}{void} fill\_window(s)
01483     \hyperlink{structinternal__state}{deflate\_state} *s;
01484 \{
01485     \textcolor{keywordtype}{unsigned} n;
01486     \textcolor{keywordtype}{unsigned} more;    \textcolor{comment}{/* Amount of free space at the end of the window. */}
01487     uInt wsize = s->w\_size;
01488 
01489     Assert(s->lookahead < MIN\_LOOKAHEAD, \textcolor{stringliteral}{"already enough lookahead"});
01490 
01491     \textcolor{keywordflow}{do} \{
01492         more = (unsigned)(s->window\_size -(ulg)s->lookahead -(ulg)s->strstart);
01493 
01494         \textcolor{comment}{/* Deal with !@#$% 64K limit: */}
01495         \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}) <= 2) \{
01496             \textcolor{keywordflow}{if} (more == 0 && s->strstart == 0 && s->lookahead == 0) \{
01497                 more = wsize;
01498 
01499             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (more == (\textcolor{keywordtype}{unsigned})(-1)) \{
01500                 \textcolor{comment}{/* Very unlikely, but possible on 16 bit machine if}
01501 \textcolor{comment}{                 * strstart == 0 && lookahead == 1 (input done a byte at time)}
01502 \textcolor{comment}{                 */}
01503                 more--;
01504             \}
01505         \}
01506 
01507         \textcolor{comment}{/* If the window is almost full and there is insufficient lookahead,}
01508 \textcolor{comment}{         * move the upper half to the lower one to make room in the upper half.}
01509 \textcolor{comment}{         */}
01510         \textcolor{keywordflow}{if} (s->strstart >= wsize+MAX\_DIST(s)) \{
01511 
01512             zmemcpy(s->window, s->window+wsize, (\textcolor{keywordtype}{unsigned})wsize - more);
01513             s->match\_start -= wsize;
01514             s->strstart    -= wsize; \textcolor{comment}{/* we now have strstart >= MAX\_DIST */}
01515             s->block\_start -= (long) wsize;
01516             slide\_hash(s);
01517             more += wsize;
01518         \}
01519         \textcolor{keywordflow}{if} (s->strm->avail\_in == 0) \textcolor{keywordflow}{break};
01520 
01521         \textcolor{comment}{/* If there was no sliding:}
01522 \textcolor{comment}{         *    strstart <= WSIZE+MAX\_DIST-1 && lookahead <= MIN\_LOOKAHEAD - 1 &&}
01523 \textcolor{comment}{         *    more == window\_size - lookahead - strstart}
01524 \textcolor{comment}{         * => more >= window\_size - (MIN\_LOOKAHEAD-1 + WSIZE + MAX\_DIST-1)}
01525 \textcolor{comment}{         * => more >= window\_size - 2*WSIZE + 2}
01526 \textcolor{comment}{         * In the BIG\_MEM or MMAP case (not yet supported),}
01527 \textcolor{comment}{         *   window\_size == input\_size + MIN\_LOOKAHEAD  &&}
01528 \textcolor{comment}{         *   strstart + s->lookahead <= input\_size => more >= MIN\_LOOKAHEAD.}
01529 \textcolor{comment}{         * Otherwise, window\_size == 2*WSIZE so more >= 2.}
01530 \textcolor{comment}{         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.}
01531 \textcolor{comment}{         */}
01532         Assert(more >= 2, \textcolor{stringliteral}{"more < 2"});
01533 
01534         n = read\_buf(s->strm, s->window + s->strstart + s->lookahead, more);
01535         s->lookahead += n;
01536 
01537         \textcolor{comment}{/* Initialize the hash value now that we have some input: */}
01538         \textcolor{keywordflow}{if} (s->lookahead + s->insert >= MIN\_MATCH) \{
01539             uInt str = s->strstart - s->insert;
01540             s->ins\_h = s->window[str];
01541             UPDATE\_HASH(s, s->ins\_h, s->window[str + 1]);
01542 \textcolor{preprocessor}{#if MIN\_MATCH != 3}
01543             Call UPDATE\_HASH() MIN\_MATCH-3 more times
01544 \textcolor{preprocessor}{#endif}
01545             \textcolor{keywordflow}{while} (s->insert) \{
01546                 UPDATE\_HASH(s, s->ins\_h, s->window[str + MIN\_MATCH-1]);
01547 \textcolor{preprocessor}{#ifndef FASTEST}
01548                 s->prev[str & s->w\_mask] = s->head[s->ins\_h];
01549 \textcolor{preprocessor}{#endif}
01550                 s->head[s->ins\_h] = (Pos)str;
01551                 str++;
01552                 s->insert--;
01553                 \textcolor{keywordflow}{if} (s->lookahead + s->insert < MIN\_MATCH)
01554                     \textcolor{keywordflow}{break};
01555             \}
01556         \}
01557         \textcolor{comment}{/* If the whole input has less than MIN\_MATCH bytes, ins\_h is garbage,}
01558 \textcolor{comment}{         * but this is not important since only literal bytes will be emitted.}
01559 \textcolor{comment}{         */}
01560 
01561     \} \textcolor{keywordflow}{while} (s->lookahead < MIN\_LOOKAHEAD && s->strm->avail\_in != 0);
01562 
01563     \textcolor{comment}{/* If the WIN\_INIT bytes after the end of the current data have never been}
01564 \textcolor{comment}{     * written, then zero those bytes in order to avoid memory check reports of}
01565 \textcolor{comment}{     * the use of uninitialized (or uninitialised as Julian writes) bytes by}
01566 \textcolor{comment}{     * the longest match routines.  Update the high water mark for the next}
01567 \textcolor{comment}{     * time through here.  WIN\_INIT is set to MAX\_MATCH since the longest match}
01568 \textcolor{comment}{     * routines allow scanning to strstart + MAX\_MATCH, ignoring lookahead.}
01569 \textcolor{comment}{     */}
01570     \textcolor{keywordflow}{if} (s->high\_water < s->window\_size) \{
01571         ulg curr = s->strstart + (ulg)(s->lookahead);
01572         ulg \hyperlink{structinit}{init};
01573 
01574         \textcolor{keywordflow}{if} (s->high\_water < curr) \{
01575             \textcolor{comment}{/* Previous high water mark below current data -- zero WIN\_INIT}
01576 \textcolor{comment}{             * bytes or up to end of window, whichever is less.}
01577 \textcolor{comment}{             */}
01578             init = s->window\_size - curr;
01579             \textcolor{keywordflow}{if} (init > WIN\_INIT)
01580                 init = WIN\_INIT;
01581             zmemzero(s->window + curr, (\textcolor{keywordtype}{unsigned})init);
01582             s->high\_water = curr + init;
01583         \}
01584         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (s->high\_water < (ulg)curr + WIN\_INIT) \{
01585             \textcolor{comment}{/* High water mark at or above current data, but below current data}
01586 \textcolor{comment}{             * plus WIN\_INIT -- zero out to current data plus WIN\_INIT, or up}
01587 \textcolor{comment}{             * to end of window, whichever is less.}
01588 \textcolor{comment}{             */}
01589             init = (ulg)curr + WIN\_INIT - s->high\_water;
01590             if (init > s->window\_size - s->high\_water)
01591                 init = s->window\_size - s->high\_water;
01592             zmemzero(s->window + s->high\_water, (\textcolor{keywordtype}{unsigned})init);
01593             s->high\_water += init;
01594         \}
01595     \}
01596 
01597     Assert((ulg)s->strstart <= s->window\_size - MIN\_LOOKAHEAD,
01598            \textcolor{stringliteral}{"not enough room for search"});
01599 \}
01600 
01601 \textcolor{comment}{/* ===========================================================================}
01602 \textcolor{comment}{ * Flush the current block, with given end-of-file flag.}
01603 \textcolor{comment}{ * IN assertion: strstart is set to the end of the current match.}
01604 \textcolor{comment}{ */}
01605 \textcolor{preprocessor}{#define FLUSH\_BLOCK\_ONLY(s, last) \{ \(\backslash\)}
01606 \textcolor{preprocessor}{   \_tr\_flush\_block(s, (s->block\_start >= 0L ? \(\backslash\)}
01607 \textcolor{preprocessor}{                   (charf *)&s->window[(unsigned)s->block\_start] : \(\backslash\)}
01608 \textcolor{preprocessor}{                   (charf *)Z\_NULL), \(\backslash\)}
01609 \textcolor{preprocessor}{                (ulg)((long)s->strstart - s->block\_start), \(\backslash\)}
01610 \textcolor{preprocessor}{                (last)); \(\backslash\)}
01611 \textcolor{preprocessor}{   s->block\_start = s->strstart; \(\backslash\)}
01612 \textcolor{preprocessor}{   flush\_pending(s->strm); \(\backslash\)}
01613 \textcolor{preprocessor}{   Tracev((stderr,"[FLUSH]")); \(\backslash\)}
01614 \textcolor{preprocessor}{\}}
01615 
01616 \textcolor{comment}{/* Same but force premature exit if necessary. */}
01617 \textcolor{preprocessor}{#define FLUSH\_BLOCK(s, last) \{ \(\backslash\)}
01618 \textcolor{preprocessor}{   FLUSH\_BLOCK\_ONLY(s, last); \(\backslash\)}
01619 \textcolor{preprocessor}{   if (s->strm->avail\_out == 0) return (last) ? finish\_started : need\_more; \(\backslash\)}
01620 \textcolor{preprocessor}{\}}
01621 
01622 \textcolor{comment}{/* Maximum stored block length in deflate format (not including header). */}
01623 \textcolor{preprocessor}{#define MAX\_STORED 65535}
01624 
01625 \textcolor{comment}{/* Minimum of a and b. */}
01626 \textcolor{preprocessor}{#define MIN(a, b) ((a) > (b) ? (b) : (a))}
01627 
01628 \textcolor{comment}{/* ===========================================================================}
01629 \textcolor{comment}{ * Copy without compression as much as possible from the input stream, return}
01630 \textcolor{comment}{ * the current block state.}
01631 \textcolor{comment}{ *}
01632 \textcolor{comment}{ * In case deflateParams() is used to later switch to a non-zero compression}
01633 \textcolor{comment}{ * level, s->matches (otherwise unused when storing) keeps track of the number}
01634 \textcolor{comment}{ * of hash table slides to perform. If s->matches is 1, then one hash table}
01635 \textcolor{comment}{ * slide will be done when switching. If s->matches is 2, the maximum value}
01636 \textcolor{comment}{ * allowed here, then the hash table will be cleared, since two or more slides}
01637 \textcolor{comment}{ * is the same as a clear.}
01638 \textcolor{comment}{ *}
01639 \textcolor{comment}{ * deflate\_stored() is written to minimize the number of times an input byte is}
01640 \textcolor{comment}{ * copied. It is most efficient with large input and output buffers, which}
01641 \textcolor{comment}{ * maximizes the opportunites to have a single copy from next\_in to next\_out.}
01642 \textcolor{comment}{ */}
01643 local block\_state deflate\_stored(s, flush)
01644     \hyperlink{structinternal__state}{deflate\_state} *s;
01645     \textcolor{keywordtype}{int} flush;
01646 \{
01647     \textcolor{comment}{/* Smallest worthy block size when not flushing or finishing. By default}
01648 \textcolor{comment}{     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For}
01649 \textcolor{comment}{     * large input and output buffers, the stored block size will be larger.}
01650 \textcolor{comment}{     */}
01651     \textcolor{keywordtype}{unsigned} min\_block = MIN(s->pending\_buf\_size - 5, s->w\_size);
01652 
01653     \textcolor{comment}{/* Copy as many min\_block or larger stored blocks directly to next\_out as}
01654 \textcolor{comment}{     * possible. If flushing, copy the remaining available input to next\_out as}
01655 \textcolor{comment}{     * stored blocks, if there is enough space.}
01656 \textcolor{comment}{     */}
01657     \textcolor{keywordtype}{unsigned} len, left, have, last = 0;
01658     \textcolor{keywordtype}{unsigned} used = s->strm->avail\_in;
01659     \textcolor{keywordflow}{do} \{
01660         \textcolor{comment}{/* Set len to the maximum size block that we can copy directly with the}
01661 \textcolor{comment}{         * available input data and output space. Set left to how much of that}
01662 \textcolor{comment}{         * would be copied from what's left in the window.}
01663 \textcolor{comment}{         */}
01664         len = MAX\_STORED;       \textcolor{comment}{/* maximum deflate stored block length */}
01665         have = (s->bi\_valid + 42) >> 3;         \textcolor{comment}{/* number of header bytes */}
01666         \textcolor{keywordflow}{if} (s->strm->avail\_out < have)          \textcolor{comment}{/* need room for header */}
01667             \textcolor{keywordflow}{break};
01668             \textcolor{comment}{/* maximum stored block length that will fit in avail\_out: */}
01669         have = s->strm->avail\_out - have;
01670         left = s->strstart - s->block\_start;    \textcolor{comment}{/* bytes left in window */}
01671         \textcolor{keywordflow}{if} (len > (ulg)left + s->strm->avail\_in)
01672             len = left + s->strm->avail\_in;     \textcolor{comment}{/* limit len to the input */}
01673         if (len > have)
01674             len = have;                         \textcolor{comment}{/* limit len to the output */}
01675 
01676         \textcolor{comment}{/* If the stored block would be less than min\_block in length, or if}
01677 \textcolor{comment}{         * unable to copy all of the available input when flushing, then try}
01678 \textcolor{comment}{         * copying to the window and the pending buffer instead. Also don't}
01679 \textcolor{comment}{         * write an empty block when flushing -- deflate() does that.}
01680 \textcolor{comment}{         */}
01681         \textcolor{keywordflow}{if} (len < min\_block && ((len == 0 && flush != Z\_FINISH) ||
01682                                 flush == Z\_NO\_FLUSH ||
01683                                 len != left + s->strm->avail\_in))
01684             \textcolor{keywordflow}{break};
01685 
01686         \textcolor{comment}{/* Make a dummy stored block in pending to get the header bytes,}
01687 \textcolor{comment}{         * including any pending bits. This also updates the debugging counts.}
01688 \textcolor{comment}{         */}
01689         last = flush == Z\_FINISH && len == left + s->strm->avail\_in ? 1 : 0;
01690         \_tr\_stored\_block(s, (\textcolor{keywordtype}{char} *)0, 0L, last);
01691 
01692         \textcolor{comment}{/* Replace the lengths in the dummy stored block with len. */}
01693         s->pending\_buf[s->pending - 4] = len;
01694         s->pending\_buf[s->pending - 3] = len >> 8;
01695         s->pending\_buf[s->pending - 2] = ~len;
01696         s->pending\_buf[s->pending - 1] = ~len >> 8;
01697 
01698         \textcolor{comment}{/* Write the stored block header bytes. */}
01699         flush\_pending(s->strm);
01700 
01701 \textcolor{preprocessor}{#ifdef ZLIB\_DEBUG}
01702         \textcolor{comment}{/* Update debugging counts for the data about to be copied. */}
01703         s->compressed\_len += len << 3;
01704         s->bits\_sent += len << 3;
01705 \textcolor{preprocessor}{#endif}
01706 
01707         \textcolor{comment}{/* Copy uncompressed bytes from the window to next\_out. */}
01708         \textcolor{keywordflow}{if} (left) \{
01709             \textcolor{keywordflow}{if} (left > len)
01710                 left = len;
01711             zmemcpy(s->strm->next\_out, s->window + s->block\_start, left);
01712             s->strm->next\_out += left;
01713             s->strm->avail\_out -= left;
01714             s->strm->total\_out += left;
01715             s->block\_start += left;
01716             len -= left;
01717         \}
01718 
01719         \textcolor{comment}{/* Copy uncompressed bytes directly from next\_in to next\_out, updating}
01720 \textcolor{comment}{         * the check value.}
01721 \textcolor{comment}{         */}
01722         \textcolor{keywordflow}{if} (len) \{
01723             read\_buf(s->strm, s->strm->next\_out, len);
01724             s->strm->next\_out += len;
01725             s->strm->avail\_out -= len;
01726             s->strm->total\_out += len;
01727         \}
01728     \} \textcolor{keywordflow}{while} (last == 0);
01729 
01730     \textcolor{comment}{/* Update the sliding window with the last s->w\_size bytes of the copied}
01731 \textcolor{comment}{     * data, or append all of the copied data to the existing window if less}
01732 \textcolor{comment}{     * than s->w\_size bytes were copied. Also update the number of bytes to}
01733 \textcolor{comment}{     * insert in the hash tables, in the event that deflateParams() switches to}
01734 \textcolor{comment}{     * a non-zero compression level.}
01735 \textcolor{comment}{     */}
01736     used -= s->strm->avail\_in;      \textcolor{comment}{/* number of input bytes directly copied */}
01737     \textcolor{keywordflow}{if} (used) \{
01738         \textcolor{comment}{/* If any input was used, then no unused input remains in the window,}
01739 \textcolor{comment}{         * therefore s->block\_start == s->strstart.}
01740 \textcolor{comment}{         */}
01741         \textcolor{keywordflow}{if} (used >= s->w\_size) \{    \textcolor{comment}{/* supplant the previous history */}
01742             s->matches = 2;         \textcolor{comment}{/* clear hash */}
01743             zmemcpy(s->window, s->strm->next\_in - s->w\_size, s->w\_size);
01744             s->strstart = s->w\_size;
01745         \}
01746         \textcolor{keywordflow}{else} \{
01747             \textcolor{keywordflow}{if} (s->window\_size - s->strstart <= used) \{
01748                 \textcolor{comment}{/* Slide the window down. */}
01749                 s->strstart -= s->w\_size;
01750                 zmemcpy(s->window, s->window + s->w\_size, s->strstart);
01751                 \textcolor{keywordflow}{if} (s->matches < 2)
01752                     s->matches++;   \textcolor{comment}{/* add a pending slide\_hash() */}
01753             \}
01754             zmemcpy(s->window + s->strstart, s->strm->next\_in - used, used);
01755             s->strstart += used;
01756         \}
01757         s->block\_start = s->strstart;
01758         s->insert += MIN(used, s->w\_size - s->insert);
01759     \}
01760     \textcolor{keywordflow}{if} (s->high\_water < s->strstart)
01761         s->high\_water = s->strstart;
01762 
01763     \textcolor{comment}{/* If the last block was written to next\_out, then done. */}
01764     \textcolor{keywordflow}{if} (last)
01765         \textcolor{keywordflow}{return} finish\_done;
01766 
01767     \textcolor{comment}{/* If flushing and all input has been consumed, then done. */}
01768     \textcolor{keywordflow}{if} (flush != Z\_NO\_FLUSH && flush != Z\_FINISH &&
01769         s->strm->avail\_in == 0 && (\textcolor{keywordtype}{long})s->strstart == s->block\_start)
01770         \textcolor{keywordflow}{return} block\_done;
01771 
01772     \textcolor{comment}{/* Fill the window with any remaining input. */}
01773     have = s->window\_size - s->strstart - 1;
01774     \textcolor{keywordflow}{if} (s->strm->avail\_in > have && s->block\_start >= (\textcolor{keywordtype}{long})s->w\_size) \{
01775         \textcolor{comment}{/* Slide the window down. */}
01776         s->block\_start -= s->w\_size;
01777         s->strstart -= s->w\_size;
01778         zmemcpy(s->window, s->window + s->w\_size, s->strstart);
01779         \textcolor{keywordflow}{if} (s->matches < 2)
01780             s->matches++;           \textcolor{comment}{/* add a pending slide\_hash() */}
01781         have += s->w\_size;          \textcolor{comment}{/* more space now */}
01782     \}
01783     \textcolor{keywordflow}{if} (have > s->strm->avail\_in)
01784         have = s->strm->avail\_in;
01785     \textcolor{keywordflow}{if} (have) \{
01786         read\_buf(s->strm, s->window + s->strstart, have);
01787         s->strstart += have;
01788     \}
01789     \textcolor{keywordflow}{if} (s->high\_water < s->strstart)
01790         s->high\_water = s->strstart;
01791 
01792     \textcolor{comment}{/* There was not enough avail\_out to write a complete worthy or flushed}
01793 \textcolor{comment}{     * stored block to next\_out. Write a stored block to pending instead, if we}
01794 \textcolor{comment}{     * have enough input for a worthy block, or if flushing and there is enough}
01795 \textcolor{comment}{     * room for the remaining input as a stored block in the pending buffer.}
01796 \textcolor{comment}{     */}
01797     have = (s->bi\_valid + 42) >> 3;         \textcolor{comment}{/* number of header bytes */}
01798         \textcolor{comment}{/* maximum stored block length that will fit in pending: */}
01799     have = MIN(s->pending\_buf\_size - have, MAX\_STORED);
01800     min\_block = MIN(have, s->w\_size);
01801     left = s->strstart - s->block\_start;
01802     \textcolor{keywordflow}{if} (left >= min\_block ||
01803         ((left || flush == Z\_FINISH) && flush != Z\_NO\_FLUSH &&
01804          s->strm->avail\_in == 0 && left <= have)) \{
01805         len = MIN(left, have);
01806         last = flush == Z\_FINISH && s->strm->avail\_in == 0 &&
01807                len == left ? 1 : 0;
01808         \_tr\_stored\_block(s, (charf *)s->window + s->block\_start, len, last);
01809         s->block\_start += len;
01810         flush\_pending(s->strm);
01811     \}
01812 
01813     \textcolor{comment}{/* We've done all we can with the available input and output. */}
01814     \textcolor{keywordflow}{return} last ? finish\_started : need\_more;
01815 \}
01816 
01817 \textcolor{comment}{/* ===========================================================================}
01818 \textcolor{comment}{ * Compress as much as possible from the input stream, return the current}
01819 \textcolor{comment}{ * block state.}
01820 \textcolor{comment}{ * This function does not perform lazy evaluation of matches and inserts}
01821 \textcolor{comment}{ * new strings in the dictionary only for unmatched strings or for short}
01822 \textcolor{comment}{ * matches. It is used only for the fast compression options.}
01823 \textcolor{comment}{ */}
01824 local block\_state deflate\_fast(s, flush)
01825     \hyperlink{structinternal__state}{deflate\_state} *s;
01826     \textcolor{keywordtype}{int} flush;
01827 \{
01828     IPos hash\_head;       \textcolor{comment}{/* head of the hash chain */}
01829     \textcolor{keywordtype}{int} bflush;           \textcolor{comment}{/* set if current block must be flushed */}
01830 
01831     \textcolor{keywordflow}{for} (;;) \{
01832         \textcolor{comment}{/* Make sure that we always have enough lookahead, except}
01833 \textcolor{comment}{         * at the end of the input file. We need MAX\_MATCH bytes}
01834 \textcolor{comment}{         * for the next match, plus MIN\_MATCH bytes to insert the}
01835 \textcolor{comment}{         * string following the next match.}
01836 \textcolor{comment}{         */}
01837         \textcolor{keywordflow}{if} (s->lookahead < MIN\_LOOKAHEAD) \{
01838             fill\_window(s);
01839             \textcolor{keywordflow}{if} (s->lookahead < MIN\_LOOKAHEAD && flush == Z\_NO\_FLUSH) \{
01840                 \textcolor{keywordflow}{return} need\_more;
01841             \}
01842             \textcolor{keywordflow}{if} (s->lookahead == 0) \textcolor{keywordflow}{break}; \textcolor{comment}{/* flush the current block */}
01843         \}
01844 
01845         \textcolor{comment}{/* Insert the string window[strstart .. strstart+2] in the}
01846 \textcolor{comment}{         * dictionary, and set hash\_head to the head of the hash chain:}
01847 \textcolor{comment}{         */}
01848         hash\_head = NIL;
01849         \textcolor{keywordflow}{if} (s->lookahead >= MIN\_MATCH) \{
01850             INSERT\_STRING(s, s->strstart, hash\_head);
01851         \}
01852 
01853         \textcolor{comment}{/* Find the longest match, discarding those <= prev\_length.}
01854 \textcolor{comment}{         * At this point we have always match\_length < MIN\_MATCH}
01855 \textcolor{comment}{         */}
01856         \textcolor{keywordflow}{if} (hash\_head != NIL && s->strstart - hash\_head <= MAX\_DIST(s)) \{
01857             \textcolor{comment}{/* To simplify the code, we prevent matches with the string}
01858 \textcolor{comment}{             * of window index 0 (in particular we have to avoid a match}
01859 \textcolor{comment}{             * of the string with itself at the start of the input file).}
01860 \textcolor{comment}{             */}
01861             s->match\_length = longest\_match (s, hash\_head);
01862             \textcolor{comment}{/* longest\_match() sets match\_start */}
01863         \}
01864         \textcolor{keywordflow}{if} (s->match\_length >= MIN\_MATCH) \{
01865             check\_match(s, s->strstart, s->match\_start, s->match\_length);
01866 
01867             \_tr\_tally\_dist(s, s->strstart - s->match\_start,
01868                            s->match\_length - MIN\_MATCH, bflush);
01869 
01870             s->lookahead -= s->match\_length;
01871 
01872             \textcolor{comment}{/* Insert new strings in the hash table only if the match length}
01873 \textcolor{comment}{             * is not too large. This saves time but degrades compression.}
01874 \textcolor{comment}{             */}
01875 \textcolor{preprocessor}{#ifndef FASTEST}
01876             \textcolor{keywordflow}{if} (s->match\_length <= s->max\_insert\_length &&
01877                 s->lookahead >= MIN\_MATCH) \{
01878                 s->match\_length--; \textcolor{comment}{/* string at strstart already in table */}
01879                 \textcolor{keywordflow}{do} \{
01880                     s->strstart++;
01881                     INSERT\_STRING(s, s->strstart, hash\_head);
01882                     \textcolor{comment}{/* strstart never exceeds WSIZE-MAX\_MATCH, so there are}
01883 \textcolor{comment}{                     * always MIN\_MATCH bytes ahead.}
01884 \textcolor{comment}{                     */}
01885                 \} \textcolor{keywordflow}{while} (--s->match\_length != 0);
01886                 s->strstart++;
01887             \} \textcolor{keywordflow}{else}
01888 \textcolor{preprocessor}{#endif}
01889             \{
01890                 s->strstart += s->match\_length;
01891                 s->match\_length = 0;
01892                 s->ins\_h = s->window[s->strstart];
01893                 UPDATE\_HASH(s, s->ins\_h, s->window[s->strstart+1]);
01894 \textcolor{preprocessor}{#if MIN\_MATCH != 3}
01895                 Call UPDATE\_HASH() MIN\_MATCH-3 more times
01896 \textcolor{preprocessor}{#endif}
01897                 \textcolor{comment}{/* If lookahead < MIN\_MATCH, ins\_h is garbage, but it does not}
01898 \textcolor{comment}{                 * matter since it will be recomputed at next deflate call.}
01899 \textcolor{comment}{                 */}
01900             \}
01901         \} \textcolor{keywordflow}{else} \{
01902             \textcolor{comment}{/* No match, output a literal byte */}
01903             Tracevv((stderr,\textcolor{stringliteral}{"%c"}, s->window[s->strstart]));
01904             \_tr\_tally\_lit (s, s->window[s->strstart], bflush);
01905             s->lookahead--;
01906             s->strstart++;
01907         \}
01908         \textcolor{keywordflow}{if} (bflush) FLUSH\_BLOCK(s, 0);
01909     \}
01910     s->insert = s->strstart < MIN\_MATCH-1 ? s->strstart : MIN\_MATCH-1;
01911     \textcolor{keywordflow}{if} (flush == Z\_FINISH) \{
01912         FLUSH\_BLOCK(s, 1);
01913         \textcolor{keywordflow}{return} finish\_done;
01914     \}
01915     \textcolor{keywordflow}{if} (s->last\_lit)
01916         FLUSH\_BLOCK(s, 0);
01917     \textcolor{keywordflow}{return} block\_done;
01918 \}
01919 
01920 \textcolor{preprocessor}{#ifndef FASTEST}
01921 \textcolor{comment}{/* ===========================================================================}
01922 \textcolor{comment}{ * Same as above, but achieves better compression. We use a lazy}
01923 \textcolor{comment}{ * evaluation for matches: a match is finally adopted only if there is}
01924 \textcolor{comment}{ * no better match at the next window position.}
01925 \textcolor{comment}{ */}
01926 local block\_state deflate\_slow(s, flush)
01927     \hyperlink{structinternal__state}{deflate\_state} *s;
01928     \textcolor{keywordtype}{int} flush;
01929 \{
01930     IPos hash\_head;          \textcolor{comment}{/* head of hash chain */}
01931     \textcolor{keywordtype}{int} bflush;              \textcolor{comment}{/* set if current block must be flushed */}
01932 
01933     \textcolor{comment}{/* Process the input block. */}
01934     \textcolor{keywordflow}{for} (;;) \{
01935         \textcolor{comment}{/* Make sure that we always have enough lookahead, except}
01936 \textcolor{comment}{         * at the end of the input file. We need MAX\_MATCH bytes}
01937 \textcolor{comment}{         * for the next match, plus MIN\_MATCH bytes to insert the}
01938 \textcolor{comment}{         * string following the next match.}
01939 \textcolor{comment}{         */}
01940         \textcolor{keywordflow}{if} (s->lookahead < MIN\_LOOKAHEAD) \{
01941             fill\_window(s);
01942             \textcolor{keywordflow}{if} (s->lookahead < MIN\_LOOKAHEAD && flush == Z\_NO\_FLUSH) \{
01943                 \textcolor{keywordflow}{return} need\_more;
01944             \}
01945             \textcolor{keywordflow}{if} (s->lookahead == 0) \textcolor{keywordflow}{break}; \textcolor{comment}{/* flush the current block */}
01946         \}
01947 
01948         \textcolor{comment}{/* Insert the string window[strstart .. strstart+2] in the}
01949 \textcolor{comment}{         * dictionary, and set hash\_head to the head of the hash chain:}
01950 \textcolor{comment}{         */}
01951         hash\_head = NIL;
01952         \textcolor{keywordflow}{if} (s->lookahead >= MIN\_MATCH) \{
01953             INSERT\_STRING(s, s->strstart, hash\_head);
01954         \}
01955 
01956         \textcolor{comment}{/* Find the longest match, discarding those <= prev\_length.}
01957 \textcolor{comment}{         */}
01958         s->prev\_length = s->match\_length, s->prev\_match = s->match\_start;
01959         s->match\_length = MIN\_MATCH-1;
01960 
01961         \textcolor{keywordflow}{if} (hash\_head != NIL && s->prev\_length < s->max\_lazy\_match &&
01962             s->strstart - hash\_head <= MAX\_DIST(s)) \{
01963             \textcolor{comment}{/* To simplify the code, we prevent matches with the string}
01964 \textcolor{comment}{             * of window index 0 (in particular we have to avoid a match}
01965 \textcolor{comment}{             * of the string with itself at the start of the input file).}
01966 \textcolor{comment}{             */}
01967             s->match\_length = longest\_match (s, hash\_head);
01968             \textcolor{comment}{/* longest\_match() sets match\_start */}
01969 
01970             \textcolor{keywordflow}{if} (s->match\_length <= 5 && (s->strategy == Z\_FILTERED
01971 #\textcolor{keywordflow}{if} TOO\_FAR <= 32767
01972                 || (s->match\_length == MIN\_MATCH &&
01973                     s->strstart - s->match\_start > TOO\_FAR)
01974 #endif
01975                 )) \{
01976 
01977                 \textcolor{comment}{/* If prev\_match is also MIN\_MATCH, match\_start is garbage}
01978 \textcolor{comment}{                 * but we will ignore the current match anyway.}
01979 \textcolor{comment}{                 */}
01980                 s->match\_length = MIN\_MATCH-1;
01981             \}
01982         \}
01983         \textcolor{comment}{/* If there was a match at the previous step and the current}
01984 \textcolor{comment}{         * match is not better, output the previous match:}
01985 \textcolor{comment}{         */}
01986         \textcolor{keywordflow}{if} (s->prev\_length >= MIN\_MATCH && s->match\_length <= s->prev\_length) \{
01987             uInt max\_insert = s->strstart + s->lookahead - MIN\_MATCH;
01988             \textcolor{comment}{/* Do not insert strings in hash table beyond this. */}
01989 
01990             check\_match(s, s->strstart-1, s->prev\_match, s->prev\_length);
01991 
01992             \_tr\_tally\_dist(s, s->strstart -1 - s->prev\_match,
01993                            s->prev\_length - MIN\_MATCH, bflush);
01994 
01995             \textcolor{comment}{/* Insert in hash table all strings up to the end of the match.}
01996 \textcolor{comment}{             * strstart-1 and strstart are already inserted. If there is not}
01997 \textcolor{comment}{             * enough lookahead, the last two strings are not inserted in}
01998 \textcolor{comment}{             * the hash table.}
01999 \textcolor{comment}{             */}
02000             s->lookahead -= s->prev\_length-1;
02001             s->prev\_length -= 2;
02002             \textcolor{keywordflow}{do} \{
02003                 \textcolor{keywordflow}{if} (++s->strstart <= max\_insert) \{
02004                     INSERT\_STRING(s, s->strstart, hash\_head);
02005                 \}
02006             \} \textcolor{keywordflow}{while} (--s->prev\_length != 0);
02007             s->match\_available = 0;
02008             s->match\_length = MIN\_MATCH-1;
02009             s->strstart++;
02010 
02011             \textcolor{keywordflow}{if} (bflush) FLUSH\_BLOCK(s, 0);
02012 
02013         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (s->match\_available) \{
02014             \textcolor{comment}{/* If there was no match at the previous position, output a}
02015 \textcolor{comment}{             * single literal. If there was a match but the current match}
02016 \textcolor{comment}{             * is longer, truncate the previous match to a single literal.}
02017 \textcolor{comment}{             */}
02018             Tracevv((stderr,\textcolor{stringliteral}{"%c"}, s->window[s->strstart-1]));
02019             \_tr\_tally\_lit(s, s->window[s->strstart-1], bflush);
02020             \textcolor{keywordflow}{if} (bflush) \{
02021                 FLUSH\_BLOCK\_ONLY(s, 0);
02022             \}
02023             s->strstart++;
02024             s->lookahead--;
02025             \textcolor{keywordflow}{if} (s->strm->avail\_out == 0) \textcolor{keywordflow}{return} need\_more;
02026         \} \textcolor{keywordflow}{else} \{
02027             \textcolor{comment}{/* There is no previous match to compare with, wait for}
02028 \textcolor{comment}{             * the next step to decide.}
02029 \textcolor{comment}{             */}
02030             s->match\_available = 1;
02031             s->strstart++;
02032             s->lookahead--;
02033         \}
02034     \}
02035     Assert (flush != Z\_NO\_FLUSH, \textcolor{stringliteral}{"no flush?"});
02036     \textcolor{keywordflow}{if} (s->match\_available) \{
02037         Tracevv((stderr,\textcolor{stringliteral}{"%c"}, s->window[s->strstart-1]));
02038         \_tr\_tally\_lit(s, s->window[s->strstart-1], bflush);
02039         s->match\_available = 0;
02040     \}
02041     s->insert = s->strstart < MIN\_MATCH-1 ? s->strstart : MIN\_MATCH-1;
02042     \textcolor{keywordflow}{if} (flush == Z\_FINISH) \{
02043         FLUSH\_BLOCK(s, 1);
02044         \textcolor{keywordflow}{return} finish\_done;
02045     \}
02046     \textcolor{keywordflow}{if} (s->last\_lit)
02047         FLUSH\_BLOCK(s, 0);
02048     \textcolor{keywordflow}{return} block\_done;
02049 \}
02050 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* FASTEST */}\textcolor{preprocessor}{}
02051 
02052 \textcolor{comment}{/* ===========================================================================}
02053 \textcolor{comment}{ * For Z\_RLE, simply look for runs of bytes, generate matches only of distance}
02054 \textcolor{comment}{ * one.  Do not maintain a hash table.  (It will be regenerated if this run of}
02055 \textcolor{comment}{ * deflate switches away from Z\_RLE.)}
02056 \textcolor{comment}{ */}
02057 local block\_state deflate\_rle(s, flush)
02058     \hyperlink{structinternal__state}{deflate\_state} *s;
02059     \textcolor{keywordtype}{int} flush;
02060 \{
02061     \textcolor{keywordtype}{int} bflush;             \textcolor{comment}{/* set if current block must be flushed */}
02062     uInt prev;              \textcolor{comment}{/* byte at distance one to match */}
02063     Bytef *scan, *strend;   \textcolor{comment}{/* scan goes up to strend for length of run */}
02064 
02065     \textcolor{keywordflow}{for} (;;) \{
02066         \textcolor{comment}{/* Make sure that we always have enough lookahead, except}
02067 \textcolor{comment}{         * at the end of the input file. We need MAX\_MATCH bytes}
02068 \textcolor{comment}{         * for the longest run, plus one for the unrolled loop.}
02069 \textcolor{comment}{         */}
02070         \textcolor{keywordflow}{if} (s->lookahead <= MAX\_MATCH) \{
02071             fill\_window(s);
02072             \textcolor{keywordflow}{if} (s->lookahead <= MAX\_MATCH && flush == Z\_NO\_FLUSH) \{
02073                 \textcolor{keywordflow}{return} need\_more;
02074             \}
02075             \textcolor{keywordflow}{if} (s->lookahead == 0) \textcolor{keywordflow}{break}; \textcolor{comment}{/* flush the current block */}
02076         \}
02077 
02078         \textcolor{comment}{/* See how many times the previous byte repeats */}
02079         s->match\_length = 0;
02080         \textcolor{keywordflow}{if} (s->lookahead >= MIN\_MATCH && s->strstart > 0) \{
02081             scan = s->window + s->strstart - 1;
02082             prev = *scan;
02083             \textcolor{keywordflow}{if} (prev == *++scan && prev == *++scan && prev == *++scan) \{
02084                 strend = s->window + s->strstart + MAX\_MATCH;
02085                 \textcolor{keywordflow}{do} \{
02086                 \} \textcolor{keywordflow}{while} (prev == *++scan && prev == *++scan &&
02087                          prev == *++scan && prev == *++scan &&
02088                          prev == *++scan && prev == *++scan &&
02089                          prev == *++scan && prev == *++scan &&
02090                          scan < strend);
02091                 s->match\_length = MAX\_MATCH - (uInt)(strend - scan);
02092                 \textcolor{keywordflow}{if} (s->match\_length > s->lookahead)
02093                     s->match\_length = s->lookahead;
02094             \}
02095             Assert(scan <= s->window+(uInt)(s->window\_size-1), \textcolor{stringliteral}{"wild scan"});
02096         \}
02097 
02098         \textcolor{comment}{/* Emit match if have run of MIN\_MATCH or longer, else emit literal */}
02099         \textcolor{keywordflow}{if} (s->match\_length >= MIN\_MATCH) \{
02100             check\_match(s, s->strstart, s->strstart - 1, s->match\_length);
02101 
02102             \_tr\_tally\_dist(s, 1, s->match\_length - MIN\_MATCH, bflush);
02103 
02104             s->lookahead -= s->match\_length;
02105             s->strstart += s->match\_length;
02106             s->match\_length = 0;
02107         \} \textcolor{keywordflow}{else} \{
02108             \textcolor{comment}{/* No match, output a literal byte */}
02109             Tracevv((stderr,\textcolor{stringliteral}{"%c"}, s->window[s->strstart]));
02110             \_tr\_tally\_lit (s, s->window[s->strstart], bflush);
02111             s->lookahead--;
02112             s->strstart++;
02113         \}
02114         \textcolor{keywordflow}{if} (bflush) FLUSH\_BLOCK(s, 0);
02115     \}
02116     s->insert = 0;
02117     \textcolor{keywordflow}{if} (flush == Z\_FINISH) \{
02118         FLUSH\_BLOCK(s, 1);
02119         \textcolor{keywordflow}{return} finish\_done;
02120     \}
02121     \textcolor{keywordflow}{if} (s->last\_lit)
02122         FLUSH\_BLOCK(s, 0);
02123     \textcolor{keywordflow}{return} block\_done;
02124 \}
02125 
02126 \textcolor{comment}{/* ===========================================================================}
02127 \textcolor{comment}{ * For Z\_HUFFMAN\_ONLY, do not look for matches.  Do not maintain a hash table.}
02128 \textcolor{comment}{ * (It will be regenerated if this run of deflate switches away from Huffman.)}
02129 \textcolor{comment}{ */}
02130 local block\_state deflate\_huff(s, flush)
02131     \hyperlink{structinternal__state}{deflate\_state} *s;
02132     \textcolor{keywordtype}{int} flush;
02133 \{
02134     \textcolor{keywordtype}{int} bflush;             \textcolor{comment}{/* set if current block must be flushed */}
02135 
02136     \textcolor{keywordflow}{for} (;;) \{
02137         \textcolor{comment}{/* Make sure that we have a literal to write. */}
02138         \textcolor{keywordflow}{if} (s->lookahead == 0) \{
02139             fill\_window(s);
02140             \textcolor{keywordflow}{if} (s->lookahead == 0) \{
02141                 \textcolor{keywordflow}{if} (flush == Z\_NO\_FLUSH)
02142                     \textcolor{keywordflow}{return} need\_more;
02143                 \textcolor{keywordflow}{break};      \textcolor{comment}{/* flush the current block */}
02144             \}
02145         \}
02146 
02147         \textcolor{comment}{/* Output a literal byte */}
02148         s->match\_length = 0;
02149         Tracevv((stderr,\textcolor{stringliteral}{"%c"}, s->window[s->strstart]));
02150         \_tr\_tally\_lit (s, s->window[s->strstart], bflush);
02151         s->lookahead--;
02152         s->strstart++;
02153         \textcolor{keywordflow}{if} (bflush) FLUSH\_BLOCK(s, 0);
02154     \}
02155     s->insert = 0;
02156     \textcolor{keywordflow}{if} (flush == Z\_FINISH) \{
02157         FLUSH\_BLOCK(s, 1);
02158         \textcolor{keywordflow}{return} finish\_done;
02159     \}
02160     \textcolor{keywordflow}{if} (s->last\_lit)
02161         FLUSH\_BLOCK(s, 0);
02162     \textcolor{keywordflow}{return} block\_done;
02163 \}
\end{DoxyCode}
