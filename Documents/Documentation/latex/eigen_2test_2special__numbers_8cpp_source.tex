\hypertarget{eigen_2test_2special__numbers_8cpp_source}{}\section{eigen/test/special\+\_\+numbers.cpp}
\label{eigen_2test_2special__numbers_8cpp_source}\index{special\+\_\+numbers.\+cpp@{special\+\_\+numbers.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2013 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "main.h"}
00011 
00012 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} special\_numbers()
00013 \{
00014   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar, Dynamic,Dynamic>} MatType;
00015   \textcolor{keywordtype}{int} rows = internal::random<int>(1,300);
00016   \textcolor{keywordtype}{int} cols = internal::random<int>(1,300);
00017   
00018   Scalar nan = std::numeric\_limits<Scalar>::quiet\_NaN();
00019   Scalar inf = std::numeric\_limits<Scalar>::infinity();
00020   Scalar s1 = internal::random<Scalar>();
00021   
00022   MatType m1    = MatType::Random(rows,cols),
00023           mnan  = MatType::Random(rows,cols),
00024           minf  = MatType::Random(rows,cols),
00025           mboth = MatType::Random(rows,cols);
00026           
00027   \textcolor{keywordtype}{int} n = internal::random<int>(1,10);
00028   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<n; ++k)
00029   \{
00030     mnan(internal::random<int>(0,rows-1), internal::random<int>(0,cols-1)) = nan;
00031     minf(internal::random<int>(0,rows-1), internal::random<int>(0,cols-1)) = inf;
00032   \}
00033   mboth = mnan + minf;
00034   
00035   VERIFY(!m1.hasNaN());
00036   VERIFY(m1.allFinite());
00037   
00038   VERIFY(mnan.hasNaN());
00039   VERIFY((s1*mnan).hasNaN());
00040   VERIFY(!minf.hasNaN());
00041   VERIFY(!(2*minf).hasNaN());
00042   VERIFY(mboth.hasNaN());
00043   VERIFY(mboth.array().hasNaN());
00044   
00045   VERIFY(!mnan.allFinite());
00046   VERIFY(!minf.allFinite());
00047   VERIFY(!(minf-mboth).allFinite());
00048   VERIFY(!mboth.allFinite());
00049   VERIFY(!mboth.array().allFinite());
00050 \}
00051 
00052 \textcolor{keywordtype}{void} test\_special\_numbers()
00053 \{
00054   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 10*g\_repeat; i++) \{
00055     CALL\_SUBTEST\_1( special\_numbers<float>() );
00056     CALL\_SUBTEST\_1( special\_numbers<double>() );
00057   \}
00058 \}
\end{DoxyCode}
