\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_executor_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Executor.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_executor_8h_source}\index{Tensor\+Executor.\+h@{Tensor\+Executor.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_EXECUTOR\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_EXECUTOR\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00023 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00024 
00025 \textcolor{comment}{// Default strategy: the expression is evaluated with a single cpu thread.}
00026 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Expression, \textcolor{keyword}{typename} Device, \textcolor{keywordtype}{bool} Vectorizable>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_executor_8h_source_l00027}\hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{00027} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{TensorExecutor}
00028 \{
00029  \textcolor{keyword}{public}:
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Expression::Index Index;
00031   EIGEN\_DEVICE\_FUNC
00032   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Expression& expr, \textcolor{keyword}{const} Device& device = Device())
00033   \{
00034     \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<Expression, Device>} 
      \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator}(expr, device);
00035     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} needs\_assign = evaluator.evalSubExprsIfNeeded(NULL);
00036     \textcolor{keywordflow}{if} (needs\_assign)
00037     \{
00038       \textcolor{keyword}{const} Index size = array\_prod(evaluator.dimensions());
00039       \textcolor{keywordflow}{for} (Index i = 0; i < size; ++i) \{
00040         evaluator.evalScalar(i);
00041       \}
00042     \}
00043     evaluator.cleanup();
00044   \}
00045 \};
00046 
00047 
00048 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Expression>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_executor_8h_source_l00049}\hyperlink{class_eigen_1_1internal_1_1_tensor_executor_3_01_expression_00_01_default_device_00_01true_01_4}{00049} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{TensorExecutor}<Expression, \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}, true>
00050 \{
00051  \textcolor{keyword}{public}:
00052   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Expression::Index Index;
00053   EIGEN\_DEVICE\_FUNC
00054   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Expression& expr, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}& device = 
      \hyperlink{struct_eigen_1_1_default_device}{DefaultDevice}())
00055   \{
00056     \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<Expression, DefaultDevice>} 
      \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator}(expr, device);
00057     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} needs\_assign = evaluator.evalSubExprsIfNeeded(NULL);
00058     \textcolor{keywordflow}{if} (needs\_assign)
00059     \{
00060       \textcolor{keyword}{const} Index size = array\_prod(evaluator.dimensions());
00061       \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{unpacket\_traits<typename TensorEvaluator<Expression, DefaultDevice>::PacketReturnType}
      >::size;
00062       \textcolor{comment}{// Give the compiler a strong hint to unroll the loop. But don't insist}
00063       \textcolor{comment}{// on unrolling, because if the function is expensive the compiler should not}
00064       \textcolor{comment}{// unroll the loop at the expense of inlining.}
00065       \textcolor{keyword}{const} Index UnrolledSize = (size / (4 * PacketSize)) * 4 * PacketSize;
00066       \textcolor{keywordflow}{for} (Index i = 0; i < UnrolledSize; i += 4*PacketSize) \{
00067         \textcolor{keywordflow}{for} (Index j = 0; j < 4; j++) \{
00068           evaluator.evalPacket(i + j * PacketSize);
00069         \}
00070       \}
00071       \textcolor{keyword}{const} Index VectorizedSize = (size / PacketSize) * PacketSize;
00072       \textcolor{keywordflow}{for} (Index i = UnrolledSize; i < VectorizedSize; i += PacketSize) \{
00073         evaluator.evalPacket(i);
00074       \}
00075       \textcolor{keywordflow}{for} (Index i = VectorizedSize; i < size; ++i) \{
00076         evaluator.evalScalar(i);
00077       \}
00078     \}
00079     evaluator.cleanup();
00080   \}
00081 \};
00082 
00083 
00084 
00085 \textcolor{comment}{// Multicore strategy: the index space is partitioned and each partition is executed on a single core}
00086 \textcolor{preprocessor}{#ifdef EIGEN\_USE\_THREADS}
00087 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Evaluator, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{bool} Vectorizable>
00088 \textcolor{keyword}{struct }EvalRange \{
00089   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(Evaluator* evaluator\_in, \textcolor{keyword}{const} Index first, \textcolor{keyword}{const} Index last) \{
00090     Evaluator \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator} = *evaluator\_in;
00091     eigen\_assert(last >= first);
00092     \textcolor{keywordflow}{for} (Index i = first; i < last; ++i) \{
00093       evaluator.evalScalar(i);
00094     \}
00095   \}
00096 
00097   \textcolor{keyword}{static} Index alignBlockSize(Index size) \{
00098     \textcolor{keywordflow}{return} size;
00099   \}
00100 \};
00101 
00102 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Evaluator, \textcolor{keyword}{typename} Index>
00103 \textcolor{keyword}{struct }EvalRange<Evaluator, Index, true> \{
00104   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{unpacket\_traits<typename Evaluator::PacketReturnType>::size}
      ;
00105 
00106   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(Evaluator* evaluator\_in, \textcolor{keyword}{const} Index first, \textcolor{keyword}{const} Index last) \{
00107     Evaluator \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator} = *evaluator\_in;
00108     eigen\_assert(last >= first);
00109     Index i = first;
00110     \textcolor{keywordflow}{if} (last - first >= PacketSize) \{
00111       eigen\_assert(first % PacketSize == 0);
00112       Index last\_chunk\_offset = last - 4 * PacketSize;
00113       \textcolor{comment}{// Give the compiler a strong hint to unroll the loop. But don't insist}
00114       \textcolor{comment}{// on unrolling, because if the function is expensive the compiler should not}
00115       \textcolor{comment}{// unroll the loop at the expense of inlining.}
00116       \textcolor{keywordflow}{for} (; i <= last\_chunk\_offset; i += 4*PacketSize) \{
00117         \textcolor{keywordflow}{for} (Index j = 0; j < 4; j++) \{
00118           evaluator.evalPacket(i + j * PacketSize);
00119         \}
00120       \}
00121       last\_chunk\_offset = last - PacketSize;
00122       \textcolor{keywordflow}{for} (; i <= last\_chunk\_offset; i += PacketSize) \{
00123         evaluator.evalPacket(i);
00124       \}
00125     \}
00126     \textcolor{keywordflow}{for} (; i < last; ++i) \{
00127       evaluator.evalScalar(i);
00128     \}
00129   \}
00130 
00131   \textcolor{keyword}{static} Index alignBlockSize(Index size) \{
00132     \textcolor{comment}{// Align block size to packet size and account for unrolling in run above.}
00133     \textcolor{keywordflow}{if} (size >= 16 * PacketSize) \{
00134       \textcolor{keywordflow}{return} (size + 4 * PacketSize - 1) & ~(4 * PacketSize - 1);
00135     \}
00136     \textcolor{comment}{// Aligning to 4 * PacketSize would increase block size by more than 25%.}
00137     \textcolor{keywordflow}{return} (size + PacketSize - 1) & ~(PacketSize - 1);
00138   \}
00139 \};
00140 
00141 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Expression, \textcolor{keywordtype}{bool} Vectorizable>
00142 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{TensorExecutor}<Expression, ThreadPoolDevice, Vectorizable> \{
00143  \textcolor{keyword}{public}:
00144   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Expression::Index Index;
00145   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Expression& expr, \textcolor{keyword}{const} ThreadPoolDevice& device)
00146   \{
00147     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<Expression, ThreadPoolDevice>} 
      Evaluator;
00148     Evaluator \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator}(expr, device);
00149     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} needs\_assign = evaluator.evalSubExprsIfNeeded(NULL);
00150     \textcolor{keywordflow}{if} (needs\_assign)
00151     \{
00152       \textcolor{keyword}{const} Index size = array\_prod(evaluator.dimensions());
00153 \textcolor{preprocessor}{#if !defined(EIGEN\_USE\_SIMPLE\_THREAD\_POOL)}
00154       device.parallelFor(size, evaluator.costPerCoeff(Vectorizable),
00155                          EvalRange<Evaluator, Index, Vectorizable>::alignBlockSize,
00156                          [&evaluator](Index first, Index last) \{
00157                            EvalRange<Evaluator, Index, Vectorizable>::run(&evaluator, first, last);
00158                          \});
00159 \textcolor{preprocessor}{#else}
00160       \textcolor{keywordtype}{size\_t} num\_threads = device.numThreads();
00161       \textcolor{keywordflow}{if} (num\_threads > 1) \{
00162         num\_threads = \hyperlink{class_eigen_1_1_tensor_cost_model}{TensorCostModel<ThreadPoolDevice>::numThreads}
      (
00163             size, evaluator.costPerCoeff(Vectorizable), num\_threads);
00164       \}
00165       \textcolor{keywordflow}{if} (num\_threads == 1) \{
00166         EvalRange<Evaluator, Index, Vectorizable>::run(&evaluator, 0, size);
00167       \} \textcolor{keywordflow}{else} \{
00168         \textcolor{keyword}{const} Index PacketSize = Vectorizable ? 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{unpacket\_traits<typename Evaluator::PacketReturnType>::size}
       : 1;
00169         Index blocksz = std::ceil<Index>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(size)/num\_threads) + PacketSize - 1;
00170         \textcolor{keyword}{const} Index blocksize = numext::maxi<Index>(PacketSize, (blocksz - (blocksz % PacketSize)));
00171         \textcolor{keyword}{const} Index numblocks = size / blocksize;
00172 
00173         Barrier barrier(numblocks);
00174         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < numblocks; ++i) \{
00175           device.enqueue\_with\_barrier(
00176               &barrier, &EvalRange<Evaluator, Index, Vectorizable>::run,
00177               &evaluator, i * blocksize, (i + 1) * blocksize);
00178         \}
00179         \textcolor{keywordflow}{if} (numblocks * blocksize < size) \{
00180           EvalRange<Evaluator, Index, Vectorizable>::run(
00181               &evaluator, numblocks * blocksize, size);
00182         \}
00183         barrier.Wait();
00184       \}
00185 \textcolor{preprocessor}{#endif  // defined(!EIGEN\_USE\_SIMPLE\_THREAD\_POOL)}
00186     \}
00187     evaluator.cleanup();
00188   \}
00189 \};
00190 \textcolor{preprocessor}{#endif  // EIGEN\_USE\_THREADS}
00191 
00192 
00193 \textcolor{comment}{// GPU: the evaluation of the expression is offloaded to a GPU.}
00194 \textcolor{preprocessor}{#if defined(EIGEN\_USE\_GPU)}
00195 
00196 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Expression, \textcolor{keywordtype}{bool} Vectorizable>
00197 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{TensorExecutor}<Expression, GpuDevice, Vectorizable> \{
00198  \textcolor{keyword}{public}:
00199   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Expression::Index Index;
00200   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Expression& expr, \textcolor{keyword}{const} GpuDevice& device);
00201 \};
00202 
00203 
00204 \textcolor{preprocessor}{#if defined(\_\_CUDACC\_\_)}
00205 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Evaluator, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{bool} Vectorizable>
00206 \textcolor{keyword}{struct }EigenMetaKernelEval \{
00207   \textcolor{keyword}{static} \_\_device\_\_ EIGEN\_ALWAYS\_INLINE
00208   \textcolor{keywordtype}{void} run(Evaluator& \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}, Index first, Index last, Index step\_size) \{
00209     \textcolor{keywordflow}{for} (Index i = first; i < last; i += step\_size) \{
00210       eval.evalScalar(i);
00211     \}
00212   \}
00213 \};
00214 
00215 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Evaluator, \textcolor{keyword}{typename} Index>
00216 \textcolor{keyword}{struct }EigenMetaKernelEval<Evaluator, Index, true> \{
00217   \textcolor{keyword}{static} \_\_device\_\_ EIGEN\_ALWAYS\_INLINE
00218   \textcolor{keywordtype}{void} run(Evaluator& \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}, Index first, Index last, Index step\_size) \{
00219     \textcolor{keyword}{const} Index PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{unpacket\_traits<typename Evaluator::PacketReturnType>::size}
      ;
00220     \textcolor{keyword}{const} Index vectorized\_size = (last / PacketSize) * PacketSize;
00221     \textcolor{keyword}{const} Index vectorized\_step\_size = step\_size * PacketSize;
00222 
00223     \textcolor{comment}{// Use the vector path}
00224     \textcolor{keywordflow}{for} (Index i = first * PacketSize; i < vectorized\_size;
00225          i += vectorized\_step\_size) \{
00226       eval.evalPacket(i);
00227     \}
00228     \textcolor{keywordflow}{for} (Index i = vectorized\_size + first; i < last; i += step\_size) \{
00229       eval.evalScalar(i);
00230     \}
00231   \}
00232 \};
00233 
00234 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Evaluator, \textcolor{keyword}{typename} Index>
00235 \_\_global\_\_ \textcolor{keywordtype}{void}
00236 \_\_launch\_bounds\_\_(1024)
00237 EigenMetaKernel(Evaluator \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}, Index size) \{
00238 
00239   \textcolor{keyword}{const} Index first\_index = blockIdx.x * blockDim.x + threadIdx.x;
00240   \textcolor{keyword}{const} Index step\_size = blockDim.x * gridDim.x;
00241 
00242   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} vectorizable = Evaluator::PacketAccess & Evaluator::IsAligned;
00243   EigenMetaKernelEval<Evaluator, Index, vectorizable>::run(eval, first\_index, size, step\_size);
00244 \}
00245 
00246 \textcolor{comment}{/*static*/}
00247 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Expression, \textcolor{keywordtype}{bool} Vectorizable>
00248 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{TensorExecutor<Expression, GpuDevice, Vectorizable>::run}
      (
00249     \textcolor{keyword}{const} Expression& expr, \textcolor{keyword}{const} GpuDevice& device) \{
00250   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<Expression, GpuDevice>} 
      \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator}(expr, device);
00251   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} needs\_assign = evaluator.evalSubExprsIfNeeded(NULL);
00252   \textcolor{keywordflow}{if} (needs\_assign) \{
00253     \textcolor{keyword}{const} \textcolor{keywordtype}{int} block\_size = device.maxCudaThreadsPerBlock();
00254     \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_blocks = device.getNumCudaMultiProcessors() *
00255                            device.maxCudaThreadsPerMultiProcessor() / block\_size;
00256     \textcolor{keyword}{const} Index size = array\_prod(evaluator.dimensions());
00257     \textcolor{comment}{// Create a least one block to ensure we won't crash when tensorflow calls with tensors of size 0.}
00258     \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_blocks = numext::maxi<int>(numext::mini<int>(max\_blocks, divup<int>(size, block\_size)), 1
      );
00259 
00260     LAUNCH\_CUDA\_KERNEL(
00261         (EigenMetaKernel<\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<Expression, GpuDevice>}, 
      Index>),
00262         num\_blocks, block\_size, 0, device, evaluator, size);
00263   \}
00264   evaluator.cleanup();
00265 \}
00266 
00267 \textcolor{preprocessor}{#endif  // \_\_CUDACC\_\_}
00268 \textcolor{preprocessor}{#endif  // EIGEN\_USE\_GPU}
00269 
00270 \textcolor{comment}{// SYCL Executor policy}
00271 \textcolor{preprocessor}{#ifdef EIGEN\_USE\_SYCL}
00272 
00273 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Expression, \textcolor{keywordtype}{bool} Vectorizable>
00274 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{TensorExecutor}<Expression, SyclDevice, Vectorizable> \{
00275 \textcolor{keyword}{public}:
00276   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} Expression &expr, \textcolor{keyword}{const} SyclDevice &device) \{
00277     \textcolor{comment}{// call TensorSYCL module}
00278     TensorSycl::run(expr, device);
00279   \}
00280 \};
00281 
00282 \textcolor{preprocessor}{#endif}
00283 
00284 \} \textcolor{comment}{// end namespace internal}
00285 
00286 \} \textcolor{comment}{// end namespace Eigen}
00287 
00288 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_EXECUTOR\_H}
\end{DoxyCode}
