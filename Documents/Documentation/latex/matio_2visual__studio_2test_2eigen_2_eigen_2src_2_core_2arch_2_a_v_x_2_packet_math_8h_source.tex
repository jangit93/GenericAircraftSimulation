\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_a_v_x_2_packet_math_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/arch/\+A\+V\+X/\+Packet\+Math.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_a_v_x_2_packet_math_8h_source}\index{Packet\+Math.\+h@{Packet\+Math.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner (benoit.steiner.goog@gmail.com)}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_PACKET\_MATH\_AVX\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_PACKET\_MATH\_AVX\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{preprocessor}{#ifndef EIGEN\_CACHEFRIENDLY\_PRODUCT\_THRESHOLD}
00018 \textcolor{preprocessor}{#define EIGEN\_CACHEFRIENDLY\_PRODUCT\_THRESHOLD 8}
00019 \textcolor{preprocessor}{#endif}
00020 
00021 \textcolor{preprocessor}{#ifndef EIGEN\_ARCH\_DEFAULT\_NUMBER\_OF\_REGISTERS}
00022 \textcolor{preprocessor}{#define EIGEN\_ARCH\_DEFAULT\_NUMBER\_OF\_REGISTERS (2*sizeof(void*))}
00023 \textcolor{preprocessor}{#endif}
00024 
00025 \textcolor{preprocessor}{#ifdef \_\_FMA\_\_}
00026 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD}
00027 \textcolor{preprocessor}{#define EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD}
00028 \textcolor{preprocessor}{#endif}
00029 \textcolor{preprocessor}{#endif}
00030 
00031 \textcolor{keyword}{typedef} \_\_m256  Packet8f;
00032 \textcolor{keyword}{typedef} \_\_m256i Packet8i;
00033 \textcolor{keyword}{typedef} \_\_m256d Packet4d;
00034 
00035 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<\_\_m256>  \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00036 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<\_\_m256i> \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00037 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<\_\_m256d> \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00038 
00039 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet8f(NAME,X) \(\backslash\)}
00040 \textcolor{preprocessor}{  const Packet8f p8f\_##NAME = pset1<Packet8f>(X)}
00041 
00042 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet4d(NAME,X) \(\backslash\)}
00043 \textcolor{preprocessor}{  const Packet4d p4d\_##NAME = pset1<Packet4d>(X)}
00044 
00045 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet8f\_FROM\_INT(NAME,X) \(\backslash\)}
00046 \textcolor{preprocessor}{  const Packet8f p8f\_##NAME = \_mm256\_castsi256\_ps(pset1<Packet8i>(X))}
00047 
00048 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet8i(NAME,X) \(\backslash\)}
00049 \textcolor{preprocessor}{  const Packet8i p8i\_##NAME = pset1<Packet8i>(X)}
00050 
00051 \textcolor{comment}{// Use the packet\_traits defined in AVX512/PacketMath.h instead if we're going}
00052 \textcolor{comment}{// to leverage AVX512 instructions.}
00053 \textcolor{preprocessor}{#ifndef EIGEN\_VECTORIZE\_AVX512}
00054 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<float>  : default\_packet\_traits
00055 \{
00056   \textcolor{keyword}{typedef} Packet8f type;
00057   \textcolor{keyword}{typedef} Packet4f half;
00058   \textcolor{keyword}{enum} \{
00059     Vectorizable = 1,
00060     AlignedOnScalar = 1,
00061     size=8,
00062     HasHalfPacket = 1,
00063 
00064     HasDiv  = 1,
00065     HasSin  = EIGEN\_FAST\_MATH,
00066     HasCos  = 0,
00067     HasLog  = 1,
00068     HasExp  = 1,
00069     HasSqrt = 1,
00070     HasRsqrt = 1,
00071     HasTanh  = EIGEN\_FAST\_MATH,
00072     HasBlend = 1,
00073     HasRound = 1,
00074     HasFloor = 1,
00075     HasCeil = 1
00076   \};
00077 \};
00078 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<double> : default\_packet\_traits
00079 \{
00080   \textcolor{keyword}{typedef} Packet4d type;
00081   \textcolor{keyword}{typedef} Packet2d half;
00082   \textcolor{keyword}{enum} \{
00083     Vectorizable = 1,
00084     AlignedOnScalar = 1,
00085     size=4,
00086     HasHalfPacket = 1,
00087 
00088     HasDiv  = 1,
00089     HasExp  = 1,
00090     HasSqrt = 1,
00091     HasRsqrt = 1,
00092     HasBlend = 1,
00093     HasRound = 1,
00094     HasFloor = 1,
00095     HasCeil = 1
00096   \};
00097 \};
00098 \textcolor{preprocessor}{#endif}
00099 
00100 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }scalar\_div\_cost<float,true> \{ \textcolor{keyword}{enum} \{ value = 14 \}; \};
00101 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }scalar\_div\_cost<double,true> \{ \textcolor{keyword}{enum} \{ value = 16 \}; \};
00102 
00103 \textcolor{comment}{/* Proper support for integers is only provided by AVX2. In the meantime, we'll}
00104 \textcolor{comment}{   use SSE instructions and packets to deal with integers.}
00105 \textcolor{comment}{template<> struct packet\_traits<int>    : default\_packet\_traits}
00106 \textcolor{comment}{\{}
00107 \textcolor{comment}{  typedef Packet8i type;}
00108 \textcolor{comment}{  enum \{}
00109 \textcolor{comment}{    Vectorizable = 1,}
00110 \textcolor{comment}{    AlignedOnScalar = 1,}
00111 \textcolor{comment}{    size=8}
00112 \textcolor{comment}{  \};}
00113 \textcolor{comment}{\};}
00114 \textcolor{comment}{*/}
00115 
00116 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet8f> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{float}  type; \textcolor{keyword}{typedef} Packet4f half; \textcolor{keyword}{enum} \{size=8, 
      alignment=\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1a7797d247b86f6e9837cc338beb6060de}{Aligned32}\}; \};
00117 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet4d> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{double} type; \textcolor{keyword}{typedef} Packet2d half; \textcolor{keyword}{enum} \{size=4, 
      alignment=\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1a7797d247b86f6e9837cc338beb6060de}{Aligned32}\}; \};
00118 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet8i> \{ \textcolor{keyword}{typedef} \textcolor{keywordtype}{int}    type; \textcolor{keyword}{typedef} Packet4i half; \textcolor{keyword}{enum} \{size=8, 
      alignment=\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1a7797d247b86f6e9837cc338beb6060de}{Aligned32}\}; \};
00119 
00120 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pset1<Packet8f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}&  from) \{ \textcolor{keywordflow}{return} \_mm256\_set1\_ps(from); 
      \}
00121 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pset1<Packet4d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& from) \{ \textcolor{keywordflow}{return} \_mm256\_set1\_pd(from); 
      \}
00122 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8i pset1<Packet8i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}&    from) \{ \textcolor{keywordflow}{return} \_mm256\_set1\_epi32(from
      ); \}
00123 
00124 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pload1<Packet8f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}*  from) \{ \textcolor{keywordflow}{return} \_mm256\_broadcast\_ss(
      from); \}
00125 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pload1<Packet4d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* from) \{ \textcolor{keywordflow}{return} \_mm256\_broadcast\_sd(
      from); \}
00126 
00127 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f plset<Packet8f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}& a) \{ \textcolor{keywordflow}{return} \_mm256\_add\_ps(
      \_mm256\_set1\_ps(a), \_mm256\_set\_ps(7.0,6.0,5.0,4.0,3.0,2.0,1.0,0.0)); \}
00128 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d plset<Packet4d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& a) \{ \textcolor{keywordflow}{return} \_mm256\_add\_pd(
      \_mm256\_set1\_pd(a), \_mm256\_set\_pd(3.0,2.0,1.0,0.0)); \}
00129 
00130 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f padd<Packet8f>(\textcolor{keyword}{const} Packet8f& a, \textcolor{keyword}{const} Packet8f& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_add\_ps(a,b); \}
00131 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d padd<Packet4d>(\textcolor{keyword}{const} Packet4d& a, \textcolor{keyword}{const} Packet4d& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_add\_pd(a,b); \}
00132 
00133 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f psub<Packet8f>(\textcolor{keyword}{const} Packet8f& a, \textcolor{keyword}{const} Packet8f& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_sub\_ps(a,b); \}
00134 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d psub<Packet4d>(\textcolor{keyword}{const} Packet4d& a, \textcolor{keyword}{const} Packet4d& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_sub\_pd(a,b); \}
00135 
00136 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pnegate(\textcolor{keyword}{const} Packet8f& a)
00137 \{
00138   \textcolor{keywordflow}{return} \_mm256\_sub\_ps(\_mm256\_set1\_ps(0.0),a);
00139 \}
00140 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pnegate(\textcolor{keyword}{const} Packet4d& a)
00141 \{
00142   \textcolor{keywordflow}{return} \_mm256\_sub\_pd(\_mm256\_set1\_pd(0.0),a);
00143 \}
00144 
00145 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pconj(\textcolor{keyword}{const} Packet8f& a) \{ \textcolor{keywordflow}{return} a; \}
00146 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pconj(\textcolor{keyword}{const} Packet4d& a) \{ \textcolor{keywordflow}{return} a; \}
00147 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8i pconj(\textcolor{keyword}{const} Packet8i& a) \{ \textcolor{keywordflow}{return} a; \}
00148 
00149 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pmul<Packet8f>(\textcolor{keyword}{const} Packet8f& a, \textcolor{keyword}{const} Packet8f& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_mul\_ps(a,b); \}
00150 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pmul<Packet4d>(\textcolor{keyword}{const} Packet4d& a, \textcolor{keyword}{const} Packet4d& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_mul\_pd(a,b); \}
00151 
00152 
00153 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pdiv<Packet8f>(\textcolor{keyword}{const} Packet8f& a, \textcolor{keyword}{const} Packet8f& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_div\_ps(a,b); \}
00154 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pdiv<Packet4d>(\textcolor{keyword}{const} Packet4d& a, \textcolor{keyword}{const} Packet4d& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_div\_pd(a,b); \}
00155 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8i pdiv<Packet8i>(\textcolor{keyword}{const} Packet8i& \textcolor{comment}{/*a*/}, \textcolor{keyword}{const} Packet8i& \textcolor{comment}{/*b*/})
00156 \{ eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"packet integer division are not supported by AVX"});
00157   \textcolor{keywordflow}{return} pset1<Packet8i>(0);
00158 \}
00159 
00160 \textcolor{preprocessor}{#ifdef \_\_FMA\_\_}
00161 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pmadd(\textcolor{keyword}{const} Packet8f& a, \textcolor{keyword}{const} Packet8f& b, \textcolor{keyword}{const} Packet8f& c) \{
00162 \textcolor{preprocessor}{#if ( EIGEN\_COMP\_GNUC\_STRICT || (EIGEN\_COMP\_CLANG && (EIGEN\_COMP\_CLANG<308)) )}
00163   \textcolor{comment}{// clang stupidly generates a vfmadd213ps instruction plus some vmovaps on registers,}
00164   \textcolor{comment}{// and gcc stupidly generates a vfmadd132ps instruction,}
00165   \textcolor{comment}{// so let's enforce it to generate a vfmadd231ps instruction since the most common use case is to
       accumulate}
00166   \textcolor{comment}{// the result of the product.}
00167   Packet8f res = c;
00168   \_\_asm\_\_(\textcolor{stringliteral}{"vfmadd231ps %[a], %[b], %[c]"} : [c] \textcolor{stringliteral}{"+x"} (res) : [a] \textcolor{stringliteral}{"x"} (a), [b] \textcolor{stringliteral}{"x"} (b));
00169   \textcolor{keywordflow}{return} res;
00170 \textcolor{preprocessor}{#else}
00171   \textcolor{keywordflow}{return} \_mm256\_fmadd\_ps(a,b,c);
00172 \textcolor{preprocessor}{#endif}
00173 \}
00174 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pmadd(\textcolor{keyword}{const} Packet4d& a, \textcolor{keyword}{const} Packet4d& b, \textcolor{keyword}{const} Packet4d& c) \{
00175 \textcolor{preprocessor}{#if ( EIGEN\_COMP\_GNUC\_STRICT || (EIGEN\_COMP\_CLANG && (EIGEN\_COMP\_CLANG<308)) )}
00176   \textcolor{comment}{// see above}
00177   Packet4d res = c;
00178   \_\_asm\_\_(\textcolor{stringliteral}{"vfmadd231pd %[a], %[b], %[c]"} : [c] \textcolor{stringliteral}{"+x"} (res) : [a] \textcolor{stringliteral}{"x"} (a), [b] \textcolor{stringliteral}{"x"} (b));
00179   \textcolor{keywordflow}{return} res;
00180 \textcolor{preprocessor}{#else}
00181   \textcolor{keywordflow}{return} \_mm256\_fmadd\_pd(a,b,c);
00182 \textcolor{preprocessor}{#endif}
00183 \}
00184 \textcolor{preprocessor}{#endif}
00185 
00186 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pmin<Packet8f>(\textcolor{keyword}{const} Packet8f& a, \textcolor{keyword}{const} Packet8f& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_min\_ps(a,b); \}
00187 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pmin<Packet4d>(\textcolor{keyword}{const} Packet4d& a, \textcolor{keyword}{const} Packet4d& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_min\_pd(a,b); \}
00188 
00189 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pmax<Packet8f>(\textcolor{keyword}{const} Packet8f& a, \textcolor{keyword}{const} Packet8f& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_max\_ps(a,b); \}
00190 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pmax<Packet4d>(\textcolor{keyword}{const} Packet4d& a, \textcolor{keyword}{const} Packet4d& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_max\_pd(a,b); \}
00191 
00192 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pround<Packet8f>(\textcolor{keyword}{const} Packet8f& a) \{ \textcolor{keywordflow}{return} \_mm256\_round\_ps(a, 
      \_MM\_FROUND\_CUR\_DIRECTION); \}
00193 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pround<Packet4d>(\textcolor{keyword}{const} Packet4d& a) \{ \textcolor{keywordflow}{return} \_mm256\_round\_pd(a, 
      \_MM\_FROUND\_CUR\_DIRECTION); \}
00194 
00195 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pceil<Packet8f>(\textcolor{keyword}{const} Packet8f& a) \{ \textcolor{keywordflow}{return} \_mm256\_ceil\_ps(a); \}
00196 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pceil<Packet4d>(\textcolor{keyword}{const} Packet4d& a) \{ \textcolor{keywordflow}{return} \_mm256\_ceil\_pd(a); \}
00197 
00198 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pfloor<Packet8f>(\textcolor{keyword}{const} Packet8f& a) \{ \textcolor{keywordflow}{return} \_mm256\_floor\_ps(a); \}
00199 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pfloor<Packet4d>(\textcolor{keyword}{const} Packet4d& a) \{ \textcolor{keywordflow}{return} \_mm256\_floor\_pd(a); \}
00200 
00201 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pand<Packet8f>(\textcolor{keyword}{const} Packet8f& a, \textcolor{keyword}{const} Packet8f& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_and\_ps(a,b); \}
00202 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pand<Packet4d>(\textcolor{keyword}{const} Packet4d& a, \textcolor{keyword}{const} Packet4d& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_and\_pd(a,b); \}
00203 
00204 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f por<Packet8f>(\textcolor{keyword}{const} Packet8f& a, \textcolor{keyword}{const} Packet8f& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_or\_ps(a,b); \}
00205 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d por<Packet4d>(\textcolor{keyword}{const} Packet4d& a, \textcolor{keyword}{const} Packet4d& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_or\_pd(a,b); \}
00206 
00207 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pxor<Packet8f>(\textcolor{keyword}{const} Packet8f& a, \textcolor{keyword}{const} Packet8f& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_xor\_ps(a,b); \}
00208 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pxor<Packet4d>(\textcolor{keyword}{const} Packet4d& a, \textcolor{keyword}{const} Packet4d& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_xor\_pd(a,b); \}
00209 
00210 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pandnot<Packet8f>(\textcolor{keyword}{const} Packet8f& a, \textcolor{keyword}{const} Packet8f& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_andnot\_ps(a,b); \}
00211 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pandnot<Packet4d>(\textcolor{keyword}{const} Packet4d& a, \textcolor{keyword}{const} Packet4d& b) \{ \textcolor{keywordflow}{return} 
      \_mm256\_andnot\_pd(a,b); \}
00212 
00213 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pload<Packet8f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}*   from) \{ EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{
      return} \_mm256\_load\_ps(from); \}
00214 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pload<Packet4d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}*  from) \{ EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{
      return} \_mm256\_load\_pd(from); \}
00215 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8i pload<Packet8i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*     from) \{ EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{
      return} \_mm256\_load\_si256(reinterpret\_cast<const \_\_m256i*>(from)); \}
00216 
00217 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f ploadu<Packet8f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}* from) \{ EIGEN\_DEBUG\_UNALIGNED\_LOAD \textcolor{keywordflow}{
      return} \_mm256\_loadu\_ps(from); \}
00218 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d ploadu<Packet4d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* from) \{ EIGEN\_DEBUG\_UNALIGNED\_LOAD \textcolor{keywordflow}{
      return} \_mm256\_loadu\_pd(from); \}
00219 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8i ploadu<Packet8i>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}* from) \{ EIGEN\_DEBUG\_UNALIGNED\_LOAD \textcolor{keywordflow}{
      return} \_mm256\_loadu\_si256(reinterpret\_cast<const \_\_m256i*>(from)); \}
00220 
00221 \textcolor{comment}{// Loads 4 floats from memory a returns the packet \{a0, a0  a1, a1, a2, a2, a3, a3\}}
00222 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f ploaddup<Packet8f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}* from)
00223 \{
00224   \textcolor{comment}{// TODO try to find a way to avoid the need of a temporary register}
00225 \textcolor{comment}{//   Packet8f tmp  = \_mm256\_castps128\_ps256(\_mm\_loadu\_ps(from));}
00226 \textcolor{comment}{//   tmp = \_mm256\_insertf128\_ps(tmp,
       \_mm\_movehl\_ps(\_mm256\_castps256\_ps128(tmp),\_mm256\_castps256\_ps128(tmp)), 1);}
00227 \textcolor{comment}{//   return \_mm256\_unpacklo\_ps(tmp,tmp);}
00228   
00229   \textcolor{comment}{// \_mm256\_insertf128\_ps is very slow on Haswell, thus:}
00230   Packet8f tmp = \_mm256\_broadcast\_ps((\textcolor{keyword}{const} \_\_m128*)(\textcolor{keyword}{const} \textcolor{keywordtype}{void}*)from);
00231   \textcolor{comment}{// mimic an "inplace" permutation of the lower 128bits using a blend}
00232   tmp = \_mm256\_blend\_ps(tmp,\_mm256\_castps128\_ps256(\_mm\_permute\_ps( \_mm256\_castps256\_ps128(tmp), \_MM\_SHUFFLE
      (1,0,1,0))), 15);
00233   \textcolor{comment}{// then we can perform a consistent permutation on the global register to get everything in shape:}
00234   \textcolor{keywordflow}{return}  \_mm256\_permute\_ps(tmp, \_MM\_SHUFFLE(3,3,2,2));
00235 \}
00236 \textcolor{comment}{// Loads 2 doubles from memory a returns the packet \{a0, a0  a1, a1\}}
00237 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d ploaddup<Packet4d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* from)
00238 \{
00239   Packet4d tmp = \_mm256\_broadcast\_pd((\textcolor{keyword}{const} \_\_m128d*)(\textcolor{keyword}{const} \textcolor{keywordtype}{void}*)from);
00240   \textcolor{keywordflow}{return}  \_mm256\_permute\_pd(tmp, 3<<2);
00241 \}
00242 
00243 \textcolor{comment}{// Loads 2 floats from memory a returns the packet \{a0, a0  a0, a0, a1, a1, a1, a1\}}
00244 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f ploadquad<Packet8f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}* from)
00245 \{
00246   Packet8f tmp = \_mm256\_castps128\_ps256(\_mm\_broadcast\_ss(from));
00247   \textcolor{keywordflow}{return} \_mm256\_insertf128\_ps(tmp, \_mm\_broadcast\_ss(from+1), 1);
00248 \}
00249 
00250 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<float>(\textcolor{keywordtype}{float}*   to, \textcolor{keyword}{const} Packet8f& from) \{ 
      EIGEN\_DEBUG\_ALIGNED\_STORE \_mm256\_store\_ps(to, from); \}
00251 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<double>(\textcolor{keywordtype}{double}* to, \textcolor{keyword}{const} Packet4d& from) \{ 
      EIGEN\_DEBUG\_ALIGNED\_STORE \_mm256\_store\_pd(to, from); \}
00252 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore<int>(\textcolor{keywordtype}{int}*       to, \textcolor{keyword}{const} Packet8i& from) \{ 
      EIGEN\_DEBUG\_ALIGNED\_STORE \_mm256\_storeu\_si256(reinterpret\_cast<\_\_m256i*>(to), from); \}
00253 
00254 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<float>(\textcolor{keywordtype}{float}*   to, \textcolor{keyword}{const} Packet8f& from) \{ 
      EIGEN\_DEBUG\_UNALIGNED\_STORE \_mm256\_storeu\_ps(to, from); \}
00255 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<double>(\textcolor{keywordtype}{double}* to, \textcolor{keyword}{const} Packet4d& from) \{ 
      EIGEN\_DEBUG\_UNALIGNED\_STORE \_mm256\_storeu\_pd(to, from); \}
00256 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<int>(\textcolor{keywordtype}{int}*       to, \textcolor{keyword}{const} Packet8i& from) \{ 
      EIGEN\_DEBUG\_UNALIGNED\_STORE \_mm256\_storeu\_si256(reinterpret\_cast<\_\_m256i*>(to), from); \}
00257 
00258 \textcolor{comment}{// NOTE: leverage \_mm256\_i32gather\_ps and \_mm256\_i32gather\_pd if AVX2 instructions are available}
00259 \textcolor{comment}{// NOTE: for the record the following seems to be slower: return \_mm256\_i32gather\_ps(from,
       \_mm256\_set1\_epi32(stride), 4);}
00260 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet8f pgather<float, Packet8f>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}* from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00261 \{
00262   \textcolor{keywordflow}{return} \_mm256\_set\_ps(from[7*stride], from[6*stride], from[5*stride], from[4*stride],
00263                        from[3*stride], from[2*stride], from[1*stride], from[0*stride]);
00264 \}
00265 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet4d pgather<double, Packet4d>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00266 \{
00267   \textcolor{keywordflow}{return} \_mm256\_set\_pd(from[3*stride], from[2*stride], from[1*stride], from[0*stride]);
00268 \}
00269 
00270 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<float, Packet8f>(\textcolor{keywordtype}{float}* to, \textcolor{keyword}{const} Packet8f& from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00271 \{
00272   \_\_m128 low = \_mm256\_extractf128\_ps(from, 0);
00273   to[stride*0] = \_mm\_cvtss\_f32(low);
00274   to[stride*1] = \_mm\_cvtss\_f32(\_mm\_shuffle\_ps(low, low, 1));
00275   to[stride*2] = \_mm\_cvtss\_f32(\_mm\_shuffle\_ps(low, low, 2));
00276   to[stride*3] = \_mm\_cvtss\_f32(\_mm\_shuffle\_ps(low, low, 3));
00277 
00278   \_\_m128 high = \_mm256\_extractf128\_ps(from, 1);
00279   to[stride*4] = \_mm\_cvtss\_f32(high);
00280   to[stride*5] = \_mm\_cvtss\_f32(\_mm\_shuffle\_ps(high, high, 1));
00281   to[stride*6] = \_mm\_cvtss\_f32(\_mm\_shuffle\_ps(high, high, 2));
00282   to[stride*7] = \_mm\_cvtss\_f32(\_mm\_shuffle\_ps(high, high, 3));
00283 \}
00284 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<double, Packet4d>(\textcolor{keywordtype}{double}* to, \textcolor{keyword}{const} Packet4d& from, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00285 \{
00286   \_\_m128d low = \_mm256\_extractf128\_pd(from, 0);
00287   to[stride*0] = \_mm\_cvtsd\_f64(low);
00288   to[stride*1] = \_mm\_cvtsd\_f64(\_mm\_shuffle\_pd(low, low, 1));
00289   \_\_m128d high = \_mm256\_extractf128\_pd(from, 1);
00290   to[stride*2] = \_mm\_cvtsd\_f64(high);
00291   to[stride*3] = \_mm\_cvtsd\_f64(\_mm\_shuffle\_pd(high, high, 1));
00292 \}
00293 
00294 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore1<Packet8f>(\textcolor{keywordtype}{float}* to, \textcolor{keyword}{const} \textcolor{keywordtype}{float}& a)
00295 \{
00296   Packet8f pa = pset1<Packet8f>(a);
00297   pstore(to, pa);
00298 \}
00299 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore1<Packet4d>(\textcolor{keywordtype}{double}* to, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& a)
00300 \{
00301   Packet4d pa = pset1<Packet4d>(a);
00302   pstore(to, pa);
00303 \}
00304 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore1<Packet8i>(\textcolor{keywordtype}{int}* to, \textcolor{keyword}{const} \textcolor{keywordtype}{int}& a)
00305 \{
00306   Packet8i pa = pset1<Packet8i>(a);
00307   pstore(to, pa);
00308 \}
00309 
00310 \textcolor{preprocessor}{#ifndef EIGEN\_VECTORIZE\_AVX512}
00311 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<float>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}*   addr) \{ \_mm\_prefetch((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)(addr)
      , \_MM\_HINT\_T0); \}
00312 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<double>(\textcolor{keyword}{const} \textcolor{keywordtype}{double}* addr) \{ \_mm\_prefetch((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)(addr)
      , \_MM\_HINT\_T0); \}
00313 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<int>(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*       addr) \{ \_mm\_prefetch((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)(addr)
      , \_MM\_HINT\_T0); \}
00314 \textcolor{preprocessor}{#endif}
00315 
00316 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float}  pfirst<Packet8f>(\textcolor{keyword}{const} Packet8f& a) \{
00317   \textcolor{keywordflow}{return} \_mm\_cvtss\_f32(\_mm256\_castps256\_ps128(a));
00318 \}
00319 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} pfirst<Packet4d>(\textcolor{keyword}{const} Packet4d& a) \{
00320   \textcolor{keywordflow}{return} \_mm\_cvtsd\_f64(\_mm256\_castpd256\_pd128(a));
00321 \}
00322 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int}    pfirst<Packet8i>(\textcolor{keyword}{const} Packet8i& a) \{
00323   \textcolor{keywordflow}{return} \_mm\_cvtsi128\_si32(\_mm256\_castsi256\_si128(a));
00324 \}
00325 
00326 
00327 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f preverse(\textcolor{keyword}{const} Packet8f& a)
00328 \{
00329   \_\_m256 tmp = \_mm256\_shuffle\_ps(a,a,0x1b);
00330   \textcolor{keywordflow}{return} \_mm256\_permute2f128\_ps(tmp, tmp, 1);
00331 \}
00332 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d preverse(\textcolor{keyword}{const} Packet4d& a)
00333 \{
00334    \_\_m256d tmp = \_mm256\_shuffle\_pd(a,a,5);
00335   \textcolor{keywordflow}{return} \_mm256\_permute2f128\_pd(tmp, tmp, 1);
00336 
00337   \_\_m256d swap\_halves = \_mm256\_permute2f128\_pd(a,a,1);
00338     \textcolor{keywordflow}{return} \_mm256\_permute\_pd(swap\_halves,5);
00339 \}
00340 
00341 \textcolor{comment}{// pabs should be ok}
00342 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pabs(\textcolor{keyword}{const} Packet8f& a)
00343 \{
00344   \textcolor{keyword}{const} Packet8f mask = \_mm256\_castsi256\_ps(\_mm256\_setr\_epi32(0x7FFFFFFF,0x7FFFFFFF,0x7FFFFFFF,0x7FFFFFFF,0
      x7FFFFFFF,0x7FFFFFFF,0x7FFFFFFF,0x7FFFFFFF));
00345   \textcolor{keywordflow}{return} \_mm256\_and\_ps(a,mask);
00346 \}
00347 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pabs(\textcolor{keyword}{const} Packet4d& a)
00348 \{
00349   \textcolor{keyword}{const} Packet4d mask = \_mm256\_castsi256\_pd(\_mm256\_setr\_epi32(0xFFFFFFFF,0x7FFFFFFF,0xFFFFFFFF,0x7FFFFFFF,0
      xFFFFFFFF,0x7FFFFFFF,0xFFFFFFFF,0x7FFFFFFF));
00350   \textcolor{keywordflow}{return} \_mm256\_and\_pd(a,mask);
00351 \}
00352 
00353 \textcolor{comment}{// preduxp should be ok}
00354 \textcolor{comment}{// FIXME: why is this ok? why isn't the simply implementation working as expected?}
00355 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f preduxp<Packet8f>(\textcolor{keyword}{const} Packet8f* vecs)
00356 \{
00357     \_\_m256 hsum1 = \_mm256\_hadd\_ps(vecs[0], vecs[1]);
00358     \_\_m256 hsum2 = \_mm256\_hadd\_ps(vecs[2], vecs[3]);
00359     \_\_m256 hsum3 = \_mm256\_hadd\_ps(vecs[4], vecs[5]);
00360     \_\_m256 hsum4 = \_mm256\_hadd\_ps(vecs[6], vecs[7]);
00361 
00362     \_\_m256 hsum5 = \_mm256\_hadd\_ps(hsum1, hsum1);
00363     \_\_m256 hsum6 = \_mm256\_hadd\_ps(hsum2, hsum2);
00364     \_\_m256 hsum7 = \_mm256\_hadd\_ps(hsum3, hsum3);
00365     \_\_m256 hsum8 = \_mm256\_hadd\_ps(hsum4, hsum4);
00366 
00367     \_\_m256 perm1 =  \_mm256\_permute2f128\_ps(hsum5, hsum5, 0x23);
00368     \_\_m256 perm2 =  \_mm256\_permute2f128\_ps(hsum6, hsum6, 0x23);
00369     \_\_m256 perm3 =  \_mm256\_permute2f128\_ps(hsum7, hsum7, 0x23);
00370     \_\_m256 perm4 =  \_mm256\_permute2f128\_ps(hsum8, hsum8, 0x23);
00371 
00372     \_\_m256 sum1 = \_mm256\_add\_ps(perm1, hsum5);
00373     \_\_m256 sum2 = \_mm256\_add\_ps(perm2, hsum6);
00374     \_\_m256 sum3 = \_mm256\_add\_ps(perm3, hsum7);
00375     \_\_m256 sum4 = \_mm256\_add\_ps(perm4, hsum8);
00376 
00377     \_\_m256 blend1 = \_mm256\_blend\_ps(sum1, sum2, 0xcc);
00378     \_\_m256 blend2 = \_mm256\_blend\_ps(sum3, sum4, 0xcc);
00379 
00380     \_\_m256 \textcolor{keyword}{final} = \_mm256\_blend\_ps(blend1, blend2, 0xf0);
00381     \textcolor{keywordflow}{return} \textcolor{keyword}{final};
00382 \}
00383 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d preduxp<Packet4d>(\textcolor{keyword}{const} Packet4d* vecs)
00384 \{
00385  Packet4d tmp0, tmp1;
00386 
00387   tmp0 = \_mm256\_hadd\_pd(vecs[0], vecs[1]);
00388   tmp0 = \_mm256\_add\_pd(tmp0, \_mm256\_permute2f128\_pd(tmp0, tmp0, 1));
00389 
00390   tmp1 = \_mm256\_hadd\_pd(vecs[2], vecs[3]);
00391   tmp1 = \_mm256\_add\_pd(tmp1, \_mm256\_permute2f128\_pd(tmp1, tmp1, 1));
00392 
00393   \textcolor{keywordflow}{return} \_mm256\_blend\_pd(tmp0, tmp1, 0xC);
00394 \}
00395 
00396 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux<Packet8f>(\textcolor{keyword}{const} Packet8f& a)
00397 \{
00398   \textcolor{keywordflow}{return} predux(Packet4f(\_mm\_add\_ps(\_mm256\_castps256\_ps128(a),\_mm256\_extractf128\_ps(a,1))));
00399 \}
00400 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux<Packet4d>(\textcolor{keyword}{const} Packet4d& a)
00401 \{
00402   \textcolor{keywordflow}{return} predux(Packet2d(\_mm\_add\_pd(\_mm256\_castpd256\_pd128(a),\_mm256\_extractf128\_pd(a,1))));
00403 \}
00404 
00405 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4f predux\_downto4<Packet8f>(\textcolor{keyword}{const} Packet8f& a)
00406 \{
00407   \textcolor{keywordflow}{return} \_mm\_add\_ps(\_mm256\_castps256\_ps128(a),\_mm256\_extractf128\_ps(a,1));
00408 \}
00409 
00410 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux\_mul<Packet8f>(\textcolor{keyword}{const} Packet8f& a)
00411 \{
00412   Packet8f tmp;
00413   tmp = \_mm256\_mul\_ps(a, \_mm256\_permute2f128\_ps(a,a,1));
00414   tmp = \_mm256\_mul\_ps(tmp, \_mm256\_shuffle\_ps(tmp,tmp,\_MM\_SHUFFLE(1,0,3,2)));
00415   \textcolor{keywordflow}{return} pfirst(\_mm256\_mul\_ps(tmp, \_mm256\_shuffle\_ps(tmp,tmp,1)));
00416 \}
00417 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux\_mul<Packet4d>(\textcolor{keyword}{const} Packet4d& a)
00418 \{
00419   Packet4d tmp;
00420   tmp = \_mm256\_mul\_pd(a, \_mm256\_permute2f128\_pd(a,a,1));
00421   \textcolor{keywordflow}{return} pfirst(\_mm256\_mul\_pd(tmp, \_mm256\_shuffle\_pd(tmp,tmp,1)));
00422 \}
00423 
00424 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux\_min<Packet8f>(\textcolor{keyword}{const} Packet8f& a)
00425 \{
00426   Packet8f tmp = \_mm256\_min\_ps(a, \_mm256\_permute2f128\_ps(a,a,1));
00427   tmp = \_mm256\_min\_ps(tmp, \_mm256\_shuffle\_ps(tmp,tmp,\_MM\_SHUFFLE(1,0,3,2)));
00428   \textcolor{keywordflow}{return} pfirst(\_mm256\_min\_ps(tmp, \_mm256\_shuffle\_ps(tmp,tmp,1)));
00429 \}
00430 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux\_min<Packet4d>(\textcolor{keyword}{const} Packet4d& a)
00431 \{
00432   Packet4d tmp = \_mm256\_min\_pd(a, \_mm256\_permute2f128\_pd(a,a,1));
00433   \textcolor{keywordflow}{return} pfirst(\_mm256\_min\_pd(tmp, \_mm256\_shuffle\_pd(tmp, tmp, 1)));
00434 \}
00435 
00436 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{float} predux\_max<Packet8f>(\textcolor{keyword}{const} Packet8f& a)
00437 \{
00438   Packet8f tmp = \_mm256\_max\_ps(a, \_mm256\_permute2f128\_ps(a,a,1));
00439   tmp = \_mm256\_max\_ps(tmp, \_mm256\_shuffle\_ps(tmp,tmp,\_MM\_SHUFFLE(1,0,3,2)));
00440   \textcolor{keywordflow}{return} pfirst(\_mm256\_max\_ps(tmp, \_mm256\_shuffle\_ps(tmp,tmp,1)));
00441 \}
00442 
00443 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{double} predux\_max<Packet4d>(\textcolor{keyword}{const} Packet4d& a)
00444 \{
00445   Packet4d tmp = \_mm256\_max\_pd(a, \_mm256\_permute2f128\_pd(a,a,1));
00446   \textcolor{keywordflow}{return} pfirst(\_mm256\_max\_pd(tmp, \_mm256\_shuffle\_pd(tmp, tmp, 1)));
00447 \}
00448 
00449 
00450 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00451 \textcolor{keyword}{struct }palign\_impl<Offset,Packet8f>
00452 \{
00453   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet8f& first, \textcolor{keyword}{const} Packet8f& second)
00454   \{
00455     \textcolor{keywordflow}{if} (Offset==1)
00456     \{
00457       first = \_mm256\_blend\_ps(first, second, 1);
00458       Packet8f tmp1 = \_mm256\_permute\_ps (first, \_MM\_SHUFFLE(0,3,2,1));
00459       Packet8f tmp2 = \_mm256\_permute2f128\_ps (tmp1, tmp1, 1);
00460       first = \_mm256\_blend\_ps(tmp1, tmp2, 0x88);
00461     \}
00462     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Offset==2)
00463     \{
00464       first = \_mm256\_blend\_ps(first, second, 3);
00465       Packet8f tmp1 = \_mm256\_permute\_ps (first, \_MM\_SHUFFLE(1,0,3,2));
00466       Packet8f tmp2 = \_mm256\_permute2f128\_ps (tmp1, tmp1, 1);
00467       first = \_mm256\_blend\_ps(tmp1, tmp2, 0xcc);
00468     \}
00469     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Offset==3)
00470     \{
00471       first = \_mm256\_blend\_ps(first, second, 7);
00472       Packet8f tmp1 = \_mm256\_permute\_ps (first, \_MM\_SHUFFLE(2,1,0,3));
00473       Packet8f tmp2 = \_mm256\_permute2f128\_ps (tmp1, tmp1, 1);
00474       first = \_mm256\_blend\_ps(tmp1, tmp2, 0xee);
00475     \}
00476     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Offset==4)
00477     \{
00478       first = \_mm256\_blend\_ps(first, second, 15);
00479       Packet8f tmp1 = \_mm256\_permute\_ps (first, \_MM\_SHUFFLE(3,2,1,0));
00480       Packet8f tmp2 = \_mm256\_permute2f128\_ps (tmp1, tmp1, 1);
00481       first = \_mm256\_permute\_ps(tmp2, \_MM\_SHUFFLE(3,2,1,0));
00482     \}
00483     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Offset==5)
00484     \{
00485       first = \_mm256\_blend\_ps(first, second, 31);
00486       first = \_mm256\_permute2f128\_ps(first, first, 1);
00487       Packet8f tmp = \_mm256\_permute\_ps (first, \_MM\_SHUFFLE(0,3,2,1));
00488       first = \_mm256\_permute2f128\_ps(tmp, tmp, 1);
00489       first = \_mm256\_blend\_ps(tmp, first, 0x88);
00490     \}
00491     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Offset==6)
00492     \{
00493       first = \_mm256\_blend\_ps(first, second, 63);
00494       first = \_mm256\_permute2f128\_ps(first, first, 1);
00495       Packet8f tmp = \_mm256\_permute\_ps (first, \_MM\_SHUFFLE(1,0,3,2));
00496       first = \_mm256\_permute2f128\_ps(tmp, tmp, 1);
00497       first = \_mm256\_blend\_ps(tmp, first, 0xcc);
00498     \}
00499     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Offset==7)
00500     \{
00501       first = \_mm256\_blend\_ps(first, second, 127);
00502       first = \_mm256\_permute2f128\_ps(first, first, 1);
00503       Packet8f tmp = \_mm256\_permute\_ps (first, \_MM\_SHUFFLE(2,1,0,3));
00504       first = \_mm256\_permute2f128\_ps(tmp, tmp, 1);
00505       first = \_mm256\_blend\_ps(tmp, first, 0xee);
00506     \}
00507   \}
00508 \};
00509 
00510 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00511 \textcolor{keyword}{struct }palign\_impl<Offset,Packet4d>
00512 \{
00513   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet4d& first, \textcolor{keyword}{const} Packet4d& second)
00514   \{
00515     \textcolor{keywordflow}{if} (Offset==1)
00516     \{
00517       first = \_mm256\_blend\_pd(first, second, 1);
00518       \_\_m256d tmp = \_mm256\_permute\_pd(first, 5);
00519       first = \_mm256\_permute2f128\_pd(tmp, tmp, 1);
00520       first = \_mm256\_blend\_pd(tmp, first, 0xA);
00521     \}
00522     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Offset==2)
00523     \{
00524       first = \_mm256\_blend\_pd(first, second, 3);
00525       first = \_mm256\_permute2f128\_pd(first, first, 1);
00526     \}
00527     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Offset==3)
00528     \{
00529       first = \_mm256\_blend\_pd(first, second, 7);
00530       \_\_m256d tmp = \_mm256\_permute\_pd(first, 5);
00531       first = \_mm256\_permute2f128\_pd(tmp, tmp, 1);
00532       first = \_mm256\_blend\_pd(tmp, first, 5);
00533     \}
00534   \}
00535 \};
00536 
00537 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00538 ptranspose(PacketBlock<Packet8f,8>& kernel) \{
00539   \_\_m256 T0 = \_mm256\_unpacklo\_ps(kernel.packet[0], kernel.packet[1]);
00540   \_\_m256 T1 = \_mm256\_unpackhi\_ps(kernel.packet[0], kernel.packet[1]);
00541   \_\_m256 T2 = \_mm256\_unpacklo\_ps(kernel.packet[2], kernel.packet[3]);
00542   \_\_m256 T3 = \_mm256\_unpackhi\_ps(kernel.packet[2], kernel.packet[3]);
00543   \_\_m256 T4 = \_mm256\_unpacklo\_ps(kernel.packet[4], kernel.packet[5]);
00544   \_\_m256 T5 = \_mm256\_unpackhi\_ps(kernel.packet[4], kernel.packet[5]);
00545   \_\_m256 T6 = \_mm256\_unpacklo\_ps(kernel.packet[6], kernel.packet[7]);
00546   \_\_m256 T7 = \_mm256\_unpackhi\_ps(kernel.packet[6], kernel.packet[7]);
00547   \_\_m256 S0 = \_mm256\_shuffle\_ps(T0,T2,\_MM\_SHUFFLE(1,0,1,0));
00548   \_\_m256 S1 = \_mm256\_shuffle\_ps(T0,T2,\_MM\_SHUFFLE(3,2,3,2));
00549   \_\_m256 S2 = \_mm256\_shuffle\_ps(T1,T3,\_MM\_SHUFFLE(1,0,1,0));
00550   \_\_m256 S3 = \_mm256\_shuffle\_ps(T1,T3,\_MM\_SHUFFLE(3,2,3,2));
00551   \_\_m256 S4 = \_mm256\_shuffle\_ps(T4,T6,\_MM\_SHUFFLE(1,0,1,0));
00552   \_\_m256 S5 = \_mm256\_shuffle\_ps(T4,T6,\_MM\_SHUFFLE(3,2,3,2));
00553   \_\_m256 S6 = \_mm256\_shuffle\_ps(T5,T7,\_MM\_SHUFFLE(1,0,1,0));
00554   \_\_m256 S7 = \_mm256\_shuffle\_ps(T5,T7,\_MM\_SHUFFLE(3,2,3,2));
00555   kernel.packet[0] = \_mm256\_permute2f128\_ps(S0, S4, 0x20);
00556   kernel.packet[1] = \_mm256\_permute2f128\_ps(S1, S5, 0x20);
00557   kernel.packet[2] = \_mm256\_permute2f128\_ps(S2, S6, 0x20);
00558   kernel.packet[3] = \_mm256\_permute2f128\_ps(S3, S7, 0x20);
00559   kernel.packet[4] = \_mm256\_permute2f128\_ps(S0, S4, 0x31);
00560   kernel.packet[5] = \_mm256\_permute2f128\_ps(S1, S5, 0x31);
00561   kernel.packet[6] = \_mm256\_permute2f128\_ps(S2, S6, 0x31);
00562   kernel.packet[7] = \_mm256\_permute2f128\_ps(S3, S7, 0x31);
00563 \}
00564 
00565 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00566 ptranspose(PacketBlock<Packet8f,4>& kernel) \{
00567   \_\_m256 T0 = \_mm256\_unpacklo\_ps(kernel.packet[0], kernel.packet[1]);
00568   \_\_m256 T1 = \_mm256\_unpackhi\_ps(kernel.packet[0], kernel.packet[1]);
00569   \_\_m256 T2 = \_mm256\_unpacklo\_ps(kernel.packet[2], kernel.packet[3]);
00570   \_\_m256 T3 = \_mm256\_unpackhi\_ps(kernel.packet[2], kernel.packet[3]);
00571 
00572   \_\_m256 S0 = \_mm256\_shuffle\_ps(T0,T2,\_MM\_SHUFFLE(1,0,1,0));
00573   \_\_m256 S1 = \_mm256\_shuffle\_ps(T0,T2,\_MM\_SHUFFLE(3,2,3,2));
00574   \_\_m256 S2 = \_mm256\_shuffle\_ps(T1,T3,\_MM\_SHUFFLE(1,0,1,0));
00575   \_\_m256 S3 = \_mm256\_shuffle\_ps(T1,T3,\_MM\_SHUFFLE(3,2,3,2));
00576 
00577   kernel.packet[0] = \_mm256\_permute2f128\_ps(S0, S1, 0x20);
00578   kernel.packet[1] = \_mm256\_permute2f128\_ps(S2, S3, 0x20);
00579   kernel.packet[2] = \_mm256\_permute2f128\_ps(S0, S1, 0x31);
00580   kernel.packet[3] = \_mm256\_permute2f128\_ps(S2, S3, 0x31);
00581 \}
00582 
00583 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00584 ptranspose(PacketBlock<Packet4d,4>& kernel) \{
00585   \_\_m256d T0 = \_mm256\_shuffle\_pd(kernel.packet[0], kernel.packet[1], 15);
00586   \_\_m256d T1 = \_mm256\_shuffle\_pd(kernel.packet[0], kernel.packet[1], 0);
00587   \_\_m256d T2 = \_mm256\_shuffle\_pd(kernel.packet[2], kernel.packet[3], 15);
00588   \_\_m256d T3 = \_mm256\_shuffle\_pd(kernel.packet[2], kernel.packet[3], 0);
00589 
00590   kernel.packet[1] = \_mm256\_permute2f128\_pd(T0, T2, 32);
00591   kernel.packet[3] = \_mm256\_permute2f128\_pd(T0, T2, 49);
00592   kernel.packet[0] = \_mm256\_permute2f128\_pd(T1, T3, 32);
00593   kernel.packet[2] = \_mm256\_permute2f128\_pd(T1, T3, 49);
00594 \}
00595 
00596 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pblend(\textcolor{keyword}{const} Selector<8>& ifPacket, \textcolor{keyword}{const} Packet8f& thenPacket, \textcolor{keyword}{
      const} Packet8f& elsePacket) \{
00597   \textcolor{keyword}{const} \_\_m256 zero = \_mm256\_setzero\_ps();
00598   \textcolor{keyword}{const} \_\_m256 select = \_mm256\_set\_ps(ifPacket.select[7], ifPacket.select[6], ifPacket.select[5], ifPacket.
      select[4], ifPacket.select[3], ifPacket.select[2], ifPacket.select[1], ifPacket.select[0]);
00599   \_\_m256 false\_mask = \_mm256\_cmp\_ps(select, zero, \_CMP\_EQ\_UQ);
00600   \textcolor{keywordflow}{return} \_mm256\_blendv\_ps(thenPacket, elsePacket, false\_mask);
00601 \}
00602 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pblend(\textcolor{keyword}{const} Selector<4>& ifPacket, \textcolor{keyword}{const} Packet4d& thenPacket, \textcolor{keyword}{
      const} Packet4d& elsePacket) \{
00603   \textcolor{keyword}{const} \_\_m256d zero = \_mm256\_setzero\_pd();
00604   \textcolor{keyword}{const} \_\_m256d select = \_mm256\_set\_pd(ifPacket.select[3], ifPacket.select[2], ifPacket.select[1], ifPacket
      .select[0]);
00605   \_\_m256d false\_mask = \_mm256\_cmp\_pd(select, zero, \_CMP\_EQ\_UQ);
00606   \textcolor{keywordflow}{return} \_mm256\_blendv\_pd(thenPacket, elsePacket, false\_mask);
00607 \}
00608 
00609 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pinsertfirst(\textcolor{keyword}{const} Packet8f& a, \textcolor{keywordtype}{float} b)
00610 \{
00611   \textcolor{keywordflow}{return} \_mm256\_blend\_ps(a,pset1<Packet8f>(b),1);
00612 \}
00613 
00614 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pinsertfirst(\textcolor{keyword}{const} Packet4d& a, \textcolor{keywordtype}{double} b)
00615 \{
00616   \textcolor{keywordflow}{return} \_mm256\_blend\_pd(a,pset1<Packet4d>(b),1);
00617 \}
00618 
00619 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet8f pinsertlast(\textcolor{keyword}{const} Packet8f& a, \textcolor{keywordtype}{float} b)
00620 \{
00621   \textcolor{keywordflow}{return} \_mm256\_blend\_ps(a,pset1<Packet8f>(b),(1<<7));
00622 \}
00623 
00624 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet4d pinsertlast(\textcolor{keyword}{const} Packet4d& a, \textcolor{keywordtype}{double} b)
00625 \{
00626   \textcolor{keywordflow}{return} \_mm256\_blend\_pd(a,pset1<Packet4d>(b),(1<<3));
00627 \}
00628 
00629 \} \textcolor{comment}{// end namespace internal}
00630 
00631 \} \textcolor{comment}{// end namespace Eigen}
00632 
00633 \textcolor{preprocessor}{#endif // EIGEN\_PACKET\_MATH\_AVX\_H}
\end{DoxyCode}
