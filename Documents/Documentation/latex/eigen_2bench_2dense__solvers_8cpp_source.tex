\hypertarget{eigen_2bench_2dense__solvers_8cpp_source}{}\section{eigen/bench/dense\+\_\+solvers.cpp}
\label{eigen_2bench_2dense__solvers_8cpp_source}\index{dense\+\_\+solvers.\+cpp@{dense\+\_\+solvers.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#include <iostream>}
00002 \textcolor{preprocessor}{#include "BenchTimer.h"}
00003 \textcolor{preprocessor}{#include <Eigen/Dense>}
00004 \textcolor{preprocessor}{#include <map>}
00005 \textcolor{preprocessor}{#include <vector>}
00006 \textcolor{preprocessor}{#include <string>}
00007 \textcolor{preprocessor}{#include <sstream>}
00008 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00009 
00010 std::map<std::string,Array<float,1,8,DontAlign|RowMajor> > results;
00011 std::vector<std::string> labels;
00012 std::vector<Array2i> sizes;
00013 
00014 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver,\textcolor{keyword}{typename} MatrixType>
00015 EIGEN\_DONT\_INLINE
00016 \textcolor{keywordtype}{void} compute\_norm\_equation(Solver &solver, \textcolor{keyword}{const} MatrixType &\hyperlink{group___core___module_class_eigen_1_1_matrix}{A}) \{
00017   \textcolor{keywordflow}{if}(A.rows()!=A.cols())
00018     solver.compute(A.transpose()*A);
00019   \textcolor{keywordflow}{else}
00020     solver.compute(A);
00021 \}
00022 
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver,\textcolor{keyword}{typename} MatrixType>
00024 EIGEN\_DONT\_INLINE
00025 \textcolor{keywordtype}{void} compute(Solver &solver, \textcolor{keyword}{const} MatrixType &A) \{
00026   solver.compute(A);
00027 \}
00028 
00029 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keywordtype}{int} Size>
00030 \textcolor{keywordtype}{void} bench(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}, \textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int} size = Size)
00031 \{
00032   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Dynamic,Size>} \hyperlink{group___core___module}{Mat};
00033   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} MatDyn;
00034   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Size,Size>} MatSquare;
00035   Mat A(rows,size);
00036   A.setRandom();
00037   \textcolor{keywordflow}{if}(rows==size)
00038     A = A*A.adjoint();
00039   \hyperlink{class_eigen_1_1_bench_timer}{BenchTimer} t\_llt, t\_ldlt, t\_lu, t\_fplu, t\_qr, t\_cpqr, t\_cod, t\_fpqr, t\_jsvd, t\_bdcsvd;
00040 
00041   \textcolor{keywordtype}{int} svd\_opt = \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9af8c742a1aa87773e165eae406c9ccaf8}{ComputeThinU}|\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a1055e53fa95c8ae04a07ebb72cfafd95}{ComputeThinV};
00042   
00043   \textcolor{keywordtype}{int} tries = 5;
00044   \textcolor{keywordtype}{int} rep = 1000/size;
00045   \textcolor{keywordflow}{if}(rep==0) rep = 1;
00046 \textcolor{comment}{//   rep = rep*rep;}
00047   
00048   \hyperlink{group___cholesky___module_class_eigen_1_1_l_l_t}{LLT<MatSquare>} llt(size);
00049   \hyperlink{group___cholesky___module_class_eigen_1_1_l_d_l_t}{LDLT<MatSquare>} ldlt(size);
00050   \hyperlink{group___l_u___module_class_eigen_1_1_partial_piv_l_u}{PartialPivLU<MatSquare>} lu(size);
00051   \hyperlink{group___l_u___module_class_eigen_1_1_full_piv_l_u}{FullPivLU<MatSquare>} fplu(size,size);
00052   \hyperlink{group___q_r___module_class_eigen_1_1_householder_q_r}{HouseholderQR<Mat>} qr(A.rows(),A.cols());
00053   \hyperlink{group___q_r___module_class_eigen_1_1_col_piv_householder_q_r}{ColPivHouseholderQR<Mat>} cpqr(A.rows(),A.cols());
00054   \hyperlink{group___q_r___module_class_eigen_1_1_complete_orthogonal_decomposition}{CompleteOrthogonalDecomposition<Mat>} cod(A.rows(),A.cols());
00055   \hyperlink{group___q_r___module_class_eigen_1_1_full_piv_householder_q_r}{FullPivHouseholderQR<Mat>} fpqr(A.rows(),A.cols());
00056   \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD<MatDyn>} jsvd(A.rows(),A.cols());
00057   \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatDyn>} bdcsvd(A.rows(),A.cols());
00058   
00059   BENCH(t\_llt, tries, rep, compute\_norm\_equation(llt,A));
00060   BENCH(t\_ldlt, tries, rep, compute\_norm\_equation(ldlt,A));
00061   BENCH(t\_lu, tries, rep, compute\_norm\_equation(lu,A));
00062   \textcolor{keywordflow}{if}(size<=1000)
00063     BENCH(t\_fplu, tries, rep, compute\_norm\_equation(fplu,A));
00064   BENCH(t\_qr, tries, rep, compute(qr,A));
00065   BENCH(t\_cpqr, tries, rep, compute(cpqr,A));
00066   BENCH(t\_cod, tries, rep, compute(cod,A));
00067   \textcolor{keywordflow}{if}(size*rows<=10000000)
00068     BENCH(t\_fpqr, tries, rep, compute(fpqr,A));
00069   \textcolor{keywordflow}{if}(size<500) \textcolor{comment}{// JacobiSVD is really too slow for too large matrices}
00070     BENCH(t\_jsvd, tries, rep, jsvd.compute(A,svd\_opt));
00071 \textcolor{comment}{//   if(size*rows<=20000000)}
00072     BENCH(t\_bdcsvd, tries, rep, bdcsvd.compute(A,svd\_opt));
00073   
00074   results[\textcolor{stringliteral}{"LLT"}][id] = t\_llt.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}();
00075   results[\textcolor{stringliteral}{"LDLT"}][id] = t\_ldlt.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}();
00076   results[\textcolor{stringliteral}{"PartialPivLU"}][id] = t\_lu.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}();
00077   results[\textcolor{stringliteral}{"FullPivLU"}][id] = t\_fplu.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}();
00078   results[\textcolor{stringliteral}{"HouseholderQR"}][id] = t\_qr.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}();
00079   results[\textcolor{stringliteral}{"ColPivHouseholderQR"}][id] = t\_cpqr.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}();
00080   results[\textcolor{stringliteral}{"CompleteOrthogonalDecomposition"}][id] = t\_cod.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}();
00081   results[\textcolor{stringliteral}{"FullPivHouseholderQR"}][id] = t\_fpqr.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}();
00082   results[\textcolor{stringliteral}{"JacobiSVD"}][id] = t\_jsvd.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}();
00083   results[\textcolor{stringliteral}{"BDCSVD"}][id] = t\_bdcsvd.\hyperlink{class_eigen_1_1_bench_timer_ae8b673b0fa356d3432c7a65c79e8af0e}{best}();
00084 \}
00085 
00086 
00087 \textcolor{keywordtype}{int} main()
00088 \{
00089   labels.push\_back(\textcolor{stringliteral}{"LLT"});
00090   labels.push\_back(\textcolor{stringliteral}{"LDLT"});
00091   labels.push\_back(\textcolor{stringliteral}{"PartialPivLU"});
00092   labels.push\_back(\textcolor{stringliteral}{"FullPivLU"});
00093   labels.push\_back(\textcolor{stringliteral}{"HouseholderQR"});
00094   labels.push\_back(\textcolor{stringliteral}{"ColPivHouseholderQR"});
00095   labels.push\_back(\textcolor{stringliteral}{"CompleteOrthogonalDecomposition"});
00096   labels.push\_back(\textcolor{stringliteral}{"FullPivHouseholderQR"});
00097   labels.push\_back(\textcolor{stringliteral}{"JacobiSVD"});
00098   labels.push\_back(\textcolor{stringliteral}{"BDCSVD"});
00099 
00100   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<labels.size(); ++i)
00101     results[labels[i]].fill(-1);
00102 
00103   \textcolor{keyword}{const} \textcolor{keywordtype}{int} small = 8;
00104   sizes.push\_back(Array2i(small,small));
00105   sizes.push\_back(Array2i(100,100));
00106   sizes.push\_back(Array2i(1000,1000));
00107   sizes.push\_back(Array2i(4000,4000));
00108   sizes.push\_back(Array2i(10000,small));
00109   sizes.push\_back(Array2i(10000,100));
00110   sizes.push\_back(Array2i(10000,1000));
00111   sizes.push\_back(Array2i(10000,4000));
00112 
00113   \textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
00114 
00115   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<sizes.size(); ++k)
00116   \{
00117     cout << sizes[k](0) << \textcolor{stringliteral}{"x"} << sizes[k](1) << \textcolor{stringliteral}{"...\(\backslash\)n"};
00118     bench<float,Dynamic>(k,sizes[k](0),sizes[k](1));
00119   \}
00120 
00121   cout.width(32);
00122   cout << \textcolor{stringliteral}{"solver/size"};
00123   cout << \textcolor{stringliteral}{"  "};
00124   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<sizes.size(); ++k)
00125   \{
00126     std::stringstream ss;
00127     ss << sizes[k](0) << \textcolor{stringliteral}{"x"} << sizes[k](1);
00128     cout.width(10); cout << ss.str(); cout << \textcolor{stringliteral}{" "};
00129   \}
00130   cout << endl;
00131 
00132 
00133   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<labels.size(); ++i)
00134   \{
00135     cout.width(32); cout << labels[i]; cout << \textcolor{stringliteral}{"  "};
00136     ArrayXf r = (results[labels[i]]*100000.f).floor()/100.f;
00137     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<sizes.size(); ++k)
00138     \{
00139       cout.width(10);
00140       \textcolor{keywordflow}{if}(r(k)>=1e6)  cout << \textcolor{stringliteral}{"-"};
00141       \textcolor{keywordflow}{else}           cout << r(k);
00142       cout << \textcolor{stringliteral}{" "};
00143     \}
00144     cout << endl;
00145   \}
00146 
00147   \textcolor{comment}{// HTML output}
00148   cout << \textcolor{stringliteral}{"<table class=\(\backslash\)"manual\(\backslash\)">"} << endl;
00149   cout << \textcolor{stringliteral}{"<tr><th>solver/size</th>"} << endl;
00150   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<sizes.size(); ++k)
00151     cout << \textcolor{stringliteral}{"  <th>"} << sizes[k](0) << \textcolor{stringliteral}{"x"} << sizes[k](1) << \textcolor{stringliteral}{"</th>"};
00152   cout << \textcolor{stringliteral}{"</tr>"} << endl;
00153   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<labels.size(); ++i)
00154   \{
00155     cout << \textcolor{stringliteral}{"<tr"};
00156     \textcolor{keywordflow}{if}(i%2==1) cout << \textcolor{stringliteral}{" class=\(\backslash\)"alt\(\backslash\)""};
00157     cout << \textcolor{stringliteral}{"><td>"} << labels[i] << \textcolor{stringliteral}{"</td>"};
00158     ArrayXf r = (results[labels[i]]*100000.f).floor()/100.f;
00159     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<sizes.size(); ++k)
00160     \{
00161       \textcolor{keywordflow}{if}(r(k)>=1e6) cout << \textcolor{stringliteral}{"<td>-</td>"};
00162       \textcolor{keywordflow}{else}
00163       \{
00164         cout << \textcolor{stringliteral}{"<td>"} << r(k);
00165         \textcolor{keywordflow}{if}(i>0)
00166           cout << \textcolor{stringliteral}{" (x"} << numext::round(10.f*results[labels[i]](k)/results[\textcolor{stringliteral}{"LLT"}](k))/10.f << \textcolor{stringliteral}{")"};
00167         \textcolor{keywordflow}{if}(i<4 && sizes[k](0)!=sizes[k](1))
00168           cout << \textcolor{stringliteral}{" <sup><a href=\(\backslash\)"#note\_ls\(\backslash\)">*</a></sup>"};
00169         cout << \textcolor{stringliteral}{"</td>"};
00170       \}
00171     \}
00172     cout << \textcolor{stringliteral}{"</tr>"} << endl;
00173   \}
00174   cout << \textcolor{stringliteral}{"</table>"} << endl;
00175 
00176 \textcolor{comment}{//   cout << "LLT                             (ms)  " << (results["LLT"]*1000.).format(fmt) << "\(\backslash\)n";}
00177 \textcolor{comment}{//   cout << "LDLT                             (%)  " << (results["LDLT"]/results["LLT"]).format(fmt) <<
       "\(\backslash\)n";}
00178 \textcolor{comment}{//   cout << "PartialPivLU                     (%)  " <<
       (results["PartialPivLU"]/results["LLT"]).format(fmt) << "\(\backslash\)n";}
00179 \textcolor{comment}{//   cout << "FullPivLU                        (%)  " << (results["FullPivLU"]/results["LLT"]).format(fmt)
       << "\(\backslash\)n";}
00180 \textcolor{comment}{//   cout << "HouseholderQR                    (%)  " <<
       (results["HouseholderQR"]/results["LLT"]).format(fmt) << "\(\backslash\)n";}
00181 \textcolor{comment}{//   cout << "ColPivHouseholderQR              (%)  " <<
       (results["ColPivHouseholderQR"]/results["LLT"]).format(fmt) << "\(\backslash\)n";}
00182 \textcolor{comment}{//   cout << "CompleteOrthogonalDecomposition  (%)  " <<
       (results["CompleteOrthogonalDecomposition"]/results["LLT"]).format(fmt) << "\(\backslash\)n";}
00183 \textcolor{comment}{//   cout << "FullPivHouseholderQR             (%)  " <<
       (results["FullPivHouseholderQR"]/results["LLT"]).format(fmt) << "\(\backslash\)n";}
00184 \textcolor{comment}{//   cout << "JacobiSVD                        (%)  " << (results["JacobiSVD"]/results["LLT"]).format(fmt)
       << "\(\backslash\)n";}
00185 \textcolor{comment}{//   cout << "BDCSVD                           (%)  " << (results["BDCSVD"]/results["LLT"]).format(fmt) <<
       "\(\backslash\)n";}
00186 \}
\end{DoxyCode}
