\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_cholesky_2_simplicial_cholesky__impl_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+Cholesky/\+Simplicial\+Cholesky\+\_\+impl.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_cholesky_2_simplicial_cholesky__impl_8h_source}\index{Simplicial\+Cholesky\+\_\+impl.\+h@{Simplicial\+Cholesky\+\_\+impl.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2012 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 
00006 \textcolor{comment}{/*}
00007 \textcolor{comment}{}
00008 \textcolor{comment}{NOTE: thes functions vave been adapted from the LDL library:}
00009 \textcolor{comment}{}
00010 \textcolor{comment}{LDL Copyright (c) 2005 by Timothy A. Davis.  All Rights Reserved.}
00011 \textcolor{comment}{}
00012 \textcolor{comment}{LDL License:}
00013 \textcolor{comment}{}
00014 \textcolor{comment}{    Your use or distribution of LDL or any modified version of}
00015 \textcolor{comment}{    LDL implies that you agree to this License.}
00016 \textcolor{comment}{}
00017 \textcolor{comment}{    This library is free software; you can redistribute it and/or}
00018 \textcolor{comment}{    modify it under the terms of the GNU Lesser General Public}
00019 \textcolor{comment}{    License as published by the Free Software Foundation; either}
00020 \textcolor{comment}{    version 2.1 of the License, or (at your option) any later version.}
00021 \textcolor{comment}{}
00022 \textcolor{comment}{    This library is distributed in the hope that it will be useful,}
00023 \textcolor{comment}{    but WITHOUT ANY WARRANTY; without even the implied warranty of}
00024 \textcolor{comment}{    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU}
00025 \textcolor{comment}{    Lesser General Public License for more details.}
00026 \textcolor{comment}{}
00027 \textcolor{comment}{    You should have received a copy of the GNU Lesser General Public}
00028 \textcolor{comment}{    License along with this library; if not, write to the Free Software}
00029 \textcolor{comment}{    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301}
00030 \textcolor{comment}{    USA}
00031 \textcolor{comment}{}
00032 \textcolor{comment}{    Permission is hereby granted to use or copy this program under the}
00033 \textcolor{comment}{    terms of the GNU LGPL, provided that the Copyright, this License,}
00034 \textcolor{comment}{    and the Availability of the original version is retained on all copies.}
00035 \textcolor{comment}{    User documentation of any code that uses this code or any modified}
00036 \textcolor{comment}{    version of this code must cite the Copyright, this License, the}
00037 \textcolor{comment}{    Availability note, and "Used by permission." Permission to modify}
00038 \textcolor{comment}{    the code and to distribute modified code is granted, provided the}
00039 \textcolor{comment}{    Copyright, this License, and the Availability note are retained,}
00040 \textcolor{comment}{    and a notice that the code was modified is included.}
00041 \textcolor{comment}{ */}
00042 
00043 \textcolor{preprocessor}{#include "../Core/util/NonMPL2.h"}
00044 
00045 \textcolor{preprocessor}{#ifndef EIGEN\_SIMPLICIAL\_CHOLESKY\_IMPL\_H}
00046 \textcolor{preprocessor}{#define EIGEN\_SIMPLICIAL\_CHOLESKY\_IMPL\_H}
00047 
00048 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00049 
00050 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00051 \textcolor{keywordtype}{void} SimplicialCholeskyBase<Derived>::analyzePattern\_preordered(\textcolor{keyword}{const} CholMatrixType& ap, \textcolor{keywordtype}{bool} doLDLT)
00052 \{
00053   \textcolor{keyword}{const} StorageIndex size = StorageIndex(ap.rows());
00054   m\_matrix.resize(size, size);
00055   m\_parent.resize(size);
00056   m\_nonZerosPerCol.resize(size);
00057 
00058   ei\_declare\_aligned\_stack\_constructed\_variable(StorageIndex, tags, size, 0);
00059 
00060   \textcolor{keywordflow}{for}(StorageIndex k = 0; k < size; ++k)
00061   \{
00062     \textcolor{comment}{/* L(k,:) pattern: all nodes reachable in etree from nz in A(0:k-1,k) */}
00063     m\_parent[k] = -1;             \textcolor{comment}{/* parent of k is not yet known */}
00064     tags[k] = k;                  \textcolor{comment}{/* mark node k as visited */}
00065     m\_nonZerosPerCol[k] = 0;      \textcolor{comment}{/* count of nonzeros in column k of L */}
00066     \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} CholMatrixType::InnerIterator it(ap,k); it; ++it)
00067     \{
00068       StorageIndex i = it.index();
00069       \textcolor{keywordflow}{if}(i < k)
00070       \{
00071         \textcolor{comment}{/* follow path from i to root of etree, stop at flagged node */}
00072         \textcolor{keywordflow}{for}(; tags[i] != k; i = m\_parent[i])
00073         \{
00074           \textcolor{comment}{/* find parent of i if not yet determined */}
00075           \textcolor{keywordflow}{if} (m\_parent[i] == -1)
00076             m\_parent[i] = k;
00077           m\_nonZerosPerCol[i]++;        \textcolor{comment}{/* L (k,i) is nonzero */}
00078           tags[i] = k;                  \textcolor{comment}{/* mark i as visited */}
00079         \}
00080       \}
00081     \}
00082   \}
00083 
00084   \textcolor{comment}{/* construct Lp index array from m\_nonZerosPerCol column counts */}
00085   StorageIndex* Lp = m\_matrix.outerIndexPtr();
00086   Lp[0] = 0;
00087   \textcolor{keywordflow}{for}(StorageIndex k = 0; k < size; ++k)
00088     Lp[k+1] = Lp[k] + m\_nonZerosPerCol[k] + (doLDLT ? 0 : 1);
00089 
00090   m\_matrix.resizeNonZeros(Lp[size]);
00091 
00092   m\_isInitialized     = \textcolor{keyword}{true};
00093   m\_info              = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00094   m\_analysisIsOk      = \textcolor{keyword}{true};
00095   m\_factorizationIsOk = \textcolor{keyword}{false};
00096 \}
00097 
00098 
00099 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00100 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} DoLDLT>
00101 \textcolor{keywordtype}{void} SimplicialCholeskyBase<Derived>::factorize\_preordered(\textcolor{keyword}{const} CholMatrixType& ap)
00102 \{
00103   \textcolor{keyword}{using} std::sqrt;
00104 
00105   eigen\_assert(m\_analysisIsOk && \textcolor{stringliteral}{"You must first call analyzePattern()"});
00106   eigen\_assert(ap.rows()==ap.cols());
00107   eigen\_assert(m\_parent.size()==ap.rows());
00108   eigen\_assert(m\_nonZerosPerCol.size()==ap.rows());
00109 
00110   \textcolor{keyword}{const} StorageIndex size = StorageIndex(ap.rows());
00111   \textcolor{keyword}{const} StorageIndex* Lp = m\_matrix.outerIndexPtr();
00112   StorageIndex* Li = m\_matrix.innerIndexPtr();
00113   Scalar* Lx = m\_matrix.valuePtr();
00114 
00115   ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, y, size, 0);
00116   ei\_declare\_aligned\_stack\_constructed\_variable(StorageIndex,  pattern, size, 0);
00117   ei\_declare\_aligned\_stack\_constructed\_variable(StorageIndex,  tags, size, 0);
00118 
00119   \textcolor{keywordtype}{bool} ok = \textcolor{keyword}{true};
00120   m\_diag.resize(DoLDLT ? size : 0);
00121 
00122   \textcolor{keywordflow}{for}(StorageIndex k = 0; k < size; ++k)
00123   \{
00124     \textcolor{comment}{// compute nonzero pattern of kth row of L, in topological order}
00125     y[k] = 0.0;                     \textcolor{comment}{// Y(0:k) is now all zero}
00126     StorageIndex top = size;               \textcolor{comment}{// stack for pattern is empty}
00127     tags[k] = k;                    \textcolor{comment}{// mark node k as visited}
00128     m\_nonZerosPerCol[k] = 0;        \textcolor{comment}{// count of nonzeros in column k of L}
00129     \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} CholMatrixType::InnerIterator it(ap,k); it; ++it)
00130     \{
00131       StorageIndex i = it.index();
00132       \textcolor{keywordflow}{if}(i <= k)
00133       \{
00134         y[i] += numext::conj(it.value());            \textcolor{comment}{/* scatter A(i,k) into Y (sum duplicates) */}
00135         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} len;
00136         \textcolor{keywordflow}{for}(len = 0; tags[i] != k; i = m\_parent[i])
00137         \{
00138           pattern[len++] = i;     \textcolor{comment}{/* L(k,i) is nonzero */}
00139           tags[i] = k;            \textcolor{comment}{/* mark i as visited */}
00140         \}
00141         \textcolor{keywordflow}{while}(len > 0)
00142           pattern[--top] = pattern[--len];
00143       \}
00144     \}
00145 
00146     \textcolor{comment}{/* compute numerical values kth row of L (a sparse triangular solve) */}
00147 
00148     RealScalar d = numext::real(y[k]) * m\_shiftScale + m\_shiftOffset;    \textcolor{comment}{// get D(k,k), apply the shift
       function, and clear Y(k)}
00149     y[k] = 0.0;
00150     \textcolor{keywordflow}{for}(; top < size; ++top)
00151     \{
00152       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = pattern[top];       \textcolor{comment}{/* pattern[top:n-1] is pattern of L(:,k) */}
00153       Scalar yi = y[i];             \textcolor{comment}{/* get and clear Y(i) */}
00154       y[i] = 0.0;
00155 
00156       \textcolor{comment}{/* the nonzero entry L(k,i) */}
00157       Scalar l\_ki;
00158       \textcolor{keywordflow}{if}(DoLDLT)
00159         l\_ki = yi / m\_diag[i];
00160       \textcolor{keywordflow}{else}
00161         yi = l\_ki = yi / Lx[Lp[i]];
00162 
00163       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p2 = Lp[i] + m\_nonZerosPerCol[i];
00164       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p;
00165       \textcolor{keywordflow}{for}(p = Lp[i] + (DoLDLT ? 0 : 1); p < p2; ++p)
00166         y[Li[p]] -= numext::conj(Lx[p]) * yi;
00167       d -= numext::real(l\_ki * numext::conj(yi));
00168       Li[p] = k;                          \textcolor{comment}{/* store L(k,i) in column form of L */}
00169       Lx[p] = l\_ki;
00170       ++m\_nonZerosPerCol[i];              \textcolor{comment}{/* increment count of nonzeros in col i */}
00171     \}
00172     \textcolor{keywordflow}{if}(DoLDLT)
00173     \{
00174       m\_diag[k] = d;
00175       \textcolor{keywordflow}{if}(d == RealScalar(0))
00176       \{
00177         ok = \textcolor{keyword}{false};                         \textcolor{comment}{/* failure, D(k,k) is zero */}
00178         \textcolor{keywordflow}{break};
00179       \}
00180     \}
00181     \textcolor{keywordflow}{else}
00182     \{
00183       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p = Lp[k] + m\_nonZerosPerCol[k]++;
00184       Li[p] = k ;                \textcolor{comment}{/* store L(k,k) = sqrt (d) in column k */}
00185       \textcolor{keywordflow}{if}(d <= RealScalar(0)) \{
00186         ok = \textcolor{keyword}{false};              \textcolor{comment}{/* failure, matrix is not positive definite */}
00187         \textcolor{keywordflow}{break};
00188       \}
00189       Lx[p] = sqrt(d) ;
00190     \}
00191   \}
00192 
00193   m\_info = ok ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} : \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00194   m\_factorizationIsOk = \textcolor{keyword}{true};
00195 \}
00196 
00197 \} \textcolor{comment}{// end namespace Eigen}
00198 
00199 \textcolor{preprocessor}{#endif // EIGEN\_SIMPLICIAL\_CHOLESKY\_IMPL\_H}
\end{DoxyCode}
