\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_chipping_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Chipping.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_chipping_8h_source}\index{Tensor\+Chipping.\+h@{Tensor\+Chipping.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_CHIPPING\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_CHIPPING\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00023 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00024 \textcolor{keyword}{template}<DenseIndex DimId, \textcolor{keyword}{typename} XprType>
00025 \textcolor{keyword}{struct }traits<TensorChippingOp<DimId, XprType> > : \textcolor{keyword}{public} traits<XprType>
00026 \{
00027   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00028   \textcolor{keyword}{typedef} traits<XprType> XprTraits;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00032   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<Nested>::type \_Nested;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions - 1;
00034   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00035 \};
00036 
00037 \textcolor{keyword}{template}<DenseIndex DimId, \textcolor{keyword}{typename} XprType>
00038 \textcolor{keyword}{struct }eval<TensorChippingOp<DimId, XprType>, \hyperlink{namespace_eigen}{Eigen}::Dense>
00039 \{
00040   \textcolor{keyword}{typedef} \textcolor{keyword}{const} TensorChippingOp<DimId, XprType>& type;
00041 \};
00042 
00043 \textcolor{keyword}{template}<DenseIndex DimId, \textcolor{keyword}{typename} XprType>
00044 \textcolor{keyword}{struct }nested<TensorChippingOp<DimId, XprType>, 1, typename eval<TensorChippingOp<DimId, XprType> >::type>
00045 \{
00046   \textcolor{keyword}{typedef} TensorChippingOp<DimId, XprType> type;
00047 \};
00048 
00049 \textcolor{keyword}{template} <DenseIndex DimId>
00050 \textcolor{keyword}{struct }DimensionId
00051 \{
00052   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE DimensionId(DenseIndex dim) \{
00053     eigen\_assert(dim == DimId);
00054   \}
00055   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE DenseIndex actualDim()\textcolor{keyword}{ const }\{
00056     \textcolor{keywordflow}{return} DimId;
00057   \}
00058 \};
00059 \textcolor{keyword}{template} <>
00060 \textcolor{keyword}{struct }DimensionId<\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}>
00061 \{
00062   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE DimensionId(DenseIndex dim) : actual\_dim(dim) \{
00063     eigen\_assert(dim >= 0);
00064   \}
00065   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE DenseIndex actualDim()\textcolor{keyword}{ const }\{
00066     \textcolor{keywordflow}{return} actual\_dim;
00067   \}
00068  \textcolor{keyword}{private}:
00069   \textcolor{keyword}{const} DenseIndex actual\_dim;
00070 \};
00071 
00072 
00073 \}  \textcolor{comment}{// end namespace internal}
00074 
00075 
00076 
00077 \textcolor{keyword}{template}<DenseIndex DimId, \textcolor{keyword}{typename} XprType>
00078 \textcolor{keyword}{class }TensorChippingOp : \textcolor{keyword}{public} TensorBase<TensorChippingOp<DimId, XprType> >
00079 \{
00080   \textcolor{keyword}{public}:
00081   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorChippingOp>::Scalar}
       Scalar;
00082   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00083   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00084   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorChippingOp>::type}
       Nested;
00085   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorChippingOp>::StorageKind}
       StorageKind;
00086   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorChippingOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00087 
00088   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorChippingOp(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} Index offset, \textcolor{keyword}{const} 
      Index dim)
00089       : m\_xpr(expr), m\_offset(offset), m\_dim(dim) \{
00090   \}
00091 
00092   EIGEN\_DEVICE\_FUNC
00093   \textcolor{keyword}{const} Index offset()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_offset; \}
00094   EIGEN\_DEVICE\_FUNC
00095   \textcolor{keyword}{const} Index dim()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dim.actualDim(); \}
00096 
00097   EIGEN\_DEVICE\_FUNC
00098   \textcolor{keyword}{const} \textcolor{keyword}{typename} internal::remove\_all<typename XprType::Nested>::type&
00099   expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00100 
00101   EIGEN\_DEVICE\_FUNC
00102   EIGEN\_STRONG\_INLINE TensorChippingOp& operator = (\textcolor{keyword}{const} TensorChippingOp& other)
00103   \{
00104     \textcolor{keyword}{typedef} TensorAssignOp<TensorChippingOp, const TensorChippingOp> Assign;
00105     Assign assign(*\textcolor{keyword}{this}, other);
00106     internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00107     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00108   \}
00109 
00110   \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00111   EIGEN\_DEVICE\_FUNC
00112   EIGEN\_STRONG\_INLINE TensorChippingOp& operator = (\textcolor{keyword}{const} OtherDerived& other)
00113   \{
00114     \textcolor{keyword}{typedef} TensorAssignOp<TensorChippingOp, const OtherDerived> Assign;
00115     Assign assign(*\textcolor{keyword}{this}, other);
00116     internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00117     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00118   \}
00119 
00120   \textcolor{keyword}{protected}:
00121     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00122     \textcolor{keyword}{const} Index m\_offset;
00123     \textcolor{keyword}{const} internal::DimensionId<DimId> m\_dim;
00124 \};
00125 
00126 
00127 \textcolor{comment}{// Eval as rvalue}
00128 \textcolor{keyword}{template}<DenseIndex DimId, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00129 \textcolor{keyword}{struct }TensorEvaluator<const TensorChippingOp<DimId, ArgType>, Device>
00130 \{
00131   \textcolor{keyword}{typedef} TensorChippingOp<DimId, ArgType> XprType;
00132   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumInputDims = internal::array\_size<typename TensorEvaluator<ArgType,
       Device>::Dimensions>::value;
00133   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = NumInputDims-1;
00134   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00135   \textcolor{keyword}{typedef} DSizes<Index, NumDims> Dimensions;
00136   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00137   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00138   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00139   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = internal::unpacket\_traits<PacketReturnType>::size;
00140 
00141 
00142   \textcolor{keyword}{enum} \{
00143     \textcolor{comment}{// Alignment can't be guaranteed at compile time since it depends on the}
00144     \textcolor{comment}{// slice offsets.}
00145     IsAligned = \textcolor{keyword}{false},
00146     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00147     Layout = TensorEvaluator<ArgType, Device>::Layout,
00148     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00149     RawAccess = \textcolor{keyword}{false}
00150   \};
00151 
00152   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00153       : m\_impl(op.expression(), device), m\_dim(op.dim()), m\_device(device)
00154   \{
00155     EIGEN\_STATIC\_ASSERT((NumInputDims >= 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00156     eigen\_assert(NumInputDims > m\_dim.actualDim());
00157 
00158     \textcolor{keyword}{const} \textcolor{keyword}{typename} TensorEvaluator<ArgType, Device>::Dimensions& input\_dims = m\_impl.dimensions();
00159     eigen\_assert(op.offset() < input\_dims[m\_dim.actualDim()]);
00160 
00161     \textcolor{keywordtype}{int} j = 0;
00162     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumInputDims; ++i) \{
00163       \textcolor{keywordflow}{if} (i != m\_dim.actualDim()) \{
00164         m\_dimensions[j] = input\_dims[i];
00165         ++j;
00166       \}
00167     \}
00168 
00169     m\_stride = 1;
00170     m\_inputStride = 1;
00171     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00172       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < m\_dim.actualDim(); ++i) \{
00173         m\_stride *= input\_dims[i];
00174         m\_inputStride *= input\_dims[i];
00175       \}
00176     \} \textcolor{keywordflow}{else} \{
00177       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumInputDims-1; i > m\_dim.actualDim(); --i) \{
00178         m\_stride *= input\_dims[i];
00179         m\_inputStride *= input\_dims[i];
00180       \}
00181     \}
00182     m\_inputStride *= input\_dims[m\_dim.actualDim()];
00183     m\_inputOffset = m\_stride * op.offset();
00184   \}
00185 
00186   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00187 
00188   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/}) \{
00189     m\_impl.evalSubExprsIfNeeded(NULL);
00190     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00191   \}
00192 
00193   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00194     m\_impl.cleanup();
00195   \}
00196 
00197   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00198 \textcolor{keyword}{  }\{
00199     \textcolor{keywordflow}{return} m\_impl.coeff(srcCoeff(index));
00200   \}
00201 
00202   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00203   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00204 \textcolor{keyword}{  }\{
00205     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00206     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00207 
00208     \textcolor{keywordflow}{if} ((static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) && m\_dim.actualDim() == 0) ||
00209     (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) && m\_dim.actualDim() == NumInputDims-1)
      ) \{
00210       \textcolor{comment}{// m\_stride is equal to 1, so let's avoid the integer division.}
00211       eigen\_assert(m\_stride == 1);
00212       Index inputIndex = index * m\_inputStride + m\_inputOffset;
00213       EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} internal::remove\_const<CoeffReturnType>::type values[PacketSize];
00214       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00215         values[i] = m\_impl.coeff(inputIndex);
00216         inputIndex += m\_inputStride;
00217       \}
00218       PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00219       \textcolor{keywordflow}{return} rslt;
00220     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) && m\_dim.actualDim() == 
      NumInputDims - 1) ||
00221            (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) && m\_dim.actualDim() == 0)) \{
00222       \textcolor{comment}{// m\_stride is aways greater than index, so let's avoid the integer division.}
00223       eigen\_assert(m\_stride > index);
00224       \textcolor{keywordflow}{return} m\_impl.template packet<LoadMode>(index + m\_inputOffset);
00225     \} \textcolor{keywordflow}{else} \{
00226       \textcolor{keyword}{const} Index idx = index / m\_stride;
00227       \textcolor{keyword}{const} Index rem = index - idx * m\_stride;
00228       \textcolor{keywordflow}{if} (rem + PacketSize <= m\_stride) \{
00229         Index inputIndex = idx * m\_inputStride + m\_inputOffset + rem;
00230         \textcolor{keywordflow}{return} m\_impl.template packet<LoadMode>(inputIndex);
00231       \} \textcolor{keywordflow}{else} \{
00232         \textcolor{comment}{// Cross the stride boundary. Fallback to slow path.}
00233         EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} internal::remove\_const<CoeffReturnType>::type values[PacketSize];
00234         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00235           values[i] = coeff(index);
00236           ++index;
00237         \}
00238         PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00239         \textcolor{keywordflow}{return} rslt;
00240       \}
00241     \}
00242   \}
00243 
00244   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorOpCost
00245   costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00246     \textcolor{keywordtype}{double} cost = 0;
00247     \textcolor{keywordflow}{if} ((static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) &&
00248          m\_dim.actualDim() == 0) ||
00249         (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) &&
00250          m\_dim.actualDim() == NumInputDims - 1)) \{
00251       cost += TensorOpCost::MulCost<Index>() + TensorOpCost::AddCost<Index>();
00252     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) &&
00253                 m\_dim.actualDim() == NumInputDims - 1) ||
00254                (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) &&
00255                 m\_dim.actualDim() == 0)) \{
00256       cost += TensorOpCost::AddCost<Index>();
00257     \} \textcolor{keywordflow}{else} \{
00258       cost += 3 * TensorOpCost::MulCost<Index>() + TensorOpCost::DivCost<Index>() +
00259               3 * TensorOpCost::AddCost<Index>();
00260     \}
00261 
00262     \textcolor{keywordflow}{return} m\_impl.costPerCoeff(vectorized) +
00263            TensorOpCost(0, 0, cost, vectorized, PacketSize);
00264   \}
00265 
00266   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType* data()\textcolor{keyword}{ const }\{
00267     CoeffReturnType* result = \textcolor{keyword}{const\_cast<}CoeffReturnType*\textcolor{keyword}{>}(m\_impl.data());
00268     \textcolor{keywordflow}{if} (((static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) && m\_dim.actualDim() == NumDims) 
      ||
00269          (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) && m\_dim.actualDim() == 0)) &&
00270         result) \{
00271       \textcolor{keywordflow}{return} result + m\_inputOffset;
00272     \} \textcolor{keywordflow}{else} \{
00273       \textcolor{keywordflow}{return} NULL;
00274     \}
00275   \}
00276 
00277  \textcolor{keyword}{protected}:
00278   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Index srcCoeff(Index index)\textcolor{keyword}{ const}
00279 \textcolor{keyword}{  }\{
00280     Index inputIndex;
00281     \textcolor{keywordflow}{if} ((static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) && m\_dim.actualDim() == 0) ||
00282     (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) && m\_dim.actualDim() == NumInputDims-1)
      ) \{
00283       \textcolor{comment}{// m\_stride is equal to 1, so let's avoid the integer division.}
00284       eigen\_assert(m\_stride == 1);
00285       inputIndex = index * m\_inputStride + m\_inputOffset;
00286     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) && m\_dim.actualDim() == 
      NumInputDims-1) ||
00287            (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) && m\_dim.actualDim() == 0)) \{
00288       \textcolor{comment}{// m\_stride is aways greater than index, so let's avoid the integer division.}
00289       eigen\_assert(m\_stride > index);
00290       inputIndex = index + m\_inputOffset;
00291     \} \textcolor{keywordflow}{else} \{
00292       \textcolor{keyword}{const} Index idx = index / m\_stride;
00293       inputIndex = idx * m\_inputStride + m\_inputOffset;
00294       index -= idx * m\_stride;
00295       inputIndex += index;
00296     \}
00297     \textcolor{keywordflow}{return} inputIndex;
00298   \}
00299 
00300   Dimensions m\_dimensions;
00301   Index m\_stride;
00302   Index m\_inputOffset;
00303   Index m\_inputStride;
00304   TensorEvaluator<ArgType, Device> m\_impl;
00305   \textcolor{keyword}{const} internal::DimensionId<DimId> m\_dim;
00306   \textcolor{keyword}{const} Device& m\_device;
00307 \};
00308 
00309 
00310 \textcolor{comment}{// Eval as lvalue}
00311 \textcolor{keyword}{template}<DenseIndex DimId, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
00312 \textcolor{keyword}{struct }TensorEvaluator<TensorChippingOp<DimId, ArgType>, Device>
00313   : \textcolor{keyword}{public} TensorEvaluator<const TensorChippingOp<DimId, ArgType>, Device>
00314 \{
00315   \textcolor{keyword}{typedef} TensorEvaluator<const TensorChippingOp<DimId, ArgType>, Device> Base;
00316   \textcolor{keyword}{typedef} TensorChippingOp<DimId, ArgType> XprType;
00317   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumInputDims = internal::array\_size<typename TensorEvaluator<ArgType,
       Device>::Dimensions>::value;
00318   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = NumInputDims-1;
00319   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00320   \textcolor{keyword}{typedef} DSizes<Index, NumDims> Dimensions;
00321   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00322   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00323   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketType<CoeffReturnType, Device>::type PacketReturnType;
00324   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = internal::unpacket\_traits<PacketReturnType>::size;
00325 
00326   \textcolor{keyword}{enum} \{
00327     IsAligned = \textcolor{keyword}{false},
00328     PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,
00329     RawAccess = \textcolor{keyword}{false}
00330   \};
00331 
00332   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorEvaluator(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& device)
00333     : Base(op, device)
00334     \{ \}
00335 
00336   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType& coeffRef(Index index)
00337   \{
00338     \textcolor{keywordflow}{return} this->m\_impl.coeffRef(this->srcCoeff(index));
00339   \}
00340 
00341   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} StoreMode> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00342   \textcolor{keywordtype}{void} writePacket(Index index, \textcolor{keyword}{const} PacketReturnType& x)
00343   \{
00344     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00345 
00346     \textcolor{keywordflow}{if} ((static\_cast<int>(this->Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) && this->m\_dim.actualDim() ==
       0) ||
00347     (static\_cast<int>(this->Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) && this->m\_dim.actualDim() == 
      NumInputDims-1)) \{
00348       \textcolor{comment}{// m\_stride is equal to 1, so let's avoid the integer division.}
00349       eigen\_assert(this->m\_stride == 1);
00350       EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} internal::remove\_const<CoeffReturnType>::type values[PacketSize];
00351       internal::pstore<CoeffReturnType, PacketReturnType>(values, x);
00352       Index inputIndex = index * this->m\_inputStride + this->m\_inputOffset;
00353       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00354         this->m\_impl.coeffRef(inputIndex) = values[i];
00355         inputIndex += this->m\_inputStride;
00356       \}
00357     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((static\_cast<int>(this->Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) && this->m\_dim.
      actualDim() == NumInputDims-1) ||
00358            (static\_cast<int>(this->Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) && this->m\_dim.actualDim()
       == 0)) \{
00359       \textcolor{comment}{// m\_stride is aways greater than index, so let's avoid the integer division.}
00360       eigen\_assert(this->m\_stride > index);
00361       this->m\_impl.template writePacket<StoreMode>(index + this->m\_inputOffset, x);
00362     \} \textcolor{keywordflow}{else} \{
00363       \textcolor{keyword}{const} Index idx = index / this->m\_stride;
00364       \textcolor{keyword}{const} Index rem = index - idx * this->m\_stride;
00365       \textcolor{keywordflow}{if} (rem + PacketSize <= this->m\_stride) \{
00366         \textcolor{keyword}{const} Index inputIndex = idx * this->m\_inputStride + this->m\_inputOffset + rem;
00367         this->m\_impl.template writePacket<StoreMode>(inputIndex, x);
00368       \} \textcolor{keywordflow}{else} \{
00369         \textcolor{comment}{// Cross stride boundary. Fallback to slow path.}
00370         EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} internal::remove\_const<CoeffReturnType>::type values[PacketSize];
00371         internal::pstore<CoeffReturnType, PacketReturnType>(values, x);
00372         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00373           this->coeffRef(index) = values[i];
00374           ++index;
00375         \}
00376       \}
00377     \}
00378   \}
00379 \};
00380 
00381 
00382 \} \textcolor{comment}{// end namespace Eigen}
00383 
00384 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_CHIPPING\_H}
\end{DoxyCode}
