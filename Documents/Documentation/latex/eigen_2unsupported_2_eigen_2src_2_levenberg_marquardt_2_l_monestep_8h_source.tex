\hypertarget{eigen_2unsupported_2_eigen_2src_2_levenberg_marquardt_2_l_monestep_8h_source}{}\section{eigen/unsupported/\+Eigen/src/\+Levenberg\+Marquardt/\+L\+Monestep.h}
\label{eigen_2unsupported_2_eigen_2src_2_levenberg_marquardt_2_l_monestep_8h_source}\index{L\+Monestep.\+h@{L\+Monestep.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Thomas Capricelli <orzel@freehackers.org>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This code initially comes from MINPACK whose original authors are:}
00007 \textcolor{comment}{// Copyright Jorge More - Argonne National Laboratory}
00008 \textcolor{comment}{// Copyright Burt Garbow - Argonne National Laboratory}
00009 \textcolor{comment}{// Copyright Ken Hillstrom - Argonne National Laboratory}
00010 \textcolor{comment}{//}
00011 \textcolor{comment}{// This Source Code Form is subject to the terms of the Minpack license}
00012 \textcolor{comment}{// (a BSD-like license) described in the campaigned CopyrightMINPACK.txt file.}
00013 
00014 \textcolor{preprocessor}{#ifndef EIGEN\_LMONESTEP\_H}
00015 \textcolor{preprocessor}{#define EIGEN\_LMONESTEP\_H}
00016 
00017 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00018 
00019 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FunctorType>
00020 LevenbergMarquardtSpace::Status
00021 LevenbergMarquardt<FunctorType>::minimizeOneStep(FVectorType  &x)
00022 \{
00023   \textcolor{keyword}{using} std::abs;
00024   \textcolor{keyword}{using} std::sqrt;
00025   RealScalar temp, temp1,temp2; 
00026   RealScalar ratio; 
00027   RealScalar pnorm, xnorm, fnorm1, actred, dirder, prered;
00028   eigen\_assert(x.size()==n); \textcolor{comment}{// check the caller is not cheating us}
00029 
00030   temp = 0.0; xnorm = 0.0;
00031   \textcolor{comment}{/* calculate the jacobian matrix. */}
00032   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} df\_ret = m\_functor.df(x, m\_fjac);
00033   \textcolor{keywordflow}{if} (df\_ret<0)
00034       \textcolor{keywordflow}{return} LevenbergMarquardtSpace::UserAsked;
00035   \textcolor{keywordflow}{if} (df\_ret>0)
00036       \textcolor{comment}{// numerical diff, we evaluated the function df\_ret times}
00037       m\_nfev += df\_ret;
00038   \textcolor{keywordflow}{else} m\_njev++;
00039 
00040   \textcolor{comment}{/* compute the qr factorization of the jacobian. */}
00041   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < x.size(); ++j)
00042     m\_wa2(j) = m\_fjac.col(j).blueNorm();
00043   QRSolver qrfac(m\_fjac);
00044   \textcolor{keywordflow}{if}(qrfac.info() != \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success}) \{
00045     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue};
00046     \textcolor{keywordflow}{return} LevenbergMarquardtSpace::ImproperInputParameters;
00047   \}
00048   \textcolor{comment}{// Make a copy of the first factor with the associated permutation}
00049   m\_rfactor = qrfac.matrixR();
00050   m\_permutation = (qrfac.colsPermutation());
00051 
00052   \textcolor{comment}{/* on the first iteration and if external scaling is not used, scale according */}
00053   \textcolor{comment}{/* to the norms of the columns of the initial jacobian. */}
00054   \textcolor{keywordflow}{if} (m\_iter == 1) \{
00055       \textcolor{keywordflow}{if} (!m\_useExternalScaling)
00056           \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < n; ++j)
00057               m\_diag[j] = (m\_wa2[j]==0.)? 1. : m\_wa2[j];
00058 
00059       \textcolor{comment}{/* on the first iteration, calculate the norm of the scaled x */}
00060       \textcolor{comment}{/* and initialize the step bound m\_delta. */}
00061       xnorm = m\_diag.cwiseProduct(x).stableNorm();
00062       m\_delta = m\_factor * xnorm;
00063       \textcolor{keywordflow}{if} (m\_delta == 0.)
00064           m\_delta = m\_factor;
00065   \}
00066 
00067   \textcolor{comment}{/* form (q transpose)*m\_fvec and store the first n components in */}
00068   \textcolor{comment}{/* m\_qtf. */}
00069   m\_wa4 = m\_fvec;
00070   m\_wa4 = qrfac.matrixQ().adjoint() * m\_fvec; 
00071   m\_qtf = m\_wa4.head(n);
00072 
00073   \textcolor{comment}{/* compute the norm of the scaled gradient. */}
00074   m\_gnorm = 0.;
00075   \textcolor{keywordflow}{if} (m\_fnorm != 0.)
00076       \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < n; ++j)
00077           \textcolor{keywordflow}{if} (m\_wa2[m\_permutation.indices()[j]] != 0.)
00078               m\_gnorm = (std::max)(m\_gnorm, abs( m\_rfactor.col(j).head(j+1).dot(m\_qtf.head(j+1)/m\_fnorm) / 
      m\_wa2[m\_permutation.indices()[j]]));
00079 
00080   \textcolor{comment}{/* test for convergence of the gradient norm. */}
00081   \textcolor{keywordflow}{if} (m\_gnorm <= m\_gtol) \{
00082     m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00083     \textcolor{keywordflow}{return} LevenbergMarquardtSpace::CosinusTooSmall;
00084   \}
00085 
00086   \textcolor{comment}{/* rescale if necessary. */}
00087   \textcolor{keywordflow}{if} (!m\_useExternalScaling)
00088       m\_diag = m\_diag.cwiseMax(m\_wa2);
00089 
00090   \textcolor{keywordflow}{do} \{
00091     \textcolor{comment}{/* determine the levenberg-marquardt parameter. */}
00092     internal::lmpar2(qrfac, m\_diag, m\_qtf, m\_delta, m\_par, m\_wa1);
00093 
00094     \textcolor{comment}{/* store the direction p and x + p. calculate the norm of p. */}
00095     m\_wa1 = -m\_wa1;
00096     m\_wa2 = x + m\_wa1;
00097     pnorm = m\_diag.cwiseProduct(m\_wa1).stableNorm();
00098 
00099     \textcolor{comment}{/* on the first iteration, adjust the initial step bound. */}
00100     \textcolor{keywordflow}{if} (m\_iter == 1)
00101         m\_delta = (std::min)(m\_delta,pnorm);
00102 
00103     \textcolor{comment}{/* evaluate the function at x + p and calculate its norm. */}
00104     \textcolor{keywordflow}{if} ( m\_functor(m\_wa2, m\_wa4) < 0)
00105         \textcolor{keywordflow}{return} LevenbergMarquardtSpace::UserAsked;
00106     ++m\_nfev;
00107     fnorm1 = m\_wa4.stableNorm();
00108 
00109     \textcolor{comment}{/* compute the scaled actual reduction. */}
00110     actred = -1.;
00111     \textcolor{keywordflow}{if} (Scalar(.1) * fnorm1 < m\_fnorm)
00112         actred = 1. - numext::abs2(fnorm1 / m\_fnorm);
00113 
00114     \textcolor{comment}{/* compute the scaled predicted reduction and */}
00115     \textcolor{comment}{/* the scaled directional derivative. */}
00116     m\_wa3 = m\_rfactor.template triangularView<Upper>() * (m\_permutation.inverse() *m\_wa1);
00117     temp1 = numext::abs2(m\_wa3.stableNorm() / m\_fnorm);
00118     temp2 = numext::abs2(sqrt(m\_par) * pnorm / m\_fnorm);
00119     prered = temp1 + temp2 / Scalar(.5);
00120     dirder = -(temp1 + temp2);
00121 
00122     \textcolor{comment}{/* compute the ratio of the actual to the predicted */}
00123     \textcolor{comment}{/* reduction. */}
00124     ratio = 0.;
00125     \textcolor{keywordflow}{if} (prered != 0.)
00126         ratio = actred / prered;
00127 
00128     \textcolor{comment}{/* update the step bound. */}
00129     \textcolor{keywordflow}{if} (ratio <= Scalar(.25)) \{
00130         \textcolor{keywordflow}{if} (actred >= 0.)
00131             temp = RealScalar(.5);
00132         \textcolor{keywordflow}{if} (actred < 0.)
00133             temp = RealScalar(.5) * dirder / (dirder + RealScalar(.5) * actred);
00134         \textcolor{keywordflow}{if} (RealScalar(.1) * fnorm1 >= m\_fnorm || temp < RealScalar(.1))
00135             temp = Scalar(.1);
00136         \textcolor{comment}{/* Computing MIN */}
00137         m\_delta = temp * (std::min)(m\_delta, pnorm / RealScalar(.1));
00138         m\_par /= temp;
00139     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!(m\_par != 0. && ratio < RealScalar(.75))) \{
00140         m\_delta = pnorm / RealScalar(.5);
00141         m\_par = RealScalar(.5) * m\_par;
00142     \}
00143 
00144     \textcolor{comment}{/* test for successful iteration. */}
00145     \textcolor{keywordflow}{if} (ratio >= RealScalar(1e-4)) \{
00146         \textcolor{comment}{/* successful iteration. update x, m\_fvec, and their norms. */}
00147         x = m\_wa2;
00148         m\_wa2 = m\_diag.cwiseProduct(x);
00149         m\_fvec = m\_wa4;
00150         xnorm = m\_wa2.stableNorm();
00151         m\_fnorm = fnorm1;
00152         ++m\_iter;
00153     \}
00154 
00155     \textcolor{comment}{/* tests for convergence. */}
00156     \textcolor{keywordflow}{if} (abs(actred) <= m\_ftol && prered <= m\_ftol && Scalar(.5) * ratio <= 1. && m\_delta <= m\_xtol * xnorm)
00157     \{
00158        m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00159       \textcolor{keywordflow}{return} LevenbergMarquardtSpace::RelativeErrorAndReductionTooSmall;
00160     \}
00161     \textcolor{keywordflow}{if} (abs(actred) <= m\_ftol && prered <= m\_ftol && Scalar(.5) * ratio <= 1.) 
00162     \{
00163       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00164       \textcolor{keywordflow}{return} LevenbergMarquardtSpace::RelativeReductionTooSmall;
00165     \}
00166     \textcolor{keywordflow}{if} (m\_delta <= m\_xtol * xnorm)
00167     \{
00168       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00169       \textcolor{keywordflow}{return} LevenbergMarquardtSpace::RelativeErrorTooSmall;
00170     \}
00171 
00172     \textcolor{comment}{/* tests for termination and stringent tolerances. */}
00173     \textcolor{keywordflow}{if} (m\_nfev >= m\_maxfev) 
00174     \{
00175       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence};
00176       \textcolor{keywordflow}{return} LevenbergMarquardtSpace::TooManyFunctionEvaluation;
00177     \}
00178     \textcolor{keywordflow}{if} (abs(actred) <= NumTraits<Scalar>::epsilon() && prered <= NumTraits<Scalar>::epsilon() && Scalar(.5)
       * ratio <= 1.)
00179     \{
00180       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00181       \textcolor{keywordflow}{return} LevenbergMarquardtSpace::FtolTooSmall;
00182     \}
00183     \textcolor{keywordflow}{if} (m\_delta <= NumTraits<Scalar>::epsilon() * xnorm) 
00184     \{
00185       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00186       \textcolor{keywordflow}{return} LevenbergMarquardtSpace::XtolTooSmall;
00187     \}
00188     \textcolor{keywordflow}{if} (m\_gnorm <= NumTraits<Scalar>::epsilon())
00189     \{
00190       m\_info = \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success};
00191       \textcolor{keywordflow}{return} LevenbergMarquardtSpace::GtolTooSmall;
00192     \}
00193 
00194   \} \textcolor{keywordflow}{while} (ratio < Scalar(1e-4));
00195 
00196   \textcolor{keywordflow}{return} LevenbergMarquardtSpace::Running;
00197 \}
00198 
00199   
00200 \} \textcolor{comment}{// end namespace Eigen}
00201 
00202 \textcolor{preprocessor}{#endif // EIGEN\_LMONESTEP\_H}
\end{DoxyCode}
