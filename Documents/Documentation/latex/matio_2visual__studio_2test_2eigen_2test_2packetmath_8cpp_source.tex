\hypertarget{matio_2visual__studio_2test_2eigen_2test_2packetmath_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/packetmath.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2packetmath_8cpp_source}\index{packetmath.\+cpp@{packetmath.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#include "main.h"}
00012 \textcolor{preprocessor}{#include "unsupported/Eigen/SpecialFunctions"}
00013 
00014 \textcolor{preprocessor}{#if defined \_\_GNUC\_\_ && \_\_GNUC\_\_>=6}
00015 \textcolor{preprocessor}{  #pragma GCC diagnostic ignored "-Wignored-attributes"}
00016 \textcolor{preprocessor}{#endif}
00017 \textcolor{comment}{// using namespace Eigen;}
00018 
00019 \textcolor{preprocessor}{#ifdef EIGEN\_VECTORIZE\_SSE}
00020 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} g\_vectorize\_sse = \textcolor{keyword}{true};
00021 \textcolor{preprocessor}{#else}
00022 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} g\_vectorize\_sse = \textcolor{keyword}{false};
00023 \textcolor{preprocessor}{#endif}
00024 
00025 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00026 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00027 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \hyperlink{group___sparse_core___module}{T} negate(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& x) \{ \textcolor{keywordflow}{return} -x; \}
00028 \}
00029 \}
00030 
00031 \textcolor{comment}{// NOTE: we disbale inlining for this function to workaround a GCC issue when using -O3 and the i387 FPU.}
00032 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> EIGEN\_DONT\_INLINE
00033 \textcolor{keywordtype}{bool} isApproxAbs(\textcolor{keyword}{const} Scalar& a, \textcolor{keyword}{const} Scalar& b, \textcolor{keyword}{const} \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real}& refvalue)
00034 \{
00035   \textcolor{keywordflow}{return} internal::isMuchSmallerThan(a-b, refvalue);
00036 \}
00037 
00038 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{bool} areApproxAbs(\textcolor{keyword}{const} Scalar* a, \textcolor{keyword}{const} Scalar* b, \textcolor{keywordtype}{int} size, \textcolor{keyword}{const} \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real}& refvalue)
00039 \{
00040   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00041   \{
00042     \textcolor{keywordflow}{if} (!isApproxAbs(a[i],b[i],refvalue))
00043     \{
00044       std::cout << \textcolor{stringliteral}{"ref: ["} << \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Matrix<Scalar,1,Dynamic>} >(a,
      size) << \textcolor{stringliteral}{"]"} << \textcolor{stringliteral}{" != vec: ["} << \hyperlink{group___core___module_class_eigen_1_1_map}{Map}<\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,1,Dynamic>} >(b,size) << \textcolor{stringliteral}{"]\(\backslash\)n
      "};
00045       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00046     \}
00047   \}
00048   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00049 \}
00050 
00051 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{bool} areApprox(\textcolor{keyword}{const} Scalar* a, \textcolor{keyword}{const} Scalar* b, \textcolor{keywordtype}{int} size)
00052 \{
00053   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00054   \{
00055     \textcolor{keywordflow}{if} (a[i]!=b[i] && !internal::isApprox(a[i],b[i]))
00056     \{
00057       std::cout << \textcolor{stringliteral}{"ref: ["} << \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const Matrix<Scalar,1,Dynamic>} >(a,
      size) << \textcolor{stringliteral}{"]"} << \textcolor{stringliteral}{" != vec: ["} << \hyperlink{group___core___module_class_eigen_1_1_map}{Map}<\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,1,Dynamic>} >(b,size) << \textcolor{stringliteral}{"]\(\backslash\)n
      "};
00058       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00059     \}
00060   \}
00061   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00062 \}
00063 
00064 \textcolor{preprocessor}{#define CHECK\_CWISE1(REFOP, POP) \{ \(\backslash\)}
00065 \textcolor{preprocessor}{  for (int i=0; i<PacketSize; ++i) \(\backslash\)}
00066 \textcolor{preprocessor}{    ref[i] = REFOP(data1[i]); \(\backslash\)}
00067 \textcolor{preprocessor}{  internal::pstore(data2, POP(internal::pload<Packet>(data1))); \(\backslash\)}
00068 \textcolor{preprocessor}{  VERIFY(areApprox(ref, data2, PacketSize) && #POP); \(\backslash\)}
00069 \textcolor{preprocessor}{\}}
00070 
00071 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Cond,\textcolor{keyword}{typename} Packet>
00072 \textcolor{keyword}{struct }\hyperlink{structpacket__helper}{packet\_helper}
00073 \{
00074   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00075   \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module}{Packet} load(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}* from)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::pload<Packet>(from); \}
00076 
00077   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00078   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} store(\hyperlink{group___sparse_core___module}{T}* to, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{Packet}& x)\textcolor{keyword}{ const }\{ internal::pstore(to,x); \}
00079 \};
00080 
00081 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00082 \textcolor{keyword}{struct }\hyperlink{structpacket__helper}{packet\_helper}<false,\hyperlink{group___sparse_core___module}{Packet}>
00083 \{
00084   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00085   \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module}{T} load(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}* from)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *from; \}
00086 
00087   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00088   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} store(\hyperlink{group___sparse_core___module}{T}* to, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& x)\textcolor{keyword}{ const }\{ *to = x; \}
00089 \};
00090 
00091 \textcolor{preprocessor}{#define CHECK\_CWISE1\_IF(COND, REFOP, POP) if(COND) \{ \(\backslash\)}
00092 \textcolor{preprocessor}{  packet\_helper<COND,Packet> h; \(\backslash\)}
00093 \textcolor{preprocessor}{  for (int i=0; i<PacketSize; ++i) \(\backslash\)}
00094 \textcolor{preprocessor}{    ref[i] = REFOP(data1[i]); \(\backslash\)}
00095 \textcolor{preprocessor}{  h.store(data2, POP(h.load(data1))); \(\backslash\)}
00096 \textcolor{preprocessor}{  VERIFY(areApprox(ref, data2, PacketSize) && #POP); \(\backslash\)}
00097 \textcolor{preprocessor}{\}}
00098 
00099 \textcolor{preprocessor}{#define CHECK\_CWISE2\_IF(COND, REFOP, POP) if(COND) \{ \(\backslash\)}
00100 \textcolor{preprocessor}{  packet\_helper<COND,Packet> h; \(\backslash\)}
00101 \textcolor{preprocessor}{  for (int i=0; i<PacketSize; ++i) \(\backslash\)}
00102 \textcolor{preprocessor}{    ref[i] = REFOP(data1[i], data1[i+PacketSize]); \(\backslash\)}
00103 \textcolor{preprocessor}{  h.store(data2, POP(h.load(data1),h.load(data1+PacketSize))); \(\backslash\)}
00104 \textcolor{preprocessor}{  VERIFY(areApprox(ref, data2, PacketSize) && #POP); \(\backslash\)}
00105 \textcolor{preprocessor}{\}}
00106 
00107 \textcolor{preprocessor}{#define REF\_ADD(a,b) ((a)+(b))}
00108 \textcolor{preprocessor}{#define REF\_SUB(a,b) ((a)-(b))}
00109 \textcolor{preprocessor}{#define REF\_MUL(a,b) ((a)*(b))}
00110 \textcolor{preprocessor}{#define REF\_DIV(a,b) ((a)/(b))}
00111 
00112 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} packetmath()
00113 \{
00114   \textcolor{keyword}{using} std::abs;
00115   \textcolor{keyword}{typedef} internal::packet\_traits<Scalar> PacketTraits;
00116   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketTraits::type \hyperlink{group___sparse_core___module}{Packet};
00117   \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = PacketTraits::size;
00118   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00119 
00120   \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_size = PacketSize > 4 ? PacketSize : 4;
00121   \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = PacketSize*max\_size;
00122   EIGEN\_ALIGN\_MAX Scalar data1[size];
00123   EIGEN\_ALIGN\_MAX Scalar data2[size];
00124   EIGEN\_ALIGN\_MAX Packet packets[PacketSize*2];
00125   EIGEN\_ALIGN\_MAX Scalar ref[size];
00126   RealScalar refvalue = 0;
00127   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00128   \{
00129     data1[i] = internal::random<Scalar>()/RealScalar(PacketSize);
00130     data2[i] = internal::random<Scalar>()/RealScalar(PacketSize);
00131     refvalue = (std::max)(refvalue,abs(data1[i]));
00132   \}
00133 
00134   internal::pstore(data2, internal::pload<Packet>(data1));
00135   VERIFY(areApprox(data1, data2, PacketSize) && \textcolor{stringliteral}{"aligned load/store"});
00136 
00137   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} offset=0; offset<PacketSize; ++offset)
00138   \{
00139     internal::pstore(data2, internal::ploadu<Packet>(data1+offset));
00140     VERIFY(areApprox(data1+offset, data2, PacketSize) && \textcolor{stringliteral}{"internal::ploadu"});
00141   \}
00142 
00143   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} offset=0; offset<PacketSize; ++offset)
00144   \{
00145     internal::pstoreu(data2+offset, internal::pload<Packet>(data1));
00146     VERIFY(areApprox(data1, data2+offset, PacketSize) && \textcolor{stringliteral}{"internal::pstoreu"});
00147   \}
00148 
00149   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} offset=0; offset<PacketSize; ++offset)
00150   \{
00151     packets[0] = internal::pload<Packet>(data1);
00152     packets[1] = internal::pload<Packet>(data1+PacketSize);
00153          \textcolor{keywordflow}{if} (offset==0) internal::palign<0>(packets[0], packets[1]);
00154     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==1) internal::palign<1>(packets[0], packets[1]);
00155     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==2) internal::palign<2>(packets[0], packets[1]);
00156     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==3) internal::palign<3>(packets[0], packets[1]);
00157     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==4) internal::palign<4>(packets[0], packets[1]);
00158     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==5) internal::palign<5>(packets[0], packets[1]);
00159     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==6) internal::palign<6>(packets[0], packets[1]);
00160     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==7) internal::palign<7>(packets[0], packets[1]);
00161     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==8) internal::palign<8>(packets[0], packets[1]);
00162     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==9) internal::palign<9>(packets[0], packets[1]);
00163     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==10) internal::palign<10>(packets[0], packets[1]);
00164     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==11) internal::palign<11>(packets[0], packets[1]);
00165     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==12) internal::palign<12>(packets[0], packets[1]);
00166     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==13) internal::palign<13>(packets[0], packets[1]);
00167     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==14) internal::palign<14>(packets[0], packets[1]);
00168     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (offset==15) internal::palign<15>(packets[0], packets[1]);
00169     internal::pstore(data2, packets[0]);
00170 
00171     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i)
00172       ref[i] = data1[i+offset];
00173 
00174     VERIFY(areApprox(ref, data2, PacketSize) && \textcolor{stringliteral}{"internal::palign"});
00175   \}
00176 
00177   VERIFY((!PacketTraits::Vectorizable) || PacketTraits::HasAdd);
00178   VERIFY((!PacketTraits::Vectorizable) || PacketTraits::HasSub);
00179   VERIFY((!PacketTraits::Vectorizable) || PacketTraits::HasMul);
00180   VERIFY((!PacketTraits::Vectorizable) || PacketTraits::HasNegate);
00181   VERIFY((internal::is\_same<Scalar,int>::value) || (!PacketTraits::Vectorizable) || PacketTraits::HasDiv);
00182 
00183   CHECK\_CWISE2\_IF(PacketTraits::HasAdd, REF\_ADD,  internal::padd);
00184   CHECK\_CWISE2\_IF(PacketTraits::HasSub, REF\_SUB,  internal::psub);
00185   CHECK\_CWISE2\_IF(PacketTraits::HasMul, REF\_MUL,  internal::pmul);
00186   CHECK\_CWISE2\_IF(PacketTraits::HasDiv, REF\_DIV, internal::pdiv);
00187 
00188   CHECK\_CWISE1(internal::negate, internal::pnegate);
00189   CHECK\_CWISE1(numext::conj, internal::pconj);
00190 
00191   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} offset=0;offset<3;++offset)
00192   \{
00193     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i)
00194       ref[i] = data1[offset];
00195     internal::pstore(data2, internal::pset1<Packet>(data1[offset]));
00196     VERIFY(areApprox(ref, data2, PacketSize) && \textcolor{stringliteral}{"internal::pset1"});
00197   \}
00198 
00199   \{
00200     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize*4; ++i)
00201       ref[i] = data1[i/PacketSize];
00202     Packet A0, A1, A2, A3;
00203     internal::pbroadcast4<Packet>(data1, A0, A1, A2, A3);
00204     internal::pstore(data2+0*PacketSize, A0);
00205     internal::pstore(data2+1*PacketSize, A1);
00206     internal::pstore(data2+2*PacketSize, A2);
00207     internal::pstore(data2+3*PacketSize, A3);
00208     VERIFY(areApprox(ref, data2, 4*PacketSize) && \textcolor{stringliteral}{"internal::pbroadcast4"});
00209   \}
00210 
00211   \{
00212     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize*2; ++i)
00213       ref[i] = data1[i/PacketSize];
00214     Packet A0, A1;
00215     internal::pbroadcast2<Packet>(data1, A0, A1);
00216     internal::pstore(data2+0*PacketSize, A0);
00217     internal::pstore(data2+1*PacketSize, A1);
00218     VERIFY(areApprox(ref, data2, 2*PacketSize) && \textcolor{stringliteral}{"internal::pbroadcast2"});
00219   \}
00220 
00221   VERIFY(internal::isApprox(data1[0], internal::pfirst(internal::pload<Packet>(data1))) && \textcolor{stringliteral}{"
      internal::pfirst"});
00222 
00223   \textcolor{keywordflow}{if}(PacketSize>1)
00224   \{
00225     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} offset=0;offset<4;++offset)
00226     \{
00227       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<PacketSize/2;++i)
00228         ref[2*i+0] = ref[2*i+1] = data1[offset+i];
00229       internal::pstore(data2,internal::ploaddup<Packet>(data1+offset));
00230       VERIFY(areApprox(ref, data2, PacketSize) && \textcolor{stringliteral}{"ploaddup"});
00231     \}
00232   \}
00233 
00234   \textcolor{keywordflow}{if}(PacketSize>2)
00235   \{
00236     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} offset=0;offset<4;++offset)
00237     \{
00238       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<PacketSize/4;++i)
00239         ref[4*i+0] = ref[4*i+1] = ref[4*i+2] = ref[4*i+3] = data1[offset+i];
00240       internal::pstore(data2,internal::ploadquad<Packet>(data1+offset));
00241       VERIFY(areApprox(ref, data2, PacketSize) && \textcolor{stringliteral}{"ploadquad"});
00242     \}
00243   \}
00244 
00245   ref[0] = 0;
00246   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i)
00247     ref[0] += data1[i];
00248   VERIFY(isApproxAbs(ref[0], internal::predux(internal::pload<Packet>(data1)), refvalue) && \textcolor{stringliteral}{"
      internal::predux"});
00249 
00250   \{
00251     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<4; ++i)
00252       ref[i] = 0;
00253     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i)
00254       ref[i%4] += data1[i];
00255     internal::pstore(data2, internal::predux\_downto4(internal::pload<Packet>(data1)));
00256     VERIFY(areApprox(ref, data2, PacketSize>4?PacketSize/2:PacketSize) && \textcolor{stringliteral}{"internal::predux\_downto4"});
00257   \}
00258 
00259   ref[0] = 1;
00260   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i)
00261     ref[0] *= data1[i];
00262   VERIFY(internal::isApprox(ref[0], internal::predux\_mul(internal::pload<Packet>(data1))) && \textcolor{stringliteral}{"
      internal::predux\_mul"});
00263 
00264   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<PacketSize; ++j)
00265   \{
00266     ref[j] = 0;
00267     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i)
00268       ref[j] += data1[i+j*PacketSize];
00269     packets[j] = internal::pload<Packet>(data1+j*PacketSize);
00270   \}
00271   internal::pstore(data2, internal::preduxp(packets));
00272   VERIFY(areApproxAbs(ref, data2, PacketSize, refvalue) && \textcolor{stringliteral}{"internal::preduxp"});
00273 
00274   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i)
00275     ref[i] = data1[PacketSize-i-1];
00276   internal::pstore(data2, internal::preverse(internal::pload<Packet>(data1)));
00277   VERIFY(areApprox(ref, data2, PacketSize) && \textcolor{stringliteral}{"internal::preverse"});
00278 
00279   internal::PacketBlock<Packet> kernel;
00280   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i) \{
00281     kernel.packet[i] = internal::pload<Packet>(data1+i*PacketSize);
00282   \}
00283   ptranspose(kernel);
00284   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i) \{
00285     internal::pstore(data2, kernel.packet[i]);
00286     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < PacketSize; ++j) \{
00287       VERIFY(isApproxAbs(data2[j], data1[i+j*PacketSize], refvalue) && \textcolor{stringliteral}{"ptranspose"});
00288     \}
00289   \}
00290 
00291   \textcolor{keywordflow}{if} (PacketTraits::HasBlend) \{
00292     Packet thenPacket = internal::pload<Packet>(data1);
00293     Packet elsePacket = internal::pload<Packet>(data2);
00294     EIGEN\_ALIGN\_MAX internal::Selector<PacketSize> selector;
00295     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00296       selector.select[i] = i;
00297     \}
00298 
00299     Packet blend = internal::pblend(selector, thenPacket, elsePacket);
00300     EIGEN\_ALIGN\_MAX Scalar result[size];
00301     internal::pstore(result, blend);
00302     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00303       VERIFY(isApproxAbs(result[i], (selector.select[i] ? data1[i] : data2[i]), refvalue));
00304     \}
00305   \}
00306 
00307   \textcolor{keywordflow}{if} (PacketTraits::HasBlend || g\_vectorize\_sse) \{
00308     \textcolor{comment}{// pinsertfirst}
00309     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i)
00310       ref[i] = data1[i];
00311     Scalar s = internal::random<Scalar>();
00312     ref[0] = s;
00313     internal::pstore(data2, internal::pinsertfirst(internal::pload<Packet>(data1),s));
00314     VERIFY(areApprox(ref, data2, PacketSize) && \textcolor{stringliteral}{"internal::pinsertfirst"});
00315   \}
00316 
00317   \textcolor{keywordflow}{if} (PacketTraits::HasBlend || g\_vectorize\_sse) \{
00318     \textcolor{comment}{// pinsertlast}
00319     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i)
00320       ref[i] = data1[i];
00321     Scalar s = internal::random<Scalar>();
00322     ref[PacketSize-1] = s;
00323     internal::pstore(data2, internal::pinsertlast(internal::pload<Packet>(data1),s));
00324     VERIFY(areApprox(ref, data2, PacketSize) && \textcolor{stringliteral}{"internal::pinsertlast"});
00325   \}
00326 \}
00327 
00328 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} packetmath\_real()
00329 \{
00330   \textcolor{keyword}{using} std::abs;
00331   \textcolor{keyword}{typedef} internal::packet\_traits<Scalar> PacketTraits;
00332   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketTraits::type Packet;
00333   \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = PacketTraits::size;
00334 
00335   \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = PacketSize*4;
00336   EIGEN\_ALIGN\_MAX Scalar data1[PacketTraits::size*4];
00337   EIGEN\_ALIGN\_MAX Scalar data2[PacketTraits::size*4];
00338   EIGEN\_ALIGN\_MAX Scalar ref[PacketTraits::size*4];
00339 
00340   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00341   \{
00342     data1[i] = internal::random<Scalar>(-1,1) * std::pow(Scalar(10), internal::random<Scalar>(-3,3));
00343     data2[i] = internal::random<Scalar>(-1,1) * std::pow(Scalar(10), internal::random<Scalar>(-3,3));
00344   \}
00345   CHECK\_CWISE1\_IF(PacketTraits::HasSin, std::sin, internal::psin);
00346   CHECK\_CWISE1\_IF(PacketTraits::HasCos, std::cos, internal::pcos);
00347   CHECK\_CWISE1\_IF(PacketTraits::HasTan, std::tan, internal::ptan);
00348 
00349   CHECK\_CWISE1\_IF(PacketTraits::HasRound, numext::round, internal::pround);
00350   CHECK\_CWISE1\_IF(PacketTraits::HasCeil, numext::ceil, internal::pceil);
00351   CHECK\_CWISE1\_IF(PacketTraits::HasFloor, numext::floor, internal::pfloor);
00352 
00353   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00354   \{
00355     data1[i] = internal::random<Scalar>(-1,1);
00356     data2[i] = internal::random<Scalar>(-1,1);
00357   \}
00358   CHECK\_CWISE1\_IF(PacketTraits::HasASin, std::asin, internal::pasin);
00359   CHECK\_CWISE1\_IF(PacketTraits::HasACos, std::acos, internal::pacos);
00360 
00361   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00362   \{
00363     data1[i] = internal::random<Scalar>(-87,88);
00364     data2[i] = internal::random<Scalar>(-87,88);
00365   \}
00366   CHECK\_CWISE1\_IF(PacketTraits::HasExp, std::exp, internal::pexp);
00367   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00368   \{
00369     data1[i] = internal::random<Scalar>(-1,1) * std::pow(Scalar(10), internal::random<Scalar>(-6,6));
00370     data2[i] = internal::random<Scalar>(-1,1) * std::pow(Scalar(10), internal::random<Scalar>(-6,6));
00371   \}
00372   CHECK\_CWISE1\_IF(PacketTraits::HasTanh, std::tanh, internal::ptanh);
00373   \textcolor{keywordflow}{if}(PacketTraits::HasExp && PacketTraits::size>=2)
00374   \{
00375     data1[0] = std::numeric\_limits<Scalar>::quiet\_NaN();
00376     data1[1] = std::numeric\_limits<Scalar>::epsilon();
00377     \hyperlink{structpacket__helper}{packet\_helper<PacketTraits::HasExp,Packet>} h;
00378     h.store(data2, internal::pexp(h.load(data1)));
00379     VERIFY((numext::isnan)(data2[0]));
00380     VERIFY\_IS\_EQUAL(std::exp(std::numeric\_limits<Scalar>::epsilon()), data2[1]);
00381 
00382     data1[0] = -std::numeric\_limits<Scalar>::epsilon();
00383     data1[1] = 0;
00384     h.store(data2, internal::pexp(h.load(data1)));
00385     VERIFY\_IS\_EQUAL(std::exp(-std::numeric\_limits<Scalar>::epsilon()), data2[0]);
00386     VERIFY\_IS\_EQUAL(std::exp(Scalar(0)), data2[1]);
00387 
00388     data1[0] = (std::numeric\_limits<Scalar>::min)();
00389     data1[1] = -(std::numeric\_limits<Scalar>::min)();
00390     h.store(data2, internal::pexp(h.load(data1)));
00391     VERIFY\_IS\_EQUAL(std::exp((std::numeric\_limits<Scalar>::min)()), data2[0]);
00392     VERIFY\_IS\_EQUAL(std::exp(-(std::numeric\_limits<Scalar>::min)()), data2[1]);
00393 
00394     data1[0] = std::numeric\_limits<Scalar>::denorm\_min();
00395     data1[1] = -std::numeric\_limits<Scalar>::denorm\_min();
00396     h.store(data2, internal::pexp(h.load(data1)));
00397     VERIFY\_IS\_EQUAL(std::exp(std::numeric\_limits<Scalar>::denorm\_min()), data2[0]);
00398     VERIFY\_IS\_EQUAL(std::exp(-std::numeric\_limits<Scalar>::denorm\_min()), data2[1]);
00399   \}
00400 
00401   \textcolor{keywordflow}{if} (PacketTraits::HasTanh) \{
00402     \textcolor{comment}{// NOTE this test migh fail with GCC prior to 6.3, see MathFunctionsImpl.h for details.}
00403     data1[0] = std::numeric\_limits<Scalar>::quiet\_NaN();
00404     \hyperlink{structpacket__helper}{packet\_helper<internal::packet\_traits<Scalar>::HasTanh}
      ,Packet> h;
00405     h.store(data2, internal::ptanh(h.load(data1)));
00406     VERIFY((numext::isnan)(data2[0]));
00407   \}
00408 
00409 \textcolor{preprocessor}{#if EIGEN\_HAS\_C99\_MATH}
00410   \{
00411     data1[0] = std::numeric\_limits<Scalar>::quiet\_NaN();
00412     \hyperlink{structpacket__helper}{packet\_helper<internal::packet\_traits<Scalar>::HasLGamma}
      ,Packet> h;
00413     h.store(data2, internal::plgamma(h.load(data1)));
00414     VERIFY((numext::isnan)(data2[0]));
00415   \}
00416   \{
00417     data1[0] = std::numeric\_limits<Scalar>::quiet\_NaN();
00418     \hyperlink{structpacket__helper}{packet\_helper<internal::packet\_traits<Scalar>::HasErf}
      ,Packet> h;
00419     h.store(data2, internal::perf(h.load(data1)));
00420     VERIFY((numext::isnan)(data2[0]));
00421   \}
00422   \{
00423     data1[0] = std::numeric\_limits<Scalar>::quiet\_NaN();
00424     \hyperlink{structpacket__helper}{packet\_helper<internal::packet\_traits<Scalar>::HasErfc}
      ,Packet> h;
00425     h.store(data2, internal::perfc(h.load(data1)));
00426     VERIFY((numext::isnan)(data2[0]));
00427   \}
00428 \textcolor{preprocessor}{#endif  // EIGEN\_HAS\_C99\_MATH}
00429 
00430   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00431   \{
00432     data1[i] = internal::random<Scalar>(0,1) * std::pow(Scalar(10), internal::random<Scalar>(-6,6));
00433     data2[i] = internal::random<Scalar>(0,1) * std::pow(Scalar(10), internal::random<Scalar>(-6,6));
00434   \}
00435 
00436   \textcolor{keywordflow}{if}(internal::random<float>(0,1)<0.1f)
00437     data1[internal::random<int>(0, PacketSize)] = 0;
00438   CHECK\_CWISE1\_IF(PacketTraits::HasSqrt, std::sqrt, internal::psqrt);
00439   CHECK\_CWISE1\_IF(PacketTraits::HasLog, std::log, internal::plog);
00440 \textcolor{preprocessor}{#if EIGEN\_HAS\_C99\_MATH && (\_\_cplusplus > 199711L)}
00441   CHECK\_CWISE1\_IF(PacketTraits::HasLog1p, std::log1p, internal::plog1p);
00442   CHECK\_CWISE1\_IF(internal::packet\_traits<Scalar>::HasLGamma, std::lgamma, internal::plgamma);
00443   CHECK\_CWISE1\_IF(internal::packet\_traits<Scalar>::HasErf, std::erf, internal::perf);
00444   CHECK\_CWISE1\_IF(internal::packet\_traits<Scalar>::HasErfc, std::erfc, internal::perfc);
00445 \textcolor{preprocessor}{#endif}
00446 
00447   \textcolor{keywordflow}{if}(PacketTraits::HasLog && PacketTraits::size>=2)
00448   \{
00449     data1[0] = std::numeric\_limits<Scalar>::quiet\_NaN();
00450     data1[1] = std::numeric\_limits<Scalar>::epsilon();
00451     \hyperlink{structpacket__helper}{packet\_helper<PacketTraits::HasLog,Packet>} h;
00452     h.store(data2, internal::plog(h.load(data1)));
00453     VERIFY((numext::isnan)(data2[0]));
00454     VERIFY\_IS\_EQUAL(std::log(std::numeric\_limits<Scalar>::epsilon()), data2[1]);
00455 
00456     data1[0] = -std::numeric\_limits<Scalar>::epsilon();
00457     data1[1] = 0;
00458     h.store(data2, internal::plog(h.load(data1)));
00459     VERIFY((numext::isnan)(data2[0]));
00460     VERIFY\_IS\_EQUAL(std::log(Scalar(0)), data2[1]);
00461 
00462     data1[0] = (std::numeric\_limits<Scalar>::min)();
00463     data1[1] = -(std::numeric\_limits<Scalar>::min)();
00464     h.store(data2, internal::plog(h.load(data1)));
00465     VERIFY\_IS\_EQUAL(std::log((std::numeric\_limits<Scalar>::min)()), data2[0]);
00466     VERIFY((numext::isnan)(data2[1]));
00467 
00468     data1[0] = std::numeric\_limits<Scalar>::denorm\_min();
00469     data1[1] = -std::numeric\_limits<Scalar>::denorm\_min();
00470     h.store(data2, internal::plog(h.load(data1)));
00471     \textcolor{comment}{// VERIFY\_IS\_EQUAL(std::log(std::numeric\_limits<Scalar>::denorm\_min()), data2[0]);}
00472     VERIFY((numext::isnan)(data2[1]));
00473 
00474     data1[0] = Scalar(-1.0f);
00475     h.store(data2, internal::plog(h.load(data1)));
00476     VERIFY((numext::isnan)(data2[0]));
00477     h.store(data2, internal::psqrt(h.load(data1)));
00478     VERIFY((numext::isnan)(data2[0]));
00479     VERIFY((numext::isnan)(data2[1]));
00480   \}
00481 \}
00482 
00483 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} packetmath\_notcomplex()
00484 \{
00485   \textcolor{keyword}{using} std::abs;
00486   \textcolor{keyword}{typedef} internal::packet\_traits<Scalar> PacketTraits;
00487   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketTraits::type Packet;
00488   \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = PacketTraits::size;
00489 
00490   EIGEN\_ALIGN\_MAX Scalar data1[PacketTraits::size*4];
00491   EIGEN\_ALIGN\_MAX Scalar data2[PacketTraits::size*4];
00492   EIGEN\_ALIGN\_MAX Scalar ref[PacketTraits::size*4];
00493 
00494   \hyperlink{group___core___module_class_eigen_1_1_array}{Array<Scalar,Dynamic,1>::Map}(data1, PacketTraits::size*4).
      \hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}();
00495 
00496   ref[0] = data1[0];
00497   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i)
00498     ref[0] = (std::min)(ref[0],data1[i]);
00499   VERIFY(internal::isApprox(ref[0], internal::predux\_min(internal::pload<Packet>(data1))) && \textcolor{stringliteral}{"
      internal::predux\_min"});
00500 
00501   VERIFY((!PacketTraits::Vectorizable) || PacketTraits::HasMin);
00502   VERIFY((!PacketTraits::Vectorizable) || PacketTraits::HasMax);
00503 
00504   CHECK\_CWISE2\_IF(PacketTraits::HasMin, (std::min), internal::pmin);
00505   CHECK\_CWISE2\_IF(PacketTraits::HasMax, (std::max), internal::pmax);
00506   CHECK\_CWISE1(abs, internal::pabs);
00507 
00508   ref[0] = data1[0];
00509   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i)
00510     ref[0] = (std::max)(ref[0],data1[i]);
00511   VERIFY(internal::isApprox(ref[0], internal::predux\_max(internal::pload<Packet>(data1))) && \textcolor{stringliteral}{"
      internal::predux\_max"});
00512 
00513   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i)
00514     ref[i] = data1[0]+Scalar(i);
00515   internal::pstore(data2, internal::plset<Packet>(data1[0]));
00516   VERIFY(areApprox(ref, data2, PacketSize) && \textcolor{stringliteral}{"internal::plset"});
00517 \}
00518 
00519 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar,\textcolor{keywordtype}{bool} ConjLhs,\textcolor{keywordtype}{bool} ConjRhs> \textcolor{keywordtype}{void} test\_conj\_helper(Scalar* data1, Scalar* data2, 
      Scalar* ref, Scalar* pval)
00520 \{
00521   \textcolor{keyword}{typedef} internal::packet\_traits<Scalar> PacketTraits;
00522   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketTraits::type Packet;
00523   \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = PacketTraits::size;
00524 
00525   internal::conj\_if<ConjLhs> cj0;
00526   internal::conj\_if<ConjRhs> cj1;
00527   internal::conj\_helper<Scalar,Scalar,ConjLhs,ConjRhs> cj;
00528   internal::conj\_helper<Packet,Packet,ConjLhs,ConjRhs> pcj;
00529 
00530   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<PacketSize;++i)
00531   \{
00532     ref[i] = cj0(data1[i]) * cj1(data2[i]);
00533     VERIFY(internal::isApprox(ref[i], cj.pmul(data1[i],data2[i])) && \textcolor{stringliteral}{"conj\_helper pmul"});
00534   \}
00535   internal::pstore(pval,pcj.pmul(internal::pload<Packet>(data1),internal::pload<Packet>(data2)));
00536   VERIFY(areApprox(ref, pval, PacketSize) && \textcolor{stringliteral}{"conj\_helper pmul"});
00537 
00538   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<PacketSize;++i)
00539   \{
00540     Scalar tmp = ref[i];
00541     ref[i] += cj0(data1[i]) * cj1(data2[i]);
00542     VERIFY(internal::isApprox(ref[i], cj.pmadd(data1[i],data2[i],tmp)) && \textcolor{stringliteral}{"conj\_helper pmadd"});
00543   \}
00544   internal::pstore(pval,pcj.pmadd(internal::pload<Packet>(data1),internal::pload<Packet>(data2),
      internal::pload<Packet>(pval)));
00545   VERIFY(areApprox(ref, pval, PacketSize) && \textcolor{stringliteral}{"conj\_helper pmadd"});
00546 \}
00547 
00548 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} packetmath\_complex()
00549 \{
00550   \textcolor{keyword}{typedef} internal::packet\_traits<Scalar> PacketTraits;
00551   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketTraits::type Packet;
00552   \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = PacketTraits::size;
00553 
00554   \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = PacketSize*4;
00555   EIGEN\_ALIGN\_MAX Scalar data1[PacketSize*4];
00556   EIGEN\_ALIGN\_MAX Scalar data2[PacketSize*4];
00557   EIGEN\_ALIGN\_MAX Scalar ref[PacketSize*4];
00558   EIGEN\_ALIGN\_MAX Scalar pval[PacketSize*4];
00559 
00560   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<size; ++i)
00561   \{
00562     data1[i] = internal::random<Scalar>() * Scalar(1e2);
00563     data2[i] = internal::random<Scalar>() * Scalar(1e2);
00564   \}
00565 
00566   test\_conj\_helper<Scalar,false,false> (data1,data2,ref,pval);
00567   test\_conj\_helper<Scalar,false,true>  (data1,data2,ref,pval);
00568   test\_conj\_helper<Scalar,true,false>  (data1,data2,ref,pval);
00569   test\_conj\_helper<Scalar,true,true>   (data1,data2,ref,pval);
00570 
00571   \{
00572     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<PacketSize;++i)
00573       ref[i] = Scalar(std::imag(data1[i]),std::real(data1[i]));
00574     internal::pstore(pval,internal::pcplxflip(internal::pload<Packet>(data1)));
00575     VERIFY(areApprox(ref, pval, PacketSize) && \textcolor{stringliteral}{"pcplxflip"});
00576   \}
00577 \}
00578 
00579 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keywordtype}{void} packetmath\_scatter\_gather()
00580 \{
00581   \textcolor{keyword}{typedef} internal::packet\_traits<Scalar> PacketTraits;
00582   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PacketTraits::type Packet;
00583   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} RealScalar;
00584   \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = PacketTraits::size;
00585   EIGEN\_ALIGN\_MAX Scalar data1[PacketSize];
00586   RealScalar refvalue = 0;
00587   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize; ++i) \{
00588     data1[i] = internal::random<Scalar>()/RealScalar(PacketSize);
00589   \}
00590 
00591   \textcolor{keywordtype}{int} stride = internal::random<int>(1,20);
00592 
00593   EIGEN\_ALIGN\_MAX Scalar buffer[PacketSize*20];
00594   memset(buffer, 0, 20*PacketSize*\textcolor{keyword}{sizeof}(Scalar));
00595   Packet packet = internal::pload<Packet>(data1);
00596   internal::pscatter<Scalar, Packet>(buffer, packet, stride);
00597 
00598   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize*20; ++i) \{
00599     \textcolor{keywordflow}{if} ((i%stride) == 0 && i<stride*PacketSize) \{
00600       VERIFY(isApproxAbs(buffer[i], data1[i/stride], refvalue) && \textcolor{stringliteral}{"pscatter"});
00601     \} \textcolor{keywordflow}{else} \{
00602       VERIFY(isApproxAbs(buffer[i], Scalar(0), refvalue) && \textcolor{stringliteral}{"pscatter"});
00603     \}
00604   \}
00605 
00606   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<PacketSize*7; ++i) \{
00607     buffer[i] = internal::random<Scalar>()/RealScalar(PacketSize);
00608   \}
00609   packet = internal::pgather<Scalar, Packet>(buffer, 7);
00610   internal::pstore(data1, packet);
00611   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00612     VERIFY(isApproxAbs(data1[i], buffer[i*7], refvalue) && \textcolor{stringliteral}{"pgather"});
00613   \}
00614 \}
00615 
00616 \textcolor{keywordtype}{void} test\_packetmath()
00617 \{
00618   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00619     CALL\_SUBTEST\_1( packetmath<float>() );
00620     CALL\_SUBTEST\_2( packetmath<double>() );
00621     CALL\_SUBTEST\_3( packetmath<int>() );
00622     CALL\_SUBTEST\_4( packetmath<std::complex<float> >() );
00623     CALL\_SUBTEST\_5( packetmath<std::complex<double> >() );
00624 
00625     CALL\_SUBTEST\_1( packetmath\_notcomplex<float>() );
00626     CALL\_SUBTEST\_2( packetmath\_notcomplex<double>() );
00627     CALL\_SUBTEST\_3( packetmath\_notcomplex<int>() );
00628 
00629     CALL\_SUBTEST\_1( packetmath\_real<float>() );
00630     CALL\_SUBTEST\_2( packetmath\_real<double>() );
00631 
00632     CALL\_SUBTEST\_4( packetmath\_complex<std::complex<float> >() );
00633     CALL\_SUBTEST\_5( packetmath\_complex<std::complex<double> >() );
00634 
00635     CALL\_SUBTEST\_1( packetmath\_scatter\_gather<float>() );
00636     CALL\_SUBTEST\_2( packetmath\_scatter\_gather<double>() );
00637     CALL\_SUBTEST\_3( packetmath\_scatter\_gather<int>() );
00638     CALL\_SUBTEST\_4( packetmath\_scatter\_gather<std::complex<float> >() );
00639     CALL\_SUBTEST\_5( packetmath\_scatter\_gather<std::complex<double> >() );
00640   \}
00641 \}
\end{DoxyCode}
