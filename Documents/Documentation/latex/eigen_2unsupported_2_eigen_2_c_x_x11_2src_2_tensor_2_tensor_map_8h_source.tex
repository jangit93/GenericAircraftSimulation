\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_map_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Map.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_map_8h_source}\index{Tensor\+Map.\+h@{Tensor\+Map.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_MAP\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_MAP\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00021 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PlainObjectType, \textcolor{keywordtype}{int} Options\_, \textcolor{keyword}{template} <\textcolor{keyword}{class}> \textcolor{keyword}{class }MakePointer\_> \textcolor{keyword}{class }TensorMap : \textcolor{keyword}{
      public} TensorBase<TensorMap<PlainObjectType, Options\_, MakePointer\_> >
00028 \{
00029   \textcolor{keyword}{public}:
00030     \textcolor{keyword}{typedef} TensorMap<PlainObjectType, Options\_, MakePointer\_> Self;
00031     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PlainObjectType::Base Base;
00032     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<Self>::type} Nested;
00033     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<PlainObjectType>::StorageKind StorageKind;
00034     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<PlainObjectType>::Index Index;
00035     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::traits<PlainObjectType>::Scalar Scalar;
00036     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<Scalar>::Real RealScalar;
00037     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::CoeffReturnType CoeffReturnType;
00038 
00039   \textcolor{comment}{/*    typedef typename internal::conditional<}
00040 \textcolor{comment}{                         bool(internal::is\_lvalue<PlainObjectType>::value),}
00041 \textcolor{comment}{                         Scalar *,}
00042 \textcolor{comment}{                         const Scalar *>::type}
00043 \textcolor{comment}{                     PointerType;*/}
00044     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MakePointer\_<Scalar>::Type PointerType;
00045     \textcolor{keyword}{typedef} PointerType PointerArgType;
00046 
00047     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Options = Options\_;
00048 
00049     \textcolor{keyword}{static} \textcolor{keyword}{const} Index NumIndices = PlainObjectType::NumIndices;
00050     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} PlainObjectType::Dimensions Dimensions;
00051 
00052     \textcolor{keyword}{enum} \{
00053       IsAligned = ((int(Options\_)&\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned})==\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}),
00054       Layout = PlainObjectType::Layout,
00055       CoordAccess = \textcolor{keyword}{true},
00056       RawAccess = \textcolor{keyword}{true}
00057     \};
00058 
00059     EIGEN\_DEVICE\_FUNC
00060     EIGEN\_STRONG\_INLINE TensorMap(PointerArgType dataPtr) : m\_data(dataPtr), m\_dimensions() \{
00061       \textcolor{comment}{// The number of dimensions used to construct a tensor must be equal to the rank of the tensor.}
00062       EIGEN\_STATIC\_ASSERT((0 == NumIndices || NumIndices == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE
      )
00063     \}
00064 
00065 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00066     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes> EIGEN\_DEVICE\_FUNC
00067     EIGEN\_STRONG\_INLINE TensorMap(PointerArgType dataPtr, Index firstDimension, IndexTypes... 
      otherDimensions) : m\_data(dataPtr), m\_dimensions(firstDimension, otherDimensions...) \{
00068       \textcolor{comment}{// The number of dimensions used to construct a tensor must be equal to the rank of the tensor.}
00069       EIGEN\_STATIC\_ASSERT((\textcolor{keyword}{sizeof}...(otherDimensions) + 1 == NumIndices || NumIndices == 
      \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00070     \}
00071 \textcolor{preprocessor}{#else}
00072     EIGEN\_DEVICE\_FUNC
00073     EIGEN\_STRONG\_INLINE TensorMap(PointerArgType dataPtr, Index firstDimension) : m\_data(dataPtr), 
      m\_dimensions(firstDimension) \{
00074       \textcolor{comment}{// The number of dimensions used to construct a tensor must be equal to the rank of the tensor.}
00075       EIGEN\_STATIC\_ASSERT((1 == NumIndices || NumIndices == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE
      )
00076     \}
00077     EIGEN\_DEVICE\_FUNC
00078     EIGEN\_STRONG\_INLINE TensorMap(PointerArgType dataPtr, Index dim1, Index dim2) : m\_data(dataPtr), 
      m\_dimensions(dim1, dim2) \{
00079       EIGEN\_STATIC\_ASSERT(2 == NumIndices || NumIndices == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00080     \}
00081     EIGEN\_DEVICE\_FUNC
00082     EIGEN\_STRONG\_INLINE TensorMap(PointerArgType dataPtr, Index dim1, Index dim2, Index dim3) : m\_data(
      dataPtr), m\_dimensions(dim1, dim2, dim3) \{
00083       EIGEN\_STATIC\_ASSERT(3 == NumIndices || NumIndices == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00084     \}
00085     EIGEN\_DEVICE\_FUNC
00086     EIGEN\_STRONG\_INLINE TensorMap(PointerArgType dataPtr, Index dim1, Index dim2, Index dim3, Index dim4) :
       m\_data(dataPtr), m\_dimensions(dim1, dim2, dim3, dim4) \{
00087       EIGEN\_STATIC\_ASSERT(4 == NumIndices || NumIndices == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00088     \}
00089     EIGEN\_DEVICE\_FUNC
00090     EIGEN\_STRONG\_INLINE TensorMap(PointerArgType dataPtr, Index dim1, Index dim2, Index dim3, Index dim4, 
      Index dim5) : m\_data(dataPtr), m\_dimensions(dim1, dim2, dim3, dim4, dim5) \{
00091       EIGEN\_STATIC\_ASSERT(5 == NumIndices || NumIndices == \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00092     \}
00093 \textcolor{preprocessor}{#endif}
00094 
00095    EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorMap(PointerArgType dataPtr, \textcolor{keyword}{const} array<Index, NumIndices>& 
      dimensions)
00096       : m\_data(dataPtr), m\_dimensions(dimensions)
00097     \{ \}
00098 
00099     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Dimensions>
00100     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorMap(PointerArgType dataPtr, \textcolor{keyword}{const} Dimensions& dimensions)
00101       : m\_data(dataPtr), m\_dimensions(dimensions)
00102     \{ \}
00103 
00104     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorMap(PlainObjectType& tensor)
00105       : m\_data(tensor.data()), m\_dimensions(tensor.dimensions())
00106     \{ \}
00107 
00108     EIGEN\_DEVICE\_FUNC
00109     EIGEN\_STRONG\_INLINE Index rank()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions.rank(); \}
00110     EIGEN\_DEVICE\_FUNC
00111     EIGEN\_STRONG\_INLINE Index dimension(Index n)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions[n]; \}
00112     EIGEN\_DEVICE\_FUNC
00113     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00114     EIGEN\_DEVICE\_FUNC
00115     EIGEN\_STRONG\_INLINE Index size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions.TotalSize(); \}
00116     EIGEN\_DEVICE\_FUNC
00117     EIGEN\_STRONG\_INLINE PointerType data() \{ \textcolor{keywordflow}{return} m\_data; \}
00118     EIGEN\_DEVICE\_FUNC
00119     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} PointerType data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data; \}
00120 
00121     EIGEN\_DEVICE\_FUNC
00122     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(\textcolor{keyword}{const} array<Index, NumIndices>& indices)\textcolor{keyword}{ const}
00123 \textcolor{keyword}{    }\{
00124       \textcolor{comment}{//      eigen\_assert(checkIndexRange(indices));}
00125       \textcolor{keywordflow}{if} (PlainObjectType::Options&\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}) \{
00126         \textcolor{keyword}{const} Index index = m\_dimensions.IndexOfRowMajor(indices);
00127         \textcolor{keywordflow}{return} m\_data[index];
00128       \} \textcolor{keywordflow}{else} \{
00129         \textcolor{keyword}{const} Index index = m\_dimensions.IndexOfColMajor(indices);
00130         \textcolor{keywordflow}{return} m\_data[index];
00131       \}
00132     \}
00133 
00134     EIGEN\_DEVICE\_FUNC
00135     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()()\textcolor{keyword}{ const}
00136 \textcolor{keyword}{    }\{
00137       EIGEN\_STATIC\_ASSERT(NumIndices == 0, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00138       \textcolor{keywordflow}{return} m\_data[0];
00139     \}
00140 
00141     EIGEN\_DEVICE\_FUNC
00142     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index index)\textcolor{keyword}{ const}
00143 \textcolor{keyword}{    }\{
00144       eigen\_internal\_assert(index >= 0 && index < size());
00145       \textcolor{keywordflow}{return} m\_data[index];
00146     \}
00147 
00148 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00149     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes> EIGEN\_DEVICE\_FUNC
00150     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index firstIndex, Index secondIndex, IndexTypes... 
      otherIndices)\textcolor{keyword}{ const}
00151 \textcolor{keyword}{    }\{
00152       EIGEN\_STATIC\_ASSERT(\textcolor{keyword}{sizeof}...(otherIndices) + 2 == NumIndices, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00153       \textcolor{keywordflow}{if} (PlainObjectType::Options&RowMajor) \{
00154         \textcolor{keyword}{const} Index index = m\_dimensions.IndexOfRowMajor(array<Index, NumIndices>\{\{firstIndex, secondIndex,
       otherIndices...\}\});
00155         \textcolor{keywordflow}{return} m\_data[index];
00156       \} \textcolor{keywordflow}{else} \{
00157         \textcolor{keyword}{const} Index index = m\_dimensions.IndexOfColMajor(array<Index, NumIndices>\{\{firstIndex, secondIndex,
       otherIndices...\}\});
00158         \textcolor{keywordflow}{return} m\_data[index];
00159       \}
00160     \}
00161 \textcolor{preprocessor}{#else}
00162     EIGEN\_DEVICE\_FUNC
00163     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index i0, Index i1)\textcolor{keyword}{ const}
00164 \textcolor{keyword}{    }\{
00165       \textcolor{keywordflow}{if} (PlainObjectType::Options&RowMajor) \{
00166         \textcolor{keyword}{const} Index index = i1 + i0 * m\_dimensions[1];
00167         \textcolor{keywordflow}{return} m\_data[index];
00168       \} \textcolor{keywordflow}{else} \{
00169         \textcolor{keyword}{const} Index index = i0 + i1 * m\_dimensions[0];
00170         \textcolor{keywordflow}{return} m\_data[index];
00171       \}
00172     \}
00173     EIGEN\_DEVICE\_FUNC
00174     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index i0, Index i1, Index i2)\textcolor{keyword}{ const}
00175 \textcolor{keyword}{    }\{
00176       \textcolor{keywordflow}{if} (PlainObjectType::Options&RowMajor) \{
00177          \textcolor{keyword}{const} Index index = i2 + m\_dimensions[2] * (i1 + m\_dimensions[1] * i0);
00178          \textcolor{keywordflow}{return} m\_data[index];
00179       \} \textcolor{keywordflow}{else} \{
00180          \textcolor{keyword}{const} Index index = i0 + m\_dimensions[0] * (i1 + m\_dimensions[1] * i2);
00181         \textcolor{keywordflow}{return} m\_data[index];
00182       \}
00183     \}
00184     EIGEN\_DEVICE\_FUNC
00185     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index i0, Index i1, Index i2, Index i3)\textcolor{keyword}{ const}
00186 \textcolor{keyword}{    }\{
00187       \textcolor{keywordflow}{if} (PlainObjectType::Options&RowMajor) \{
00188         \textcolor{keyword}{const} Index index = i3 + m\_dimensions[3] * (i2 + m\_dimensions[2] * (i1 + m\_dimensions[1] * i0));
00189         \textcolor{keywordflow}{return} m\_data[index];
00190       \} \textcolor{keywordflow}{else} \{
00191         \textcolor{keyword}{const} Index index = i0 + m\_dimensions[0] * (i1 + m\_dimensions[1] * (i2 + m\_dimensions[2] * i3));
00192         \textcolor{keywordflow}{return} m\_data[index];
00193       \}
00194     \}
00195     EIGEN\_DEVICE\_FUNC
00196     EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Scalar& operator()(Index i0, Index i1, Index i2, Index i3, Index i4)\textcolor{keyword}{ const}
00197 \textcolor{keyword}{    }\{
00198       \textcolor{keywordflow}{if} (PlainObjectType::Options&RowMajor) \{
00199         \textcolor{keyword}{const} Index index = i4 + m\_dimensions[4] * (i3 + m\_dimensions[3] * (i2 + m\_dimensions[2] * (i1 + 
      m\_dimensions[1] * i0)));
00200         \textcolor{keywordflow}{return} m\_data[index];
00201       \} \textcolor{keywordflow}{else} \{
00202         \textcolor{keyword}{const} Index index = i0 + m\_dimensions[0] * (i1 + m\_dimensions[1] * (i2 + m\_dimensions[2] * (i3 + 
      m\_dimensions[3] * i4)));
00203         \textcolor{keywordflow}{return} m\_data[index];
00204       \}
00205     \}
00206 \textcolor{preprocessor}{#endif}
00207 
00208     EIGEN\_DEVICE\_FUNC
00209     EIGEN\_STRONG\_INLINE Scalar& operator()(\textcolor{keyword}{const} array<Index, NumIndices>& indices)
00210     \{
00211       \textcolor{comment}{//      eigen\_assert(checkIndexRange(indices));}
00212       \textcolor{keywordflow}{if} (PlainObjectType::Options&RowMajor) \{
00213         \textcolor{keyword}{const} Index index = m\_dimensions.IndexOfRowMajor(indices);
00214         \textcolor{keywordflow}{return} m\_data[index];
00215       \} \textcolor{keywordflow}{else} \{
00216         \textcolor{keyword}{const} Index index = m\_dimensions.IndexOfColMajor(indices);
00217         \textcolor{keywordflow}{return} m\_data[index];
00218       \}
00219     \}
00220 
00221     EIGEN\_DEVICE\_FUNC
00222     EIGEN\_STRONG\_INLINE Scalar& operator()()
00223     \{
00224       EIGEN\_STATIC\_ASSERT(NumIndices == 0, YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00225       \textcolor{keywordflow}{return} m\_data[0];
00226     \}
00227 
00228     EIGEN\_DEVICE\_FUNC
00229     EIGEN\_STRONG\_INLINE Scalar& operator()(Index index)
00230     \{
00231       eigen\_internal\_assert(index >= 0 && index < size());
00232       \textcolor{keywordflow}{return} m\_data[index];
00233     \}
00234 
00235 \textcolor{preprocessor}{#if EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00236     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... IndexTypes> EIGEN\_DEVICE\_FUNC
00237     EIGEN\_STRONG\_INLINE Scalar& operator()(Index firstIndex, Index secondIndex, IndexTypes... otherIndices)
00238     \{
00239       static\_assert(\textcolor{keyword}{sizeof}...(otherIndices) + 2 == NumIndices || NumIndices == 
      \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, \textcolor{stringliteral}{"Number of indices used to access a tensor coefficient must be equal to the rank of the
       tensor."});
00240       \textcolor{keyword}{const} std::size\_t NumDims = \textcolor{keyword}{sizeof}...(otherIndices) + 2;
00241       \textcolor{keywordflow}{if} (PlainObjectType::Options&RowMajor) \{
00242         \textcolor{keyword}{const} Index index = m\_dimensions.IndexOfRowMajor(array<Index, NumDims>\{\{firstIndex, secondIndex, 
      otherIndices...\}\});
00243         \textcolor{keywordflow}{return} m\_data[index];
00244       \} \textcolor{keywordflow}{else} \{
00245         \textcolor{keyword}{const} Index index = m\_dimensions.IndexOfColMajor(array<Index, NumDims>\{\{firstIndex, secondIndex, 
      otherIndices...\}\});
00246         \textcolor{keywordflow}{return} m\_data[index];
00247       \}
00248     \}
00249 \textcolor{preprocessor}{#else}
00250     EIGEN\_DEVICE\_FUNC
00251     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1)
00252     \{
00253        \textcolor{keywordflow}{if} (PlainObjectType::Options&RowMajor) \{
00254          \textcolor{keyword}{const} Index index = i1 + i0 * m\_dimensions[1];
00255         \textcolor{keywordflow}{return} m\_data[index];
00256       \} \textcolor{keywordflow}{else} \{
00257         \textcolor{keyword}{const} Index index = i0 + i1 * m\_dimensions[0];
00258         \textcolor{keywordflow}{return} m\_data[index];
00259       \}
00260     \}
00261     EIGEN\_DEVICE\_FUNC
00262     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1, Index i2)
00263     \{
00264        \textcolor{keywordflow}{if} (PlainObjectType::Options&RowMajor) \{
00265          \textcolor{keyword}{const} Index index = i2 + m\_dimensions[2] * (i1 + m\_dimensions[1] * i0);
00266         \textcolor{keywordflow}{return} m\_data[index];
00267       \} \textcolor{keywordflow}{else} \{
00268          \textcolor{keyword}{const} Index index = i0 + m\_dimensions[0] * (i1 + m\_dimensions[1] * i2);
00269         \textcolor{keywordflow}{return} m\_data[index];
00270       \}
00271     \}
00272     EIGEN\_DEVICE\_FUNC
00273     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3)
00274     \{
00275       \textcolor{keywordflow}{if} (PlainObjectType::Options&RowMajor) \{
00276         \textcolor{keyword}{const} Index index = i3 + m\_dimensions[3] * (i2 + m\_dimensions[2] * (i1 + m\_dimensions[1] * i0));
00277         \textcolor{keywordflow}{return} m\_data[index];
00278       \} \textcolor{keywordflow}{else} \{
00279         \textcolor{keyword}{const} Index index = i0 + m\_dimensions[0] * (i1 + m\_dimensions[1] * (i2 + m\_dimensions[2] * i3));
00280         \textcolor{keywordflow}{return} m\_data[index];
00281       \}
00282     \}
00283     EIGEN\_DEVICE\_FUNC
00284     EIGEN\_STRONG\_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3, Index i4)
00285     \{
00286       \textcolor{keywordflow}{if} (PlainObjectType::Options&RowMajor) \{
00287         \textcolor{keyword}{const} Index index = i4 + m\_dimensions[4] * (i3 + m\_dimensions[3] * (i2 + m\_dimensions[2] * (i1 + 
      m\_dimensions[1] * i0)));
00288         \textcolor{keywordflow}{return} m\_data[index];
00289       \} \textcolor{keywordflow}{else} \{
00290         \textcolor{keyword}{const} Index index = i0 + m\_dimensions[0] * (i1 + m\_dimensions[1] * (i2 + m\_dimensions[2] * (i3 + 
      m\_dimensions[3] * i4)));
00291         \textcolor{keywordflow}{return} m\_data[index];
00292       \}
00293     \}
00294 \textcolor{preprocessor}{#endif}
00295 
00296     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Self& operator=(\textcolor{keyword}{const} Self& other)
00297     \{
00298       \textcolor{keyword}{typedef} TensorAssignOp<Self, const Self> Assign;
00299       Assign assign(*\textcolor{keyword}{this}, other);
00300       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00301       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00302     \}
00303 
00304     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00305     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00306     Self& operator=(\textcolor{keyword}{const} OtherDerived& other)
00307     \{
00308       \textcolor{keyword}{typedef} TensorAssignOp<Self, const OtherDerived> Assign;
00309       Assign assign(*\textcolor{keyword}{this}, other);
00310       internal::TensorExecutor<const Assign, DefaultDevice>::run(assign, DefaultDevice());
00311       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00312     \}
00313 
00314   \textcolor{keyword}{private}:
00315     \textcolor{keyword}{typename} MakePointer\_<Scalar>::Type m\_data;
00316     Dimensions m\_dimensions;
00317 \};
00318 
00319 \} \textcolor{comment}{// end namespace Eigen}
00320 
00321 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_MAP\_H}
\end{DoxyCode}
