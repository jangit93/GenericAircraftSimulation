\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_meta_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Meta.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_meta_8h_source}\index{Tensor\+Meta.\+h@{Tensor\+Meta.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_META\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_META\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} cond> \textcolor{keyword}{struct }Cond \{\};
00016 
00017 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2> EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE
00018 \textcolor{keyword}{const} T1& choose(Cond<true>, \textcolor{keyword}{const} T1& first, \textcolor{keyword}{const} T2&) \{
00019   \textcolor{keywordflow}{return} first;
00020 \}
00021 
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2> EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE
00023 \textcolor{keyword}{const} T2& choose(Cond<false>, \textcolor{keyword}{const} T1&, \textcolor{keyword}{const} T2& second) \{
00024   \textcolor{keywordflow}{return} second;
00025 \}
00026 
00027 
00028 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} X, \textcolor{keyword}{typename} Y>
00029 EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE
00030 \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} divup(\textcolor{keyword}{const} X x, \textcolor{keyword}{const} Y y) \{
00031   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}\textcolor{keyword}{>}((x + y - 1) / y);
00032 \}
00033 
00034 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00035 EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE
00036 \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} divup(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} x, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} y) \{
00037   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}\textcolor{keyword}{>}((x + y - 1) / y);
00038 \}
00039 
00040 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} n> \textcolor{keyword}{struct }max\_n\_1 \{
00041   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} size = n;
00042 \};
00043 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }max\_n\_1<0> \{
00044   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} size = 1;
00045 \};
00046 
00047 
00048 \textcolor{comment}{// Default packet types}
00049 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Device>
00050 \textcolor{keyword}{struct }PacketType : internal::packet\_traits<Scalar> \{
00051   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::packet\_traits<Scalar>::type type;
00052 \};
00053 
00054 \textcolor{comment}{// For CUDA packet types when using a GpuDevice}
00055 \textcolor{preprocessor}{#if defined(EIGEN\_USE\_GPU) && defined(\_\_CUDACC\_\_) && defined(EIGEN\_HAS\_CUDA\_FP16)}
00056 \textcolor{keyword}{template} <>
00057 \textcolor{keyword}{struct }PacketType<half, GpuDevice> \{
00058   \textcolor{keyword}{typedef} half2 type;
00059   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = 2;
00060   \textcolor{keyword}{enum} \{
00061     HasAdd    = 1,
00062     HasSub    = 1,
00063     HasMul    = 1,
00064     HasNegate = 1,
00065     HasAbs    = 1,
00066     HasArg    = 0,
00067     HasAbs2   = 0,
00068     HasMin    = 1,
00069     HasMax    = 1,
00070     HasConj   = 0,
00071     HasSetLinear = 0,
00072     HasBlend  = 0,
00073 
00074     HasDiv    = 1,
00075     HasSqrt   = 1,
00076     HasRsqrt  = 1,
00077     HasExp    = 1,
00078     HasLog    = 1,
00079     HasLog1p  = 0,
00080     HasLog10  = 0,
00081     HasPow    = 1,
00082   \};
00083 \};
00084 \textcolor{preprocessor}{#endif}
00085 
00086 \textcolor{preprocessor}{#if defined(EIGEN\_USE\_SYCL)}
00087 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>
00088   \textcolor{keyword}{struct }PacketType<\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}, SyclDevice> \{
00089   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} type;
00090   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = 1;
00091   \textcolor{keyword}{enum} \{
00092     HasAdd    = 0,
00093     HasSub    = 0,
00094     HasMul    = 0,
00095     HasNegate = 0,
00096     HasAbs    = 0,
00097     HasArg    = 0,
00098     HasAbs2   = 0,
00099     HasMin    = 0,
00100     HasMax    = 0,
00101     HasConj   = 0,
00102     HasSetLinear = 0,
00103     HasBlend  = 0
00104   \};
00105 \};
00106 \textcolor{preprocessor}{#endif}
00107 
00108 
00109 \textcolor{comment}{// Tuple mimics std::pair but works on e.g. nvcc.}
00110 \textcolor{keyword}{template} <\textcolor{keyword}{typename} U, \textcolor{keyword}{typename} V> \textcolor{keyword}{struct }Tuple \{
00111  \textcolor{keyword}{public}:
00112   U first;
00113   V second;
00114 
00115   \textcolor{keyword}{typedef} U first\_type;
00116   \textcolor{keyword}{typedef} V second\_type;
00117 
00118   EIGEN\_CONSTEXPR EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00119   Tuple() : first(), second() \{\}
00120 
00121   EIGEN\_CONSTEXPR EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00122   Tuple(\textcolor{keyword}{const} U& f, \textcolor{keyword}{const} V& s) : first(f), second(s) \{\}
00123 
00124   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00125   Tuple& operator= (\textcolor{keyword}{const} Tuple& rhs) \{
00126     \textcolor{keywordflow}{if} (&rhs == \textcolor{keyword}{this}) \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00127     first = rhs.first;
00128     second = rhs.second;
00129     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00130   \}
00131 
00132   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00133   \textcolor{keywordtype}{void} \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(Tuple& rhs) \{
00134     \textcolor{keyword}{using} \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{numext::swap};
00135     \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(first, rhs.first);
00136     \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(second, rhs.second);
00137   \}
00138 \};
00139 
00140 \textcolor{keyword}{template} <\textcolor{keyword}{typename} U, \textcolor{keyword}{typename} V>
00141 EIGEN\_CONSTEXPR EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00142 \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} Tuple<U, V>& x, \textcolor{keyword}{const} Tuple<U, V>& y) \{
00143   \textcolor{keywordflow}{return} (x.first == y.first && x.second == y.second);
00144 \}
00145 
00146 \textcolor{keyword}{template} <\textcolor{keyword}{typename} U, \textcolor{keyword}{typename} V>
00147 EIGEN\_CONSTEXPR EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00148 \textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} Tuple<U, V>& x, \textcolor{keyword}{const} Tuple<U, V>& y) \{
00149   \textcolor{keywordflow}{return} !(x == y);
00150 \}
00151 
00152 
00153 \textcolor{comment}{// Can't use std::pairs on cuda devices}
00154 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Idx> \textcolor{keyword}{struct }IndexPair \{
00155   EIGEN\_CONSTEXPR EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE IndexPair() : first(0), second(0) \{\}
00156   EIGEN\_CONSTEXPR EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE IndexPair(Idx f, Idx s) : first(f), second(s) \{\}
00157 
00158   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} \textcolor{keyword}{set}(IndexPair<Idx> val) \{
00159     first = val.first;
00160     second = val.second;
00161   \}
00162 
00163   Idx first;
00164   Idx second;
00165 \};
00166 
00167 
00168 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_SFINAE}
00169 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00170 
00171   \textcolor{keyword}{template}<\textcolor{keyword}{typename} IndexType, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}... Is>
00172   EIGEN\_CONSTEXPR EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00173   array<\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keyword}{sizeof}...(Is)> customIndices2Array(IndexType& idx, numeric\_list<Index, Is...>) \{
00174     \textcolor{keywordflow}{return} \{ idx[Is]... \};
00175   \}
00176   \textcolor{keyword}{template}<\textcolor{keyword}{typename} IndexType>
00177   EIGEN\_CONSTEXPR EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00178   array<Index, 0> customIndices2Array(IndexType&, numeric\_list<Index>) \{
00179     \textcolor{keywordflow}{return} array<Index, 0>();
00180   \}
00181 
00183   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Index, std::\textcolor{keywordtype}{size\_t} NumIndices, \textcolor{keyword}{typename} IndexType>
00184   EIGEN\_CONSTEXPR EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00185   array<Index, NumIndices> customIndices2Array(IndexType& idx) \{
00186     \textcolor{keywordflow}{return} customIndices2Array(idx, \textcolor{keyword}{typename} gen\_numeric\_list<Index, NumIndices>::type\{\});
00187   \}
00188 
00189 
00190   \textcolor{keyword}{template} <\textcolor{keyword}{typename} B, \textcolor{keyword}{typename} D>
00191   \textcolor{keyword}{struct }is\_base\_of
00192   \{
00193 
00194     \textcolor{keyword}{typedef} char (&yes)[1];
00195     \textcolor{keyword}{typedef} char (&no)[2];
00196 
00197     \textcolor{keyword}{template} <\textcolor{keyword}{typename} BB, \textcolor{keyword}{typename} DD>
00198     \textcolor{keyword}{struct }Host
00199     \{
00200       \textcolor{keyword}{operator} BB*() \textcolor{keyword}{const};
00201       \textcolor{keyword}{operator} DD*();
00202     \};
00203 
00204     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00205     \textcolor{keyword}{static} yes check(D*, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T});
00206     \textcolor{keyword}{static} no check(B*, \textcolor{keywordtype}{int});
00207 
00208     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{sizeof}(check(Host<B,D>(), \textcolor{keywordtype}{int}())) == \textcolor{keyword}{sizeof}(yes);
00209   \};
00210 
00211 \}
00212 \textcolor{preprocessor}{#endif}
00213 
00214 
00215 
00216 \}  \textcolor{comment}{// namespace Eigen}
00217 
00218 \textcolor{preprocessor}{#endif  // EIGEN\_CXX11\_TENSOR\_TENSOR\_META\_H}
\end{DoxyCode}
