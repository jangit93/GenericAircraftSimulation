\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_sparse_extra_2_market_i_o_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/src/\+Sparse\+Extra/\+Market\+IO.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2src_2_sparse_extra_2_market_i_o_8h_source}\index{Market\+I\+O.\+h@{Market\+I\+O.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2011 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2012 Desire NUENTSA WAKAM <desire.nuentsa\_wakam@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSE\_MARKET\_IO\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_SPARSE\_MARKET\_IO\_H}
00013 
00014 \textcolor{preprocessor}{#include <iostream>}
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00017 
00018 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} 
00019 \{
00020   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00021   \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} GetMarketLine (std::stringstream& line, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& \hyperlink{group___core___module_class_eigen_1_1_matrix}{M}, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& N, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& i, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& j, Scalar& value)
00022   \{
00023     line >> i >> j >> value;
00024     i--;
00025     j--;
00026     \textcolor{keywordflow}{if}(i>=0 && j>=0 && i<M && j<N)
00027     \{
00028       \textcolor{keywordflow}{return} \textcolor{keyword}{true}; 
00029     \}
00030     \textcolor{keywordflow}{else}
00031       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00032   \}
00033   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar>
00034   \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} GetMarketLine (std::stringstream& line, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& M, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& N, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& i, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& j, std::complex<Scalar>& value)
00035   \{
00036     Scalar valR, valI;
00037     line >> i >> j >> valR >> valI;
00038     i--;
00039     j--;
00040     \textcolor{keywordflow}{if}(i>=0 && j>=0 && i<M && j<N)
00041     \{
00042       value = std::complex<Scalar>(valR, valI);
00043       \textcolor{keywordflow}{return} \textcolor{keyword}{true}; 
00044     \}
00045     \textcolor{keywordflow}{else}
00046       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00047   \}
00048 
00049   \textcolor{keyword}{template} <\textcolor{keyword}{typename} RealScalar>
00050   \textcolor{keyword}{inline} \textcolor{keywordtype}{void}  GetVectorElt (\textcolor{keyword}{const} std::string& line, RealScalar& val)
00051   \{
00052     std::istringstream newline(line);
00053     newline >> val;  
00054   \}
00055 
00056   \textcolor{keyword}{template} <\textcolor{keyword}{typename} RealScalar>
00057   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} GetVectorElt (\textcolor{keyword}{const} std::string& line, std::complex<RealScalar>& val)
00058   \{
00059     RealScalar valR, valI; 
00060     std::istringstream newline(line);
00061     newline >> valR >> valI; 
00062     val = std::complex<RealScalar>(valR, valI);
00063   \}
00064   
00065   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00066   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} putMarketHeader(std::string& header,\textcolor{keywordtype}{int} sym)
00067   \{
00068     header= \textcolor{stringliteral}{"%%MatrixMarket matrix coordinate "};
00069     \textcolor{keywordflow}{if}(internal::is\_same<Scalar, std::complex<float> >::value || internal::is\_same<Scalar, 
      std::complex<double> >::value)
00070     \{
00071       header += \textcolor{stringliteral}{" complex"}; 
00072       \textcolor{keywordflow}{if}(sym == \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4}{Symmetric}) header += \textcolor{stringliteral}{" symmetric"};
00073       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (sym == \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda2491fc6765056421f504eb7e16083e8f}{SelfAdjoint}) header += \textcolor{stringliteral}{" Hermitian"};
00074       \textcolor{keywordflow}{else} header += \textcolor{stringliteral}{" general"};
00075     \}
00076     \textcolor{keywordflow}{else}
00077     \{
00078       header += \textcolor{stringliteral}{" real"}; 
00079       \textcolor{keywordflow}{if}(sym == \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4}{Symmetric}) header += \textcolor{stringliteral}{" symmetric"};
00080       \textcolor{keywordflow}{else} header += \textcolor{stringliteral}{" general"};
00081     \}
00082   \}
00083 
00084   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00085   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} PutMatrixElt(Scalar value, \textcolor{keywordtype}{int} row, \textcolor{keywordtype}{int} col, std::ofstream& out)
00086   \{
00087     out << row << \textcolor{stringliteral}{" "}<< col << \textcolor{stringliteral}{" "} << value << \textcolor{stringliteral}{"\(\backslash\)n"};
00088   \}
00089   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00090   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} PutMatrixElt(std::complex<Scalar> value, \textcolor{keywordtype}{int} row, \textcolor{keywordtype}{int} col, std::ofstream& out)
00091   \{
00092     out << row << \textcolor{stringliteral}{" "} << col << \textcolor{stringliteral}{" "} << value.real() << \textcolor{stringliteral}{" "} << value.imag() << \textcolor{stringliteral}{"\(\backslash\)n"};
00093   \}
00094 
00095 
00096   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00097   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} putVectorElt(Scalar value, std::ofstream& out)
00098   \{
00099     out << value << \textcolor{stringliteral}{"\(\backslash\)n"}; 
00100   \}
00101   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00102   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} putVectorElt(std::complex<Scalar> value, std::ofstream& out)
00103   \{
00104     out << value.real << \textcolor{stringliteral}{" "} << value.imag()<< \textcolor{stringliteral}{"\(\backslash\)n"}; 
00105   \}
00106 
00107 \} \textcolor{comment}{// end namepsace internal}
00108 
00109 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} getMarketHeader(\textcolor{keyword}{const} std::string& filename, \textcolor{keywordtype}{int}& sym, \textcolor{keywordtype}{bool}& iscomplex, \textcolor{keywordtype}{bool}& isvector)
00110 \{
00111   sym = 0; 
00112   isvector = \textcolor{keyword}{false};
00113   std::ifstream in(filename.c\_str(),std::ios::in);
00114   \textcolor{keywordflow}{if}(!in)
00115     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00116   
00117   std::string line; 
00118   \textcolor{comment}{// The matrix header is always the first line in the file }
00119   std::getline(in, line); eigen\_assert(in.good());
00120   
00121   std::stringstream fmtline(line); 
00122   std::string substr[5];
00123   fmtline>> substr[0] >> substr[1] >> substr[2] >> substr[3] >> substr[4];
00124   \textcolor{keywordflow}{if}(substr[2].compare(\textcolor{stringliteral}{"array"}) == 0) isvector = \textcolor{keyword}{true};
00125   \textcolor{keywordflow}{if}(substr[3].compare(\textcolor{stringliteral}{"complex"}) == 0) iscomplex = \textcolor{keyword}{true};
00126   \textcolor{keywordflow}{if}(substr[4].compare(\textcolor{stringliteral}{"symmetric"}) == 0) sym = \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4}{Symmetric};
00127   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (substr[4].compare(\textcolor{stringliteral}{"Hermitian"}) == 0) sym = \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda2491fc6765056421f504eb7e16083e8f}{SelfAdjoint};
00128   
00129   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00130 \}
00131   
00132 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseMatrixType>
00133 \textcolor{keywordtype}{bool} loadMarket(SparseMatrixType& mat, \textcolor{keyword}{const} std::string& filename)
00134 \{
00135   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::Scalar Scalar;
00136   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00137   std::ifstream input(filename.c\_str(),std::ios::in);
00138   \textcolor{keywordflow}{if}(!input)
00139     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00140   
00141   \textcolor{keyword}{const} \textcolor{keywordtype}{int} maxBuffersize = 2048;
00142   \textcolor{keywordtype}{char} buffer[maxBuffersize];
00143   
00144   \textcolor{keywordtype}{bool} readsizes = \textcolor{keyword}{false};
00145 
00146   \textcolor{keyword}{typedef} Triplet<Scalar,Index> \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T};
00147   std::vector<T> elements;
00148   
00149   Index M(-1), N(-1), NNZ(-1);
00150   Index count = 0;
00151   \textcolor{keywordflow}{while}(input.getline(buffer, maxBuffersize))
00152   \{
00153     \textcolor{comment}{// skip comments   }
00154     \textcolor{comment}{//NOTE An appropriate test should be done on the header to get the  symmetry}
00155     \textcolor{keywordflow}{if}(buffer[0]==\textcolor{charliteral}{'%'})
00156       \textcolor{keywordflow}{continue};
00157     
00158     std::stringstream line(buffer);
00159     
00160     \textcolor{keywordflow}{if}(!readsizes)
00161     \{
00162       line >> M >> N >> NNZ;
00163       \textcolor{keywordflow}{if}(M > 0 && N > 0 && NNZ > 0) 
00164       \{
00165         readsizes = \textcolor{keyword}{true};
00166         \textcolor{comment}{//std::cout << "sizes: " << M << "," << N << "," << NNZ << "\(\backslash\)n";}
00167         mat.resize(M,N);
00168         mat.reserve(NNZ);
00169       \}
00170     \}
00171     \textcolor{keywordflow}{else}
00172     \{ 
00173       Index i(-1), j(-1);
00174       Scalar value; 
00175       \textcolor{keywordflow}{if}( internal::GetMarketLine(line, M, N, i, j, value) ) 
00176       \{
00177         ++ count;
00178         elements.push\_back(T(i,j,value));
00179       \}
00180       \textcolor{keywordflow}{else} 
00181         std::cerr << \textcolor{stringliteral}{"Invalid read: "} << i << \textcolor{stringliteral}{","} << j << \textcolor{stringliteral}{"\(\backslash\)n"};        
00182     \}
00183   \}
00184   mat.setFromTriplets(elements.begin(), elements.end());
00185   \textcolor{keywordflow}{if}(count!=NNZ)
00186     std::cerr << count << \textcolor{stringliteral}{"!="} << NNZ << \textcolor{stringliteral}{"\(\backslash\)n"};
00187   
00188   input.close();
00189   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00190 \}
00191 
00192 \textcolor{keyword}{template}<\textcolor{keyword}{typename} VectorType>
00193 \textcolor{keywordtype}{bool} loadMarketVector(\hyperlink{struct_vector_type}{VectorType}& vec, \textcolor{keyword}{const} std::string& filename)
00194 \{
00195    \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::Scalar Scalar;
00196   std::ifstream in(filename.c\_str(), std::ios::in);
00197   \textcolor{keywordflow}{if}(!in)
00198     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00199   
00200   std::string line; 
00201   \textcolor{keywordtype}{int} n(0), col(0); 
00202   \textcolor{keywordflow}{do} 
00203   \{ \textcolor{comment}{// Skip comments}
00204     std::getline(in, line); eigen\_assert(in.good());
00205   \} \textcolor{keywordflow}{while} (line[0] == \textcolor{charliteral}{'%'});
00206   std::istringstream newline(line);
00207   newline  >> n >> col; 
00208   eigen\_assert(n>0 && col>0);
00209   vec.resize(n);
00210   \textcolor{keywordtype}{int} i = 0; 
00211   Scalar value; 
00212   \textcolor{keywordflow}{while} ( std::getline(in, line) && (i < n) )\{
00213     internal::GetVectorElt(line, value); 
00214     vec(i++) = value; 
00215   \}
00216   in.close();
00217   \textcolor{keywordflow}{if} (i!=n)\{
00218     std::cerr<< \textcolor{stringliteral}{"Unable to read all elements from file "} << filename << \textcolor{stringliteral}{"\(\backslash\)n"};
00219     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00220   \}
00221   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00222 \}
00223 
00224 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseMatrixType>
00225 \textcolor{keywordtype}{bool} saveMarket(\textcolor{keyword}{const} SparseMatrixType& mat, \textcolor{keyword}{const} std::string& filename, \textcolor{keywordtype}{int} sym = 0)
00226 \{
00227   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::Scalar Scalar;
00228   std::ofstream out(filename.c\_str(),std::ios::out);
00229   \textcolor{keywordflow}{if}(!out)
00230     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00231   
00232   out.flags(std::ios\_base::scientific);
00233   out.precision(64);
00234   std::string header; 
00235   internal::putMarketHeader<Scalar>(header, sym); 
00236   out << header << std::endl; 
00237   out << mat.rows() << \textcolor{stringliteral}{" "} << mat.cols() << \textcolor{stringliteral}{" "} << mat.nonZeros() << \textcolor{stringliteral}{"\(\backslash\)n"};
00238   \textcolor{keywordtype}{int} count = 0;
00239   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<mat.outerSize(); ++j)
00240     \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} SparseMatrixType::InnerIterator it(mat,j); it; ++it)
00241     \{
00242       ++ count;
00243       internal::PutMatrixElt(it.value(), it.row()+1, it.col()+1, out);
00244       \textcolor{comment}{// out << it.row()+1 << " " << it.col()+1 << " " << it.value() << "\(\backslash\)n";}
00245     \}
00246   out.close();
00247   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00248 \}
00249 
00250 \textcolor{keyword}{template}<\textcolor{keyword}{typename} VectorType>
00251 \textcolor{keywordtype}{bool} saveMarketVector (\textcolor{keyword}{const} \hyperlink{struct_vector_type}{VectorType}& vec, \textcolor{keyword}{const} std::string& filename)
00252 \{
00253  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} VectorType::Scalar Scalar; 
00254  std::ofstream out(filename.c\_str(),std::ios::out);
00255   \textcolor{keywordflow}{if}(!out)
00256     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00257   
00258   out.flags(std::ios\_base::scientific);
00259   out.precision(64);
00260   \textcolor{keywordflow}{if}(internal::is\_same<Scalar, std::complex<float> >::value || internal::is\_same<Scalar, 
      std::complex<double> >::value)
00261       out << \textcolor{stringliteral}{"%%MatrixMarket matrix array complex general\(\backslash\)n"}; 
00262   \textcolor{keywordflow}{else}
00263     out << \textcolor{stringliteral}{"%%MatrixMarket matrix array real general\(\backslash\)n"}; 
00264   out << vec.size() << \textcolor{stringliteral}{" "}<< 1 << \textcolor{stringliteral}{"\(\backslash\)n"};
00265   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < vec.size(); i++)\{
00266     internal::putVectorElt(vec(i), out); 
00267   \}
00268   out.close();
00269   \textcolor{keywordflow}{return} \textcolor{keyword}{true}; 
00270 \}
00271 
00272 \} \textcolor{comment}{// end namespace Eigen}
00273 
00274 \textcolor{preprocessor}{#endif // EIGEN\_SPARSE\_MARKET\_IO\_H}
\end{DoxyCode}
