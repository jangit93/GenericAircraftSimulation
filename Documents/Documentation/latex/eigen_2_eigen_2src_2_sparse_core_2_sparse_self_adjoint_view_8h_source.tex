\hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source}{}\section{eigen/\+Eigen/src/\+Sparse\+Core/\+Sparse\+Self\+Adjoint\+View.h}
\label{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source}\index{Sparse\+Self\+Adjoint\+View.\+h@{Sparse\+Self\+Adjoint\+View.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSE\_SELFADJOINTVIEW\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SPARSE\_SELFADJOINTVIEW\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014   
00029 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00030   
00031 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Mode>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00032}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_sparse_self_adjoint_view_3_01_matrix_type_00_01_mode_01_4_01_4}{00032} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView}<MatrixType,Mode> > : 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<MatrixType> \{
00033 \};
00034 
00035 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SrcMode,\textcolor{keywordtype}{int} DstMode,\textcolor{keyword}{typename} MatrixType,\textcolor{keywordtype}{int} DestOrder>
00036 \textcolor{keywordtype}{void} permute\_symm\_to\_symm(\textcolor{keyword}{const} MatrixType& mat, 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::StorageIndex>}
      & \_dest, \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::StorageIndex* perm = 0);
00037 
00038 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Mode,\textcolor{keyword}{typename} MatrixType,\textcolor{keywordtype}{int} DestOrder>
00039 \textcolor{keywordtype}{void} permute\_symm\_to\_fullsymm(\textcolor{keyword}{const} MatrixType& mat, 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::StorageIndex>}
      & \_dest, \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::StorageIndex* perm = 0);
00040 
00041 \}
00042 
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00043}\hyperlink{group___sparse_core___module}{00043} \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_Mode> \textcolor{keyword}{class }\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView}
00044   : \textcolor{keyword}{public} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase}<SparseSelfAdjointView<MatrixType,\_Mode> >
00045 \{
00046   \textcolor{keyword}{public}:
00047     
00048     \textcolor{keyword}{enum} \{
00049       Mode = \_Mode,
00050       TransposeMode = ((Mode & \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}) ? \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} : 0) | ((Mode & \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) ? 
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper} : 0),
00051       RowsAtCompileTime = 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<SparseSelfAdjointView>::RowsAtCompileTime}
      ,
00052       ColsAtCompileTime = 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<SparseSelfAdjointView>::ColsAtCompileTime}
00053     \};
00054 
00055     \textcolor{keyword}{typedef} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<SparseSelfAdjointView>} 
      \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{Base};
00056     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00057     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00058     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<StorageIndex,Dynamic,1>} \hyperlink{group___core___module}{VectorI};
00059     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::ref\_selector<MatrixType>::non\_const\_type}
       \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{MatrixTypeNested};
00060     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<MatrixTypeNested>::type}
       \hyperlink{group___sparse_core___module}{\_MatrixTypeNested};
00061     
00062     \textcolor{keyword}{explicit} \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView}(MatrixType& matrix) : m\_matrix(matrix)
00063     \{
00064       eigen\_assert(rows()==cols() && \textcolor{stringliteral}{"SelfAdjointView is only for squared matrices"});
00065     \}
00066 
00067     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix.rows(); \}
00068     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix.cols(); \}
00069 
00071     \textcolor{keyword}{const} \_MatrixTypeNested& matrix()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix; \}
00072     \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_reference<MatrixTypeNested>::type}
      & matrix() \{ \textcolor{keywordflow}{return} m\_matrix; \}
00073 
00079     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00080     \hyperlink{group___core___module_class_eigen_1_1_product}{Product<SparseSelfAdjointView, OtherDerived>}
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00081}\hyperlink{group___sparse_core___module_a9d1e5ef26775e3b43be08fd4ae191aa8}{00081}     \hyperlink{group___sparse_core___module_a9d1e5ef26775e3b43be08fd4ae191aa8}{operator*}(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<OtherDerived>}& rhs)\textcolor{keyword}{ const}
00082 \textcolor{keyword}{    }\{
00083       \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_product}{Product<SparseSelfAdjointView, OtherDerived>}(*\textcolor{keyword}{this}
      , rhs.derived());
00084     \}
00085 
00091     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived> \textcolor{keyword}{friend}
00092     \hyperlink{group___core___module_class_eigen_1_1_product}{Product<OtherDerived, SparseSelfAdjointView>}
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00093}\hyperlink{group___sparse_core___module_a9bbe41a5c050f8067d4fe77372eb0b7a}{00093}     \hyperlink{group___sparse_core___module_a9bbe41a5c050f8067d4fe77372eb0b7a}{operator*}(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<OtherDerived>}& lhs, \textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView}& rhs)
00094     \{
00095       \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_product}{Product<OtherDerived, SparseSelfAdjointView>}(lhs.
      derived(), rhs);
00096     \}
00097     
00099     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00100     \hyperlink{group___core___module_class_eigen_1_1_product}{Product<SparseSelfAdjointView,OtherDerived>}
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00101}\hyperlink{group___sparse_core___module_a887e3b5fa468af8413276141ddc8bb93}{00101}     \hyperlink{group___sparse_core___module_a887e3b5fa468af8413276141ddc8bb93}{operator*}(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<OtherDerived>}& rhs)\textcolor{keyword}{ const}
00102 \textcolor{keyword}{    }\{
00103       \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_product}{Product<SparseSelfAdjointView,OtherDerived>}(*\textcolor{keyword}{this}, 
      rhs.derived());
00104     \}
00105 
00107     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived> \textcolor{keyword}{friend}
00108     \hyperlink{group___core___module_class_eigen_1_1_product}{Product<OtherDerived,SparseSelfAdjointView>}
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00109}\hyperlink{group___sparse_core___module_a346ad7b3c5c8769c0fe29ae9e921b429}{00109}     \hyperlink{group___sparse_core___module_a346ad7b3c5c8769c0fe29ae9e921b429}{operator*}(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<OtherDerived>}& lhs, \textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView}& rhs)
00110     \{
00111       \textcolor{keywordflow}{return} \hyperlink{group___core___module_class_eigen_1_1_product}{Product<OtherDerived,SparseSelfAdjointView>}(lhs.
      derived(), rhs);
00112     \}
00113 
00122     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedU>
00123     \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView}& rankUpdate(\textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<DerivedU>}& u, \textcolor{keyword}{const} Scalar& alpha = Scalar(1));
00124     
00126     \textcolor{comment}{// TODO implement twists in a more evaluator friendly fashion}
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00127}\hyperlink{group___sparse_core___module_acde15b45cf7b43520e1005ec65d55f3c}{00127}     \hyperlink{class_eigen_1_1_sparse_symmetric_permutation_product}{SparseSymmetricPermutationProduct<\_MatrixTypeNested,Mode>}
       \hyperlink{group___sparse_core___module_acde15b45cf7b43520e1005ec65d55f3c}{twistedBy}(\textcolor{keyword}{const} \hyperlink{group___core___module}{PermutationMatrix<Dynamic,Dynamic,StorageIndex>}
      & perm)\textcolor{keyword}{ const}
00128 \textcolor{keyword}{    }\{
00129       \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_sparse_symmetric_permutation_product}{SparseSymmetricPermutationProduct<\_MatrixTypeNested,Mode>}
      (m\_matrix, perm);
00130     \}
00131 
00132     \textcolor{keyword}{template}<\textcolor{keyword}{typename} SrcMatrixType,\textcolor{keywordtype}{int} SrcMode>
00133     \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView}& operator=(\textcolor{keyword}{const} 
      \hyperlink{class_eigen_1_1_sparse_symmetric_permutation_product}{SparseSymmetricPermutationProduct<SrcMatrixType,SrcMode>}
      & permutedMatrix)
00134     \{
00135       internal::call\_assignment\_no\_alias\_no\_transpose(*\textcolor{keyword}{this}, permutedMatrix);
00136       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00137     \}
00138 
00139     \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView}& operator=(\textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView}& src)
00140     \{
00141       \hyperlink{group___core___module}{PermutationMatrix<Dynamic,Dynamic,StorageIndex>} pnull;
00142       \textcolor{keywordflow}{return} *\textcolor{keyword}{this} = src.\hyperlink{group___sparse_core___module_acde15b45cf7b43520e1005ec65d55f3c}{twistedBy}(pnull);
00143     \}
00144 
00145     \textcolor{keyword}{template}<\textcolor{keyword}{typename} SrcMatrixType,\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} SrcMode>
00146     \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView}& operator=(\textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView<SrcMatrixType,SrcMode>}& src)
00147     \{
00148       \hyperlink{group___core___module}{PermutationMatrix<Dynamic,Dynamic,StorageIndex>} pnull;
00149       \textcolor{keywordflow}{return} *\textcolor{keyword}{this} = src.\hyperlink{group___sparse_core___module_acde15b45cf7b43520e1005ec65d55f3c}{twistedBy}(pnull);
00150     \}
00151     
00152     \textcolor{keywordtype}{void} resize(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} rows, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} cols)
00153     \{
00154       EIGEN\_ONLY\_USED\_FOR\_DEBUG(rows);
00155       EIGEN\_ONLY\_USED\_FOR\_DEBUG(cols);
00156       eigen\_assert(rows == this->rows() && cols == this->cols()
00157                 && \textcolor{stringliteral}{"SparseSelfadjointView::resize() does not actually allow to resize."});
00158     \}
00159     
00160   \textcolor{keyword}{protected}:
00161 
00162     MatrixTypeNested m\_matrix;
00163     \textcolor{comment}{//mutable VectorI m\_countPerRow;}
00164     \textcolor{comment}{//mutable VectorI m\_countPerCol;}
00165   \textcolor{keyword}{private}:
00166     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest> \textcolor{keywordtype}{void} evalTo(Dest &) \textcolor{keyword}{const};
00167 \};
00168 
00169 \textcolor{comment}{/***************************************************************************}
00170 \textcolor{comment}{* Implementation of SparseMatrixBase methods}
00171 \textcolor{comment}{***************************************************************************/}
00172 
00173 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00174 \textcolor{keyword}{template}<\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} UpLo>
00175 \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<Derived>::template} 
      ConstSelfAdjointViewReturnType<UpLo>::Type \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<Derived>::selfadjointView}()\textcolor{keyword}{ const}
00176 \textcolor{keyword}{}\{
00177   \textcolor{keywordflow}{return} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView<const Derived, UpLo>}(derived());
00178 \}
00179 
00180 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00181 \textcolor{keyword}{template}<\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} UpLo>
00182 \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<Derived>::template} 
      SelfAdjointViewReturnType<UpLo>::Type \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<Derived>::selfadjointView}()
00183 \{
00184   \textcolor{keywordflow}{return} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView<Derived, UpLo>}(derived());
00185 \}
00186 
00187 \textcolor{comment}{/***************************************************************************}
00188 \textcolor{comment}{* Implementation of SparseSelfAdjointView methods}
00189 \textcolor{comment}{***************************************************************************/}
00190 
00191 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Mode>
00192 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedU>
00193 \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView<MatrixType,Mode>}&
00194 \hyperlink{group___sparse_core___module_abe66734215f8d8220be0985d67901021}{SparseSelfAdjointView<MatrixType,Mode>::rankUpdate}(\textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<DerivedU>}& u, \textcolor{keyword}{const} Scalar& alpha)
00195 \{
00196   \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar,(MatrixType::Flags&RowMajorBit)?RowMajor:ColMajor>}
       tmp = u * u.adjoint();
00197   \textcolor{keywordflow}{if}(alpha==Scalar(0))
00198     m\_matrix = tmp.template triangularView<Mode>();
00199   \textcolor{keywordflow}{else}
00200     m\_matrix += alpha * tmp.template triangularView<Mode>();
00201 
00202   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00203 \}
00204 
00205 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00206   
00207 \textcolor{comment}{// TODO currently a selfadjoint expression has the form SelfAdjointView<.,.>}
00208 \textcolor{comment}{//      in the future selfadjoint-ness should be defined by the expression traits}
00209 \textcolor{comment}{//      such that Transpose<SelfAdjointView<.,.> > is valid. (currently TriangularBase::transpose() is
       overloaded to make it work)}
00210 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Mode>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00211}\hyperlink{struct_eigen_1_1internal_1_1evaluator__traits_3_01_sparse_self_adjoint_view_3_01_matrix_type_00_01_mode_01_4_01_4}{00211} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1evaluator__traits}{evaluator\_traits}<\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView}<MatrixType,Mode> >
00212 \{
00213   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1_index_based}{storage\_kind\_to\_evaluator\_kind<typename MatrixType::StorageKind>::Kind}
       \hyperlink{struct_eigen_1_1internal_1_1_index_based}{Kind};
00214   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint_shape}{SparseSelfAdjointShape} \hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint_shape}{Shape};
00215 \};
00216 
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00217}\hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint2_sparse}{00217} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint2_sparse}{SparseSelfAdjoint2Sparse} \{\};
00218 
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00219}\hyperlink{struct_eigen_1_1internal_1_1_assignment_kind_3_01_sparse_shape_00_01_sparse_self_adjoint_shape_01_4}{00219} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment_kind}{AssignmentKind}<\hyperlink{struct_eigen_1_1_sparse_shape}{SparseShape},
      \hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint_shape}{SparseSelfAdjointShape}> \{ \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint2_sparse}{SparseSelfAdjoint2Sparse} 
      \hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint2_sparse}{Kind}; \};
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00220}\hyperlink{struct_eigen_1_1internal_1_1_assignment_kind_3_01_sparse_self_adjoint_shape_00_01_sparse_shape_01_4}{00220} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment_kind}{AssignmentKind}<\hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint_shape}{SparseSelfAdjointShape},
      \hyperlink{struct_eigen_1_1_sparse_shape}{SparseShape}> \{ \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1_sparse2_sparse}{Sparse2Sparse} \hyperlink{struct_eigen_1_1internal_1_1_sparse2_sparse}{Kind}; \};
00221 
00222 \textcolor{keyword}{template}< \textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} SrcXprType, \textcolor{keyword}{typename} Functor>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00223}\hyperlink{struct_eigen_1_1internal_1_1_assignment_3_01_dst_xpr_type_00_01_src_xpr_type_00_01_functor_00_017b35cf78061a31c93b838bddfa619fa3}{00223} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment}{Assignment}<DstXprType, SrcXprType, \hyperlink{struct_functor}{Functor}, 
      \hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint2_sparse}{SparseSelfAdjoint2Sparse}>
00224 \{
00225   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::StorageIndex StorageIndex;
00226   \textcolor{keyword}{typedef} 
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<typename DstXprType::Scalar,typename SrcXprType::Scalar>}
       \hyperlink{struct_eigen_1_1internal_1_1assign__op}{AssignOpType};
00227 
00228   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DestScalar,\textcolor{keywordtype}{int} StorageOrder>
00229   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<DestScalar,StorageOrder,StorageIndex>}
       &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} AssignOpType&\textcolor{comment}{/*func*/})
00230   \{
00231     internal::permute\_symm\_to\_fullsymm<SrcXprType::Mode>(src.matrix(), dst);
00232   \}
00233 
00234   \textcolor{comment}{// FIXME: the handling of += and -= in sparse matrices should be cleanup so that next two overloads could
       be reduced to:}
00235   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DestScalar,\textcolor{keywordtype}{int} StorageOrder,\textcolor{keyword}{typename} AssignFunc>
00236   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<DestScalar,StorageOrder,StorageIndex>}
       &dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} AssignFunc& \hyperlink{structfunc}{func})
00237   \{
00238     \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<DestScalar,StorageOrder,StorageIndex>} 
      tmp(src.rows(),src.cols());
00239     run(tmp, src, AssignOpType());
00240     call\_assignment\_no\_alias\_no\_transpose(dst, tmp, func);
00241   \}
00242 
00243   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DestScalar,\textcolor{keywordtype}{int} StorageOrder>
00244   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<DestScalar,StorageOrder,StorageIndex>}
       &dst, \textcolor{keyword}{const} SrcXprType &src,
00245                   \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1add__assign__op}{internal::add\_assign\_op<typename DstXprType::Scalar,typename SrcXprType::Scalar>}
      & \textcolor{comment}{/* func */})
00246   \{
00247     \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<DestScalar,StorageOrder,StorageIndex>} 
      tmp(src.rows(),src.cols());
00248     run(tmp, src, AssignOpType());
00249     dst += tmp;
00250   \}
00251 
00252   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DestScalar,\textcolor{keywordtype}{int} StorageOrder>
00253   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<DestScalar,StorageOrder,StorageIndex>}
       &dst, \textcolor{keyword}{const} SrcXprType &src,
00254                   \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1sub__assign__op}{internal::sub\_assign\_op<typename DstXprType::Scalar,typename SrcXprType::Scalar>}
      & \textcolor{comment}{/* func */})
00255   \{
00256     \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<DestScalar,StorageOrder,StorageIndex>} 
      tmp(src.rows(),src.cols());
00257     run(tmp, src, AssignOpType());
00258     dst -= tmp;
00259   \}
00260   
00261   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DestScalar>
00262   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\hyperlink{class_eigen_1_1_dynamic_sparse_matrix}{DynamicSparseMatrix<DestScalar,ColMajor,StorageIndex>}
      & dst, \textcolor{keyword}{const} SrcXprType &src, \textcolor{keyword}{const} AssignOpType&\textcolor{comment}{/*func*/})
00263   \{
00264     \textcolor{comment}{// TODO directly evaluate into dst;}
00265     \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<DestScalar,ColMajor,StorageIndex>} tmp(dst.
      rows(),dst.cols());
00266     internal::permute\_symm\_to\_fullsymm<SrcXprType::Mode>(src.matrix(), tmp);
00267     dst = tmp;
00268   \}
00269 \};
00270 
00271 \} \textcolor{comment}{// end namespace internal}
00272 
00273 \textcolor{comment}{/***************************************************************************}
00274 \textcolor{comment}{* Implementation of sparse self-adjoint time dense matrix}
00275 \textcolor{comment}{***************************************************************************/}
00276 
00277 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00278 
00279 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Mode, \textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType, \textcolor{keyword}{typename} AlphaType
      >
00280 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} sparse\_selfadjoint\_time\_dense\_product(\textcolor{keyword}{const} SparseLhsType& lhs, \textcolor{keyword}{const} DenseRhsType& rhs, 
      DenseResType& res, \textcolor{keyword}{const} AlphaType& alpha)
00281 \{
00282   EIGEN\_ONLY\_USED\_FOR\_DEBUG(alpha);
00283   
00284   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{internal::nested\_eval<SparseLhsType,DenseRhsType::MaxColsAtCompileTime>::type}
       SparseLhsTypeNested;
00285   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<SparseLhsTypeNested>::type}
       SparseLhsTypeNestedCleaned;
00286   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<SparseLhsTypeNestedCleaned>} LhsEval;
00287   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsEval::InnerIterator LhsIterator;
00288   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseLhsType::Scalar LhsScalar;
00289   
00290   \textcolor{keyword}{enum} \{
00291     LhsIsRowMajor = (LhsEval::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit},
00292     ProcessFirstHalf =
00293               ((Mode&(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}|\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}))==(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}|\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}))
00294           || ( (Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}) && !LhsIsRowMajor)
00295           || ( (Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) && LhsIsRowMajor),
00296     ProcessSecondHalf = !ProcessFirstHalf
00297   \};
00298   
00299   SparseLhsTypeNested lhs\_nested(lhs);
00300   LhsEval lhsEval(lhs\_nested);
00301 
00302   \textcolor{comment}{// work on one column at once}
00303   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<rhs.cols(); ++k)
00304   \{
00305     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<lhs.outerSize(); ++j)
00306     \{
00307       LhsIterator i(lhsEval,j);
00308       \textcolor{comment}{// handle diagonal coeff}
00309       \textcolor{keywordflow}{if} (ProcessSecondHalf)
00310       \{
00311         \textcolor{keywordflow}{while} (i && i.index()<j) ++i;
00312         \textcolor{keywordflow}{if}(i && i.index()==j)
00313         \{
00314           res(j,k) += alpha * i.value() * rhs(j,k);
00315           ++i;
00316         \}
00317       \}
00318 
00319       \textcolor{comment}{// premultiplied rhs for scatters}
00320       \textcolor{keyword}{typename} 
      \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<AlphaType, typename DenseRhsType::Scalar>::ReturnType}
       rhs\_j(alpha*rhs(j,k));
00321       \textcolor{comment}{// accumulator for partial scalar product}
00322       \textcolor{keyword}{typename} DenseResType::Scalar res\_j(0);
00323       \textcolor{keywordflow}{for}(; (ProcessFirstHalf ? i && i.index() < j : i) ; ++i)
00324       \{
00325         LhsScalar lhs\_ij = i.value();
00326         \textcolor{keywordflow}{if}(!LhsIsRowMajor) lhs\_ij = numext::conj(lhs\_ij);
00327         res\_j += lhs\_ij * rhs(i.index(),k);
00328         res(i.index(),k) += numext::conj(lhs\_ij) * rhs\_j;
00329       \}
00330       res(j,k) += alpha * res\_j;
00331 
00332       \textcolor{comment}{// handle diagonal coeff}
00333       \textcolor{keywordflow}{if} (ProcessFirstHalf && i && (i.index()==j))
00334         res(j,k) += alpha * i.value() * rhs(j,k);
00335     \}
00336   \}
00337 \}
00338 
00339 
00340 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsView, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductType>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00341}\hyperlink{struct_eigen_1_1internal_1_1generic__product__impl_3_01_lhs_view_00_01_rhs_00_01_sparse_self_adj0d7cb22d06770c150f0f74fa6f4e5968}{00341} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1generic__product__impl}{generic\_product\_impl}<LhsView, Rhs, 
      \hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint_shape}{SparseSelfAdjointShape}, \hyperlink{struct_eigen_1_1_dense_shape}{DenseShape}, ProductType>
00342 : \hyperlink{struct_eigen_1_1internal_1_1generic__product__impl__base}{generic\_product\_impl\_base}<LhsView, Rhs, generic\_product\_impl<LhsView, Rhs, Spars
      eSelfAdjointShape, DenseShape, ProductType> >
00343 \{
00344   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00345   \textcolor{keyword}{static} \textcolor{keywordtype}{void} scaleAndAddTo(Dest& dst, \textcolor{keyword}{const} LhsView& lhsView, \textcolor{keyword}{const} Rhs& rhs, \textcolor{keyword}{const} \textcolor{keyword}{typename} Dest::Scalar&
       alpha)
00346   \{
00347     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsView::\_MatrixTypeNested Lhs;
00348     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{nested\_eval<Lhs,Dynamic>::type} LhsNested;
00349     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{nested\_eval<Rhs,Dynamic>::type} RhsNested;
00350     LhsNested lhsNested(lhsView.matrix());
00351     RhsNested rhsNested(rhs);
00352     
00353     internal::sparse\_selfadjoint\_time\_dense\_product<LhsView::Mode>(lhsNested, rhsNested, dst, alpha);
00354   \}
00355 \};
00356 
00357 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} RhsView, \textcolor{keywordtype}{int} ProductType>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00358}\hyperlink{struct_eigen_1_1internal_1_1generic__product__impl_3_01_lhs_00_01_rhs_view_00_01_dense_shape_00_97d81d328d4cc9ddd79aee8e69e68494}{00358} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1generic__product__impl}{generic\_product\_impl}<Lhs, RhsView, \hyperlink{struct_eigen_1_1_dense_shape}{DenseShape}, 
      \hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint_shape}{SparseSelfAdjointShape}, ProductType>
00359 : \hyperlink{struct_eigen_1_1internal_1_1generic__product__impl__base}{generic\_product\_impl\_base}<Lhs, RhsView, generic\_product\_impl<Lhs, RhsView, Dense
      Shape, SparseSelfAdjointShape, ProductType> >
00360 \{
00361   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00362   \textcolor{keyword}{static} \textcolor{keywordtype}{void} scaleAndAddTo(Dest& dst, \textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} RhsView& rhsView, \textcolor{keyword}{const} \textcolor{keyword}{typename} Dest::Scalar&
       alpha)
00363   \{
00364     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsView::\_MatrixTypeNested Rhs;
00365     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{nested\_eval<Lhs,Dynamic>::type} LhsNested;
00366     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{nested\_eval<Rhs,Dynamic>::type} RhsNested;
00367     LhsNested lhsNested(lhs);
00368     RhsNested rhsNested(rhsView.matrix());
00369     
00370     \textcolor{comment}{// transpose everything}
00371     \hyperlink{group___core___module_class_eigen_1_1_transpose}{Transpose<Dest>} dstT(dst);
00372     internal::sparse\_selfadjoint\_time\_dense\_product<RhsView::TransposeMode>(rhsNested.transpose(), 
      lhsNested.transpose(), dstT, alpha);
00373   \}
00374 \};
00375 
00376 \textcolor{comment}{// NOTE: these two overloads are needed to evaluate the sparse selfadjoint view into a full sparse matrix}
00377 \textcolor{comment}{// TODO: maybe the copy could be handled by generic\_product\_impl so that these overloads would not be
       needed anymore}
00378 
00379 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsView, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductTag>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00380}\hyperlink{struct_eigen_1_1internal_1_1product__evaluator_3_01_product_3_01_lhs_view_00_01_rhs_00_01_defaul9695c5493cd4054bc6e3c91568225f16}{00380} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1product__evaluator}{product\_evaluator}<\hyperlink{group___core___module_class_eigen_1_1_product}{Product}<LhsView, Rhs, DefaultProduct>, ProductTag, 
      \hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint_shape}{SparseSelfAdjointShape}, \hyperlink{struct_eigen_1_1_sparse_shape}{SparseShape}>
00381   : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator}<typename Product<typename Rhs::PlainObject, Rhs, DefaultProduct>::PlainObject
      >
00382 \{
00383   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_product}{Product<LhsView, Rhs, DefaultProduct>} 
      \hyperlink{group___core___module_class_eigen_1_1_product}{XprType};
00384   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::PlainObject PlainObject;
00385   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<PlainObject>} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{Base};
00386 
00387   \hyperlink{struct_eigen_1_1internal_1_1product__evaluator}{product\_evaluator}(\textcolor{keyword}{const} XprType& xpr)
00388     : m\_lhs(xpr.lhs()), m\_result(xpr.rows(), xpr.cols())
00389   \{
00390     ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(m\_result);
00391     
      \hyperlink{struct_eigen_1_1internal_1_1generic__product__impl}{generic\_product\_impl<typename Rhs::PlainObject, Rhs, SparseShape, SparseShape, ProductTag>::evalTo}
      (m\_result, m\_lhs, xpr.rhs());
00392   \}
00393   
00394 \textcolor{keyword}{protected}:
00395   \textcolor{keyword}{typename} Rhs::PlainObject m\_lhs;
00396   PlainObject m\_result;
00397 \};
00398 
00399 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} RhsView, \textcolor{keywordtype}{int} ProductTag>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00400}\hyperlink{struct_eigen_1_1internal_1_1product__evaluator_3_01_product_3_01_lhs_00_01_rhs_view_00_01_defaule3daa34d3e750fc1a34e5c28fcdbf893}{00400} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1product__evaluator}{product\_evaluator}<\hyperlink{group___core___module_class_eigen_1_1_product}{Product}<Lhs, RhsView, DefaultProduct>, ProductTag, 
      \hyperlink{struct_eigen_1_1_sparse_shape}{SparseShape}, \hyperlink{struct_eigen_1_1internal_1_1_sparse_self_adjoint_shape}{SparseSelfAdjointShape}>
00401   : \textcolor{keyword}{public} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator}<typename Product<Lhs, typename Lhs::PlainObject, DefaultProduct>::PlainObject
      >
00402 \{
00403   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_product}{Product<Lhs, RhsView, DefaultProduct>} 
      \hyperlink{group___core___module_class_eigen_1_1_product}{XprType};
00404   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::PlainObject PlainObject;
00405   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<PlainObject>} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{Base};
00406 
00407   \hyperlink{struct_eigen_1_1internal_1_1product__evaluator}{product\_evaluator}(\textcolor{keyword}{const} XprType& xpr)
00408     : m\_rhs(xpr.rhs()), m\_result(xpr.rows(), xpr.cols())
00409   \{
00410     ::new (static\_cast<Base*>(\textcolor{keyword}{this})) Base(m\_result);
00411     
      \hyperlink{struct_eigen_1_1internal_1_1generic__product__impl}{generic\_product\_impl<Lhs, typename Lhs::PlainObject, SparseShape, SparseShape, ProductTag>::evalTo}
      (m\_result, xpr.lhs(), m\_rhs);
00412   \}
00413   
00414 \textcolor{keyword}{protected}:
00415   \textcolor{keyword}{typename} Lhs::PlainObject m\_rhs;
00416   PlainObject m\_result;
00417 \};
00418 
00419 \} \textcolor{comment}{// namespace internal}
00420 
00421 \textcolor{comment}{/***************************************************************************}
00422 \textcolor{comment}{* Implementation of symmetric copies and permutations}
00423 \textcolor{comment}{***************************************************************************/}
00424 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00425 
00426 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Mode,\textcolor{keyword}{typename} MatrixType,\textcolor{keywordtype}{int} DestOrder>
00427 \textcolor{keywordtype}{void} permute\_symm\_to\_fullsymm(\textcolor{keyword}{const} MatrixType& mat, 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::StorageIndex>}
      & \_dest, \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::StorageIndex* perm)
00428 \{
00429   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00430   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00431   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar,DestOrder,StorageIndex>} Dest;
00432   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<StorageIndex,Dynamic,1>} VectorI;
00433   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<MatrixType>} MatEval;
00434   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<MatrixType>::InnerIterator} MatIterator;
00435   
00436   MatEval matEval(mat);
00437   Dest& dest(\_dest.derived());
00438   \textcolor{keyword}{enum} \{
00439     StorageOrderMatch = int(Dest::IsRowMajor) == int(MatrixType::IsRowMajor)
00440   \};
00441   
00442   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = mat.rows();
00443   VectorI count;
00444   count.resize(size);
00445   count.setZero();
00446   dest.resize(size,size);
00447   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j<size; ++j)
00448   \{
00449     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} jp = perm ? perm[j] : j;
00450     \textcolor{keywordflow}{for}(MatIterator it(matEval,j); it; ++it)
00451     \{
00452       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = it.index();
00453       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} r = it.row();
00454       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} c = it.col();
00455       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} ip = perm ? perm[i] : i;
00456       \textcolor{keywordflow}{if}(Mode==(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}|\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}))
00457         count[StorageOrderMatch ? jp : ip]++;
00458       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(r==c)
00459         count[ip]++;
00460       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(( Mode==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} && r>c) || ( Mode==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper} && r<c))
00461       \{
00462         count[ip]++;
00463         count[jp]++;
00464       \}
00465     \}
00466   \}
00467   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nnz = count.sum();
00468   
00469   \textcolor{comment}{// reserve space}
00470   dest.resizeNonZeros(nnz);
00471   dest.outerIndexPtr()[0] = 0;
00472   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<size; ++j)
00473     dest.outerIndexPtr()[j+1] = dest.outerIndexPtr()[j] + count[j];
00474   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<size; ++j)
00475     count[j] = dest.outerIndexPtr()[j];
00476   
00477   \textcolor{comment}{// copy data}
00478   \textcolor{keywordflow}{for}(StorageIndex j = 0; j<size; ++j)
00479   \{
00480     \textcolor{keywordflow}{for}(MatIterator it(matEval,j); it; ++it)
00481     \{
00482       StorageIndex i = internal::convert\_index<StorageIndex>(it.index());
00483       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} r = it.row();
00484       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} c = it.col();
00485       
00486       StorageIndex jp = perm ? perm[j] : j;
00487       StorageIndex ip = perm ? perm[i] : i;
00488       
00489       \textcolor{keywordflow}{if}(Mode==(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}|\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}))
00490       \{
00491         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = count[StorageOrderMatch ? jp : ip]++;
00492         dest.innerIndexPtr()[k] = StorageOrderMatch ? ip : jp;
00493         dest.valuePtr()[k] = it.value();
00494       \}
00495       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(r==c)
00496       \{
00497         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = count[ip]++;
00498         dest.innerIndexPtr()[k] = ip;
00499         dest.valuePtr()[k] = it.value();
00500       \}
00501       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(( (Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower})==Lower && r>c) || ( (Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper})==Upper && r<c))
00502       \{
00503         \textcolor{keywordflow}{if}(!StorageOrderMatch)
00504           \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(ip,jp);
00505         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = count[jp]++;
00506         dest.innerIndexPtr()[k] = ip;
00507         dest.valuePtr()[k] = it.value();
00508         k = count[ip]++;
00509         dest.innerIndexPtr()[k] = jp;
00510         dest.valuePtr()[k] = numext::conj(it.value());
00511       \}
00512     \}
00513   \}
00514 \}
00515 
00516 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} \_SrcMode,\textcolor{keywordtype}{int} \_DstMode,\textcolor{keyword}{typename} MatrixType,\textcolor{keywordtype}{int} DstOrder>
00517 \textcolor{keywordtype}{void} permute\_symm\_to\_symm(\textcolor{keyword}{const} MatrixType& mat, 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::StorageIndex>}
      & \_dest, \textcolor{keyword}{const} \textcolor{keyword}{typename} MatrixType::StorageIndex* perm)
00518 \{
00519   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00520   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00521   \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar,DstOrder,StorageIndex>}& dest(\_dest.derived(
      ));
00522   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<StorageIndex,Dynamic,1>} VectorI;
00523   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<MatrixType>} MatEval;
00524   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{evaluator<MatrixType>::InnerIterator} MatIterator;
00525 
00526   \textcolor{keyword}{enum} \{
00527     SrcOrder = MatrixType::IsRowMajor ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},
00528     StorageOrderMatch = int(SrcOrder) == int(DstOrder),
00529     DstMode = DstOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? (\_DstMode==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper} ? \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} : 
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}) : \_DstMode,
00530     SrcMode = SrcOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? (\_SrcMode==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper} ? \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} : 
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}) : \_SrcMode
00531   \};
00532 
00533   MatEval matEval(mat);
00534   
00535   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = mat.rows();
00536   VectorI count(size);
00537   count.setZero();
00538   dest.resize(size,size);
00539   \textcolor{keywordflow}{for}(StorageIndex j = 0; j<size; ++j)
00540   \{
00541     StorageIndex jp = perm ? perm[j] : j;
00542     \textcolor{keywordflow}{for}(MatIterator it(matEval,j); it; ++it)
00543     \{
00544       StorageIndex i = it.index();
00545       \textcolor{keywordflow}{if}((\textcolor{keywordtype}{int}(SrcMode)==\textcolor{keywordtype}{int}(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) && i<j) || (\textcolor{keywordtype}{int}(SrcMode)==\textcolor{keywordtype}{int}(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}) && i>j))
00546         \textcolor{keywordflow}{continue};
00547                   
00548       StorageIndex ip = perm ? perm[i] : i;
00549       count[int(DstMode)==int(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) ? (std::min)(ip,jp) : (std::max)(ip,jp)]++;
00550     \}
00551   \}
00552   dest.outerIndexPtr()[0] = 0;
00553   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<size; ++j)
00554     dest.outerIndexPtr()[j+1] = dest.outerIndexPtr()[j] + count[j];
00555   dest.resizeNonZeros(dest.outerIndexPtr()[size]);
00556   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<size; ++j)
00557     count[j] = dest.outerIndexPtr()[j];
00558   
00559   \textcolor{keywordflow}{for}(StorageIndex j = 0; j<size; ++j)
00560   \{
00561     
00562     \textcolor{keywordflow}{for}(MatIterator it(matEval,j); it; ++it)
00563     \{
00564       StorageIndex i = it.index();
00565       \textcolor{keywordflow}{if}((\textcolor{keywordtype}{int}(SrcMode)==\textcolor{keywordtype}{int}(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) && i<j) || (\textcolor{keywordtype}{int}(SrcMode)==\textcolor{keywordtype}{int}(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}) && i>j))
00566         \textcolor{keywordflow}{continue};
00567                   
00568       StorageIndex jp = perm ? perm[j] : j;
00569       StorageIndex ip = perm? perm[i] : i;
00570       
00571       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = count[int(DstMode)==int(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) ? (std::min)(ip,jp) : (std::max)(ip,jp)]++;
00572       dest.innerIndexPtr()[k] = int(DstMode)==int(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) ? (std::max)(ip,jp) : (std::min)(ip,jp);
00573       
00574       \textcolor{keywordflow}{if}(!StorageOrderMatch) \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(ip,jp);
00575       \textcolor{keywordflow}{if}( ((\textcolor{keywordtype}{int}(DstMode)==\textcolor{keywordtype}{int}(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) && ip<jp) || (\textcolor{keywordtype}{int}(DstMode)==\textcolor{keywordtype}{int}(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}) && ip>jp)))
00576         dest.valuePtr()[k] = numext::conj(it.value());
00577       \textcolor{keywordflow}{else}
00578         dest.valuePtr()[k] = it.value();
00579     \}
00580   \}
00581 \}
00582 
00583 \}
00584 
00585 \textcolor{comment}{// TODO implement twists in a more evaluator friendly fashion}
00586 
00587 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00588 
00589 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} Mode>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00590}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_sparse_symmetric_permutation_product_3_01_matrix_type_00_01_mode_01_4_01_4}{00590} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_sparse_symmetric_permutation_product}{SparseSymmetricPermutationProduct}<MatrixType,Mode> > :
       \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<MatrixType> \{
00591 \};
00592 
00593 \}
00594 
00595 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType,\textcolor{keywordtype}{int} Mode>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00596}\hyperlink{class_eigen_1_1_sparse_symmetric_permutation_product}{00596} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_sparse_symmetric_permutation_product}{SparseSymmetricPermutationProduct}
00597   : \textcolor{keyword}{public} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase}<SparseSymmetricPermutationProduct<MatrixType,Mode> >
00598 \{
00599   \textcolor{keyword}{public}:
00600     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00601     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::StorageIndex StorageIndex;
00602     \textcolor{keyword}{enum} \{
00603       RowsAtCompileTime = 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<SparseSymmetricPermutationProduct>::RowsAtCompileTime}
      ,
00604       ColsAtCompileTime = 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{internal::traits<SparseSymmetricPermutationProduct>::ColsAtCompileTime}
00605     \};
00606   \textcolor{keyword}{protected}:
00607     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{PermutationMatrix<Dynamic,Dynamic,StorageIndex>} 
      \hyperlink{group___core___module}{Perm};
00608   \textcolor{keyword}{public}:
00609     \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<StorageIndex,Dynamic,1>} \hyperlink{group___core___module}{VectorI};
00610     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Nested MatrixTypeNested;
00611     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<MatrixTypeNested>::type}
       \hyperlink{group___sparse_core___module}{NestedExpression};
00612     
00613     \hyperlink{class_eigen_1_1_sparse_symmetric_permutation_product}{SparseSymmetricPermutationProduct}(\textcolor{keyword}{const} MatrixType& mat, \textcolor{keyword}{const} Perm& 
      perm)
00614       : m\_matrix(mat), m\_perm(perm)
00615     \{\}
00616     
00617     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix.rows(); \}
00618     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix.cols(); \}
00619         
00620     \textcolor{keyword}{const} NestedExpression& matrix()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_matrix; \}
00621     \textcolor{keyword}{const} Perm& perm()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_perm; \}
00622     
00623   \textcolor{keyword}{protected}:
00624     MatrixTypeNested m\_matrix;
00625     \textcolor{keyword}{const} Perm& m\_perm;
00626 
00627 \};
00628 
00629 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00630   
00631 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DstXprType, \textcolor{keyword}{typename} MatrixType, \textcolor{keywordtype}{int} Mode, \textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2_eigen_2src_2_sparse_core_2_sparse_self_adjoint_view_8h_source_l00632}\hyperlink{struct_eigen_1_1internal_1_1_assignment_3_01_dst_xpr_type_00_01_sparse_symmetric_permutation_pro69955201e4d84b32d17d1959c46119e9}{00632} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_assignment}{Assignment}<DstXprType, \hyperlink{class_eigen_1_1_sparse_symmetric_permutation_product}{SparseSymmetricPermutationProduct}<
      MatrixType,Mode>, \hyperlink{namespaceinternal}{internal}::\hyperlink{struct_eigen_1_1internal_1_1assign__op}{assign\_op}<Scalar,typename MatrixType::Scalar>, 
      \hyperlink{struct_eigen_1_1internal_1_1_sparse2_sparse}{Sparse2Sparse}>
00633 \{
00634   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_sparse_symmetric_permutation_product}{SparseSymmetricPermutationProduct<MatrixType,Mode>}
       \hyperlink{class_eigen_1_1_sparse_symmetric_permutation_product}{SrcXprType};
00635   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DstXprType::StorageIndex DstIndex;
00636   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Options>
00637   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar,Options,DstIndex>} &dst, \textcolor{keyword}{const} 
      SrcXprType &src, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<Scalar,typename MatrixType::Scalar>}
       &)
00638   \{
00639     \textcolor{comment}{// internal::permute\_symm\_to\_fullsymm<Mode>(m\_matrix,\_dest,m\_perm.indices().data());}
00640     
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar,(Options&RowMajor)==RowMajor ? ColMajor : RowMajor, DstIndex>}
       tmp;
00641     internal::permute\_symm\_to\_fullsymm<Mode>(src.matrix(),tmp,src.perm().\hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}().data());
00642     dst = tmp;
00643   \}
00644   
00645   \textcolor{keyword}{template}<\textcolor{keyword}{typename} DestType,\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} DestMode>
00646   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView<DestType,DestMode>}& dst, \textcolor{keyword}{
      const} SrcXprType &src, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1assign__op}{internal::assign\_op<Scalar,typename MatrixType::Scalar>}
       &)
00647   \{
00648     internal::permute\_symm\_to\_symm<Mode,DestMode>(src.matrix(),dst.matrix(),src.perm().
      \hyperlink{group___core___module_a2f1ab379207fcd1ceb33941e25cf50c2}{indices}().data());
00649   \}
00650 \};
00651 
00652 \} \textcolor{comment}{// end namespace internal}
00653 
00654 \} \textcolor{comment}{// end namespace Eigen}
00655 
00656 \textcolor{preprocessor}{#endif // EIGEN\_SPARSE\_SELFADJOINTVIEW\_H}
\end{DoxyCode}
