\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_least_square_conjugate_gradient_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Iterative\+Linear\+Solvers/\+Least\+Square\+Conjugate\+Gradient.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_least_square_conjugate_gradient_8h_source}\index{Least\+Square\+Conjugate\+Gradient.\+h@{Least\+Square\+Conjugate\+Gradient.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_LEAST\_SQUARE\_CONJUGATE\_GRADIENT\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_LEAST\_SQUARE\_CONJUGATE\_GRADIENT\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00026 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Dest, \textcolor{keyword}{typename} Preconditioner>
00027 EIGEN\_DONT\_INLINE
00028 \textcolor{keywordtype}{void} least\_square\_conjugate\_gradient(\textcolor{keyword}{const} MatrixType& mat, \textcolor{keyword}{const} Rhs& rhs, Dest& x,
00029                                      \textcolor{keyword}{const} Preconditioner& precond, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& iters,
00030                                      \textcolor{keyword}{typename} Dest::RealScalar& tol\_error)
00031 \{
00032   \textcolor{keyword}{using} std::sqrt;
00033   \textcolor{keyword}{using} std::abs;
00034   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Dest::RealScalar RealScalar;
00035   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Dest::Scalar Scalar;
00036   \textcolor{keyword}{typedef} Matrix<Scalar,Dynamic,1> \hyperlink{struct_vector_type}{VectorType};
00037   
00038   RealScalar tol = tol\_error;
00039   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} maxIters = iters;
00040   
00041   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m = mat.rows(), n = mat.cols();
00042 
00043   VectorType residual        = rhs - mat * x;
00044   VectorType normal\_residual = mat.adjoint() * residual;
00045 
00046   RealScalar rhsNorm2 = (mat.adjoint()*rhs).squaredNorm();
00047   \textcolor{keywordflow}{if}(rhsNorm2 == 0) 
00048   \{
00049     x.setZero();
00050     iters = 0;
00051     tol\_error = 0;
00052     \textcolor{keywordflow}{return};
00053   \}
00054   RealScalar threshold = tol*tol*rhsNorm2;
00055   RealScalar residualNorm2 = normal\_residual.squaredNorm();
00056   \textcolor{keywordflow}{if} (residualNorm2 < threshold)
00057   \{
00058     iters = 0;
00059     tol\_error = sqrt(residualNorm2 / rhsNorm2);
00060     \textcolor{keywordflow}{return};
00061   \}
00062   
00063   VectorType p(n);
00064   p = precond.solve(normal\_residual);                         \textcolor{comment}{// initial search direction}
00065 
00066   VectorType z(n), tmp(m);
00067   RealScalar absNew = numext::real(normal\_residual.dot(p));  \textcolor{comment}{// the square of the absolute value of r
       scaled by invM}
00068   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0;
00069   \textcolor{keywordflow}{while}(i < maxIters)
00070   \{
00071     tmp.noalias() = mat * p;
00072 
00073     Scalar alpha = absNew / tmp.squaredNorm();      \textcolor{comment}{// the amount we travel on dir}
00074     x += alpha * p;                                 \textcolor{comment}{// update solution}
00075     residual -= alpha * tmp;                        \textcolor{comment}{// update residual}
00076     normal\_residual = mat.adjoint() * residual;     \textcolor{comment}{// update residual of the normal equation}
00077     
00078     residualNorm2 = normal\_residual.squaredNorm();
00079     \textcolor{keywordflow}{if}(residualNorm2 < threshold)
00080       \textcolor{keywordflow}{break};
00081     
00082     z = precond.solve(normal\_residual);             \textcolor{comment}{// approximately solve for "A'A z = normal\_residual"}
00083 
00084     RealScalar absOld = absNew;
00085     absNew = numext::real(normal\_residual.dot(z));  \textcolor{comment}{// update the absolute value of r}
00086     RealScalar beta = absNew / absOld;              \textcolor{comment}{// calculate the Gram-Schmidt value used to create the
       new search direction}
00087     p = z + beta * p;                               \textcolor{comment}{// update search direction}
00088     i++;
00089   \}
00090   tol\_error = sqrt(residualNorm2 / rhsNorm2);
00091   iters = i;
00092 \}
00093 
00094 \}
00095 
00096 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \_MatrixType,
00097           \textcolor{keyword}{typename} \_Preconditioner = LeastSquareDiagonalPreconditioner<typename \_MatrixType::Scalar> >
00098 \textcolor{keyword}{class }LeastSquaresConjugateGradient;
00099 
00100 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00101 
00102 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_Preconditioner>
00103 \textcolor{keyword}{struct }traits<LeastSquaresConjugateGradient<\_MatrixType,\_Preconditioner> >
00104 \{
00105   \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00106   \textcolor{keyword}{typedef} \_Preconditioner Preconditioner;
00107 \};
00108 
00109 \}
00110 
00148 \textcolor{keyword}{template}< \textcolor{keyword}{typename} \_MatrixType, \textcolor{keyword}{typename} \_Preconditioner>
00149 \textcolor{keyword}{class }LeastSquaresConjugateGradient : \textcolor{keyword}{public} IterativeSolverBase<LeastSquaresConjugateGradient<\_MatrixType,
      \_Preconditioner> >
00150 \{
00151   \textcolor{keyword}{typedef} IterativeSolverBase<LeastSquaresConjugateGradient> Base;
00152   \textcolor{keyword}{using} Base::matrix;
00153   \textcolor{keyword}{using} Base::m\_error;
00154   \textcolor{keyword}{using} Base::m\_iterations;
00155   \textcolor{keyword}{using} Base::m\_info;
00156   \textcolor{keyword}{using} Base::m\_isInitialized;
00157 \textcolor{keyword}{public}:
00158   \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00159   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00160   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00161   \textcolor{keyword}{typedef} \_Preconditioner Preconditioner;
00162 
00163 \textcolor{keyword}{public}:
00164 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_least_square_conjugate_gradient_8h_source_l00166}\hyperlink{group___iterative_linear_solvers___module_ace69f423fcc1f8960d0e2de0667447c9}{00166}   \hyperlink{group___iterative_linear_solvers___module_ace69f423fcc1f8960d0e2de0667447c9}{LeastSquaresConjugateGradient}() : Base() \{\}
00167 
00178   \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixDerived>
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_iterative_linear_solvers_2_least_square_conjugate_gradient_8h_source_l00179}\hyperlink{group___iterative_linear_solvers___module_a91c4f2edc20f93cee9b721165937fb99}{00179}   \textcolor{keyword}{explicit} \hyperlink{group___iterative_linear_solvers___module_a91c4f2edc20f93cee9b721165937fb99}{LeastSquaresConjugateGradient}(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<MatrixDerived>}& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}) : Base(A.derived()) \{\}
00180 
00181   ~\hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_least_squares_conjugate_gradient}{LeastSquaresConjugateGradient}() \{\}
00182 
00184   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs,\textcolor{keyword}{typename} Dest>
00185   \textcolor{keywordtype}{void} \_solve\_with\_guess\_impl(\textcolor{keyword}{const} Rhs& b, Dest& x)\textcolor{keyword}{ const}
00186 \textcolor{keyword}{  }\{
00187     m\_iterations = Base::maxIterations();
00188     m\_error = Base::m\_tolerance;
00189 
00190     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<b.cols(); ++j)
00191     \{
00192       m\_iterations = Base::maxIterations();
00193       m\_error = Base::m\_tolerance;
00194 
00195       \textcolor{keyword}{typename} Dest::ColXpr xj(x,j);
00196       internal::least\_square\_conjugate\_gradient(matrix(), b.col(j), xj, Base::m\_preconditioner, 
      m\_iterations, m\_error);
00197     \}
00198 
00199     m\_isInitialized = \textcolor{keyword}{true};
00200     m\_info = m\_error <= Base::m\_tolerance ? \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} : \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8}{NoConvergence};
00201   \}
00202   
00204   \textcolor{keyword}{using} Base::\_solve\_impl;
00205   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Rhs,\textcolor{keyword}{typename} Dest>
00206   \textcolor{keywordtype}{void} \_solve\_impl(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>}& b, Dest& x)\textcolor{keyword}{ const}
00207 \textcolor{keyword}{  }\{
00208     x.setZero();
00209     \_solve\_with\_guess\_impl(b.derived(),x);
00210   \}
00211 
00212 \};
00213 
00214 \} \textcolor{comment}{// end namespace Eigen}
00215 
00216 \textcolor{preprocessor}{#endif // EIGEN\_LEAST\_SQUARE\_CONJUGATE\_GRADIENT\_H}
\end{DoxyCode}
