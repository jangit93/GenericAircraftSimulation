\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_alti_vec_2_math_functions_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/arch/\+Alti\+Vec/\+Math\+Functions.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_alti_vec_2_math_functions_8h_source}\index{Math\+Functions.\+h@{Math\+Functions.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2007 Julien Pommier}
00005 \textcolor{comment}{// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{// Copyright (C) 2016 Konstantinos Margaritis <markos@freevec.org>}
00007 \textcolor{comment}{//}
00008 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00009 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00010 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00011 
00012 \textcolor{comment}{/* The sin, cos, exp, and log functions of this file come from}
00013 \textcolor{comment}{ * Julien Pommier's sse math library: http://gruntthepeon.free.fr/ssemath/}
00014 \textcolor{comment}{ */}
00015 
00016 \textcolor{preprocessor}{#ifndef EIGEN\_MATH\_FUNCTIONS\_ALTIVEC\_H}
00017 \textcolor{preprocessor}{#define EIGEN\_MATH\_FUNCTIONS\_ALTIVEC\_H}
00018 
00019 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00020 
00021 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00022 
00023 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(1 , 1.0f);
00024 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(half, 0.5f);
00025 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4i(0x7f, 0x7f);
00026 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4i(23, 23);
00027 
00028 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(inv\_mant\_mask, ~0x7f800000);
00029 
00030 \textcolor{comment}{/* the smallest non denormalized float number */}
00031 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(min\_norm\_pos,  0x00800000);
00032 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(minus\_inf,     0xff800000); \textcolor{comment}{// -1.f/0.f}
00033 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f\_FROM\_INT(minus\_nan,     0xffffffff);
00034   
00035 \textcolor{comment}{/* natural logarithm computed for 4 simultaneous float}
00036 \textcolor{comment}{  return NaN for x <= 0}
00037 \textcolor{comment}{*/}
00038 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_SQRTHF, 0.707106781186547524f);
00039 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p0, 7.0376836292E-2f);
00040 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p1, - 1.1514610310E-1f);
00041 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p2, 1.1676998740E-1f);
00042 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p3, - 1.2420140846E-1f);
00043 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p4, + 1.4249322787E-1f);
00044 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p5, - 1.6668057665E-1f);
00045 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p6, + 2.0000714765E-1f);
00046 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p7, - 2.4999993993E-1f);
00047 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_p8, + 3.3333331174E-1f);
00048 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_q1, -2.12194440e-4f);
00049 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_log\_q2, 0.693359375f);
00050 
00051 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(exp\_hi,  88.3762626647950f);
00052 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(exp\_lo, -88.3762626647949f);
00053 
00054 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_LOG2EF, 1.44269504088896341f);
00055 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_C1, 0.693359375f);
00056 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_C2, -2.12194440e-4f);
00057 
00058 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_p0, 1.9875691500E-4f);
00059 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_p1, 1.3981999507E-3f);
00060 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_p2, 8.3334519073E-3f);
00061 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_p3, 4.1665795894E-2f);
00062 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_p4, 1.6666665459E-1f);
00063 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet4f(cephes\_exp\_p5, 5.0000001201E-1f);
00064 
00065 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00066 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(1 , 1.0);
00067 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(2 , 2.0);
00068 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(half, 0.5);
00069 
00070 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(exp\_hi,  709.437);
00071 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(exp\_lo, -709.436139303);
00072 
00073 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_LOG2EF, 1.4426950408889634073599);
00074 
00075 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_p0, 1.26177193074810590878e-4);
00076 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_p1, 3.02994407707441961300e-2);
00077 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_p2, 9.99999999999999999910e-1);
00078 
00079 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_q0, 3.00198505138664455042e-6);
00080 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_q1, 2.52448340349684104192e-3);
00081 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_q2, 2.27265548208155028766e-1);
00082 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_q3, 2.00000000000000000009e0);
00083 
00084 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_C1, 0.693145751953125);
00085 \textcolor{keyword}{static} \_EIGEN\_DECLARE\_CONST\_Packet2d(cephes\_exp\_C2, 1.42860682030941723212e-6);
00086 
00087 \textcolor{preprocessor}{#ifdef \_\_POWER8\_VECTOR\_\_}
00088 \textcolor{keyword}{static} Packet2l p2l\_1023 = \{ 1023, 1023 \};
00089 \textcolor{keyword}{static} Packet2ul p2ul\_52 = \{ 52, 52 \};
00090 \textcolor{preprocessor}{#endif}
00091 
00092 \textcolor{preprocessor}{#endif}
00093 
00094 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00095 Packet4f plog<Packet4f>(\textcolor{keyword}{const} Packet4f& \_x)
00096 \{
00097   Packet4f x = \_x;
00098 
00099   Packet4i emm0;
00100 
00101   \textcolor{comment}{/* isvalid\_mask is 0 if x < 0 or x is NaN. */}
00102   Packet4ui isvalid\_mask = \textcolor{keyword}{reinterpret\_cast<}Packet4ui\textcolor{keyword}{>}(vec\_cmpge(x, p4f\_ZERO));
00103   Packet4ui iszero\_mask = \textcolor{keyword}{reinterpret\_cast<}Packet4ui\textcolor{keyword}{>}(vec\_cmpeq(x, p4f\_ZERO));
00104 
00105   x = pmax(x, p4f\_min\_norm\_pos);  \textcolor{comment}{/* cut off denormalized stuff */}
00106   emm0 = vec\_sr(reinterpret\_cast<Packet4i>(x),
00107                 reinterpret\_cast<Packet4ui>(p4i\_23));
00108 
00109   \textcolor{comment}{/* keep only the fractional part */}
00110   x = pand(x, p4f\_inv\_mant\_mask);
00111   x = por(x, p4f\_half);
00112 
00113   emm0 = psub(emm0, p4i\_0x7f);
00114   Packet4f e = padd(vec\_ctf(emm0, 0), p4f\_1);
00115 
00116   \textcolor{comment}{/* part2:}
00117 \textcolor{comment}{     if( x < SQRTHF ) \{}
00118 \textcolor{comment}{       e -= 1;}
00119 \textcolor{comment}{       x = x + x - 1.0;}
00120 \textcolor{comment}{     \} else \{ x = x - 1.0; \}}
00121 \textcolor{comment}{  */}
00122   Packet4f mask = \textcolor{keyword}{reinterpret\_cast<}Packet4f\textcolor{keyword}{>}(vec\_cmplt(x, p4f\_cephes\_SQRTHF));
00123   Packet4f tmp = pand(x, mask);
00124   x = psub(x, p4f\_1);
00125   e = psub(e, pand(p4f\_1, mask));
00126   x = padd(x, tmp);
00127 
00128   Packet4f x2 = pmul(x,x);
00129   Packet4f x3 = pmul(x2,x);
00130 
00131   Packet4f y, y1, y2;
00132   y  = pmadd(p4f\_cephes\_log\_p0, x, p4f\_cephes\_log\_p1);
00133   y1 = pmadd(p4f\_cephes\_log\_p3, x, p4f\_cephes\_log\_p4);
00134   y2 = pmadd(p4f\_cephes\_log\_p6, x, p4f\_cephes\_log\_p7);
00135   y  = pmadd(y , x, p4f\_cephes\_log\_p2);
00136   y1 = pmadd(y1, x, p4f\_cephes\_log\_p5);
00137   y2 = pmadd(y2, x, p4f\_cephes\_log\_p8);
00138   y = pmadd(y, x3, y1);
00139   y = pmadd(y, x3, y2);
00140   y = pmul(y, x3);
00141 
00142   y1 = pmul(e, p4f\_cephes\_log\_q1);
00143   tmp = pmul(x2, p4f\_half);
00144   y = padd(y, y1);
00145   x = psub(x, tmp);
00146   y2 = pmul(e, p4f\_cephes\_log\_q2);
00147   x = padd(x, y);
00148   x = padd(x, y2);
00149   \textcolor{comment}{// negative arg will be NAN, 0 will be -INF}
00150   x = vec\_sel(x, p4f\_minus\_inf, iszero\_mask);
00151   x = vec\_sel(p4f\_minus\_nan, x, isvalid\_mask);
00152   \textcolor{keywordflow}{return} x;
00153 \}
00154 
00155 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00156 Packet4f pexp<Packet4f>(\textcolor{keyword}{const} Packet4f& \_x)
00157 \{
00158   Packet4f x = \_x;
00159 
00160   Packet4f tmp, fx;
00161   Packet4i emm0;
00162 
00163   \textcolor{comment}{// clamp x}
00164   x = pmax(pmin(x, p4f\_exp\_hi), p4f\_exp\_lo);
00165 
00166   \textcolor{comment}{// express exp(x) as exp(g + n*log(2))}
00167   fx = pmadd(x, p4f\_cephes\_LOG2EF, p4f\_half);
00168 
00169   fx = pfloor(fx);
00170 
00171   tmp = pmul(fx, p4f\_cephes\_exp\_C1);
00172   Packet4f z = pmul(fx, p4f\_cephes\_exp\_C2);
00173   x = psub(x, tmp);
00174   x = psub(x, z);
00175 
00176   z = pmul(x,x);
00177 
00178   Packet4f y = p4f\_cephes\_exp\_p0;
00179   y = pmadd(y, x, p4f\_cephes\_exp\_p1);
00180   y = pmadd(y, x, p4f\_cephes\_exp\_p2);
00181   y = pmadd(y, x, p4f\_cephes\_exp\_p3);
00182   y = pmadd(y, x, p4f\_cephes\_exp\_p4);
00183   y = pmadd(y, x, p4f\_cephes\_exp\_p5);
00184   y = pmadd(y, z, x);
00185   y = padd(y, p4f\_1);
00186 
00187   \textcolor{comment}{// build 2^n}
00188   emm0 = vec\_cts(fx, 0);
00189   emm0 = vec\_add(emm0, p4i\_0x7f);
00190   emm0 = vec\_sl(emm0, reinterpret\_cast<Packet4ui>(p4i\_23));
00191 
00192   \textcolor{comment}{// Altivec's max & min operators just drop silent NaNs. Check NaNs in }
00193   \textcolor{comment}{// inputs and return them unmodified.}
00194   Packet4ui isnumber\_mask = \textcolor{keyword}{reinterpret\_cast<}Packet4ui\textcolor{keyword}{>}(vec\_cmpeq(\_x, \_x));
00195   \textcolor{keywordflow}{return} vec\_sel(\_x, pmax(pmul(y, reinterpret\_cast<Packet4f>(emm0)), \_x),
00196                  isnumber\_mask);
00197 \}
00198 
00199 \textcolor{preprocessor}{#ifndef EIGEN\_COMP\_CLANG}
00200 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00201 Packet4f prsqrt<Packet4f>(\textcolor{keyword}{const} Packet4f& x)
00202 \{
00203   \textcolor{keywordflow}{return}  vec\_rsqrt(x);
00204 \}
00205 \textcolor{preprocessor}{#endif}
00206 
00207 \textcolor{preprocessor}{#ifdef \_\_VSX\_\_}
00208 \textcolor{preprocessor}{#ifndef EIGEN\_COMP\_CLANG}
00209 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00210 Packet2d prsqrt<Packet2d>(\textcolor{keyword}{const} Packet2d& x)
00211 \{
00212   \textcolor{keywordflow}{return}  vec\_rsqrt(x);
00213 \}
00214 \textcolor{preprocessor}{#endif}
00215 
00216 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00217 Packet4f psqrt<Packet4f>(\textcolor{keyword}{const} Packet4f& x)
00218 \{
00219   \textcolor{keywordflow}{return}  vec\_sqrt(x);
00220 \}
00221 
00222 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00223 Packet2d psqrt<Packet2d>(\textcolor{keyword}{const} Packet2d& x)
00224 \{
00225   \textcolor{keywordflow}{return}  vec\_sqrt(x);
00226 \}
00227 
00228 \textcolor{comment}{// VSX support varies between different compilers and even different}
00229 \textcolor{comment}{// versions of the same compiler.  For gcc version >= 4.9.3, we can use}
00230 \textcolor{comment}{// vec\_cts to efficiently convert Packet2d to Packet2l.  Otherwise, use}
00231 \textcolor{comment}{// a slow version that works with older compilers. }
00232 \textcolor{comment}{// Update: apparently vec\_cts/vec\_ctf intrinsics for 64-bit doubles}
00233 \textcolor{comment}{// are buggy, https://gcc.gnu.org/bugzilla/show\_bug.cgi?id=70963}
00234 \textcolor{keyword}{static} \textcolor{keyword}{inline} Packet2l ConvertToPacket2l(\textcolor{keyword}{const} Packet2d& x) \{
00235 \textcolor{preprocessor}{#if EIGEN\_GNUC\_AT\_LEAST(5, 4) || \(\backslash\)}
00236 \textcolor{preprocessor}{    (EIGEN\_GNUC\_AT(6, 1) && \_\_GNUC\_PATCHLEVEL\_\_ >= 1)}
00237   \textcolor{keywordflow}{return} vec\_cts(x, 0);    \textcolor{comment}{// TODO: check clang version.}
00238 \textcolor{preprocessor}{#else}
00239   \textcolor{keywordtype}{double} tmp[2];
00240   memcpy(tmp, &x, \textcolor{keyword}{sizeof}(tmp));
00241   Packet2l l = \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(tmp[0]),
00242                  static\_cast<long long>(tmp[1]) \};
00243   \textcolor{keywordflow}{return} l;
00244 \textcolor{preprocessor}{#endif}
00245 \}
00246 
00247 \textcolor{keyword}{template}<> EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED
00248 Packet2d pexp<Packet2d>(\textcolor{keyword}{const} Packet2d& \_x)
00249 \{
00250   Packet2d x = \_x;
00251 
00252   Packet2d tmp, fx;
00253   Packet2l emm0;
00254 
00255   \textcolor{comment}{// clamp x}
00256   x = pmax(pmin(x, p2d\_exp\_hi), p2d\_exp\_lo);
00257 
00258   \textcolor{comment}{/* express exp(x) as exp(g + n*log(2)) */}
00259   fx = pmadd(x, p2d\_cephes\_LOG2EF, p2d\_half);
00260 
00261   fx = pfloor(fx);
00262 
00263   tmp = pmul(fx, p2d\_cephes\_exp\_C1);
00264   Packet2d z = pmul(fx, p2d\_cephes\_exp\_C2);
00265   x = psub(x, tmp);
00266   x = psub(x, z);
00267 
00268   Packet2d x2 = pmul(x,x);
00269 
00270   Packet2d px = p2d\_cephes\_exp\_p0;
00271   px = pmadd(px, x2, p2d\_cephes\_exp\_p1);
00272   px = pmadd(px, x2, p2d\_cephes\_exp\_p2);
00273   px = pmul (px, x);
00274 
00275   Packet2d qx = p2d\_cephes\_exp\_q0;
00276   qx = pmadd(qx, x2, p2d\_cephes\_exp\_q1);
00277   qx = pmadd(qx, x2, p2d\_cephes\_exp\_q2);
00278   qx = pmadd(qx, x2, p2d\_cephes\_exp\_q3);
00279 
00280   x = pdiv(px,psub(qx,px));
00281   x = pmadd(p2d\_2,x,p2d\_1);
00282 
00283   \textcolor{comment}{// build 2^n}
00284   emm0 = ConvertToPacket2l(fx);
00285 
00286 \textcolor{preprocessor}{#ifdef \_\_POWER8\_VECTOR\_\_ }
00287   emm0 = vec\_add(emm0, p2l\_1023);
00288   emm0 = vec\_sl(emm0, p2ul\_52);
00289 \textcolor{preprocessor}{#else}
00290   \textcolor{comment}{// Code is a bit complex for POWER7.  There is actually a}
00291   \textcolor{comment}{// vec\_xxsldi intrinsic but it is not supported by some gcc versions.}
00292   \textcolor{comment}{// So we shift (52-32) bits and do a word swap with zeros.}
00293   \_EIGEN\_DECLARE\_CONST\_Packet4i(1023, 1023);
00294   \_EIGEN\_DECLARE\_CONST\_Packet4i(20, 20);    \textcolor{comment}{// 52 - 32}
00295 
00296   Packet4i emm04i = \textcolor{keyword}{reinterpret\_cast<}Packet4i\textcolor{keyword}{>}(emm0);
00297   emm04i = vec\_add(emm04i, p4i\_1023);
00298   emm04i = vec\_sl(emm04i, reinterpret\_cast<Packet4ui>(p4i\_20));
00299   \textcolor{keyword}{static} \textcolor{keyword}{const} Packet16uc perm = \{
00300     0x14, 0x15, 0x16, 0x17, 0x00, 0x01, 0x02, 0x03, 
00301     0x1c, 0x1d, 0x1e, 0x1f, 0x08, 0x09, 0x0a, 0x0b \};
00302 \textcolor{preprocessor}{#ifdef  \_BIG\_ENDIAN}
00303   emm0 = \textcolor{keyword}{reinterpret\_cast<}Packet2l\textcolor{keyword}{>}(vec\_perm(p4i\_ZERO, emm04i, perm));
00304 \textcolor{preprocessor}{#else}
00305   emm0 = \textcolor{keyword}{reinterpret\_cast<}Packet2l\textcolor{keyword}{>}(vec\_perm(emm04i, p4i\_ZERO, perm));
00306 \textcolor{preprocessor}{#endif}
00307 
00308 \textcolor{preprocessor}{#endif}
00309 
00310   \textcolor{comment}{// Altivec's max & min operators just drop silent NaNs. Check NaNs in }
00311   \textcolor{comment}{// inputs and return them unmodified.}
00312   Packet2ul isnumber\_mask = \textcolor{keyword}{reinterpret\_cast<}Packet2ul\textcolor{keyword}{>}(vec\_cmpeq(\_x, \_x));
00313   \textcolor{keywordflow}{return} vec\_sel(\_x, pmax(pmul(x, reinterpret\_cast<Packet2d>(emm0)), \_x),
00314                  isnumber\_mask);
00315 \}
00316 \textcolor{preprocessor}{#endif}
00317 
00318 \}  \textcolor{comment}{// end namespace internal}
00319 
00320 \}  \textcolor{comment}{// end namespace Eigen}
00321 
00322 \textcolor{preprocessor}{#endif  // EIGEN\_MATH\_FUNCTIONS\_ALTIVEC\_H}
\end{DoxyCode}
