\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u___memory_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+L\+U/\+Sparse\+L\+U\+\_\+\+Memory.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u___memory_8h_source}\index{Sparse\+L\+U\+\_\+\+Memory.\+h@{Sparse\+L\+U\+\_\+\+Memory.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{comment}{/* }
00011 \textcolor{comment}{ }
00012 \textcolor{comment}{ * NOTE: This file is the modified version of [s,d,c,z]memory.c files in SuperLU }
00013 \textcolor{comment}{ }
00014 \textcolor{comment}{ * -- SuperLU routine (version 3.1) --}
00015 \textcolor{comment}{ * Univ. of California Berkeley, Xerox Palo Alto Research Center,}
00016 \textcolor{comment}{ * and Lawrence Berkeley National Lab.}
00017 \textcolor{comment}{ * August 1, 2008}
00018 \textcolor{comment}{ *}
00019 \textcolor{comment}{ * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.}
00020 \textcolor{comment}{ *}
00021 \textcolor{comment}{ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY}
00022 \textcolor{comment}{ * EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.}
00023 \textcolor{comment}{ *}
00024 \textcolor{comment}{ * Permission is hereby granted to use or copy this program for any}
00025 \textcolor{comment}{ * purpose, provided the above notices are retained on all copies.}
00026 \textcolor{comment}{ * Permission to modify the code and to distribute modified code is}
00027 \textcolor{comment}{ * granted, provided the above notices are retained, and a notice that}
00028 \textcolor{comment}{ * the code was modified is included with the above copyright notice.}
00029 \textcolor{comment}{ */}
00030 
00031 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSELU\_MEMORY}
00032 \textcolor{preprocessor}{#define EIGEN\_SPARSELU\_MEMORY}
00033 
00034 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00035 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00036   
00037 \textcolor{keyword}{enum} \{ LUNoMarker = 3 \};
00038 \textcolor{keyword}{enum} \{emptyIdxLU = -1\};
00039 \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} LUnumTempV(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& m, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& w, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& t, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& b)
00040 \{
00041   \textcolor{keywordflow}{return} (std::max)(m, (t+b)*w);
00042 \}
00043 
00044 \textcolor{keyword}{template}< \textcolor{keyword}{typename} Scalar>
00045 \textcolor{keyword}{inline} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} LUTempSpace(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}&m, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& w)
00046 \{
00047   \textcolor{keywordflow}{return} (2*w + 4 + LUNoMarker) * m * \textcolor{keyword}{sizeof}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}) + (w + 1) * m * \textcolor{keyword}{sizeof}(Scalar);
00048 \}
00049 
00050 
00051 
00052 
00061 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} StorageIndex>
00062 \textcolor{keyword}{template} <\textcolor{keyword}{typename} VectorType>
00063 \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}  \hyperlink{group___sparse_l_u___module_acc7811f7de19ffb804cb4b1fd5288f3e}{SparseLUImpl<Scalar,StorageIndex>::expand}(
      \hyperlink{struct_vector_type}{VectorType}& vec, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& length, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nbElts, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} keep\_prev, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& num\_expansions) 
00064 \{
00065   
00066   \textcolor{keywordtype}{float} alpha = 1.5; \textcolor{comment}{// Ratio of the memory increase }
00067   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} new\_len; \textcolor{comment}{// New size of the allocated memory}
00068   
00069   \textcolor{keywordflow}{if}(num\_expansions == 0 || keep\_prev) 
00070     new\_len = length ; \textcolor{comment}{// First time allocate requested}
00071   \textcolor{keywordflow}{else} 
00072     new\_len = (std::max)(length+1,\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(alpha * length));
00073   
00074   \hyperlink{struct_vector_type}{VectorType} old\_vec; \textcolor{comment}{// Temporary vector to hold the previous values   }
00075   \textcolor{keywordflow}{if} (nbElts > 0 )
00076     old\_vec = vec.segment(0,nbElts); 
00077   
00078   \textcolor{comment}{//Allocate or expand the current vector}
00079 \textcolor{preprocessor}{#ifdef EIGEN\_EXCEPTIONS}
00080   \textcolor{keywordflow}{try}
00081 \textcolor{preprocessor}{#endif}
00082   \{
00083     vec.resize(new\_len); 
00084   \}
00085 \textcolor{preprocessor}{#ifdef EIGEN\_EXCEPTIONS}
00086   \textcolor{keywordflow}{catch}(std::bad\_alloc& )
00087 \textcolor{preprocessor}{#else}
00088   \textcolor{keywordflow}{if}(!vec.size())
00089 #endif
00090   \{
00091     \textcolor{keywordflow}{if} (!num\_expansions)
00092     \{
00093       \textcolor{comment}{// First time to allocate from LUMemInit()}
00094       \textcolor{comment}{// Let LUMemInit() deals with it.}
00095       \textcolor{keywordflow}{return} -1;
00096     \}
00097     \textcolor{keywordflow}{if} (keep\_prev)
00098     \{
00099       \textcolor{comment}{// In this case, the memory length should not not be reduced}
00100       \textcolor{keywordflow}{return} new\_len;
00101     \}
00102     \textcolor{keywordflow}{else} 
00103     \{
00104       \textcolor{comment}{// Reduce the size and increase again }
00105       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} tries = 0; \textcolor{comment}{// Number of attempts}
00106       \textcolor{keywordflow}{do} 
00107       \{
00108         alpha = (alpha + 1)/2;
00109         new\_len = (std::max)(length+1,\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(alpha * length));
00110 \textcolor{preprocessor}{#ifdef EIGEN\_EXCEPTIONS}
00111         \textcolor{keywordflow}{try}
00112 \textcolor{preprocessor}{#endif}
00113         \{
00114           vec.resize(new\_len); 
00115         \}
00116 \textcolor{preprocessor}{#ifdef EIGEN\_EXCEPTIONS}
00117         \textcolor{keywordflow}{catch}(std::bad\_alloc& )
00118 \textcolor{preprocessor}{#else}
00119         \textcolor{keywordflow}{if} (!vec.size())
00120 #endif
00121         \{
00122           tries += 1; 
00123           \textcolor{keywordflow}{if} ( tries > 10) \textcolor{keywordflow}{return} new\_len; 
00124         \}
00125       \} \textcolor{keywordflow}{while} (!vec.size());
00126     \}
00127   \}
00128   \textcolor{comment}{//Copy the previous values to the newly allocated space }
00129   \textcolor{keywordflow}{if} (nbElts > 0)
00130     vec.segment(0, nbElts) = old\_vec;   
00131    
00132   
00133   length  = new\_len;
00134   \textcolor{keywordflow}{if}(num\_expansions) ++num\_expansions;
00135   \textcolor{keywordflow}{return} 0; 
00136 \}
00137 
00150 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} StorageIndex>
00151 \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{group___sparse_l_u___module_ac018b8ed9664d4e19e34f1ff2d6c578a}{SparseLUImpl<Scalar,StorageIndex>::memInit}(
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} annz, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lwork, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} fillratio, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} panel\_size,  GlobalLU\_t& glu)
00152 \{
00153   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& num\_expansions = glu.num\_expansions; \textcolor{comment}{//No memory expansions so far}
00154   num\_expansions = 0;
00155   glu.nzumax = glu.nzlumax = (std::min)(fillratio * (annz+1) / n, m) * n; \textcolor{comment}{// estimated number of nonzeros
       in U }
00156   glu.nzlmax = (std::max)(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(4), fillratio) * (annz+1) / 4; \textcolor{comment}{// estimated  nnz in L factor}
00157   \textcolor{comment}{// Return the estimated size to the user if necessary}
00158   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} tempSpace;
00159   tempSpace = (2*panel\_size + 4 + LUNoMarker) * m * \textcolor{keyword}{sizeof}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}) + (panel\_size + 1) * m * \textcolor{keyword}{sizeof}(
      Scalar);
00160   \textcolor{keywordflow}{if} (lwork == emptyIdxLU) 
00161   \{
00162     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} estimated\_size;
00163     estimated\_size = (5 * n + 5) * \textcolor{keyword}{sizeof}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index})  + tempSpace
00164                     + (glu.nzlmax + glu.nzumax) * \textcolor{keyword}{sizeof}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}) + (glu.nzlumax+glu.nzumax) *  \textcolor{keyword}{sizeof}(
      Scalar) + n; 
00165     \textcolor{keywordflow}{return} estimated\_size;
00166   \}
00167   
00168   \textcolor{comment}{// Setup the required space }
00169   
00170   \textcolor{comment}{// First allocate Integer pointers for L\(\backslash\)U factors}
00171   glu.xsup.resize(n+1);
00172   glu.supno.resize(n+1);
00173   glu.xlsub.resize(n+1);
00174   glu.xlusup.resize(n+1);
00175   glu.xusub.resize(n+1);
00176 
00177   \textcolor{comment}{// Reserve memory for L/U factors}
00178   \textcolor{keywordflow}{do} 
00179   \{
00180     \textcolor{keywordflow}{if}(     (expand<ScalarVector>(glu.lusup, glu.nzlumax, 0, 0, num\_expansions)<0)
00181         ||  (expand<ScalarVector>(glu.ucol,  glu.nzumax,  0, 0, num\_expansions)<0)
00182         ||  (expand<IndexVector> (glu.lsub,  glu.nzlmax,  0, 0, num\_expansions)<0)
00183         ||  (expand<IndexVector> (glu.usub,  glu.nzumax,  0, 1, num\_expansions)<0) )
00184     \{
00185       \textcolor{comment}{//Reduce the estimated size and retry}
00186       glu.nzlumax /= 2;
00187       glu.nzumax /= 2;
00188       glu.nzlmax /= 2;
00189       \textcolor{keywordflow}{if} (glu.nzlumax < annz ) \textcolor{keywordflow}{return} glu.nzlumax; 
00190     \}
00191   \} \textcolor{keywordflow}{while} (!glu.lusup.size() || !glu.ucol.size() || !glu.lsub.size() || !glu.usub.size());
00192   
00193   ++num\_expansions;
00194   \textcolor{keywordflow}{return} 0;
00195   
00196 \} \textcolor{comment}{// end LuMemInit}
00197 
00207 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} StorageIndex>
00208 \textcolor{keyword}{template} <\textcolor{keyword}{typename} VectorType>
00209 \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{group___sparse_l_u___module_a2a6465f1173fd8b74b2e5b8ceec53343}{SparseLUImpl<Scalar,StorageIndex>::memXpand}(
      \hyperlink{struct_vector_type}{VectorType}& vec, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& maxlen, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nbElts, MemType memtype, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& num\_expansions)
00210 \{
00211   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} failed\_size; 
00212   \textcolor{keywordflow}{if} (memtype == USUB)
00213      failed\_size = this->expand<VectorType>(vec, maxlen, nbElts, 1, num\_expansions);
00214   \textcolor{keywordflow}{else}
00215     failed\_size = this->expand<VectorType>(vec, maxlen, nbElts, 0, num\_expansions);
00216 
00217   \textcolor{keywordflow}{if} (failed\_size)
00218     \textcolor{keywordflow}{return} failed\_size; 
00219   
00220   \textcolor{keywordflow}{return} 0 ;  
00221 \}
00222 
00223 \} \textcolor{comment}{// end namespace internal}
00224 
00225 \} \textcolor{comment}{// end namespace Eigen}
00226 \textcolor{preprocessor}{#endif // EIGEN\_SPARSELU\_MEMORY}
\end{DoxyCode}
