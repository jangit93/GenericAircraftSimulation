\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_volume_patch_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Volume\+Patch.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_volume_patch_8h_source}\index{Tensor\+Volume\+Patch.\+h@{Tensor\+Volume\+Patch.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 
00004 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_VOLUME\_PATCH\_H}
00005 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_VOLUME\_PATCH\_H}
00006 
00007 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00008 
00024 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00025 \textcolor{keyword}{template}<DenseIndex Planes, DenseIndex Rows, DenseIndex Cols, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_volume_patch_8h_source_l00026}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_volume_patch_op_3_01_planes_00_01_rows_00_01_cols_00_01_xpr_type_01_4_01_4}{00026} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_volume_patch_op}{TensorVolumePatchOp}<Planes, Rows, Cols, XprType> > : \textcolor{keyword}{public} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<XprType>
00027 \{
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<typename XprType::Scalar>::type}
       \hyperlink{group___sparse_core___module}{Scalar};
00029   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>} \hyperlink{struct_eigen_1_1internal_1_1traits}{XprTraits};
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00032   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00033   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<Nested>::type} 
      \hyperlink{group___sparse_core___module}{\_Nested};
00034   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions + 1;
00035   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00036 \};
00037 
00038 \textcolor{keyword}{template}<DenseIndex Planes, DenseIndex Rows, DenseIndex Cols, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_volume_patch_8h_source_l00039}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_volume_patch_op_3_01_planes_00_01_rows_00_01_cols_0fbbbfea9d11ccf46d4c751aec1ba44e4}{00039} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_volume_patch_op}{TensorVolumePatchOp}<Planes, Rows, Cols, XprType>, 
      \hyperlink{namespace_eigen}{Eigen}::\hyperlink{struct_eigen_1_1_dense}{Dense}>
00040 \{
00041   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_volume_patch_op}{TensorVolumePatchOp<Planes, Rows, Cols, XprType>}
      & \hyperlink{class_eigen_1_1_tensor_volume_patch_op}{type};
00042 \};
00043 
00044 \textcolor{keyword}{template}<DenseIndex Planes, DenseIndex Rows, DenseIndex Cols, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_volume_patch_8h_source_l00045}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_volume_patch_op_3_01_planes_00_01_rows_00_01_cols82921df878abaf81e0e304ae8f39bd52}{00045} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_volume_patch_op}{TensorVolumePatchOp}<Planes, Rows, Cols, XprType>, 1, typename 
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_volume_patch_op}{TensorVolumePatchOp}<Planes, Rows, Cols, XprType> >::
      \hyperlink{class_eigen_1_1_tensor_volume_patch_op}{type}>
00046 \{
00047   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_volume_patch_op}{TensorVolumePatchOp<Planes, Rows, Cols, XprType>} 
      \hyperlink{class_eigen_1_1_tensor_volume_patch_op}{type};
00048 \};
00049 
00050 \}  \textcolor{comment}{// end namespace internal}
00051 
00052 \textcolor{keyword}{template}<DenseIndex Planes, DenseIndex Rows, DenseIndex Cols, \textcolor{keyword}{typename} XprType>
00053 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_volume_patch_op}{TensorVolumePatchOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorVolumePatchOp<Planes, Rows
      , Cols, XprType>, ReadOnlyAccessors>
00054 \{
00055   \textcolor{keyword}{public}:
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorVolumePatchOp>::Scalar}
       Scalar;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorVolumePatchOp>::type}
       Nested;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorVolumePatchOp>::StorageKind}
       StorageKind;
00061   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorVolumePatchOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00062 
00063   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_volume_patch_op}{TensorVolumePatchOp}(\textcolor{keyword}{const} XprType& expr, 
      DenseIndex patch\_planes, DenseIndex patch\_rows, DenseIndex patch\_cols,
00064                                                             DenseIndex plane\_strides, DenseIndex 
      row\_strides, DenseIndex col\_strides,
00065                                                             DenseIndex in\_plane\_strides, DenseIndex 
      in\_row\_strides, DenseIndex in\_col\_strides,
00066                                                             DenseIndex plane\_inflate\_strides, DenseIndex 
      row\_inflate\_strides, DenseIndex col\_inflate\_strides,
00067                                                             PaddingType padding\_type, Scalar padding\_value)
00068       : m\_xpr(expr), m\_patch\_planes(patch\_planes), m\_patch\_rows(patch\_rows), m\_patch\_cols(patch\_cols),
00069         m\_plane\_strides(plane\_strides), m\_row\_strides(row\_strides), m\_col\_strides(col\_strides),
00070         m\_in\_plane\_strides(in\_plane\_strides), m\_in\_row\_strides(in\_row\_strides), m\_in\_col\_strides(
      in\_col\_strides),
00071         m\_plane\_inflate\_strides(plane\_inflate\_strides), m\_row\_inflate\_strides(row\_inflate\_strides), 
      m\_col\_inflate\_strides(col\_inflate\_strides),
00072         m\_padding\_explicit(\textcolor{keyword}{false}), m\_padding\_top\_z(0), m\_padding\_bottom\_z(0), m\_padding\_top(0), 
      m\_padding\_bottom(0), m\_padding\_left(0), m\_padding\_right(0),
00073         m\_padding\_type(padding\_type), m\_padding\_value(padding\_value) \{\}
00074 
00075   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE TensorVolumePatchOp(\textcolor{keyword}{const} XprType& expr, DenseIndex patch\_planes, 
      DenseIndex patch\_rows, DenseIndex patch\_cols,
00076                                                            DenseIndex plane\_strides, DenseIndex row\_strides
      , DenseIndex col\_strides,
00077                                                            DenseIndex in\_plane\_strides, DenseIndex 
      in\_row\_strides, DenseIndex in\_col\_strides,
00078                                                            DenseIndex plane\_inflate\_strides, DenseIndex 
      row\_inflate\_strides, DenseIndex col\_inflate\_strides,
00079                                                            DenseIndex padding\_top\_z, DenseIndex 
      padding\_bottom\_z,
00080                                                            DenseIndex padding\_top, DenseIndex 
      padding\_bottom,
00081                                                            DenseIndex padding\_left, DenseIndex 
      padding\_right,
00082                                                            Scalar padding\_value)
00083       : m\_xpr(expr), m\_patch\_planes(patch\_planes), m\_patch\_rows(patch\_rows), m\_patch\_cols(patch\_cols),
00084         m\_plane\_strides(plane\_strides), m\_row\_strides(row\_strides), m\_col\_strides(col\_strides),
00085         m\_in\_plane\_strides(in\_plane\_strides), m\_in\_row\_strides(in\_row\_strides), m\_in\_col\_strides(
      in\_col\_strides),
00086         m\_plane\_inflate\_strides(plane\_inflate\_strides), m\_row\_inflate\_strides(row\_inflate\_strides), 
      m\_col\_inflate\_strides(col\_inflate\_strides),
00087         m\_padding\_explicit(\textcolor{keyword}{true}), m\_padding\_top\_z(padding\_top\_z), m\_padding\_bottom\_z(padding\_bottom\_z), 
      m\_padding\_top(padding\_top), m\_padding\_bottom(padding\_bottom),
00088         m\_padding\_left(padding\_left), m\_padding\_right(padding\_right),
00089         m\_padding\_type(PADDING\_VALID), m\_padding\_value(padding\_value) \{\}
00090 
00091     EIGEN\_DEVICE\_FUNC
00092     DenseIndex patch\_planes()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_patch\_planes; \}
00093     EIGEN\_DEVICE\_FUNC
00094     DenseIndex patch\_rows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_patch\_rows; \}
00095     EIGEN\_DEVICE\_FUNC
00096     DenseIndex patch\_cols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_patch\_cols; \}
00097     EIGEN\_DEVICE\_FUNC
00098     DenseIndex plane\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_plane\_strides; \}
00099     EIGEN\_DEVICE\_FUNC
00100     DenseIndex row\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_row\_strides; \}
00101     EIGEN\_DEVICE\_FUNC
00102     DenseIndex col\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_col\_strides; \}
00103     EIGEN\_DEVICE\_FUNC
00104     DenseIndex in\_plane\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_in\_plane\_strides; \}
00105     EIGEN\_DEVICE\_FUNC
00106     DenseIndex in\_row\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_in\_row\_strides; \}
00107     EIGEN\_DEVICE\_FUNC
00108     DenseIndex in\_col\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_in\_col\_strides; \}
00109     EIGEN\_DEVICE\_FUNC
00110     DenseIndex plane\_inflate\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_plane\_inflate\_strides; \}
00111     EIGEN\_DEVICE\_FUNC
00112     DenseIndex row\_inflate\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_row\_inflate\_strides; \}
00113     EIGEN\_DEVICE\_FUNC
00114     DenseIndex col\_inflate\_strides()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_col\_inflate\_strides; \}
00115     EIGEN\_DEVICE\_FUNC
00116     \textcolor{keywordtype}{bool} padding\_explicit()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_explicit; \}
00117     EIGEN\_DEVICE\_FUNC
00118     DenseIndex padding\_top\_z()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_top\_z; \}
00119     EIGEN\_DEVICE\_FUNC
00120     DenseIndex padding\_bottom\_z()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_bottom\_z; \}
00121     EIGEN\_DEVICE\_FUNC
00122     DenseIndex padding\_top()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_top; \}
00123     EIGEN\_DEVICE\_FUNC
00124     DenseIndex padding\_bottom()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_bottom; \}
00125     EIGEN\_DEVICE\_FUNC
00126     DenseIndex padding\_left()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_left; \}
00127     EIGEN\_DEVICE\_FUNC
00128     DenseIndex padding\_right()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_right; \}
00129     EIGEN\_DEVICE\_FUNC
00130     PaddingType padding\_type()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_type; \}
00131     EIGEN\_DEVICE\_FUNC
00132     Scalar padding\_value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_padding\_value; \}
00133 
00134     EIGEN\_DEVICE\_FUNC
00135     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename XprType::Nested>::type}
      &
00136     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00137 
00138   \textcolor{keyword}{protected}:
00139     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00140     \textcolor{keyword}{const} DenseIndex m\_patch\_planes;
00141     \textcolor{keyword}{const} DenseIndex m\_patch\_rows;
00142     \textcolor{keyword}{const} DenseIndex m\_patch\_cols;
00143     \textcolor{keyword}{const} DenseIndex m\_plane\_strides;
00144     \textcolor{keyword}{const} DenseIndex m\_row\_strides;
00145     \textcolor{keyword}{const} DenseIndex m\_col\_strides;
00146     \textcolor{keyword}{const} DenseIndex m\_in\_plane\_strides;
00147     \textcolor{keyword}{const} DenseIndex m\_in\_row\_strides;
00148     \textcolor{keyword}{const} DenseIndex m\_in\_col\_strides;
00149     \textcolor{keyword}{const} DenseIndex m\_plane\_inflate\_strides;
00150     \textcolor{keyword}{const} DenseIndex m\_row\_inflate\_strides;
00151     \textcolor{keyword}{const} DenseIndex m\_col\_inflate\_strides;
00152     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} m\_padding\_explicit;
00153     \textcolor{keyword}{const} DenseIndex m\_padding\_top\_z;
00154     \textcolor{keyword}{const} DenseIndex m\_padding\_bottom\_z;
00155     \textcolor{keyword}{const} DenseIndex m\_padding\_top;
00156     \textcolor{keyword}{const} DenseIndex m\_padding\_bottom;
00157     \textcolor{keyword}{const} DenseIndex m\_padding\_left;
00158     \textcolor{keyword}{const} DenseIndex m\_padding\_right;
00159     \textcolor{keyword}{const} PaddingType m\_padding\_type;
00160     \textcolor{keyword}{const} Scalar m\_padding\_value;
00161 \};
00162 
00163 
00164 \textcolor{comment}{// Eval as rvalue}
00165 \textcolor{keyword}{template}<DenseIndex Planes, DenseIndex Rows, DenseIndex Cols, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_volume_patch_8h_source_l00166}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_volume_patch_op_3_01_planes_00_01_rows_00_7868d50e868058a145e213ecbb5a830e}{00166} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_volume_patch_op}{TensorVolumePatchOp}<Planes, Rows, Cols, 
      ArgType>, Device>
00167 \{
00168   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_volume_patch_op}{TensorVolumePatchOp<Planes, Rows, Cols, ArgType>} 
      \hyperlink{class_eigen_1_1_tensor_volume_patch_op}{XprType};
00169   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00170   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumInputDims = 
      \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<typename TensorEvaluator<ArgType, Device>::Dimensions}
      >::value;
00171   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = NumInputDims + 1;
00172   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1_d_sizes}{DSizes<Index, NumDims>} \hyperlink{struct_eigen_1_1_d_sizes}{Dimensions};
00173   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<typename XprType::Scalar>::type}
       \hyperlink{group___sparse_core___module}{Scalar};
00174   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00175   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00176   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PacketSize = 
      \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size};
00177 
00178   \textcolor{keyword}{enum} \{
00179     IsAligned = \textcolor{keyword}{false},
00180     PacketAccess = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::PacketAccess}
      ,
00181     BlockAccess = \textcolor{keyword}{false},
00182     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Layout},
00183     CoordAccess = \textcolor{keyword}{false},
00184     RawAccess = \textcolor{keyword}{false}
00185   \};
00186 
00187   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00188       : m\_impl(op.expression(), device)
00189   \{
00190     EIGEN\_STATIC\_ASSERT((NumDims >= 5), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE);
00191 
00192     m\_paddingValue = op.padding\_value();
00193 
00194     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Dimensions}
      & input\_dims = m\_impl.dimensions();
00195 
00196     \textcolor{comment}{// Cache a few variables.}
00197     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00198       m\_inputDepth = input\_dims[0];
00199       m\_inputPlanes = input\_dims[1];
00200       m\_inputRows = input\_dims[2];
00201       m\_inputCols = input\_dims[3];
00202     \} \textcolor{keywordflow}{else} \{
00203       m\_inputDepth = input\_dims[NumInputDims-1];
00204       m\_inputPlanes = input\_dims[NumInputDims-2];
00205       m\_inputRows = input\_dims[NumInputDims-3];
00206       m\_inputCols = input\_dims[NumInputDims-4];
00207     \}
00208 
00209     m\_plane\_strides = op.plane\_strides();
00210     m\_row\_strides = op.row\_strides();
00211     m\_col\_strides = op.col\_strides();
00212 
00213     \textcolor{comment}{// Input strides and effective input/patch size}
00214     m\_in\_plane\_strides = op.in\_plane\_strides();
00215     m\_in\_row\_strides = op.in\_row\_strides();
00216     m\_in\_col\_strides = op.in\_col\_strides();
00217     m\_plane\_inflate\_strides = op.plane\_inflate\_strides();
00218     m\_row\_inflate\_strides = op.row\_inflate\_strides();
00219     m\_col\_inflate\_strides = op.col\_inflate\_strides();
00220 
00221     \textcolor{comment}{// The "effective" spatial size after inflating data with zeros.}
00222     m\_input\_planes\_eff = (m\_inputPlanes - 1) * m\_plane\_inflate\_strides + 1;
00223     m\_input\_rows\_eff = (m\_inputRows - 1) * m\_row\_inflate\_strides + 1;
00224     m\_input\_cols\_eff = (m\_inputCols - 1) * m\_col\_inflate\_strides + 1;
00225     m\_patch\_planes\_eff = op.patch\_planes() + (op.patch\_planes() - 1) * (m\_in\_plane\_strides - 1);
00226     m\_patch\_rows\_eff = op.patch\_rows() + (op.patch\_rows() - 1) * (m\_in\_row\_strides - 1);
00227     m\_patch\_cols\_eff = op.patch\_cols() + (op.patch\_cols() - 1) * (m\_in\_col\_strides - 1);
00228 
00229     \textcolor{keywordflow}{if} (op.padding\_explicit()) \{
00230       m\_outputPlanes = numext::ceil((m\_input\_planes\_eff + op.padding\_top\_z() + op.padding\_bottom\_z() - 
      m\_patch\_planes\_eff + 1.f) / static\_cast<float>(m\_plane\_strides));
00231       m\_outputRows = numext::ceil((m\_input\_rows\_eff + op.padding\_top() + op.padding\_bottom() - 
      m\_patch\_rows\_eff + 1.f) / static\_cast<float>(m\_row\_strides));
00232       m\_outputCols = numext::ceil((m\_input\_cols\_eff + op.padding\_left() + op.padding\_right() - 
      m\_patch\_cols\_eff + 1.f) / static\_cast<float>(m\_col\_strides));
00233       m\_planePaddingTop = op.padding\_top\_z();
00234       m\_rowPaddingTop = op.padding\_top();
00235       m\_colPaddingLeft = op.padding\_left();
00236     \} \textcolor{keywordflow}{else} \{
00237       \textcolor{comment}{// Computing padding from the type}
00238       \textcolor{keywordflow}{switch} (op.padding\_type()) \{
00239         \textcolor{keywordflow}{case} PADDING\_VALID:
00240           m\_outputPlanes = numext::ceil((m\_input\_planes\_eff - m\_patch\_planes\_eff + 1.f) / 
      static\_cast<float>(m\_plane\_strides));
00241           m\_outputRows = numext::ceil((m\_input\_rows\_eff - m\_patch\_rows\_eff + 1.f) / static\_cast<float>(
      m\_row\_strides));
00242           m\_outputCols = numext::ceil((m\_input\_cols\_eff - m\_patch\_cols\_eff + 1.f) / static\_cast<float>(
      m\_col\_strides));
00243           m\_planePaddingTop = 0;
00244           m\_rowPaddingTop = 0;
00245           m\_colPaddingLeft = 0;
00246           \textcolor{keywordflow}{break};
00247         \textcolor{keywordflow}{case} PADDING\_SAME: \{
00248           m\_outputPlanes = numext::ceil(m\_input\_planes\_eff / static\_cast<float>(m\_plane\_strides));
00249           m\_outputRows = numext::ceil(m\_input\_rows\_eff / static\_cast<float>(m\_row\_strides));
00250           m\_outputCols = numext::ceil(m\_input\_cols\_eff / static\_cast<float>(m\_col\_strides));
00251           \textcolor{keyword}{const} Index dz = m\_outputPlanes * m\_plane\_strides + m\_patch\_planes\_eff - 1 - m\_input\_planes\_eff;
00252           \textcolor{keyword}{const} Index dy = m\_outputRows * m\_row\_strides + m\_patch\_rows\_eff - 1 - m\_input\_rows\_eff;
00253           \textcolor{keyword}{const} Index dx = m\_outputCols * m\_col\_strides + m\_patch\_cols\_eff - 1 - m\_input\_cols\_eff;
00254           m\_planePaddingTop = dz - dz / 2;
00255           m\_rowPaddingTop = dy - dy / 2;
00256           m\_colPaddingLeft = dx - dx / 2;
00257           \textcolor{keywordflow}{break};
00258         \}
00259         \textcolor{keywordflow}{default}:
00260           eigen\_assert(\textcolor{keyword}{false} && \textcolor{stringliteral}{"unexpected padding"});
00261       \}
00262     \}
00263     eigen\_assert(m\_outputRows > 0);
00264     eigen\_assert(m\_outputCols > 0);
00265     eigen\_assert(m\_outputPlanes > 0);
00266 
00267     \textcolor{comment}{// Dimensions for result of extraction.}
00268     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00269       \textcolor{comment}{// ColMajor}
00270       \textcolor{comment}{// 0: depth}
00271       \textcolor{comment}{// 1: patch\_planes}
00272       \textcolor{comment}{// 2: patch\_rows}
00273       \textcolor{comment}{// 3: patch\_cols}
00274       \textcolor{comment}{// 4: number of patches}
00275       \textcolor{comment}{// 5 and beyond: anything else (such as batch).}
00276       m\_dimensions[0] = input\_dims[0];
00277       m\_dimensions[1] = op.patch\_planes();
00278       m\_dimensions[2] = op.patch\_rows();
00279       m\_dimensions[3] = op.patch\_cols();
00280       m\_dimensions[4] = m\_outputPlanes * m\_outputRows * m\_outputCols;
00281       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 5; i < NumDims; ++i) \{
00282         m\_dimensions[i] = input\_dims[i-1];
00283       \}
00284     \} \textcolor{keywordflow}{else} \{
00285       \textcolor{comment}{// RowMajor}
00286       \textcolor{comment}{// NumDims-1: depth}
00287       \textcolor{comment}{// NumDims-2: patch\_planes}
00288       \textcolor{comment}{// NumDims-3: patch\_rows}
00289       \textcolor{comment}{// NumDims-4: patch\_cols}
00290       \textcolor{comment}{// NumDims-5: number of patches}
00291       \textcolor{comment}{// NumDims-6 and beyond: anything else (such as batch).}
00292       m\_dimensions[NumDims-1] = input\_dims[NumInputDims-1];
00293       m\_dimensions[NumDims-2] = op.patch\_planes();
00294       m\_dimensions[NumDims-3] = op.patch\_rows();
00295       m\_dimensions[NumDims-4] = op.patch\_cols();
00296       m\_dimensions[NumDims-5] = m\_outputPlanes * m\_outputRows * m\_outputCols;
00297       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims-6; i >= 0; --i) \{
00298         m\_dimensions[i] = input\_dims[i];
00299       \}
00300     \}
00301 
00302     \textcolor{comment}{// Strides for the output tensor.}
00303     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00304       m\_rowStride = m\_dimensions[1];
00305       m\_colStride = m\_dimensions[2] * m\_rowStride;
00306       m\_patchStride = m\_colStride * m\_dimensions[3] * m\_dimensions[0];
00307       m\_otherStride = m\_patchStride * m\_dimensions[4];
00308     \} \textcolor{keywordflow}{else} \{
00309       m\_rowStride = m\_dimensions[NumDims-2];
00310       m\_colStride = m\_dimensions[NumDims-3] * m\_rowStride;
00311       m\_patchStride = m\_colStride * m\_dimensions[NumDims-4] * m\_dimensions[NumDims-1];
00312       m\_otherStride = m\_patchStride * m\_dimensions[NumDims-5];
00313     \}
00314 
00315     \textcolor{comment}{// Strides for navigating through the input tensor.}
00316     m\_planeInputStride = m\_inputDepth;
00317     m\_rowInputStride = m\_inputDepth * m\_inputPlanes;
00318     m\_colInputStride = m\_inputDepth * m\_inputRows * m\_inputPlanes;
00319     m\_otherInputStride = m\_inputDepth * m\_inputRows * m\_inputCols * m\_inputPlanes;
00320 
00321     m\_outputPlanesRows = m\_outputPlanes * m\_outputRows;
00322 
00323     \textcolor{comment}{// Fast representations of different variables.}
00324     m\_fastOtherStride = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_otherStride);
00325     m\_fastPatchStride = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_patchStride);
00326     m\_fastColStride = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_colStride);
00327     m\_fastRowStride = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_rowStride);
00328     m\_fastInputRowStride = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(
      m\_row\_inflate\_strides);
00329     m\_fastInputColStride = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(
      m\_col\_inflate\_strides);
00330     m\_fastInputPlaneStride = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(
      m\_plane\_inflate\_strides);
00331     m\_fastInputColsEff = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(
      m\_input\_cols\_eff);
00332     m\_fastOutputPlanes = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_outputPlanes)
      ;
00333     m\_fastOutputPlanesRows = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(
      m\_outputPlanesRows);
00334 
00335     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00336       m\_fastOutputDepth = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_dimensions[0
      ]);
00337     \} \textcolor{keywordflow}{else} \{
00338       m\_fastOutputDepth = \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>}(m\_dimensions[
      NumDims-1]);
00339     \}
00340   \}
00341 
00342   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00343 
00344   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/}) \{
00345     m\_impl.evalSubExprsIfNeeded(NULL);
00346     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00347   \}
00348 
00349   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00350     m\_impl.cleanup();
00351   \}
00352 
00353   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00354 \textcolor{keyword}{  }\{
00355     \textcolor{comment}{// Patch index corresponding to the passed in index.}
00356     \textcolor{keyword}{const} Index patchIndex = index / m\_fastPatchStride;
00357 
00358     \textcolor{comment}{// Spatial offset within the patch. This has to be translated into 3D}
00359     \textcolor{comment}{// coordinates within the patch.}
00360     \textcolor{keyword}{const} Index patchOffset = (index - patchIndex * m\_patchStride) / m\_fastOutputDepth;
00361 
00362     \textcolor{comment}{// Batch, etc.}
00363     \textcolor{keyword}{const} Index otherIndex = (NumDims == 5) ? 0 : index / m\_fastOtherStride;
00364     \textcolor{keyword}{const} Index patch3DIndex = (NumDims == 5) ? patchIndex : (index - otherIndex * m\_otherStride) / 
      m\_fastPatchStride;
00365 
00366     \textcolor{comment}{// Calculate column index in the input original tensor.}
00367     \textcolor{keyword}{const} Index colIndex = patch3DIndex / m\_fastOutputPlanesRows;
00368     \textcolor{keyword}{const} Index colOffset = patchOffset / m\_fastColStride;
00369     \textcolor{keyword}{const} Index inputCol = colIndex * m\_col\_strides + colOffset * m\_in\_col\_strides - m\_colPaddingLeft;
00370     \textcolor{keyword}{const} Index origInputCol = (m\_col\_inflate\_strides == 1) ? inputCol : ((inputCol >= 0) ? (inputCol / 
      m\_fastInputColStride) : 0);
00371     \textcolor{keywordflow}{if} (inputCol < 0 || inputCol >= m\_input\_cols\_eff ||
00372         ((m\_col\_inflate\_strides != 1) && (inputCol != origInputCol * m\_col\_inflate\_strides))) \{
00373       \textcolor{keywordflow}{return} Scalar(m\_paddingValue);
00374     \}
00375 
00376     \textcolor{comment}{// Calculate row index in the original input tensor.}
00377     \textcolor{keyword}{const} Index rowIndex = (patch3DIndex - colIndex * m\_outputPlanesRows) / m\_fastOutputPlanes;
00378     \textcolor{keyword}{const} Index rowOffset = (patchOffset - colOffset * m\_colStride) / m\_fastRowStride;
00379     \textcolor{keyword}{const} Index inputRow = rowIndex * m\_row\_strides + rowOffset * m\_in\_row\_strides - m\_rowPaddingTop;
00380     \textcolor{keyword}{const} Index origInputRow = (m\_row\_inflate\_strides == 1) ? inputRow : ((inputRow >= 0) ? (inputRow / 
      m\_fastInputRowStride) : 0);
00381     \textcolor{keywordflow}{if} (inputRow < 0 || inputRow >= m\_input\_rows\_eff ||
00382         ((m\_row\_inflate\_strides != 1) && (inputRow != origInputRow * m\_row\_inflate\_strides))) \{
00383       \textcolor{keywordflow}{return} Scalar(m\_paddingValue);
00384     \}
00385 
00386     \textcolor{comment}{// Calculate plane index in the original input tensor.}
00387     \textcolor{keyword}{const} Index planeIndex = (patch3DIndex - m\_outputPlanes * (colIndex * m\_outputRows + rowIndex));
00388     \textcolor{keyword}{const} Index planeOffset = patchOffset - colOffset * m\_colStride - rowOffset * m\_rowStride;
00389     \textcolor{keyword}{const} Index inputPlane = planeIndex * m\_plane\_strides + planeOffset * m\_in\_plane\_strides - 
      m\_planePaddingTop;
00390     \textcolor{keyword}{const} Index origInputPlane = (m\_plane\_inflate\_strides == 1) ? inputPlane : ((inputPlane >= 0) ? (
      inputPlane / m\_fastInputPlaneStride) : 0);
00391     \textcolor{keywordflow}{if} (inputPlane < 0 || inputPlane >= m\_input\_planes\_eff ||
00392         ((m\_plane\_inflate\_strides != 1) && (inputPlane != origInputPlane * m\_plane\_inflate\_strides))) \{
00393       \textcolor{keywordflow}{return} Scalar(m\_paddingValue);
00394     \}
00395 
00396     \textcolor{keyword}{const} \textcolor{keywordtype}{int} depth\_index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) ? 0 : NumDims - 1;
00397     \textcolor{keyword}{const} Index depth = index - (index / m\_fastOutputDepth) * m\_dimensions[depth\_index];
00398 
00399     \textcolor{keyword}{const} Index inputIndex = depth +
00400         origInputRow * m\_rowInputStride +
00401         origInputCol * m\_colInputStride +
00402         origInputPlane * m\_planeInputStride +
00403         otherIndex * m\_otherInputStride;
00404 
00405     \textcolor{keywordflow}{return} m\_impl.coeff(inputIndex);
00406   \}
00407 
00408   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00409   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00410 \textcolor{keyword}{  }\{
00411     EIGEN\_STATIC\_ASSERT((PacketSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00412     eigen\_assert(index+PacketSize-1 < dimensions().TotalSize());
00413 
00414     \textcolor{keywordflow}{if} (m\_in\_row\_strides != 1 || m\_in\_col\_strides != 1 || m\_row\_inflate\_strides != 1 || 
      m\_col\_inflate\_strides != 1 ||
00415         m\_in\_plane\_strides != 1 || m\_plane\_inflate\_strides != 1) \{
00416       \textcolor{keywordflow}{return} packetWithPossibleZero(index);
00417     \}
00418 
00419     \textcolor{keyword}{const} Index indices[2] = \{index, index + PacketSize - 1\};
00420     \textcolor{keyword}{const} Index patchIndex = indices[0] / m\_fastPatchStride;
00421     \textcolor{keywordflow}{if} (patchIndex != indices[1] / m\_fastPatchStride) \{
00422       \textcolor{keywordflow}{return} packetWithPossibleZero(index);
00423     \}
00424     \textcolor{keyword}{const} Index otherIndex = (NumDims == 5) ? 0 : indices[0] / m\_fastOtherStride;
00425     eigen\_assert(otherIndex == indices[1] / m\_fastOtherStride);
00426 
00427     \textcolor{comment}{// Find the offset of the element wrt the location of the first element.}
00428     \textcolor{keyword}{const} Index patchOffsets[2] = \{(indices[0] - patchIndex * m\_patchStride) / m\_fastOutputDepth,
00429                                    (indices[1] - patchIndex * m\_patchStride) / m\_fastOutputDepth\};
00430 
00431     \textcolor{keyword}{const} Index patch3DIndex = (NumDims == 5) ? patchIndex : (indices[0] - otherIndex * m\_otherStride) / 
      m\_fastPatchStride;
00432     eigen\_assert(patch3DIndex == (indices[1] - otherIndex * m\_otherStride) / m\_fastPatchStride);
00433 
00434     \textcolor{keyword}{const} Index colIndex = patch3DIndex / m\_fastOutputPlanesRows;
00435     \textcolor{keyword}{const} Index colOffsets[2] = \{
00436       patchOffsets[0] / m\_fastColStride,
00437       patchOffsets[1] / m\_fastColStride\};
00438 
00439     \textcolor{comment}{// Calculate col indices in the original input tensor.}
00440     \textcolor{keyword}{const} Index inputCols[2] = \{
00441       colIndex * m\_col\_strides + colOffsets[0] - m\_colPaddingLeft,
00442       colIndex * m\_col\_strides + colOffsets[1] - m\_colPaddingLeft\};
00443     \textcolor{keywordflow}{if} (inputCols[1] < 0 || inputCols[0] >= m\_inputCols) \{
00444       \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(Scalar(m\_paddingValue));
00445     \}
00446 
00447     \textcolor{keywordflow}{if} (inputCols[0] != inputCols[1]) \{
00448       \textcolor{keywordflow}{return} packetWithPossibleZero(index);
00449     \}
00450 
00451     \textcolor{keyword}{const} Index rowIndex = (patch3DIndex - colIndex * m\_outputPlanesRows) / m\_fastOutputPlanes;
00452     \textcolor{keyword}{const} Index rowOffsets[2] = \{
00453       (patchOffsets[0] - colOffsets[0] * m\_colStride) / m\_fastRowStride,
00454       (patchOffsets[1] - colOffsets[1] * m\_colStride) / m\_fastRowStride\};
00455     eigen\_assert(rowOffsets[0] <= rowOffsets[1]);
00456     \textcolor{comment}{// Calculate col indices in the original input tensor.}
00457     \textcolor{keyword}{const} Index inputRows[2] = \{
00458       rowIndex * m\_row\_strides + rowOffsets[0] - m\_rowPaddingTop,
00459       rowIndex * m\_row\_strides + rowOffsets[1] - m\_rowPaddingTop\};
00460 
00461     \textcolor{keywordflow}{if} (inputRows[1] < 0 || inputRows[0] >= m\_inputRows) \{
00462       \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(Scalar(m\_paddingValue));
00463     \}
00464 
00465     \textcolor{keywordflow}{if} (inputRows[0] != inputRows[1]) \{
00466       \textcolor{keywordflow}{return} packetWithPossibleZero(index);
00467     \}
00468 
00469     \textcolor{keyword}{const} Index planeIndex = (patch3DIndex - m\_outputPlanes * (colIndex * m\_outputRows + rowIndex));
00470     \textcolor{keyword}{const} Index planeOffsets[2] = \{
00471       patchOffsets[0] - colOffsets[0] * m\_colStride - rowOffsets[0] * m\_rowStride,
00472       patchOffsets[1] - colOffsets[1] * m\_colStride - rowOffsets[1] * m\_rowStride\};
00473     eigen\_assert(planeOffsets[0] <= planeOffsets[1]);
00474     \textcolor{keyword}{const} Index inputPlanes[2] = \{
00475       planeIndex * m\_plane\_strides + planeOffsets[0] - m\_planePaddingTop,
00476       planeIndex * m\_plane\_strides + planeOffsets[1] - m\_planePaddingTop\};
00477 
00478     \textcolor{keywordflow}{if} (inputPlanes[1] < 0 || inputPlanes[0] >= m\_inputPlanes) \{
00479       \textcolor{keywordflow}{return} internal::pset1<PacketReturnType>(Scalar(m\_paddingValue));
00480     \}
00481 
00482     \textcolor{keywordflow}{if} (inputPlanes[0] >= 0 && inputPlanes[1] < m\_inputPlanes) \{
00483       \textcolor{comment}{// no padding}
00484       \textcolor{keyword}{const} \textcolor{keywordtype}{int} depth\_index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(Layout) == static\_cast<int>(
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}) ? 0 : NumDims - 1;
00485       \textcolor{keyword}{const} Index depth = index - (index / m\_fastOutputDepth) * m\_dimensions[depth\_index];
00486       \textcolor{keyword}{const} Index inputIndex = depth +
00487           inputRows[0] * m\_rowInputStride +
00488           inputCols[0] * m\_colInputStride +
00489           m\_planeInputStride * inputPlanes[0] +
00490           otherIndex * m\_otherInputStride;
00491       \textcolor{keywordflow}{return} m\_impl.template packet<Unaligned>(inputIndex);
00492     \}
00493 
00494     \textcolor{keywordflow}{return} packetWithPossibleZero(index);
00495   \}
00496 
00497   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}
00498   costPerCoeff(\textcolor{keywordtype}{bool} vectorized)\textcolor{keyword}{ const }\{
00499     \textcolor{keyword}{const} \textcolor{keywordtype}{double} compute\_cost =
00500         10 * TensorOpCost::DivCost<Index>() + 21 * TensorOpCost::MulCost<Index>() +
00501         8 * TensorOpCost::AddCost<Index>();
00502     \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, compute\_cost, vectorized, PacketSize);
00503   \}
00504 
00505   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00506 
00507   \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>}& impl()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_impl; \}
00508 
00509   Index planePaddingTop()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_planePaddingTop; \}
00510   Index rowPaddingTop()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_rowPaddingTop; \}
00511   Index colPaddingLeft()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_colPaddingLeft; \}
00512   Index outputPlanes()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_outputPlanes; \}
00513   Index outputRows()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_outputRows; \}
00514   Index outputCols()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_outputCols; \}
00515   Index userPlaneStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_plane\_strides; \}
00516   Index userRowStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_row\_strides; \}
00517   Index userColStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_col\_strides; \}
00518   Index userInPlaneStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_in\_plane\_strides; \}
00519   Index userInRowStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_in\_row\_strides; \}
00520   Index userInColStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_in\_col\_strides; \}
00521   Index planeInflateStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_plane\_inflate\_strides; \}
00522   Index rowInflateStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_row\_inflate\_strides; \}
00523   Index colInflateStride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_col\_inflate\_strides; \}
00524 
00525  \textcolor{keyword}{protected}:
00526   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packetWithPossibleZero(Index index)\textcolor{keyword}{ const}
00527 \textcolor{keyword}{  }\{
00528     EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<CoeffReturnType>::type}
       values[PacketSize];
00529     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < PacketSize; ++i) \{
00530       values[i] = coeff(index+i);
00531     \}
00532     PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00533     \textcolor{keywordflow}{return} rslt;
00534   \}
00535 
00536   Dimensions m\_dimensions;
00537 
00538   \textcolor{comment}{// Parameters passed to the costructor.}
00539   Index m\_plane\_strides;
00540   Index m\_row\_strides;
00541   Index m\_col\_strides;
00542 
00543   Index m\_outputPlanes;
00544   Index m\_outputRows;
00545   Index m\_outputCols;
00546 
00547   Index m\_planePaddingTop;
00548   Index m\_rowPaddingTop;
00549   Index m\_colPaddingLeft;
00550 
00551   Index m\_in\_plane\_strides;
00552   Index m\_in\_row\_strides;
00553   Index m\_in\_col\_strides;
00554 
00555   Index m\_plane\_inflate\_strides;
00556   Index m\_row\_inflate\_strides;
00557   Index m\_col\_inflate\_strides;
00558 
00559   \textcolor{comment}{// Cached input size.}
00560   Index m\_inputDepth;
00561   Index m\_inputPlanes;
00562   Index m\_inputRows;
00563   Index m\_inputCols;
00564 
00565   \textcolor{comment}{// Other cached variables.}
00566   Index m\_outputPlanesRows;
00567 
00568   \textcolor{comment}{// Effective input/patch post-inflation size.}
00569   Index m\_input\_planes\_eff;
00570   Index m\_input\_rows\_eff;
00571   Index m\_input\_cols\_eff;
00572   Index m\_patch\_planes\_eff;
00573   Index m\_patch\_rows\_eff;
00574   Index m\_patch\_cols\_eff;
00575 
00576   \textcolor{comment}{// Strides for the output tensor.}
00577   Index m\_otherStride;
00578   Index m\_patchStride;
00579   Index m\_rowStride;
00580   Index m\_colStride;
00581 
00582   \textcolor{comment}{// Strides for the input tensor.}
00583   Index m\_planeInputStride;
00584   Index m\_rowInputStride;
00585   Index m\_colInputStride;
00586   Index m\_otherInputStride;
00587 
00588   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastOtherStride;
00589   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastPatchStride;
00590   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastColStride;
00591   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastRowStride;
00592   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastInputPlaneStride;
00593   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastInputRowStride;
00594   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastInputColStride;
00595   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastInputColsEff;
00596   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastOutputPlanesRows;
00597   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastOutputPlanes;
00598   \hyperlink{struct_eigen_1_1internal_1_1_tensor_int_divisor}{internal::TensorIntDivisor<Index>} m\_fastOutputDepth;
00599 
00600   Scalar m\_paddingValue;
00601 
00602   \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} m\_impl;
00603 \};
00604 
00605 
00606 \} \textcolor{comment}{// end namespace Eigen}
00607 
00608 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_VOLUME\_PATCH\_H}
\end{DoxyCode}
