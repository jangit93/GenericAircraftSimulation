\hypertarget{eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_complex_8h_source}{}\section{eigen/\+Eigen/src/\+Core/arch/\+S\+S\+E/\+Complex.h}
\label{eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_complex_8h_source}\index{Complex.\+h@{Complex.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_COMPLEX\_SSE\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_COMPLEX\_SSE\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{comment}{//---------- float ----------}
00018 \textcolor{keyword}{struct }Packet2cf
00019 \{
00020   EIGEN\_STRONG\_INLINE Packet2cf() \{\}
00021   EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} Packet2cf(\textcolor{keyword}{const} \_\_m128& a) : v(a) \{\}
00022   \_\_m128  v;
00023 \};
00024 
00025 \textcolor{comment}{// Use the packet\_traits defined in AVX/PacketMath.h instead if we're going}
00026 \textcolor{comment}{// to leverage AVX instructions.}
00027 \textcolor{preprocessor}{#ifndef EIGEN\_VECTORIZE\_AVX}
00028 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<float> >  : default\_packet\_traits
00029 \{
00030   \textcolor{keyword}{typedef} Packet2cf type;
00031   \textcolor{keyword}{typedef} Packet2cf half;
00032   \textcolor{keyword}{enum} \{
00033     Vectorizable = 1,
00034     AlignedOnScalar = 1,
00035     size = 2,
00036     HasHalfPacket = 0,
00037 
00038     HasAdd    = 1,
00039     HasSub    = 1,
00040     HasMul    = 1,
00041     HasDiv    = 1,
00042     HasNegate = 1,
00043     HasAbs    = 0,
00044     HasAbs2   = 0,
00045     HasMin    = 0,
00046     HasMax    = 0,
00047     HasSetLinear = 0,
00048     HasBlend = 1
00049   \};
00050 \};
00051 \textcolor{preprocessor}{#endif}
00052 
00053 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet2cf> \{ \textcolor{keyword}{typedef} std::complex<float> type; \textcolor{keyword}{enum} \{size=2, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet2cf half; \};
00054 
00055 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf padd<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{return} 
      Packet2cf(\_mm\_add\_ps(a.v,b.v)); \}
00056 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf psub<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{return} 
      Packet2cf(\_mm\_sub\_ps(a.v,b.v)); \}
00057 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pnegate(\textcolor{keyword}{const} Packet2cf& a)
00058 \{
00059   \textcolor{keyword}{const} \_\_m128 mask = \_mm\_castsi128\_ps(\_mm\_setr\_epi32(0x80000000,0x80000000,0x80000000,0x80000000));
00060   \textcolor{keywordflow}{return} Packet2cf(\_mm\_xor\_ps(a.v,mask));
00061 \}
00062 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pconj(\textcolor{keyword}{const} Packet2cf& a)
00063 \{
00064   \textcolor{keyword}{const} \_\_m128 mask = \_mm\_castsi128\_ps(\_mm\_setr\_epi32(0x00000000,0x80000000,0x00000000,0x80000000));
00065   \textcolor{keywordflow}{return} Packet2cf(\_mm\_xor\_ps(a.v,mask));
00066 \}
00067 
00068 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pmul<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)
00069 \{
00070 \textcolor{preprocessor}{  #ifdef EIGEN\_VECTORIZE\_SSE3}
00071   \textcolor{keywordflow}{return} Packet2cf(\_mm\_addsub\_ps(\_mm\_mul\_ps(\_mm\_moveldup\_ps(a.v), b.v),
00072                                  \_mm\_mul\_ps(\_mm\_movehdup\_ps(a.v),
00073                                             vec4f\_swizzle1(b.v, 1, 0, 3, 2))));
00074 \textcolor{comment}{//   return Packet2cf(\_mm\_addsub\_ps(\_mm\_mul\_ps(vec4f\_swizzle1(a.v, 0, 0, 2, 2), b.v),}
00075 \textcolor{comment}{//                                  \_mm\_mul\_ps(vec4f\_swizzle1(a.v, 1, 1, 3, 3),}
00076 \textcolor{comment}{//                                             vec4f\_swizzle1(b.v, 1, 0, 3, 2))));}
00077 \textcolor{preprocessor}{  #else}
00078   \textcolor{keyword}{const} \_\_m128 mask = \_mm\_castsi128\_ps(\_mm\_setr\_epi32(0x80000000,0x00000000,0x80000000,0x00000000));
00079   \textcolor{keywordflow}{return} Packet2cf(\_mm\_add\_ps(\_mm\_mul\_ps(vec4f\_swizzle1(a.v, 0, 0, 2, 2), b.v),
00080                               \_mm\_xor\_ps(\_mm\_mul\_ps(vec4f\_swizzle1(a.v, 1, 1, 3, 3),
00081                                                     vec4f\_swizzle1(b.v, 1, 0, 3, 2)), mask)));
00082 \textcolor{preprocessor}{  #endif}
00083 \}
00084 
00085 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pand   <Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{
      return} Packet2cf(\_mm\_and\_ps(a.v,b.v)); \}
00086 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf por    <Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{
      return} Packet2cf(\_mm\_or\_ps(a.v,b.v)); \}
00087 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pxor   <Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{
      return} Packet2cf(\_mm\_xor\_ps(a.v,b.v)); \}
00088 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pandnot<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{
      return} Packet2cf(\_mm\_andnot\_ps(a.v,b.v)); \}
00089 
00090 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pload <Packet2cf>(\textcolor{keyword}{const} std::complex<float>* from) \{ 
      EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{return} Packet2cf(pload<Packet4f>(&numext::real\_ref(*from))); \}
00091 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf ploadu<Packet2cf>(\textcolor{keyword}{const} std::complex<float>* from) \{ 
      EIGEN\_DEBUG\_UNALIGNED\_LOAD \textcolor{keywordflow}{return} Packet2cf(ploadu<Packet4f>(&numext::real\_ref(*from))); \}
00092 
00093 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pset1<Packet2cf>(\textcolor{keyword}{const} std::complex<float>&  from)
00094 \{
00095   Packet2cf res;
00096 \textcolor{preprocessor}{#if EIGEN\_GNUC\_AT\_MOST(4,2)}
00097   \textcolor{comment}{// Workaround annoying "may be used uninitialized in this function" warning with gcc 4.2}
00098   res.v = \_mm\_loadl\_pi(\_mm\_set1\_ps(0.0f), reinterpret\_cast<const \_\_m64*>(&from));
00099 \textcolor{preprocessor}{#elif EIGEN\_GNUC\_AT\_LEAST(4,6)}
00100   \textcolor{comment}{// Suppress annoying "may be used uninitialized in this function" warning with gcc >= 4.6}
00101 \textcolor{preprocessor}{  #pragma GCC diagnostic push}
00102 \textcolor{preprocessor}{  #pragma GCC diagnostic ignored "-Wuninitialized"}
00103   res.v = \_mm\_loadl\_pi(res.v, (\textcolor{keyword}{const} \_\_m64*)&from);
00104 \textcolor{preprocessor}{  #pragma GCC diagnostic pop}
00105 \textcolor{preprocessor}{#else}
00106   res.v = \_mm\_loadl\_pi(res.v, (\textcolor{keyword}{const} \_\_m64*)&from);
00107 \textcolor{preprocessor}{#endif}
00108   \textcolor{keywordflow}{return} Packet2cf(\_mm\_movelh\_ps(res.v,res.v));
00109 \}
00110 
00111 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf ploaddup<Packet2cf>(\textcolor{keyword}{const} std::complex<float>* from) \{ \textcolor{keywordflow}{return} 
      pset1<Packet2cf>(*from); \}
00112 
00113 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore <std::complex<float> >(std::complex<float> *   to, \textcolor{keyword}{const} 
      Packet2cf& from) \{ EIGEN\_DEBUG\_ALIGNED\_STORE pstore(&numext::real\_ref(*to), Packet4f(from.v)); \}
00114 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<std::complex<float> >(std::complex<float> *   to, \textcolor{keyword}{const} 
      Packet2cf& from) \{ EIGEN\_DEBUG\_UNALIGNED\_STORE pstoreu(&numext::real\_ref(*to), Packet4f(from.v)); \}
00115 
00116 
00117 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet2cf pgather<std::complex<float>, Packet2cf>(\textcolor{keyword}{const} 
      std::complex<float>* from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00118 \{
00119   \textcolor{keywordflow}{return} Packet2cf(\_mm\_set\_ps(std::imag(from[1*stride]), std::real(from[1*stride]),
00120                               std::imag(from[0*stride]), std::real(from[0*stride])));
00121 \}
00122 
00123 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, \textcolor{keyword}{
      const} Packet2cf& from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00124 \{
00125   to[stride*0] = std::complex<float>(\_mm\_cvtss\_f32(\_mm\_shuffle\_ps(from.v, from.v, 0)),
00126                                      \_mm\_cvtss\_f32(\_mm\_shuffle\_ps(from.v, from.v, 1)));
00127   to[stride*1] = std::complex<float>(\_mm\_cvtss\_f32(\_mm\_shuffle\_ps(from.v, from.v, 2)),
00128                                      \_mm\_cvtss\_f32(\_mm\_shuffle\_ps(from.v, from.v, 3)));
00129 \}
00130 
00131 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<std::complex<float> >(\textcolor{keyword}{const} std::complex<float> *   addr) \{ 
      \_mm\_prefetch((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)(addr), \_MM\_HINT\_T0); \}
00132 
00133 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float>  pfirst<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00134 \{
00135 \textcolor{preprocessor}{  #if EIGEN\_GNUC\_AT\_MOST(4,3)}
00136   \textcolor{comment}{// Workaround gcc 4.2 ICE - this is not performance wise ideal, but who cares...}
00137   \textcolor{comment}{// This workaround also fix invalid code generation with gcc 4.3}
00138   EIGEN\_ALIGN16 std::complex<float> res[2];
00139   \_mm\_store\_ps((\textcolor{keywordtype}{float}*)res, a.v);
00140   \textcolor{keywordflow}{return} res[0];
00141 \textcolor{preprocessor}{  #else}
00142   std::complex<float> res;
00143   \_mm\_storel\_pi((\_\_m64*)&res, a.v);
00144   \textcolor{keywordflow}{return} res;
00145 \textcolor{preprocessor}{  #endif}
00146 \}
00147 
00148 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf preverse(\textcolor{keyword}{const} Packet2cf& a) \{ \textcolor{keywordflow}{return} Packet2cf(\_mm\_castpd\_ps(
      preverse(Packet2d(\_mm\_castps\_pd(a.v))))); \}
00149 
00150 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> predux<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00151 \{
00152   \textcolor{keywordflow}{return} pfirst(Packet2cf(\_mm\_add\_ps(a.v, \_mm\_movehl\_ps(a.v,a.v))));
00153 \}
00154 
00155 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf preduxp<Packet2cf>(\textcolor{keyword}{const} Packet2cf* vecs)
00156 \{
00157   \textcolor{keywordflow}{return} Packet2cf(\_mm\_add\_ps(\_mm\_movelh\_ps(vecs[0].v,vecs[1].v), \_mm\_movehl\_ps(vecs[1].v,vecs[0].v)));
00158 \}
00159 
00160 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> predux\_mul<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00161 \{
00162   \textcolor{keywordflow}{return} pfirst(pmul(a, Packet2cf(\_mm\_movehl\_ps(a.v,a.v))));
00163 \}
00164 
00165 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00166 \textcolor{keyword}{struct }palign\_impl<Offset,Packet2cf>
00167 \{
00168   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet2cf& first, \textcolor{keyword}{const} Packet2cf& second)
00169   \{
00170     \textcolor{keywordflow}{if} (Offset==1)
00171     \{
00172       first.v = \_mm\_movehl\_ps(first.v, first.v);
00173       first.v = \_mm\_movelh\_ps(first.v, second.v);
00174     \}
00175   \}
00176 \};
00177 
00178 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet2cf, false,true>
00179 \{
00180   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00181 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00182 
00183   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)\textcolor{keyword}{ const}
00184 \textcolor{keyword}{  }\{
00185 \textcolor{preprocessor}{    #ifdef EIGEN\_VECTORIZE\_SSE3}
00186     \textcolor{keywordflow}{return} internal::pmul(a, pconj(b));
00187 \textcolor{preprocessor}{    #else}
00188     \textcolor{keyword}{const} \_\_m128 mask = \_mm\_castsi128\_ps(\_mm\_setr\_epi32(0x00000000,0x80000000,0x00000000,0x80000000));
00189     \textcolor{keywordflow}{return} Packet2cf(\_mm\_add\_ps(\_mm\_xor\_ps(\_mm\_mul\_ps(vec4f\_swizzle1(a.v, 0, 0, 2, 2), b.v), mask),
00190                                 \_mm\_mul\_ps(vec4f\_swizzle1(a.v, 1, 1, 3, 3),
00191                                            vec4f\_swizzle1(b.v, 1, 0, 3, 2))));
00192 \textcolor{preprocessor}{    #endif}
00193   \}
00194 \};
00195 
00196 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet2cf, true,false>
00197 \{
00198   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00199 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00200 
00201   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)\textcolor{keyword}{ const}
00202 \textcolor{keyword}{  }\{
00203 \textcolor{preprocessor}{    #ifdef EIGEN\_VECTORIZE\_SSE3}
00204     \textcolor{keywordflow}{return} internal::pmul(pconj(a), b);
00205 \textcolor{preprocessor}{    #else}
00206     \textcolor{keyword}{const} \_\_m128 mask = \_mm\_castsi128\_ps(\_mm\_setr\_epi32(0x00000000,0x80000000,0x00000000,0x80000000));
00207     \textcolor{keywordflow}{return} Packet2cf(\_mm\_add\_ps(\_mm\_mul\_ps(vec4f\_swizzle1(a.v, 0, 0, 2, 2), b.v),
00208                                 \_mm\_xor\_ps(\_mm\_mul\_ps(vec4f\_swizzle1(a.v, 1, 1, 3, 3),
00209                                                       vec4f\_swizzle1(b.v, 1, 0, 3, 2)), mask)));
00210 \textcolor{preprocessor}{    #endif}
00211   \}
00212 \};
00213 
00214 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet2cf, true,true>
00215 \{
00216   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00217 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00218 
00219   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)\textcolor{keyword}{ const}
00220 \textcolor{keyword}{  }\{
00221 \textcolor{preprocessor}{    #ifdef EIGEN\_VECTORIZE\_SSE3}
00222     \textcolor{keywordflow}{return} pconj(internal::pmul(a, b));
00223 \textcolor{preprocessor}{    #else}
00224     \textcolor{keyword}{const} \_\_m128 mask = \_mm\_castsi128\_ps(\_mm\_setr\_epi32(0x00000000,0x80000000,0x00000000,0x80000000));
00225     \textcolor{keywordflow}{return} Packet2cf(\_mm\_sub\_ps(\_mm\_xor\_ps(\_mm\_mul\_ps(vec4f\_swizzle1(a.v, 0, 0, 2, 2), b.v), mask),
00226                                 \_mm\_mul\_ps(vec4f\_swizzle1(a.v, 1, 1, 3, 3),
00227                                            vec4f\_swizzle1(b.v, 1, 0, 3, 2))));
00228 \textcolor{preprocessor}{    #endif}
00229   \}
00230 \};
00231 
00232 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet4f, Packet2cf, false,false>
00233 \{
00234   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet4f& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00235 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00236 
00237   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet4f& x, \textcolor{keyword}{const} Packet2cf& y)\textcolor{keyword}{ const}
00238 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} Packet2cf(Eigen::internal::pmul<Packet4f>(x, y.v)); \}
00239 \};
00240 
00241 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet4f, false,false>
00242 \{
00243   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet4f& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00244 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00245 
00246   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet4f& y)\textcolor{keyword}{ const}
00247 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} Packet2cf(Eigen::internal::pmul<Packet4f>(x.v, y)); \}
00248 \};
00249 
00250 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pdiv<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)
00251 \{
00252   \textcolor{comment}{// TODO optimize it for SSE3 and 4}
00253   Packet2cf res = conj\_helper<Packet2cf,Packet2cf,false,true>().pmul(a,b);
00254   \_\_m128 s = \_mm\_mul\_ps(b.v,b.v);
00255   \textcolor{keywordflow}{return} Packet2cf(\_mm\_div\_ps(res.v,\_mm\_add\_ps(s,\_mm\_castsi128\_ps(\_mm\_shuffle\_epi32(\_mm\_castps\_si128(s), 0
      xb1)))));
00256 \}
00257 
00258 EIGEN\_STRONG\_INLINE Packet2cf pcplxflip\textcolor{comment}{/* <Packet2cf> */}(\textcolor{keyword}{const} Packet2cf& x)
00259 \{
00260   \textcolor{keywordflow}{return} Packet2cf(vec4f\_swizzle1(x.v, 1, 0, 3, 2));
00261 \}
00262 
00263 
00264 \textcolor{comment}{//---------- double ----------}
\Hypertarget{eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_complex_8h_source_l00265}\hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{00265} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}
00266 \{
00267   EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}() \{\}
00268   EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\textcolor{keyword}{const} \_\_m128d& a) : v(a) \{\}
00269   \_\_m128d  v;
00270 \};
00271 
00272 \textcolor{comment}{// Use the packet\_traits defined in AVX/PacketMath.h instead if we're going}
00273 \textcolor{comment}{// to leverage AVX instructions.}
00274 \textcolor{preprocessor}{#ifndef EIGEN\_VECTORIZE\_AVX}
00275 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits}<std::\hyperlink{structcomplex}{complex}<double> >  : 
      \hyperlink{struct_eigen_1_1internal_1_1default__packet__traits}{default\_packet\_traits}
00276 \{
00277   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} type;
00278   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} \hyperlink{struct_eigen_1_1half}{half};
00279   \textcolor{keyword}{enum} \{
00280     Vectorizable = 1,
00281     AlignedOnScalar = 0,
00282     size = 1,
00283     HasHalfPacket = 0,
00284 
00285     HasAdd    = 1,
00286     HasSub    = 1,
00287     HasMul    = 1,
00288     HasDiv    = 1,
00289     HasNegate = 1,
00290     HasAbs    = 0,
00291     HasAbs2   = 0,
00292     HasMin    = 0,
00293     HasMax    = 0,
00294     HasSetLinear = 0
00295   \};
00296 \};
00297 \textcolor{preprocessor}{#endif}
00298 
\Hypertarget{eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_complex_8h_source_l00299}\hyperlink{struct_eigen_1_1internal_1_1unpacket__traits_3_01_packet1cd_01_4}{00299} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{unpacket\_traits}<\hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}> \{ \textcolor{keyword}{typedef} std::complex<double> type; \textcolor{keyword}{
      enum} \{size=1, alignment=\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{half}; \};
00300 
00301 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} padd<Packet1cd>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& b) \{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_add\_pd(a.v,b.v)); \}
00302 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} psub<Packet1cd>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& b) \{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_sub\_pd(a.v,b.v)); \}
00303 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pnegate(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a) \{ \textcolor{keywordflow}{return} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(pnegate(Packet2d(a.v))); \}
00304 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pconj(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a)
00305 \{
00306   \textcolor{keyword}{const} \_\_m128d mask = \_mm\_castsi128\_pd(\_mm\_set\_epi32(0x80000000,0x0,0x0,0x0));
00307   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_xor\_pd(a.v,mask));
00308 \}
00309 
00310 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pmul<Packet1cd>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& b)
00311 \{
00312 \textcolor{preprocessor}{  #ifdef EIGEN\_VECTORIZE\_SSE3}
00313   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_addsub\_pd(\_mm\_mul\_pd(\_mm\_movedup\_pd(a.v), b.v),
00314                                  \_mm\_mul\_pd(vec2d\_swizzle1(a.v, 1, 1),
00315                                             vec2d\_swizzle1(b.v, 1, 0))));
00316 \textcolor{preprocessor}{  #else}
00317   \textcolor{keyword}{const} \_\_m128d mask = \_mm\_castsi128\_pd(\_mm\_set\_epi32(0x0,0x0,0x80000000,0x0));
00318   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_add\_pd(\_mm\_mul\_pd(vec2d\_swizzle1(a.v, 0, 0), b.v),
00319                               \_mm\_xor\_pd(\_mm\_mul\_pd(vec2d\_swizzle1(a.v, 1, 1),
00320                                                     vec2d\_swizzle1(b.v, 1, 0)), mask)));
00321 \textcolor{preprocessor}{  #endif}
00322 \}
00323 
00324 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pand   <Packet1cd>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& b) \{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_and\_pd(a.v,b.v)); \}
00325 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} por    <Packet1cd>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& b) \{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_or\_pd(a.v,b.v)); \}
00326 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pxor   <Packet1cd>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& b) \{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_xor\_pd(a.v,b.v)); \}
00327 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pandnot<Packet1cd>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& b) \{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_andnot\_pd(a.v,b.v)); \}
00328 
00329 \textcolor{comment}{// FIXME force unaligned load, this is a temporary fix}
00330 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pload <Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from)
00331 \{ EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(pload<Packet2d>((\textcolor{keyword}{const} \textcolor{keywordtype}{double}*)from)); \}
00332 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} ploadu<Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from)
00333 \{ EIGEN\_DEBUG\_UNALIGNED\_LOAD \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(ploadu<Packet2d>((\textcolor{keyword}{const} \textcolor{keywordtype}{double}*)from)); \}
00334 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pset1<Packet1cd>(\textcolor{keyword}{const} std::complex<double>&  from)
00335 \{ \textcolor{comment}{/* here we really have to use unaligned loads :( */} \textcolor{keywordflow}{return} ploadu<Packet1cd>(&from); \}
00336 
00337 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} ploaddup<Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from) \{ \textcolor{keywordflow}{
      return} pset1<Packet1cd>(*from); \}
00338 
00339 \textcolor{comment}{// FIXME force unaligned store, this is a temporary fix}
00340 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore <std::complex<double> >(std::complex<double> *   to, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& from) \{ EIGEN\_DEBUG\_ALIGNED\_STORE pstore((\textcolor{keywordtype}{double}*)to, Packet2d(from.v)); \}
00341 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<std::complex<double> >(std::complex<double> *   to, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& from) \{ EIGEN\_DEBUG\_UNALIGNED\_STORE pstoreu((\textcolor{keywordtype}{double}*)to, Packet2d(from.v)); \}
00342 
00343 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<std::complex<double> >(\textcolor{keyword}{const} std::complex<double> *   addr) \{ 
      \_mm\_prefetch((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)(addr), \_MM\_HINT\_T0); \}
00344 
00345 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double>  pfirst<Packet1cd>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a)
00346 \{
00347   EIGEN\_ALIGN16 \textcolor{keywordtype}{double} res[2];
00348   \_mm\_store\_pd(res, a.v);
00349   \textcolor{keywordflow}{return} std::complex<double>(res[0],res[1]);
00350 \}
00351 
00352 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} preverse(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a) \{ \textcolor{keywordflow}{return} a; \}
00353 
00354 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double> predux<Packet1cd>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a)
00355 \{
00356   \textcolor{keywordflow}{return} pfirst(a);
00357 \}
00358 
00359 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} preduxp<Packet1cd>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}* vecs)
00360 \{
00361   \textcolor{keywordflow}{return} vecs[0];
00362 \}
00363 
00364 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double> predux\_mul<Packet1cd>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a)
00365 \{
00366   \textcolor{keywordflow}{return} pfirst(a);
00367 \}
00368 
00369 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
\Hypertarget{eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_complex_8h_source_l00370}\hyperlink{struct_eigen_1_1internal_1_1palign__impl_3_01_offset_00_01_packet1cd_01_4}{00370} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1palign__impl}{palign\_impl}<Offset,\hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}>
00371 \{
00372   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(\hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& \textcolor{comment}{/*first*/}, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& \textcolor{comment}{/*second*/})
00373   \{
00374     \textcolor{comment}{// FIXME is it sure we never have to align a Packet1cd?}
00375     \textcolor{comment}{// Even though a std::complex<double> has 16 bytes, it is not necessarily aligned on a 16 bytes
       boundary...}
00376   \}
00377 \};
00378 
\Hypertarget{eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_complex_8h_source_l00379}\hyperlink{struct_eigen_1_1internal_1_1conj__helper_3_01_packet1cd_00_01_packet1cd_00_01false_00_01true_01_4}{00379} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper}<\hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}, \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}, false,true>
00380 \{
00381   EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pmadd(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& x, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& y, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& c)\textcolor{keyword}{ const}
00382 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00383 
00384   EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pmul(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& b)\textcolor{keyword}{ const}
00385 \textcolor{keyword}{  }\{
00386 \textcolor{preprocessor}{    #ifdef EIGEN\_VECTORIZE\_SSE3}
00387     \textcolor{keywordflow}{return} internal::pmul(a, pconj(b));
00388 \textcolor{preprocessor}{    #else}
00389     \textcolor{keyword}{const} \_\_m128d mask = \_mm\_castsi128\_pd(\_mm\_set\_epi32(0x80000000,0x0,0x0,0x0));
00390     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_add\_pd(\_mm\_xor\_pd(\_mm\_mul\_pd(vec2d\_swizzle1(a.v, 0, 0), b.v), mask),
00391                                 \_mm\_mul\_pd(vec2d\_swizzle1(a.v, 1, 1),
00392                                            vec2d\_swizzle1(b.v, 1, 0))));
00393 \textcolor{preprocessor}{    #endif}
00394   \}
00395 \};
00396 
\Hypertarget{eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_complex_8h_source_l00397}\hyperlink{struct_eigen_1_1internal_1_1conj__helper_3_01_packet1cd_00_01_packet1cd_00_01true_00_01false_01_4}{00397} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper}<\hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}, \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}, true,false>
00398 \{
00399   EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pmadd(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& x, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& y, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& c)\textcolor{keyword}{ const}
00400 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00401 
00402   EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pmul(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& b)\textcolor{keyword}{ const}
00403 \textcolor{keyword}{  }\{
00404 \textcolor{preprocessor}{    #ifdef EIGEN\_VECTORIZE\_SSE3}
00405     \textcolor{keywordflow}{return} internal::pmul(pconj(a), b);
00406 \textcolor{preprocessor}{    #else}
00407     \textcolor{keyword}{const} \_\_m128d mask = \_mm\_castsi128\_pd(\_mm\_set\_epi32(0x80000000,0x0,0x0,0x0));
00408     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_add\_pd(\_mm\_mul\_pd(vec2d\_swizzle1(a.v, 0, 0), b.v),
00409                                 \_mm\_xor\_pd(\_mm\_mul\_pd(vec2d\_swizzle1(a.v, 1, 1),
00410                                                       vec2d\_swizzle1(b.v, 1, 0)), mask)));
00411 \textcolor{preprocessor}{    #endif}
00412   \}
00413 \};
00414 
\Hypertarget{eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_complex_8h_source_l00415}\hyperlink{struct_eigen_1_1internal_1_1conj__helper_3_01_packet1cd_00_01_packet1cd_00_01true_00_01true_01_4}{00415} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper}<\hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}, \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}, true,true>
00416 \{
00417   EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pmadd(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& x, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& y, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& c)\textcolor{keyword}{ const}
00418 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00419 
00420   EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pmul(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& b)\textcolor{keyword}{ const}
00421 \textcolor{keyword}{  }\{
00422 \textcolor{preprocessor}{    #ifdef EIGEN\_VECTORIZE\_SSE3}
00423     \textcolor{keywordflow}{return} pconj(internal::pmul(a, b));
00424 \textcolor{preprocessor}{    #else}
00425     \textcolor{keyword}{const} \_\_m128d mask = \_mm\_castsi128\_pd(\_mm\_set\_epi32(0x80000000,0x0,0x0,0x0));
00426     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_sub\_pd(\_mm\_xor\_pd(\_mm\_mul\_pd(vec2d\_swizzle1(a.v, 0, 0), b.v), mask),
00427                                 \_mm\_mul\_pd(vec2d\_swizzle1(a.v, 1, 1),
00428                                            vec2d\_swizzle1(b.v, 1, 0))));
00429 \textcolor{preprocessor}{    #endif}
00430   \}
00431 \};
00432 
\Hypertarget{eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_complex_8h_source_l00433}\hyperlink{struct_eigen_1_1internal_1_1conj__helper_3_01_packet2d_00_01_packet1cd_00_01false_00_01false_01_4}{00433} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper}<Packet2d, \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}, false,false>
00434 \{
00435   EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pmadd(\textcolor{keyword}{const} Packet2d& x, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& y, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& c)\textcolor{keyword}{ const}
00436 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00437 
00438   EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pmul(\textcolor{keyword}{const} Packet2d& x, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& y)\textcolor{keyword}{ const}
00439 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(Eigen::internal::pmul<Packet2d>(x, y.v)); \}
00440 \};
00441 
\Hypertarget{eigen_2_eigen_2src_2_core_2arch_2_s_s_e_2_complex_8h_source_l00442}\hyperlink{struct_eigen_1_1internal_1_1conj__helper_3_01_packet1cd_00_01_packet2d_00_01false_00_01false_01_4}{00442} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper}<\hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}, Packet2d, false,false>
00443 \{
00444   EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pmadd(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& x, \textcolor{keyword}{const} Packet2d& y, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& c)\textcolor{keyword}{ const}
00445 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00446 
00447   EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pmul(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& x, \textcolor{keyword}{const} Packet2d& y)\textcolor{keyword}{ const}
00448 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(Eigen::internal::pmul<Packet2d>(x.v, y)); \}
00449 \};
00450 
00451 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pdiv<Packet1cd>(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& a, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& b)
00452 \{
00453   \textcolor{comment}{// TODO optimize it for SSE3 and 4}
00454   \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} res = \hyperlink{struct_eigen_1_1internal_1_1conj__helper_3_01_packet1cd_00_01_packet1cd_00_01false_00_01true_01_4}{conj\_helper<Packet1cd,Packet1cd,false,true>}
      ().pmul(a,b);
00455   \_\_m128d s = \_mm\_mul\_pd(b.v,b.v);
00456   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(\_mm\_div\_pd(res.v, \_mm\_add\_pd(s,\_mm\_shuffle\_pd(s, s, 0x1))));
00457 \}
00458 
00459 EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pcplxflip\textcolor{comment}{/* <Packet1cd> */}(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}& x)
00460 \{
00461   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}(preverse(Packet2d(x.v)));
00462 \}
00463 
00464 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void}
00465 ptranspose(\hyperlink{struct_eigen_1_1internal_1_1_packet_block}{PacketBlock<Packet2cf,2>}& kernel) \{
00466   \_\_m128d w1 = \_mm\_castps\_pd(kernel.packet[0].v);
00467   \_\_m128d w2 = \_mm\_castps\_pd(kernel.packet[1].v);
00468 
00469   \_\_m128 tmp = \_mm\_castpd\_ps(\_mm\_unpackhi\_pd(w1, w2));
00470   kernel.packet[0].v = \_mm\_castpd\_ps(\_mm\_unpacklo\_pd(w1, w2));
00471   kernel.packet[1].v = tmp;
00472 \}
00473 
00474 \textcolor{keyword}{template}<>  EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet2cf}{Packet2cf} pblend(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_selector}{Selector<2>}& ifPacket, \textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1internal_1_1_packet2cf}{Packet2cf}& thenPacket, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet2cf}{Packet2cf}& elsePacket) \{
00475   \_\_m128d result = pblend<Packet2d>(ifPacket, \_mm\_castps\_pd(thenPacket.v), \_mm\_castps\_pd(elsePacket.v));
00476   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet2cf}{Packet2cf}(\_mm\_castpd\_ps(result));
00477 \}
00478 
00479 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet2cf}{Packet2cf} pinsertfirst(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet2cf}{Packet2cf}& a, 
      std::complex<float> b)
00480 \{
00481   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet2cf}{Packet2cf}(\_mm\_loadl\_pi(a.v, reinterpret\_cast<const \_\_m64*>(&b)));
00482 \}
00483 
00484 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pinsertfirst(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}&, 
      std::complex<double> b)
00485 \{
00486   \textcolor{keywordflow}{return} pset1<Packet1cd>(b);
00487 \}
00488 
00489 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet2cf}{Packet2cf} pinsertlast(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet2cf}{Packet2cf}& a, 
      std::complex<float> b)
00490 \{
00491   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1_packet2cf}{Packet2cf}(\_mm\_loadh\_pi(a.v, reinterpret\_cast<const \_\_m64*>(&b)));
00492 \}
00493 
00494 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd} pinsertlast(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1internal_1_1_packet1cd}{Packet1cd}&, 
      std::complex<double> b)
00495 \{
00496   \textcolor{keywordflow}{return} pset1<Packet1cd>(b);
00497 \}
00498 
00499 \} \textcolor{comment}{// end namespace internal}
00500 
00501 \} \textcolor{comment}{// end namespace Eigen}
00502 
00503 \textcolor{preprocessor}{#endif // EIGEN\_COMPLEX\_SSE\_H}
\end{DoxyCode}
