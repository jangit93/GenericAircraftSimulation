\hypertarget{matio_2visual__studio_2test_2eigen_2blas_2level1__real__impl_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/blas/level1\+\_\+real\+\_\+impl.h}
\label{matio_2visual__studio_2test_2eigen_2blas_2level1__real__impl_8h_source}\index{level1\+\_\+real\+\_\+impl.\+h@{level1\+\_\+real\+\_\+impl.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "common.h"}
00011 
00012 \textcolor{comment}{// computes the sum of magnitudes of all vector elements or, for a complex vector x, the sum}
00013 \textcolor{comment}{// res = |Rex1| + |Imx1| + |Rex2| + |Imx2| + ... + |Rexn| + |Imxn|, where x is a vector of order n}
00014 RealScalar EIGEN\_BLAS\_FUNC(asum)(\textcolor{keywordtype}{int} *n, RealScalar *px, \textcolor{keywordtype}{int} *incx)
00015 \{
00016 \textcolor{comment}{//   std::cerr << "\_asum " << *n << " " << *incx << "\(\backslash\)n";}
00017 
00018   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00019 
00020   \textcolor{keywordflow}{if}(*n<=0) \textcolor{keywordflow}{return} 0;
00021 
00022   \textcolor{keywordflow}{if}(*incx==1)  \textcolor{keywordflow}{return} make\_vector(x,*n).cwiseAbs().sum();
00023   \textcolor{keywordflow}{else}          \textcolor{keywordflow}{return} make\_vector(x,*n,std::abs(*incx)).cwiseAbs().sum();
00024 \}
00025 
00026 \textcolor{comment}{// computes a vector-vector dot product.}
00027 Scalar EIGEN\_BLAS\_FUNC(dot)(\textcolor{keywordtype}{int} *n, RealScalar *px, \textcolor{keywordtype}{int} *incx, RealScalar *py, \textcolor{keywordtype}{int} *incy)
00028 \{
00029 \textcolor{comment}{//   std::cerr << "\_dot " << *n << " " << *incx << " " << *incy << "\(\backslash\)n";}
00030 
00031   \textcolor{keywordflow}{if}(*n<=0) \textcolor{keywordflow}{return} 0;
00032 
00033   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00034   Scalar* y = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(py);
00035 
00036   \textcolor{keywordflow}{if}(*incx==1 && *incy==1)    \textcolor{keywordflow}{return} (make\_vector(x,*n).cwiseProduct(make\_vector(y,*n))).sum();
00037   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx>0 && *incy>0) \textcolor{keywordflow}{return} (make\_vector(x,*n,*incx).cwiseProduct(make\_vector(y,*n,*incy))).sum();
00038   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx<0 && *incy>0) \textcolor{keywordflow}{return} (make\_vector(x,*n,-*incx).reverse().cwiseProduct(make\_vector(y,*n,*
      incy))).sum();
00039   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx>0 && *incy<0) \textcolor{keywordflow}{return} (make\_vector(x,*n,*incx).cwiseProduct(make\_vector(y,*n,-*incy).reverse
      ())).sum();
00040   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx<0 && *incy<0) \textcolor{keywordflow}{return} (make\_vector(x,*n,-*incx).reverse().cwiseProduct(make\_vector(y,*n,-*
      incy).reverse())).sum();
00041   \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} 0;
00042 \}
00043 
00044 \textcolor{comment}{// computes the Euclidean norm of a vector.}
00045 \textcolor{comment}{// FIXME}
00046 Scalar EIGEN\_BLAS\_FUNC(nrm2)(\textcolor{keywordtype}{int} *n, RealScalar *px, \textcolor{keywordtype}{int} *incx)
00047 \{
00048 \textcolor{comment}{//   std::cerr << "\_nrm2 " << *n << " " << *incx << "\(\backslash\)n";}
00049   \textcolor{keywordflow}{if}(*n<=0) \textcolor{keywordflow}{return} 0;
00050 
00051   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00052 
00053   \textcolor{keywordflow}{if}(*incx==1)  \textcolor{keywordflow}{return} make\_vector(x,*n).stableNorm();
00054   \textcolor{keywordflow}{else}          \textcolor{keywordflow}{return} make\_vector(x,*n,std::abs(*incx)).stableNorm();
00055 \}
00056 
00057 \textcolor{keywordtype}{int} EIGEN\_BLAS\_FUNC(rot)(\textcolor{keywordtype}{int} *n, RealScalar *px, \textcolor{keywordtype}{int} *incx, RealScalar *py, \textcolor{keywordtype}{int} *incy, RealScalar *pc, 
      RealScalar *ps)
00058 \{
00059 \textcolor{comment}{//   std::cerr << "\_rot " << *n << " " << *incx << " " << *incy << "\(\backslash\)n";}
00060   \textcolor{keywordflow}{if}(*n<=0) \textcolor{keywordflow}{return} 0;
00061 
00062   Scalar* x = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(px);
00063   Scalar* y = \textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(py);
00064   Scalar c = *\textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(pc);
00065   Scalar s = *\textcolor{keyword}{reinterpret\_cast<}Scalar*\textcolor{keyword}{>}(ps);
00066 
00067   \hyperlink{group___core___module_class_eigen_1_1_map}{StridedVectorType} vx(make\_vector(x,*n,std::abs(*incx)));
00068   \hyperlink{group___core___module_class_eigen_1_1_map}{StridedVectorType} vy(make\_vector(y,*n,std::abs(*incy)));
00069 
00070   \hyperlink{group___core___module_class_eigen_1_1_reverse}{Reverse<StridedVectorType>} rvx(vx);
00071   \hyperlink{group___core___module_class_eigen_1_1_reverse}{Reverse<StridedVectorType>} rvy(vy);
00072 
00073        \textcolor{keywordflow}{if}(*incx<0 && *incy>0) internal::apply\_rotation\_in\_the\_plane(rvx, vy, 
      \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<Scalar>}(c,s));
00074   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*incx>0 && *incy<0) internal::apply\_rotation\_in\_the\_plane(vx, rvy, 
      \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<Scalar>}(c,s));
00075   \textcolor{keywordflow}{else}                        internal::apply\_rotation\_in\_the\_plane(vx, vy,  
      \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<Scalar>}(c,s));
00076 
00077 
00078   \textcolor{keywordflow}{return} 0;
00079 \}
00080 
00081 \textcolor{comment}{/*}
00082 \textcolor{comment}{// performs rotation of points in the modified plane.}
00083 \textcolor{comment}{int EIGEN\_BLAS\_FUNC(rotm)(int *n, RealScalar *px, int *incx, RealScalar *py, int *incy, RealScalar *param)}
00084 \textcolor{comment}{\{}
00085 \textcolor{comment}{  Scalar* x = reinterpret\_cast<Scalar*>(px);}
00086 \textcolor{comment}{  Scalar* y = reinterpret\_cast<Scalar*>(py);}
00087 \textcolor{comment}{}
00088 \textcolor{comment}{  // TODO}
00089 \textcolor{comment}{}
00090 \textcolor{comment}{  return 0;}
00091 \textcolor{comment}{\}}
00092 \textcolor{comment}{}
00093 \textcolor{comment}{// computes the modified parameters for a Givens rotation.}
00094 \textcolor{comment}{int EIGEN\_BLAS\_FUNC(rotmg)(RealScalar *d1, RealScalar *d2, RealScalar *x1, RealScalar *x2, RealScalar *
      param)}
00095 \textcolor{comment}{\{}
00096 \textcolor{comment}{  // TODO}
00097 \textcolor{comment}{}
00098 \textcolor{comment}{  return 0;}
00099 \textcolor{comment}{\}}
00100 \textcolor{comment}{*/}
\end{DoxyCode}
