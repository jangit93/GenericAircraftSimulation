\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u__panel__bmod_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+L\+U/\+Sparse\+L\+U\+\_\+panel\+\_\+bmod.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u__panel__bmod_8h_source}\index{Sparse\+L\+U\+\_\+panel\+\_\+bmod.\+h@{Sparse\+L\+U\+\_\+panel\+\_\+bmod.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2012 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{comment}{/* }
00012 \textcolor{comment}{ }
00013 \textcolor{comment}{ * NOTE: This file is the modified version of [s,d,c,z]panel\_bmod.c file in SuperLU }
00014 \textcolor{comment}{ }
00015 \textcolor{comment}{ * -- SuperLU routine (version 3.0) --}
00016 \textcolor{comment}{ * Univ. of California Berkeley, Xerox Palo Alto Research Center,}
00017 \textcolor{comment}{ * and Lawrence Berkeley National Lab.}
00018 \textcolor{comment}{ * October 15, 2003}
00019 \textcolor{comment}{ *}
00020 \textcolor{comment}{ * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.}
00021 \textcolor{comment}{ *}
00022 \textcolor{comment}{ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY}
00023 \textcolor{comment}{ * EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.}
00024 \textcolor{comment}{ *}
00025 \textcolor{comment}{ * Permission is hereby granted to use or copy this program for any}
00026 \textcolor{comment}{ * purpose, provided the above notices are retained on all copies.}
00027 \textcolor{comment}{ * Permission to modify the code and to distribute modified code is}
00028 \textcolor{comment}{ * granted, provided the above notices are retained, and a notice that}
00029 \textcolor{comment}{ * the code was modified is included with the above copyright notice.}
00030 \textcolor{comment}{ */}
00031 \textcolor{preprocessor}{#ifndef SPARSELU\_PANEL\_BMOD\_H}
00032 \textcolor{preprocessor}{#define SPARSELU\_PANEL\_BMOD\_H}
00033 
00034 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00035 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00036 
00055 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} StorageIndex>
00056 \textcolor{keywordtype}{void} \hyperlink{group___sparse_l_u___module_a277936738db49e25285164ac25c498c3}{SparseLUImpl<Scalar,StorageIndex>::panel\_bmod}(\textcolor{keyword}{const} 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} w, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} jcol, 
00057                                             \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nseg, ScalarVector& dense, ScalarVector& tempv
      ,
00058                                             IndexVector& segrep, IndexVector& repfnz, GlobalLU\_t& glu)
00059 \{
00060   
00061   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} ksub,jj,nextl\_col; 
00062   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} fsupc, nsupc, nsupr, nrow; 
00063   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} krep, kfnz; 
00064   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lptr; \textcolor{comment}{// points to the row subscripts of a supernode }
00065   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} luptr; \textcolor{comment}{// ...}
00066   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} segsize,no\_zeros ; 
00067   \textcolor{comment}{// For each nonz supernode segment of U[*,j] in topological order}
00068   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = nseg - 1; 
00069   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} PacketSize = internal::packet\_traits<Scalar>::size;
00070   
00071   \textcolor{keywordflow}{for} (ksub = 0; ksub < nseg; ksub++)
00072   \{ \textcolor{comment}{// For each updating supernode}
00073     \textcolor{comment}{/* krep = representative of current k-th supernode}
00074 \textcolor{comment}{     * fsupc =  first supernodal column}
00075 \textcolor{comment}{     * nsupc = number of columns in a supernode}
00076 \textcolor{comment}{     * nsupr = number of rows in a supernode}
00077 \textcolor{comment}{     */}
00078     krep = segrep(k); k--; 
00079     fsupc = glu.xsup(glu.supno(krep)); 
00080     nsupc = krep - fsupc + 1; 
00081     nsupr = glu.xlsub(fsupc+1) - glu.xlsub(fsupc); 
00082     nrow = nsupr - nsupc; 
00083     lptr = glu.xlsub(fsupc); 
00084     
00085     \textcolor{comment}{// loop over the panel columns to detect the actual number of columns and rows}
00086     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} u\_rows = 0;
00087     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} u\_cols = 0;
00088     \textcolor{keywordflow}{for} (jj = jcol; jj < jcol + w; jj++)
00089     \{
00090       nextl\_col = (jj-jcol) * m; 
00091       VectorBlock<IndexVector> repfnz\_col(repfnz, nextl\_col, m); \textcolor{comment}{// First nonzero column index for each row}
00092       
00093       kfnz = repfnz\_col(krep); 
00094       \textcolor{keywordflow}{if} ( kfnz == emptyIdxLU ) 
00095         \textcolor{keywordflow}{continue}; \textcolor{comment}{// skip any zero segment}
00096       
00097       segsize = krep - kfnz + 1;
00098       u\_cols++;
00099       u\_rows = (std::max)(segsize,u\_rows);
00100     \}
00101     
00102     \textcolor{keywordflow}{if}(nsupc >= 2)
00103     \{ 
00104       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} ldu = internal::first\_multiple<Index>(u\_rows, PacketSize);
00105       Map<ScalarMatrix, Aligned,  OuterStride<> > U(tempv.data(), u\_rows, u\_cols, OuterStride<>(ldu));
00106       
00107       \textcolor{comment}{// gather U}
00108       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} u\_col = 0;
00109       \textcolor{keywordflow}{for} (jj = jcol; jj < jcol + w; jj++)
00110       \{
00111         nextl\_col = (jj-jcol) * m; 
00112         VectorBlock<IndexVector> repfnz\_col(repfnz, nextl\_col, m); \textcolor{comment}{// First nonzero column index for each
       row}
00113         VectorBlock<ScalarVector> dense\_col(dense, nextl\_col, m); \textcolor{comment}{// Scatter/gather entire matrix column
       from/to here}
00114         
00115         kfnz = repfnz\_col(krep); 
00116         \textcolor{keywordflow}{if} ( kfnz == emptyIdxLU ) 
00117           \textcolor{keywordflow}{continue}; \textcolor{comment}{// skip any zero segment}
00118         
00119         segsize = krep - kfnz + 1;
00120         luptr = glu.xlusup(fsupc);    
00121         no\_zeros = kfnz - fsupc; 
00122         
00123         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} isub = lptr + no\_zeros;
00124         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} off = u\_rows-segsize;
00125         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < off; i++) U(i,u\_col) = 0;
00126         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < segsize; i++)
00127         \{
00128           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} irow = glu.lsub(isub); 
00129           U(i+off,u\_col) = dense\_col(irow); 
00130           ++isub; 
00131         \}
00132         u\_col++;
00133       \}
00134       \textcolor{comment}{// solve U = A^-1 U}
00135       luptr = glu.xlusup(fsupc);
00136       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lda = glu.xlusup(fsupc+1) - glu.xlusup(fsupc);
00137       no\_zeros = (krep - u\_rows + 1) - fsupc;
00138       luptr += lda * no\_zeros + no\_zeros;
00139       MappedMatrixBlock A(glu.lusup.data()+luptr, u\_rows, u\_rows, OuterStride<>(lda) );
00140       U = A.template triangularView<UnitLower>().solve(U);
00141       
00142       \textcolor{comment}{// update}
00143       luptr += u\_rows;
00144       MappedMatrixBlock B(glu.lusup.data()+luptr, nrow, u\_rows, OuterStride<>(lda) );
00145       eigen\_assert(tempv.size()>w*ldu + nrow*w + 1);
00146       
00147       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} ldl = internal::first\_multiple<Index>(nrow, PacketSize);
00148       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset = (PacketSize-internal::first\_default\_aligned(B.data(), PacketSize)) % PacketSize;
00149       MappedMatrixBlock L(tempv.data()+w*ldu+offset, nrow, u\_cols, OuterStride<>(ldl));
00150       
00151       L.setZero();
00152       internal::sparselu\_gemm<Scalar>(L.rows(), L.cols(), B.cols(), B.data(), B.outerStride(), U.data(), U.
      outerStride(), L.data(), L.outerStride());
00153       
00154       \textcolor{comment}{// scatter U and L}
00155       u\_col = 0;
00156       \textcolor{keywordflow}{for} (jj = jcol; jj < jcol + w; jj++)
00157       \{
00158         nextl\_col = (jj-jcol) * m; 
00159         VectorBlock<IndexVector> repfnz\_col(repfnz, nextl\_col, m); \textcolor{comment}{// First nonzero column index for each
       row}
00160         VectorBlock<ScalarVector> dense\_col(dense, nextl\_col, m); \textcolor{comment}{// Scatter/gather entire matrix column
       from/to here}
00161         
00162         kfnz = repfnz\_col(krep); 
00163         \textcolor{keywordflow}{if} ( kfnz == emptyIdxLU ) 
00164           \textcolor{keywordflow}{continue}; \textcolor{comment}{// skip any zero segment}
00165         
00166         segsize = krep - kfnz + 1;
00167         no\_zeros = kfnz - fsupc; 
00168         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} isub = lptr + no\_zeros;
00169         
00170         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} off = u\_rows-segsize;
00171         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < segsize; i++)
00172         \{
00173           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} irow = glu.lsub(isub++); 
00174           dense\_col(irow) = U.coeff(i+off,u\_col);
00175           U.coeffRef(i+off,u\_col) = 0;
00176         \}
00177         
00178         \textcolor{comment}{// Scatter l into SPA dense[]}
00179         \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < nrow; i++)
00180         \{
00181           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} irow = glu.lsub(isub++); 
00182           dense\_col(irow) -= L.coeff(i,u\_col);
00183           L.coeffRef(i,u\_col) = 0;
00184         \}
00185         u\_col++;
00186       \}
00187     \}
00188     \textcolor{keywordflow}{else} \textcolor{comment}{// level 2 only}
00189     \{
00190       \textcolor{comment}{// Sequence through each column in the panel}
00191       \textcolor{keywordflow}{for} (jj = jcol; jj < jcol + w; jj++)
00192       \{
00193         nextl\_col = (jj-jcol) * m; 
00194         VectorBlock<IndexVector> repfnz\_col(repfnz, nextl\_col, m); \textcolor{comment}{// First nonzero column index for each
       row}
00195         VectorBlock<ScalarVector> dense\_col(dense, nextl\_col, m); \textcolor{comment}{// Scatter/gather entire matrix column
       from/to here}
00196         
00197         kfnz = repfnz\_col(krep); 
00198         \textcolor{keywordflow}{if} ( kfnz == emptyIdxLU ) 
00199           \textcolor{keywordflow}{continue}; \textcolor{comment}{// skip any zero segment}
00200         
00201         segsize = krep - kfnz + 1;
00202         luptr = glu.xlusup(fsupc);
00203         
00204         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lda = glu.xlusup(fsupc+1)-glu.xlusup(fsupc);\textcolor{comment}{// nsupr}
00205         
00206         \textcolor{comment}{// Perform a trianglar solve and block update, }
00207         \textcolor{comment}{// then scatter the result of sup-col update to dense[]}
00208         no\_zeros = kfnz - fsupc; 
00209               \textcolor{keywordflow}{if}(segsize==1)  LU\_kernel\_bmod<1>::run(segsize, dense\_col, tempv, glu.lusup, luptr, lda, nrow
      , glu.lsub, lptr, no\_zeros);
00210         \textcolor{keywordflow}{else}  \textcolor{keywordflow}{if}(segsize==2)  LU\_kernel\_bmod<2>::run(segsize, dense\_col, tempv, glu.lusup, luptr, lda, nrow
      , glu.lsub, lptr, no\_zeros);
00211         \textcolor{keywordflow}{else}  \textcolor{keywordflow}{if}(segsize==3)  LU\_kernel\_bmod<3>::run(segsize, dense\_col, tempv, glu.lusup, luptr, lda, nrow
      , glu.lsub, lptr, no\_zeros);
00212         \textcolor{keywordflow}{else}                  LU\_kernel\_bmod<Dynamic>::run(segsize, dense\_col, tempv, glu.lusup, luptr, lda
      , nrow, glu.lsub, lptr, no\_zeros); 
00213       \} \textcolor{comment}{// End for each column in the panel }
00214     \}
00215     
00216   \} \textcolor{comment}{// End for each updating supernode}
00217 \} \textcolor{comment}{// end panel bmod}
00218 
00219 \} \textcolor{comment}{// end namespace internal}
00220 
00221 \} \textcolor{comment}{// end namespace Eigen}
00222 
00223 \textcolor{preprocessor}{#endif // SPARSELU\_PANEL\_BMOD\_H}
\end{DoxyCode}
