\hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source}{}\section{eigen/\+Eigen/src/\+Core/util/\+Blas\+Util.h}
\label{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source}\index{Blas\+Util.\+h@{Blas\+Util.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009-2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_BLASUTIL\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_BLASUTIL\_H}
00012 
00013 \textcolor{comment}{// This file contains many lightweight helper classes used to}
00014 \textcolor{comment}{// implement and control fast level 2 and level 3 BLAS-like routines.}
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00017 
00018 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00019 
00020 \textcolor{comment}{// forward declarations}
00021 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} mr, \textcolor{keywordtype}{int} nr, \textcolor{keywordtype}{bool} 
      ConjugateLhs=false, \textcolor{keywordtype}{bool} ConjugateRhs=false>
00022 \textcolor{keyword}{struct }gebp\_kernel;
00023 
00024 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} nr, \textcolor{keywordtype}{int} StorageOrder, \textcolor{keywordtype}{bool} Conjugate = f
      alse, \textcolor{keywordtype}{bool} PanelMode=false>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00025}\hyperlink{struct_eigen_1_1internal_1_1gemm__pack__rhs}{00025} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1gemm__pack__rhs}{gemm\_pack\_rhs};
00026 
00027 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} Pack1, \textcolor{keywordtype}{int} Pack2, \textcolor{keywordtype}{int} StorageOrder, \textcolor{keywordtype}{bool}
       Conjugate = false, \textcolor{keywordtype}{bool} PanelMode = false>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00028}\hyperlink{struct_eigen_1_1internal_1_1gemm__pack__lhs}{00028} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1gemm__pack__lhs}{gemm\_pack\_lhs};
00029 
00030 \textcolor{keyword}{template}<
00031   \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00032   \textcolor{keyword}{typename} LhsScalar, \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00033   \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs,
00034   \textcolor{keywordtype}{int} ResStorageOrder>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00035}\hyperlink{struct_eigen_1_1internal_1_1general__matrix__matrix__product}{00035} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1general__matrix__matrix__product}{general\_matrix\_matrix\_product};
00036 
00037 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00038          \textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} LhsMapper, \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00039          \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{typename} RhsMapper, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int} Version=Specialized>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00040}\hyperlink{struct_eigen_1_1internal_1_1general__matrix__vector__product}{00040} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1general__matrix__vector__product}{general\_matrix\_vector\_product};
00041 
00042 
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00043}\hyperlink{struct_eigen_1_1internal_1_1conj__if}{00043} \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Conjugate> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__if}{conj\_if};
00044 
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00045}\hyperlink{struct_eigen_1_1internal_1_1conj__if_3_01true_01_4}{00045} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__if}{conj\_if}<true> \{
00046   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00047   \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module}{T} operator()(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& x)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} numext::conj(x); \}
00048   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00049   \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module}{T} pconj(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& x)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::pconj(x); \}
00050 \};
00051 
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00052}\hyperlink{struct_eigen_1_1internal_1_1conj__if_3_01false_01_4}{00052} \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__if}{conj\_if}<false> \{
00053   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00054   \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& operator()(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& x)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} x; \}
00055   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00056   \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& pconj(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module}{T}& x)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} x; \}
00057 \};
00058 
00059 \textcolor{comment}{// Generic implementation for custom complex types.}
00060 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{bool} ConjLhs, \textcolor{keywordtype}{bool} ConjRhs>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00061}\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{00061} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper}
00062 \{
00063   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_scalar_binary_op_traits}{ScalarBinaryOpTraits<LhsScalar,RhsScalar>::ReturnType}
       Scalar;
00064 
00065   EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} LhsScalar& x, \textcolor{keyword}{const} RhsScalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{ const}
00066 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00067 
00068   EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} LhsScalar& x, \textcolor{keyword}{const} RhsScalar& y)\textcolor{keyword}{ const}
00069 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1conj__if}{conj\_if<ConjLhs>}()(x) *  \hyperlink{struct_eigen_1_1internal_1_1conj__if}{conj\_if<ConjRhs>}()(y); \}
00070 \};
00071 
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00072}\hyperlink{struct_eigen_1_1internal_1_1conj__helper_3_01_scalar_00_01_scalar_00_01false_00_01false_01_4}{00072} \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper}<Scalar,Scalar,false,false>
00073 \{
00074   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{
       const }\{ \textcolor{keywordflow}{return} internal::pmadd(x,y,c); \}
00075   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 
      internal::pmul(x,y); \}
00076 \};
00077 
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00078}\hyperlink{struct_eigen_1_1internal_1_1conj__helper_3_01std_1_1complex_3_01_real_scalar_01_4_00_01std_1_1co17cad1c9f1dd5f8fd2568a2fb541b29b}{00078} \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper}<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<RealScalar>, 
      std::complex<RealScalar>, false,true>
00079 \{
00080   \textcolor{keyword}{typedef} std::complex<RealScalar> Scalar;
00081   EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{ const}
00082 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} c + pmul(x,y); \}
00083 
00084   EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y)\textcolor{keyword}{ const}
00085 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} Scalar(numext::real(x)*numext::real(y) + numext::imag(x)*numext::imag(y), numext::imag(x)*
      numext::real(y) - numext::real(x)*numext::imag(y)); \}
00086 \};
00087 
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00088}\hyperlink{struct_eigen_1_1internal_1_1conj__helper_3_01std_1_1complex_3_01_real_scalar_01_4_00_01std_1_1coc8c8eb305908066796b4a168e94f9c59}{00088} \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper}<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<RealScalar>, 
      std::complex<RealScalar>, true,false>
00089 \{
00090   \textcolor{keyword}{typedef} std::complex<RealScalar> Scalar;
00091   EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{ const}
00092 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} c + pmul(x,y); \}
00093 
00094   EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y)\textcolor{keyword}{ const}
00095 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} Scalar(numext::real(x)*numext::real(y) + numext::imag(x)*numext::imag(y), numext::real(x)*
      numext::imag(y) - numext::imag(x)*numext::real(y)); \}
00096 \};
00097 
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00098}\hyperlink{struct_eigen_1_1internal_1_1conj__helper_3_01std_1_1complex_3_01_real_scalar_01_4_00_01std_1_1co7e279017f32d052cf58f01f1590ee000}{00098} \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper}<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<RealScalar>, 
      std::complex<RealScalar>, true,true>
00099 \{
00100   \textcolor{keyword}{typedef} std::complex<RealScalar> Scalar;
00101   EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{ const}
00102 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} c + pmul(x,y); \}
00103 
00104   EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} Scalar& y)\textcolor{keyword}{ const}
00105 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} Scalar(numext::real(x)*numext::real(y) - numext::imag(x)*numext::imag(y), - numext::real(x)*
      numext::imag(y) - numext::imag(x)*numext::real(y)); \}
00106 \};
00107 
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00108}\hyperlink{struct_eigen_1_1internal_1_1conj__helper_3_01std_1_1complex_3_01_real_scalar_01_4_00_01_real_scalar_00_01_conj_00_01false_01_4}{00108} \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar,\textcolor{keywordtype}{bool} Conj> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper}<\hyperlink{namespacestd}{std}::
      \hyperlink{structcomplex}{complex}<RealScalar>, RealScalar, Conj,false>
00109 \{
00110   \textcolor{keyword}{typedef} std::complex<RealScalar> Scalar;
00111   EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} RealScalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{ const}
00112 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00113   EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} Scalar& x, \textcolor{keyword}{const} RealScalar& y)\textcolor{keyword}{ const}
00114 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1conj__if}{conj\_if<Conj>}()(x)*y; \}
00115 \};
00116 
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00117}\hyperlink{struct_eigen_1_1internal_1_1conj__helper_3_01_real_scalar_00_01std_1_1complex_3_01_real_scalar_01_4_00_01false_00_01_conj_01_4}{00117} \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar,\textcolor{keywordtype}{bool} Conj> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1conj__helper}{conj\_helper}<RealScalar, 
      \hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<RealScalar>, false,Conj>
00118 \{
00119   \textcolor{keyword}{typedef} std::complex<RealScalar> Scalar;
00120   EIGEN\_STRONG\_INLINE Scalar pmadd(\textcolor{keyword}{const} RealScalar& x, \textcolor{keyword}{const} Scalar& y, \textcolor{keyword}{const} Scalar& c)\textcolor{keyword}{ const}
00121 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(c, pmul(x,y)); \}
00122   EIGEN\_STRONG\_INLINE Scalar pmul(\textcolor{keyword}{const} RealScalar& x, \textcolor{keyword}{const} Scalar& y)\textcolor{keyword}{ const}
00123 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} x*\hyperlink{struct_eigen_1_1internal_1_1conj__if}{conj\_if<Conj>}()(y); \}
00124 \};
00125 
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00126}\hyperlink{struct_eigen_1_1internal_1_1get__factor}{00126} \textcolor{keyword}{template}<\textcolor{keyword}{typename} From,\textcolor{keyword}{typename} To> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1get__factor}{get\_factor} \{
00127   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE To run(\textcolor{keyword}{const} From& x) \{ \textcolor{keywordflow}{return} To(x); \}
00128 \};
00129 
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00130}\hyperlink{struct_eigen_1_1internal_1_1get__factor_3_01_scalar_00_01typename_01_num_traits_3_01_scalar_01_4_1_1_real_01_4}{00130} \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1get__factor}{get\_factor}<Scalar,typename \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits}<Scalar>::Real> \{
00131   EIGEN\_DEVICE\_FUNC
00132   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real} run(\textcolor{keyword}{const} Scalar& x) \{
       \textcolor{keywordflow}{return} numext::real(x); \}
00133 \};
00134 
00135 
00136 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00137}\hyperlink{class_eigen_1_1internal_1_1_blas_vector_mapper}{00137} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1_blas_vector_mapper}{BlasVectorMapper} \{
00138   \textcolor{keyword}{public}:
00139   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \hyperlink{class_eigen_1_1internal_1_1_blas_vector_mapper}{BlasVectorMapper}(Scalar *data) : m\_data(data) \{\}
00140 
00141   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE Scalar operator()(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i)\textcolor{keyword}{ const }\{
00142     \textcolor{keywordflow}{return} m\_data[i];
00143   \}
00144   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet, \textcolor{keywordtype}{int} AlignmentType>
00145   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \hyperlink{union_eigen_1_1internal_1_1_packet}{Packet} load(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i)\textcolor{keyword}{ const }\{
00146     \textcolor{keywordflow}{return} ploadt<Packet, AlignmentType>(m\_data + i);
00147   \}
00148 
00149   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Packet>
00150   EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{bool} aligned(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i)\textcolor{keyword}{ const }\{
00151     \textcolor{keywordflow}{return} (UIntPtr(m\_data+i)%\textcolor{keyword}{sizeof}(\hyperlink{union_eigen_1_1internal_1_1_packet}{Packet}))==0;
00152   \}
00153 
00154   \textcolor{keyword}{protected}:
00155   Scalar* m\_data;
00156 \};
00157 
00158 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} AlignmentType>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00159}\hyperlink{class_eigen_1_1internal_1_1_blas_linear_mapper}{00159} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1_blas_linear_mapper}{BlasLinearMapper} \{
00160   \textcolor{keyword}{public}:
00161   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<Scalar>::type} Packet;
00162   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<Scalar>::half} HalfPacket;
00163 
00164   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \hyperlink{class_eigen_1_1internal_1_1_blas_linear_mapper}{BlasLinearMapper}(Scalar *data) : m\_data(data) \{\}
00165 
00166   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \textcolor{keywordtype}{void} prefetch(\textcolor{keywordtype}{int} i)\textcolor{keyword}{ const }\{
00167     internal::prefetch(&\textcolor{keyword}{operator}()(i));
00168   \}
00169 
00170   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE Scalar& operator()(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i)\textcolor{keyword}{ const }\{
00171     \textcolor{keywordflow}{return} m\_data[i];
00172   \}
00173 
00174   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE Packet loadPacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i)\textcolor{keyword}{ const }\{
00175     \textcolor{keywordflow}{return} ploadt<Packet, AlignmentType>(m\_data + i);
00176   \}
00177 
00178   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE HalfPacket loadHalfPacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i)\textcolor{keyword}{ const }\{
00179     \textcolor{keywordflow}{return} ploadt<HalfPacket, AlignmentType>(m\_data + i);
00180   \}
00181 
00182   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \textcolor{keywordtype}{void} storePacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, \textcolor{keyword}{const} Packet &p)\textcolor{keyword}{ const }\{
00183     pstoret<Scalar, Packet, AlignmentType>(m\_data + i, p);
00184   \}
00185 
00186   \textcolor{keyword}{protected}:
00187   Scalar *m\_data;
00188 \};
00189 
00190 \textcolor{comment}{// Lightweight helper class to access matrix coefficients.}
00191 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} StorageOrder, \textcolor{keywordtype}{int} AlignmentType = Unaligned>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00192}\hyperlink{class_eigen_1_1internal_1_1blas__data__mapper}{00192} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1blas__data__mapper}{blas\_data\_mapper} \{
00193   \textcolor{keyword}{public}:
00194   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<Scalar>::type} Packet;
00195   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1packet__traits}{packet\_traits<Scalar>::half} HalfPacket;
00196 
00197   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1_blas_linear_mapper}{BlasLinearMapper<Scalar, Index, AlignmentType>} 
      \hyperlink{class_eigen_1_1internal_1_1_blas_linear_mapper}{LinearMapper};
00198   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1internal_1_1_blas_vector_mapper}{BlasVectorMapper<Scalar, Index>} 
      \hyperlink{class_eigen_1_1internal_1_1_blas_vector_mapper}{VectorMapper};
00199 
00200   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \hyperlink{class_eigen_1_1internal_1_1blas__data__mapper}{blas\_data\_mapper}(Scalar* data, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride) : m\_data(data), m\_stride(stride) \{\}
00201 
00202   EIGEN\_DEVICE\_FUNC  EIGEN\_ALWAYS\_INLINE 
      \hyperlink{class_eigen_1_1internal_1_1blas__data__mapper}{blas\_data\_mapper<Scalar, Index, StorageOrder, AlignmentType>}
00203   getSubMapper(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j)\textcolor{keyword}{ const }\{
00204     \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1internal_1_1blas__data__mapper}{blas\_data\_mapper<Scalar, Index, StorageOrder, AlignmentType>}
      (&operator()(i, j), m\_stride);
00205   \}
00206 
00207   EIGEN\_DEVICE\_FUNC  EIGEN\_ALWAYS\_INLINE LinearMapper getLinearMapper(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j)\textcolor{keyword}{ const }\{
00208     \textcolor{keywordflow}{return} LinearMapper(&\textcolor{keyword}{operator}()(i, j));
00209   \}
00210 
00211   EIGEN\_DEVICE\_FUNC  EIGEN\_ALWAYS\_INLINE VectorMapper getVectorMapper(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j)\textcolor{keyword}{ const }\{
00212     \textcolor{keywordflow}{return} VectorMapper(&\textcolor{keyword}{operator}()(i, j));
00213   \}
00214 
00215 
00216   EIGEN\_DEVICE\_FUNC
00217   EIGEN\_ALWAYS\_INLINE Scalar& operator()(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j)\textcolor{keyword}{ const }\{
00218     \textcolor{keywordflow}{return} m\_data[StorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? j + i*m\_stride : i + j*m\_stride];
00219   \}
00220 
00221   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE Packet loadPacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j)\textcolor{keyword}{ const }\{
00222     \textcolor{keywordflow}{return} ploadt<Packet, AlignmentType>(&operator()(i, j));
00223   \}
00224 
00225   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE HalfPacket loadHalfPacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j)\textcolor{keyword}{ const }\{
00226     \textcolor{keywordflow}{return} ploadt<HalfPacket, AlignmentType>(&operator()(i, j));
00227   \}
00228 
00229   \textcolor{keyword}{template}<\textcolor{keyword}{typename} SubPacket>
00230   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE \textcolor{keywordtype}{void} scatterPacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j, \textcolor{keyword}{const} SubPacket &p)\textcolor{keyword}{
       const }\{
00231     pscatter<Scalar, SubPacket>(&operator()(i, j), p, m\_stride);
00232   \}
00233 
00234   \textcolor{keyword}{template}<\textcolor{keyword}{typename} SubPacket>
00235   EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE SubPacket gatherPacket(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j)\textcolor{keyword}{ const }\{
00236     \textcolor{keywordflow}{return} pgather<Scalar, SubPacket>(&operator()(i, j), m\_stride);
00237   \}
00238 
00239   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_stride; \}
00240   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{const} Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data; \}
00241 
00242   EIGEN\_DEVICE\_FUNC \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstAligned(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size)\textcolor{keyword}{ const }\{
00243     \textcolor{keywordflow}{if} (UIntPtr(m\_data)%\textcolor{keyword}{sizeof}(Scalar)) \{
00244       \textcolor{keywordflow}{return} -1;
00245     \}
00246     \textcolor{keywordflow}{return} internal::first\_default\_aligned(m\_data, size);
00247   \}
00248 
00249   \textcolor{keyword}{protected}:
00250   Scalar* EIGEN\_RESTRICT m\_data;
00251   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_stride;
00252 \};
00253 
00254 \textcolor{comment}{// lightweight helper class to access matrix coefficients (const version)}
00255 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keywordtype}{int} StorageOrder>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00256}\hyperlink{class_eigen_1_1internal_1_1const__blas__data__mapper}{00256} \textcolor{keyword}{class }\hyperlink{class_eigen_1_1internal_1_1const__blas__data__mapper}{const\_blas\_data\_mapper} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1internal_1_1blas__data__mapper}{blas\_data\_mapper}<const Scalar, 
      Index, StorageOrder> \{
00257   \textcolor{keyword}{public}:
00258   EIGEN\_ALWAYS\_INLINE \hyperlink{class_eigen_1_1internal_1_1const__blas__data__mapper}{const\_blas\_data\_mapper}(\textcolor{keyword}{const} Scalar *data, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride) : \hyperlink{class_eigen_1_1internal_1_1blas__data__mapper}{blas\_data\_mapper<const Scalar, Index, StorageOrder>}
      (data, stride) \{\}
00259 
00260   EIGEN\_ALWAYS\_INLINE \hyperlink{class_eigen_1_1internal_1_1const__blas__data__mapper}{const\_blas\_data\_mapper<Scalar, Index, StorageOrder>}
       getSubMapper(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j)\textcolor{keyword}{ const }\{
00261     \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1internal_1_1const__blas__data__mapper}{const\_blas\_data\_mapper<Scalar, Index, StorageOrder>}
      (&(this->operator()(i, j)), this->m\_stride);
00262   \}
00263 \};
00264 
00265 
00266 \textcolor{comment}{/* Helper class to analyze the factors of a Product expression.}
00267 \textcolor{comment}{ * In particular it allows to pop out operator-, scalar multiples,}
00268 \textcolor{comment}{ * and conjugate */}
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00269}\hyperlink{struct_eigen_1_1internal_1_1blas__traits}{00269} \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType> \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}
00270 \{
00271   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>::Scalar} Scalar;
00272   \textcolor{keyword}{typedef} \textcolor{keyword}{const} XprType& ExtractType;
00273   \textcolor{keyword}{typedef} XprType \_ExtractType;
00274   \textcolor{keyword}{enum} \{
00275     IsComplex = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsComplex},
00276     IsTransposed = \textcolor{keyword}{false},
00277     NeedToConjugate = \textcolor{keyword}{false},
00278     HasUsableDirectAccess = (    (int(XprType::Flags)&\hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit})
00279                               && (   \textcolor{keywordtype}{bool}(XprType::IsVectorAtCompileTime)
00280                                   || int(
      \hyperlink{struct_eigen_1_1internal_1_1inner__stride__at__compile__time}{inner\_stride\_at\_compile\_time<XprType>::ret}) == 1)
00281                              ) ?  1 : 0
00282   \};
00283   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{conditional}<bool(HasUsableDirectAccess),
00284     ExtractType,
00285     \textcolor{keyword}{typename} \_ExtractType::PlainObject
00286     >::type \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{DirectLinearAccessType};
00287   \textcolor{keyword}{static} \textcolor{keyword}{inline} ExtractType extract(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} x; \}
00288   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar extractScalarFactor(\textcolor{keyword}{const} XprType&) \{ \textcolor{keywordflow}{return} Scalar(1); \}
00289 \};
00290 
00291 \textcolor{comment}{// pop conjugate}
00292 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} NestedXpr>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00293}\hyperlink{struct_eigen_1_1internal_1_1blas__traits_3_01_cwise_unary_op_3_01scalar__conjugate__op_3_01_scal305db6e51b207e2ce8fc6ea06996a706}{00293} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<\hyperlink{group___core___module_class_eigen_1_1_cwise_unary_op}{CwiseUnaryOp}<\hyperlink{struct_eigen_1_1internal_1_1scalar__conjugate__op}{scalar\_conjugate\_op}<Scalar>, 
      NestedXpr> >
00294  : \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<NestedXpr>
00295 \{
00296   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits<NestedXpr>} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{Base};
00297   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_cwise_unary_op}{CwiseUnaryOp<scalar\_conjugate\_op<Scalar>}, NestedXpr> 
      \hyperlink{group___core___module_class_eigen_1_1_cwise_unary_op}{XprType};
00298   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::ExtractType ExtractType;
00299 
00300   \textcolor{keyword}{enum} \{
00301     IsComplex = \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsComplex},
00302     NeedToConjugate = Base::NeedToConjugate ? 0 : IsComplex
00303   \};
00304   \textcolor{keyword}{static} \textcolor{keyword}{inline} ExtractType extract(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} Base::extract(x.
      \hyperlink{group___core___module_a25d4402be360cf0b8ff867863da46c7d}{nestedExpression}()); \}
00305   \textcolor{keyword}{static} \textcolor{keyword}{inline} Scalar extractScalarFactor(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} conj(Base::extractScalarFactor(x.
      \hyperlink{group___core___module_a25d4402be360cf0b8ff867863da46c7d}{nestedExpression}())); \}
00306 \};
00307 
00308 \textcolor{comment}{// pop scalar multiple}
00309 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} NestedXpr, \textcolor{keyword}{typename} Plain>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00310}\hyperlink{struct_eigen_1_1internal_1_1blas__traits_3_01_cwise_binary_op_3_01scalar__product__op_3_01_scala460c90a32ed86eb7afe907bd9f50947d}{00310} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<\hyperlink{group___core___module_class_eigen_1_1_cwise_binary_op}{CwiseBinaryOp}<\hyperlink{struct_eigen_1_1internal_1_1scalar__product__op}{scalar\_product\_op}<Scalar>, const 
      \hyperlink{group___core___module_class_eigen_1_1_cwise_nullary_op}{CwiseNullaryOp}<\hyperlink{struct_eigen_1_1internal_1_1scalar__constant__op}{scalar\_constant\_op}<Scalar>,Plain>, NestedXpr> >
00311  : \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<NestedXpr>
00312 \{
00313   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits<NestedXpr>} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{Base};
00314   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_cwise_binary_op}{CwiseBinaryOp<scalar\_product\_op<Scalar>}, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_cwise_nullary_op}{CwiseNullaryOp<scalar\_constant\_op<Scalar>},Plain>, NestedXpr> 
      \hyperlink{group___core___module_class_eigen_1_1_cwise_binary_op}{XprType};
00315   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::ExtractType ExtractType;
00316   \textcolor{keyword}{static} \textcolor{keyword}{inline} ExtractType extract(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} Base::extract(x.
      \hyperlink{group___core___module_a3a61cbdf6d1adaa62f012045b04b6d09}{rhs}()); \}
00317   \textcolor{keyword}{static} \textcolor{keyword}{inline} Scalar extractScalarFactor(\textcolor{keyword}{const} XprType& x)
00318   \{ \textcolor{keywordflow}{return} x.\hyperlink{group___core___module_a0f73e7585dfb54d41c1983e1e6a4b269}{lhs}().functor().m\_other * Base::extractScalarFactor(x.\hyperlink{group___core___module_a3a61cbdf6d1adaa62f012045b04b6d09}{rhs}()); \}
00319 \};
00320 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} NestedXpr, \textcolor{keyword}{typename} Plain>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00321}\hyperlink{struct_eigen_1_1internal_1_1blas__traits_3_01_cwise_binary_op_3_01scalar__product__op_3_01_scala947462575c60123595df86e5556ae031}{00321} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<\hyperlink{group___core___module_class_eigen_1_1_cwise_binary_op}{CwiseBinaryOp}<\hyperlink{struct_eigen_1_1internal_1_1scalar__product__op}{scalar\_product\_op}<Scalar>, 
      NestedXpr, const \hyperlink{group___core___module_class_eigen_1_1_cwise_nullary_op}{CwiseNullaryOp}<\hyperlink{struct_eigen_1_1internal_1_1scalar__constant__op}{scalar\_constant\_op}<Scalar>,Plain> > >
00322  : \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<NestedXpr>
00323 \{
00324   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits<NestedXpr>} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{Base};
00325   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_cwise_binary_op}{CwiseBinaryOp<scalar\_product\_op<Scalar>}, NestedXpr, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_cwise_nullary_op}{CwiseNullaryOp<scalar\_constant\_op<Scalar>},Plain> > 
      \hyperlink{group___core___module_class_eigen_1_1_cwise_binary_op}{XprType};
00326   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::ExtractType ExtractType;
00327   \textcolor{keyword}{static} \textcolor{keyword}{inline} ExtractType extract(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} Base::extract(x.
      \hyperlink{group___core___module_a0f73e7585dfb54d41c1983e1e6a4b269}{lhs}()); \}
00328   \textcolor{keyword}{static} \textcolor{keyword}{inline} Scalar extractScalarFactor(\textcolor{keyword}{const} XprType& x)
00329   \{ \textcolor{keywordflow}{return} Base::extractScalarFactor(x.\hyperlink{group___core___module_a0f73e7585dfb54d41c1983e1e6a4b269}{lhs}()) * x.\hyperlink{group___core___module_a3a61cbdf6d1adaa62f012045b04b6d09}{rhs}().functor().m\_other; \}
00330 \};
00331 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Plain1, \textcolor{keyword}{typename} Plain2>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00332}\hyperlink{struct_eigen_1_1internal_1_1blas__traits_3_01_cwise_binary_op_3_01scalar__product__op_3_01_scala720e6aa72051d527ea4818c5301d9b21}{00332} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<\hyperlink{group___core___module_class_eigen_1_1_cwise_binary_op}{CwiseBinaryOp}<\hyperlink{struct_eigen_1_1internal_1_1scalar__product__op}{scalar\_product\_op}<Scalar>, const 
      \hyperlink{group___core___module_class_eigen_1_1_cwise_nullary_op}{CwiseNullaryOp}<\hyperlink{struct_eigen_1_1internal_1_1scalar__constant__op}{scalar\_constant\_op}<Scalar>,Plain1>,
00333                                                             const \hyperlink{group___core___module_class_eigen_1_1_cwise_nullary_op}{CwiseNullaryOp}<
      \hyperlink{struct_eigen_1_1internal_1_1scalar__constant__op}{scalar\_constant\_op}<Scalar>,Plain2> > >
00334  : \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<CwiseNullaryOp<scalar\_constant\_op<Scalar>,Plain1> >
00335 \{\};
00336 
00337 \textcolor{comment}{// pop opposite}
00338 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} NestedXpr>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00339}\hyperlink{struct_eigen_1_1internal_1_1blas__traits_3_01_cwise_unary_op_3_01scalar__opposite__op_3_01_scalabef74274251827708a3725df034ebf7d}{00339} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<\hyperlink{group___core___module_class_eigen_1_1_cwise_unary_op}{CwiseUnaryOp}<\hyperlink{struct_eigen_1_1internal_1_1scalar__opposite__op}{scalar\_opposite\_op}<Scalar>, 
      NestedXpr> >
00340  : \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<NestedXpr>
00341 \{
00342   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits<NestedXpr>} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{Base};
00343   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_cwise_unary_op}{CwiseUnaryOp<scalar\_opposite\_op<Scalar>}, NestedXpr> 
      \hyperlink{group___core___module_class_eigen_1_1_cwise_unary_op}{XprType};
00344   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::ExtractType ExtractType;
00345   \textcolor{keyword}{static} \textcolor{keyword}{inline} ExtractType extract(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} Base::extract(x.
      \hyperlink{group___core___module_a25d4402be360cf0b8ff867863da46c7d}{nestedExpression}()); \}
00346   \textcolor{keyword}{static} \textcolor{keyword}{inline} Scalar extractScalarFactor(\textcolor{keyword}{const} XprType& x)
00347   \{ \textcolor{keywordflow}{return} - Base::extractScalarFactor(x.\hyperlink{group___core___module_a25d4402be360cf0b8ff867863da46c7d}{nestedExpression}()); \}
00348 \};
00349 
00350 \textcolor{comment}{// pop/push transpose}
00351 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NestedXpr>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00352}\hyperlink{struct_eigen_1_1internal_1_1blas__traits_3_01_transpose_3_01_nested_xpr_01_4_01_4}{00352} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<\hyperlink{group___core___module_class_eigen_1_1_transpose}{Transpose}<NestedXpr> >
00353  : \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<NestedXpr>
00354 \{
00355   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NestedXpr::Scalar Scalar;
00356   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits<NestedXpr>} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{Base};
00357   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_transpose}{Transpose<NestedXpr>} \hyperlink{group___core___module_class_eigen_1_1_transpose}{XprType};
00358   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_transpose}{Transpose<const typename Base::\_ExtractType>}  
      \hyperlink{group___core___module_class_eigen_1_1_transpose}{ExtractType}; \textcolor{comment}{// const to get rid of a compile error; anyway blas traits are only used on the RHS}
00359   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_transpose}{Transpose<const typename Base::\_ExtractType>} 
      \hyperlink{group___core___module_class_eigen_1_1_transpose}{\_ExtractType};
00360   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1conditional}{conditional}<bool(Base::HasUsableDirectAccess),
00361     ExtractType,
00362     \textcolor{keyword}{typename} ExtractType::PlainObject
00363     >::type \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{DirectLinearAccessType};
00364   \textcolor{keyword}{enum} \{
00365     IsTransposed = Base::IsTransposed ? 0 : 1
00366   \};
00367   \textcolor{keyword}{static} \textcolor{keyword}{inline} ExtractType extract(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} ExtractType(Base::extract(x.
      \hyperlink{group___core___module_a72aefbf67f5e3caf62a99f73409b4a63}{nestedExpression}())); \}
00368   \textcolor{keyword}{static} \textcolor{keyword}{inline} Scalar extractScalarFactor(\textcolor{keyword}{const} XprType& x) \{ \textcolor{keywordflow}{return} Base::extractScalarFactor(x.
      \hyperlink{group___core___module_a72aefbf67f5e3caf62a99f73409b4a63}{nestedExpression}()); \}
00369 \};
00370 
00371 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00372}\hyperlink{struct_eigen_1_1internal_1_1blas__traits_3_01const_01_t_01_4}{00372} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<const \hyperlink{group___sparse_core___module}{T}>
00373      : \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits}<T>
00374 \{\};
00375 
00376 template<typename T, bool HasUsableDirectAccess=blas\_traits<T>::HasUsableDirectAccess>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00377}\hyperlink{struct_eigen_1_1internal_1_1extract__data__selector}{00377} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1extract__data__selector}{extract\_data\_selector} \{
00378   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{typename} T::Scalar* run(\textcolor{keyword}{const} T& m)
00379   \{
00380     \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1blas__traits}{blas\_traits<T>::extract}(m).data();
00381   \}
00382 \};
00383 
00384 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
\Hypertarget{eigen_2_eigen_2src_2_core_2util_2_blas_util_8h_source_l00385}\hyperlink{struct_eigen_1_1internal_1_1extract__data__selector_3_01_t_00_01false_01_4}{00385} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1extract__data__selector}{extract\_data\_selector}<T,false> \{
00386   \textcolor{keyword}{static} \textcolor{keyword}{typename} T::Scalar* run(\textcolor{keyword}{const} T&) \{ \textcolor{keywordflow}{return} 0; \}
00387 \};
00388 
00389 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{const} \textcolor{keyword}{typename} T::Scalar* extract\_data(\textcolor{keyword}{const} T& m)
00390 \{
00391   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1internal_1_1extract__data__selector}{extract\_data\_selector<T>::run}(m);
00392 \}
00393 
00394 \} \textcolor{comment}{// end namespace internal}
00395 
00396 \} \textcolor{comment}{// end namespace Eigen}
00397 
00398 \textcolor{preprocessor}{#endif // EIGEN\_BLASUTIL\_H}
\end{DoxyCode}
