\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_dense_product_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+Core/\+Sparse\+Dense\+Product.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_dense_product_8h_source}\index{Sparse\+Dense\+Product.\+h@{Sparse\+Dense\+Product.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSEDENSEPRODUCT\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SPARSEDENSEPRODUCT\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }product\_promote\_storage\_type<Sparse,Dense, OuterProduct> \{ \textcolor{keyword}{typedef} Sparse ret; \};
00018 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }product\_promote\_storage\_type<Dense,Sparse, OuterProduct> \{ \textcolor{keyword}{typedef} Sparse ret; \};
00019 
00020 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType,
00021          \textcolor{keyword}{typename} AlphaType,
00022          \textcolor{keywordtype}{int} LhsStorageOrder = ((SparseLhsType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},
00023          \textcolor{keywordtype}{bool} ColPerCol = ((DenseRhsType::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit})==0) || 
      DenseRhsType::ColsAtCompileTime==1>
00024 \textcolor{keyword}{struct }sparse\_time\_dense\_product\_impl;
00025 
00026 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType>
00027 \textcolor{keyword}{struct }sparse\_time\_dense\_product\_impl<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::
      Scalar, \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}, true>
00028 \{
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<SparseLhsType>::type Lhs;
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseRhsType>::type Rhs;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseResType>::type Res;
00032   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<Lhs>::InnerIterator LhsInnerIterator;
00033   \textcolor{keyword}{typedef} evaluator<Lhs> LhsEval;
00034   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} SparseLhsType& lhs, \textcolor{keyword}{const} DenseRhsType& rhs, DenseResType& res, \textcolor{keyword}{const} \textcolor{keyword}{typename} 
      Res::Scalar& alpha)
00035   \{
00036     LhsEval lhsEval(lhs);
00037     
00038     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = lhs.outerSize();
00039 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_OPENMP}
00040     \hyperlink{namespace_eigen_a820c0e0460934cc17eb6dacbad54a9f5}{Eigen::initParallel}();
00041     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} threads = \hyperlink{namespace_eigen_a9aca97d83e21b91a04ec079360dfffeb}{Eigen::nbThreads}();
00042 \textcolor{preprocessor}{#endif}
00043     
00044     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} c=0; c<rhs.cols(); ++c)
00045     \{
00046 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_OPENMP}
00047       \textcolor{comment}{// This 20000 threshold has been found experimentally on 2D and 3D Poisson problems.}
00048       \textcolor{comment}{// It basically represents the minimal amount of work to be done to be worth it.}
00049       \textcolor{keywordflow}{if}(threads>1 && lhsEval.nonZerosEstimate() > 20000)
00050       \{
00051 \textcolor{preprocessor}{        #pragma omp parallel for schedule(dynamic,(n+threads*4-1)/(threads*4)) num\_threads(threads)}
00052         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<n; ++i)
00053           processRow(lhsEval,rhs,res,alpha,i,c);
00054       \}
00055       \textcolor{keywordflow}{else}
00056 \textcolor{preprocessor}{#endif}
00057       \{
00058         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<n; ++i)
00059           processRow(lhsEval,rhs,res,alpha,i,c);
00060       \}
00061     \}
00062   \}
00063   
00064   \textcolor{keyword}{static} \textcolor{keywordtype}{void} processRow(\textcolor{keyword}{const} LhsEval& lhsEval, \textcolor{keyword}{const} DenseRhsType& rhs, DenseResType& res, \textcolor{keyword}{const} \textcolor{keyword}{typename}
       Res::Scalar& alpha, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col)
00065   \{
00066     \textcolor{keyword}{typename} Res::Scalar tmp(0);
00067     \textcolor{keywordflow}{for}(LhsInnerIterator it(lhsEval,i); it ;++it)
00068       tmp += it.value() * rhs.coeff(it.index(),col);
00069     res.coeffRef(i,col) += alpha * tmp;
00070   \}
00071   
00072 \};
00073 
00074 \textcolor{comment}{// FIXME: what is the purpose of the following specialization? Is it for the BlockedSparse format?}
00075 \textcolor{comment}{// -> let's disable it for now as it is conflicting with generic scalar*matrix and matrix*scalar operators}
00076 \textcolor{comment}{// template<typename T1, typename T2/*, int \_Options, typename \_StrideType*/>}
00077 \textcolor{comment}{// struct ScalarBinaryOpTraits<T1, Ref<T2/*, \_Options, \_StrideType*/> >}
00078 \textcolor{comment}{// \{}
00079 \textcolor{comment}{//   enum \{}
00080 \textcolor{comment}{//     Defined = 1}
00081 \textcolor{comment}{//   \};}
00082 \textcolor{comment}{//   typedef typename CwiseUnaryOp<scalar\_multiple2\_op<T1, typename T2::Scalar>, T2>::PlainObject
       ReturnType;}
00083 \textcolor{comment}{// \};}
00084 
00085 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType, \textcolor{keyword}{typename} AlphaType>
00086 \textcolor{keyword}{struct }sparse\_time\_dense\_product\_impl<SparseLhsType,DenseRhsType,DenseResType, AlphaType, 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}, true>
00087 \{
00088   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<SparseLhsType>::type Lhs;
00089   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseRhsType>::type Rhs;
00090   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseResType>::type Res;
00091   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<Lhs>::InnerIterator LhsInnerIterator;
00092   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} SparseLhsType& lhs, \textcolor{keyword}{const} DenseRhsType& rhs, DenseResType& res, \textcolor{keyword}{const} AlphaType& 
      alpha)
00093   \{
00094     evaluator<Lhs> lhsEval(lhs);
00095     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} c=0; c<rhs.cols(); ++c)
00096     \{
00097       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<lhs.outerSize(); ++j)
00098       \{
00099 \textcolor{comment}{//        typename Res::Scalar rhs\_j = alpha * rhs.coeff(j,c);}
00100         \textcolor{keyword}{typename} ScalarBinaryOpTraits<AlphaType, typename Rhs::Scalar>::ReturnType rhs\_j(alpha * rhs.coeff(
      j,c));
00101         \textcolor{keywordflow}{for}(LhsInnerIterator it(lhsEval,j); it ;++it)
00102           res.coeffRef(it.index(),c) += it.value() * rhs\_j;
00103       \}
00104     \}
00105   \}
00106 \};
00107 
00108 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType>
00109 \textcolor{keyword}{struct }sparse\_time\_dense\_product\_impl<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::
      Scalar, \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}, false>
00110 \{
00111   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<SparseLhsType>::type Lhs;
00112   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseRhsType>::type Rhs;
00113   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseResType>::type Res;
00114   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<Lhs>::InnerIterator LhsInnerIterator;
00115   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} SparseLhsType& lhs, \textcolor{keyword}{const} DenseRhsType& rhs, DenseResType& res, \textcolor{keyword}{const} \textcolor{keyword}{typename} 
      Res::Scalar& alpha)
00116   \{
00117     evaluator<Lhs> lhsEval(lhs);
00118     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<lhs.outerSize(); ++j)
00119     \{
00120       \textcolor{keyword}{typename} Res::RowXpr res\_j(res.row(j));
00121       \textcolor{keywordflow}{for}(LhsInnerIterator it(lhsEval,j); it ;++it)
00122         res\_j += (alpha*it.value()) * rhs.row(it.index());
00123     \}
00124   \}
00125 \};
00126 
00127 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType>
00128 \textcolor{keyword}{struct }sparse\_time\_dense\_product\_impl<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::
      Scalar, \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}, false>
00129 \{
00130   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<SparseLhsType>::type Lhs;
00131   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseRhsType>::type Rhs;
00132   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseResType>::type Res;
00133   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<Lhs>::InnerIterator LhsInnerIterator;
00134   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} SparseLhsType& lhs, \textcolor{keyword}{const} DenseRhsType& rhs, DenseResType& res, \textcolor{keyword}{const} \textcolor{keyword}{typename} 
      Res::Scalar& alpha)
00135   \{
00136     evaluator<Lhs> lhsEval(lhs);
00137     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<lhs.outerSize(); ++j)
00138     \{
00139       \textcolor{keyword}{typename} Rhs::ConstRowXpr rhs\_j(rhs.row(j));
00140       \textcolor{keywordflow}{for}(LhsInnerIterator it(lhsEval,j); it ;++it)
00141         res.row(it.index()) += (alpha*it.value()) * rhs\_j;
00142     \}
00143   \}
00144 \};
00145 
00146 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType,\textcolor{keyword}{typename} AlphaType>
00147 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} sparse\_time\_dense\_product(\textcolor{keyword}{const} SparseLhsType& lhs, \textcolor{keyword}{const} DenseRhsType& rhs, DenseResType& res,
       \textcolor{keyword}{const} AlphaType& alpha)
00148 \{
00149   sparse\_time\_dense\_product\_impl<SparseLhsType,DenseRhsType,DenseResType, AlphaType>::run(lhs, rhs, res, 
      alpha);
00150 \}
00151 
00152 \} \textcolor{comment}{// end namespace internal}
00153 
00154 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00155 
00156 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductType>
00157 \textcolor{keyword}{struct }generic\_product\_impl<Lhs, Rhs, SparseShape, DenseShape, ProductType>
00158  : generic\_product\_impl\_base<Lhs,Rhs,generic\_product\_impl<Lhs,Rhs,SparseShape,DenseShape,ProductType> >
00159 \{
00160   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Product<Lhs,Rhs>::Scalar Scalar;
00161   
00162   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>
00163   \textcolor{keyword}{static} \textcolor{keywordtype}{void} scaleAndAddTo(Dest& dst, \textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, \textcolor{keyword}{const} Scalar& alpha)
00164   \{
00165     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} nested\_eval<Lhs,((Rhs::Flags&RowMajorBit)==0) ? 1 : Rhs::ColsAtCompileTime>::type 
      LhsNested;
00166     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} nested\_eval<Rhs,((Lhs::Flags&RowMajorBit)==0) ? 1 : Dynamic>::type RhsNested;
00167     LhsNested lhsNested(lhs);
00168     RhsNested rhsNested(rhs);
00169     internal::sparse\_time\_dense\_product(lhsNested, rhsNested, dst, alpha);
00170   \}
00171 \};
00172 
00173 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductType>
00174 \textcolor{keyword}{struct }generic\_product\_impl<Lhs, Rhs, SparseTriangularShape, DenseShape, ProductType>
00175   : generic\_product\_impl<Lhs, Rhs, SparseShape, DenseShape, ProductType>
00176 \{\};
00177 
00178 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductType>
00179 \textcolor{keyword}{struct }generic\_product\_impl<Lhs, Rhs, DenseShape, SparseShape, ProductType>
00180   : generic\_product\_impl\_base<Lhs,Rhs,generic\_product\_impl<Lhs,Rhs,DenseShape,SparseShape,ProductType> >
00181 \{
00182   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Product<Lhs,Rhs>::Scalar Scalar;
00183   
00184   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst>
00185   \textcolor{keyword}{static} \textcolor{keywordtype}{void} scaleAndAddTo(Dst& dst, \textcolor{keyword}{const} Lhs& lhs, \textcolor{keyword}{const} Rhs& rhs, \textcolor{keyword}{const} Scalar& alpha)
00186   \{
00187     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} nested\_eval<Lhs,((Rhs::Flags&RowMajorBit)==0) ? Dynamic : 1>::type LhsNested;
00188     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} nested\_eval<Rhs,((Lhs::Flags&RowMajorBit)==RowMajorBit) ? 1 :
       Lhs::RowsAtCompileTime>::type RhsNested;
00189     LhsNested lhsNested(lhs);
00190     RhsNested rhsNested(rhs);
00191     
00192     \textcolor{comment}{// transpose everything}
00193     Transpose<Dst> dstT(dst);
00194     internal::sparse\_time\_dense\_product(rhsNested.transpose(), lhsNested.transpose(), dstT, alpha);
00195   \}
00196 \};
00197 
00198 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductType>
00199 \textcolor{keyword}{struct }generic\_product\_impl<Lhs, Rhs, DenseShape, SparseTriangularShape, ProductType>
00200   : generic\_product\_impl<Lhs, Rhs, DenseShape, SparseShape, ProductType>
00201 \{\};
00202 
00203 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT, \textcolor{keywordtype}{bool} NeedToTranspose>
00204 \textcolor{keyword}{struct }sparse\_dense\_outer\_product\_evaluator
00205 \{
00206 \textcolor{keyword}{protected}:
00207   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<NeedToTranspose,RhsT,LhsT>::type Lhs1;
00208   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<NeedToTranspose,LhsT,RhsT>::type ActualRhs;
00209   \textcolor{keyword}{typedef} Product<LhsT,RhsT,DefaultProduct> ProdXprType;
00210   
00211   \textcolor{comment}{// if the actual left-hand side is a dense vector,}
00212   \textcolor{comment}{// then build a sparse-view so that we can seamlessly iterate over it.}
00213   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<is\_same<typename internal::traits<Lhs1>::StorageKind,Sparse>::value,
00214             Lhs1, SparseView<Lhs1> >::type ActualLhs;
00215   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<is\_same<typename internal::traits<Lhs1>::StorageKind,Sparse>::value,
00216             Lhs1 \textcolor{keyword}{const}&, SparseView<Lhs1> >::type LhsArg;
00217             
00218   \textcolor{keyword}{typedef} evaluator<ActualLhs> LhsEval;
00219   \textcolor{keyword}{typedef} evaluator<ActualRhs> RhsEval;
00220   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} evaluator<ActualLhs>::InnerIterator LhsIterator;
00221   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ProdXprType::Scalar Scalar;
00222   
00223 \textcolor{keyword}{public}:
00224   \textcolor{keyword}{enum} \{
00225     Flags = NeedToTranspose ? \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} : 0,
00226     CoeffReadCost = \hyperlink{namespace_eigen_a3163430a1c13173faffde69016b48aaf}{HugeCost}
00227   \};
00228   
00229   \textcolor{keyword}{class }InnerIterator : \textcolor{keyword}{public} LhsIterator
00230   \{
00231   \textcolor{keyword}{public}:
00232     InnerIterator(\textcolor{keyword}{const} sparse\_dense\_outer\_product\_evaluator &xprEval, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer)
00233       : LhsIterator(xprEval.m\_lhsXprImpl, 0),
00234         m\_outer(outer),
00235         m\_empty(false),
00236         m\_factor(get(xprEval.m\_rhsXprImpl, outer, typename \hyperlink{namespaceinternal}{internal}::traits<ActualRhs>::StorageKind
      () ))
00237     \{\}
00238     
00239     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_outer; \}
00240     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} row()\textcolor{keyword}{   const }\{ \textcolor{keywordflow}{return} NeedToTranspose ? m\_outer : LhsIterator::index();
       \}
00241     EIGEN\_STRONG\_INLINE \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col()\textcolor{keyword}{   const }\{ \textcolor{keywordflow}{return} NeedToTranspose ? LhsIterator::index() : m\_outer;
       \}
00242 
00243     EIGEN\_STRONG\_INLINE Scalar value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} LhsIterator::value() * m\_factor; \}
00244     EIGEN\_STRONG\_INLINE \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} LhsIterator::operator bool() && (!m\_empty); \}
00245     
00246   \textcolor{keyword}{protected}:
00247     Scalar \textcolor{keyword}{get}(\textcolor{keyword}{const} RhsEval &rhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer, Dense = Dense()) \textcolor{keyword}{const}
00248     \{
00249       \textcolor{keywordflow}{return} rhs.coeff(outer);
00250     \}
00251     
00252     Scalar \textcolor{keyword}{get}(\textcolor{keyword}{const} RhsEval &rhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} outer, Sparse = Sparse())
00253     \{
00254       \textcolor{keyword}{typename} RhsEval::InnerIterator it(rhs, outer);
00255       \textcolor{keywordflow}{if} (it && it.index()==0 && it.value()!=Scalar(0))
00256         \textcolor{keywordflow}{return} it.value();
00257       m\_empty = \textcolor{keyword}{true};
00258       \textcolor{keywordflow}{return} Scalar(0);
00259     \}
00260     
00261     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_outer;
00262     \textcolor{keywordtype}{bool} m\_empty;
00263     Scalar m\_factor;
00264   \};
00265   
00266   sparse\_dense\_outer\_product\_evaluator(\textcolor{keyword}{const} Lhs1 &lhs, \textcolor{keyword}{const} ActualRhs &rhs)
00267      : m\_lhs(lhs), m\_lhsXprImpl(m\_lhs), m\_rhsXprImpl(rhs)
00268   \{
00269     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00270   \}
00271   
00272   \textcolor{comment}{// transpose case}
00273   sparse\_dense\_outer\_product\_evaluator(\textcolor{keyword}{const} ActualRhs &rhs, \textcolor{keyword}{const} Lhs1 &lhs)
00274      : m\_lhs(lhs), m\_lhsXprImpl(m\_lhs), m\_rhsXprImpl(rhs)
00275   \{
00276     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);
00277   \}
00278     
00279 \textcolor{keyword}{protected}:
00280   \textcolor{keyword}{const} LhsArg m\_lhs;
00281   evaluator<ActualLhs> m\_lhsXprImpl;
00282   evaluator<ActualRhs> m\_rhsXprImpl;
00283 \};
00284 
00285 \textcolor{comment}{// sparse * dense outer product}
00286 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00287 \textcolor{keyword}{struct }product\_evaluator<Product<Lhs, Rhs, DefaultProduct>, OuterProduct, SparseShape, DenseShape>
00288   : sparse\_dense\_outer\_product\_evaluator<Lhs,Rhs, Lhs::IsRowMajor>
00289 \{
00290   \textcolor{keyword}{typedef} sparse\_dense\_outer\_product\_evaluator<Lhs,Rhs, Lhs::IsRowMajor> Base;
00291   
00292   \textcolor{keyword}{typedef} Product<Lhs, Rhs> XprType;
00293   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::PlainObject PlainObject;
00294 
00295   \textcolor{keyword}{explicit} product\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00296     : Base(xpr.lhs(), xpr.rhs())
00297   \{\}
00298   
00299 \};
00300 
00301 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00302 \textcolor{keyword}{struct }product\_evaluator<Product<Lhs, Rhs, DefaultProduct>, OuterProduct, DenseShape, SparseShape>
00303   : sparse\_dense\_outer\_product\_evaluator<Lhs,Rhs, Rhs::IsRowMajor>
00304 \{
00305   \textcolor{keyword}{typedef} sparse\_dense\_outer\_product\_evaluator<Lhs,Rhs, Rhs::IsRowMajor> Base;
00306   
00307   \textcolor{keyword}{typedef} Product<Lhs, Rhs> XprType;
00308   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::PlainObject PlainObject;
00309 
00310   \textcolor{keyword}{explicit} product\_evaluator(\textcolor{keyword}{const} XprType& xpr)
00311     : Base(xpr.lhs(), xpr.rhs())
00312   \{\}
00313   
00314 \};
00315 
00316 \} \textcolor{comment}{// end namespace internal}
00317 
00318 \} \textcolor{comment}{// end namespace Eigen}
00319 
00320 \textcolor{preprocessor}{#endif // EIGEN\_SPARSEDENSEPRODUCT\_H}
\end{DoxyCode}
