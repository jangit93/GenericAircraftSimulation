\hypertarget{eigen_2_eigen_2src_2_core_2arch_2_z_vector_2_complex_8h_source}{}\section{eigen/\+Eigen/src/\+Core/arch/\+Z\+Vector/\+Complex.h}
\label{eigen_2_eigen_2src_2_core_2arch_2_z_vector_2_complex_8h_source}\index{Complex.\+h@{Complex.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2010 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2016 Konstantinos Margaritis <markos@freevec.org>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_COMPLEX32\_ALTIVEC\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_COMPLEX32\_ALTIVEC\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00017 
00018 \textcolor{keyword}{static} Packet2ul  p2ul\_CONJ\_XOR1 = (Packet2ul) vec\_sld((Packet4ui) p2d\_ZERO\_, (Packet4ui) p2l\_ZERO, 8);\textcolor{comment}{//\{
       0x8000000000000000, 0x0000000000000000 \};}
00019 \textcolor{keyword}{static} Packet2ul  p2ul\_CONJ\_XOR2 = (Packet2ul) vec\_sld((Packet4ui) p2l\_ZERO,  (Packet4ui) p2d\_ZERO\_, 8);\textcolor{comment}{//\{
       0x8000000000000000, 0x0000000000000000 \};}
00020 
00021 \textcolor{keyword}{struct }Packet1cd
00022 \{
00023   EIGEN\_STRONG\_INLINE Packet1cd() \{\}
00024   EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} Packet1cd(\textcolor{keyword}{const} Packet2d& a) : v(a) \{\}
00025   Packet2d v;
00026 \};
00027 
00028 \textcolor{keyword}{struct }Packet2cf
00029 \{
00030   EIGEN\_STRONG\_INLINE Packet2cf() \{\}
00031   EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} Packet2cf(\textcolor{keyword}{const} Packet4f& a) : v(a) \{\}
00032   \textcolor{keyword}{union }\{
00033     Packet4f v;
00034     Packet1cd cd[2];
00035   \};
00036 \};
00037 
00038 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<float> >  : default\_packet\_traits
00039 \{
00040   \textcolor{keyword}{typedef} Packet2cf type;
00041   \textcolor{keyword}{typedef} Packet2cf half;
00042   \textcolor{keyword}{enum} \{
00043     Vectorizable = 1,
00044     AlignedOnScalar = 1,
00045     size = 2,
00046     HasHalfPacket = 0,
00047 
00048     HasAdd    = 1,
00049     HasSub    = 1,
00050     HasMul    = 1,
00051     HasDiv    = 1,
00052     HasNegate = 1,
00053     HasAbs    = 0,
00054     HasAbs2   = 0,
00055     HasMin    = 0,
00056     HasMax    = 0,
00057     HasBlend  = 1,
00058     HasSetLinear = 0
00059   \};
00060 \};
00061 
00062 
00063 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<double> >  : default\_packet\_traits
00064 \{
00065   \textcolor{keyword}{typedef} Packet1cd type;
00066   \textcolor{keyword}{typedef} Packet1cd half;
00067   \textcolor{keyword}{enum} \{
00068     Vectorizable = 1,
00069     AlignedOnScalar = 1,
00070     size = 1,
00071     HasHalfPacket = 0,
00072 
00073     HasAdd    = 1,
00074     HasSub    = 1,
00075     HasMul    = 1,
00076     HasDiv    = 1,
00077     HasNegate = 1,
00078     HasAbs    = 0,
00079     HasAbs2   = 0,
00080     HasMin    = 0,
00081     HasMax    = 0,
00082     HasSetLinear = 0
00083   \};
00084 \};
00085 
00086 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet2cf> \{ \textcolor{keyword}{typedef} std::complex<float>  type; \textcolor{keyword}{enum} \{size=2, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet2cf half; \};
00087 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet1cd> \{ \textcolor{keyword}{typedef} std::complex<double> type; \textcolor{keyword}{enum} \{size=1, alignment=
      \hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc}{Aligned16}\}; \textcolor{keyword}{typedef} Packet1cd half; \};
00088 
00089 \textcolor{comment}{/* Forward declaration */}
00090 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} ptranspose(PacketBlock<Packet2cf,2>& kernel);
00091 
00092 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pload <Packet2cf>(\textcolor{keyword}{const} std::complex<float>* from)  \{ 
      EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{return} Packet2cf(pload<Packet4f>((\textcolor{keyword}{const} \textcolor{keywordtype}{float}*)from)); \}
00093 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pload <Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from) \{ 
      EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{return} Packet1cd(pload<Packet2d>((\textcolor{keyword}{const} \textcolor{keywordtype}{double}*)from)); \}
00094 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf ploadu<Packet2cf>(\textcolor{keyword}{const} std::complex<float>* from)  \{ 
      EIGEN\_DEBUG\_UNALIGNED\_LOAD \textcolor{keywordflow}{return} Packet2cf(ploadu<Packet4f>((\textcolor{keyword}{const} \textcolor{keywordtype}{float}*)from)); \}
00095 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd ploadu<Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from) \{ 
      EIGEN\_DEBUG\_UNALIGNED\_LOAD \textcolor{keywordflow}{return} Packet1cd(ploadu<Packet2d>((\textcolor{keyword}{const} \textcolor{keywordtype}{double}*)from)); \}
00096 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore <std::complex<float> >(std::complex<float> *     to, \textcolor{keyword}{const} 
      Packet2cf& from) \{ EIGEN\_DEBUG\_ALIGNED\_STORE pstore((\textcolor{keywordtype}{float}*)to, from.v); \}
00097 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore <std::complex<double> >(std::complex<double> *   to, \textcolor{keyword}{const} 
      Packet1cd& from) \{ EIGEN\_DEBUG\_ALIGNED\_STORE pstore((\textcolor{keywordtype}{double}*)to, from.v); \}
00098 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<std::complex<float> >(std::complex<float> *     to, \textcolor{keyword}{const} 
      Packet2cf& from) \{ EIGEN\_DEBUG\_UNALIGNED\_STORE pstoreu((\textcolor{keywordtype}{float}*)to, from.v); \}
00099 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<std::complex<double> >(std::complex<double> *   to, \textcolor{keyword}{const} 
      Packet1cd& from) \{ EIGEN\_DEBUG\_UNALIGNED\_STORE pstoreu((\textcolor{keywordtype}{double}*)to, from.v); \}
00100 
00101 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pset1<Packet1cd>(\textcolor{keyword}{const} std::complex<double>&  from)
00102 \{ \textcolor{comment}{/* here we really have to use unaligned loads :( */} \textcolor{keywordflow}{return} ploadu<Packet1cd>(&from); \}
00103 
00104 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pset1<Packet2cf>(\textcolor{keyword}{const} std::complex<float>&  from)
00105 \{
00106   Packet2cf res;
00107   res.cd[0] = Packet1cd(vec\_ld2f((\textcolor{keyword}{const} \textcolor{keywordtype}{float} *)&from));
00108   res.cd[1] = res.cd[0];
00109   \textcolor{keywordflow}{return} res;
00110 \}
00111 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet2cf pgather<std::complex<float>, Packet2cf>(\textcolor{keyword}{const} 
      std::complex<float>* from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00112 \{
00113   std::complex<float> EIGEN\_ALIGN16 af[2];
00114   af[0] = from[0*stride];
00115   af[1] = from[1*stride];
00116   \textcolor{keywordflow}{return} pload<Packet2cf>(af);
00117 \}
00118 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet1cd pgather<std::complex<double>, Packet1cd>(\textcolor{keyword}{const} 
      std::complex<double>* from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride EIGEN\_UNUSED)
00119 \{
00120   \textcolor{keywordflow}{return} pload<Packet1cd>(from);
00121 \}
00122 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, \textcolor{keyword}{
      const} Packet2cf& from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride)
00123 \{
00124   std::complex<float> EIGEN\_ALIGN16 af[2];
00125   pstore<std::complex<float> >((std::complex<float> *) af, from);
00126   to[0*stride] = af[0];
00127   to[1*stride] = af[1];
00128 \}
00129 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to
      , \textcolor{keyword}{const} Packet1cd& from, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride EIGEN\_UNUSED)
00130 \{
00131   pstore<std::complex<double> >(to, from);
00132 \}
00133 
00134 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf padd<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{return} 
      Packet2cf(padd<Packet4f>(a.v, b.v)); \}
00135 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd padd<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{return} 
      Packet1cd(a.v + b.v); \}
00136 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf psub<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{return} 
      Packet2cf(psub<Packet4f>(a.v, b.v)); \}
00137 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd psub<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{return} 
      Packet1cd(a.v - b.v); \}
00138 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pnegate(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} Packet1cd(pnegate(Packet2d(a.
      v))); \}
00139 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pnegate(\textcolor{keyword}{const} Packet2cf& a) \{ \textcolor{keywordflow}{return} Packet2cf(pnegate(Packet4f(a.
      v))); \}
00140 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pconj(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} Packet1cd((Packet2d)vec\_xor((
      Packet2d)a.v, (Packet2d)p2ul\_CONJ\_XOR2)); \}
00141 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pconj(\textcolor{keyword}{const} Packet2cf& a)
00142 \{
00143   Packet2cf res;
00144   res.v.v4f[0] = pconj(Packet1cd(reinterpret\_cast<Packet2d>(a.v.v4f[0]))).v;
00145   res.v.v4f[1] = pconj(Packet1cd(reinterpret\_cast<Packet2d>(a.v.v4f[1]))).v;
00146   \textcolor{keywordflow}{return} res;
00147 \}
00148 
00149 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pmul<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)
00150 \{
00151   Packet2d a\_re, a\_im, v1, v2;
00152 
00153   \textcolor{comment}{// Permute and multiply the real parts of a and b}
00154   a\_re = vec\_perm(a.v, a.v, p16uc\_PSET64\_HI);
00155   \textcolor{comment}{// Get the imaginary parts of a}
00156   a\_im = vec\_perm(a.v, a.v, p16uc\_PSET64\_LO);
00157   \textcolor{comment}{// multiply a\_re * b}
00158   v1 = vec\_madd(a\_re, b.v, p2d\_ZERO);
00159   \textcolor{comment}{// multiply a\_im * b and get the conjugate result}
00160   v2 = vec\_madd(a\_im, b.v, p2d\_ZERO);
00161   v2 = (Packet2d) vec\_sld((Packet4ui)v2, (Packet4ui)v2, 8);
00162   v2 = (Packet2d) vec\_xor((Packet2d)v2, (Packet2d) p2ul\_CONJ\_XOR1);
00163 
00164   \textcolor{keywordflow}{return} Packet1cd(v1 + v2);
00165 \}
00166 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pmul<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)
00167 \{
00168   Packet2cf res;
00169   res.v.v4f[0] = pmul(Packet1cd(reinterpret\_cast<Packet2d>(a.v.v4f[0])), Packet1cd(
      reinterpret\_cast<Packet2d>(b.v.v4f[0]))).v;
00170   res.v.v4f[1] = pmul(Packet1cd(reinterpret\_cast<Packet2d>(a.v.v4f[1])), Packet1cd(
      reinterpret\_cast<Packet2d>(b.v.v4f[1]))).v;
00171   \textcolor{keywordflow}{return} res;
00172 \}
00173 
00174 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pand   <Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{
      return} Packet1cd(vec\_and(a.v,b.v)); \}
00175 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pand   <Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{
      return} Packet2cf(pand<Packet4f>(a.v,b.v)); \}
00176 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd por    <Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{
      return} Packet1cd(vec\_or(a.v,b.v)); \}
00177 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf por    <Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{
      return} Packet2cf(por<Packet4f>(a.v,b.v)); \}
00178 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pxor   <Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{
      return} Packet1cd(vec\_xor(a.v,b.v)); \}
00179 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pxor   <Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{
      return} Packet2cf(pxor<Packet4f>(a.v,b.v)); \}
00180 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pandnot<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b) \{ \textcolor{keywordflow}{
      return} Packet1cd(vec\_and(a.v, vec\_nor(b.v,b.v))); \}
00181 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pandnot<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b) \{ \textcolor{keywordflow}{
      return} Packet2cf(pandnot<Packet4f>(a.v,b.v)); \}
00182 
00183 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd ploaddup<Packet1cd>(\textcolor{keyword}{const} std::complex<double>*     from) \{  \textcolor{keywordflow}{
      return} pset1<Packet1cd>(*from); \}
00184 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf ploaddup<Packet2cf>(\textcolor{keyword}{const} std::complex<float>*      from) \{  \textcolor{keywordflow}{
      return} pset1<Packet2cf>(*from); \}
00185 
00186 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<std::complex<float> >(\textcolor{keyword}{const} std::complex<float> *     addr) \{ 
      EIGEN\_ZVECTOR\_PREFETCH(addr); \}
00187 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<std::complex<double> >(\textcolor{keyword}{const} std::complex<double> *   addr) \{ 
      EIGEN\_ZVECTOR\_PREFETCH(addr); \}
00188 
00189 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double>  pfirst<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a)
00190 \{
00191   std::complex<double> EIGEN\_ALIGN16 res;
00192   pstore<std::complex<double> >(&res, a);
00193 
00194   \textcolor{keywordflow}{return} res;
00195 \}
00196 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float>  pfirst<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00197 \{
00198   std::complex<float> EIGEN\_ALIGN16 res[2];
00199   pstore<std::complex<float> >(res, a);
00200 
00201   \textcolor{keywordflow}{return} res[0];
00202 \}
00203 
00204 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd preverse(\textcolor{keyword}{const} Packet1cd& a) \{ \textcolor{keywordflow}{return} a; \}
00205 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf preverse(\textcolor{keyword}{const} Packet2cf& a)
00206 \{
00207   Packet2cf res;
00208   res.cd[0] = a.cd[1];
00209   res.cd[1] = a.cd[0];
00210   \textcolor{keywordflow}{return} res;
00211 \}
00212 
00213 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double> predux<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a)
00214 \{
00215   \textcolor{keywordflow}{return} pfirst(a);
00216 \}
00217 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> predux<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00218 \{
00219   std::complex<float> res;
00220   Packet1cd b = padd<Packet1cd>(a.cd[0], a.cd[1]);
00221   vec\_st2f(b.v, (\textcolor{keywordtype}{float}*)&res);
00222   \textcolor{keywordflow}{return} res;
00223 \}
00224 
00225 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd preduxp<Packet1cd>(\textcolor{keyword}{const} Packet1cd* vecs)
00226 \{
00227   \textcolor{keywordflow}{return} vecs[0];
00228 \}
00229 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf preduxp<Packet2cf>(\textcolor{keyword}{const} Packet2cf* vecs)
00230 \{
00231   PacketBlock<Packet2cf,2> transpose;
00232   transpose.packet[0] = vecs[0];
00233   transpose.packet[1] = vecs[1];
00234   ptranspose(transpose);
00235 
00236   \textcolor{keywordflow}{return} padd<Packet2cf>(transpose.packet[0], transpose.packet[1]);
00237 \} 
00238 
00239 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double> predux\_mul<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a)
00240 \{
00241   \textcolor{keywordflow}{return} pfirst(a);
00242 \}
00243 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> predux\_mul<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a)
00244 \{
00245   std::complex<float> res;
00246   Packet1cd b = pmul<Packet1cd>(a.cd[0], a.cd[1]);
00247   vec\_st2f(b.v, (\textcolor{keywordtype}{float}*)&res);
00248   \textcolor{keywordflow}{return} res;
00249 \}
00250 
00251 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00252 \textcolor{keyword}{struct }palign\_impl<Offset,Packet1cd>
00253 \{
00254   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet1cd& \textcolor{comment}{/*first*/}, \textcolor{keyword}{const} Packet1cd& \textcolor{comment}{/*second*/})
00255   \{
00256     \textcolor{comment}{// FIXME is it sure we never have to align a Packet1cd?}
00257     \textcolor{comment}{// Even though a std::complex<double> has 16 bytes, it is not necessarily aligned on a 16 bytes
       boundary...}
00258   \}
00259 \};
00260 
00261 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Offset>
00262 \textcolor{keyword}{struct }palign\_impl<Offset,Packet2cf>
00263 \{
00264   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(Packet2cf& first, \textcolor{keyword}{const} Packet2cf& second)
00265   \{
00266     \textcolor{keywordflow}{if} (Offset == 1) \{
00267       first.cd[0] = first.cd[1];
00268       first.cd[1] = second.cd[0];
00269     \}
00270   \}
00271 \};
00272 
00273 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet1cd, Packet1cd, false,true>
00274 \{
00275   EIGEN\_STRONG\_INLINE Packet1cd pmadd(\textcolor{keyword}{const} Packet1cd& x, \textcolor{keyword}{const} Packet1cd& y, \textcolor{keyword}{const} Packet1cd& c)\textcolor{keyword}{ const}
00276 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00277 
00278   EIGEN\_STRONG\_INLINE Packet1cd pmul(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)\textcolor{keyword}{ const}
00279 \textcolor{keyword}{  }\{
00280     \textcolor{keywordflow}{return} internal::pmul(a, pconj(b));
00281   \}
00282 \};
00283 
00284 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet1cd, Packet1cd, true,false>
00285 \{
00286   EIGEN\_STRONG\_INLINE Packet1cd pmadd(\textcolor{keyword}{const} Packet1cd& x, \textcolor{keyword}{const} Packet1cd& y, \textcolor{keyword}{const} Packet1cd& c)\textcolor{keyword}{ const}
00287 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00288 
00289   EIGEN\_STRONG\_INLINE Packet1cd pmul(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)\textcolor{keyword}{ const}
00290 \textcolor{keyword}{  }\{
00291     \textcolor{keywordflow}{return} internal::pmul(pconj(a), b);
00292   \}
00293 \};
00294 
00295 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet1cd, Packet1cd, true,true>
00296 \{
00297   EIGEN\_STRONG\_INLINE Packet1cd pmadd(\textcolor{keyword}{const} Packet1cd& x, \textcolor{keyword}{const} Packet1cd& y, \textcolor{keyword}{const} Packet1cd& c)\textcolor{keyword}{ const}
00298 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00299 
00300   EIGEN\_STRONG\_INLINE Packet1cd pmul(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)\textcolor{keyword}{ const}
00301 \textcolor{keyword}{  }\{
00302     \textcolor{keywordflow}{return} pconj(internal::pmul(a, b));
00303   \}
00304 \};
00305 
00306 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet2cf, false,true>
00307 \{
00308   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00309 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00310 
00311   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)\textcolor{keyword}{ const}
00312 \textcolor{keyword}{  }\{
00313     \textcolor{keywordflow}{return} internal::pmul(a, pconj(b));
00314   \}
00315 \};
00316 
00317 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet2cf, true,false>
00318 \{
00319   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00320 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00321 
00322   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)\textcolor{keyword}{ const}
00323 \textcolor{keyword}{  }\{
00324     \textcolor{keywordflow}{return} internal::pmul(pconj(a), b);
00325   \}
00326 \};
00327 
00328 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }conj\_helper<Packet2cf, Packet2cf, true,true>
00329 \{
00330   EIGEN\_STRONG\_INLINE Packet2cf pmadd(\textcolor{keyword}{const} Packet2cf& x, \textcolor{keyword}{const} Packet2cf& y, \textcolor{keyword}{const} Packet2cf& c)\textcolor{keyword}{ const}
00331 \textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} padd(pmul(x,y),c); \}
00332 
00333   EIGEN\_STRONG\_INLINE Packet2cf pmul(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)\textcolor{keyword}{ const}
00334 \textcolor{keyword}{  }\{
00335     \textcolor{keywordflow}{return} pconj(internal::pmul(a, b));
00336   \}
00337 \};
00338 
00339 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pdiv<Packet1cd>(\textcolor{keyword}{const} Packet1cd& a, \textcolor{keyword}{const} Packet1cd& b)
00340 \{
00341   \textcolor{comment}{// TODO optimize it for AltiVec}
00342   Packet1cd res = conj\_helper<Packet1cd,Packet1cd,false,true>().pmul(a,b);
00343   Packet2d s = vec\_madd(b.v, b.v, p2d\_ZERO\_);
00344   \textcolor{keywordflow}{return} Packet1cd(pdiv(res.v, s + vec\_perm(s, s, p16uc\_REVERSE64)));
00345 \}
00346 
00347 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pdiv<Packet2cf>(\textcolor{keyword}{const} Packet2cf& a, \textcolor{keyword}{const} Packet2cf& b)
00348 \{
00349   \textcolor{comment}{// TODO optimize it for AltiVec}
00350   Packet2cf res;
00351   res.cd[0] = pdiv<Packet1cd>(a.cd[0], b.cd[0]);
00352   res.cd[1] = pdiv<Packet1cd>(a.cd[1], b.cd[1]);
00353   \textcolor{keywordflow}{return} res;
00354 \}
00355 
00356 EIGEN\_STRONG\_INLINE Packet1cd pcplxflip\textcolor{comment}{/*<Packet1cd>*/}(\textcolor{keyword}{const} Packet1cd& x)
00357 \{
00358   \textcolor{keywordflow}{return} Packet1cd(preverse(Packet2d(x.v)));
00359 \}
00360 
00361 EIGEN\_STRONG\_INLINE Packet2cf pcplxflip\textcolor{comment}{/*<Packet2cf>*/}(\textcolor{keyword}{const} Packet2cf& x)
00362 \{
00363   Packet2cf res;
00364   res.cd[0] = pcplxflip(x.cd[0]);
00365   res.cd[1] = pcplxflip(x.cd[1]);
00366   \textcolor{keywordflow}{return} res;
00367 \}
00368 
00369 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} ptranspose(PacketBlock<Packet1cd,2>& kernel)
00370 \{
00371   Packet2d tmp = vec\_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc\_TRANSPOSE64\_HI);
00372   kernel.packet[1].v = vec\_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc\_TRANSPOSE64\_LO);
00373   kernel.packet[0].v = tmp;
00374 \}
00375 
00376 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} ptranspose(PacketBlock<Packet2cf,2>& kernel)
00377 \{
00378   Packet1cd tmp = kernel.packet[0].cd[1];
00379   kernel.packet[0].cd[1] = kernel.packet[1].cd[0];
00380   kernel.packet[1].cd[0] = tmp;
00381 \}
00382 
00383 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pblend(\textcolor{keyword}{const} Selector<2>& ifPacket, \textcolor{keyword}{const} Packet2cf& thenPacket, \textcolor{keyword}{
      const} Packet2cf& elsePacket) \{
00384   Packet2cf result;
00385   \textcolor{keyword}{const} Selector<4> ifPacket4 = \{ ifPacket.select[0], ifPacket.select[0], ifPacket.select[1], ifPacket.
      select[1] \};
00386   result.v = pblend<Packet4f>(ifPacket4, thenPacket.v, elsePacket.v);
00387   \textcolor{keywordflow}{return} result;
00388 \}
00389 
00390 \} \textcolor{comment}{// end namespace internal}
00391 
00392 \} \textcolor{comment}{// end namespace Eigen}
00393 
00394 \textcolor{preprocessor}{#endif // EIGEN\_COMPLEX32\_ALTIVEC\_H}
\end{DoxyCode}
