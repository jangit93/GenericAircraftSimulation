\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_b_d_c_s_v_d_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+S\+V\+D/\+B\+D\+C\+S\+VD.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_b_d_c_s_v_d_8h_source}\index{B\+D\+C\+S\+V\+D.\+h@{B\+D\+C\+S\+V\+D.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{// }
00004 \textcolor{comment}{// We used the "A Divide-And-Conquer Algorithm for the Bidiagonal SVD"}
00005 \textcolor{comment}{// research report written by Ming Gu and Stanley C.Eisenstat}
00006 \textcolor{comment}{// The code variable names correspond to the names they used in their }
00007 \textcolor{comment}{// report}
00008 \textcolor{comment}{//}
00009 \textcolor{comment}{// Copyright (C) 2013 Gauthier Brun <brun.gauthier@gmail.com>}
00010 \textcolor{comment}{// Copyright (C) 2013 Nicolas Carre <nicolas.carre@ensimag.fr>}
00011 \textcolor{comment}{// Copyright (C) 2013 Jean Ceccato <jean.ceccato@ensimag.fr>}
00012 \textcolor{comment}{// Copyright (C) 2013 Pierre Zoppitelli <pierre.zoppitelli@ensimag.fr>}
00013 \textcolor{comment}{// Copyright (C) 2013 Jitse Niesen <jitse@maths.leeds.ac.uk>}
00014 \textcolor{comment}{// Copyright (C) 2014-2016 Gael Guennebaud <gael.guennebaud@inria.fr>}
00015 \textcolor{comment}{//}
00016 \textcolor{comment}{// Source Code Form is subject to the terms of the Mozilla}
00017 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00018 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00019 
00020 \textcolor{preprocessor}{#ifndef EIGEN\_BDCSVD\_H}
00021 \textcolor{preprocessor}{#define EIGEN\_BDCSVD\_H}
00022 \textcolor{comment}{// #define EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00023 \textcolor{comment}{// #define EIGEN\_BDCSVD\_SANITY\_CHECKS}
00024 
00025 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00026 
00027 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00028 IOFormat bdcsvdfmt(8, 0, \textcolor{stringliteral}{", "}, \textcolor{stringliteral}{"\(\backslash\)n"}, \textcolor{stringliteral}{"  ["}, \textcolor{stringliteral}{"]"});
00029 \textcolor{preprocessor}{#endif}
00030   
00031 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType> \textcolor{keyword}{class }BDCSVD;
00032 
00033 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00034 
00035 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType> 
00036 \textcolor{keyword}{struct }traits<BDCSVD<\_MatrixType> >
00037 \{
00038   \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00039 \};  
00040 
00041 \} \textcolor{comment}{// end namespace internal}
00042   
00043   
00066 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType> 
00067 \textcolor{keyword}{class }BDCSVD : \textcolor{keyword}{public} SVDBase<BDCSVD<\_MatrixType> >
00068 \{
00069   \textcolor{keyword}{typedef} SVDBase<BDCSVD> Base;
00070     
00071 \textcolor{keyword}{public}:
00072   \textcolor{keyword}{using} Base::rows;
00073   \textcolor{keyword}{using} Base::cols;
00074   \textcolor{keyword}{using} Base::computeU;
00075   \textcolor{keyword}{using} Base::computeV;
00076   
00077   \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00078   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00079   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<typename MatrixType::Scalar>::Real RealScalar;
00080   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} NumTraits<RealScalar>::Literal Literal;
00081   \textcolor{keyword}{enum} \{
00082     RowsAtCompileTime = MatrixType::RowsAtCompileTime, 
00083     ColsAtCompileTime = MatrixType::ColsAtCompileTime, 
00084     DiagSizeAtCompileTime = EIGEN\_SIZE\_MIN\_PREFER\_DYNAMIC(RowsAtCompileTime, ColsAtCompileTime), 
00085     MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime, 
00086     MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime, 
00087     MaxDiagSizeAtCompileTime = EIGEN\_SIZE\_MIN\_PREFER\_FIXED(MaxRowsAtCompileTime, MaxColsAtCompileTime), 
00088     MatrixOptions = MatrixType::Options
00089   \};
00090 
00091   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::MatrixUType MatrixUType;
00092   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::MatrixVType MatrixVType;
00093   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::SingularValuesType SingularValuesType;
00094   
00095   \textcolor{keyword}{typedef} Matrix<Scalar, Dynamic, Dynamic, ColMajor> MatrixX;
00096   \textcolor{keyword}{typedef} Matrix<RealScalar, Dynamic, Dynamic, ColMajor> MatrixXr;
00097   \textcolor{keyword}{typedef} Matrix<RealScalar, Dynamic, 1> \hyperlink{struct_vector_type}{VectorType};
00098   \textcolor{keyword}{typedef} Array<RealScalar, Dynamic, 1> ArrayXr;
00099   \textcolor{keyword}{typedef} Array<Index,1,Dynamic> ArrayXi;
00100   \textcolor{keyword}{typedef} Ref<ArrayXr> ArrayRef;
00101   \textcolor{keyword}{typedef} Ref<ArrayXi> IndicesRef;
00102 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_b_d_c_s_v_d_8h_source_l00108}\hyperlink{group___s_v_d___module_a39514816d38f9c418cf3f3514b511c2c}{00108}   \hyperlink{group___s_v_d___module_a39514816d38f9c418cf3f3514b511c2c}{BDCSVD}() : m\_algoswap(16), m\_numIters(0)
00109   \{\}
00110 
00111 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_b_d_c_s_v_d_8h_source_l00118}\hyperlink{group___s_v_d___module_a3e1fa48b3d042b7daf7392724a68bb60}{00118}   \hyperlink{group___s_v_d___module_a3e1fa48b3d042b7daf7392724a68bb60}{BDCSVD}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions = 0)
00119     : m\_algoswap(16), m\_numIters(0)
00120   \{
00121     allocate(rows, cols, computationOptions);
00122   \}
00123 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_b_d_c_s_v_d_8h_source_l00134}\hyperlink{group___s_v_d___module_a302746d9c534cd513c1df87c7ae4850d}{00134}   \hyperlink{group___s_v_d___module_a302746d9c534cd513c1df87c7ae4850d}{BDCSVD}(\textcolor{keyword}{const} MatrixType& matrix, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions = 0)
00135     : m\_algoswap(16), m\_numIters(0)
00136   \{
00137     compute(matrix, computationOptions);
00138   \}
00139 
00140   ~\hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD}() 
00141   \{
00142   \}
00143   
00154   \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD}& compute(\textcolor{keyword}{const} MatrixType& matrix, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions);
00155 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_b_d_c_s_v_d_8h_source_l00162}\hyperlink{group___s_v_d___module_acf27f41ed044d74ea8e8cbaf17ffdb04}{00162}   \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD}& \hyperlink{group___s_v_d___module_acf27f41ed044d74ea8e8cbaf17ffdb04}{compute}(\textcolor{keyword}{const} MatrixType& matrix)
00163   \{
00164     \textcolor{keywordflow}{return} compute(matrix, this->m\_computationOptions);
00165   \}
00166 
00167   \textcolor{keywordtype}{void} setSwitchSize(\textcolor{keywordtype}{int} s) 
00168   \{
00169     eigen\_assert(s>3 && \textcolor{stringliteral}{"BDCSVD the size of the algo switch has to be greater than 3"});
00170     m\_algoswap = s;
00171   \}
00172  
00173 \textcolor{keyword}{private}:
00174   \textcolor{keywordtype}{void} allocate(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions);
00175   \textcolor{keywordtype}{void} divide(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstCol, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lastCol, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstRowW, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstColW, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} shift);
00176   \textcolor{keywordtype}{void} computeSVDofM(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstCol, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n, MatrixXr& U, VectorType& singVals, MatrixXr& V);
00177   \textcolor{keywordtype}{void} computeSingVals(\textcolor{keyword}{const} ArrayRef& col0, \textcolor{keyword}{const} ArrayRef& diag, \textcolor{keyword}{const} IndicesRef& perm, VectorType& 
      singVals, ArrayRef shifts, ArrayRef mus);
00178   \textcolor{keywordtype}{void} perturbCol0(\textcolor{keyword}{const} ArrayRef& col0, \textcolor{keyword}{const} ArrayRef& diag, \textcolor{keyword}{const} IndicesRef& perm, \textcolor{keyword}{const} VectorType& 
      singVals, \textcolor{keyword}{const} ArrayRef& shifts, \textcolor{keyword}{const} ArrayRef& mus, ArrayRef zhat);
00179   \textcolor{keywordtype}{void} computeSingVecs(\textcolor{keyword}{const} ArrayRef& zhat, \textcolor{keyword}{const} ArrayRef& diag, \textcolor{keyword}{const} IndicesRef& perm, \textcolor{keyword}{const} VectorType
      & singVals, \textcolor{keyword}{const} ArrayRef& shifts, \textcolor{keyword}{const} ArrayRef& mus, MatrixXr& U, MatrixXr& V);
00180   \textcolor{keywordtype}{void} deflation43(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstCol, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} shift, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size);
00181   \textcolor{keywordtype}{void} deflation44(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstColu , \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstColm, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstRowW, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstColW, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size);
00182   \textcolor{keywordtype}{void} deflation(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstCol, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lastCol, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstRowW, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstColW, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} shift);
00183   \textcolor{keyword}{template}<\textcolor{keyword}{typename} HouseholderU, \textcolor{keyword}{typename} HouseholderV, \textcolor{keyword}{typename} NaiveU, \textcolor{keyword}{typename} NaiveV>
00184   \textcolor{keywordtype}{void} copyUV(\textcolor{keyword}{const} HouseholderU &householderU, \textcolor{keyword}{const} HouseholderV &householderV, \textcolor{keyword}{const} NaiveU &naiveU, \textcolor{keyword}{
      const} NaiveV &naivev);
00185   \textcolor{keywordtype}{void} structured\_update(\hyperlink{group___core___module_class_eigen_1_1_block}{Block<MatrixXr,Dynamic,Dynamic>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, \textcolor{keyword}{const} MatrixXr &B, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n1);
00186   \textcolor{keyword}{static} RealScalar secularEq(RealScalar x, \textcolor{keyword}{const} ArrayRef& col0, \textcolor{keyword}{const} ArrayRef& diag, \textcolor{keyword}{const} IndicesRef &
      perm, \textcolor{keyword}{const} ArrayRef& diagShifted, RealScalar shift);
00187 
00188 \textcolor{keyword}{protected}:
00189   MatrixXr m\_naiveU, m\_naiveV;
00190   MatrixXr m\_computed;
00191   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_nRec;
00192   ArrayXr m\_workspace;
00193   ArrayXi m\_workspaceI;
00194   \textcolor{keywordtype}{int} m\_algoswap;
00195   \textcolor{keywordtype}{bool} m\_isTranspose, m\_compU, m\_compV;
00196   
00197   \textcolor{keyword}{using} Base::m\_singularValues;
00198   \textcolor{keyword}{using} Base::m\_diagSize;
00199   \textcolor{keyword}{using} Base::m\_computeFullU;
00200   \textcolor{keyword}{using} Base::m\_computeFullV;
00201   \textcolor{keyword}{using} Base::m\_computeThinU;
00202   \textcolor{keyword}{using} Base::m\_computeThinV;
00203   \textcolor{keyword}{using} Base::m\_matrixU;
00204   \textcolor{keyword}{using} Base::m\_matrixV;
00205   \textcolor{keyword}{using} Base::m\_isInitialized;
00206   \textcolor{keyword}{using} Base::m\_nonzeroSingularValues;
00207 
00208 \textcolor{keyword}{public}:  
00209   \textcolor{keywordtype}{int} m\_numIters;
00210 \}; \textcolor{comment}{//end class BDCSVD}
00211 
00212 
00213 \textcolor{comment}{// Method to allocate and initialize matrix and attributes}
00214 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00215 \textcolor{keywordtype}{void} \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>::allocate}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions)
00216 \{
00217   m\_isTranspose = (cols > rows);
00218 
00219   \textcolor{keywordflow}{if} (Base::allocate(rows, cols, computationOptions))
00220     \textcolor{keywordflow}{return};
00221   
00222   m\_computed = MatrixXr::Zero(m\_diagSize + 1, m\_diagSize );
00223   m\_compU = computeV();
00224   m\_compV = computeU();
00225   \textcolor{keywordflow}{if} (m\_isTranspose)
00226     \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_compU, m\_compV);
00227   
00228   \textcolor{keywordflow}{if} (m\_compU) m\_naiveU = MatrixXr::Zero(m\_diagSize + 1, m\_diagSize + 1 );
00229   \textcolor{keywordflow}{else}         m\_naiveU = MatrixXr::Zero(2, m\_diagSize + 1 );
00230   
00231   \textcolor{keywordflow}{if} (m\_compV) m\_naiveV = MatrixXr::Zero(m\_diagSize, m\_diagSize);
00232   
00233   m\_workspace.resize((m\_diagSize+1)*(m\_diagSize+1)*3);
00234   m\_workspaceI.resize(3*m\_diagSize);
00235 \}\textcolor{comment}{// end allocate}
00236 
00237 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00238 \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>}& \hyperlink{group___s_v_d___module_a52e3c627775010775c64d16a00cdb770}{BDCSVD<MatrixType>::compute}(\textcolor{keyword}{const} 
      MatrixType& matrix, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions) 
00239 \{
00240 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00241   std::cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)n
      ======================================================================================================================\(\backslash\)n\(\backslash\)n\(\backslash\)n"};
00242 \textcolor{preprocessor}{#endif}
00243   allocate(matrix.rows(), matrix.cols(), computationOptions);
00244   \textcolor{keyword}{using} std::abs;
00245 
00246   \textcolor{keyword}{const} RealScalar considerZero = (std::numeric\_limits<RealScalar>::min)();
00247   
00248   \textcolor{comment}{//**** step -1 - If the problem is too small, directly falls back to JacobiSVD and return}
00249   \textcolor{keywordflow}{if}(matrix.cols() < m\_algoswap)
00250   \{
00251     \textcolor{comment}{// FIXME this line involves temporaries}
00252     \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD<MatrixType>} jsvd(matrix,computationOptions);
00253     \textcolor{keywordflow}{if}(computeU()) m\_matrixU = jsvd.\hyperlink{group___s_v_d___module_afc7fe1546b0f6e1801b86f22f5664cb8}{matrixU}();
00254     \textcolor{keywordflow}{if}(computeV()) m\_matrixV = jsvd.\hyperlink{group___s_v_d___module_a245a453b5e7347f737295c23133238c4}{matrixV}();
00255     m\_singularValues = jsvd.\hyperlink{group___s_v_d___module_a4e7bac123570c348f7ed6be909e1e474}{singularValues}();
00256     m\_nonzeroSingularValues = jsvd.\hyperlink{group___s_v_d___module_afe8a555f38393a319a71ec0f0331c9ef}{nonzeroSingularValues}();
00257     m\_isInitialized = \textcolor{keyword}{true};
00258     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00259   \}
00260   
00261   \textcolor{comment}{//**** step 0 - Copy the input matrix and apply scaling to reduce over/under-flows}
00262   RealScalar scale = matrix.cwiseAbs().maxCoeff();
00263   \textcolor{keywordflow}{if}(scale==Literal(0)) scale = Literal(1);
00264   \hyperlink{group___core___module_class_eigen_1_1_matrix}{MatrixX} copy;
00265   \textcolor{keywordflow}{if} (m\_isTranspose) copy = matrix.adjoint()/scale;
00266   \textcolor{keywordflow}{else}               copy = matrix/scale;
00267   
00268   \textcolor{comment}{//**** step 1 - Bidiagonalization}
00269   \textcolor{comment}{// FIXME this line involves temporaries}
00270   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization}{internal::UpperBidiagonalization<MatrixX>} bid(copy);
00271 
00272   \textcolor{comment}{//**** step 2 - Divide & Conquer}
00273   m\_naiveU.setZero();
00274   m\_naiveV.setZero();
00275   \textcolor{comment}{// FIXME this line involves a temporary matrix}
00276   m\_computed.topRows(m\_diagSize) = bid.bidiagonal().toDenseMatrix().transpose();
00277   m\_computed.template bottomRows<1>().setZero();
00278   divide(0, m\_diagSize - 1, 0, 0, 0);
00279 
00280   \textcolor{comment}{//**** step 3 - Copy singular values and vectors}
00281   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<m\_diagSize; i++)
00282   \{
00283     RealScalar a = abs(m\_computed.coeff(i, i));
00284     m\_singularValues.coeffRef(i) = a * scale;
00285     \textcolor{keywordflow}{if} (a<considerZero)
00286     \{
00287       m\_nonzeroSingularValues = i;
00288       m\_singularValues.tail(m\_diagSize - i - 1).setZero();
00289       \textcolor{keywordflow}{break};
00290     \}
00291     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (i == m\_diagSize - 1)
00292     \{
00293       m\_nonzeroSingularValues = i + 1;
00294       \textcolor{keywordflow}{break};
00295     \}
00296   \}
00297 
00298 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00299 \textcolor{comment}{//   std::cout << "m\_naiveU\(\backslash\)n" << m\_naiveU << "\(\backslash\)n\(\backslash\)n";}
00300 \textcolor{comment}{//   std::cout << "m\_naiveV\(\backslash\)n" << m\_naiveV << "\(\backslash\)n\(\backslash\)n";}
00301 \textcolor{preprocessor}{#endif}
00302   \textcolor{keywordflow}{if}(m\_isTranspose) copyUV(bid.householderV(), bid.householderU(), m\_naiveV, m\_naiveU);
00303   \textcolor{keywordflow}{else}              copyUV(bid.householderU(), bid.householderV(), m\_naiveU, m\_naiveV);
00304 
00305   m\_isInitialized = \textcolor{keyword}{true};
00306   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00307 \}\textcolor{comment}{// end compute}
00308 
00309 
00310 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00311 \textcolor{keyword}{template}<\textcolor{keyword}{typename} HouseholderU, \textcolor{keyword}{typename} HouseholderV, \textcolor{keyword}{typename} NaiveU, \textcolor{keyword}{typename} NaiveV>
00312 \textcolor{keywordtype}{void} \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>::copyUV}(\textcolor{keyword}{const} HouseholderU &householderU, \textcolor{keyword}{const} 
      HouseholderV &householderV, \textcolor{keyword}{const} NaiveU &naiveU, \textcolor{keyword}{const} NaiveV &naiveV)
00313 \{
00314   \textcolor{comment}{// Note exchange of U and V: m\_matrixU is set from m\_naiveV and vice versa}
00315   \textcolor{keywordflow}{if} (computeU())
00316   \{
00317     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} Ucols = m\_computeThinU ? m\_diagSize : householderU.cols();
00318     m\_matrixU = MatrixX::Identity(householderU.cols(), Ucols);
00319     m\_matrixU.topLeftCorner(m\_diagSize, m\_diagSize) = naiveV.template cast<Scalar>().topLeftCorner(
      m\_diagSize, m\_diagSize);
00320     householderU.applyThisOnTheLeft(m\_matrixU); \textcolor{comment}{// FIXME this line involves a temporary buffer}
00321   \}
00322   \textcolor{keywordflow}{if} (computeV())
00323   \{
00324     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} Vcols = m\_computeThinV ? m\_diagSize : householderV.cols();
00325     m\_matrixV = MatrixX::Identity(householderV.cols(), Vcols);
00326     m\_matrixV.topLeftCorner(m\_diagSize, m\_diagSize) = naiveU.template cast<Scalar>().topLeftCorner(
      m\_diagSize, m\_diagSize);
00327     householderV.applyThisOnTheLeft(m\_matrixV); \textcolor{comment}{// FIXME this line involves a temporary buffer}
00328   \}
00329 \}
00330 
00339 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00340 \textcolor{keywordtype}{void} \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>::structured\_update}(
      \hyperlink{group___core___module_class_eigen_1_1_block}{Block<MatrixXr,Dynamic,Dynamic>} \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, \textcolor{keyword}{const} 
      \hyperlink{group___core___module}{MatrixXr} &B, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n1)
00341 \{
00342   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = A.rows();
00343   \textcolor{keywordflow}{if}(n>100)
00344   \{
00345     \textcolor{comment}{// If the matrices are large enough, let's exploit the sparse structure of A by}
00346     \textcolor{comment}{// splitting it in half (wrt n1), and packing the non-zero columns.}
00347     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n2 = n - n1;
00348     \hyperlink{group___core___module_class_eigen_1_1_map}{Map<MatrixXr>} A1(m\_workspace.data()      , n1, n);
00349     \hyperlink{group___core___module_class_eigen_1_1_map}{Map<MatrixXr>} A2(m\_workspace.data()+ n1*n, n2, n);
00350     \hyperlink{group___core___module_class_eigen_1_1_map}{Map<MatrixXr>} B1(m\_workspace.data()+  n*n, n,  n);
00351     \hyperlink{group___core___module_class_eigen_1_1_map}{Map<MatrixXr>} B2(m\_workspace.data()+2*n*n, n,  n);
00352     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k1=0, k2=0;
00353     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=0; j<n; ++j)
00354     \{
00355       \textcolor{keywordflow}{if}( (A.col(j).head(n1).array()!=Literal(0)).any() )
00356       \{
00357         A1.col(k1) = A.col(j).head(n1);
00358         B1.row(k1) = B.row(j);
00359         ++k1;
00360       \}
00361       \textcolor{keywordflow}{if}( (A.col(j).tail(n2).array()!=Literal(0)).any() )
00362       \{
00363         A2.col(k2) = A.col(j).tail(n2);
00364         B2.row(k2) = B.row(j);
00365         ++k2;
00366       \}
00367     \}
00368   
00369     A.topRows(n1).noalias()    = A1.leftCols(k1) * B1.topRows(k1);
00370     A.bottomRows(n2).noalias() = A2.leftCols(k2) * B2.topRows(k2);
00371   \}
00372   \textcolor{keywordflow}{else}
00373   \{
00374     \hyperlink{group___core___module_class_eigen_1_1_map}{Map<MatrixXr,Aligned>} tmp(m\_workspace.data(),n,n);
00375     tmp.noalias() = A*B;
00376     A = tmp;
00377   \}
00378 \}
00379 
00380 \textcolor{comment}{// The divide algorithm is done "in place", we are always working on subsets of the same matrix. The divide
       methods takes as argument the }
00381 \textcolor{comment}{// place of the submatrix we are currently working on.}
00382 
00383 \textcolor{comment}{//@param firstCol : The Index of the first column of the submatrix of m\_computed and for m\_naiveU;}
00384 \textcolor{comment}{//@param lastCol : The Index of the last column of the submatrix of m\_computed and for m\_naiveU; }
00385 \textcolor{comment}{// lastCol + 1 - firstCol is the size of the submatrix.}
00386 \textcolor{comment}{//@param firstRowW : The Index of the first row of the matrix W that we are to change. (see the reference
       paper section 1 for more information on W)}
00387 \textcolor{comment}{//@param firstRowW : Same as firstRowW with the column.}
00388 \textcolor{comment}{//@param shift : Each time one takes the left submatrix, one must add 1 to the shift. Why? Because! We
       actually want the last column of the U submatrix }
00389 \textcolor{comment}{// to become the first column (*coeff) and to shift all the other columns to the right. There are more
       details on the reference paper.}
00390 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00391 \textcolor{keywordtype}{void} \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>::divide} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstCol, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lastCol, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstRowW, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstColW, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} shift)
00392 \{
00393   \textcolor{comment}{// requires rows = cols + 1;}
00394   \textcolor{keyword}{using} std::pow;
00395   \textcolor{keyword}{using} std::sqrt;
00396   \textcolor{keyword}{using} std::abs;
00397   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = lastCol - firstCol + 1;
00398   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = n/2;
00399   \textcolor{keyword}{const} RealScalar considerZero = (std::numeric\_limits<RealScalar>::min)();
00400   RealScalar alphaK;
00401   RealScalar betaK; 
00402   RealScalar r0; 
00403   RealScalar lambda, phi, c0, s0;
00404   \hyperlink{group___core___module}{VectorType} l, f;
00405   \textcolor{comment}{// We use the other algorithm which is more efficient for small }
00406   \textcolor{comment}{// matrices.}
00407   \textcolor{keywordflow}{if} (n < m\_algoswap)
00408   \{
00409     \textcolor{comment}{// FIXME this line involves temporaries}
00410     \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD<MatrixXr>} b(m\_computed.block(firstCol, firstCol, n + 1, n), 
      \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a2b4f91ca5859a4159dbfe8090043817f}{ComputeFullU} | (m\_compV ? \hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a52c6f7e80bbf9a42297c88f700245b51}{ComputeFullV} : 0));
00411     \textcolor{keywordflow}{if} (m\_compU)
00412       m\_naiveU.block(firstCol, firstCol, n + 1, n + 1).real() = b.\hyperlink{group___s_v_d___module_afc7fe1546b0f6e1801b86f22f5664cb8}{matrixU}();
00413     \textcolor{keywordflow}{else} 
00414     \{
00415       m\_naiveU.row(0).segment(firstCol, n + 1).real() = b.\hyperlink{group___s_v_d___module_afc7fe1546b0f6e1801b86f22f5664cb8}{matrixU}().row(0);
00416       m\_naiveU.row(1).segment(firstCol, n + 1).real() = b.\hyperlink{group___s_v_d___module_afc7fe1546b0f6e1801b86f22f5664cb8}{matrixU}().row(n);
00417     \}
00418     \textcolor{keywordflow}{if} (m\_compV) m\_naiveV.block(firstRowW, firstColW, n, n).real() = b.\hyperlink{group___s_v_d___module_a245a453b5e7347f737295c23133238c4}{matrixV}();
00419     m\_computed.block(firstCol + shift, firstCol + shift, n + 1, n).setZero();
00420     m\_computed.diagonal().segment(firstCol + shift, n) = b.\hyperlink{group___s_v_d___module_a4e7bac123570c348f7ed6be909e1e474}{singularValues}().head(n);
00421     \textcolor{keywordflow}{return};
00422   \}
00423   \textcolor{comment}{// We use the divide and conquer algorithm}
00424   alphaK =  m\_computed(firstCol + k, firstCol + k);
00425   betaK = m\_computed(firstCol + k + 1, firstCol + k);
00426   \textcolor{comment}{// The divide must be done in that order in order to have good results. Divide change the data inside the
       submatrices}
00427   \textcolor{comment}{// and the divide of the right submatrice reads one column of the left submatrice. That's why we need to
       treat the }
00428   \textcolor{comment}{// right submatrix before the left one. }
00429   divide(k + 1 + firstCol, lastCol, k + 1 + firstRowW, k + 1 + firstColW, shift);
00430   divide(firstCol, k - 1 + firstCol, firstRowW, firstColW + 1, shift + 1);
00431 
00432   \textcolor{keywordflow}{if} (m\_compU)
00433   \{
00434     lambda = m\_naiveU(firstCol + k, firstCol + k);
00435     phi = m\_naiveU(firstCol + k + 1, lastCol + 1);
00436   \} 
00437   \textcolor{keywordflow}{else} 
00438   \{
00439     lambda = m\_naiveU(1, firstCol + k);
00440     phi = m\_naiveU(0, lastCol + 1);
00441   \}
00442   r0 = sqrt((abs(alphaK * lambda) * abs(alphaK * lambda)) + abs(betaK * phi) * abs(betaK * phi));
00443   \textcolor{keywordflow}{if} (m\_compU)
00444   \{
00445     l = m\_naiveU.row(firstCol + k).segment(firstCol, k);
00446     f = m\_naiveU.row(firstCol + k + 1).segment(firstCol + k + 1, n - k - 1);
00447   \} 
00448   \textcolor{keywordflow}{else} 
00449   \{
00450     l = m\_naiveU.row(1).segment(firstCol, k);
00451     f = m\_naiveU.row(0).segment(firstCol + k + 1, n - k - 1);
00452   \}
00453   \textcolor{keywordflow}{if} (m\_compV) m\_naiveV(firstRowW+k, firstColW) = Literal(1);
00454   \textcolor{keywordflow}{if} (r0<considerZero)
00455   \{
00456     c0 = Literal(1);
00457     s0 = Literal(0);
00458   \}
00459   \textcolor{keywordflow}{else}
00460   \{
00461     c0 = alphaK * lambda / r0;
00462     s0 = betaK * phi / r0;
00463   \}
00464   
00465 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_SANITY\_CHECKS}
00466   assert(m\_naiveU.allFinite());
00467   assert(m\_naiveV.allFinite());
00468   assert(m\_computed.allFinite());
00469 \textcolor{preprocessor}{#endif}
00470   
00471   \textcolor{keywordflow}{if} (m\_compU)
00472   \{
00473     \hyperlink{group___core___module}{MatrixXr} q1 (m\_naiveU.col(firstCol + k).segment(firstCol, k + 1));     
00474     \textcolor{comment}{// we shiftW Q1 to the right}
00475     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = firstCol + k - 1; i >= firstCol; i--) 
00476       m\_naiveU.col(i + 1).segment(firstCol, k + 1) = m\_naiveU.col(i).segment(firstCol, k + 1);
00477     \textcolor{comment}{// we shift q1 at the left with a factor c0}
00478     m\_naiveU.col(firstCol).segment( firstCol, k + 1) = (q1 * c0);
00479     \textcolor{comment}{// last column = q1 * - s0}
00480     m\_naiveU.col(lastCol + 1).segment(firstCol, k + 1) = (q1 * ( - s0));
00481     \textcolor{comment}{// first column = q2 * s0}
00482     m\_naiveU.col(firstCol).segment(firstCol + k + 1, n - k) = m\_naiveU.col(lastCol + 1).segment(firstCol + 
      k + 1, n - k) * s0; 
00483     \textcolor{comment}{// q2 *= c0}
00484     m\_naiveU.col(lastCol + 1).segment(firstCol + k + 1, n - k) *= c0;
00485   \} 
00486   \textcolor{keywordflow}{else} 
00487   \{
00488     RealScalar q1 = m\_naiveU(0, firstCol + k);
00489     \textcolor{comment}{// we shift Q1 to the right}
00490     \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = firstCol + k - 1; i >= firstCol; i--) 
00491       m\_naiveU(0, i + 1) = m\_naiveU(0, i);
00492     \textcolor{comment}{// we shift q1 at the left with a factor c0}
00493     m\_naiveU(0, firstCol) = (q1 * c0);
00494     \textcolor{comment}{// last column = q1 * - s0}
00495     m\_naiveU(0, lastCol + 1) = (q1 * ( - s0));
00496     \textcolor{comment}{// first column = q2 * s0}
00497     m\_naiveU(1, firstCol) = m\_naiveU(1, lastCol + 1) *s0; 
00498     \textcolor{comment}{// q2 *= c0}
00499     m\_naiveU(1, lastCol + 1) *= c0;
00500     m\_naiveU.row(1).segment(firstCol + 1, k).setZero();
00501     m\_naiveU.row(0).segment(firstCol + k + 1, n - k - 1).setZero();
00502   \}
00503   
00504 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_SANITY\_CHECKS}
00505   assert(m\_naiveU.allFinite());
00506   assert(m\_naiveV.allFinite());
00507   assert(m\_computed.allFinite());
00508 \textcolor{preprocessor}{#endif}
00509   
00510   m\_computed(firstCol + shift, firstCol + shift) = r0;
00511   m\_computed.col(firstCol + shift).segment(firstCol + shift + 1, k) = alphaK * l.transpose().real();
00512   m\_computed.col(firstCol + shift).segment(firstCol + shift + k + 1, n - k - 1) = betaK * f.transpose().
      real();
00513 
00514 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00515   \hyperlink{group___core___module}{ArrayXr} tmp1 = (m\_computed.block(firstCol+shift, firstCol+shift, n, n)).jacobiSvd().singularValues
      ();
00516 \textcolor{preprocessor}{#endif}
00517   \textcolor{comment}{// Second part: try to deflate singular values in combined matrix}
00518   deflation(firstCol, lastCol, k, firstRowW, firstColW, shift);
00519 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00520   \hyperlink{group___core___module}{ArrayXr} tmp2 = (m\_computed.block(firstCol+shift, firstCol+shift, n, n)).jacobiSvd().singularValues
      ();
00521   std::cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)nj1 = "} << tmp1.transpose().format(bdcsvdfmt) << \textcolor{stringliteral}{"\(\backslash\)n"};
00522   std::cout << \textcolor{stringliteral}{"j2 = "} << tmp2.transpose().format(bdcsvdfmt) << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
00523   std::cout << \textcolor{stringliteral}{"err:      "} << ((tmp1-tmp2).abs()>1e-12*tmp2.abs()).transpose() << \textcolor{stringliteral}{"\(\backslash\)n"};
00524   \textcolor{keyword}{static} \textcolor{keywordtype}{int} count = 0;
00525   std::cout << \textcolor{stringliteral}{"# "} << ++count << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
00526   assert((tmp1-tmp2).matrix().norm() < 1e-14*tmp2.matrix().norm());
00527 \textcolor{comment}{//   assert(count<681);}
00528 \textcolor{comment}{//   assert(((tmp1-tmp2).abs()<1e-13*tmp2.abs()).all());}
00529 \textcolor{preprocessor}{#endif}
00530   
00531   \textcolor{comment}{// Third part: compute SVD of combined matrix}
00532   \hyperlink{group___core___module}{MatrixXr} UofSVD, VofSVD;
00533   \hyperlink{group___core___module}{VectorType} singVals;
00534   computeSVDofM(firstCol + shift, n, UofSVD, singVals, VofSVD);
00535   
00536 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_SANITY\_CHECKS}
00537   assert(UofSVD.allFinite());
00538   assert(VofSVD.allFinite());
00539 \textcolor{preprocessor}{#endif}
00540   
00541   \textcolor{keywordflow}{if} (m\_compU)
00542     structured\_update(m\_naiveU.block(firstCol, firstCol, n + 1, n + 1), UofSVD, (n+2)/2);
00543   \textcolor{keywordflow}{else}
00544   \{
00545     \hyperlink{group___core___module_class_eigen_1_1_map}{Map<Matrix<RealScalar,2,Dynamic>},\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}> tmp(m\_workspace.data()
      ,2,n+1);
00546     tmp.noalias() = m\_naiveU.middleCols(firstCol, n+1) * UofSVD;
00547     m\_naiveU.middleCols(firstCol, n + 1) = tmp;
00548   \}
00549   
00550   \textcolor{keywordflow}{if} (m\_compV)  structured\_update(m\_naiveV.block(firstRowW, firstColW, n, n), VofSVD, (n+1)/2);
00551   
00552 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_SANITY\_CHECKS}
00553   assert(m\_naiveU.allFinite());
00554   assert(m\_naiveV.allFinite());
00555   assert(m\_computed.allFinite());
00556 \textcolor{preprocessor}{#endif}
00557   
00558   m\_computed.block(firstCol + shift, firstCol + shift, n, n).setZero();
00559   m\_computed.block(firstCol + shift, firstCol + shift, n, n).diagonal() = singVals;
00560 \}\textcolor{comment}{// end divide}
00561 
00562 \textcolor{comment}{// Compute SVD of m\_computed.block(firstCol, firstCol, n + 1, n); this block only has non-zeros in}
00563 \textcolor{comment}{// the first column and on the diagonal and has undergone deflation, so diagonal is in increasing}
00564 \textcolor{comment}{// order except for possibly the (0,0) entry. The computed SVD is stored U, singVals and V, except}
00565 \textcolor{comment}{// that if m\_compV is false, then V is not computed. Singular values are sorted in decreasing order.}
00566 \textcolor{comment}{//}
00567 \textcolor{comment}{// TODO Opportunities for optimization: better root finding algo, better stopping criterion, better}
00568 \textcolor{comment}{// handling of round-off errors, be consistent in ordering}
00569 \textcolor{comment}{// For instance, to solve the secular equation using FMM, see
       http://www.stat.uchicago.edu/~lekheng/courses/302/classics/greengard-rokhlin.pdf}
00570 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00571 \textcolor{keywordtype}{void} \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>::computeSVDofM}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstCol, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n, \hyperlink{group___core___module}{MatrixXr}& U, \hyperlink{group___core___module}{VectorType}& singVals, \hyperlink{group___core___module}{MatrixXr}& V)
00572 \{
00573   \textcolor{keyword}{const} RealScalar considerZero = (std::numeric\_limits<RealScalar>::min)();
00574   \textcolor{keyword}{using} std::abs;
00575   \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef} col0 = m\_computed.col(firstCol).segment(firstCol, n);
00576   m\_workspace.head(n) =  m\_computed.block(firstCol, firstCol, n, n).diagonal();
00577   \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef} diag = m\_workspace.head(n);
00578   diag(0) = Literal(0);
00579 
00580   \textcolor{comment}{// Allocate space for singular values and vectors}
00581   singVals.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(n);
00582   U.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(n+1, n+1);
00583   \textcolor{keywordflow}{if} (m\_compV) V.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(n, n);
00584 
00585 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00586   \textcolor{keywordflow}{if} (col0.hasNaN() || diag.hasNaN())
00587     std::cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)nHAS NAN\(\backslash\)n\(\backslash\)n"};
00588 \textcolor{preprocessor}{#endif}
00589   
00590   \textcolor{comment}{// Many singular values might have been deflated, the zero ones have been moved to the end,}
00591   \textcolor{comment}{// but others are interleaved and we must ignore them at this stage.}
00592   \textcolor{comment}{// To this end, let's compute a permutation skipping them:}
00593   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_n = n;
00594   \textcolor{keywordflow}{while}(actual\_n>1 && diag(actual\_n-1)==Literal(0)) --actual\_n;
00595   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m = 0; \textcolor{comment}{// size of the deflated problem}
00596   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0;k<actual\_n;++k)
00597     \textcolor{keywordflow}{if}(abs(col0(k))>considerZero)
00598       m\_workspaceI(m++) = k;
00599   \hyperlink{group___core___module_class_eigen_1_1_map}{Map<ArrayXi>} perm(m\_workspaceI.data(),m);
00600   
00601   \hyperlink{group___core___module_class_eigen_1_1_map}{Map<ArrayXr>} shifts(m\_workspace.data()+1*n, n);
00602   \hyperlink{group___core___module_class_eigen_1_1_map}{Map<ArrayXr>} mus(m\_workspace.data()+2*n, n);
00603   \hyperlink{group___core___module_class_eigen_1_1_map}{Map<ArrayXr>} zhat(m\_workspace.data()+3*n, n);
00604 
00605 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00606   std::cout << \textcolor{stringliteral}{"computeSVDofM using:\(\backslash\)n"};
00607   std::cout << \textcolor{stringliteral}{"  z: "} << col0.transpose() << \textcolor{stringliteral}{"\(\backslash\)n"};
00608   std::cout << \textcolor{stringliteral}{"  d: "} << diag.transpose() << \textcolor{stringliteral}{"\(\backslash\)n"};
00609 \textcolor{preprocessor}{#endif}
00610   
00611   \textcolor{comment}{// Compute singVals, shifts, and mus}
00612   computeSingVals(col0, diag, perm, singVals, shifts, mus);
00613   
00614 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00615   std::cout << \textcolor{stringliteral}{"  j:        "} << (m\_computed.block(firstCol, firstCol, n, n)).jacobiSvd().singularValues().
      transpose().reverse() << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
00616   std::cout << \textcolor{stringliteral}{"  sing-val: "} << singVals.transpose() << \textcolor{stringliteral}{"\(\backslash\)n"};
00617   std::cout << \textcolor{stringliteral}{"  mu:       "} << mus.transpose() << \textcolor{stringliteral}{"\(\backslash\)n"};
00618   std::cout << \textcolor{stringliteral}{"  shift:    "} << shifts.transpose() << \textcolor{stringliteral}{"\(\backslash\)n"};
00619   
00620   \{
00621     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_n = n;
00622     \textcolor{keywordflow}{while}(actual\_n>1 && abs(col0(actual\_n-1))<considerZero) --actual\_n;
00623     std::cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n    mus:    "} << mus.head(actual\_n).transpose() << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
00624     std::cout << \textcolor{stringliteral}{"    check1 (expect0) : "} << ((singVals.array()-(shifts+mus)) / singVals.array()).head(
      actual\_n).transpose() << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
00625     std::cout << \textcolor{stringliteral}{"    check2 (>0)      : "} << ((singVals.array()-diag) / singVals.array()).head(actual\_n).
      transpose() << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
00626     std::cout << \textcolor{stringliteral}{"    check3 (>0)      : "} << ((diag.segment(1,actual\_n-1)-singVals.head(actual\_n-1).array(
      )) / singVals.head(actual\_n-1).array()).transpose() << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)n"};
00627     std::cout << \textcolor{stringliteral}{"    check4 (>0)      : "} << ((singVals.segment(1,actual\_n-1)-singVals.head(actual\_n-1))).
      transpose() << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)n"};
00628   \}
00629 \textcolor{preprocessor}{#endif}
00630   
00631 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_SANITY\_CHECKS}
00632   assert(singVals.allFinite());
00633   assert(mus.allFinite());
00634   assert(shifts.allFinite());
00635 \textcolor{preprocessor}{#endif}
00636   
00637   \textcolor{comment}{// Compute zhat}
00638   perturbCol0(col0, diag, perm, singVals, shifts, mus, zhat);
00639 \textcolor{preprocessor}{#ifdef  EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00640   std::cout << \textcolor{stringliteral}{"  zhat: "} << zhat.transpose() << \textcolor{stringliteral}{"\(\backslash\)n"};
00641 \textcolor{preprocessor}{#endif}
00642   
00643 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_SANITY\_CHECKS}
00644   assert(zhat.allFinite());
00645 \textcolor{preprocessor}{#endif}
00646   
00647   computeSingVecs(zhat, diag, perm, singVals, shifts, mus, U, V);
00648   
00649 \textcolor{preprocessor}{#ifdef  EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00650   std::cout << \textcolor{stringliteral}{"U^T U: "} << (U.transpose() * U - \hyperlink{group___core___module}{MatrixXr}(MatrixXr::Identity(U.cols(),U.cols()))).
      norm() << \textcolor{stringliteral}{"\(\backslash\)n"};
00651   std::cout << \textcolor{stringliteral}{"V^T V: "} << (V.transpose() * V - \hyperlink{group___core___module}{MatrixXr}(MatrixXr::Identity(V.cols(),V.cols()))).
      norm() << \textcolor{stringliteral}{"\(\backslash\)n"};
00652 \textcolor{preprocessor}{#endif}
00653   
00654 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_SANITY\_CHECKS}
00655   assert(U.allFinite());
00656   assert(V.allFinite());
00657   assert((U.transpose() * U - \hyperlink{group___core___module}{MatrixXr}(MatrixXr::Identity(U.cols(),U.cols()))).norm() < 1e-14 * n);
00658   assert((V.transpose() * V - \hyperlink{group___core___module}{MatrixXr}(MatrixXr::Identity(V.cols(),V.cols()))).norm() < 1e-14 * n);
00659   assert(m\_naiveU.allFinite());
00660   assert(m\_naiveV.allFinite());
00661   assert(m\_computed.allFinite());
00662 \textcolor{preprocessor}{#endif}
00663   
00664   \textcolor{comment}{// Because of deflation, the singular values might not be completely sorted.}
00665   \textcolor{comment}{// Fortunately, reordering them is a O(n) problem}
00666   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<actual\_n-1; ++i)
00667   \{
00668     \textcolor{keywordflow}{if}(singVals(i)>singVals(i+1))
00669     \{
00670       \textcolor{keyword}{using} \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap};
00671       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(singVals(i),singVals(i+1));
00672       U.col(i).swap(U.col(i+1));
00673       \textcolor{keywordflow}{if}(m\_compV) V.col(i).swap(V.col(i+1));
00674     \}
00675   \}
00676   
00677   \textcolor{comment}{// Reverse order so that singular values in increased order}
00678   \textcolor{comment}{// Because of deflation, the zeros singular-values are already at the end}
00679   singVals.head(actual\_n).reverseInPlace();
00680   U.leftCols(actual\_n).rowwise().reverseInPlace();
00681   \textcolor{keywordflow}{if} (m\_compV) V.leftCols(actual\_n).rowwise().reverseInPlace();
00682   
00683 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00684   \hyperlink{group___s_v_d___module_class_eigen_1_1_jacobi_s_v_d}{JacobiSVD<MatrixXr>} jsvd(m\_computed.block(firstCol, firstCol, n, n) );
00685   std::cout << \textcolor{stringliteral}{"  * j:        "} << jsvd.singularValues().transpose() << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
00686   std::cout << \textcolor{stringliteral}{"  * sing-val: "} << singVals.transpose() << \textcolor{stringliteral}{"\(\backslash\)n"};
00687 \textcolor{comment}{//   std::cout << "  * err:      " << ((jsvd.singularValues()-singVals)>1e-13*singVals.norm()).transpose()
       << "\(\backslash\)n";}
00688 \textcolor{preprocessor}{#endif}
00689 \}
00690 
00691 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00692 \textcolor{keyword}{typename} BDCSVD<MatrixType>::RealScalar \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>::secularEq}(
      RealScalar mu, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& col0, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& diag, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_ref}{IndicesRef} &perm, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& diagShifted, RealScalar shift)
00693 \{
00694   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m = perm.size();
00695   RealScalar res = Literal(1);
00696   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0; i<m; ++i)
00697   \{
00698     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = perm(i);
00699     res += numext::abs2(col0(j)) / ((diagShifted(j) - mu) * (diag(j) + shift + mu));
00700   \}
00701   \textcolor{keywordflow}{return} res;
00702 
00703 \}
00704 
00705 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00706 \textcolor{keywordtype}{void} \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>::computeSingVals}(\textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& col0, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& diag, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{IndicesRef} &perm,
00707                                          \hyperlink{group___core___module}{VectorType}& singVals, 
      \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef} shifts, \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef} mus)
00708 \{
00709   \textcolor{keyword}{using} std::abs;
00710   \textcolor{keyword}{using} \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap};
00711 
00712   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = col0.size();
00713   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_n = n;
00714   \textcolor{keywordflow}{while}(actual\_n>1 && col0(actual\_n-1)==Literal(0)) --actual\_n;
00715 
00716   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = 0; k < n; ++k)
00717   \{
00718     \textcolor{keywordflow}{if} (col0(k) == Literal(0) || actual\_n==1)
00719     \{
00720       \textcolor{comment}{// if col0(k) == 0, then entry is deflated, so singular value is on diagonal}
00721       \textcolor{comment}{// if actual\_n==1, then the deflated problem is already diagonalized}
00722       singVals(k) = k==0 ? col0(0) : diag(k);
00723       mus(k) = Literal(0);
00724       shifts(k) = k==0 ? col0(0) : diag(k);
00725       \textcolor{keywordflow}{continue};
00726     \} 
00727 
00728     \textcolor{comment}{// otherwise, use secular equation to find singular value}
00729     RealScalar left = diag(k);
00730     RealScalar right; \textcolor{comment}{// was: = (k != actual\_n-1) ? diag(k+1) : (diag(actual\_n-1) + col0.matrix().norm());}
00731     \textcolor{keywordflow}{if}(k==actual\_n-1)
00732       right = (diag(actual\_n-1) + col0.matrix().norm());
00733     \textcolor{keywordflow}{else}
00734     \{
00735       \textcolor{comment}{// Skip deflated singular values}
00736       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} l = k+1;
00737       \textcolor{keywordflow}{while}(col0(l)==Literal(0)) \{ ++l; eigen\_internal\_assert(l<actual\_n); \}
00738       right = diag(l);
00739     \}
00740 
00741     \textcolor{comment}{// first decide whether it's closer to the left end or the right end}
00742     RealScalar mid = left + (right-left) / Literal(2);
00743     RealScalar fMid = secularEq(mid, col0, diag, perm, diag, Literal(0));
00744 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00745     std::cout << right-left << \textcolor{stringliteral}{"\(\backslash\)n"};
00746     std::cout << \textcolor{stringliteral}{"fMid = "} << fMid << \textcolor{stringliteral}{" "} << secularEq(mid-left, col0, diag, perm, diag-left, left) << \textcolor{stringliteral}{" "} 
      << secularEq(mid-right, col0, diag, perm, diag-right, right)   << \textcolor{stringliteral}{"\(\backslash\)n"};
00747     std::cout << \textcolor{stringliteral}{"     = "} << secularEq(0.1*(left+right), col0, diag, perm, diag, 0)
00748               << \textcolor{stringliteral}{" "}       << secularEq(0.2*(left+right), col0, diag, perm, diag, 0)
00749               << \textcolor{stringliteral}{" "}       << secularEq(0.3*(left+right), col0, diag, perm, diag, 0)
00750               << \textcolor{stringliteral}{" "}       << secularEq(0.4*(left+right), col0, diag, perm, diag, 0)
00751               << \textcolor{stringliteral}{" "}       << secularEq(0.49*(left+right), col0, diag, perm, diag, 0)
00752               << \textcolor{stringliteral}{" "}       << secularEq(0.5*(left+right), col0, diag, perm, diag, 0)
00753               << \textcolor{stringliteral}{" "}       << secularEq(0.51*(left+right), col0, diag, perm, diag, 0)
00754               << \textcolor{stringliteral}{" "}       << secularEq(0.6*(left+right), col0, diag, perm, diag, 0)
00755               << \textcolor{stringliteral}{" "}       << secularEq(0.7*(left+right), col0, diag, perm, diag, 0)
00756               << \textcolor{stringliteral}{" "}       << secularEq(0.8*(left+right), col0, diag, perm, diag, 0)
00757               << \textcolor{stringliteral}{" "}       << secularEq(0.9*(left+right), col0, diag, perm, diag, 0) << \textcolor{stringliteral}{"\(\backslash\)n"};
00758 \textcolor{preprocessor}{#endif}
00759     RealScalar shift = (k == actual\_n-1 || fMid > Literal(0)) ? left : right;
00760     
00761     \textcolor{comment}{// measure everything relative to shift}
00762     \hyperlink{group___core___module_class_eigen_1_1_map}{Map<ArrayXr>} diagShifted(m\_workspace.data()+4*n, n);
00763     diagShifted = diag - shift;
00764     
00765     \textcolor{comment}{// initial guess}
00766     RealScalar muPrev, muCur;
00767     \textcolor{keywordflow}{if} (shift == left)
00768     \{
00769       muPrev = (right - left) * RealScalar(0.1);
00770       \textcolor{keywordflow}{if} (k == actual\_n-1) muCur = right - left;
00771       \textcolor{keywordflow}{else}                 muCur = (right - left) * RealScalar(0.5);
00772     \}
00773     \textcolor{keywordflow}{else}
00774     \{
00775       muPrev = -(right - left) * RealScalar(0.1);
00776       muCur = -(right - left) * RealScalar(0.5);
00777     \}
00778 
00779     RealScalar fPrev = secularEq(muPrev, col0, diag, perm, diagShifted, shift);
00780     RealScalar fCur = secularEq(muCur, col0, diag, perm, diagShifted, shift);
00781     \textcolor{keywordflow}{if} (abs(fPrev) < abs(fCur))
00782     \{
00783       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(fPrev, fCur);
00784       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(muPrev, muCur);
00785     \}
00786 
00787     \textcolor{comment}{// rational interpolation: fit a function of the form a / mu + b through the two previous}
00788     \textcolor{comment}{// iterates and use its zero to compute the next iterate}
00789     \textcolor{keywordtype}{bool} useBisection = fPrev*fCur>Literal(0);
00790     \textcolor{keywordflow}{while} (fCur!=Literal(0) && abs(muCur - muPrev) > Literal(8) * 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::epsilon}() * numext::maxi<RealScalar>(abs(muCur), abs(
      muPrev)) && abs(fCur - fPrev)>\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::epsilon}() && !useBisection
      )
00791     \{
00792       ++m\_numIters;
00793 
00794       \textcolor{comment}{// Find a and b such that the function f(mu) = a / mu + b matches the current and previous samples.}
00795       RealScalar a = (fCur - fPrev) / (Literal(1)/muCur - Literal(1)/muPrev);
00796       RealScalar b = fCur - a / muCur;
00797       \textcolor{comment}{// And find mu such that f(mu)==0:}
00798       RealScalar muZero = -a/b;
00799       RealScalar fZero = secularEq(muZero, col0, diag, perm, diagShifted, shift);
00800       
00801       muPrev = muCur;
00802       fPrev = fCur;
00803       muCur = muZero;
00804       fCur = fZero;
00805       
00806       
00807       \textcolor{keywordflow}{if} (shift == left  && (muCur < Literal(0) || muCur > right - left)) useBisection = \textcolor{keyword}{true};
00808       \textcolor{keywordflow}{if} (shift == right && (muCur < -(right - left) || muCur > Literal(0))) useBisection = \textcolor{keyword}{true};
00809       \textcolor{keywordflow}{if} (abs(fCur)>abs(fPrev)) useBisection = \textcolor{keyword}{true};
00810     \}
00811 
00812     \textcolor{comment}{// fall back on bisection method if rational interpolation did not work}
00813     \textcolor{keywordflow}{if} (useBisection)
00814     \{
00815 \textcolor{preprocessor}{#ifdef  EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00816       std::cout << \textcolor{stringliteral}{"useBisection for k = "} << k << \textcolor{stringliteral}{", actual\_n = "} << actual\_n << \textcolor{stringliteral}{"\(\backslash\)n"};
00817 \textcolor{preprocessor}{#endif}
00818       RealScalar leftShifted, rightShifted;
00819       \textcolor{keywordflow}{if} (shift == left)
00820       \{
00821         leftShifted = (std::numeric\_limits<RealScalar>::min)();
00822         \textcolor{comment}{// I don't understand why the case k==0 would be special there:}
00823         \textcolor{comment}{// if (k == 0) rightShifted = right - left; else }
00824         rightShifted = (k==actual\_n-1) ? right : ((right - left) * RealScalar(0.6)); \textcolor{comment}{// theoretically we
       can take 0.5, but let's be safe}
00825       \}
00826       \textcolor{keywordflow}{else}
00827       \{
00828         leftShifted = -(right - left) * RealScalar(0.6);
00829         rightShifted = -(std::numeric\_limits<RealScalar>::min)();
00830       \}
00831       
00832       RealScalar fLeft = secularEq(leftShifted, col0, diag, perm, diagShifted, shift);
00833 
00834 \textcolor{preprocessor}{#if defined EIGEN\_INTERNAL\_DEBUGGING || defined EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00835       RealScalar fRight = secularEq(rightShifted, col0, diag, perm, diagShifted, shift);
00836 \textcolor{preprocessor}{#endif}
00837 
00838 \textcolor{preprocessor}{#ifdef  EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00839       \textcolor{keywordflow}{if}(!(fLeft * fRight<0))
00840       \{
00841         std::cout << \textcolor{stringliteral}{"fLeft: "} << leftShifted << \textcolor{stringliteral}{" - "} << diagShifted.head(10).transpose()  << \textcolor{stringliteral}{"\(\backslash\)n ; "} << 
      bool(left==shift) << \textcolor{stringliteral}{" "} << (left-shift) << \textcolor{stringliteral}{"\(\backslash\)n"};
00842         std::cout << k << \textcolor{stringliteral}{" : "} <<  fLeft << \textcolor{stringliteral}{" * "} << fRight << \textcolor{stringliteral}{" == "} << fLeft * fRight << \textcolor{stringliteral}{"  ;  "} << left
       << \textcolor{stringliteral}{" - "} << right << \textcolor{stringliteral}{" -> "} <<  leftShifted << \textcolor{stringliteral}{" "} << rightShifted << \textcolor{stringliteral}{"   shift="} << shift << \textcolor{stringliteral}{"\(\backslash\)n"};
00843       \}
00844 \textcolor{preprocessor}{#endif}
00845       eigen\_internal\_assert(fLeft * fRight < Literal(0));
00846       
00847       \textcolor{keywordflow}{while} (rightShifted - leftShifted > Literal(2) * 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::epsilon}() * numext::maxi<RealScalar>(abs(leftShifted),
       abs(rightShifted)))
00848       \{
00849         RealScalar midShifted = (leftShifted + rightShifted) / Literal(2);
00850         fMid = secularEq(midShifted, col0, diag, perm, diagShifted, shift);
00851         \textcolor{keywordflow}{if} (fLeft * fMid < Literal(0))
00852         \{
00853           rightShifted = midShifted;
00854         \}
00855         \textcolor{keywordflow}{else}
00856         \{
00857           leftShifted = midShifted;
00858           fLeft = fMid;
00859         \}
00860       \}
00861 
00862       muCur = (leftShifted + rightShifted) / Literal(2);
00863     \}
00864       
00865     singVals[k] = shift + muCur;
00866     shifts[k] = shift;
00867     mus[k] = muCur;
00868 
00869     \textcolor{comment}{// perturb singular value slightly if it equals diagonal entry to avoid division by zero later}
00870     \textcolor{comment}{// (deflation is supposed to avoid this from happening)}
00871     \textcolor{comment}{// - this does no seem to be necessary anymore -}
00872 \textcolor{comment}{//     if (singVals[k] == left) singVals[k] *= 1 + NumTraits<RealScalar>::epsilon();}
00873 \textcolor{comment}{//     if (singVals[k] == right) singVals[k] *= 1 - NumTraits<RealScalar>::epsilon();}
00874   \}
00875 \}
00876 
00877 
00878 \textcolor{comment}{// zhat is perturbation of col0 for which singular vectors can be computed stably (see Section 3.1)}
00879 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00880 \textcolor{keywordtype}{void} \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>::perturbCol0}
00881    (\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& col0, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& diag, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{IndicesRef} &perm, \textcolor{keyword}{const} 
      \hyperlink{group___core___module}{VectorType}& singVals,
00882     \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& shifts, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& mus, \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef} zhat)
00883 \{
00884   \textcolor{keyword}{using} std::sqrt;
00885   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = col0.size();
00886   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m = perm.size();
00887   \textcolor{keywordflow}{if}(m==0)
00888   \{
00889     zhat.setZero();
00890     \textcolor{keywordflow}{return};
00891   \}
00892   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} last = perm(m-1);
00893   \textcolor{comment}{// The offset permits to skip deflated entries while computing zhat}
00894   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = 0; k < n; ++k)
00895   \{
00896     \textcolor{keywordflow}{if} (col0(k) == Literal(0)) \textcolor{comment}{// deflated}
00897       zhat(k) = Literal(0);
00898     \textcolor{keywordflow}{else}
00899     \{
00900       \textcolor{comment}{// see equation (3.6)}
00901       RealScalar dk = diag(k);
00902       RealScalar prod = (singVals(last) + dk) * (mus(last) + (shifts(last) - dk));
00903 
00904       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} l = 0; l<m; ++l)
00905       \{
00906         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = perm(l);
00907         \textcolor{keywordflow}{if}(i!=k)
00908         \{
00909           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = i<k ? i : perm(l-1);
00910           prod *= ((singVals(j)+dk) / ((diag(i)+dk))) * ((mus(j)+(shifts(j)-dk)) / ((diag(i)-dk)));
00911 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00912           \textcolor{keywordflow}{if}(i!=k && std::abs(((singVals(j)+dk)*(mus(j)+(shifts(j)-dk)))/((diag(i)+dk)*(diag(i)-dk)) - 1) >
       0.9 )
00913             std::cout << \textcolor{stringliteral}{"     "} << ((singVals(j)+dk)*(mus(j)+(shifts(j)-dk)))/((diag(i)+dk)*(diag(i)-dk)) 
      << \textcolor{stringliteral}{" == ("} << (singVals(j)+dk) << \textcolor{stringliteral}{" * "} << (mus(j)+(shifts(j)-dk))
00914                        << \textcolor{stringliteral}{") / ("} << (diag(i)+dk) << \textcolor{stringliteral}{" * "} << (diag(i)-dk) << \textcolor{stringliteral}{")\(\backslash\)n"};
00915 \textcolor{preprocessor}{#endif}
00916         \}
00917       \}
00918 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
00919       std::cout << \textcolor{stringliteral}{"zhat("} << k << \textcolor{stringliteral}{") =  sqrt( "} << prod << \textcolor{stringliteral}{")  ;  "} << (singVals(last) + dk) << \textcolor{stringliteral}{" * "} << 
      mus(last) + shifts(last) << \textcolor{stringliteral}{" - "} << dk << \textcolor{stringliteral}{"\(\backslash\)n"};
00920 \textcolor{preprocessor}{#endif}
00921       RealScalar tmp = sqrt(prod);
00922       zhat(k) = col0(k) > Literal(0) ? tmp : -tmp;
00923     \}
00924   \}
00925 \}
00926 
00927 \textcolor{comment}{// compute singular vectors}
00928 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00929 \textcolor{keywordtype}{void} \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>::computeSingVecs}
00930    (\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& zhat, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& diag, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{IndicesRef} &perm, \textcolor{keyword}{const} 
      \hyperlink{group___core___module}{VectorType}& singVals,
00931     \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& shifts, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_ref}{ArrayRef}& mus, \hyperlink{group___core___module}{MatrixXr}& U, 
      \hyperlink{group___core___module}{MatrixXr}& V)
00932 \{
00933   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n = zhat.size();
00934   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m = perm.size();
00935   
00936   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k = 0; k < n; ++k)
00937   \{
00938     \textcolor{keywordflow}{if} (zhat(k) == Literal(0))
00939     \{
00940       U.col(k) = VectorType::Unit(n+1, k);
00941       \textcolor{keywordflow}{if} (m\_compV) V.col(k) = VectorType::Unit(n, k);
00942     \}
00943     \textcolor{keywordflow}{else}
00944     \{
00945       U.col(k).\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00946       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} l=0;l<m;++l)
00947       \{
00948         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = perm(l);
00949         U(i,k) = zhat(i)/(((diag(i) - shifts(k)) - mus(k)) )/( (diag(i) + singVals[k]));
00950       \}
00951       U(n,k) = Literal(0);
00952       U.col(k).normalize();
00953     
00954       \textcolor{keywordflow}{if} (m\_compV)
00955       \{
00956         V.col(k).\hyperlink{class_eigen_1_1_plain_object_base_ac21ad5f989f320e46958b75ac8d9a1da}{setZero}();
00957         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} l=1;l<m;++l)
00958         \{
00959           \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = perm(l);
00960           V(i,k) = diag(i) * zhat(i) / (((diag(i) - shifts(k)) - mus(k)) )/( (diag(i) + singVals[k]));
00961         \}
00962         V(0,k) = Literal(-1);
00963         V.col(k).normalize();
00964       \}
00965     \}
00966   \}
00967   U.col(n) = VectorType::Unit(n+1, n);
00968 \}
00969 
00970 
00971 \textcolor{comment}{// page 12\_13}
00972 \textcolor{comment}{// i >= 1, di almost null and zi non null.}
00973 \textcolor{comment}{// We use a rotation to zero out zi applied to the left of M}
00974 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
00975 \textcolor{keywordtype}{void} \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>::deflation43}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstCol, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} shift, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size)
00976 \{
00977   \textcolor{keyword}{using} std::abs;
00978   \textcolor{keyword}{using} std::sqrt;
00979   \textcolor{keyword}{using} std::pow;
00980   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} start = firstCol + shift;
00981   RealScalar c = m\_computed(start, start);
00982   RealScalar s = m\_computed(start+i, start);
00983   RealScalar r = sqrt(numext::abs2(c) + numext::abs2(s));
00984   \textcolor{keywordflow}{if} (r == Literal(0))
00985   \{
00986     m\_computed(start+i, start+i) = Literal(0);
00987     \textcolor{keywordflow}{return};
00988   \}
00989   m\_computed(start,start) = r;  
00990   m\_computed(start+i, start) = Literal(0);
00991   m\_computed(start+i, start+i) = Literal(0);
00992   
00993   \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<RealScalar>} J(c/r,-s/r);
00994   \textcolor{keywordflow}{if} (m\_compU)  m\_naiveU.middleRows(firstCol, size+1).applyOnTheRight(firstCol, firstCol+i, J);
00995   \textcolor{keywordflow}{else}          m\_naiveU.applyOnTheRight(firstCol, firstCol+i, J);
00996 \}\textcolor{comment}{// end deflation 43}
00997 
00998 
00999 \textcolor{comment}{// page 13}
01000 \textcolor{comment}{// i,j >= 1, i!=j and |di - dj| < epsilon * norm2(M)}
01001 \textcolor{comment}{// We apply two rotations to have zj = 0;}
01002 \textcolor{comment}{// TODO deflation44 is still broken and not properly tested}
01003 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
01004 \textcolor{keywordtype}{void} \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>::deflation44}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstColu , 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstColm, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstRowW, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstColW, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size)
01005 \{
01006   \textcolor{keyword}{using} std::abs;
01007   \textcolor{keyword}{using} std::sqrt;
01008   \textcolor{keyword}{using} std::conj;
01009   \textcolor{keyword}{using} std::pow;
01010   RealScalar c = m\_computed(firstColm+i, firstColm);
01011   RealScalar s = m\_computed(firstColm+j, firstColm);
01012   RealScalar r = sqrt(numext::abs2(c) + numext::abs2(s));
01013 \textcolor{preprocessor}{#ifdef  EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
01014   std::cout << \textcolor{stringliteral}{"deflation 4.4: "} << i << \textcolor{stringliteral}{","} << j << \textcolor{stringliteral}{" -> "} << c << \textcolor{stringliteral}{" "} << s << \textcolor{stringliteral}{" "} << r << \textcolor{stringliteral}{" ; "}
01015     << m\_computed(firstColm + i-1, firstColm)  << \textcolor{stringliteral}{" "}
01016     << m\_computed(firstColm + i, firstColm)  << \textcolor{stringliteral}{" "}
01017     << m\_computed(firstColm + i+1, firstColm) << \textcolor{stringliteral}{" "}
01018     << m\_computed(firstColm + i+2, firstColm) << \textcolor{stringliteral}{"\(\backslash\)n"};
01019   std::cout << m\_computed(firstColm + i-1, firstColm + i-1)  << \textcolor{stringliteral}{" "}
01020     << m\_computed(firstColm + i, firstColm+i)  << \textcolor{stringliteral}{" "}
01021     << m\_computed(firstColm + i+1, firstColm+i+1) << \textcolor{stringliteral}{" "}
01022     << m\_computed(firstColm + i+2, firstColm+i+2) << \textcolor{stringliteral}{"\(\backslash\)n"};
01023 \textcolor{preprocessor}{#endif}
01024   \textcolor{keywordflow}{if} (r==Literal(0))
01025   \{
01026     m\_computed(firstColm + i, firstColm + i) = m\_computed(firstColm + j, firstColm + j);
01027     \textcolor{keywordflow}{return};
01028   \}
01029   c/=r;
01030   s/=r;
01031   m\_computed(firstColm + i, firstColm) = r;  
01032   m\_computed(firstColm + j, firstColm + j) = m\_computed(firstColm + i, firstColm + i);
01033   m\_computed(firstColm + j, firstColm) = Literal(0);
01034 
01035   \hyperlink{group___jacobi___module_class_eigen_1_1_jacobi_rotation}{JacobiRotation<RealScalar>} J(c,-s);
01036   \textcolor{keywordflow}{if} (m\_compU)  m\_naiveU.middleRows(firstColu, size+1).applyOnTheRight(firstColu + i, firstColu + j, J);
01037   \textcolor{keywordflow}{else}          m\_naiveU.applyOnTheRight(firstColu+i, firstColu+j, J);
01038   \textcolor{keywordflow}{if} (m\_compV)  m\_naiveV.middleRows(firstRowW, size).applyOnTheRight(firstColW + i, firstColW + j, J);
01039 \}\textcolor{comment}{// end deflation 44}
01040 
01041 
01042 \textcolor{comment}{// acts on block from (firstCol+shift, firstCol+shift) to (lastCol+shift, lastCol+shift) [inclusive]}
01043 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatrixType>
01044 \textcolor{keywordtype}{void} \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<MatrixType>::deflation}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstCol, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lastCol, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstRowW, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} firstColW, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} shift)
01045 \{
01046   \textcolor{keyword}{using} std::sqrt;
01047   \textcolor{keyword}{using} std::abs;
01048   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} length = lastCol + 1 - firstCol;
01049   
01050   \hyperlink{group___core___module_class_eigen_1_1_block}{Block<MatrixXr,Dynamic,1>} col0(m\_computed, firstCol+shift, firstCol+shift, 
      length, 1);
01051   \hyperlink{group___core___module_class_eigen_1_1_diagonal}{Diagonal<MatrixXr>} fulldiag(m\_computed);
01052   \hyperlink{group___core___module_class_eigen_1_1_vector_block}{VectorBlock<Diagonal<MatrixXr>},\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}> diag(fulldiag, firstCol+
      shift, length);
01053   
01054   \textcolor{keyword}{const} RealScalar considerZero = (std::numeric\_limits<RealScalar>::min)();
01055   RealScalar maxDiag = diag.tail((std::max)(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(1),length-1)).cwiseAbs().maxCoeff();
01056   RealScalar epsilon\_strict = numext::maxi<RealScalar>(considerZero,
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::epsilon}() * maxDiag);
01057   RealScalar epsilon\_coarse = Literal(8) * \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::epsilon}() *
       numext::maxi<RealScalar>(col0.cwiseAbs().maxCoeff(), maxDiag);
01058   
01059 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_SANITY\_CHECKS}
01060   assert(m\_naiveU.allFinite());
01061   assert(m\_naiveV.allFinite());
01062   assert(m\_computed.allFinite());
01063 \textcolor{preprocessor}{#endif}
01064 
01065 \textcolor{preprocessor}{#ifdef  EIGEN\_BDCSVD\_DEBUG\_VERBOSE  }
01066   std::cout << \textcolor{stringliteral}{"\(\backslash\)ndeflate:"} << diag.head(k+1).transpose() << \textcolor{stringliteral}{"  |  "} << diag.segment(k+1,length-k-1).
      transpose() << \textcolor{stringliteral}{"\(\backslash\)n"};
01067 \textcolor{preprocessor}{#endif}
01068   
01069   \textcolor{comment}{//condition 4.1}
01070   \textcolor{keywordflow}{if} (diag(0) < epsilon\_coarse)
01071   \{ 
01072 \textcolor{preprocessor}{#ifdef  EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
01073     std::cout << \textcolor{stringliteral}{"deflation 4.1, because "} << diag(0) << \textcolor{stringliteral}{" < "} << epsilon\_coarse << \textcolor{stringliteral}{"\(\backslash\)n"};
01074 \textcolor{preprocessor}{#endif}
01075     diag(0) = epsilon\_coarse;
01076   \}
01077 
01078   \textcolor{comment}{//condition 4.2}
01079   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=1;i<length;++i)
01080     \textcolor{keywordflow}{if} (abs(col0(i)) < epsilon\_strict)
01081     \{
01082 \textcolor{preprocessor}{#ifdef  EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
01083       std::cout << \textcolor{stringliteral}{"deflation 4.2, set z("} << i << \textcolor{stringliteral}{") to zero because "} << abs(col0(i)) << \textcolor{stringliteral}{" < "} << 
      epsilon\_strict << \textcolor{stringliteral}{"  (diag("} << i << \textcolor{stringliteral}{")="} << diag(i) << \textcolor{stringliteral}{")\(\backslash\)n"};
01084 \textcolor{preprocessor}{#endif}
01085       col0(i) = Literal(0);
01086     \}
01087 
01088   \textcolor{comment}{//condition 4.3}
01089   \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=1;i<length; i++)
01090     \textcolor{keywordflow}{if} (diag(i) < epsilon\_coarse)
01091     \{
01092 \textcolor{preprocessor}{#ifdef  EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
01093       std::cout << \textcolor{stringliteral}{"deflation 4.3, cancel z("} << i << \textcolor{stringliteral}{")="} << col0(i) << \textcolor{stringliteral}{" because diag("} << i << \textcolor{stringliteral}{")="} << 
      diag(i) << \textcolor{stringliteral}{" < "} << epsilon\_coarse << \textcolor{stringliteral}{"\(\backslash\)n"};
01094 \textcolor{preprocessor}{#endif}
01095       deflation43(firstCol, shift, i, length);
01096     \}
01097 
01098 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_SANITY\_CHECKS}
01099   assert(m\_naiveU.allFinite());
01100   assert(m\_naiveV.allFinite());
01101   assert(m\_computed.allFinite());
01102 \textcolor{preprocessor}{#endif}
01103 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
01104   std::cout << \textcolor{stringliteral}{"to be sorted: "} << diag.transpose() << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
01105 \textcolor{preprocessor}{#endif}
01106   \{
01107     \textcolor{comment}{// Check for total deflation}
01108     \textcolor{comment}{// If we have a total deflation, then we have to consider col0(0)==diag(0) as a singular value during
       sorting}
01109     \textcolor{keywordtype}{bool} total\_deflation = (col0.tail(length-1).array()<considerZero).all();
01110     
01111     \textcolor{comment}{// Sort the diagonal entries, since diag(1:k-1) and diag(k:length) are already sorted, let's do a
       sorted merge.}
01112     \textcolor{comment}{// First, compute the respective permutation.}
01113     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} *permutation = m\_workspaceI.data();
01114     \{
01115       permutation[0] = 0;
01116       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} p = 1;
01117       
01118       \textcolor{comment}{// Move deflated diagonal entries at the end.}
01119       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=1; i<length; ++i)
01120         \textcolor{keywordflow}{if}(abs(diag(i))<considerZero)
01121           permutation[p++] = i;
01122         
01123       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=1, j=k+1;
01124       \textcolor{keywordflow}{for}( ; p < length; ++p)
01125       \{
01126              \textcolor{keywordflow}{if} (i > k)             permutation[p] = j++;
01127         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j >= length)       permutation[p] = i++;
01128         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (diag(i) < diag(j)) permutation[p] = j++;
01129         \textcolor{keywordflow}{else}                        permutation[p] = i++;
01130       \}
01131     \}
01132     
01133     \textcolor{comment}{// If we have a total deflation, then we have to insert diag(0) at the right place}
01134     \textcolor{keywordflow}{if}(total\_deflation)
01135     \{
01136       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=1; i<length; ++i)
01137       \{
01138         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} pi = permutation[i];
01139         \textcolor{keywordflow}{if}(abs(diag(pi))<considerZero || diag(0)<diag(pi))
01140           permutation[i-1] = permutation[i];
01141         \textcolor{keywordflow}{else}
01142         \{
01143           permutation[i-1] = 0;
01144           \textcolor{keywordflow}{break};
01145         \}
01146       \}
01147     \}
01148     
01149     \textcolor{comment}{// Current index of each col, and current column of each index}
01150     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} *realInd = m\_workspaceI.data()+length;
01151     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} *realCol = m\_workspaceI.data()+2*length;
01152     
01153     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} pos = 0; pos< length; pos++)
01154     \{
01155       realCol[pos] = pos;
01156       realInd[pos] = pos;
01157     \}
01158     
01159     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = total\_deflation?0:1; i < length; i++)
01160     \{
01161       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} pi = permutation[length - (total\_deflation ? i+1 : i)];
01162       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} J = realCol[pi];
01163       
01164       \textcolor{keyword}{using} \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap};
01165       \textcolor{comment}{// swap diagonal and first column entries:}
01166       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(diag(i), diag(J));
01167       \textcolor{keywordflow}{if}(i!=0 && J!=0) \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(col0(i), col0(J));
01168 
01169       \textcolor{comment}{// change columns}
01170       \textcolor{keywordflow}{if} (m\_compU) m\_naiveU.col(firstCol+i).segment(firstCol, length + 1).swap(m\_naiveU.col(firstCol+J).
      segment(firstCol, length + 1));
01171       \textcolor{keywordflow}{else}         m\_naiveU.col(firstCol+i).segment(0, 2)                .swap(m\_naiveU.col(firstCol+J).
      segment(0, 2));
01172       \textcolor{keywordflow}{if} (m\_compV) m\_naiveV.col(firstColW + i).segment(firstRowW, length).swap(m\_naiveV.col(firstColW + J).
      segment(firstRowW, length));
01173 
01174       \textcolor{comment}{//update real pos}
01175       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} realI = realInd[i];
01176       realCol[realI] = J;
01177       realCol[pi] = i;
01178       realInd[J] = realI;
01179       realInd[i] = pi;
01180     \}
01181   \}
01182 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
01183   std::cout << \textcolor{stringliteral}{"sorted: "} << diag.transpose().format(bdcsvdfmt) << \textcolor{stringliteral}{"\(\backslash\)n"};
01184   std::cout << \textcolor{stringliteral}{"      : "} << col0.transpose() << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};
01185 \textcolor{preprocessor}{#endif}
01186     
01187   \textcolor{comment}{//condition 4.4}
01188   \{
01189     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = length-1;
01190     \textcolor{keywordflow}{while}(i>0 && (abs(diag(i))<considerZero || abs(col0(i))<considerZero)) --i;
01191     \textcolor{keywordflow}{for}(; i>1;--i)
01192        \textcolor{keywordflow}{if}( (diag(i) - diag(i-1)) < \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::epsilon}()*maxDiag )
01193       \{
01194 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_DEBUG\_VERBOSE}
01195         std::cout << \textcolor{stringliteral}{"deflation 4.4 with i = "} << i << \textcolor{stringliteral}{" because "} << (diag(i) - diag(i-1)) << \textcolor{stringliteral}{" < "} << 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::epsilon}()*diag(i) << \textcolor{stringliteral}{"\(\backslash\)n"};
01196 \textcolor{preprocessor}{#endif}
01197         eigen\_internal\_assert(abs(diag(i) - diag(i-1))<epsilon\_coarse && \textcolor{stringliteral}{" diagonal entries are not
       properly sorted"});
01198         deflation44(firstCol, firstCol + shift, firstRowW, firstColW, i-1, i, length);
01199       \}
01200   \}
01201   
01202 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_SANITY\_CHECKS}
01203   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j=2;j<length;++j)
01204     assert(diag(j-1)<=diag(j) || abs(diag(j))<considerZero);
01205 \textcolor{preprocessor}{#endif}
01206   
01207 \textcolor{preprocessor}{#ifdef EIGEN\_BDCSVD\_SANITY\_CHECKS}
01208   assert(m\_naiveU.allFinite());
01209   assert(m\_naiveV.allFinite());
01210   assert(m\_computed.allFinite());
01211 \textcolor{preprocessor}{#endif}
01212 \}\textcolor{comment}{//end deflation}
01213 
01214 \textcolor{preprocessor}{#ifndef \_\_CUDACC\_\_}
01215 
01221 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
01222 \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<typename MatrixBase<Derived>::PlainObject}>
01223 \hyperlink{group___core___module_ae171b74b5d530846ee0836135ffcf837}{MatrixBase<Derived>::bdcSvd}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} computationOptions)\textcolor{keyword}{ const}
01224 \textcolor{keyword}{}\{
01225   \textcolor{keywordflow}{return} \hyperlink{group___s_v_d___module_class_eigen_1_1_b_d_c_s_v_d}{BDCSVD<PlainObject>}(*\textcolor{keyword}{this}, computationOptions);
01226 \}
01227 \textcolor{preprocessor}{#endif}
01228 
01229 \} \textcolor{comment}{// end namespace Eigen}
01230 
01231 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
