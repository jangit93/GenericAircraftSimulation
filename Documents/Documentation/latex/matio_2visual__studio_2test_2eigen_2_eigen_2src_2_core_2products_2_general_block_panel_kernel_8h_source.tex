\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2products_2_general_block_panel_kernel_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/products/\+General\+Block\+Panel\+Kernel.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2products_2_general_block_panel_kernel_8h_source}\index{General\+Block\+Panel\+Kernel.\+h@{General\+Block\+Panel\+Kernel.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_GENERAL\_BLOCK\_PANEL\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_GENERAL\_BLOCK\_PANEL\_H}
00012 
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00017 
00018 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_LhsScalar, \textcolor{keyword}{typename} \_RhsScalar, \textcolor{keywordtype}{bool} \_ConjLhs=false, \textcolor{keywordtype}{bool} \_ConjRhs=false>
00019 \textcolor{keyword}{class }gebp\_traits;
00020 
00021 
00023 \textcolor{keyword}{inline} std::ptrdiff\_t manage\_caching\_sizes\_helper(std::ptrdiff\_t a, std::ptrdiff\_t b)
00024 \{
00025   \textcolor{keywordflow}{return} a<=0 ? b : a;
00026 \}
00027 
00028 \textcolor{preprocessor}{#if EIGEN\_ARCH\_i386\_OR\_x86\_64}
00029 \textcolor{keyword}{const} std::ptrdiff\_t defaultL1CacheSize = 32*1024;
00030 \textcolor{keyword}{const} std::ptrdiff\_t defaultL2CacheSize = 256*1024;
00031 \textcolor{keyword}{const} std::ptrdiff\_t defaultL3CacheSize = 2*1024*1024;
00032 \textcolor{preprocessor}{#else}
00033 \textcolor{keyword}{const} std::ptrdiff\_t defaultL1CacheSize = 16*1024;
00034 \textcolor{keyword}{const} std::ptrdiff\_t defaultL2CacheSize = 512*1024;
00035 \textcolor{keyword}{const} std::ptrdiff\_t defaultL3CacheSize = 512*1024;
00036 \textcolor{preprocessor}{#endif}
00037 
00039 \textcolor{keyword}{struct }CacheSizes \{
00040   CacheSizes(): m\_l1(-1),m\_l2(-1),m\_l3(-1) \{
00041     \textcolor{keywordtype}{int} \hyperlink{namespace_eigen_a2669f89ff38296a38e6d973552eb4e33}{l1CacheSize}, \hyperlink{namespace_eigen_a2cfc0330ba567d63a496be1cac8427ae}{l2CacheSize}, \hyperlink{namespace_eigen_ae2efa4852ea90c2d47b7dcec5b40ba2b}{l3CacheSize};
00042     queryCacheSizes(l1CacheSize, l2CacheSize, l3CacheSize);
00043     m\_l1 = manage\_caching\_sizes\_helper(l1CacheSize, defaultL1CacheSize);
00044     m\_l2 = manage\_caching\_sizes\_helper(l2CacheSize, defaultL2CacheSize);
00045     m\_l3 = manage\_caching\_sizes\_helper(l3CacheSize, defaultL3CacheSize);
00046   \}
00047 
00048   std::ptrdiff\_t m\_l1;
00049   std::ptrdiff\_t m\_l2;
00050   std::ptrdiff\_t m\_l3;
00051 \};
00052 
00053 
00055 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} manage\_caching\_sizes(Action action, std::ptrdiff\_t* l1, std::ptrdiff\_t* l2, std::ptrdiff\_t* l3)
00056 \{
00057   \textcolor{keyword}{static} CacheSizes m\_cacheSizes;
00058 
00059   \textcolor{keywordflow}{if}(action==SetAction)
00060   \{
00061     \textcolor{comment}{// set the cpu cache size and cache all block sizes from a global cache size in byte}
00062     eigen\_internal\_assert(l1!=0 && l2!=0);
00063     m\_cacheSizes.m\_l1 = *l1;
00064     m\_cacheSizes.m\_l2 = *l2;
00065     m\_cacheSizes.m\_l3 = *l3;
00066   \}
00067   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(action==GetAction)
00068   \{
00069     eigen\_internal\_assert(l1!=0 && l2!=0);
00070     *l1 = m\_cacheSizes.m\_l1;
00071     *l2 = m\_cacheSizes.m\_l2;
00072     *l3 = m\_cacheSizes.m\_l3;
00073   \}
00074   \textcolor{keywordflow}{else}
00075   \{
00076     eigen\_internal\_assert(\textcolor{keyword}{false});
00077   \}
00078 \}
00079 
00080 \textcolor{comment}{/* Helper for computeProductBlockingSizes.}
00081 \textcolor{comment}{ *}
00082 \textcolor{comment}{ * Given a m x k times k x n matrix product of scalar types \(\backslash\)c LhsScalar and \(\backslash\)c RhsScalar,}
00083 \textcolor{comment}{ * this function computes the blocking size parameters along the respective dimensions}
00084 \textcolor{comment}{ * for matrix products and related algorithms. The blocking sizes depends on various}
00085 \textcolor{comment}{ * parameters:}
00086 \textcolor{comment}{ * - the L1 and L2 cache sizes,}
00087 \textcolor{comment}{ * - the register level blocking sizes defined by gebp\_traits,}
00088 \textcolor{comment}{ * - the number of scalars that fit into a packet (when vectorization is enabled).}
00089 \textcolor{comment}{ *}
00090 \textcolor{comment}{ * \(\backslash\)sa setCpuCacheSizes */}
00091 
00092 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{int} KcFactor, \textcolor{keyword}{typename} Index>
00093 \textcolor{keywordtype}{void} evaluateProductBlockingSizesHeuristic(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& k, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& m, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& n, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} num\_threads = 1)
00094 \{
00095   \textcolor{keyword}{typedef} gebp\_traits<LhsScalar,RhsScalar> Traits;
00096 
00097   \textcolor{comment}{// Explanations:}
00098   \textcolor{comment}{// Let's recall that the product algorithms form mc x kc vertical panels A' on the lhs and}
00099   \textcolor{comment}{// kc x nc blocks B' on the rhs. B' has to fit into L2/L3 cache. Moreover, A' is processed}
00100   \textcolor{comment}{// per mr x kc horizontal small panels where mr is the blocking size along the m dimension}
00101   \textcolor{comment}{// at the register level. This small horizontal panel has to stay within L1 cache.}
00102   std::ptrdiff\_t l1, l2, l3;
00103   manage\_caching\_sizes(GetAction, &l1, &l2, &l3);
00104 
00105   \textcolor{keywordflow}{if} (num\_threads > 1) \{
00106     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Traits::ResScalar ResScalar;
00107     \textcolor{keyword}{enum} \{
00108       kdiv = KcFactor * (Traits::mr * \textcolor{keyword}{sizeof}(LhsScalar) + Traits::nr * \textcolor{keyword}{sizeof}(RhsScalar)),
00109       ksub = Traits::mr * Traits::nr * \textcolor{keyword}{sizeof}(ResScalar),
00110       kr = 8,
00111       mr = Traits::mr,
00112       nr = Traits::nr
00113     \};
00114     \textcolor{comment}{// Increasing k gives us more time to prefetch the content of the "C"}
00115     \textcolor{comment}{// registers. However once the latency is hidden there is no point in}
00116     \textcolor{comment}{// increasing the value of k, so we'll cap it at 320 (value determined}
00117     \textcolor{comment}{// experimentally).}
00118     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k\_cache = (numext::mini<Index>)((l1-ksub)/kdiv, 320);
00119     \textcolor{keywordflow}{if} (k\_cache < k) \{
00120       k = k\_cache - (k\_cache % kr);
00121       eigen\_internal\_assert(k > 0);
00122     \}
00123 
00124     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n\_cache = (l2-l1) / (nr * \textcolor{keyword}{sizeof}(RhsScalar) * k);
00125     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} n\_per\_thread = numext::div\_ceil(n, num\_threads);
00126     \textcolor{keywordflow}{if} (n\_cache <= n\_per\_thread) \{
00127       \textcolor{comment}{// Don't exceed the capacity of the l2 cache.}
00128       eigen\_internal\_assert(n\_cache >= static\_cast<Index>(nr));
00129       n = n\_cache - (n\_cache % nr);
00130       eigen\_internal\_assert(n > 0);
00131     \} \textcolor{keywordflow}{else} \{
00132       n = (numext::mini<Index>)(n, (n\_per\_thread + nr - 1) - ((n\_per\_thread + nr - 1) % nr));
00133     \}
00134 
00135     \textcolor{keywordflow}{if} (l3 > l2) \{
00136       \textcolor{comment}{// l3 is shared between all cores, so we'll give each thread its own chunk of l3.}
00137       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_cache = (l3-l2) / (\textcolor{keyword}{sizeof}(LhsScalar) * k * num\_threads);
00138       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_per\_thread = numext::div\_ceil(m, num\_threads);
00139       \textcolor{keywordflow}{if}(m\_cache < m\_per\_thread && m\_cache >= static\_cast<Index>(mr)) \{
00140         m = m\_cache - (m\_cache % mr);
00141         eigen\_internal\_assert(m > 0);
00142       \} \textcolor{keywordflow}{else} \{
00143         m = (numext::mini<Index>)(m, (m\_per\_thread + mr - 1) - ((m\_per\_thread + mr - 1) % mr));
00144       \}
00145     \}
00146   \}
00147   \textcolor{keywordflow}{else} \{
00148     \textcolor{comment}{// In unit tests we do not want to use extra large matrices,}
00149     \textcolor{comment}{// so we reduce the cache size to check the blocking strategy is not flawed}
00150 \textcolor{preprocessor}{#ifdef EIGEN\_DEBUG\_SMALL\_PRODUCT\_BLOCKS}
00151     l1 = 9*1024;
00152     l2 = 32*1024;
00153     l3 = 512*1024;
00154 \textcolor{preprocessor}{#endif}
00155 
00156     \textcolor{comment}{// Early return for small problems because the computation below are time consuming for small problems.}
00157     \textcolor{comment}{// Perhaps it would make more sense to consider k*n*m??}
00158     \textcolor{comment}{// Note that for very tiny problem, this function should be bypassed anyway}
00159     \textcolor{comment}{// because we use the coefficient-based implementation for them.}
00160     \textcolor{keywordflow}{if}((numext::maxi)(k,(numext::maxi)(m,n))<48)
00161       \textcolor{keywordflow}{return};
00162 
00163     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Traits::ResScalar ResScalar;
00164     \textcolor{keyword}{enum} \{
00165       k\_peeling = 8,
00166       k\_div = KcFactor * (Traits::mr * \textcolor{keyword}{sizeof}(LhsScalar) + Traits::nr * \textcolor{keyword}{sizeof}(RhsScalar)),
00167       k\_sub = Traits::mr * Traits::nr * \textcolor{keyword}{sizeof}(ResScalar)
00168     \};
00169 
00170     \textcolor{comment}{// ---- 1st level of blocking on L1, yields kc ----}
00171 
00172     \textcolor{comment}{// Blocking on the third dimension (i.e., k) is chosen so that an horizontal panel}
00173     \textcolor{comment}{// of size mr x kc of the lhs plus a vertical panel of kc x nr of the rhs both fits within L1 cache.}
00174     \textcolor{comment}{// We also include a register-level block of the result (mx x nr).}
00175     \textcolor{comment}{// (In an ideal world only the lhs panel would stay in L1)}
00176     \textcolor{comment}{// Moreover, kc has to be a multiple of 8 to be compatible with loop peeling, leading to a maximum
       blocking size of:}
00177     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} max\_kc = numext::maxi<Index>(((l1-k\_sub)/k\_div) & (~(k\_peeling-1)),1);
00178     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} old\_k = k;
00179     \textcolor{keywordflow}{if}(k>max\_kc)
00180     \{
00181       \textcolor{comment}{// We are really blocking on the third dimension:}
00182       \textcolor{comment}{// -> reduce blocking size to make sure the last block is as large as possible}
00183       \textcolor{comment}{//    while keeping the same number of sweeps over the result.}
00184       k = (k%max\_kc)==0 ? max\_kc
00185                         : max\_kc - k\_peeling * ((max\_kc-1-(k%max\_kc))/(k\_peeling*(k/max\_kc+1)));
00186 
00187       eigen\_internal\_assert(((old\_k/k) == (old\_k/max\_kc)) && \textcolor{stringliteral}{"the number of sweeps has to remain the same"})
      ;
00188     \}
00189 
00190     \textcolor{comment}{// ---- 2nd level of blocking on max(L2,L3), yields nc ----}
00191 
00192     \textcolor{comment}{// TODO find a reliable way to get the actual amount of cache per core to use for 2nd level blocking,
       that is:}
00193     \textcolor{comment}{//      actual\_l2 = max(l2, l3/nb\_core\_sharing\_l3)}
00194     \textcolor{comment}{// The number below is quite conservative: it is better to underestimate the cache size rather than
       overestimating it)}
00195     \textcolor{comment}{// For instance, it corresponds to 6MB of L3 shared among 4 cores.}
00196 \textcolor{preprocessor}{    #ifdef EIGEN\_DEBUG\_SMALL\_PRODUCT\_BLOCKS}
00197     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_l2 = l3;
00198 \textcolor{preprocessor}{    #else}
00199     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_l2 = 1572864; \textcolor{comment}{// == 1.5 MB}
00200 \textcolor{preprocessor}{    #endif}
00201 
00202     \textcolor{comment}{// Here, nc is chosen such that a block of kc x nc of the rhs fit within half of L2.}
00203     \textcolor{comment}{// The second half is implicitly reserved to access the result and lhs coefficients.}
00204     \textcolor{comment}{// When k<max\_kc, then nc can arbitrarily growth. In practice, it seems to be fruitful}
00205     \textcolor{comment}{// to limit this growth: we bound nc to growth by a factor x1.5.}
00206     \textcolor{comment}{// However, if the entire lhs block fit within L1, then we are not going to block on the rows at all,}
00207     \textcolor{comment}{// and it becomes fruitful to keep the packed rhs blocks in L1 if there is enough remaining space.}
00208     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} max\_nc;
00209     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lhs\_bytes = m * k * \textcolor{keyword}{sizeof}(LhsScalar);
00210     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} remaining\_l1 = l1- k\_sub - lhs\_bytes;
00211     \textcolor{keywordflow}{if}(remaining\_l1 >= \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(Traits::nr*\textcolor{keyword}{sizeof}(RhsScalar))*k)
00212     \{
00213       \textcolor{comment}{// L1 blocking}
00214       max\_nc = remaining\_l1 / (k*\textcolor{keyword}{sizeof}(RhsScalar));
00215     \}
00216     \textcolor{keywordflow}{else}
00217     \{
00218       \textcolor{comment}{// L2 blocking}
00219       max\_nc = (3*actual\_l2)/(2*2*max\_kc*\textcolor{keyword}{sizeof}(RhsScalar));
00220     \}
00221     \textcolor{comment}{// WARNING Below, we assume that Traits::nr is a power of two.}
00222     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nc = numext::mini<Index>(actual\_l2/(2*k*\textcolor{keyword}{sizeof}(RhsScalar)), max\_nc) & (~(Traits::nr-1));
00223     \textcolor{keywordflow}{if}(n>nc)
00224     \{
00225       \textcolor{comment}{// We are really blocking over the columns:}
00226       \textcolor{comment}{// -> reduce blocking size to make sure the last block is as large as possible}
00227       \textcolor{comment}{//    while keeping the same number of sweeps over the packed lhs.}
00228       \textcolor{comment}{//    Here we allow one more sweep if this gives us a perfect match, thus the commented "-1"}
00229       n = (n%nc)==0 ? nc
00230                     : (nc - Traits::nr * ((nc\textcolor{comment}{/*-1*/}-(n%nc))/(Traits::nr*(n/nc+1))));
00231     \}
00232     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(old\_k==k)
00233     \{
00234       \textcolor{comment}{// So far, no blocking at all, i.e., kc==k, and nc==n.}
00235       \textcolor{comment}{// In this case, let's perform a blocking over the rows such that the packed lhs data is kept in
       cache L1/L2}
00236       \textcolor{comment}{// TODO: part of this blocking strategy is now implemented within the kernel itself, so the L1-based
       heuristic here should be obsolete.}
00237       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} problem\_size = k*n*\textcolor{keyword}{sizeof}(LhsScalar);
00238       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_lm = actual\_l2;
00239       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} max\_mc = m;
00240       \textcolor{keywordflow}{if}(problem\_size<=1024)
00241       \{
00242         \textcolor{comment}{// problem is small enough to keep in L1}
00243         \textcolor{comment}{// Let's choose m such that lhs's block fit in 1/3 of L1}
00244         actual\_lm = l1;
00245       \}
00246       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(l3!=0 && problem\_size<=32768)
00247       \{
00248         \textcolor{comment}{// we have both L2 and L3, and problem is small enough to be kept in L2}
00249         \textcolor{comment}{// Let's choose m such that lhs's block fit in 1/3 of L2}
00250         actual\_lm = l2;
00251         max\_mc = (numext::mini<Index>)(576,max\_mc);
00252       \}
00253       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} mc = (numext::mini<Index>)(actual\_lm/(3*k*\textcolor{keyword}{sizeof}(LhsScalar)), max\_mc);
00254       \textcolor{keywordflow}{if} (mc > Traits::mr) mc -= mc % Traits::mr;
00255       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (mc==0) \textcolor{keywordflow}{return};
00256       m = (m%mc)==0 ? mc
00257                     : (mc - Traits::mr * ((mc\textcolor{comment}{/*-1*/}-(m%mc))/(Traits::mr*(m/mc+1))));
00258     \}
00259   \}
00260 \}
00261 
00262 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Index>
00263 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} useSpecificBlockingSizes(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& k, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& m, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& n)
00264 \{
00265 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_SPECIFIC\_BLOCKING\_SIZES}
00266   \textcolor{keywordflow}{if} (EIGEN\_TEST\_SPECIFIC\_BLOCKING\_SIZES) \{
00267     k = numext::mini<Index>(k, EIGEN\_TEST\_SPECIFIC\_BLOCKING\_SIZE\_K);
00268     m = numext::mini<Index>(m, EIGEN\_TEST\_SPECIFIC\_BLOCKING\_SIZE\_M);
00269     n = numext::mini<Index>(n, EIGEN\_TEST\_SPECIFIC\_BLOCKING\_SIZE\_N);
00270     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00271   \}
00272 \textcolor{preprocessor}{#else}
00273   EIGEN\_UNUSED\_VARIABLE(k)
00274   EIGEN\_UNUSED\_VARIABLE(m)
00275   EIGEN\_UNUSED\_VARIABLE(n)
00276 \textcolor{preprocessor}{#endif}
00277   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00278 \}
00279 
00296 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keywordtype}{int} KcFactor, \textcolor{keyword}{typename} Index>
00297 \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a85af7f706f2ecd66aaa5a088fc32cbcc}{computeProductBlockingSizes}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& k, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& m, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& n, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} num\_threads = 1)
00298 \{
00299   \textcolor{keywordflow}{if} (!useSpecificBlockingSizes(k, m, n)) \{
00300     evaluateProductBlockingSizesHeuristic<LhsScalar, RhsScalar, KcFactor, Index>(k, m, n, num\_threads);
00301   \}
00302 \}
00303 
00304 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{typename} Index>
00305 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_1_1internal_a85af7f706f2ecd66aaa5a088fc32cbcc}{computeProductBlockingSizes}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& k, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& m, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}& n, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} num\_threads = 1)
00306 \{
00307   computeProductBlockingSizes<LhsScalar,RhsScalar,1,Index>(k, m, n, num\_threads);
00308 \}
00309 
00310 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_SINGLE\_INSTRUCTION\_CJMADD}
00311 \textcolor{preprocessor}{  #define CJMADD(CJ,A,B,C,T)  C = CJ.pmadd(A,B,C);}
00312 \textcolor{preprocessor}{#else}
00313 
00314   \textcolor{comment}{// FIXME (a bit overkill maybe ?)}
00315 
00316   \textcolor{keyword}{template}<\textcolor{keyword}{typename} CJ, \textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B, \textcolor{keyword}{typename} C, \textcolor{keyword}{typename} T> \textcolor{keyword}{struct }gebp\_madd\_selector \{
00317     EIGEN\_ALWAYS\_INLINE \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} CJ& cj, A& a, B& b, C& c, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& \textcolor{comment}{/*t*/})
00318     \{
00319       c = cj.pmadd(a,b,c);
00320     \}
00321   \};
00322 
00323   \textcolor{keyword}{template}<\textcolor{keyword}{typename} CJ, \textcolor{keyword}{typename} T> \textcolor{keyword}{struct }gebp\_madd\_selector<CJ,\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T},\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T},\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T},\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}> \{
00324     EIGEN\_ALWAYS\_INLINE \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} CJ& cj, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& a, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& b, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& c, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& t)
00325     \{
00326       t = b; t = cj.pmul(a,t); c = padd(c,t);
00327     \}
00328   \};
00329 
00330   \textcolor{keyword}{template}<\textcolor{keyword}{typename} CJ, \textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B, \textcolor{keyword}{typename} C, \textcolor{keyword}{typename} T>
00331   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} gebp\_madd(\textcolor{keyword}{const} CJ& cj, A& a, B& b, C& c, \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& t)
00332   \{
00333     gebp\_madd\_selector<CJ,A,B,C,T>::run(cj,a,b,c,t);
00334   \}
00335 
00336 \textcolor{preprocessor}{  #define CJMADD(CJ,A,B,C,T)  gebp\_madd(CJ,A,B,C,T);}
00337 \textcolor{comment}{//   #define CJMADD(CJ,A,B,C,T)  T = B; T = CJ.pmul(A,T); C = padd(C,T);}
00338 \textcolor{preprocessor}{#endif}
00339 
00340 \textcolor{comment}{/* Vectorization logic}
00341 \textcolor{comment}{ *  real*real: unpack rhs to constant packets, ...}
00342 \textcolor{comment}{ * }
00343 \textcolor{comment}{ *  cd*cd : unpack rhs to (b\_r,b\_r), (b\_i,b\_i), mul to get (a\_r b\_r,a\_i b\_r) (a\_r b\_i,a\_i b\_i),}
00344 \textcolor{comment}{ *          storing each res packet into two packets (2x2),}
00345 \textcolor{comment}{ *          at the end combine them: swap the second and addsub them }
00346 \textcolor{comment}{ *  cf*cf : same but with 2x4 blocks}
00347 \textcolor{comment}{ *  cplx*real : unpack rhs to constant packets, ...}
00348 \textcolor{comment}{ *  real*cplx : load lhs as (a0,a0,a1,a1), and mul as usual}
00349 \textcolor{comment}{ */}
00350 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_LhsScalar, \textcolor{keyword}{typename} \_RhsScalar, \textcolor{keywordtype}{bool} \_ConjLhs, \textcolor{keywordtype}{bool} \_ConjRhs>
00351 \textcolor{keyword}{class }gebp\_traits
00352 \{
00353 \textcolor{keyword}{public}:
00354   \textcolor{keyword}{typedef} \_LhsScalar LhsScalar;
00355   \textcolor{keyword}{typedef} \_RhsScalar RhsScalar;
00356   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;
00357 
00358   \textcolor{keyword}{enum} \{
00359     ConjLhs = \_ConjLhs,
00360     ConjRhs = \_ConjRhs,
00361     Vectorizable = packet\_traits<LhsScalar>::Vectorizable && packet\_traits<RhsScalar>::Vectorizable,
00362     LhsPacketSize = Vectorizable ? packet\_traits<LhsScalar>::size : 1,
00363     RhsPacketSize = Vectorizable ? packet\_traits<RhsScalar>::size : 1,
00364     ResPacketSize = Vectorizable ? packet\_traits<ResScalar>::size : 1,
00365     
00366     NumberOfRegisters = EIGEN\_ARCH\_DEFAULT\_NUMBER\_OF\_REGISTERS,
00367 
00368     \textcolor{comment}{// register block size along the N direction must be 1 or 4}
00369     nr = 4,
00370 
00371     \textcolor{comment}{// register block size along the M direction (currently, this one cannot be modified)}
00372     default\_mr = (EIGEN\_PLAIN\_ENUM\_MIN(16,NumberOfRegisters)/2/nr)*LhsPacketSize,
00373 #\textcolor{keywordflow}{if} defined(EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD) && !defined(EIGEN\_VECTORIZE\_ALTIVEC) && !defined(
      EIGEN\_VECTORIZE\_VSX)
00374     \textcolor{comment}{// we assume 16 registers}
00375     \textcolor{comment}{// See bug 992, if the scalar type is not vectorizable but that EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD is
       defined,}
00376     \textcolor{comment}{// then using 3*LhsPacketSize triggers non-implemented paths in syrk.}
00377     mr = Vectorizable ? 3*LhsPacketSize : default\_mr,
00378 \textcolor{preprocessor}{#else}
00379     mr = default\_mr,
00380 \textcolor{preprocessor}{#endif}
00381     
00382     LhsProgress = LhsPacketSize,
00383     RhsProgress = 1
00384   \};
00385 
00386   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<LhsScalar>::type  \_LhsPacket;
00387   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<RhsScalar>::type  \_RhsPacket;
00388   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<ResScalar>::type  \_ResPacket;
00389 
00390   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,\_LhsPacket,LhsScalar>::type LhsPacket;
00391   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,\_RhsPacket,RhsScalar>::type RhsPacket;
00392   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,\_ResPacket,ResScalar>::type ResPacket;
00393 
00394   \textcolor{keyword}{typedef} ResPacket AccPacket;
00395   
00396   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} initAcc(AccPacket& p)
00397   \{
00398     p = pset1<ResPacket>(ResScalar(0));
00399   \}
00400   
00401   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} broadcastRhs(\textcolor{keyword}{const} RhsScalar* b, RhsPacket& b0, RhsPacket& b1, RhsPacket& b2, 
      RhsPacket& b3)
00402   \{
00403     pbroadcast4(b, b0, b1, b2, b3);
00404   \}
00405   
00406 \textcolor{comment}{//   EIGEN\_STRONG\_INLINE void broadcastRhs(const RhsScalar* b, RhsPacket& b0, RhsPacket& b1)}
00407 \textcolor{comment}{//   \{}
00408 \textcolor{comment}{//     pbroadcast2(b, b0, b1);}
00409 \textcolor{comment}{//   \}}
00410   
00411   \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsPacketType>
00412   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadRhs(\textcolor{keyword}{const} RhsScalar* b, RhsPacketType& dest)\textcolor{keyword}{ const}
00413 \textcolor{keyword}{  }\{
00414     dest = pset1<RhsPacketType>(*b);
00415   \}
00416   
00417   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadRhsQuad(\textcolor{keyword}{const} RhsScalar* b, RhsPacket& dest)\textcolor{keyword}{ const}
00418 \textcolor{keyword}{  }\{
00419     dest = ploadquad<RhsPacket>(b);
00420   \}
00421 
00422   \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsPacketType>
00423   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadLhs(\textcolor{keyword}{const} LhsScalar* a, LhsPacketType& dest)\textcolor{keyword}{ const}
00424 \textcolor{keyword}{  }\{
00425     dest = pload<LhsPacketType>(a);
00426   \}
00427 
00428   \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsPacketType>
00429   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadLhsUnaligned(\textcolor{keyword}{const} LhsScalar* a, LhsPacketType& dest)\textcolor{keyword}{ const}
00430 \textcolor{keyword}{  }\{
00431     dest = ploadu<LhsPacketType>(a);
00432   \}
00433 
00434   \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsPacketType, \textcolor{keyword}{typename} RhsPacketType, \textcolor{keyword}{typename} AccPacketType>
00435   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} madd(\textcolor{keyword}{const} LhsPacketType& a, \textcolor{keyword}{const} RhsPacketType& b, AccPacketType& c, 
      AccPacketType& tmp)\textcolor{keyword}{ const}
00436 \textcolor{keyword}{  }\{
00437     conj\_helper<LhsPacketType,RhsPacketType,ConjLhs,ConjRhs> cj;
00438     \textcolor{comment}{// It would be a lot cleaner to call pmadd all the time. Unfortunately if we}
00439     \textcolor{comment}{// let gcc allocate the register in which to store the result of the pmul}
00440     \textcolor{comment}{// (in the case where there is no FMA) gcc fails to figure out how to avoid}
00441     \textcolor{comment}{// spilling register.}
00442 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD}
00443     EIGEN\_UNUSED\_VARIABLE(tmp);
00444     c = cj.pmadd(a,b,c);
00445 \textcolor{preprocessor}{#else}
00446     tmp = b; tmp = cj.pmul(a,tmp); c = padd(c,tmp);
00447 \textcolor{preprocessor}{#endif}
00448   \}
00449 
00450   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} acc(\textcolor{keyword}{const} AccPacket& c, \textcolor{keyword}{const} ResPacket& alpha, ResPacket& r)\textcolor{keyword}{ const}
00451 \textcolor{keyword}{  }\{
00452     r = pmadd(c,alpha,r);
00453   \}
00454   
00455   \textcolor{keyword}{template}<\textcolor{keyword}{typename} ResPacketHalf>
00456   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} acc(\textcolor{keyword}{const} ResPacketHalf& c, \textcolor{keyword}{const} ResPacketHalf& alpha, ResPacketHalf& r)\textcolor{keyword}{ const}
00457 \textcolor{keyword}{  }\{
00458     r = pmadd(c,alpha,r);
00459   \}
00460 
00461 \};
00462 
00463 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar, \textcolor{keywordtype}{bool} \_ConjLhs>
00464 \textcolor{keyword}{class }gebp\_traits<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<RealScalar>, RealScalar, \_ConjLhs, false>
00465 \{
00466 \textcolor{keyword}{public}:
00467   \textcolor{keyword}{typedef} std::complex<RealScalar> LhsScalar;
00468   \textcolor{keyword}{typedef} RealScalar RhsScalar;
00469   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;
00470 
00471   \textcolor{keyword}{enum} \{
00472     ConjLhs = \_ConjLhs,
00473     ConjRhs = \textcolor{keyword}{false},
00474     Vectorizable = packet\_traits<LhsScalar>::Vectorizable && packet\_traits<RhsScalar>::Vectorizable,
00475     LhsPacketSize = Vectorizable ? packet\_traits<LhsScalar>::size : 1,
00476     RhsPacketSize = Vectorizable ? packet\_traits<RhsScalar>::size : 1,
00477     ResPacketSize = Vectorizable ? packet\_traits<ResScalar>::size : 1,
00478     
00479     NumberOfRegisters = EIGEN\_ARCH\_DEFAULT\_NUMBER\_OF\_REGISTERS,
00480     nr = 4,
00481 \textcolor{preprocessor}{#if defined(EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD) && !defined(EIGEN\_VECTORIZE\_ALTIVEC) &&
       !defined(EIGEN\_VECTORIZE\_VSX)}
00482     \textcolor{comment}{// we assume 16 registers}
00483     mr = 3*LhsPacketSize,
00484 \textcolor{preprocessor}{#else}
00485     mr = (EIGEN\_PLAIN\_ENUM\_MIN(16,NumberOfRegisters)/2/nr)*LhsPacketSize,
00486 #endif
00487 
00488     LhsProgress = LhsPacketSize,
00489     RhsProgress = 1
00490   \};
00491 
00492   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<LhsScalar>::type  \_LhsPacket;
00493   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<RhsScalar>::type  \_RhsPacket;
00494   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<ResScalar>::type  \_ResPacket;
00495 
00496   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,\_LhsPacket,LhsScalar>::type LhsPacket;
00497   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,\_RhsPacket,RhsScalar>::type RhsPacket;
00498   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,\_ResPacket,ResScalar>::type ResPacket;
00499 
00500   \textcolor{keyword}{typedef} ResPacket AccPacket;
00501 
00502   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} initAcc(AccPacket& p)
00503   \{
00504     p = pset1<ResPacket>(ResScalar(0));
00505   \}
00506 
00507   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadRhs(\textcolor{keyword}{const} RhsScalar* b, RhsPacket& dest)\textcolor{keyword}{ const}
00508 \textcolor{keyword}{  }\{
00509     dest = pset1<RhsPacket>(*b);
00510   \}
00511   
00512   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadRhsQuad(\textcolor{keyword}{const} RhsScalar* b, RhsPacket& dest)\textcolor{keyword}{ const}
00513 \textcolor{keyword}{  }\{
00514     dest = pset1<RhsPacket>(*b);
00515   \}
00516 
00517   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadLhs(\textcolor{keyword}{const} LhsScalar* a, LhsPacket& dest)\textcolor{keyword}{ const}
00518 \textcolor{keyword}{  }\{
00519     dest = pload<LhsPacket>(a);
00520   \}
00521 
00522   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadLhsUnaligned(\textcolor{keyword}{const} LhsScalar* a, LhsPacket& dest)\textcolor{keyword}{ const}
00523 \textcolor{keyword}{  }\{
00524     dest = ploadu<LhsPacket>(a);
00525   \}
00526 
00527   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} broadcastRhs(\textcolor{keyword}{const} RhsScalar* b, RhsPacket& b0, RhsPacket& b1, RhsPacket& b2, 
      RhsPacket& b3)
00528   \{
00529     pbroadcast4(b, b0, b1, b2, b3);
00530   \}
00531   
00532 \textcolor{comment}{//   EIGEN\_STRONG\_INLINE void broadcastRhs(const RhsScalar* b, RhsPacket& b0, RhsPacket& b1)}
00533 \textcolor{comment}{//   \{}
00534 \textcolor{comment}{//     pbroadcast2(b, b0, b1);}
00535 \textcolor{comment}{//   \}}
00536 
00537   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} madd(\textcolor{keyword}{const} LhsPacket& a, \textcolor{keyword}{const} RhsPacket& b, AccPacket& c, RhsPacket& tmp)\textcolor{keyword}{ const}
00538 \textcolor{keyword}{  }\{
00539     madd\_impl(a, b, c, tmp, \textcolor{keyword}{typename} conditional<Vectorizable,true\_type,false\_type>::type());
00540   \}
00541 
00542   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} madd\_impl(\textcolor{keyword}{const} LhsPacket& a, \textcolor{keyword}{const} RhsPacket& b, AccPacket& c, RhsPacket& tmp, \textcolor{keyword}{
      const} true\_type&)\textcolor{keyword}{ const}
00543 \textcolor{keyword}{  }\{
00544 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD}
00545     EIGEN\_UNUSED\_VARIABLE(tmp);
00546     c.v = pmadd(a.v,b,c.v);
00547 \textcolor{preprocessor}{#else}
00548     tmp = b; tmp = pmul(a.v,tmp); c.v = padd(c.v,tmp);
00549 \textcolor{preprocessor}{#endif}
00550   \}
00551 
00552   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} madd\_impl(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b, ResScalar& c, RhsScalar& \textcolor{comment}{/*tmp
      */}, \textcolor{keyword}{const} false\_type&)\textcolor{keyword}{ const}
00553 \textcolor{keyword}{  }\{
00554     c += a * b;
00555   \}
00556 
00557   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} acc(\textcolor{keyword}{const} AccPacket& c, \textcolor{keyword}{const} ResPacket& alpha, ResPacket& r)\textcolor{keyword}{ const}
00558 \textcolor{keyword}{  }\{
00559     r = cj.pmadd(c,alpha,r);
00560   \}
00561 
00562 \textcolor{keyword}{protected}:
00563   conj\_helper<ResPacket,ResPacket,ConjLhs,false> cj;
00564 \};
00565 
00566 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00567 \textcolor{keyword}{struct }DoublePacket
00568 \{
00569   Packet first;
00570   Packet second;
00571 \};
00572 
00573 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00574 DoublePacket<Packet> padd(\textcolor{keyword}{const} DoublePacket<Packet> &a, \textcolor{keyword}{const} DoublePacket<Packet> &b)
00575 \{
00576   DoublePacket<Packet> res;
00577   res.first  = padd(a.first, b.first);
00578   res.second = padd(a.second,b.second);
00579   \textcolor{keywordflow}{return} res;
00580 \}
00581 
00582 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet>
00583 \textcolor{keyword}{const} DoublePacket<Packet>& predux\_downto4(\textcolor{keyword}{const} DoublePacket<Packet> &a)
00584 \{
00585   \textcolor{keywordflow}{return} a;
00586 \}
00587 
00588 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Packet> \textcolor{keyword}{struct }unpacket\_traits<DoublePacket<Packet> > \{ \textcolor{keyword}{typedef} DoublePacket<Packet> half
      ; \};
00589 \textcolor{comment}{// template<typename Packet>}
00590 \textcolor{comment}{// DoublePacket<Packet> pmadd(const DoublePacket<Packet> &a, const DoublePacket<Packet> &b)}
00591 \textcolor{comment}{// \{}
00592 \textcolor{comment}{//   DoublePacket<Packet> res;}
00593 \textcolor{comment}{//   res.first  = padd(a.first, b.first);}
00594 \textcolor{comment}{//   res.second = padd(a.second,b.second);}
00595 \textcolor{comment}{//   return res;}
00596 \textcolor{comment}{// \}}
00597 
00598 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar, \textcolor{keywordtype}{bool} \_ConjLhs, \textcolor{keywordtype}{bool} \_ConjRhs>
00599 \textcolor{keyword}{class }gebp\_traits<\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<RealScalar>, std::complex<RealScalar>, \_ConjLhs, \_ConjRhs >
00600 \{
00601 \textcolor{keyword}{public}:
00602   \textcolor{keyword}{typedef} std::complex<RealScalar>  Scalar;
00603   \textcolor{keyword}{typedef} std::complex<RealScalar>  LhsScalar;
00604   \textcolor{keyword}{typedef} std::complex<RealScalar>  RhsScalar;
00605   \textcolor{keyword}{typedef} std::complex<RealScalar>  ResScalar;
00606   
00607   \textcolor{keyword}{enum} \{
00608     ConjLhs = \_ConjLhs,
00609     ConjRhs = \_ConjRhs,
00610     Vectorizable = packet\_traits<RealScalar>::Vectorizable
00611                 && packet\_traits<Scalar>::Vectorizable,
00612     RealPacketSize  = Vectorizable ? packet\_traits<RealScalar>::size : 1,
00613     ResPacketSize   = Vectorizable ? packet\_traits<ResScalar>::size : 1,
00614     LhsPacketSize = Vectorizable ? packet\_traits<LhsScalar>::size : 1,
00615     RhsPacketSize = Vectorizable ? packet\_traits<RhsScalar>::size : 1,
00616 
00617     \textcolor{comment}{// FIXME: should depend on NumberOfRegisters}
00618     nr = 4,
00619     mr = ResPacketSize,
00620 
00621     LhsProgress = ResPacketSize,
00622     RhsProgress = 1
00623   \};
00624   
00625   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<RealScalar>::type RealPacket;
00626   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::type     ScalarPacket;
00627   \textcolor{keyword}{typedef} DoublePacket<RealPacket> DoublePacketType;
00628 
00629   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,RealPacket,  Scalar>::type LhsPacket;
00630   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,DoublePacketType,Scalar>::type RhsPacket;
00631   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,ScalarPacket,Scalar>::type ResPacket;
00632   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,DoublePacketType,Scalar>::type AccPacket;
00633   
00634   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} initAcc(Scalar& p) \{ p = Scalar(0); \}
00635 
00636   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} initAcc(DoublePacketType& p)
00637   \{
00638     p.first   = pset1<RealPacket>(RealScalar(0));
00639     p.second  = pset1<RealPacket>(RealScalar(0));
00640   \}
00641 
00642   \textcolor{comment}{// Scalar path}
00643   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadRhs(\textcolor{keyword}{const} RhsScalar* b, ResPacket& dest)\textcolor{keyword}{ const}
00644 \textcolor{keyword}{  }\{
00645     dest = pset1<ResPacket>(*b);
00646   \}
00647 
00648   \textcolor{comment}{// Vectorized path}
00649   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadRhs(\textcolor{keyword}{const} RhsScalar* b, DoublePacketType& dest)\textcolor{keyword}{ const}
00650 \textcolor{keyword}{  }\{
00651     dest.first  = pset1<RealPacket>(real(*b));
00652     dest.second = pset1<RealPacket>(imag(*b));
00653   \}
00654   
00655   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadRhsQuad(\textcolor{keyword}{const} RhsScalar* b, ResPacket& dest)\textcolor{keyword}{ const}
00656 \textcolor{keyword}{  }\{
00657     loadRhs(b,dest);
00658   \}
00659   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadRhsQuad(\textcolor{keyword}{const} RhsScalar* b, DoublePacketType& dest)\textcolor{keyword}{ const}
00660 \textcolor{keyword}{  }\{
00661     eigen\_internal\_assert(unpacket\_traits<ScalarPacket>::size<=4);
00662     loadRhs(b,dest);
00663   \}
00664   
00665   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} broadcastRhs(\textcolor{keyword}{const} RhsScalar* b, RhsPacket& b0, RhsPacket& b1, RhsPacket& b2, 
      RhsPacket& b3)
00666   \{
00667     \textcolor{comment}{// FIXME not sure that's the best way to implement it!}
00668     loadRhs(b+0, b0);
00669     loadRhs(b+1, b1);
00670     loadRhs(b+2, b2);
00671     loadRhs(b+3, b3);
00672   \}
00673   
00674   \textcolor{comment}{// Vectorized path}
00675   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} broadcastRhs(\textcolor{keyword}{const} RhsScalar* b, DoublePacketType& b0, DoublePacketType& b1)
00676   \{
00677     \textcolor{comment}{// FIXME not sure that's the best way to implement it!}
00678     loadRhs(b+0, b0);
00679     loadRhs(b+1, b1);
00680   \}
00681   
00682   \textcolor{comment}{// Scalar path}
00683   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} broadcastRhs(\textcolor{keyword}{const} RhsScalar* b, RhsScalar& b0, RhsScalar& b1)
00684   \{
00685     \textcolor{comment}{// FIXME not sure that's the best way to implement it!}
00686     loadRhs(b+0, b0);
00687     loadRhs(b+1, b1);
00688   \}
00689 
00690   \textcolor{comment}{// nothing special here}
00691   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadLhs(\textcolor{keyword}{const} LhsScalar* a, LhsPacket& dest)\textcolor{keyword}{ const}
00692 \textcolor{keyword}{  }\{
00693     dest = pload<LhsPacket>((\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<LhsPacket>::type*)(a));
00694   \}
00695 
00696   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadLhsUnaligned(\textcolor{keyword}{const} LhsScalar* a, LhsPacket& dest)\textcolor{keyword}{ const}
00697 \textcolor{keyword}{  }\{
00698     dest = ploadu<LhsPacket>((\textcolor{keyword}{const} \textcolor{keyword}{typename} unpacket\_traits<LhsPacket>::type*)(a));
00699   \}
00700 
00701   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} madd(\textcolor{keyword}{const} LhsPacket& a, \textcolor{keyword}{const} RhsPacket& b, DoublePacketType& c, RhsPacket& \textcolor{comment}{/*
      tmp*/})\textcolor{keyword}{ const}
00702 \textcolor{keyword}{  }\{
00703     c.first   = padd(pmul(a,b.first), c.first);
00704     c.second  = padd(pmul(a,b.second),c.second);
00705   \}
00706 
00707   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} madd(\textcolor{keyword}{const} LhsPacket& a, \textcolor{keyword}{const} RhsPacket& b, ResPacket& c, RhsPacket& \textcolor{comment}{/*tmp*/})\textcolor{keyword}{
       const}
00708 \textcolor{keyword}{  }\{
00709     c = cj.pmadd(a,b,c);
00710   \}
00711   
00712   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} acc(\textcolor{keyword}{const} Scalar& c, \textcolor{keyword}{const} Scalar& alpha, Scalar& r)\textcolor{keyword}{ const }\{ r += alpha * c; \}
00713   
00714   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} acc(\textcolor{keyword}{const} DoublePacketType& c, \textcolor{keyword}{const} ResPacket& alpha, ResPacket& r)\textcolor{keyword}{ const}
00715 \textcolor{keyword}{  }\{
00716     \textcolor{comment}{// assemble c}
00717     ResPacket tmp;
00718     \textcolor{keywordflow}{if}((!ConjLhs)&&(!ConjRhs))
00719     \{
00720       tmp = pcplxflip(pconj(ResPacket(c.second)));
00721       tmp = padd(ResPacket(c.first),tmp);
00722     \}
00723     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((!ConjLhs)&&(ConjRhs))
00724     \{
00725       tmp = pconj(pcplxflip(ResPacket(c.second)));
00726       tmp = padd(ResPacket(c.first),tmp);
00727     \}
00728     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((ConjLhs)&&(!ConjRhs))
00729     \{
00730       tmp = pcplxflip(ResPacket(c.second));
00731       tmp = padd(pconj(ResPacket(c.first)),tmp);
00732     \}
00733     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((ConjLhs)&&(ConjRhs))
00734     \{
00735       tmp = pcplxflip(ResPacket(c.second));
00736       tmp = psub(pconj(ResPacket(c.first)),tmp);
00737     \}
00738     
00739     r = pmadd(tmp,alpha,r);
00740   \}
00741 
00742 \textcolor{keyword}{protected}:
00743   conj\_helper<LhsScalar,RhsScalar,ConjLhs,ConjRhs> cj;
00744 \};
00745 
00746 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealScalar, \textcolor{keywordtype}{bool} \_ConjRhs>
00747 \textcolor{keyword}{class }gebp\_traits<RealScalar, \hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<RealScalar>, false, \_ConjRhs >
00748 \{
00749 \textcolor{keyword}{public}:
00750   \textcolor{keyword}{typedef} std::complex<RealScalar>  Scalar;
00751   \textcolor{keyword}{typedef} RealScalar  LhsScalar;
00752   \textcolor{keyword}{typedef} Scalar      RhsScalar;
00753   \textcolor{keyword}{typedef} Scalar      ResScalar;
00754 
00755   \textcolor{keyword}{enum} \{
00756     ConjLhs = \textcolor{keyword}{false},
00757     ConjRhs = \_ConjRhs,
00758     Vectorizable = packet\_traits<RealScalar>::Vectorizable
00759                 && packet\_traits<Scalar>::Vectorizable,
00760     LhsPacketSize = Vectorizable ? packet\_traits<LhsScalar>::size : 1,
00761     RhsPacketSize = Vectorizable ? packet\_traits<RhsScalar>::size : 1,
00762     ResPacketSize = Vectorizable ? packet\_traits<ResScalar>::size : 1,
00763     
00764     NumberOfRegisters = EIGEN\_ARCH\_DEFAULT\_NUMBER\_OF\_REGISTERS,
00765     \textcolor{comment}{// FIXME: should depend on NumberOfRegisters}
00766     nr = 4,
00767     mr = (EIGEN\_PLAIN\_ENUM\_MIN(16,NumberOfRegisters)/2/nr)*ResPacketSize,
00768 
00769     LhsProgress = ResPacketSize,
00770     RhsProgress = 1
00771   \};
00772 
00773   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<LhsScalar>::type  \_LhsPacket;
00774   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<RhsScalar>::type  \_RhsPacket;
00775   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<ResScalar>::type  \_ResPacket;
00776 
00777   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,\_LhsPacket,LhsScalar>::type LhsPacket;
00778   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,\_RhsPacket,RhsScalar>::type RhsPacket;
00779   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<Vectorizable,\_ResPacket,ResScalar>::type ResPacket;
00780 
00781   \textcolor{keyword}{typedef} ResPacket AccPacket;
00782 
00783   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} initAcc(AccPacket& p)
00784   \{
00785     p = pset1<ResPacket>(ResScalar(0));
00786   \}
00787 
00788   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadRhs(\textcolor{keyword}{const} RhsScalar* b, RhsPacket& dest)\textcolor{keyword}{ const}
00789 \textcolor{keyword}{  }\{
00790     dest = pset1<RhsPacket>(*b);
00791   \}
00792   
00793   \textcolor{keywordtype}{void} broadcastRhs(\textcolor{keyword}{const} RhsScalar* b, RhsPacket& b0, RhsPacket& b1, RhsPacket& b2, RhsPacket& b3)
00794   \{
00795     pbroadcast4(b, b0, b1, b2, b3);
00796   \}
00797   
00798 \textcolor{comment}{//   EIGEN\_STRONG\_INLINE void broadcastRhs(const RhsScalar* b, RhsPacket& b0, RhsPacket& b1)}
00799 \textcolor{comment}{//   \{}
00800 \textcolor{comment}{//     // FIXME not sure that's the best way to implement it!}
00801 \textcolor{comment}{//     b0 = pload1<RhsPacket>(b+0);}
00802 \textcolor{comment}{//     b1 = pload1<RhsPacket>(b+1);}
00803 \textcolor{comment}{//   \}}
00804 
00805   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadLhs(\textcolor{keyword}{const} LhsScalar* a, LhsPacket& dest)\textcolor{keyword}{ const}
00806 \textcolor{keyword}{  }\{
00807     dest = ploaddup<LhsPacket>(a);
00808   \}
00809   
00810   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadRhsQuad(\textcolor{keyword}{const} RhsScalar* b, RhsPacket& dest)\textcolor{keyword}{ const}
00811 \textcolor{keyword}{  }\{
00812     eigen\_internal\_assert(unpacket\_traits<RhsPacket>::size<=4);
00813     loadRhs(b,dest);
00814   \}
00815 
00816   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} loadLhsUnaligned(\textcolor{keyword}{const} LhsScalar* a, LhsPacket& dest)\textcolor{keyword}{ const}
00817 \textcolor{keyword}{  }\{
00818     dest = ploaddup<LhsPacket>(a);
00819   \}
00820 
00821   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} madd(\textcolor{keyword}{const} LhsPacket& a, \textcolor{keyword}{const} RhsPacket& b, AccPacket& c, RhsPacket& tmp)\textcolor{keyword}{ const}
00822 \textcolor{keyword}{  }\{
00823     madd\_impl(a, b, c, tmp, \textcolor{keyword}{typename} conditional<Vectorizable,true\_type,false\_type>::type());
00824   \}
00825 
00826   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} madd\_impl(\textcolor{keyword}{const} LhsPacket& a, \textcolor{keyword}{const} RhsPacket& b, AccPacket& c, RhsPacket& tmp, \textcolor{keyword}{
      const} true\_type&)\textcolor{keyword}{ const}
00827 \textcolor{keyword}{  }\{
00828 \textcolor{preprocessor}{#ifdef EIGEN\_HAS\_SINGLE\_INSTRUCTION\_MADD}
00829     EIGEN\_UNUSED\_VARIABLE(tmp);
00830     c.v = pmadd(a,b.v,c.v);
00831 \textcolor{preprocessor}{#else}
00832     tmp = b; tmp.v = pmul(a,tmp.v); c = padd(c,tmp);
00833 \textcolor{preprocessor}{#endif}
00834     
00835   \}
00836 
00837   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} madd\_impl(\textcolor{keyword}{const} LhsScalar& a, \textcolor{keyword}{const} RhsScalar& b, ResScalar& c, RhsScalar& \textcolor{comment}{/*tmp
      */}, \textcolor{keyword}{const} false\_type&)\textcolor{keyword}{ const}
00838 \textcolor{keyword}{  }\{
00839     c += a * b;
00840   \}
00841 
00842   EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} acc(\textcolor{keyword}{const} AccPacket& c, \textcolor{keyword}{const} ResPacket& alpha, ResPacket& r)\textcolor{keyword}{ const}
00843 \textcolor{keyword}{  }\{
00844     r = cj.pmadd(alpha,c,r);
00845   \}
00846 
00847 \textcolor{keyword}{protected}:
00848   conj\_helper<ResPacket,ResPacket,false,ConjRhs> cj;
00849 \};
00850 
00851 \textcolor{comment}{/* optimized GEneral packed Block * packed Panel product kernel}
00852 \textcolor{comment}{ *}
00853 \textcolor{comment}{ * Mixing type logic: C += A * B}
00854 \textcolor{comment}{ *  |  A  |  B  | comments}
00855 \textcolor{comment}{ *  |real |cplx | no vectorization yet, would require to pack A with duplication}
00856 \textcolor{comment}{ *  |cplx |real | easy vectorization}
00857 \textcolor{comment}{ */}
00858 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} mr, \textcolor{keywordtype}{int} nr, \textcolor{keywordtype}{bool} 
      ConjugateLhs, \textcolor{keywordtype}{bool} ConjugateRhs>
00859 \textcolor{keyword}{struct }gebp\_kernel
00860 \{
00861   \textcolor{keyword}{typedef} gebp\_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> Traits;
00862   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Traits::ResScalar ResScalar;
00863   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Traits::LhsPacket LhsPacket;
00864   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Traits::RhsPacket RhsPacket;
00865   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Traits::ResPacket ResPacket;
00866   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Traits::AccPacket AccPacket;
00867 
00868   \textcolor{keyword}{typedef} gebp\_traits<RhsScalar,LhsScalar,ConjugateRhs,ConjugateLhs> SwappedTraits;
00869   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SwappedTraits::ResScalar SResScalar;
00870   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SwappedTraits::LhsPacket SLhsPacket;
00871   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SwappedTraits::RhsPacket SRhsPacket;
00872   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SwappedTraits::ResPacket SResPacket;
00873   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SwappedTraits::AccPacket SAccPacket;
00874 
00875   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DataMapper::LinearMapper LinearMapper;
00876 
00877   \textcolor{keyword}{enum} \{
00878     Vectorizable  = Traits::Vectorizable,
00879     LhsProgress   = Traits::LhsProgress,
00880     RhsProgress   = Traits::RhsProgress,
00881     ResPacketSize = Traits::ResPacketSize
00882   \};
00883 
00884   EIGEN\_DONT\_INLINE
00885   \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} DataMapper& res, \textcolor{keyword}{const} LhsScalar* blockA, \textcolor{keyword}{const} RhsScalar* blockB,
00886                   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, ResScalar alpha,
00887                   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} strideA=-1, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} strideB=-1, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offsetA=0, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offsetB=0);
00888 \};
00889 
00890 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsScalar, \textcolor{keyword}{typename} RhsScalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} mr, \textcolor{keywordtype}{int} nr, \textcolor{keywordtype}{bool} 
      ConjugateLhs, \textcolor{keywordtype}{bool} ConjugateRhs>
00891 EIGEN\_DONT\_INLINE
00892 \textcolor{keywordtype}{void} gebp\_kernel<LhsScalar,RhsScalar,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs>
00893   ::operator()(\textcolor{keyword}{const} DataMapper& res, \textcolor{keyword}{const} LhsScalar* blockA, \textcolor{keyword}{const} RhsScalar* blockB,
00894                \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, ResScalar alpha,
00895                \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} strideA, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} strideB, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offsetA, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offsetB)
00896   \{
00897     Traits traits;
00898     SwappedTraits straits;
00899     
00900     \textcolor{keywordflow}{if}(strideA==-1) strideA = depth;
00901     \textcolor{keywordflow}{if}(strideB==-1) strideB = depth;
00902     conj\_helper<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> cj;
00903     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} packet\_cols4 = nr>=4 ? (cols/4) * 4 : 0;
00904     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeled\_mc3 = mr>=3*Traits::LhsProgress ? (rows/(3*LhsProgress))*(3*LhsProgress) : 0;
00905     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeled\_mc2 = mr>=2*Traits::LhsProgress ? peeled\_mc3+((rows-peeled\_mc3)/(2*LhsProgress)
      )*(2*LhsProgress) : 0;
00906     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeled\_mc1 = mr>=1*Traits::LhsProgress ? (rows/(1*LhsProgress))*(1*LhsProgress) : 0;
00907     \textcolor{keyword}{enum} \{ pk = 8 \}; \textcolor{comment}{// NOTE Such a large peeling factor is important for large matrices (~ +5% when >1000
       on Haswell)}
00908     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeled\_kc  = depth & ~(pk-1);
00909     \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} prefetch\_res\_offset = 32/\textcolor{keyword}{sizeof}(ResScalar);    
00910 \textcolor{comment}{//     const Index depth2     = depth & ~1;}
00911 
00912     \textcolor{comment}{//---------- Process 3 * LhsProgress rows at once ----------}
00913     \textcolor{comment}{// This corresponds to 3*LhsProgress x nr register blocks.}
00914     \textcolor{comment}{// Usually, make sense only with FMA}
00915     \textcolor{keywordflow}{if}(mr>=3*Traits::LhsProgress)
00916     \{
00917       \textcolor{comment}{// Here, the general idea is to loop on each largest micro horizontal panel of the lhs
       (3*Traits::LhsProgress x depth)}
00918       \textcolor{comment}{// and on each largest micro vertical panel of the rhs (depth * nr).}
00919       \textcolor{comment}{// Blocking sizes, i.e., 'depth' has been computed so that the micro horizontal panel of the lhs fit
       in L1.}
00920       \textcolor{comment}{// However, if depth is too small, we can extend the number of rows of these horizontal panels.}
00921       \textcolor{comment}{// This actual number of rows is computed as follow:}
00922       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} l1 = defaultL1CacheSize; \textcolor{comment}{// in Bytes, TODO, l1 should be passed to this function.}
00923       \textcolor{comment}{// The max(1, ...) here is needed because we may be using blocking params larger than what our known
       l1 cache size}
00924       \textcolor{comment}{// suggests we should be using: either because our known l1 cache size is inaccurate (e.g. on
       Android, we can only guess),}
00925       \textcolor{comment}{// or because we are testing specific blocking sizes.}
00926       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_panel\_rows = (3*LhsProgress) * std::max<Index>(1,( (l1 - \textcolor{keyword}{sizeof}(ResScalar)*mr
      *nr - depth*nr*\textcolor{keyword}{sizeof}(RhsScalar)) / (depth * \textcolor{keyword}{sizeof}(LhsScalar) * 3*LhsProgress) ));
00927       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i1=0; i1<peeled\_mc3; i1+=actual\_panel\_rows)
00928       \{
00929         \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_panel\_end = (std::min)(i1+actual\_panel\_rows, peeled\_mc3);
00930         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=0; j2<packet\_cols4; j2+=nr)
00931         \{
00932           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=i1; i<actual\_panel\_end; i+=3*LhsProgress)
00933           \{
00934           
00935           \textcolor{comment}{// We selected a 3*Traits::LhsProgress x nr micro block of res which is entirely}
00936           \textcolor{comment}{// stored into 3 x nr registers.}
00937           
00938           \textcolor{keyword}{const} LhsScalar* blA = &blockA[i*strideA+offsetA*(3*LhsProgress)];
00939           prefetch(&blA[0]);
00940 
00941           \textcolor{comment}{// gets res block as register}
00942           AccPacket C0, C1, C2,  C3,
00943                     C4, C5, C6,  C7,
00944                     C8, C9, C10, C11;
00945           traits.initAcc(C0);  traits.initAcc(C1);  traits.initAcc(C2);  traits.initAcc(C3);
00946           traits.initAcc(C4);  traits.initAcc(C5);  traits.initAcc(C6);  traits.initAcc(C7);
00947           traits.initAcc(C8);  traits.initAcc(C9);  traits.initAcc(C10); traits.initAcc(C11);
00948 
00949           LinearMapper r0 = res.getLinearMapper(i, j2 + 0);
00950           LinearMapper r1 = res.getLinearMapper(i, j2 + 1);
00951           LinearMapper r2 = res.getLinearMapper(i, j2 + 2);
00952           LinearMapper r3 = res.getLinearMapper(i, j2 + 3);
00953 
00954           r0.prefetch(0);
00955           r1.prefetch(0);
00956           r2.prefetch(0);
00957           r3.prefetch(0);
00958 
00959           \textcolor{comment}{// performs "inner" products}
00960           \textcolor{keyword}{const} RhsScalar* blB = &blockB[j2*strideB+offsetB*nr];
00961           prefetch(&blB[0]);
00962           LhsPacket A0, A1;
00963 
00964           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<peeled\_kc; k+=pk)
00965           \{
00966             EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"begin gebp micro kernel 3pX4"});
00967             RhsPacket B\_0, T0;
00968             LhsPacket A2;
00969 
00970 \textcolor{preprocessor}{#define EIGEN\_GEBP\_ONESTEP(K) \(\backslash\)}
00971 \textcolor{preprocessor}{            do \{ \(\backslash\)}
00972 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("begin step of gebp micro kernel 3pX4"); \(\backslash\)}
00973 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("Note: these asm comments work around bug 935!"); \(\backslash\)}
00974 \textcolor{preprocessor}{              internal::prefetch(blA+(3*K+16)*LhsProgress); \(\backslash\)}
00975 \textcolor{preprocessor}{              if (EIGEN\_ARCH\_ARM) \{ internal::prefetch(blB+(4*K+16)*RhsProgress); \} }\textcolor{comment}{/* Bug 953 */}\textcolor{preprocessor}{ \(\backslash\)}
00976 \textcolor{preprocessor}{              traits.loadLhs(&blA[(0+3*K)*LhsProgress], A0);  \(\backslash\)}
00977 \textcolor{preprocessor}{              traits.loadLhs(&blA[(1+3*K)*LhsProgress], A1);  \(\backslash\)}
00978 \textcolor{preprocessor}{              traits.loadLhs(&blA[(2+3*K)*LhsProgress], A2);  \(\backslash\)}
00979 \textcolor{preprocessor}{              traits.loadRhs(blB + (0+4*K)*Traits::RhsProgress, B\_0); \(\backslash\)}
00980 \textcolor{preprocessor}{              traits.madd(A0, B\_0, C0, T0); \(\backslash\)}
00981 \textcolor{preprocessor}{              traits.madd(A1, B\_0, C4, T0); \(\backslash\)}
00982 \textcolor{preprocessor}{              traits.madd(A2, B\_0, C8, B\_0); \(\backslash\)}
00983 \textcolor{preprocessor}{              traits.loadRhs(blB + (1+4*K)*Traits::RhsProgress, B\_0); \(\backslash\)}
00984 \textcolor{preprocessor}{              traits.madd(A0, B\_0, C1, T0); \(\backslash\)}
00985 \textcolor{preprocessor}{              traits.madd(A1, B\_0, C5, T0); \(\backslash\)}
00986 \textcolor{preprocessor}{              traits.madd(A2, B\_0, C9, B\_0); \(\backslash\)}
00987 \textcolor{preprocessor}{              traits.loadRhs(blB + (2+4*K)*Traits::RhsProgress, B\_0); \(\backslash\)}
00988 \textcolor{preprocessor}{              traits.madd(A0, B\_0, C2,  T0); \(\backslash\)}
00989 \textcolor{preprocessor}{              traits.madd(A1, B\_0, C6,  T0); \(\backslash\)}
00990 \textcolor{preprocessor}{              traits.madd(A2, B\_0, C10, B\_0); \(\backslash\)}
00991 \textcolor{preprocessor}{              traits.loadRhs(blB + (3+4*K)*Traits::RhsProgress, B\_0); \(\backslash\)}
00992 \textcolor{preprocessor}{              traits.madd(A0, B\_0, C3 , T0); \(\backslash\)}
00993 \textcolor{preprocessor}{              traits.madd(A1, B\_0, C7,  T0); \(\backslash\)}
00994 \textcolor{preprocessor}{              traits.madd(A2, B\_0, C11, B\_0); \(\backslash\)}
00995 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("end step of gebp micro kernel 3pX4"); \(\backslash\)}
00996 \textcolor{preprocessor}{            \} while(false)}
00997 
00998             internal::prefetch(blB);
00999             EIGEN\_GEBP\_ONESTEP(0);
01000             EIGEN\_GEBP\_ONESTEP(1);
01001             EIGEN\_GEBP\_ONESTEP(2);
01002             EIGEN\_GEBP\_ONESTEP(3);
01003             EIGEN\_GEBP\_ONESTEP(4);
01004             EIGEN\_GEBP\_ONESTEP(5);
01005             EIGEN\_GEBP\_ONESTEP(6);
01006             EIGEN\_GEBP\_ONESTEP(7);
01007 
01008             blB += pk*4*RhsProgress;
01009             blA += pk*3*Traits::LhsProgress;
01010 
01011             EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"end gebp micro kernel 3pX4"});
01012           \}
01013           \textcolor{comment}{// process remaining peeled loop}
01014           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=peeled\_kc; k<depth; k++)
01015           \{
01016             RhsPacket B\_0, T0;
01017             LhsPacket A2;
01018             EIGEN\_GEBP\_ONESTEP(0);
01019             blB += 4*RhsProgress;
01020             blA += 3*Traits::LhsProgress;
01021           \}
01022 
01023 \textcolor{preprocessor}{#undef EIGEN\_GEBP\_ONESTEP}
01024 
01025           ResPacket R0, R1, R2;
01026           ResPacket alphav = pset1<ResPacket>(alpha);
01027 
01028           R0 = r0.loadPacket(0 * Traits::ResPacketSize);
01029           R1 = r0.loadPacket(1 * Traits::ResPacketSize);
01030           R2 = r0.loadPacket(2 * Traits::ResPacketSize);
01031           traits.acc(C0, alphav, R0);
01032           traits.acc(C4, alphav, R1);
01033           traits.acc(C8, alphav, R2);
01034           r0.storePacket(0 * Traits::ResPacketSize, R0);
01035           r0.storePacket(1 * Traits::ResPacketSize, R1);
01036           r0.storePacket(2 * Traits::ResPacketSize, R2);
01037 
01038           R0 = r1.loadPacket(0 * Traits::ResPacketSize);
01039           R1 = r1.loadPacket(1 * Traits::ResPacketSize);
01040           R2 = r1.loadPacket(2 * Traits::ResPacketSize);
01041           traits.acc(C1, alphav, R0);
01042           traits.acc(C5, alphav, R1);
01043           traits.acc(C9, alphav, R2);
01044           r1.storePacket(0 * Traits::ResPacketSize, R0);
01045           r1.storePacket(1 * Traits::ResPacketSize, R1);
01046           r1.storePacket(2 * Traits::ResPacketSize, R2);
01047 
01048           R0 = r2.loadPacket(0 * Traits::ResPacketSize);
01049           R1 = r2.loadPacket(1 * Traits::ResPacketSize);
01050           R2 = r2.loadPacket(2 * Traits::ResPacketSize);
01051           traits.acc(C2, alphav, R0);
01052           traits.acc(C6, alphav, R1);
01053           traits.acc(C10, alphav, R2);
01054           r2.storePacket(0 * Traits::ResPacketSize, R0);
01055           r2.storePacket(1 * Traits::ResPacketSize, R1);
01056           r2.storePacket(2 * Traits::ResPacketSize, R2);
01057 
01058           R0 = r3.loadPacket(0 * Traits::ResPacketSize);
01059           R1 = r3.loadPacket(1 * Traits::ResPacketSize);
01060           R2 = r3.loadPacket(2 * Traits::ResPacketSize);
01061           traits.acc(C3, alphav, R0);
01062           traits.acc(C7, alphav, R1);
01063           traits.acc(C11, alphav, R2);
01064           r3.storePacket(0 * Traits::ResPacketSize, R0);
01065           r3.storePacket(1 * Traits::ResPacketSize, R1);
01066           r3.storePacket(2 * Traits::ResPacketSize, R2);          
01067           \}
01068         \}
01069 
01070         \textcolor{comment}{// Deal with remaining columns of the rhs}
01071         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=packet\_cols4; j2<cols; j2++)
01072         \{
01073           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=i1; i<actual\_panel\_end; i+=3*LhsProgress)
01074           \{
01075           \textcolor{comment}{// One column at a time}
01076           \textcolor{keyword}{const} LhsScalar* blA = &blockA[i*strideA+offsetA*(3*Traits::LhsProgress)];
01077           prefetch(&blA[0]);
01078 
01079           \textcolor{comment}{// gets res block as register}
01080           AccPacket C0, C4, C8;
01081           traits.initAcc(C0);
01082           traits.initAcc(C4);
01083           traits.initAcc(C8);
01084 
01085           LinearMapper r0 = res.getLinearMapper(i, j2);
01086           r0.prefetch(0);
01087 
01088           \textcolor{comment}{// performs "inner" products}
01089           \textcolor{keyword}{const} RhsScalar* blB = &blockB[j2*strideB+offsetB];
01090           LhsPacket A0, A1, A2;
01091           
01092           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<peeled\_kc; k+=pk)
01093           \{
01094             EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"begin gebp micro kernel 3pX1"});
01095             RhsPacket B\_0;
01096 \textcolor{preprocessor}{#define EIGEN\_GEBGP\_ONESTEP(K) \(\backslash\)}
01097 \textcolor{preprocessor}{            do \{ \(\backslash\)}
01098 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("begin step of gebp micro kernel 3pX1"); \(\backslash\)}
01099 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("Note: these asm comments work around bug 935!"); \(\backslash\)}
01100 \textcolor{preprocessor}{              traits.loadLhs(&blA[(0+3*K)*LhsProgress], A0);  \(\backslash\)}
01101 \textcolor{preprocessor}{              traits.loadLhs(&blA[(1+3*K)*LhsProgress], A1);  \(\backslash\)}
01102 \textcolor{preprocessor}{              traits.loadLhs(&blA[(2+3*K)*LhsProgress], A2);  \(\backslash\)}
01103 \textcolor{preprocessor}{              traits.loadRhs(&blB[(0+K)*RhsProgress], B\_0);   \(\backslash\)}
01104 \textcolor{preprocessor}{              traits.madd(A0, B\_0, C0, B\_0); \(\backslash\)}
01105 \textcolor{preprocessor}{              traits.madd(A1, B\_0, C4, B\_0); \(\backslash\)}
01106 \textcolor{preprocessor}{              traits.madd(A2, B\_0, C8, B\_0); \(\backslash\)}
01107 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("end step of gebp micro kernel 3pX1"); \(\backslash\)}
01108 \textcolor{preprocessor}{            \} while(false)}
01109         
01110             EIGEN\_GEBGP\_ONESTEP(0);
01111             EIGEN\_GEBGP\_ONESTEP(1);
01112             EIGEN\_GEBGP\_ONESTEP(2);
01113             EIGEN\_GEBGP\_ONESTEP(3);
01114             EIGEN\_GEBGP\_ONESTEP(4);
01115             EIGEN\_GEBGP\_ONESTEP(5);
01116             EIGEN\_GEBGP\_ONESTEP(6);
01117             EIGEN\_GEBGP\_ONESTEP(7);
01118 
01119             blB += pk*RhsProgress;
01120             blA += pk*3*Traits::LhsProgress;
01121 
01122             EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"end gebp micro kernel 3pX1"});
01123           \}
01124 
01125           \textcolor{comment}{// process remaining peeled loop}
01126           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=peeled\_kc; k<depth; k++)
01127           \{
01128             RhsPacket B\_0;
01129             EIGEN\_GEBGP\_ONESTEP(0);
01130             blB += RhsProgress;
01131             blA += 3*Traits::LhsProgress;
01132           \}
01133 \textcolor{preprocessor}{#undef EIGEN\_GEBGP\_ONESTEP}
01134           ResPacket R0, R1, R2;
01135           ResPacket alphav = pset1<ResPacket>(alpha);
01136 
01137           R0 = r0.loadPacket(0 * Traits::ResPacketSize);
01138           R1 = r0.loadPacket(1 * Traits::ResPacketSize);
01139           R2 = r0.loadPacket(2 * Traits::ResPacketSize);
01140           traits.acc(C0, alphav, R0);
01141           traits.acc(C4, alphav, R1);
01142           traits.acc(C8, alphav, R2);
01143           r0.storePacket(0 * Traits::ResPacketSize, R0);
01144           r0.storePacket(1 * Traits::ResPacketSize, R1);
01145           r0.storePacket(2 * Traits::ResPacketSize, R2);          
01146           \}
01147         \}
01148       \}
01149     \}
01150 
01151     \textcolor{comment}{//---------- Process 2 * LhsProgress rows at once ----------}
01152     \textcolor{keywordflow}{if}(mr>=2*Traits::LhsProgress)
01153     \{
01154       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} l1 = defaultL1CacheSize; \textcolor{comment}{// in Bytes, TODO, l1 should be passed to this function.}
01155       \textcolor{comment}{// The max(1, ...) here is needed because we may be using blocking params larger than what our known
       l1 cache size}
01156       \textcolor{comment}{// suggests we should be using: either because our known l1 cache size is inaccurate (e.g. on
       Android, we can only guess),}
01157       \textcolor{comment}{// or because we are testing specific blocking sizes.}
01158       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_panel\_rows = (2*LhsProgress) * std::max<Index>(1,( (l1 - \textcolor{keyword}{sizeof}(ResScalar)*mr*nr - 
      depth*nr*\textcolor{keyword}{sizeof}(RhsScalar)) / (depth * \textcolor{keyword}{sizeof}(LhsScalar) * 2*LhsProgress) ));
01159 
01160       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i1=peeled\_mc3; i1<peeled\_mc2; i1+=actual\_panel\_rows)
01161       \{
01162         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} actual\_panel\_end = (std::min)(i1+actual\_panel\_rows, peeled\_mc2);
01163         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=0; j2<packet\_cols4; j2+=nr)
01164         \{
01165           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=i1; i<actual\_panel\_end; i+=2*LhsProgress)
01166           \{
01167           
01168           \textcolor{comment}{// We selected a 2*Traits::LhsProgress x nr micro block of res which is entirely}
01169           \textcolor{comment}{// stored into 2 x nr registers.}
01170           
01171           \textcolor{keyword}{const} LhsScalar* blA = &blockA[i*strideA+offsetA*(2*Traits::LhsProgress)];
01172           prefetch(&blA[0]);
01173 
01174           \textcolor{comment}{// gets res block as register}
01175           AccPacket C0, C1, C2, C3,
01176                     C4, C5, C6, C7;
01177           traits.initAcc(C0); traits.initAcc(C1); traits.initAcc(C2); traits.initAcc(C3);
01178           traits.initAcc(C4); traits.initAcc(C5); traits.initAcc(C6); traits.initAcc(C7);
01179 
01180           LinearMapper r0 = res.getLinearMapper(i, j2 + 0);
01181           LinearMapper r1 = res.getLinearMapper(i, j2 + 1);
01182           LinearMapper r2 = res.getLinearMapper(i, j2 + 2);
01183           LinearMapper r3 = res.getLinearMapper(i, j2 + 3);
01184 
01185           r0.prefetch(prefetch\_res\_offset);
01186           r1.prefetch(prefetch\_res\_offset);
01187           r2.prefetch(prefetch\_res\_offset);
01188           r3.prefetch(prefetch\_res\_offset);
01189 
01190           \textcolor{comment}{// performs "inner" products}
01191           \textcolor{keyword}{const} RhsScalar* blB = &blockB[j2*strideB+offsetB*nr];
01192           prefetch(&blB[0]);
01193           LhsPacket A0, A1;
01194 
01195           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<peeled\_kc; k+=pk)
01196           \{
01197             EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"begin gebp micro kernel 2pX4"});
01198             RhsPacket B\_0, B1, B2, B3, T0;
01199 
01200 \textcolor{preprocessor}{   #define EIGEN\_GEBGP\_ONESTEP(K) \(\backslash\)}
01201 \textcolor{preprocessor}{            do \{                                                                \(\backslash\)}
01202 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("begin step of gebp micro kernel 2pX4");        \(\backslash\)}
01203 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("Note: these asm comments work around bug 935!"); \(\backslash\)}
01204 \textcolor{preprocessor}{              traits.loadLhs(&blA[(0+2*K)*LhsProgress], A0);                    \(\backslash\)}
01205 \textcolor{preprocessor}{              traits.loadLhs(&blA[(1+2*K)*LhsProgress], A1);                    \(\backslash\)}
01206 \textcolor{preprocessor}{              traits.broadcastRhs(&blB[(0+4*K)*RhsProgress], B\_0, B1, B2, B3);  \(\backslash\)}
01207 \textcolor{preprocessor}{              traits.madd(A0, B\_0, C0, T0);                                     \(\backslash\)}
01208 \textcolor{preprocessor}{              traits.madd(A1, B\_0, C4, B\_0);                                    \(\backslash\)}
01209 \textcolor{preprocessor}{              traits.madd(A0, B1,  C1, T0);                                     \(\backslash\)}
01210 \textcolor{preprocessor}{              traits.madd(A1, B1,  C5, B1);                                     \(\backslash\)}
01211 \textcolor{preprocessor}{              traits.madd(A0, B2,  C2, T0);                                     \(\backslash\)}
01212 \textcolor{preprocessor}{              traits.madd(A1, B2,  C6, B2);                                     \(\backslash\)}
01213 \textcolor{preprocessor}{              traits.madd(A0, B3,  C3, T0);                                     \(\backslash\)}
01214 \textcolor{preprocessor}{              traits.madd(A1, B3,  C7, B3);                                     \(\backslash\)}
01215 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("end step of gebp micro kernel 2pX4");          \(\backslash\)}
01216 \textcolor{preprocessor}{            \} while(false)}
01217             
01218             internal::prefetch(blB+(48+0));
01219             EIGEN\_GEBGP\_ONESTEP(0);
01220             EIGEN\_GEBGP\_ONESTEP(1);
01221             EIGEN\_GEBGP\_ONESTEP(2);
01222             EIGEN\_GEBGP\_ONESTEP(3);
01223             internal::prefetch(blB+(48+16));
01224             EIGEN\_GEBGP\_ONESTEP(4);
01225             EIGEN\_GEBGP\_ONESTEP(5);
01226             EIGEN\_GEBGP\_ONESTEP(6);
01227             EIGEN\_GEBGP\_ONESTEP(7);
01228 
01229             blB += pk*4*RhsProgress;
01230             blA += pk*(2*Traits::LhsProgress);
01231 
01232             EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"end gebp micro kernel 2pX4"});
01233           \}
01234           \textcolor{comment}{// process remaining peeled loop}
01235           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=peeled\_kc; k<depth; k++)
01236           \{
01237             RhsPacket B\_0, B1, B2, B3, T0;
01238             EIGEN\_GEBGP\_ONESTEP(0);
01239             blB += 4*RhsProgress;
01240             blA += 2*Traits::LhsProgress;
01241           \}
01242 \textcolor{preprocessor}{#undef EIGEN\_GEBGP\_ONESTEP}
01243 
01244           ResPacket R0, R1, R2, R3;
01245           ResPacket alphav = pset1<ResPacket>(alpha);
01246 
01247           R0 = r0.loadPacket(0 * Traits::ResPacketSize);
01248           R1 = r0.loadPacket(1 * Traits::ResPacketSize);
01249           R2 = r1.loadPacket(0 * Traits::ResPacketSize);
01250           R3 = r1.loadPacket(1 * Traits::ResPacketSize);
01251           traits.acc(C0, alphav, R0);
01252           traits.acc(C4, alphav, R1);
01253           traits.acc(C1, alphav, R2);
01254           traits.acc(C5, alphav, R3);
01255           r0.storePacket(0 * Traits::ResPacketSize, R0);
01256           r0.storePacket(1 * Traits::ResPacketSize, R1);
01257           r1.storePacket(0 * Traits::ResPacketSize, R2);
01258           r1.storePacket(1 * Traits::ResPacketSize, R3);
01259 
01260           R0 = r2.loadPacket(0 * Traits::ResPacketSize);
01261           R1 = r2.loadPacket(1 * Traits::ResPacketSize);
01262           R2 = r3.loadPacket(0 * Traits::ResPacketSize);
01263           R3 = r3.loadPacket(1 * Traits::ResPacketSize);
01264           traits.acc(C2,  alphav, R0);
01265           traits.acc(C6,  alphav, R1);
01266           traits.acc(C3,  alphav, R2);
01267           traits.acc(C7,  alphav, R3);
01268           r2.storePacket(0 * Traits::ResPacketSize, R0);
01269           r2.storePacket(1 * Traits::ResPacketSize, R1);
01270           r3.storePacket(0 * Traits::ResPacketSize, R2);
01271           r3.storePacket(1 * Traits::ResPacketSize, R3);
01272           \}
01273         \}
01274       
01275         \textcolor{comment}{// Deal with remaining columns of the rhs}
01276         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=packet\_cols4; j2<cols; j2++)
01277         \{
01278           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=i1; i<actual\_panel\_end; i+=2*LhsProgress)
01279           \{
01280           \textcolor{comment}{// One column at a time}
01281           \textcolor{keyword}{const} LhsScalar* blA = &blockA[i*strideA+offsetA*(2*Traits::LhsProgress)];
01282           prefetch(&blA[0]);
01283 
01284           \textcolor{comment}{// gets res block as register}
01285           AccPacket C0, C4;
01286           traits.initAcc(C0);
01287           traits.initAcc(C4);
01288 
01289           LinearMapper r0 = res.getLinearMapper(i, j2);
01290           r0.prefetch(prefetch\_res\_offset);
01291 
01292           \textcolor{comment}{// performs "inner" products}
01293           \textcolor{keyword}{const} RhsScalar* blB = &blockB[j2*strideB+offsetB];
01294           LhsPacket A0, A1;
01295 
01296           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<peeled\_kc; k+=pk)
01297           \{
01298             EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"begin gebp micro kernel 2pX1"});
01299             RhsPacket B\_0, B1;
01300         
01301 \textcolor{preprocessor}{#define EIGEN\_GEBGP\_ONESTEP(K) \(\backslash\)}
01302 \textcolor{preprocessor}{            do \{                                                                  \(\backslash\)}
01303 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("begin step of gebp micro kernel 2pX1");          \(\backslash\)}
01304 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("Note: these asm comments work around bug 935!"); \(\backslash\)}
01305 \textcolor{preprocessor}{              traits.loadLhs(&blA[(0+2*K)*LhsProgress], A0);                      \(\backslash\)}
01306 \textcolor{preprocessor}{              traits.loadLhs(&blA[(1+2*K)*LhsProgress], A1);                      \(\backslash\)}
01307 \textcolor{preprocessor}{              traits.loadRhs(&blB[(0+K)*RhsProgress], B\_0);                       \(\backslash\)}
01308 \textcolor{preprocessor}{              traits.madd(A0, B\_0, C0, B1);                                       \(\backslash\)}
01309 \textcolor{preprocessor}{              traits.madd(A1, B\_0, C4, B\_0);                                      \(\backslash\)}
01310 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("end step of gebp micro kernel 2pX1");            \(\backslash\)}
01311 \textcolor{preprocessor}{            \} while(false)}
01312         
01313             EIGEN\_GEBGP\_ONESTEP(0);
01314             EIGEN\_GEBGP\_ONESTEP(1);
01315             EIGEN\_GEBGP\_ONESTEP(2);
01316             EIGEN\_GEBGP\_ONESTEP(3);
01317             EIGEN\_GEBGP\_ONESTEP(4);
01318             EIGEN\_GEBGP\_ONESTEP(5);
01319             EIGEN\_GEBGP\_ONESTEP(6);
01320             EIGEN\_GEBGP\_ONESTEP(7);
01321 
01322             blB += pk*RhsProgress;
01323             blA += pk*2*Traits::LhsProgress;
01324 
01325             EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"end gebp micro kernel 2pX1"});
01326           \}
01327 
01328           \textcolor{comment}{// process remaining peeled loop}
01329           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=peeled\_kc; k<depth; k++)
01330           \{
01331             RhsPacket B\_0, B1;
01332             EIGEN\_GEBGP\_ONESTEP(0);
01333             blB += RhsProgress;
01334             blA += 2*Traits::LhsProgress;
01335           \}
01336 \textcolor{preprocessor}{#undef EIGEN\_GEBGP\_ONESTEP}
01337           ResPacket R0, R1;
01338           ResPacket alphav = pset1<ResPacket>(alpha);
01339 
01340           R0 = r0.loadPacket(0 * Traits::ResPacketSize);
01341           R1 = r0.loadPacket(1 * Traits::ResPacketSize);
01342           traits.acc(C0, alphav, R0);
01343           traits.acc(C4, alphav, R1);
01344           r0.storePacket(0 * Traits::ResPacketSize, R0);
01345           r0.storePacket(1 * Traits::ResPacketSize, R1);
01346           \}
01347         \}
01348       \}
01349     \}
01350     \textcolor{comment}{//---------- Process 1 * LhsProgress rows at once ----------}
01351     \textcolor{keywordflow}{if}(mr>=1*Traits::LhsProgress)
01352     \{
01353       \textcolor{comment}{// loops on each largest micro horizontal panel of lhs (1*LhsProgress x depth)}
01354       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=peeled\_mc2; i<peeled\_mc1; i+=1*LhsProgress)
01355       \{
01356         \textcolor{comment}{// loops on each largest micro vertical panel of rhs (depth * nr)}
01357         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=0; j2<packet\_cols4; j2+=nr)
01358         \{
01359           \textcolor{comment}{// We select a 1*Traits::LhsProgress x nr micro block of res which is entirely}
01360           \textcolor{comment}{// stored into 1 x nr registers.}
01361           
01362           \textcolor{keyword}{const} LhsScalar* blA = &blockA[i*strideA+offsetA*(1*Traits::LhsProgress)];
01363           prefetch(&blA[0]);
01364 
01365           \textcolor{comment}{// gets res block as register}
01366           AccPacket C0, C1, C2, C3;
01367           traits.initAcc(C0);
01368           traits.initAcc(C1);
01369           traits.initAcc(C2);
01370           traits.initAcc(C3);
01371 
01372           LinearMapper r0 = res.getLinearMapper(i, j2 + 0);
01373           LinearMapper r1 = res.getLinearMapper(i, j2 + 1);
01374           LinearMapper r2 = res.getLinearMapper(i, j2 + 2);
01375           LinearMapper r3 = res.getLinearMapper(i, j2 + 3);
01376 
01377           r0.prefetch(prefetch\_res\_offset);
01378           r1.prefetch(prefetch\_res\_offset);
01379           r2.prefetch(prefetch\_res\_offset);
01380           r3.prefetch(prefetch\_res\_offset);
01381 
01382           \textcolor{comment}{// performs "inner" products}
01383           \textcolor{keyword}{const} RhsScalar* blB = &blockB[j2*strideB+offsetB*nr];
01384           prefetch(&blB[0]);
01385           LhsPacket A0;
01386 
01387           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<peeled\_kc; k+=pk)
01388           \{
01389             EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"begin gebp micro kernel 1pX4"});
01390             RhsPacket B\_0, B1, B2, B3;
01391                
01392 \textcolor{preprocessor}{#define EIGEN\_GEBGP\_ONESTEP(K) \(\backslash\)}
01393 \textcolor{preprocessor}{            do \{                                                                \(\backslash\)}
01394 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("begin step of gebp micro kernel 1pX4");        \(\backslash\)}
01395 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("Note: these asm comments work around bug 935!"); \(\backslash\)}
01396 \textcolor{preprocessor}{              traits.loadLhs(&blA[(0+1*K)*LhsProgress], A0);                    \(\backslash\)}
01397 \textcolor{preprocessor}{              traits.broadcastRhs(&blB[(0+4*K)*RhsProgress], B\_0, B1, B2, B3);  \(\backslash\)}
01398 \textcolor{preprocessor}{              traits.madd(A0, B\_0, C0, B\_0);                                    \(\backslash\)}
01399 \textcolor{preprocessor}{              traits.madd(A0, B1,  C1, B1);                                     \(\backslash\)}
01400 \textcolor{preprocessor}{              traits.madd(A0, B2,  C2, B2);                                     \(\backslash\)}
01401 \textcolor{preprocessor}{              traits.madd(A0, B3,  C3, B3);                                     \(\backslash\)}
01402 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("end step of gebp micro kernel 1pX4");          \(\backslash\)}
01403 \textcolor{preprocessor}{            \} while(false)}
01404             
01405             internal::prefetch(blB+(48+0));
01406             EIGEN\_GEBGP\_ONESTEP(0);
01407             EIGEN\_GEBGP\_ONESTEP(1);
01408             EIGEN\_GEBGP\_ONESTEP(2);
01409             EIGEN\_GEBGP\_ONESTEP(3);
01410             internal::prefetch(blB+(48+16));
01411             EIGEN\_GEBGP\_ONESTEP(4);
01412             EIGEN\_GEBGP\_ONESTEP(5);
01413             EIGEN\_GEBGP\_ONESTEP(6);
01414             EIGEN\_GEBGP\_ONESTEP(7);
01415 
01416             blB += pk*4*RhsProgress;
01417             blA += pk*1*LhsProgress;
01418 
01419             EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"end gebp micro kernel 1pX4"});
01420           \}
01421           \textcolor{comment}{// process remaining peeled loop}
01422           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=peeled\_kc; k<depth; k++)
01423           \{
01424             RhsPacket B\_0, B1, B2, B3;
01425             EIGEN\_GEBGP\_ONESTEP(0);
01426             blB += 4*RhsProgress;
01427             blA += 1*LhsProgress;
01428           \}
01429 \textcolor{preprocessor}{#undef EIGEN\_GEBGP\_ONESTEP}
01430 
01431           ResPacket R0, R1;
01432           ResPacket alphav = pset1<ResPacket>(alpha);
01433 
01434           R0 = r0.loadPacket(0 * Traits::ResPacketSize);
01435           R1 = r1.loadPacket(0 * Traits::ResPacketSize);
01436           traits.acc(C0, alphav, R0);
01437           traits.acc(C1,  alphav, R1);
01438           r0.storePacket(0 * Traits::ResPacketSize, R0);
01439           r1.storePacket(0 * Traits::ResPacketSize, R1);
01440 
01441           R0 = r2.loadPacket(0 * Traits::ResPacketSize);
01442           R1 = r3.loadPacket(0 * Traits::ResPacketSize);
01443           traits.acc(C2,  alphav, R0);
01444           traits.acc(C3,  alphav, R1);
01445           r2.storePacket(0 * Traits::ResPacketSize, R0);
01446           r3.storePacket(0 * Traits::ResPacketSize, R1);
01447         \}
01448 
01449         \textcolor{comment}{// Deal with remaining columns of the rhs}
01450         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=packet\_cols4; j2<cols; j2++)
01451         \{
01452           \textcolor{comment}{// One column at a time}
01453           \textcolor{keyword}{const} LhsScalar* blA = &blockA[i*strideA+offsetA*(1*Traits::LhsProgress)];
01454           prefetch(&blA[0]);
01455 
01456           \textcolor{comment}{// gets res block as register}
01457           AccPacket C0;
01458           traits.initAcc(C0);
01459 
01460           LinearMapper r0 = res.getLinearMapper(i, j2);
01461 
01462           \textcolor{comment}{// performs "inner" products}
01463           \textcolor{keyword}{const} RhsScalar* blB = &blockB[j2*strideB+offsetB];
01464           LhsPacket A0;
01465 
01466           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<peeled\_kc; k+=pk)
01467           \{
01468             EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"begin gebp micro kernel 1pX1"});
01469             RhsPacket B\_0;
01470         
01471 \textcolor{preprocessor}{#define EIGEN\_GEBGP\_ONESTEP(K) \(\backslash\)}
01472 \textcolor{preprocessor}{            do \{                                                                \(\backslash\)}
01473 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("begin step of gebp micro kernel 1pX1");        \(\backslash\)}
01474 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("Note: these asm comments work around bug 935!"); \(\backslash\)}
01475 \textcolor{preprocessor}{              traits.loadLhs(&blA[(0+1*K)*LhsProgress], A0);                    \(\backslash\)}
01476 \textcolor{preprocessor}{              traits.loadRhs(&blB[(0+K)*RhsProgress], B\_0);                     \(\backslash\)}
01477 \textcolor{preprocessor}{              traits.madd(A0, B\_0, C0, B\_0);                                    \(\backslash\)}
01478 \textcolor{preprocessor}{              EIGEN\_ASM\_COMMENT("end step of gebp micro kernel 1pX1");          \(\backslash\)}
01479 \textcolor{preprocessor}{            \} while(false);}
01480 
01481             EIGEN\_GEBGP\_ONESTEP(0);
01482             EIGEN\_GEBGP\_ONESTEP(1);
01483             EIGEN\_GEBGP\_ONESTEP(2);
01484             EIGEN\_GEBGP\_ONESTEP(3);
01485             EIGEN\_GEBGP\_ONESTEP(4);
01486             EIGEN\_GEBGP\_ONESTEP(5);
01487             EIGEN\_GEBGP\_ONESTEP(6);
01488             EIGEN\_GEBGP\_ONESTEP(7);
01489 
01490             blB += pk*RhsProgress;
01491             blA += pk*1*Traits::LhsProgress;
01492 
01493             EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"end gebp micro kernel 1pX1"});
01494           \}
01495 
01496           \textcolor{comment}{// process remaining peeled loop}
01497           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=peeled\_kc; k<depth; k++)
01498           \{
01499             RhsPacket B\_0;
01500             EIGEN\_GEBGP\_ONESTEP(0);
01501             blB += RhsProgress;
01502             blA += 1*Traits::LhsProgress;
01503           \}
01504 \textcolor{preprocessor}{#undef EIGEN\_GEBGP\_ONESTEP}
01505           ResPacket R0;
01506           ResPacket alphav = pset1<ResPacket>(alpha);
01507           R0 = r0.loadPacket(0 * Traits::ResPacketSize);
01508           traits.acc(C0, alphav, R0);
01509           r0.storePacket(0 * Traits::ResPacketSize, R0);
01510         \}
01511       \}
01512     \}
01513     \textcolor{comment}{//---------- Process remaining rows, 1 at once ----------}
01514     \textcolor{keywordflow}{if}(peeled\_mc1<rows)
01515     \{
01516       \textcolor{comment}{// loop on each panel of the rhs}
01517       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=0; j2<packet\_cols4; j2+=nr)
01518       \{
01519         \textcolor{comment}{// loop on each row of the lhs (1*LhsProgress x depth)}
01520         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=peeled\_mc1; i<rows; i+=1)
01521         \{
01522           \textcolor{keyword}{const} LhsScalar* blA = &blockA[i*strideA+offsetA];
01523           prefetch(&blA[0]);
01524           \textcolor{keyword}{const} RhsScalar* blB = &blockB[j2*strideB+offsetB*nr];
01525 
01526           \textcolor{comment}{// The following piece of code wont work for 512 bit registers}
01527           \textcolor{comment}{// Moreover, if LhsProgress==8 it assumes that there is a half packet of the same size}
01528           \textcolor{comment}{// as nr (which is currently 4) for the return type.}
01529           \textcolor{keyword}{typedef} \textcolor{keyword}{typename} unpacket\_traits<SResPacket>::half SResPacketHalf;
01530           \textcolor{keywordflow}{if} ((SwappedTraits::LhsProgress % 4) == 0 &&
01531               (SwappedTraits::LhsProgress <= 8) &&
01532               (SwappedTraits::LhsProgress!=8 || unpacket\_traits<SResPacketHalf>::size==nr))
01533           \{
01534             SAccPacket C0, C1, C2, C3;
01535             straits.initAcc(C0);
01536             straits.initAcc(C1);
01537             straits.initAcc(C2);
01538             straits.initAcc(C3);
01539 
01540             \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} spk   = (std::max)(1,SwappedTraits::LhsProgress/4);
01541             \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} endk  = (depth/spk)*spk;
01542             \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} endk4 = (depth/(spk*4))*(spk*4);
01543 
01544             \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0;
01545             \textcolor{keywordflow}{for}(; k<endk4; k+=4*spk)
01546             \{
01547               SLhsPacket A0,A1;
01548               SRhsPacket B\_0,B\_1;
01549 
01550               straits.loadLhsUnaligned(blB+0*SwappedTraits::LhsProgress, A0);
01551               straits.loadLhsUnaligned(blB+1*SwappedTraits::LhsProgress, A1);
01552 
01553               straits.loadRhsQuad(blA+0*spk, B\_0);
01554               straits.loadRhsQuad(blA+1*spk, B\_1);
01555               straits.madd(A0,B\_0,C0,B\_0);
01556               straits.madd(A1,B\_1,C1,B\_1);
01557 
01558               straits.loadLhsUnaligned(blB+2*SwappedTraits::LhsProgress, A0);
01559               straits.loadLhsUnaligned(blB+3*SwappedTraits::LhsProgress, A1);
01560               straits.loadRhsQuad(blA+2*spk, B\_0);
01561               straits.loadRhsQuad(blA+3*spk, B\_1);
01562               straits.madd(A0,B\_0,C2,B\_0);
01563               straits.madd(A1,B\_1,C3,B\_1);
01564 
01565               blB += 4*SwappedTraits::LhsProgress;
01566               blA += 4*spk;
01567             \}
01568             C0 = padd(padd(C0,C1),padd(C2,C3));
01569             \textcolor{keywordflow}{for}(; k<endk; k+=spk)
01570             \{
01571               SLhsPacket A0;
01572               SRhsPacket B\_0;
01573 
01574               straits.loadLhsUnaligned(blB, A0);
01575               straits.loadRhsQuad(blA, B\_0);
01576               straits.madd(A0,B\_0,C0,B\_0);
01577 
01578               blB += SwappedTraits::LhsProgress;
01579               blA += spk;
01580             \}
01581             \textcolor{keywordflow}{if}(SwappedTraits::LhsProgress==8)
01582             \{
01583               \textcolor{comment}{// Special case where we have to first reduce the accumulation register C0}
01584               \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<SwappedTraits::LhsProgress>=8,\textcolor{keyword}{typename} 
      unpacket\_traits<SResPacket>::half,SResPacket>::type SResPacketHalf;
01585               \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<SwappedTraits::LhsProgress>=8,\textcolor{keyword}{typename} 
      unpacket\_traits<SLhsPacket>::half,SLhsPacket>::type SLhsPacketHalf;
01586               \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<SwappedTraits::LhsProgress>=8,\textcolor{keyword}{typename} 
      unpacket\_traits<SLhsPacket>::half,SRhsPacket>::type SRhsPacketHalf;
01587               \textcolor{keyword}{typedef} \textcolor{keyword}{typename} conditional<SwappedTraits::LhsProgress>=8,\textcolor{keyword}{typename} 
      unpacket\_traits<SAccPacket>::half,SAccPacket>::type SAccPacketHalf;
01588 
01589               SResPacketHalf R = res.template gatherPacket<SResPacketHalf>(i, j2);
01590               SResPacketHalf alphav = pset1<SResPacketHalf>(alpha);
01591 
01592               \textcolor{keywordflow}{if}(depth-endk>0)
01593               \{
01594                 \textcolor{comment}{// We have to handle the last row of the rhs which corresponds to a half-packet}
01595                 SLhsPacketHalf a0;
01596                 SRhsPacketHalf b0;
01597                 straits.loadLhsUnaligned(blB, a0);
01598                 straits.loadRhs(blA, b0);
01599                 SAccPacketHalf c0 = predux\_downto4(C0);
01600                 straits.madd(a0,b0,c0,b0);
01601                 straits.acc(c0, alphav, R);
01602               \}
01603               \textcolor{keywordflow}{else}
01604               \{
01605                 straits.acc(predux\_downto4(C0), alphav, R);
01606               \}
01607               res.scatterPacket(i, j2, R);
01608             \}
01609             \textcolor{keywordflow}{else}
01610             \{
01611               SResPacket R = res.template gatherPacket<SResPacket>(i, j2);
01612               SResPacket alphav = pset1<SResPacket>(alpha);
01613               straits.acc(C0, alphav, R);
01614               res.scatterPacket(i, j2, R);
01615             \}
01616           \}
01617           \textcolor{keywordflow}{else} \textcolor{comment}{// scalar path}
01618           \{
01619             \textcolor{comment}{// get a 1 x 4 res block as registers}
01620             ResScalar C0(0), C1(0), C2(0), C3(0);
01621 
01622             \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<depth; k++)
01623             \{
01624               LhsScalar A0;
01625               RhsScalar B\_0, B\_1;
01626 
01627               A0 = blA[k];
01628 
01629               B\_0 = blB[0];
01630               B\_1 = blB[1];
01631               CJMADD(cj,A0,B\_0,C0,  B\_0);
01632               CJMADD(cj,A0,B\_1,C1,  B\_1);
01633               
01634               B\_0 = blB[2];
01635               B\_1 = blB[3];
01636               CJMADD(cj,A0,B\_0,C2,  B\_0);
01637               CJMADD(cj,A0,B\_1,C3,  B\_1);
01638               
01639               blB += 4;
01640             \}
01641             res(i, j2 + 0) += alpha * C0;
01642             res(i, j2 + 1) += alpha * C1;
01643             res(i, j2 + 2) += alpha * C2;
01644             res(i, j2 + 3) += alpha * C3;
01645           \}
01646         \}
01647       \}
01648       \textcolor{comment}{// remaining columns}
01649       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=packet\_cols4; j2<cols; j2++)
01650       \{
01651         \textcolor{comment}{// loop on each row of the lhs (1*LhsProgress x depth)}
01652         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=peeled\_mc1; i<rows; i+=1)
01653         \{
01654           \textcolor{keyword}{const} LhsScalar* blA = &blockA[i*strideA+offsetA];
01655           prefetch(&blA[0]);
01656           \textcolor{comment}{// gets a 1 x 1 res block as registers}
01657           ResScalar C0(0);
01658           \textcolor{keyword}{const} RhsScalar* blB = &blockB[j2*strideB+offsetB];
01659           \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<depth; k++)
01660           \{
01661             LhsScalar A0 = blA[k];
01662             RhsScalar B\_0 = blB[k];
01663             CJMADD(cj, A0, B\_0, C0, B\_0);
01664           \}
01665           res(i, j2) += alpha * C0;
01666         \}
01667       \}
01668     \}
01669   \}
01670 
01671 
01672 \textcolor{preprocessor}{#undef CJMADD}
01673 
01674 \textcolor{comment}{// pack a block of the lhs}
01675 \textcolor{comment}{// The traversal is as follow (mr==4):}
01676 \textcolor{comment}{//   0  4  8 12 ...}
01677 \textcolor{comment}{//   1  5  9 13 ...}
01678 \textcolor{comment}{//   2  6 10 14 ...}
01679 \textcolor{comment}{//   3  7 11 15 ...}
01680 \textcolor{comment}{//}
01681 \textcolor{comment}{//  16 20 24 28 ...}
01682 \textcolor{comment}{//  17 21 25 29 ...}
01683 \textcolor{comment}{//  18 22 26 30 ...}
01684 \textcolor{comment}{//  19 23 27 31 ...}
01685 \textcolor{comment}{//}
01686 \textcolor{comment}{//  32 33 34 35 ...}
01687 \textcolor{comment}{//  36 36 38 39 ...}
01688 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} Pack1, \textcolor{keywordtype}{int} Pack2, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{bool} P
      anelMode>
01689 \textcolor{keyword}{struct }gemm\_pack\_lhs<Scalar, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, DataMapper, Pack1, Pack2, \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}, Conjugate, PanelMode>
01690 \{
01691   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DataMapper::LinearMapper LinearMapper;
01692   EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} operator()(Scalar* blockA, \textcolor{keyword}{const} DataMapper& lhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride=0, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset=0);
01693 \};
01694 
01695 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} Pack1, \textcolor{keywordtype}{int} Pack2, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{bool} P
      anelMode>
01696 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} gemm\_pack\_lhs<Scalar, Index, DataMapper, Pack1, Pack2, ColMajor, Conjugate,
       PanelMode>
01697   ::operator()(Scalar* blockA, \textcolor{keyword}{const} DataMapper& lhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset)
01698 \{
01699   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::type Packet;
01700   \textcolor{keyword}{enum} \{ PacketSize = packet\_traits<Scalar>::size \};
01701 
01702   EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"EIGEN PRODUCT PACK LHS"});
01703   EIGEN\_UNUSED\_VARIABLE(stride);
01704   EIGEN\_UNUSED\_VARIABLE(offset);
01705   eigen\_assert(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride));
01706   eigen\_assert( ((Pack1%PacketSize)==0 && Pack1<=4*PacketSize) || (Pack1<=4) );
01707   conj\_if<NumTraits<Scalar>::IsComplex && Conjugate> cj;
01708   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} count = 0;
01709 
01710   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeled\_mc3 = Pack1>=3*PacketSize ? (rows/(3*PacketSize))*(3*PacketSize) : 0;
01711   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeled\_mc2 = Pack1>=2*PacketSize ? peeled\_mc3+((rows-peeled\_mc3)/(2*PacketSize))*(2*
      PacketSize) : 0;
01712   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeled\_mc1 = Pack1>=1*PacketSize ? (rows/(1*PacketSize))*(1*PacketSize) : 0;
01713   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeled\_mc0 = Pack2>=1*PacketSize ? peeled\_mc1
01714                          : Pack2>1             ? (rows/Pack2)*Pack2 : 0;
01715 
01716   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i=0;
01717 
01718   \textcolor{comment}{// Pack 3 packets}
01719   \textcolor{keywordflow}{if}(Pack1>=3*PacketSize)
01720   \{
01721     \textcolor{keywordflow}{for}(; i<peeled\_mc3; i+=3*PacketSize)
01722     \{
01723       \textcolor{keywordflow}{if}(PanelMode) count += (3*PacketSize) * offset;
01724 
01725       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<depth; k++)
01726       \{
01727         Packet A, B, C;
01728         A = lhs.loadPacket(i+0*PacketSize, k);
01729         B = lhs.loadPacket(i+1*PacketSize, k);
01730         C = lhs.loadPacket(i+2*PacketSize, k);
01731         pstore(blockA+count, cj.pconj(A)); count+=PacketSize;
01732         pstore(blockA+count, cj.pconj(B)); count+=PacketSize;
01733         pstore(blockA+count, cj.pconj(C)); count+=PacketSize;
01734       \}
01735       \textcolor{keywordflow}{if}(PanelMode) count += (3*PacketSize) * (stride-offset-depth);
01736     \}
01737   \}
01738   \textcolor{comment}{// Pack 2 packets}
01739   \textcolor{keywordflow}{if}(Pack1>=2*PacketSize)
01740   \{
01741     \textcolor{keywordflow}{for}(; i<peeled\_mc2; i+=2*PacketSize)
01742     \{
01743       \textcolor{keywordflow}{if}(PanelMode) count += (2*PacketSize) * offset;
01744 
01745       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<depth; k++)
01746       \{
01747         Packet A, B;
01748         A = lhs.loadPacket(i+0*PacketSize, k);
01749         B = lhs.loadPacket(i+1*PacketSize, k);
01750         pstore(blockA+count, cj.pconj(A)); count+=PacketSize;
01751         pstore(blockA+count, cj.pconj(B)); count+=PacketSize;
01752       \}
01753       \textcolor{keywordflow}{if}(PanelMode) count += (2*PacketSize) * (stride-offset-depth);
01754     \}
01755   \}
01756   \textcolor{comment}{// Pack 1 packets}
01757   \textcolor{keywordflow}{if}(Pack1>=1*PacketSize)
01758   \{
01759     \textcolor{keywordflow}{for}(; i<peeled\_mc1; i+=1*PacketSize)
01760     \{
01761       \textcolor{keywordflow}{if}(PanelMode) count += (1*PacketSize) * offset;
01762 
01763       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<depth; k++)
01764       \{
01765         Packet A;
01766         A = lhs.loadPacket(i+0*PacketSize, k);
01767         pstore(blockA+count, cj.pconj(A));
01768         count+=PacketSize;
01769       \}
01770       \textcolor{keywordflow}{if}(PanelMode) count += (1*PacketSize) * (stride-offset-depth);
01771     \}
01772   \}
01773   \textcolor{comment}{// Pack scalars}
01774   \textcolor{keywordflow}{if}(Pack2<PacketSize && Pack2>1)
01775   \{
01776     \textcolor{keywordflow}{for}(; i<peeled\_mc0; i+=Pack2)
01777     \{
01778       \textcolor{keywordflow}{if}(PanelMode) count += Pack2 * offset;
01779 
01780       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<depth; k++)
01781         \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} w=0; w<Pack2; w++)
01782           blockA[count++] = cj(lhs(i+w, k));
01783 
01784       \textcolor{keywordflow}{if}(PanelMode) count += Pack2 * (stride-offset-depth);
01785     \}
01786   \}
01787   \textcolor{keywordflow}{for}(; i<rows; i++)
01788   \{
01789     \textcolor{keywordflow}{if}(PanelMode) count += offset;
01790     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<depth; k++)
01791       blockA[count++] = cj(lhs(i, k));
01792     \textcolor{keywordflow}{if}(PanelMode) count += (stride-offset-depth);
01793   \}
01794 \}
01795 
01796 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} Pack1, \textcolor{keywordtype}{int} Pack2, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{bool} P
      anelMode>
01797 \textcolor{keyword}{struct }gemm\_pack\_lhs<Scalar, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, DataMapper, Pack1, Pack2, \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}, Conjugate, PanelMode>
01798 \{
01799   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DataMapper::LinearMapper LinearMapper;
01800   EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} operator()(Scalar* blockA, \textcolor{keyword}{const} DataMapper& lhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride=0, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset=0);
01801 \};
01802 
01803 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} Pack1, \textcolor{keywordtype}{int} Pack2, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{bool} P
      anelMode>
01804 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} gemm\_pack\_lhs<Scalar, Index, DataMapper, Pack1, Pack2, RowMajor, Conjugate,
       PanelMode>
01805   ::operator()(Scalar* blockA, \textcolor{keyword}{const} DataMapper& lhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} rows, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset)
01806 \{
01807   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::type Packet;
01808   \textcolor{keyword}{enum} \{ PacketSize = packet\_traits<Scalar>::size \};
01809 
01810   EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"EIGEN PRODUCT PACK LHS"});
01811   EIGEN\_UNUSED\_VARIABLE(stride);
01812   EIGEN\_UNUSED\_VARIABLE(offset);
01813   eigen\_assert(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride));
01814   conj\_if<NumTraits<Scalar>::IsComplex && Conjugate> cj;
01815   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} count = 0;
01816 
01817 \textcolor{comment}{//   const Index peeled\_mc3 = Pack1>=3*PacketSize ? (rows/(3*PacketSize))*(3*PacketSize) : 0;}
01818 \textcolor{comment}{//   const Index peeled\_mc2 = Pack1>=2*PacketSize ?
       peeled\_mc3+((rows-peeled\_mc3)/(2*PacketSize))*(2*PacketSize) : 0;}
01819 \textcolor{comment}{//   const Index peeled\_mc1 = Pack1>=1*PacketSize ? (rows/(1*PacketSize))*(1*PacketSize) : 0;}
01820 
01821   \textcolor{keywordtype}{int} pack = Pack1;
01822   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0;
01823   \textcolor{keywordflow}{while}(pack>0)
01824   \{
01825     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} remaining\_rows = rows-i;
01826     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeled\_mc = i+(remaining\_rows/pack)*pack;
01827     \textcolor{keywordflow}{for}(; i<peeled\_mc; i+=pack)
01828     \{
01829       \textcolor{keywordflow}{if}(PanelMode) count += pack * offset;
01830 
01831       \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeled\_k = (depth/PacketSize)*PacketSize;
01832       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0;
01833       \textcolor{keywordflow}{if}(pack>=PacketSize)
01834       \{
01835         \textcolor{keywordflow}{for}(; k<peeled\_k; k+=PacketSize)
01836         \{
01837           \textcolor{keywordflow}{for} (\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m = 0; m < pack; m += PacketSize)
01838           \{
01839             PacketBlock<Packet> kernel;
01840             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} p = 0; p < PacketSize; ++p) kernel.packet[p] = lhs.loadPacket(i+p+m, k);
01841             ptranspose(kernel);
01842             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} p = 0; p < PacketSize; ++p) pstore(blockA+count+m+(pack)*p, cj.pconj(kernel.packet[p])
      );
01843           \}
01844           count += PacketSize*pack;
01845         \}
01846       \}
01847       \textcolor{keywordflow}{for}(; k<depth; k++)
01848       \{
01849         \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} w=0;
01850         \textcolor{keywordflow}{for}(; w<pack-3; w+=4)
01851         \{
01852           Scalar a(cj(lhs(i+w+0, k))),
01853                  b(cj(lhs(i+w+1, k))),
01854                  c(cj(lhs(i+w+2, k))),
01855                  d(cj(lhs(i+w+3, k)));
01856           blockA[count++] = a;
01857           blockA[count++] = b;
01858           blockA[count++] = c;
01859           blockA[count++] = d;
01860         \}
01861         \textcolor{keywordflow}{if}(pack%4)
01862           \textcolor{keywordflow}{for}(;w<pack;++w)
01863             blockA[count++] = cj(lhs(i+w, k));
01864       \}
01865 
01866       \textcolor{keywordflow}{if}(PanelMode) count += pack * (stride-offset-depth);
01867     \}
01868 
01869     pack -= PacketSize;
01870     \textcolor{keywordflow}{if}(pack<Pack2 && (pack+PacketSize)!=Pack2)
01871       pack = Pack2;
01872   \}
01873 
01874   \textcolor{keywordflow}{for}(; i<rows; i++)
01875   \{
01876     \textcolor{keywordflow}{if}(PanelMode) count += offset;
01877     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<depth; k++)
01878       blockA[count++] = cj(lhs(i, k));
01879     \textcolor{keywordflow}{if}(PanelMode) count += (stride-offset-depth);
01880   \}
01881 \}
01882 
01883 \textcolor{comment}{// copy a complete panel of the rhs}
01884 \textcolor{comment}{// this version is optimized for column major matrices}
01885 \textcolor{comment}{// The traversal order is as follow: (nr==4):}
01886 \textcolor{comment}{//  0  1  2  3   12 13 14 15   24 27}
01887 \textcolor{comment}{//  4  5  6  7   16 17 18 19   25 28}
01888 \textcolor{comment}{//  8  9 10 11   20 21 22 23   26 29}
01889 \textcolor{comment}{//  .  .  .  .    .  .  .  .    .  .}
01890 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} nr, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{bool} PanelMode>
01891 \textcolor{keyword}{struct }gemm\_pack\_rhs<Scalar, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, DataMapper, nr, \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}, Conjugate, PanelMode>
01892 \{
01893   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::type Packet;
01894   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DataMapper::LinearMapper LinearMapper;
01895   \textcolor{keyword}{enum} \{ PacketSize = packet\_traits<Scalar>::size \};
01896   EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} operator()(Scalar* blockB, \textcolor{keyword}{const} DataMapper& rhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride=0, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset=0);
01897 \};
01898 
01899 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} nr, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{bool} PanelMode>
01900 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} gemm\_pack\_rhs<Scalar, Index, DataMapper, nr, ColMajor, Conjugate, PanelMode>
01901   ::operator()(Scalar* blockB, \textcolor{keyword}{const} DataMapper& rhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset)
01902 \{
01903   EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"EIGEN PRODUCT PACK RHS COLMAJOR"});
01904   EIGEN\_UNUSED\_VARIABLE(stride);
01905   EIGEN\_UNUSED\_VARIABLE(offset);
01906   eigen\_assert(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride));
01907   conj\_if<NumTraits<Scalar>::IsComplex && Conjugate> cj;
01908   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} packet\_cols8 = nr>=8 ? (cols/8) * 8 : 0;
01909   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} packet\_cols4 = nr>=4 ? (cols/4) * 4 : 0;
01910   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} count = 0;
01911   \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} peeled\_k = (depth/PacketSize)*PacketSize;
01912 \textcolor{comment}{//   if(nr>=8)}
01913 \textcolor{comment}{//   \{}
01914 \textcolor{comment}{//     for(Index j2=0; j2<packet\_cols8; j2+=8)}
01915 \textcolor{comment}{//     \{}
01916 \textcolor{comment}{//       // skip what we have before}
01917 \textcolor{comment}{//       if(PanelMode) count += 8 * offset;}
01918 \textcolor{comment}{//       const Scalar* b0 = &rhs[(j2+0)*rhsStride];}
01919 \textcolor{comment}{//       const Scalar* b1 = &rhs[(j2+1)*rhsStride];}
01920 \textcolor{comment}{//       const Scalar* b2 = &rhs[(j2+2)*rhsStride];}
01921 \textcolor{comment}{//       const Scalar* b3 = &rhs[(j2+3)*rhsStride];}
01922 \textcolor{comment}{//       const Scalar* b4 = &rhs[(j2+4)*rhsStride];}
01923 \textcolor{comment}{//       const Scalar* b5 = &rhs[(j2+5)*rhsStride];}
01924 \textcolor{comment}{//       const Scalar* b6 = &rhs[(j2+6)*rhsStride];}
01925 \textcolor{comment}{//       const Scalar* b7 = &rhs[(j2+7)*rhsStride];}
01926 \textcolor{comment}{//       Index k=0;}
01927 \textcolor{comment}{//       if(PacketSize==8) // TODO enbale vectorized transposition for PacketSize==4}
01928 \textcolor{comment}{//       \{}
01929 \textcolor{comment}{//         for(; k<peeled\_k; k+=PacketSize) \{}
01930 \textcolor{comment}{//           PacketBlock<Packet> kernel;}
01931 \textcolor{comment}{//           for (int p = 0; p < PacketSize; ++p) \{}
01932 \textcolor{comment}{//             kernel.packet[p] = ploadu<Packet>(&rhs[(j2+p)*rhsStride+k]);}
01933 \textcolor{comment}{//           \}}
01934 \textcolor{comment}{//           ptranspose(kernel);}
01935 \textcolor{comment}{//           for (int p = 0; p < PacketSize; ++p) \{}
01936 \textcolor{comment}{//             pstoreu(blockB+count, cj.pconj(kernel.packet[p]));}
01937 \textcolor{comment}{//             count+=PacketSize;}
01938 \textcolor{comment}{//           \}}
01939 \textcolor{comment}{//         \}}
01940 \textcolor{comment}{//       \}}
01941 \textcolor{comment}{//       for(; k<depth; k++)}
01942 \textcolor{comment}{//       \{}
01943 \textcolor{comment}{//         blockB[count+0] = cj(b0[k]);}
01944 \textcolor{comment}{//         blockB[count+1] = cj(b1[k]);}
01945 \textcolor{comment}{//         blockB[count+2] = cj(b2[k]);}
01946 \textcolor{comment}{//         blockB[count+3] = cj(b3[k]);}
01947 \textcolor{comment}{//         blockB[count+4] = cj(b4[k]);}
01948 \textcolor{comment}{//         blockB[count+5] = cj(b5[k]);}
01949 \textcolor{comment}{//         blockB[count+6] = cj(b6[k]);}
01950 \textcolor{comment}{//         blockB[count+7] = cj(b7[k]);}
01951 \textcolor{comment}{//         count += 8;}
01952 \textcolor{comment}{//       \}}
01953 \textcolor{comment}{//       // skip what we have after}
01954 \textcolor{comment}{//       if(PanelMode) count += 8 * (stride-offset-depth);}
01955 \textcolor{comment}{//     \}}
01956 \textcolor{comment}{//   \}}
01957 
01958   \textcolor{keywordflow}{if}(nr>=4)
01959   \{
01960     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=packet\_cols8; j2<packet\_cols4; j2+=4)
01961     \{
01962       \textcolor{comment}{// skip what we have before}
01963       \textcolor{keywordflow}{if}(PanelMode) count += 4 * offset;
01964       \textcolor{keyword}{const} LinearMapper dm0 = rhs.getLinearMapper(0, j2 + 0);
01965       \textcolor{keyword}{const} LinearMapper dm1 = rhs.getLinearMapper(0, j2 + 1);
01966       \textcolor{keyword}{const} LinearMapper dm2 = rhs.getLinearMapper(0, j2 + 2);
01967       \textcolor{keyword}{const} LinearMapper dm3 = rhs.getLinearMapper(0, j2 + 3);
01968 
01969       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0;
01970       \textcolor{keywordflow}{if}((PacketSize%4)==0) \textcolor{comment}{// TODO enable vectorized transposition for PacketSize==2 ??}
01971       \{
01972         \textcolor{keywordflow}{for}(; k<peeled\_k; k+=PacketSize) \{
01973           PacketBlock<Packet,(PacketSize%4)==0?4:PacketSize> kernel;
01974           kernel.packet[0] = dm0.loadPacket(k);
01975           kernel.packet[1%PacketSize] = dm1.loadPacket(k);
01976           kernel.packet[2%PacketSize] = dm2.loadPacket(k);
01977           kernel.packet[3%PacketSize] = dm3.loadPacket(k);
01978           ptranspose(kernel);
01979           pstoreu(blockB+count+0*PacketSize, cj.pconj(kernel.packet[0]));
01980           pstoreu(blockB+count+1*PacketSize, cj.pconj(kernel.packet[1%PacketSize]));
01981           pstoreu(blockB+count+2*PacketSize, cj.pconj(kernel.packet[2%PacketSize]));
01982           pstoreu(blockB+count+3*PacketSize, cj.pconj(kernel.packet[3%PacketSize]));
01983           count+=4*PacketSize;
01984         \}
01985       \}
01986       \textcolor{keywordflow}{for}(; k<depth; k++)
01987       \{
01988         blockB[count+0] = cj(dm0(k));
01989         blockB[count+1] = cj(dm1(k));
01990         blockB[count+2] = cj(dm2(k));
01991         blockB[count+3] = cj(dm3(k));
01992         count += 4;
01993       \}
01994       \textcolor{comment}{// skip what we have after}
01995       \textcolor{keywordflow}{if}(PanelMode) count += 4 * (stride-offset-depth);
01996     \}
01997   \}
01998 
01999   \textcolor{comment}{// copy the remaining columns one at a time (nr==1)}
02000   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=packet\_cols4; j2<cols; ++j2)
02001   \{
02002     \textcolor{keywordflow}{if}(PanelMode) count += offset;
02003     \textcolor{keyword}{const} LinearMapper dm0 = rhs.getLinearMapper(0, j2);
02004     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<depth; k++)
02005     \{
02006       blockB[count] = cj(dm0(k));
02007       count += 1;
02008     \}
02009     \textcolor{keywordflow}{if}(PanelMode) count += (stride-offset-depth);
02010   \}
02011 \}
02012 
02013 \textcolor{comment}{// this version is optimized for row major matrices}
02014 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} nr, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{bool} PanelMode>
02015 \textcolor{keyword}{struct }gemm\_pack\_rhs<Scalar, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, DataMapper, nr, \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}, Conjugate, PanelMode>
02016 \{
02017   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} packet\_traits<Scalar>::type Packet;
02018   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} DataMapper::LinearMapper LinearMapper;
02019   \textcolor{keyword}{enum} \{ PacketSize = packet\_traits<Scalar>::size \};
02020   EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} operator()(Scalar* blockB, \textcolor{keyword}{const} DataMapper& rhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride=0, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset=0);
02021 \};
02022 
02023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Index, \textcolor{keyword}{typename} DataMapper, \textcolor{keywordtype}{int} nr, \textcolor{keywordtype}{bool} Conjugate, \textcolor{keywordtype}{bool} PanelMode>
02024 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} gemm\_pack\_rhs<Scalar, Index, DataMapper, nr, RowMajor, Conjugate, PanelMode>
02025   ::operator()(Scalar* blockB, \textcolor{keyword}{const} DataMapper& rhs, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} depth, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} cols, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} stride, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset)
02026 \{
02027   EIGEN\_ASM\_COMMENT(\textcolor{stringliteral}{"EIGEN PRODUCT PACK RHS ROWMAJOR"});
02028   EIGEN\_UNUSED\_VARIABLE(stride);
02029   EIGEN\_UNUSED\_VARIABLE(offset);
02030   eigen\_assert(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride));
02031   conj\_if<NumTraits<Scalar>::IsComplex && Conjugate> cj;
02032   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} packet\_cols8 = nr>=8 ? (cols/8) * 8 : 0;
02033   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} packet\_cols4 = nr>=4 ? (cols/4) * 4 : 0;
02034   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} count = 0;
02035 
02036 \textcolor{comment}{//   if(nr>=8)}
02037 \textcolor{comment}{//   \{}
02038 \textcolor{comment}{//     for(Index j2=0; j2<packet\_cols8; j2+=8)}
02039 \textcolor{comment}{//     \{}
02040 \textcolor{comment}{//       // skip what we have before}
02041 \textcolor{comment}{//       if(PanelMode) count += 8 * offset;}
02042 \textcolor{comment}{//       for(Index k=0; k<depth; k++)}
02043 \textcolor{comment}{//       \{}
02044 \textcolor{comment}{//         if (PacketSize==8) \{}
02045 \textcolor{comment}{//           Packet A = ploadu<Packet>(&rhs[k*rhsStride + j2]);}
02046 \textcolor{comment}{//           pstoreu(blockB+count, cj.pconj(A));}
02047 \textcolor{comment}{//         \} else if (PacketSize==4) \{}
02048 \textcolor{comment}{//           Packet A = ploadu<Packet>(&rhs[k*rhsStride + j2]);}
02049 \textcolor{comment}{//           Packet B = ploadu<Packet>(&rhs[k*rhsStride + j2 + PacketSize]);}
02050 \textcolor{comment}{//           pstoreu(blockB+count, cj.pconj(A));}
02051 \textcolor{comment}{//           pstoreu(blockB+count+PacketSize, cj.pconj(B));}
02052 \textcolor{comment}{//         \} else \{}
02053 \textcolor{comment}{//           const Scalar* b0 = &rhs[k*rhsStride + j2];}
02054 \textcolor{comment}{//           blockB[count+0] = cj(b0[0]);}
02055 \textcolor{comment}{//           blockB[count+1] = cj(b0[1]);}
02056 \textcolor{comment}{//           blockB[count+2] = cj(b0[2]);}
02057 \textcolor{comment}{//           blockB[count+3] = cj(b0[3]);}
02058 \textcolor{comment}{//           blockB[count+4] = cj(b0[4]);}
02059 \textcolor{comment}{//           blockB[count+5] = cj(b0[5]);}
02060 \textcolor{comment}{//           blockB[count+6] = cj(b0[6]);}
02061 \textcolor{comment}{//           blockB[count+7] = cj(b0[7]);}
02062 \textcolor{comment}{//         \}}
02063 \textcolor{comment}{//         count += 8;}
02064 \textcolor{comment}{//       \}}
02065 \textcolor{comment}{//       // skip what we have after}
02066 \textcolor{comment}{//       if(PanelMode) count += 8 * (stride-offset-depth);}
02067 \textcolor{comment}{//     \}}
02068 \textcolor{comment}{//   \}}
02069   \textcolor{keywordflow}{if}(nr>=4)
02070   \{
02071     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=packet\_cols8; j2<packet\_cols4; j2+=4)
02072     \{
02073       \textcolor{comment}{// skip what we have before}
02074       \textcolor{keywordflow}{if}(PanelMode) count += 4 * offset;
02075       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<depth; k++)
02076       \{
02077         \textcolor{keywordflow}{if} (PacketSize==4) \{
02078           Packet A = rhs.loadPacket(k, j2);
02079           pstoreu(blockB+count, cj.pconj(A));
02080           count += PacketSize;
02081         \} \textcolor{keywordflow}{else} \{
02082           \textcolor{keyword}{const} LinearMapper dm0 = rhs.getLinearMapper(k, j2);
02083           blockB[count+0] = cj(dm0(0));
02084           blockB[count+1] = cj(dm0(1));
02085           blockB[count+2] = cj(dm0(2));
02086           blockB[count+3] = cj(dm0(3));
02087           count += 4;
02088         \}
02089       \}
02090       \textcolor{comment}{// skip what we have after}
02091       \textcolor{keywordflow}{if}(PanelMode) count += 4 * (stride-offset-depth);
02092     \}
02093   \}
02094   \textcolor{comment}{// copy the remaining columns one at a time (nr==1)}
02095   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j2=packet\_cols4; j2<cols; ++j2)
02096   \{
02097     \textcolor{keywordflow}{if}(PanelMode) count += offset;
02098     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} k=0; k<depth; k++)
02099     \{
02100       blockB[count] = cj(rhs(k, j2));
02101       count += 1;
02102     \}
02103     \textcolor{keywordflow}{if}(PanelMode) count += stride-offset-depth;
02104   \}
02105 \}
02106 
02107 \} \textcolor{comment}{// end namespace internal}
02108 
02111 \textcolor{keyword}{inline} std::ptrdiff\_t \hyperlink{namespace_eigen_a2669f89ff38296a38e6d973552eb4e33}{l1CacheSize}()
02112 \{
02113   std::ptrdiff\_t l1, l2, l3;
02114   internal::manage\_caching\_sizes(GetAction, &l1, &l2, &l3);
02115   \textcolor{keywordflow}{return} l1;
02116 \}
02117 
02120 \textcolor{keyword}{inline} std::ptrdiff\_t \hyperlink{namespace_eigen_a2cfc0330ba567d63a496be1cac8427ae}{l2CacheSize}()
02121 \{
02122   std::ptrdiff\_t l1, l2, l3;
02123   internal::manage\_caching\_sizes(GetAction, &l1, &l2, &l3);
02124   \textcolor{keywordflow}{return} l2;
02125 \}
02126 
02130 \textcolor{keyword}{inline} std::ptrdiff\_t \hyperlink{namespace_eigen_ae2efa4852ea90c2d47b7dcec5b40ba2b}{l3CacheSize}()
02131 \{
02132   std::ptrdiff\_t l1, l2, l3;
02133   internal::manage\_caching\_sizes(GetAction, &l1, &l2, &l3);
02134   \textcolor{keywordflow}{return} l3;
02135 \}
02136 
02142 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{namespace_eigen_ae64421554aa0a4bf9258bafe3170102b}{setCpuCacheSizes}(std::ptrdiff\_t l1, std::ptrdiff\_t l2, std::ptrdiff\_t l3)
02143 \{
02144   internal::manage\_caching\_sizes(SetAction, &l1, &l2, &l3);
02145 \}
02146 
02147 \} \textcolor{comment}{// end namespace Eigen}
02148 
02149 \textcolor{preprocessor}{#endif // EIGEN\_GENERAL\_BLOCK\_PANEL\_H}
\end{DoxyCode}
