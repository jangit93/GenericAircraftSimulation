\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_a_v_x512_2_math_functions_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/arch/\+A\+V\+X512/\+Math\+Functions.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_a_v_x512_2_math_functions_8h_source}\index{Math\+Functions.\+h@{Math\+Functions.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2016 Pedro Gonnet (pedro.gonnet@gmail.com)}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef THIRD\_PARTY\_EIGEN3\_EIGEN\_SRC\_CORE\_ARCH\_AVX512\_MATHFUNCTIONS\_H\_}
00011 \textcolor{preprocessor}{#define THIRD\_PARTY\_EIGEN3\_EIGEN\_SRC\_CORE\_ARCH\_AVX512\_MATHFUNCTIONS\_H\_}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{comment}{// Disable the code for older versions of gcc that don't support many of the required avx512 instrinsics.}
00018 \textcolor{preprocessor}{#if EIGEN\_GNUC\_AT\_LEAST(5, 3)}
00019 
00020 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet16f(NAME, X) \(\backslash\)}
00021 \textcolor{preprocessor}{  const Packet16f p16f\_##NAME = pset1<Packet16f>(X)}
00022 
00023 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet16f\_FROM\_INT(NAME, X) \(\backslash\)}
00024 \textcolor{preprocessor}{  const Packet16f p16f\_##NAME = (\_\_m512)pset1<Packet16i>(X)}
00025 
00026 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet8d(NAME, X) \(\backslash\)}
00027 \textcolor{preprocessor}{  const Packet8d p8d\_##NAME = pset1<Packet8d>(X)}
00028 
00029 \textcolor{preprocessor}{#define \_EIGEN\_DECLARE\_CONST\_Packet8d\_FROM\_INT64(NAME, X) \(\backslash\)}
00030 \textcolor{preprocessor}{  const Packet8d p8d\_##NAME = \_mm512\_castsi512\_pd(\_mm512\_set1\_epi64(X))}
00031 
00032 \textcolor{comment}{// Natural logarithm}
00033 \textcolor{comment}{// Computes log(x) as log(2^e * m) = C*e + log(m), where the constant C =log(2)}
00034 \textcolor{comment}{// and m is in the range [sqrt(1/2),sqrt(2)). In this range, the logarithm can}
00035 \textcolor{comment}{// be easily approximated by a polynomial centered on m=1 for stability.}
00036 \textcolor{preprocessor}{#if defined(EIGEN\_VECTORIZE\_AVX512DQ)}
00037 \textcolor{keyword}{template} <>
00038 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet16f
00039 plog<Packet16f>(\textcolor{keyword}{const} Packet16f& \_x) \{
00040   Packet16f x = \_x;
00041   \_EIGEN\_DECLARE\_CONST\_Packet16f(1, 1.0f);
00042   \_EIGEN\_DECLARE\_CONST\_Packet16f(half, 0.5f);
00043   \_EIGEN\_DECLARE\_CONST\_Packet16f(126f, 126.0f);
00044 
00045   \_EIGEN\_DECLARE\_CONST\_Packet16f\_FROM\_INT(inv\_mant\_mask, ~0x7f800000);
00046 
00047   \textcolor{comment}{// The smallest non denormalized float number.}
00048   \_EIGEN\_DECLARE\_CONST\_Packet16f\_FROM\_INT(min\_norm\_pos, 0x00800000);
00049   \_EIGEN\_DECLARE\_CONST\_Packet16f\_FROM\_INT(minus\_inf, 0xff800000);
00050   \_EIGEN\_DECLARE\_CONST\_Packet16f\_FROM\_INT(nan, 0x7fc00000);
00051 
00052   \textcolor{comment}{// Polynomial coefficients.}
00053   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_SQRTHF, 0.707106781186547524f);
00054   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_log\_p0, 7.0376836292E-2f);
00055   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_log\_p1, -1.1514610310E-1f);
00056   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_log\_p2, 1.1676998740E-1f);
00057   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_log\_p3, -1.2420140846E-1f);
00058   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_log\_p4, +1.4249322787E-1f);
00059   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_log\_p5, -1.6668057665E-1f);
00060   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_log\_p6, +2.0000714765E-1f);
00061   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_log\_p7, -2.4999993993E-1f);
00062   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_log\_p8, +3.3333331174E-1f);
00063   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_log\_q1, -2.12194440e-4f);
00064   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_log\_q2, 0.693359375f);
00065 
00066   \textcolor{comment}{// invalid\_mask is set to true when x is NaN}
00067   \_\_mmask16 invalid\_mask =
00068       \_mm512\_cmp\_ps\_mask(x, \_mm512\_setzero\_ps(), \_CMP\_NGE\_UQ);
00069   \_\_mmask16 iszero\_mask =
00070       \_mm512\_cmp\_ps\_mask(x, \_mm512\_setzero\_ps(), \_CMP\_EQ\_UQ);
00071 
00072   \textcolor{comment}{// Truncate input values to the minimum positive normal.}
00073   x = pmax(x, p16f\_min\_norm\_pos);
00074 
00075   \textcolor{comment}{// Extract the shifted exponents.}
00076   Packet16f emm0 = \_mm512\_cvtepi32\_ps(\_mm512\_srli\_epi32((\_\_m512i)x, 23));
00077   Packet16f e = \_mm512\_sub\_ps(emm0, p16f\_126f);
00078 
00079   \textcolor{comment}{// Set the exponents to -1, i.e. x are in the range [0.5,1).}
00080   x = \_mm512\_and\_ps(x, p16f\_inv\_mant\_mask);
00081   x = \_mm512\_or\_ps(x, p16f\_half);
00082 
00083   \textcolor{comment}{// part2: Shift the inputs from the range [0.5,1) to [sqrt(1/2),sqrt(2))}
00084   \textcolor{comment}{// and shift by -1. The values are then centered around 0, which improves}
00085   \textcolor{comment}{// the stability of the polynomial evaluation.}
00086   \textcolor{comment}{//   if( x < SQRTHF ) \{}
00087   \textcolor{comment}{//     e -= 1;}
00088   \textcolor{comment}{//     x = x + x - 1.0;}
00089   \textcolor{comment}{//   \} else \{ x = x - 1.0; \}}
00090   \_\_mmask16 mask = \_mm512\_cmp\_ps\_mask(x, p16f\_cephes\_SQRTHF, \_CMP\_LT\_OQ);
00091   Packet16f tmp = \_mm512\_mask\_blend\_ps(mask, x, \_mm512\_setzero\_ps());
00092   x = psub(x, p16f\_1);
00093   e = psub(e, \_mm512\_mask\_blend\_ps(mask, p16f\_1, \_mm512\_setzero\_ps()));
00094   x = padd(x, tmp);
00095 
00096   Packet16f x2 = pmul(x, x);
00097   Packet16f x3 = pmul(x2, x);
00098 
00099   \textcolor{comment}{// Evaluate the polynomial approximant of degree 8 in three parts, probably}
00100   \textcolor{comment}{// to improve instruction-level parallelism.}
00101   Packet16f y, y1, y2;
00102   y = pmadd(p16f\_cephes\_log\_p0, x, p16f\_cephes\_log\_p1);
00103   y1 = pmadd(p16f\_cephes\_log\_p3, x, p16f\_cephes\_log\_p4);
00104   y2 = pmadd(p16f\_cephes\_log\_p6, x, p16f\_cephes\_log\_p7);
00105   y = pmadd(y, x, p16f\_cephes\_log\_p2);
00106   y1 = pmadd(y1, x, p16f\_cephes\_log\_p5);
00107   y2 = pmadd(y2, x, p16f\_cephes\_log\_p8);
00108   y = pmadd(y, x3, y1);
00109   y = pmadd(y, x3, y2);
00110   y = pmul(y, x3);
00111 
00112   \textcolor{comment}{// Add the logarithm of the exponent back to the result of the interpolation.}
00113   y1 = pmul(e, p16f\_cephes\_log\_q1);
00114   tmp = pmul(x2, p16f\_half);
00115   y = padd(y, y1);
00116   x = psub(x, tmp);
00117   y2 = pmul(e, p16f\_cephes\_log\_q2);
00118   x = padd(x, y);
00119   x = padd(x, y2);
00120 
00121   \textcolor{comment}{// Filter out invalid inputs, i.e. negative arg will be NAN, 0 will be -INF.}
00122   \textcolor{keywordflow}{return} \_mm512\_mask\_blend\_ps(iszero\_mask, p16f\_minus\_inf,
00123                               \_mm512\_mask\_blend\_ps(invalid\_mask, p16f\_nan, x));
00124 \}
00125 \textcolor{preprocessor}{#endif}
00126 
00127 \textcolor{comment}{// Exponential function. Works by writing "x = m*log(2) + r" where}
00128 \textcolor{comment}{// "m = floor(x/log(2)+1/2)" and "r" is the remainder. The result is then}
00129 \textcolor{comment}{// "exp(x) = 2^m*exp(r)" where exp(r) is in the range [-1,1).}
00130 \textcolor{keyword}{template} <>
00131 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet16f
00132 pexp<Packet16f>(\textcolor{keyword}{const} Packet16f& \_x) \{
00133   \_EIGEN\_DECLARE\_CONST\_Packet16f(1, 1.0f);
00134   \_EIGEN\_DECLARE\_CONST\_Packet16f(half, 0.5f);
00135   \_EIGEN\_DECLARE\_CONST\_Packet16f(127, 127.0f);
00136 
00137   \_EIGEN\_DECLARE\_CONST\_Packet16f(exp\_hi, 88.3762626647950f);
00138   \_EIGEN\_DECLARE\_CONST\_Packet16f(exp\_lo, -88.3762626647949f);
00139 
00140   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_LOG2EF, 1.44269504088896341f);
00141 
00142   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_exp\_p0, 1.9875691500E-4f);
00143   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_exp\_p1, 1.3981999507E-3f);
00144   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_exp\_p2, 8.3334519073E-3f);
00145   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_exp\_p3, 4.1665795894E-2f);
00146   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_exp\_p4, 1.6666665459E-1f);
00147   \_EIGEN\_DECLARE\_CONST\_Packet16f(cephes\_exp\_p5, 5.0000001201E-1f);
00148 
00149   \textcolor{comment}{// Clamp x.}
00150   Packet16f x = pmax(pmin(\_x, p16f\_exp\_hi), p16f\_exp\_lo);
00151 
00152   \textcolor{comment}{// Express exp(x) as exp(m*ln(2) + r), start by extracting}
00153   \textcolor{comment}{// m = floor(x/ln(2) + 0.5).}
00154   Packet16f m = \_mm512\_floor\_ps(pmadd(x, p16f\_cephes\_LOG2EF, p16f\_half));
00155 
00156   \textcolor{comment}{// Get r = x - m*ln(2). Note that we can do this without losing more than one}
00157   \textcolor{comment}{// ulp precision due to the FMA instruction.}
00158   \_EIGEN\_DECLARE\_CONST\_Packet16f(nln2, -0.6931471805599453f);
00159   Packet16f r = \_mm512\_fmadd\_ps(m, p16f\_nln2, x);
00160   Packet16f r2 = pmul(r, r);
00161 
00162   \textcolor{comment}{// TODO(gonnet): Split into odd/even polynomials and try to exploit}
00163   \textcolor{comment}{//               instruction-level parallelism.}
00164   Packet16f y = p16f\_cephes\_exp\_p0;
00165   y = pmadd(y, r, p16f\_cephes\_exp\_p1);
00166   y = pmadd(y, r, p16f\_cephes\_exp\_p2);
00167   y = pmadd(y, r, p16f\_cephes\_exp\_p3);
00168   y = pmadd(y, r, p16f\_cephes\_exp\_p4);
00169   y = pmadd(y, r, p16f\_cephes\_exp\_p5);
00170   y = pmadd(y, r2, r);
00171   y = padd(y, p16f\_1);
00172 
00173   \textcolor{comment}{// Build emm0 = 2^m.}
00174   Packet16i emm0 = \_mm512\_cvttps\_epi32(padd(m, p16f\_127));
00175   emm0 = \_mm512\_slli\_epi32(emm0, 23);
00176 
00177   \textcolor{comment}{// Return 2^m * exp(r).}
00178   \textcolor{keywordflow}{return} pmax(pmul(y, \_mm512\_castsi512\_ps(emm0)), \_x);
00179 \}
00180 
00181 \textcolor{comment}{/*template <>}
00182 \textcolor{comment}{EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet8d}
00183 \textcolor{comment}{pexp<Packet8d>(const Packet8d& \_x) \{}
00184 \textcolor{comment}{  Packet8d x = \_x;}
00185 \textcolor{comment}{}
00186 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(1, 1.0);}
00187 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(2, 2.0);}
00188 \textcolor{comment}{}
00189 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(exp\_hi, 709.437);}
00190 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(exp\_lo, -709.436139303);}
00191 \textcolor{comment}{}
00192 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(cephes\_LOG2EF, 1.4426950408889634073599);}
00193 \textcolor{comment}{}
00194 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(cephes\_exp\_p0, 1.26177193074810590878e-4);}
00195 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(cephes\_exp\_p1, 3.02994407707441961300e-2);}
00196 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(cephes\_exp\_p2, 9.99999999999999999910e-1);}
00197 \textcolor{comment}{}
00198 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(cephes\_exp\_q0, 3.00198505138664455042e-6);}
00199 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(cephes\_exp\_q1, 2.52448340349684104192e-3);}
00200 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(cephes\_exp\_q2, 2.27265548208155028766e-1);}
00201 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(cephes\_exp\_q3, 2.00000000000000000009e0);}
00202 \textcolor{comment}{}
00203 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(cephes\_exp\_C1, 0.693145751953125);}
00204 \textcolor{comment}{  \_EIGEN\_DECLARE\_CONST\_Packet8d(cephes\_exp\_C2, 1.42860682030941723212e-6);}
00205 \textcolor{comment}{}
00206 \textcolor{comment}{  // clamp x}
00207 \textcolor{comment}{  x = pmax(pmin(x, p8d\_exp\_hi), p8d\_exp\_lo);}
00208 \textcolor{comment}{}
00209 \textcolor{comment}{  // Express exp(x) as exp(g + n*log(2)).}
00210 \textcolor{comment}{  const Packet8d n =}
00211 \textcolor{comment}{      \_mm512\_mul\_round\_pd(p8d\_cephes\_LOG2EF, x, \_MM\_FROUND\_TO\_NEAREST\_INT);}
00212 \textcolor{comment}{}
00213 \textcolor{comment}{  // Get the remainder modulo log(2), i.e. the "g" described above. Subtract}
00214 \textcolor{comment}{  // n*log(2) out in two steps, i.e. n*C1 + n*C2, C1+C2=log2 to get the last}
00215 \textcolor{comment}{  // digits right.}
00216 \textcolor{comment}{  const Packet8d nC1 = pmul(n, p8d\_cephes\_exp\_C1);}
00217 \textcolor{comment}{  const Packet8d nC2 = pmul(n, p8d\_cephes\_exp\_C2);}
00218 \textcolor{comment}{  x = psub(x, nC1);}
00219 \textcolor{comment}{  x = psub(x, nC2);}
00220 \textcolor{comment}{}
00221 \textcolor{comment}{  const Packet8d x2 = pmul(x, x);}
00222 \textcolor{comment}{}
00223 \textcolor{comment}{  // Evaluate the numerator polynomial of the rational interpolant.}
00224 \textcolor{comment}{  Packet8d px = p8d\_cephes\_exp\_p0;}
00225 \textcolor{comment}{  px = pmadd(px, x2, p8d\_cephes\_exp\_p1);}
00226 \textcolor{comment}{  px = pmadd(px, x2, p8d\_cephes\_exp\_p2);}
00227 \textcolor{comment}{  px = pmul(px, x);}
00228 \textcolor{comment}{}
00229 \textcolor{comment}{  // Evaluate the denominator polynomial of the rational interpolant.}
00230 \textcolor{comment}{  Packet8d qx = p8d\_cephes\_exp\_q0;}
00231 \textcolor{comment}{  qx = pmadd(qx, x2, p8d\_cephes\_exp\_q1);}
00232 \textcolor{comment}{  qx = pmadd(qx, x2, p8d\_cephes\_exp\_q2);}
00233 \textcolor{comment}{  qx = pmadd(qx, x2, p8d\_cephes\_exp\_q3);}
00234 \textcolor{comment}{}
00235 \textcolor{comment}{  // I don't really get this bit, copied from the SSE2 routines, so...}
00236 \textcolor{comment}{  // TODO(gonnet): Figure out what is going on here, perhaps find a better}
00237 \textcolor{comment}{  // rational interpolant?}
00238 \textcolor{comment}{  x = \_mm512\_div\_pd(px, psub(qx, px));}
00239 \textcolor{comment}{  x = pmadd(p8d\_2, x, p8d\_1);}
00240 \textcolor{comment}{}
00241 \textcolor{comment}{  // Build e=2^n.}
00242 \textcolor{comment}{  const Packet8d e = \_mm512\_castsi512\_pd(\_mm512\_slli\_epi64(}
00243 \textcolor{comment}{      \_mm512\_add\_epi64(\_mm512\_cvtpd\_epi64(n), \_mm512\_set1\_epi64(1023)), 52));}
00244 \textcolor{comment}{}
00245 \textcolor{comment}{  // Construct the result 2^n * exp(g) = e * x. The max is used to catch}
00246 \textcolor{comment}{  // non-finite values in the input.}
00247 \textcolor{comment}{  return pmax(pmul(x, e), \_x);}
00248 \textcolor{comment}{  \}*/}
00249 
00250 \textcolor{comment}{// Functions for sqrt.}
00251 \textcolor{comment}{// The EIGEN\_FAST\_MATH version uses the \_mm\_rsqrt\_ps approximation and one step}
00252 \textcolor{comment}{// of Newton's method, at a cost of 1-2 bits of precision as opposed to the}
00253 \textcolor{comment}{// exact solution. The main advantage of this approach is not just speed, but}
00254 \textcolor{comment}{// also the fact that it can be inlined and pipelined with other computations,}
00255 \textcolor{comment}{// further reducing its effective latency.}
00256 \textcolor{preprocessor}{#if EIGEN\_FAST\_MATH}
00257 \textcolor{keyword}{template} <>
00258 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet16f
00259 psqrt<Packet16f>(\textcolor{keyword}{const} Packet16f& \_x) \{
00260   \_EIGEN\_DECLARE\_CONST\_Packet16f(one\_point\_five, 1.5f);
00261   \_EIGEN\_DECLARE\_CONST\_Packet16f(minus\_half, -0.5f);
00262   \_EIGEN\_DECLARE\_CONST\_Packet16f\_FROM\_INT(flt\_min, 0x00800000);
00263 
00264   Packet16f neg\_half = pmul(\_x, p16f\_minus\_half);
00265 
00266   \textcolor{comment}{// select only the inverse sqrt of positive normal inputs (denormals are}
00267   \textcolor{comment}{// flushed to zero and cause infs as well).}
00268   \_\_mmask16 non\_zero\_mask = \_mm512\_cmp\_ps\_mask(\_x, p16f\_flt\_min, \_CMP\_GE\_OQ);
00269   Packet16f x = \_mm512\_mask\_blend\_ps(non\_zero\_mask, \_mm512\_rsqrt14\_ps(\_x),
00270                                      \_mm512\_setzero\_ps());
00271 
00272   \textcolor{comment}{// Do a single step of Newton's iteration.}
00273   x = pmul(x, pmadd(neg\_half, pmul(x, x), p16f\_one\_point\_five));
00274 
00275   \textcolor{comment}{// Multiply the original \_x by it's reciprocal square root to extract the}
00276   \textcolor{comment}{// square root.}
00277   \textcolor{keywordflow}{return} pmul(\_x, x);
00278 \}
00279 
00280 \textcolor{keyword}{template} <>
00281 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet8d
00282 psqrt<Packet8d>(\textcolor{keyword}{const} Packet8d& \_x) \{
00283   \_EIGEN\_DECLARE\_CONST\_Packet8d(one\_point\_five, 1.5);
00284   \_EIGEN\_DECLARE\_CONST\_Packet8d(minus\_half, -0.5);
00285   \_EIGEN\_DECLARE\_CONST\_Packet8d\_FROM\_INT64(dbl\_min, 0x0010000000000000LL);
00286 
00287   Packet8d neg\_half = pmul(\_x, p8d\_minus\_half);
00288 
00289   \textcolor{comment}{// select only the inverse sqrt of positive normal inputs (denormals are}
00290   \textcolor{comment}{// flushed to zero and cause infs as well).}
00291   \_\_mmask8 non\_zero\_mask = \_mm512\_cmp\_pd\_mask(\_x, p8d\_dbl\_min, \_CMP\_GE\_OQ);
00292   Packet8d x = \_mm512\_mask\_blend\_pd(non\_zero\_mask, \_mm512\_rsqrt14\_pd(\_x),
00293                                     \_mm512\_setzero\_pd());
00294 
00295   \textcolor{comment}{// Do a first step of Newton's iteration.}
00296   x = pmul(x, pmadd(neg\_half, pmul(x, x), p8d\_one\_point\_five));
00297 
00298   \textcolor{comment}{// Do a second step of Newton's iteration.}
00299   x = pmul(x, pmadd(neg\_half, pmul(x, x), p8d\_one\_point\_five));
00300 
00301   \textcolor{comment}{// Multiply the original \_x by it's reciprocal square root to extract the}
00302   \textcolor{comment}{// square root.}
00303   \textcolor{keywordflow}{return} pmul(\_x, x);
00304 \}
00305 \textcolor{preprocessor}{#else}
00306 \textcolor{keyword}{template} <>
00307 EIGEN\_STRONG\_INLINE Packet16f psqrt<Packet16f>(\textcolor{keyword}{const} Packet16f& x) \{
00308   \textcolor{keywordflow}{return} \_mm512\_sqrt\_ps(x);
00309 \}
00310 \textcolor{keyword}{template} <>
00311 EIGEN\_STRONG\_INLINE Packet8d psqrt<Packet8d>(\textcolor{keyword}{const} Packet8d& x) \{
00312   \textcolor{keywordflow}{return} \_mm512\_sqrt\_pd(x);
00313 \}
00314 \textcolor{preprocessor}{#endif}
00315 
00316 \textcolor{comment}{// Functions for rsqrt.}
00317 \textcolor{comment}{// Almost identical to the sqrt routine, just leave out the last multiplication}
00318 \textcolor{comment}{// and fill in NaN/Inf where needed. Note that this function only exists as an}
00319 \textcolor{comment}{// iterative version for doubles since there is no instruction for diretly}
00320 \textcolor{comment}{// computing the reciprocal square root in AVX-512.}
00321 \textcolor{preprocessor}{#ifdef EIGEN\_FAST\_MATH}
00322 \textcolor{keyword}{template} <>
00323 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet16f
00324 prsqrt<Packet16f>(\textcolor{keyword}{const} Packet16f& \_x) \{
00325   \_EIGEN\_DECLARE\_CONST\_Packet16f\_FROM\_INT(inf, 0x7f800000);
00326   \_EIGEN\_DECLARE\_CONST\_Packet16f\_FROM\_INT(nan, 0x7fc00000);
00327   \_EIGEN\_DECLARE\_CONST\_Packet16f(one\_point\_five, 1.5f);
00328   \_EIGEN\_DECLARE\_CONST\_Packet16f(minus\_half, -0.5f);
00329   \_EIGEN\_DECLARE\_CONST\_Packet16f\_FROM\_INT(flt\_min, 0x00800000);
00330 
00331   Packet16f neg\_half = pmul(\_x, p16f\_minus\_half);
00332 
00333   \textcolor{comment}{// select only the inverse sqrt of positive normal inputs (denormals are}
00334   \textcolor{comment}{// flushed to zero and cause infs as well).}
00335   \_\_mmask16 le\_zero\_mask = \_mm512\_cmp\_ps\_mask(\_x, p16f\_flt\_min, \_CMP\_LT\_OQ);
00336   Packet16f x = \_mm512\_mask\_blend\_ps(le\_zero\_mask, \_mm512\_setzero\_ps(),
00337                                      \_mm512\_rsqrt14\_ps(\_x));
00338 
00339   \textcolor{comment}{// Fill in NaNs and Infs for the negative/zero entries.}
00340   \_\_mmask16 neg\_mask = \_mm512\_cmp\_ps\_mask(\_x, \_mm512\_setzero\_ps(), \_CMP\_LT\_OQ);
00341   Packet16f infs\_and\_nans = \_mm512\_mask\_blend\_ps(
00342       neg\_mask, p16f\_nan,
00343       \_mm512\_mask\_blend\_ps(le\_zero\_mask, p16f\_inf, \_mm512\_setzero\_ps()));
00344 
00345   \textcolor{comment}{// Do a single step of Newton's iteration.}
00346   x = pmul(x, pmadd(neg\_half, pmul(x, x), p16f\_one\_point\_five));
00347 
00348   \textcolor{comment}{// Insert NaNs and Infs in all the right places.}
00349   \textcolor{keywordflow}{return} \_mm512\_mask\_blend\_ps(le\_zero\_mask, infs\_and\_nans, x);
00350 \}
00351 
00352 \textcolor{keyword}{template} <>
00353 EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS EIGEN\_UNUSED Packet8d
00354 prsqrt<Packet8d>(\textcolor{keyword}{const} Packet8d& \_x) \{
00355   \_EIGEN\_DECLARE\_CONST\_Packet8d\_FROM\_INT64(inf, 0x7ff0000000000000LL);
00356   \_EIGEN\_DECLARE\_CONST\_Packet8d\_FROM\_INT64(nan, 0x7ff1000000000000LL);
00357   \_EIGEN\_DECLARE\_CONST\_Packet8d(one\_point\_five, 1.5);
00358   \_EIGEN\_DECLARE\_CONST\_Packet8d(minus\_half, -0.5);
00359   \_EIGEN\_DECLARE\_CONST\_Packet8d\_FROM\_INT64(dbl\_min, 0x0010000000000000LL);
00360 
00361   Packet8d neg\_half = pmul(\_x, p8d\_minus\_half);
00362 
00363   \textcolor{comment}{// select only the inverse sqrt of positive normal inputs (denormals are}
00364   \textcolor{comment}{// flushed to zero and cause infs as well).}
00365   \_\_mmask8 le\_zero\_mask = \_mm512\_cmp\_pd\_mask(\_x, p8d\_dbl\_min, \_CMP\_LT\_OQ);
00366   Packet8d x = \_mm512\_mask\_blend\_pd(le\_zero\_mask, \_mm512\_setzero\_pd(),
00367                                     \_mm512\_rsqrt14\_pd(\_x));
00368 
00369   \textcolor{comment}{// Fill in NaNs and Infs for the negative/zero entries.}
00370   \_\_mmask8 neg\_mask = \_mm512\_cmp\_pd\_mask(\_x, \_mm512\_setzero\_pd(), \_CMP\_LT\_OQ);
00371   Packet8d infs\_and\_nans = \_mm512\_mask\_blend\_pd(
00372       neg\_mask, p8d\_nan,
00373       \_mm512\_mask\_blend\_pd(le\_zero\_mask, p8d\_inf, \_mm512\_setzero\_pd()));
00374 
00375   \textcolor{comment}{// Do a first step of Newton's iteration.}
00376   x = pmul(x, pmadd(neg\_half, pmul(x, x), p8d\_one\_point\_five));
00377 
00378   \textcolor{comment}{// Do a second step of Newton's iteration.}
00379   x = pmul(x, pmadd(neg\_half, pmul(x, x), p8d\_one\_point\_five));
00380 
00381   \textcolor{comment}{// Insert NaNs and Infs in all the right places.}
00382   \textcolor{keywordflow}{return} \_mm512\_mask\_blend\_pd(le\_zero\_mask, infs\_and\_nans, x);
00383 \}
00384 \textcolor{preprocessor}{#else}
00385 \textcolor{keyword}{template} <>
00386 EIGEN\_STRONG\_INLINE Packet16f prsqrt<Packet16f>(\textcolor{keyword}{const} Packet16f& x) \{
00387   \textcolor{keywordflow}{return} \_mm512\_rsqrt28\_ps(x);
00388 \}
00389 \textcolor{preprocessor}{#endif}
00390 \textcolor{preprocessor}{#endif}
00391 
00392 \}  \textcolor{comment}{// end namespace internal}
00393 
00394 \}  \textcolor{comment}{// end namespace Eigen}
00395 
00396 \textcolor{preprocessor}{#endif  // THIRD\_PARTY\_EIGEN3\_EIGEN\_SRC\_CORE\_ARCH\_AVX512\_MATHFUNCTIONS\_H\_}
\end{DoxyCode}
