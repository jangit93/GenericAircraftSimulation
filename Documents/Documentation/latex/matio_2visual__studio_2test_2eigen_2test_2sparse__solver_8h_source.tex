\hypertarget{matio_2visual__studio_2test_2eigen_2test_2sparse__solver_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/sparse\+\_\+solver.h}
\label{matio_2visual__studio_2test_2eigen_2test_2sparse__solver_8h_source}\index{sparse\+\_\+solver.\+h@{sparse\+\_\+solver.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2011 Gael Guennebaud <g.gael@free.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include "sparse.h"}
00011 \textcolor{preprocessor}{#include <Eigen/SparseCore>}
00012 \textcolor{preprocessor}{#include <sstream>}
00013 
00014 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Guess,\textcolor{keyword}{typename} Result>
00015 \textcolor{keywordtype}{void} solve\_with\_guess(\hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_iterative_solver_base}{IterativeSolverBase<Solver>}& solver, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>}& b, \textcolor{keyword}{const} Guess& g, Result &x) \{
00016   \textcolor{keywordflow}{if}(internal::random<bool>())
00017   \{
00018     \textcolor{comment}{// With a temporary through evaluator<SolveWithGuess>}
00019     x = solver.derived().solveWithGuess(b,g) + Result::Zero(x.rows(), x.cols());
00020   \}
00021   \textcolor{keywordflow}{else}
00022   \{
00023     \textcolor{comment}{// direct evaluation within x through Assignment<Result,SolveWithGuess>}
00024     x = solver.derived().solveWithGuess(b.derived(),g);
00025   \}
00026 \}
00027 
00028 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Guess,\textcolor{keyword}{typename} Result>
00029 \textcolor{keywordtype}{void} solve\_with\_guess(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase<Solver>}& solver, \textcolor{keyword}{const} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Rhs>}& b, \textcolor{keyword}{const} Guess& , Result& x) \{
00030   \textcolor{keywordflow}{if}(internal::random<bool>())
00031     x = solver.derived().solve(b) + Result::Zero(x.rows(), x.cols());
00032   \textcolor{keywordflow}{else}
00033     x = solver.derived().solve(b);
00034 \}
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Guess,\textcolor{keyword}{typename} Result>
00037 \textcolor{keywordtype}{void} solve\_with\_guess(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase<Solver>}& solver, \textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<Rhs>}& b, \textcolor{keyword}{const} Guess& , Result& x) \{
00038   x = solver.derived().solve(b);
00039 \}
00040 
00041 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} DenseMat, \textcolor{keyword}{typename} DenseRhs>
00042 \textcolor{keywordtype}{void} check\_sparse\_solving(Solver& solver, \textcolor{keyword}{const} \textcolor{keyword}{typename} Solver::MatrixType& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A}, \textcolor{keyword}{const} Rhs& b, \textcolor{keyword}{const} 
      DenseMat& dA, \textcolor{keyword}{const} DenseRhs& db)
00043 \{
00044   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType \hyperlink{group___core___module}{Mat};
00045   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00046   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::StorageIndex StorageIndex;
00047 
00048   DenseRhs refX = dA.householderQr().solve(db);
00049   \{
00050     Rhs x(A.cols(), b.cols());
00051     Rhs oldb = b;
00052 
00053     solver.compute(A);
00054     \textcolor{keywordflow}{if} (solver.info() != \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success})
00055     \{
00056       std::cerr << \textcolor{stringliteral}{"ERROR | sparse solver testing, factorization failed ("} << \textcolor{keyword}{typeid}(Solver).name() << \textcolor{stringliteral}{")\(\backslash\)n
      "};
00057       VERIFY(solver.info() == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success});
00058     \}
00059     x = solver.solve(b);
00060     \textcolor{keywordflow}{if} (solver.info() != \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success})
00061     \{
00062       std::cerr << \textcolor{stringliteral}{"WARNING | sparse solver testing: solving failed ("} << \textcolor{keyword}{typeid}(Solver).name() << \textcolor{stringliteral}{")\(\backslash\)n"};
00063       \textcolor{keywordflow}{return};
00064     \}
00065     VERIFY(oldb.isApprox(b) && \textcolor{stringliteral}{"sparse solver testing: the rhs should not be modified!"});
00066     VERIFY(x.isApprox(refX,test\_precision<Scalar>()));
00067 
00068     x.setZero();
00069     solve\_with\_guess(solver, b, x, x);
00070     VERIFY(solver.info() == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} && \textcolor{stringliteral}{"solving failed when using analyzePattern/factorize API"});
00071     VERIFY(oldb.isApprox(b) && \textcolor{stringliteral}{"sparse solver testing: the rhs should not be modified!"});
00072     VERIFY(x.isApprox(refX,test\_precision<Scalar>()));
00073     
00074     x.setZero();
00075     \textcolor{comment}{// test the analyze/factorize API}
00076     solver.analyzePattern(A);
00077     solver.factorize(A);
00078     VERIFY(solver.info() == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} && \textcolor{stringliteral}{"factorization failed when using analyzePattern/factorize API
      "});
00079     x = solver.solve(b);
00080     VERIFY(solver.info() == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} && \textcolor{stringliteral}{"solving failed when using analyzePattern/factorize API"});
00081     VERIFY(oldb.isApprox(b) && \textcolor{stringliteral}{"sparse solver testing: the rhs should not be modified!"});
00082     VERIFY(x.isApprox(refX,test\_precision<Scalar>()));
00083     
00084     x.setZero();
00085     \textcolor{comment}{// test with Map}
00086     \hyperlink{class_eigen_1_1_mapped_sparse_matrix}{MappedSparseMatrix<Scalar,Mat::Options,StorageIndex>}
       Am(A.rows(), A.cols(), A.nonZeros(), \textcolor{keyword}{const\_cast<}StorageIndex*\textcolor{keyword}{>}(A.outerIndexPtr()), 
      const\_cast<StorageIndex*>(A.innerIndexPtr()), const\_cast<Scalar*>(A.valuePtr()));
00087     solver.compute(Am);
00088     VERIFY(solver.info() == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} && \textcolor{stringliteral}{"factorization failed when using Map"});
00089     DenseRhs dx(refX);
00090     dx.setZero();
00091     \hyperlink{group___core___module_class_eigen_1_1_map}{Map<DenseRhs>} xm(dx.data(), dx.rows(), dx.cols());
00092     \hyperlink{group___core___module_class_eigen_1_1_map}{Map<const DenseRhs>} bm(db.data(), db.rows(), db.cols());
00093     xm = solver.solve(bm);
00094     VERIFY(solver.info() == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success} && \textcolor{stringliteral}{"solving failed when using Map"});
00095     VERIFY(oldb.isApprox(bm) && \textcolor{stringliteral}{"sparse solver testing: the rhs should not be modified!"});
00096     VERIFY(xm.isApprox(refX,test\_precision<Scalar>()));
00097   \}
00098   
00099   \textcolor{comment}{// if not too large, do some extra check:}
00100   \textcolor{keywordflow}{if}(A.rows()<2000)
00101   \{
00102     \textcolor{comment}{// test initialization ctor}
00103     \{
00104       Rhs x(b.rows(), b.cols());
00105       Solver solver2(A);
00106       VERIFY(solver2.info() == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success});
00107       x = solver2.solve(b);
00108       VERIFY(x.isApprox(refX,test\_precision<Scalar>()));
00109     \}
00110 
00111     \textcolor{comment}{// test dense Block as the result and rhs:}
00112     \{
00113       DenseRhs x(refX.rows(), refX.cols());
00114       DenseRhs oldb(db);
00115       x.setZero();
00116       x.block(0,0,x.rows(),x.cols()) = solver.solve(db.block(0,0,db.rows(),db.cols()));
00117       VERIFY(oldb.isApprox(db) && \textcolor{stringliteral}{"sparse solver testing: the rhs should not be modified!"});
00118       VERIFY(x.isApprox(refX,test\_precision<Scalar>()));
00119     \}
00120 
00121     \textcolor{comment}{// test uncompressed inputs}
00122     \{
00123       Mat A2 = A;
00124       A2.reserve((ArrayXf::Random(A.outerSize())+2).template cast<typename Mat::StorageIndex>().eval());
00125       solver.compute(A2);
00126       Rhs x = solver.solve(b);
00127       VERIFY(x.isApprox(refX,test\_precision<Scalar>()));
00128     \}
00129 
00130     \textcolor{comment}{// test expression as input}
00131     \{
00132       solver.compute(0.5*(A+A));
00133       Rhs x = solver.solve(b);
00134       VERIFY(x.isApprox(refX,test\_precision<Scalar>()));
00135 
00136       Solver solver2(0.5*(A+A));
00137       Rhs x2 = solver2.solve(b);
00138       VERIFY(x2.isApprox(refX,test\_precision<Scalar>()));
00139     \}
00140   \}
00141 \}
00142 
00143 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} Rhs>
00144 \textcolor{keywordtype}{void} check\_sparse\_solving\_real\_cases(Solver& solver, \textcolor{keyword}{const} \textcolor{keyword}{typename} Solver::MatrixType& A, \textcolor{keyword}{const} Rhs& b, \textcolor{keyword}{
      const} \textcolor{keyword}{typename} Solver::MatrixType& fullA, \textcolor{keyword}{const} Rhs& refX)
00145 \{
00146   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType Mat;
00147   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00148   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::RealScalar RealScalar;
00149   
00150   Rhs x(A.cols(), b.cols());
00151 
00152   solver.compute(A);
00153   \textcolor{keywordflow}{if} (solver.info() != \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success})
00154   \{
00155     std::cerr << \textcolor{stringliteral}{"ERROR | sparse solver testing, factorization failed ("} << \textcolor{keyword}{typeid}(Solver).name() << \textcolor{stringliteral}{")\(\backslash\)n"};
00156     VERIFY(solver.info() == \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success});
00157   \}
00158   x = solver.solve(b);
00159   
00160   \textcolor{keywordflow}{if} (solver.info() != \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success})
00161   \{
00162     std::cerr << \textcolor{stringliteral}{"WARNING | sparse solver testing, solving failed ("} << \textcolor{keyword}{typeid}(Solver).name() << \textcolor{stringliteral}{")\(\backslash\)n"};
00163     \textcolor{keywordflow}{return};
00164   \}
00165   
00166   RealScalar res\_error = (fullA*x-b).norm()/b.norm();  
00167   VERIFY( (res\_error <= test\_precision<Scalar>() ) && \textcolor{stringliteral}{"sparse solver failed without noticing it"}); 
00168 
00169   
00170   \textcolor{keywordflow}{if}(refX.size() != 0 && (refX - x).norm()/refX.norm() > test\_precision<Scalar>())
00171   \{
00172     std::cerr << \textcolor{stringliteral}{"WARNING | found solution is different from the provided reference one\(\backslash\)n"};
00173   \}
00174   
00175 \}
00176 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} DenseMat>
00177 \textcolor{keywordtype}{void} check\_sparse\_determinant(Solver& solver, \textcolor{keyword}{const} \textcolor{keyword}{typename} Solver::MatrixType& A, \textcolor{keyword}{const} DenseMat& dA)
00178 \{
00179   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType Mat;
00180   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00181   
00182   solver.compute(A);
00183   \textcolor{keywordflow}{if} (solver.info() != \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success})
00184   \{
00185     std::cerr << \textcolor{stringliteral}{"WARNING | sparse solver testing: factorization failed (check\_sparse\_determinant)\(\backslash\)n"};
00186     \textcolor{keywordflow}{return};
00187   \}
00188 
00189   Scalar refDet = dA.determinant();
00190   VERIFY\_IS\_APPROX(refDet,solver.determinant());
00191 \}
00192 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} DenseMat>
00193 \textcolor{keywordtype}{void} check\_sparse\_abs\_determinant(Solver& solver, \textcolor{keyword}{const} \textcolor{keyword}{typename} Solver::MatrixType& A, \textcolor{keyword}{const} DenseMat& dA)
00194 \{
00195   \textcolor{keyword}{using} std::abs;
00196   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType Mat;
00197   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00198   
00199   solver.compute(A);
00200   \textcolor{keywordflow}{if} (solver.info() != \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea}{Success})
00201   \{
00202     std::cerr << \textcolor{stringliteral}{"WARNING | sparse solver testing: factorization failed (check\_sparse\_abs\_determinant)\(\backslash\)n"};
00203     \textcolor{keywordflow}{return};
00204   \}
00205 
00206   Scalar refDet = abs(dA.determinant());
00207   VERIFY\_IS\_APPROX(refDet,solver.absDeterminant());
00208 \}
00209 
00210 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} DenseMat>
00211 \textcolor{keywordtype}{int} generate\_sparse\_spd\_problem(Solver& , \textcolor{keyword}{typename} Solver::MatrixType& A, \textcolor{keyword}{typename} Solver::MatrixType& 
      halfA, DenseMat& dA, \textcolor{keywordtype}{int} maxSize = 300)
00212 \{
00213   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType Mat;
00214   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00215   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} 
      \hyperlink{group___core___module}{DenseMatrix};
00216 
00217   \textcolor{keywordtype}{int} size = internal::random<int>(1,maxSize);
00218   \textcolor{keywordtype}{double} density = (std::max)(8./(size*size), 0.01);
00219 
00220   Mat \hyperlink{group___core___module_class_eigen_1_1_matrix}{M}(size, size);
00221   DenseMatrix dM(size, size);
00222 
00223   initSparse<Scalar>(density, dM, \hyperlink{group___core___module_class_eigen_1_1_matrix}{M}, ForceNonZeroDiag);
00224 
00225   A = M * M.adjoint();
00226   dA = dM * dM.adjoint();
00227   
00228   halfA.resize(size,size);
00229   \textcolor{keywordflow}{if}(Solver::UpLo==(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}|\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}))
00230     halfA = A;
00231   \textcolor{keywordflow}{else}
00232     halfA.template selfadjointView<Solver::UpLo>().rankUpdate(M);
00233   
00234   \textcolor{keywordflow}{return} size;
00235 \}
00236 
00237 
00238 \textcolor{preprocessor}{#ifdef TEST\_REAL\_CASES}
00239 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
00240 \textcolor{keyword}{inline} std::string get\_matrixfolder()
00241 \{
00242   std::string mat\_folder = TEST\_REAL\_CASES; 
00243   \textcolor{keywordflow}{if}( internal::is\_same<Scalar, std::complex<float> >::value || internal::is\_same<Scalar, 
      std::complex<double> >::value )
00244     mat\_folder  = mat\_folder + \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(\textcolor{stringliteral}{"/complex/"});
00245   \textcolor{keywordflow}{else}
00246     mat\_folder = mat\_folder + \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(\textcolor{stringliteral}{"/real/"});
00247   \textcolor{keywordflow}{return} mat\_folder;
00248 \}
00249 std::string sym\_to\_string(\textcolor{keywordtype}{int} sym)
00250 \{
00251   \textcolor{keywordflow}{if}(sym==\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4}{Symmetric}) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Symmetric "};
00252   \textcolor{keywordflow}{if}(sym==SPD)       \textcolor{keywordflow}{return} \textcolor{stringliteral}{"SPD "};
00253   \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
00254 \}
00255 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00256 std::string solver\_stats(\textcolor{keyword}{const} \hyperlink{group___iterative_linear_solvers___module_class_eigen_1_1_iterative_solver_base}{IterativeSolverBase<Derived>} &solver)
00257 \{
00258   std::stringstream ss;
00259   ss << solver.\hyperlink{group___iterative_linear_solvers___module_ae778dd098bd5e6655625b20b1e9f15da}{iterations}() << \textcolor{stringliteral}{" iters, error: "} << solver.\hyperlink{group___iterative_linear_solvers___module_a117c241af3fb1141ad0916a3cf3157ec}{error}();
00260   \textcolor{keywordflow}{return} ss.str();
00261 \}
00262 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00263 std::string solver\_stats(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_solver_base}{SparseSolverBase<Derived>} &\textcolor{comment}{/*solver*/})
00264 \{
00265   \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
00266 \}
00267 \textcolor{preprocessor}{#endif}
00268 
00269 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver> \textcolor{keywordtype}{void} check\_sparse\_spd\_solving(Solver& solver, \textcolor{keywordtype}{int} maxSize = 300, \textcolor{keywordtype}{int} 
      maxRealWorldSize = 100000)
00270 \{
00271   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType Mat;
00272   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00273   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::StorageIndex StorageIndex;
00274   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module}{SparseMatrix<Scalar,ColMajor, StorageIndex>} 
      \hyperlink{group___sparse_core___module}{SpMat};
00275   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_vector}{SparseVector<Scalar, 0, StorageIndex>} SpVec;
00276   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} DenseMatrix;
00277   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} \hyperlink{group___core___module}{DenseVector};
00278 
00279   \textcolor{comment}{// generate the problem}
00280   Mat A, halfA;
00281   DenseMatrix dA;
00282   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00283     \textcolor{keywordtype}{int} size = generate\_sparse\_spd\_problem(solver, A, halfA, dA, maxSize);
00284 
00285     \textcolor{comment}{// generate the right hand sides}
00286     \textcolor{keywordtype}{int} rhsCols = internal::random<int>(1,16);
00287     \textcolor{keywordtype}{double} density = (std::max)(8./(size*rhsCols), 0.1);
00288     SpMat \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}(size,rhsCols);
00289     DenseVector b = DenseVector::Random(size);
00290     DenseMatrix dB(size,rhsCols);
00291     initSparse<Scalar>(density, dB, \hyperlink{group___core___module_class_eigen_1_1_matrix}{B}, ForceNonZeroDiag);
00292     SpVec c = B.col(0);
00293     DenseVector dc = dB.col(0);
00294   
00295     CALL\_SUBTEST( check\_sparse\_solving(solver, A,     b,  dA, b)  );
00296     CALL\_SUBTEST( check\_sparse\_solving(solver, halfA, b,  dA, b)  );
00297     CALL\_SUBTEST( check\_sparse\_solving(solver, A,     dB, dA, dB) );
00298     CALL\_SUBTEST( check\_sparse\_solving(solver, halfA, dB, dA, dB) );
00299     CALL\_SUBTEST( check\_sparse\_solving(solver, A,     B,  dA, dB) );
00300     CALL\_SUBTEST( check\_sparse\_solving(solver, halfA, B,  dA, dB) );
00301     CALL\_SUBTEST( check\_sparse\_solving(solver, A,     c,  dA, dc) );
00302     CALL\_SUBTEST( check\_sparse\_solving(solver, halfA, c,  dA, dc) );
00303     
00304     \textcolor{comment}{// check only once}
00305     \textcolor{keywordflow}{if}(i==0)
00306     \{
00307       b = DenseVector::Zero(size);
00308       check\_sparse\_solving(solver, A, b, dA, b);
00309     \}
00310   \}
00311   
00312   \textcolor{comment}{// First, get the folder }
00313 \textcolor{preprocessor}{#ifdef TEST\_REAL\_CASES}
00314   \textcolor{comment}{// Test real problems with double precision only}
00315   \textcolor{keywordflow}{if} (internal::is\_same<\textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real}, \textcolor{keywordtype}{double}>::value)
00316   \{
00317     std::string mat\_folder = get\_matrixfolder<Scalar>();
00318     \hyperlink{class_eigen_1_1_matrix_market_iterator}{MatrixMarketIterator<Scalar>} it(mat\_folder);
00319     \textcolor{keywordflow}{for} (; it; ++it)
00320     \{
00321       \textcolor{keywordflow}{if} (it.sym() == SPD)\{
00322         A = it.matrix();
00323         \textcolor{keywordflow}{if}(A.diagonal().size() <= maxRealWorldSize)
00324         \{
00325           DenseVector b = it.rhs();
00326           DenseVector refX = it.refX();
00327           \hyperlink{group___core___module}{PermutationMatrix<Dynamic, Dynamic, StorageIndex>}
       pnull;
00328           halfA.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(A.rows(), A.cols());
00329           \textcolor{keywordflow}{if}(Solver::UpLo == (\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}|\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}))
00330             halfA = A;
00331           \textcolor{keywordflow}{else}
00332             halfA.template selfadjointView<Solver::UpLo>() = A.template triangularView<Eigen::Lower>().
      twistedBy(pnull);
00333           
00334           std::cout << \textcolor{stringliteral}{"INFO | Testing "} << sym\_to\_string(it.sym()) << \textcolor{stringliteral}{"sparse problem "} << it.matname()
00335                   << \textcolor{stringliteral}{" ("} << A.rows() << \textcolor{stringliteral}{"x"} << A.cols() << \textcolor{stringliteral}{") using "} << \textcolor{keyword}{typeid}(Solver).name() << \textcolor{stringliteral}{"..."} <<
       std::endl;
00336           CALL\_SUBTEST( check\_sparse\_solving\_real\_cases(solver, A,     b, A, refX) );
00337           std::string stats = solver\_stats(solver);
00338           \textcolor{keywordflow}{if}(stats.size()>0)
00339             std::cout << \textcolor{stringliteral}{"INFO |  "} << stats << std::endl;
00340           CALL\_SUBTEST( check\_sparse\_solving\_real\_cases(solver, halfA, b, A, refX) );
00341         \}
00342         \textcolor{keywordflow}{else}
00343         \{
00344           std::cout << \textcolor{stringliteral}{"INFO | Skip sparse problem \(\backslash\)""} << it.matname() << \textcolor{stringliteral}{"\(\backslash\)" (too large)"} << std::endl;
00345         \}
00346       \}
00347     \}
00348   \}
00349 \textcolor{preprocessor}{#else}
00350   EIGEN\_UNUSED\_VARIABLE(maxRealWorldSize);
00351 \textcolor{preprocessor}{#endif}
00352 \}
00353 
00354 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver> \textcolor{keywordtype}{void} check\_sparse\_spd\_determinant(Solver& solver)
00355 \{
00356   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType Mat;
00357   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00358   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} DenseMatrix;
00359 
00360   \textcolor{comment}{// generate the problem}
00361   Mat A, halfA;
00362   DenseMatrix dA;
00363   generate\_sparse\_spd\_problem(solver, A, halfA, dA, 30);
00364   
00365   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00366     check\_sparse\_determinant(solver, A,     dA);
00367     check\_sparse\_determinant(solver, halfA, dA );
00368   \}
00369 \}
00370 
00371 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} DenseMat>
00372 \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} generate\_sparse\_square\_problem(Solver&, \textcolor{keyword}{typename} Solver::MatrixType& A, DenseMat& dA, \textcolor{keywordtype}{int} 
      maxSize = 300, \textcolor{keywordtype}{int} options = ForceNonZeroDiag)
00373 \{
00374   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType Mat;
00375   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00376 
00377   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = internal::random<int>(1,maxSize);
00378   \textcolor{keywordtype}{double} density = (std::max)(8./(size*size), 0.01);
00379   
00380   A.resize(size,size);
00381   dA.resize(size,size);
00382 
00383   initSparse<Scalar>(density, dA, A, options);
00384   
00385   \textcolor{keywordflow}{return} size;
00386 \}
00387 
00388 
00389 \textcolor{keyword}{struct }\hyperlink{structprune__column}{prune\_column} \{
00390   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_col;
00391   \hyperlink{structprune__column}{prune\_column}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col) : m\_col(col) \{\}
00392   \textcolor{keyword}{template}<\textcolor{keyword}{class} Scalar>
00393   \textcolor{keywordtype}{bool} operator()(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col, \textcolor{keyword}{const} Scalar&)\textcolor{keyword}{ const }\{
00394     \textcolor{keywordflow}{return} col != m\_col;
00395   \}
00396 \};
00397 
00398 
00399 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver> \textcolor{keywordtype}{void} check\_sparse\_square\_solving(Solver& solver, \textcolor{keywordtype}{int} maxSize = 300, \textcolor{keywordtype}{int} 
      maxRealWorldSize = 100000, \textcolor{keywordtype}{bool} checkDeficient = \textcolor{keyword}{false})
00400 \{
00401   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType Mat;
00402   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00403   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar,ColMajor, typename Mat::StorageIndex>}
       SpMat;
00404   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_vector}{SparseVector<Scalar, 0, typename Mat::StorageIndex>}
       SpVec;
00405   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} DenseMatrix;
00406   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} DenseVector;
00407 
00408   \textcolor{keywordtype}{int} rhsCols = internal::random<int>(1,16);
00409 
00410   Mat A;
00411   DenseMatrix dA;
00412   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00413     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} size = generate\_sparse\_square\_problem(solver, A, dA, maxSize);
00414 
00415     A.makeCompressed();
00416     DenseVector b = DenseVector::Random(size);
00417     DenseMatrix dB(size,rhsCols);
00418     SpMat B(size,rhsCols);
00419     \textcolor{keywordtype}{double} density = (std::max)(8./(size*rhsCols), 0.1);
00420     initSparse<Scalar>(density, dB, B, ForceNonZeroDiag);
00421     B.makeCompressed();
00422     SpVec c = B.col(0);
00423     DenseVector dc = dB.col(0);
00424     CALL\_SUBTEST(check\_sparse\_solving(solver, A, b,  dA, b));
00425     CALL\_SUBTEST(check\_sparse\_solving(solver, A, dB, dA, dB));
00426     CALL\_SUBTEST(check\_sparse\_solving(solver, A, B,  dA, dB));
00427     CALL\_SUBTEST(check\_sparse\_solving(solver, A, c,  dA, dc));
00428     
00429     \textcolor{comment}{// check only once}
00430     \textcolor{keywordflow}{if}(i==0)
00431     \{
00432       b = DenseVector::Zero(size);
00433       check\_sparse\_solving(solver, A, b, dA, b);
00434     \}
00435     \textcolor{comment}{// regression test for Bug 792 (structurally rank deficient matrices):}
00436     \textcolor{keywordflow}{if}(checkDeficient && size>1) \{
00437       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} col = internal::random<int>(0,int(size-1));
00438       A.prune(\hyperlink{structprune__column}{prune\_column}(col));
00439       solver.compute(A);
00440       VERIFY\_IS\_EQUAL(solver.info(), \hyperlink{group__enums_gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f}{NumericalIssue});
00441     \}
00442   \}
00443   
00444   \textcolor{comment}{// First, get the folder }
00445 \textcolor{preprocessor}{#ifdef TEST\_REAL\_CASES}
00446   \textcolor{comment}{// Test real problems with double precision only}
00447   \textcolor{keywordflow}{if} (internal::is\_same<\textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::Real}, \textcolor{keywordtype}{double}>::value)
00448   \{
00449     std::string mat\_folder = get\_matrixfolder<Scalar>();
00450     \hyperlink{class_eigen_1_1_matrix_market_iterator}{MatrixMarketIterator<Scalar>} it(mat\_folder);
00451     \textcolor{keywordflow}{for} (; it; ++it)
00452     \{
00453       A = it.matrix();
00454       \textcolor{keywordflow}{if}(A.diagonal().size() <= maxRealWorldSize)
00455       \{
00456         DenseVector b = it.rhs();
00457         DenseVector refX = it.refX();
00458         std::cout << \textcolor{stringliteral}{"INFO | Testing "} << sym\_to\_string(it.sym()) << \textcolor{stringliteral}{"sparse problem "} << it.matname()
00459                   << \textcolor{stringliteral}{" ("} << A.rows() << \textcolor{stringliteral}{"x"} << A.cols() << \textcolor{stringliteral}{") using "} << \textcolor{keyword}{typeid}(Solver).name() << \textcolor{stringliteral}{"..."} <<
       std::endl;
00460         CALL\_SUBTEST(check\_sparse\_solving\_real\_cases(solver, A, b, A, refX));
00461         std::string stats = solver\_stats(solver);
00462         \textcolor{keywordflow}{if}(stats.size()>0)
00463           std::cout << \textcolor{stringliteral}{"INFO |  "} << stats << std::endl;
00464       \}
00465       \textcolor{keywordflow}{else}
00466       \{
00467         std::cout << \textcolor{stringliteral}{"INFO | SKIP sparse problem \(\backslash\)""} << it.matname() << \textcolor{stringliteral}{"\(\backslash\)" (too large)"} << std::endl;
00468       \}
00469     \}
00470   \}
00471 \textcolor{preprocessor}{#else}
00472   EIGEN\_UNUSED\_VARIABLE(maxRealWorldSize);
00473 \textcolor{preprocessor}{#endif}
00474 
00475 \}
00476 
00477 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver> \textcolor{keywordtype}{void} check\_sparse\_square\_determinant(Solver& solver)
00478 \{
00479   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType Mat;
00480   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00481   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} DenseMatrix;
00482   
00483   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00484     \textcolor{comment}{// generate the problem}
00485     Mat A;
00486     DenseMatrix dA;
00487     
00488     \textcolor{keywordtype}{int} size = internal::random<int>(1,30);
00489     dA.\hyperlink{class_eigen_1_1_plain_object_base_af0e576a0e1aefc9ee346de44cc352ba3}{setRandom}(size,size);
00490     
00491     dA = (dA.array().abs()<0.3).select(0,dA);
00492     dA.diagonal() = (dA.diagonal().array()==0).select(1,dA.diagonal());
00493     A = dA.sparseView();
00494     A.makeCompressed();
00495   
00496     check\_sparse\_determinant(solver, A, dA);
00497   \}
00498 \}
00499 
00500 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver> \textcolor{keywordtype}{void} check\_sparse\_square\_abs\_determinant(Solver& solver)
00501 \{
00502   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType Mat;
00503   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00504   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} DenseMatrix;
00505 
00506   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00507     \textcolor{comment}{// generate the problem}
00508     Mat A;
00509     DenseMatrix dA;
00510     generate\_sparse\_square\_problem(solver, A, dA, 30);
00511     A.makeCompressed();
00512     check\_sparse\_abs\_determinant(solver, A, dA);
00513   \}
00514 \}
00515 
00516 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver, \textcolor{keyword}{typename} DenseMat>
00517 \textcolor{keywordtype}{void} generate\_sparse\_leastsquare\_problem(Solver&, \textcolor{keyword}{typename} Solver::MatrixType& A, DenseMat& dA, \textcolor{keywordtype}{int} maxSize
       = 300, \textcolor{keywordtype}{int} options = ForceNonZeroDiag)
00518 \{
00519   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType Mat;
00520   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00521 
00522   \textcolor{keywordtype}{int} rows = internal::random<int>(1,maxSize);
00523   \textcolor{keywordtype}{int} cols = internal::random<int>(1,rows);
00524   \textcolor{keywordtype}{double} density = (std::max)(8./(rows*cols), 0.01);
00525   
00526   A.resize(rows,cols);
00527   dA.resize(rows,cols);
00528 
00529   initSparse<Scalar>(density, dA, A, options);
00530 \}
00531 
00532 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Solver> \textcolor{keywordtype}{void} check\_sparse\_leastsquare\_solving(Solver& solver)
00533 \{
00534   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Solver::MatrixType Mat;
00535   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Mat::Scalar Scalar;
00536   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar,ColMajor, typename Mat::StorageIndex>}
       SpMat;
00537   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,Dynamic>} DenseMatrix;
00538   \textcolor{keyword}{typedef} \hyperlink{group___core___module}{Matrix<Scalar,Dynamic,1>} DenseVector;
00539 
00540   \textcolor{keywordtype}{int} rhsCols = internal::random<int>(1,16);
00541 
00542   Mat A;
00543   DenseMatrix dA;
00544   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00545     generate\_sparse\_leastsquare\_problem(solver, A, dA);
00546 
00547     A.makeCompressed();
00548     DenseVector b = DenseVector::Random(A.rows());
00549     DenseMatrix dB(A.rows(),rhsCols);
00550     SpMat B(A.rows(),rhsCols);
00551     \textcolor{keywordtype}{double} density = (std::max)(8./(A.rows()*rhsCols), 0.1);
00552     initSparse<Scalar>(density, dB, B, ForceNonZeroDiag);
00553     B.makeCompressed();
00554     check\_sparse\_solving(solver, A, b,  dA, b);
00555     check\_sparse\_solving(solver, A, dB, dA, dB);
00556     check\_sparse\_solving(solver, A, B,  dA, dB);
00557     
00558     \textcolor{comment}{// check only once}
00559     \textcolor{keywordflow}{if}(i==0)
00560     \{
00561       b = DenseVector::Zero(A.rows());
00562       check\_sparse\_solving(solver, A, b, dA, b);
00563     \}
00564   \}
00565 \}
\end{DoxyCode}
