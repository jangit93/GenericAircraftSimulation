\hypertarget{eigen_2_eigen_2src_2_core_2_i_o_8h_source}{}\section{eigen/\+Eigen/src/\+Core/\+IO.h}
\label{eigen_2_eigen_2src_2_core_2_i_o_8h_source}\index{I\+O.\+h@{I\+O.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_IO\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_IO\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00015 
00016 \textcolor{keyword}{enum} \{ DontAlignCols = 1 \};
00017 \textcolor{keyword}{enum} \{ StreamPrecision = -1,
00018        FullPrecision = -2 \};
00019 
00020 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00021 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00022 std::ostream & print\_matrix(std::ostream & s, \textcolor{keyword}{const} Derived& \_m, \textcolor{keyword}{const} IOFormat& fmt);
00023 \}
00024 
\Hypertarget{eigen_2_eigen_2src_2_core_2_i_o_8h_source_l00050}\hyperlink{group___core___module}{00050} \textcolor{keyword}{struct }\hyperlink{group___core___module_struct_eigen_1_1_i_o_format}{IOFormat}
00051 \{
\Hypertarget{eigen_2_eigen_2src_2_core_2_i_o_8h_source_l00053}\hyperlink{group___core___module_a637b0b62f49a87c1396a904de46c4856}{00053}   \hyperlink{group___core___module_a637b0b62f49a87c1396a904de46c4856}{IOFormat}(\textcolor{keywordtype}{int} \_precision = StreamPrecision, \textcolor{keywordtype}{int} \_flags = 0,
00054     \textcolor{keyword}{const} std::string& \_coeffSeparator = \textcolor{stringliteral}{" "},
00055     \textcolor{keyword}{const} std::string& \_rowSeparator = \textcolor{stringliteral}{"\(\backslash\)n"}, \textcolor{keyword}{const} std::string& \_rowPrefix=\textcolor{stringliteral}{""}, \textcolor{keyword}{const} std::string& 
      \_rowSuffix=\textcolor{stringliteral}{""},
00056     \textcolor{keyword}{const} std::string& \_matPrefix=\textcolor{stringliteral}{""}, \textcolor{keyword}{const} std::string& \_matSuffix=\textcolor{stringliteral}{""})
00057   : matPrefix(\_matPrefix), matSuffix(\_matSuffix), rowPrefix(\_rowPrefix), rowSuffix(\_rowSuffix), 
      rowSeparator(\_rowSeparator),
00058     rowSpacer(\textcolor{stringliteral}{""}), coeffSeparator(\_coeffSeparator), precision(\_precision), flags(\_flags)
00059   \{
00060     \textcolor{comment}{// TODO check if rowPrefix, rowSuffix or rowSeparator contains a newline}
00061     \textcolor{comment}{// don't add rowSpacer if columns are not to be aligned}
00062     \textcolor{keywordflow}{if}((flags & DontAlignCols))
00063       \textcolor{keywordflow}{return};
00064     \textcolor{keywordtype}{int} i = int(matSuffix.length())-1;
00065     \textcolor{keywordflow}{while} (i>=0 && matSuffix[i]!=\textcolor{charliteral}{'\(\backslash\)n'})
00066     \{
00067       rowSpacer += \textcolor{charliteral}{' '};
00068       i--;
00069     \}
00070   \}
00071   std::string matPrefix, matSuffix;
00072   std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;
00073   std::string coeffSeparator;
00074   \textcolor{keywordtype}{int} precision;
00075   \textcolor{keywordtype}{int} flags;
00076 \};
00077 
00093 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType>
\Hypertarget{eigen_2_eigen_2src_2_core_2_i_o_8h_source_l00094}\hyperlink{group___core___module}{00094} \textcolor{keyword}{class }\hyperlink{group___core___module_class_eigen_1_1_with_format}{WithFormat}
00095 \{
00096   \textcolor{keyword}{public}:
00097 
00098     \hyperlink{group___core___module_class_eigen_1_1_with_format}{WithFormat}(\textcolor{keyword}{const} ExpressionType& matrix, \textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_i_o_format}{IOFormat}& format)
00099       : m\_matrix(matrix), m\_format(format)
00100     \{\}
00101 
00102     \textcolor{keyword}{friend} std::ostream & operator << (std::ostream & s, \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_with_format}{WithFormat}& wf)
00103     \{
00104       \textcolor{keywordflow}{return} internal::print\_matrix(s, wf.m\_matrix.eval(), wf.m\_format);
00105     \}
00106 
00107   \textcolor{keyword}{protected}:
00108     \textcolor{keyword}{typename} ExpressionType::Nested m\_matrix;
00109     \hyperlink{group___core___module_struct_eigen_1_1_i_o_format}{IOFormat} m\_format;
00110 \};
00111 
00112 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00113 
00114 \textcolor{comment}{// NOTE: This helper is kept for backward compatibility with previous code specializing}
00115 \textcolor{comment}{//       this internal::significant\_decimals\_impl structure. In the future we should directly}
00116 \textcolor{comment}{//       call digits10() which has been introduced in July 2016 in 3.3.}
00117 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar>
\Hypertarget{eigen_2_eigen_2src_2_core_2_i_o_8h_source_l00118}\hyperlink{struct_eigen_1_1internal_1_1significant__decimals__impl}{00118} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1significant__decimals__impl}{significant\_decimals\_impl}
00119 \{
00120   \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} run()
00121   \{
00122     \textcolor{keywordflow}{return} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::digits10}();
00123   \}
00124 \};
00125 
00128 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00129 std::ostream & print\_matrix(std::ostream & s, \textcolor{keyword}{const} Derived& \_m, \textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_i_o_format}{IOFormat}& fmt)
00130 \{
00131   \textcolor{keywordflow}{if}(\_m.size() == 0)
00132   \{
00133     s << fmt.matPrefix << fmt.matSuffix;
00134     \textcolor{keywordflow}{return} s;
00135   \}
00136   
00137   \textcolor{keyword}{typename} Derived::Nested m = \_m;
00138   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;
00139 
00140   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} width = 0;
00141 
00142   std::streamsize explicit\_precision;
00143   \textcolor{keywordflow}{if}(fmt.precision == StreamPrecision)
00144   \{
00145     explicit\_precision = 0;
00146   \}
00147   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(fmt.precision == FullPrecision)
00148   \{
00149     \textcolor{keywordflow}{if} (\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<Scalar>::IsInteger})
00150     \{
00151       explicit\_precision = 0;
00152     \}
00153     \textcolor{keywordflow}{else}
00154     \{
00155       explicit\_precision = \hyperlink{struct_eigen_1_1internal_1_1significant__decimals__impl}{significant\_decimals\_impl<Scalar>::run}();
00156     \}
00157   \}
00158   \textcolor{keywordflow}{else}
00159   \{
00160     explicit\_precision = fmt.precision;
00161   \}
00162 
00163   std::streamsize old\_precision = 0;
00164   \textcolor{keywordflow}{if}(explicit\_precision) old\_precision = s.precision(explicit\_precision);
00165 
00166   \textcolor{keywordtype}{bool} align\_cols = !(fmt.flags & DontAlignCols);
00167   \textcolor{keywordflow}{if}(align\_cols)
00168   \{
00169     \textcolor{comment}{// compute the largest width}
00170     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 0; j < m.cols(); ++j)
00171       \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < m.rows(); ++i)
00172       \{
00173         std::stringstream sstr;
00174         sstr.copyfmt(s);
00175         sstr << m.coeff(i,j);
00176         width = std::max<Index>(width, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(sstr.str().length()));
00177       \}
00178   \}
00179   s << fmt.matPrefix;
00180   \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} i = 0; i < m.rows(); ++i)
00181   \{
00182     \textcolor{keywordflow}{if} (i)
00183       s << fmt.rowSpacer;
00184     s << fmt.rowPrefix;
00185     \textcolor{keywordflow}{if}(width) s.width(width);
00186     s << m.coeff(i, 0);
00187     \textcolor{keywordflow}{for}(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} j = 1; j < m.cols(); ++j)
00188     \{
00189       s << fmt.coeffSeparator;
00190       \textcolor{keywordflow}{if} (width) s.width(width);
00191       s << m.coeff(i, j);
00192     \}
00193     s << fmt.rowSuffix;
00194     \textcolor{keywordflow}{if}( i < m.rows() - 1)
00195       s << fmt.rowSeparator;
00196   \}
00197   s << fmt.matSuffix;
00198   \textcolor{keywordflow}{if}(explicit\_precision) s.precision(old\_precision);
00199   \textcolor{keywordflow}{return} s;
00200 \}
00201 
00202 \} \textcolor{comment}{// end namespace internal}
00203 
00215 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00216 std::ostream & \textcolor{keyword}{operator} <<
\Hypertarget{eigen_2_eigen_2src_2_core_2_i_o_8h_source_l00217}\hyperlink{group___core___module_a3806d3f42de165878dace160e6aba40a}{00217} (std::ostream & s,
00218  \textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_dense_base}{DenseBase<Derived>} & m)
00219 \{
00220   \textcolor{keywordflow}{return} internal::print\_matrix(s, m.eval(), EIGEN\_DEFAULT\_IO\_FORMAT);
00221 \}
00222 
00223 \} \textcolor{comment}{// end namespace Eigen}
00224 
00225 \textcolor{preprocessor}{#endif // EIGEN\_IO\_H}
\end{DoxyCode}
