\hypertarget{eigen_2_eigen_2src_2_stl_support_2_std_list_8h_source}{}\section{eigen/\+Eigen/src/\+Stl\+Support/\+Std\+List.h}
\label{eigen_2_eigen_2src_2_stl_support_2_std_list_8h_source}\index{Std\+List.\+h@{Std\+List.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Hauke Heibel <hauke.heibel@googlemail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_STDLIST\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_STDLIST\_H}
00012 
00013 \textcolor{preprocessor}{#include "details.h"}
00014 
00020 \textcolor{preprocessor}{#define EIGEN\_DEFINE\_STL\_LIST\_SPECIALIZATION(...) \(\backslash\)}
00021 \textcolor{preprocessor}{namespace std \(\backslash\)}
00022 \textcolor{preprocessor}{\{ \(\backslash\)}
00023 \textcolor{preprocessor}{  template<> \(\backslash\)}
00024 \textcolor{preprocessor}{  class list<\_\_VA\_ARGS\_\_, std::allocator<\_\_VA\_ARGS\_\_> >           \(\backslash\)}
00025 \textcolor{preprocessor}{    : public list<\_\_VA\_ARGS\_\_, EIGEN\_ALIGNED\_ALLOCATOR<\_\_VA\_ARGS\_\_> > \(\backslash\)}
00026 \textcolor{preprocessor}{  \{ \(\backslash\)}
00027 \textcolor{preprocessor}{    typedef list<\_\_VA\_ARGS\_\_, EIGEN\_ALIGNED\_ALLOCATOR<\_\_VA\_ARGS\_\_> > list\_base; \(\backslash\)}
00028 \textcolor{preprocessor}{  public: \(\backslash\)}
00029 \textcolor{preprocessor}{    typedef \_\_VA\_ARGS\_\_ value\_type; \(\backslash\)}
00030 \textcolor{preprocessor}{    typedef list\_base::allocator\_type allocator\_type; \(\backslash\)}
00031 \textcolor{preprocessor}{    typedef list\_base::size\_type size\_type;  \(\backslash\)}
00032 \textcolor{preprocessor}{    typedef list\_base::iterator iterator;  \(\backslash\)}
00033 \textcolor{preprocessor}{    explicit list(const allocator\_type& a = allocator\_type()) : list\_base(a) \{\}  \(\backslash\)}
00034 \textcolor{preprocessor}{    template<typename InputIterator> \(\backslash\)}
00035 \textcolor{preprocessor}{    list(InputIterator first, InputIterator last, const allocator\_type& a = allocator\_type()) :
       list\_base(first, last, a) \{\} \(\backslash\)}
00036 \textcolor{preprocessor}{    list(const list& c) : list\_base(c) \{\}  \(\backslash\)}
00037 \textcolor{preprocessor}{    explicit list(size\_type num, const value\_type& val = value\_type()) : list\_base(num, val) \{\} \(\backslash\)}
00038 \textcolor{preprocessor}{    list(iterator start, iterator end) : list\_base(start, end) \{\}  \(\backslash\)}
00039 \textcolor{preprocessor}{    list& operator=(const list& x) \{  \(\backslash\)}
00040 \textcolor{preprocessor}{      list\_base::operator=(x);  \(\backslash\)}
00041 \textcolor{preprocessor}{      return *this;  \(\backslash\)}
00042 \textcolor{preprocessor}{    \} \(\backslash\)}
00043 \textcolor{preprocessor}{  \}; \(\backslash\)}
00044 \textcolor{preprocessor}{\}}
00045 
00046 \textcolor{comment}{// check whether we really need the std::list specialization}
00047 \textcolor{preprocessor}{#if !EIGEN\_HAS\_CXX11\_CONTAINERS && !(defined(\_GLIBCXX\_LIST) && (!EIGEN\_GNUC\_AT\_LEAST(4,1))) }\textcolor{comment}{/* Note that
       before gcc-4.1 we already have: std::list::resize(size\_type,const T&). */}\textcolor{preprocessor}{}
00048 
00049 \textcolor{keyword}{namespace }\hyperlink{namespacestd}{std}
00050 \{
00051 
00052 \textcolor{preprocessor}{#define EIGEN\_STD\_LIST\_SPECIALIZATION\_BODY \(\backslash\)}
00053 \textcolor{preprocessor}{  public:  \(\backslash\)}
00054 \textcolor{preprocessor}{    typedef T value\_type; \(\backslash\)}
00055 \textcolor{preprocessor}{    typedef typename list\_base::allocator\_type allocator\_type; \(\backslash\)}
00056 \textcolor{preprocessor}{    typedef typename list\_base::size\_type size\_type;  \(\backslash\)}
00057 \textcolor{preprocessor}{    typedef typename list\_base::iterator iterator;  \(\backslash\)}
00058 \textcolor{preprocessor}{    typedef typename list\_base::const\_iterator const\_iterator;  \(\backslash\)}
00059 \textcolor{preprocessor}{    explicit list(const allocator\_type& a = allocator\_type()) : list\_base(a) \{\}  \(\backslash\)}
00060 \textcolor{preprocessor}{    template<typename InputIterator> \(\backslash\)}
00061 \textcolor{preprocessor}{    list(InputIterator first, InputIterator last, const allocator\_type& a = allocator\_type()) \(\backslash\)}
00062 \textcolor{preprocessor}{    : list\_base(first, last, a) \{\} \(\backslash\)}
00063 \textcolor{preprocessor}{    list(const list& c) : list\_base(c) \{\}  \(\backslash\)}
00064 \textcolor{preprocessor}{    explicit list(size\_type num, const value\_type& val = value\_type()) : list\_base(num, val) \{\} \(\backslash\)}
00065 \textcolor{preprocessor}{    list(iterator start, iterator end) : list\_base(start, end) \{\}  \(\backslash\)}
00066 \textcolor{preprocessor}{    list& operator=(const list& x) \{  \(\backslash\)}
00067 \textcolor{preprocessor}{    list\_base::operator=(x);  \(\backslash\)}
00068 \textcolor{preprocessor}{    return *this; \(\backslash\)}
00069 \textcolor{preprocessor}{  \}}
00070 
00071   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
\Hypertarget{eigen_2_eigen_2src_2_stl_support_2_std_list_8h_source_l00072}\hyperlink{classstd_1_1list_3_01_t_00_01_e_i_g_e_n___a_l_i_g_n_e_d___a_l_l_o_c_a_t_o_r_3_01_t_01_4_01_4}{00072}   \textcolor{keyword}{class }list<\hyperlink{group___sparse_core___module}{T},EIGEN\_ALIGNED\_ALLOCATOR<\hyperlink{group___sparse_core___module}{T}> >
00073     : \textcolor{keyword}{public} list<EIGEN\_WORKAROUND\_MSVC\_STL\_SUPPORT(T),
00074                   Eigen::aligned\_allocator\_indirection<EIGEN\_WORKAROUND\_MSVC\_STL\_SUPPORT(T)> >
00075   \{
00076     \textcolor{keyword}{typedef} list<EIGEN\_WORKAROUND\_MSVC\_STL\_SUPPORT(\hyperlink{group___sparse_core___module}{T}),
00077                  
      \hyperlink{class_eigen_1_1aligned__allocator__indirection}{Eigen::aligned\_allocator\_indirection<EIGEN\_WORKAROUND\_MSVC\_STL\_SUPPORT(T)>}
       > list\_base;
00078     EIGEN\_STD\_LIST\_SPECIALIZATION\_BODY
00079 
00080     \textcolor{keywordtype}{void} resize(size\_type new\_size)
00081     \{ resize(new\_size, \hyperlink{group___sparse_core___module}{T}()); \}
00082 
00083     \textcolor{keywordtype}{void} resize(size\_type new\_size, \textcolor{keyword}{const} value\_type& x)
00084     \{
00085       \textcolor{keywordflow}{if} (list\_base::size() < new\_size)
00086         list\_base::insert(list\_base::end(), new\_size - list\_base::size(), x);
00087       \textcolor{keywordflow}{else}
00088         \textcolor{keywordflow}{while} (new\_size < list\_base::size()) list\_base::pop\_back();
00089     \}
00090 
00091 \textcolor{preprocessor}{#if defined(\_LIST\_)}
00092     \textcolor{comment}{// workaround MSVC std::list implementation}
00093     \textcolor{keywordtype}{void} push\_back(\textcolor{keyword}{const} value\_type& x)
00094     \{ list\_base::push\_back(x); \} 
00095     \textcolor{keyword}{using} list\_base::insert;  
00096     iterator insert(const\_iterator position, \textcolor{keyword}{const} value\_type& x)
00097     \{ \textcolor{keywordflow}{return} list\_base::insert(position,x); \}
00098     \textcolor{keywordtype}{void} insert(const\_iterator position, size\_type new\_size, \textcolor{keyword}{const} value\_type& x)
00099     \{ list\_base::insert(position, new\_size, x); \}
00100 \textcolor{preprocessor}{#endif}
00101   \};
00102 \}
00103 
00104 \textcolor{preprocessor}{#endif // check whether specialization is actually required}
00105 
00106 \textcolor{preprocessor}{#endif // EIGEN\_STDLIST\_H}
\end{DoxyCode}
