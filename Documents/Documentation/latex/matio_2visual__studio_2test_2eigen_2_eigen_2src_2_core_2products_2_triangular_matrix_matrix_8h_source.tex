\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2products_2_triangular_matrix_matrix_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/products/\+Triangular\+Matrix\+Matrix.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2products_2_triangular_matrix_matrix_8h_source}\index{Triangular\+Matrix\+Matrix.\+h@{Triangular\+Matrix\+Matrix.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_TRIANGULAR\_MATRIX\_MATRIX\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_TRIANGULAR\_MATRIX\_MATRIX\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00015 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00016 
00017 \textcolor{comment}{// template<typename Scalar, int mr, int StorageOrder, bool Conjugate, int Mode>}
00018 \textcolor{comment}{// struct gemm\_pack\_lhs\_triangular}
00019 \textcolor{comment}{// \{}
00020 \textcolor{comment}{//   Matrix<Scalar,mr,mr,}
00021 \textcolor{comment}{//   void operator()(Scalar* blockA, const EIGEN\_RESTRICT Scalar* \_lhs, int lhsStride, int depth, int rows)}
00022 \textcolor{comment}{//   \{}
00023 \textcolor{comment}{//     conj\_if<NumTraits<Scalar>::IsComplex && Conjugate> cj;}
00024 \textcolor{comment}{//     const\_blas\_data\_mapper<Scalar, StorageOrder> lhs(\_lhs,lhsStride);}
00025 \textcolor{comment}{//     int count = 0;}
00026 \textcolor{comment}{//     const int peeled\_mc = (rows/mr)*mr;}
00027 \textcolor{comment}{//     for(int i=0; i<peeled\_mc; i+=mr)}
00028 \textcolor{comment}{//     \{}
00029 \textcolor{comment}{//       for(int k=0; k<depth; k++)}
00030 \textcolor{comment}{//         for(int w=0; w<mr; w++)}
00031 \textcolor{comment}{//           blockA[count++] = cj(lhs(i+w, k));}
00032 \textcolor{comment}{//     \}}
00033 \textcolor{comment}{//     for(int i=peeled\_mc; i<rows; i++)}
00034 \textcolor{comment}{//     \{}
00035 \textcolor{comment}{//       for(int k=0; k<depth; k++)}
00036 \textcolor{comment}{//         blockA[count++] = cj(lhs(i, k));}
00037 \textcolor{comment}{//     \}}
00038 \textcolor{comment}{//   \}}
00039 \textcolor{comment}{// \};}
00040 
00041 \textcolor{comment}{/* Optimized triangular matrix * matrix (\_TRMM++) product built on top of}
00042 \textcolor{comment}{ * the general matrix matrix product.}
00043 \textcolor{comment}{ */}
00044 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00045           \textcolor{keywordtype}{int} Mode, \textcolor{keywordtype}{bool} LhsIsTriangular,
00046           \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00047           \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs,
00048           \textcolor{keywordtype}{int} ResStorageOrder, \textcolor{keywordtype}{int} Version = Specialized>
00049 \textcolor{keyword}{struct }product\_triangular\_matrix\_matrix;
00050 
00051 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00052           \textcolor{keywordtype}{int} Mode, \textcolor{keywordtype}{bool} LhsIsTriangular,
00053           \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00054           \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int} Version>
00055 \textcolor{keyword}{struct }product\_triangular\_matrix\_matrix<Scalar,Index,Mode,LhsIsTriangular,
00056                                            LhsStorageOrder,ConjugateLhs,
00057                                            RhsStorageOrder,ConjugateRhs,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},Version>
00058 \{
00059   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} run(
00060     Index rows, Index cols, Index depth,
00061     \textcolor{keyword}{const} Scalar* lhs, Index lhsStride,
00062     \textcolor{keyword}{const} Scalar* rhs, Index rhsStride,
00063     Scalar* res,       Index resStride,
00064     \textcolor{keyword}{const} Scalar& alpha, level3\_blocking<Scalar,Scalar>& blocking)
00065   \{
00066     product\_triangular\_matrix\_matrix<Scalar, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00067       (Mode&(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaddb72f888ac85d5a1c52333e54f9374b}{UnitDiag}|\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda884ff7240392e85aa6e4b3c957e36483}{ZeroDiag})) | ((Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}) ? \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} : 
      \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}),
00068       (!LhsIsTriangular),
00069       RhsStorageOrder==\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor},
00070       ConjugateRhs,
00071       LhsStorageOrder==RowMajor ? \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor} : RowMajor,
00072       ConjugateLhs,
00073       \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}>
00074       ::run(cols, rows, depth, rhs, rhsStride, lhs, lhsStride, res, resStride, alpha, blocking);
00075   \}
00076 \};
00077 
00078 \textcolor{comment}{// implements col-major += alpha * op(triangular) * op(general)}
00079 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keywordtype}{int} Mode,
00080           \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00081           \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int} Version>
00082 \textcolor{keyword}{struct }product\_triangular\_matrix\_matrix<Scalar,Index,Mode,true,
00083                                            LhsStorageOrder,ConjugateLhs,
00084                                            RhsStorageOrder,ConjugateRhs,\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},Version>
00085 \{
00086   
00087   \textcolor{keyword}{typedef} gebp\_traits<Scalar,Scalar> Traits;
00088   \textcolor{keyword}{enum} \{
00089     SmallPanelWidth   = 2 * EIGEN\_PLAIN\_ENUM\_MAX(Traits::mr,Traits::nr),
00090     IsLower = (Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) == \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower},
00091     SetDiag = (Mode&(\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda884ff7240392e85aa6e4b3c957e36483}{ZeroDiag}|\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaddb72f888ac85d5a1c52333e54f9374b}{UnitDiag})) ? 0 : 1
00092   \};
00093 
00094   \textcolor{keyword}{static} EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} run(
00095     Index \_rows, Index \_cols, Index \_depth,
00096     \textcolor{keyword}{const} Scalar* \_lhs, Index lhsStride,
00097     \textcolor{keyword}{const} Scalar* \_rhs, Index rhsStride,
00098     Scalar* res,        Index resStride,
00099     \textcolor{keyword}{const} Scalar& alpha, level3\_blocking<Scalar,Scalar>& blocking);
00100 \};
00101 
00102 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keywordtype}{int} Mode,
00103           \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00104           \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int} Version>
00105 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} product\_triangular\_matrix\_matrix<Scalar,\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},Mode,\textcolor{keyword}{true},
00106                                                         LhsStorageOrder,ConjugateLhs,
00107                                                         RhsStorageOrder,ConjugateRhs,
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},Version>::run(
00108     Index \_rows, Index \_cols, Index \_depth,
00109     \textcolor{keyword}{const} Scalar* \_lhs, Index lhsStride,
00110     \textcolor{keyword}{const} Scalar* \_rhs, Index rhsStride,
00111     Scalar* \_res,        Index resStride,
00112     \textcolor{keyword}{const} Scalar& alpha, level3\_blocking<Scalar,Scalar>& blocking)
00113   \{
00114     \textcolor{comment}{// strip zeros}
00115     Index diagSize  = (std::min)(\_rows,\_depth);
00116     Index rows      = IsLower ? \_rows : diagSize;
00117     Index depth     = IsLower ? diagSize : \_depth;
00118     Index cols      = \_cols;
00119     
00120     \textcolor{keyword}{typedef} const\_blas\_data\_mapper<Scalar, Index, LhsStorageOrder> LhsMapper;
00121     \textcolor{keyword}{typedef} const\_blas\_data\_mapper<Scalar, Index, RhsStorageOrder> RhsMapper;
00122     \textcolor{keyword}{typedef} blas\_data\_mapper<typename Traits::ResScalar, Index, ColMajor> ResMapper;
00123     LhsMapper lhs(\_lhs,lhsStride);
00124     RhsMapper rhs(\_rhs,rhsStride);
00125     ResMapper res(\_res, resStride);
00126 
00127     Index kc = blocking.kc();                   \textcolor{comment}{// cache block size along the K direction}
00128     Index mc = (std::min)(rows,blocking.mc());  \textcolor{comment}{// cache block size along the M direction}
00129     \textcolor{comment}{// The small panel size must not be larger than blocking size.}
00130     \textcolor{comment}{// Usually this should never be the case because SmallPanelWidth^2 is very small}
00131     \textcolor{comment}{// compared to L2 cache size, but let's be safe:}
00132     Index panelWidth = (std::min)(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(SmallPanelWidth),(std::min)(kc,mc));
00133 
00134     std::size\_t sizeA = kc*mc;
00135     std::size\_t sizeB = kc*cols;
00136 
00137     ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, blockA, sizeA, blocking.blockA());
00138     ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, blockB, sizeB, blocking.blockB());
00139 
00140     Matrix<Scalar,SmallPanelWidth,SmallPanelWidth,LhsStorageOrder> triangularBuffer((
      internal::constructor\_without\_unaligned\_array\_assert()));
00141     triangularBuffer.setZero();
00142     \textcolor{keywordflow}{if}((Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda884ff7240392e85aa6e4b3c957e36483}{ZeroDiag})==ZeroDiag)
00143       triangularBuffer.diagonal().setZero();
00144     \textcolor{keywordflow}{else}
00145       triangularBuffer.diagonal().setOnes();
00146 
00147     gebp\_kernel<Scalar, Scalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> 
      gebp\_kernel;
00148     gemm\_pack\_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack\_lhs;
00149     gemm\_pack\_rhs<Scalar, Index, RhsMapper, Traits::nr,RhsStorageOrder> pack\_rhs;
00150 
00151     \textcolor{keywordflow}{for}(Index k2=IsLower ? depth : 0;
00152         IsLower ? k2>0 : k2<depth;
00153         IsLower ? k2-=kc : k2+=kc)
00154     \{
00155       Index actual\_kc = (std::min)(IsLower ? k2 : depth-k2, kc);
00156       Index actual\_k2 = IsLower ? k2-actual\_kc : k2;
00157 
00158       \textcolor{comment}{// align blocks with the end of the triangular part for trapezoidal lhs}
00159       \textcolor{keywordflow}{if}((!IsLower)&&(k2<rows)&&(k2+actual\_kc>rows))
00160       \{
00161         actual\_kc = rows-k2;
00162         k2 = k2+actual\_kc-kc;
00163       \}
00164 
00165       pack\_rhs(blockB, rhs.getSubMapper(actual\_k2,0), actual\_kc, cols);
00166 
00167       \textcolor{comment}{// the selected lhs's panel has to be split in three different parts:}
00168       \textcolor{comment}{//  1 - the part which is zero => skip it}
00169       \textcolor{comment}{//  2 - the diagonal block => special kernel}
00170       \textcolor{comment}{//  3 - the dense panel below (lower case) or above (upper case) the diagonal block => GEPP}
00171 
00172       \textcolor{comment}{// the block diagonal, if any:}
00173       \textcolor{keywordflow}{if}(IsLower || actual\_k2<rows)
00174       \{
00175         \textcolor{comment}{// for each small vertical panels of lhs}
00176         \textcolor{keywordflow}{for} (Index k1=0; k1<actual\_kc; k1+=panelWidth)
00177         \{
00178           Index actualPanelWidth = std::min<Index>(actual\_kc-k1, panelWidth);
00179           Index lengthTarget = IsLower ? actual\_kc-k1-actualPanelWidth : k1;
00180           Index startBlock   = actual\_k2+k1;
00181           Index blockBOffset = k1;
00182 
00183           \textcolor{comment}{// => GEBP with the micro triangular block}
00184           \textcolor{comment}{// The trick is to pack this micro block while filling the opposite triangular part with zeros.}
00185           \textcolor{comment}{// To this end we do an extra triangular copy to a small temporary buffer}
00186           \textcolor{keywordflow}{for} (Index k=0;k<actualPanelWidth;++k)
00187           \{
00188             \textcolor{keywordflow}{if} (SetDiag)
00189               triangularBuffer.coeffRef(k,k) = lhs(startBlock+k,startBlock+k);
00190             \textcolor{keywordflow}{for} (Index i=IsLower ? k+1 : 0; IsLower ? i<actualPanelWidth : i<k; ++i)
00191               triangularBuffer.coeffRef(i,k) = lhs(startBlock+i,startBlock+k);
00192           \}
00193           pack\_lhs(blockA, LhsMapper(triangularBuffer.data(), triangularBuffer.outerStride()), 
      actualPanelWidth, actualPanelWidth);
00194 
00195           gebp\_kernel(res.getSubMapper(startBlock, 0), blockA, blockB,
00196                       actualPanelWidth, actualPanelWidth, cols, alpha,
00197                       actualPanelWidth, actual\_kc, 0, blockBOffset);
00198 
00199           \textcolor{comment}{// GEBP with remaining micro panel}
00200           \textcolor{keywordflow}{if} (lengthTarget>0)
00201           \{
00202             Index startTarget  = IsLower ? actual\_k2+k1+actualPanelWidth : actual\_k2;
00203 
00204             pack\_lhs(blockA, lhs.getSubMapper(startTarget,startBlock), actualPanelWidth, lengthTarget);
00205 
00206             gebp\_kernel(res.getSubMapper(startTarget, 0), blockA, blockB,
00207                         lengthTarget, actualPanelWidth, cols, alpha,
00208                         actualPanelWidth, actual\_kc, 0, blockBOffset);
00209           \}
00210         \}
00211       \}
00212       \textcolor{comment}{// the part below (lower case) or above (upper case) the diagonal => GEPP}
00213       \{
00214         Index start = IsLower ? k2 : 0;
00215         Index end   = IsLower ? rows : (std::min)(actual\_k2,rows);
00216         \textcolor{keywordflow}{for}(Index i2=start; i2<end; i2+=mc)
00217         \{
00218           \textcolor{keyword}{const} Index actual\_mc = (std::min)(i2+mc,end)-i2;
00219           gemm\_pack\_lhs<Scalar, Index, LhsMapper, Traits::mr,Traits::LhsProgress, LhsStorageOrder,false>()
00220             (blockA, lhs.getSubMapper(i2, actual\_k2), actual\_kc, actual\_mc);
00221 
00222           gebp\_kernel(res.getSubMapper(i2, 0), blockA, blockB, actual\_mc,
00223                       actual\_kc, cols, alpha, -1, -1, 0, 0);
00224         \}
00225       \}
00226     \}
00227   \}
00228 
00229 \textcolor{comment}{// implements col-major += alpha * op(general) * op(triangular)}
00230 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keywordtype}{int} Mode,
00231           \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00232           \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int} Version>
00233 \textcolor{keyword}{struct }product\_triangular\_matrix\_matrix<Scalar,Index,Mode,false,
00234                                         LhsStorageOrder,ConjugateLhs,
00235                                         RhsStorageOrder,ConjugateRhs,ColMajor,Version>
00236 \{
00237   \textcolor{keyword}{typedef} gebp\_traits<Scalar,Scalar> Traits;
00238   \textcolor{keyword}{enum} \{
00239     SmallPanelWidth   = EIGEN\_PLAIN\_ENUM\_MAX(Traits::mr,Traits::nr),
00240     IsLower = (Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) == \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower},
00241     SetDiag = (Mode&(ZeroDiag|\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaddb72f888ac85d5a1c52333e54f9374b}{UnitDiag})) ? 0 : 1
00242   \};
00243 
00244   \textcolor{keyword}{static} EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} run(
00245     Index \_rows, Index \_cols, Index \_depth,
00246     \textcolor{keyword}{const} Scalar* \_lhs, Index lhsStride,
00247     \textcolor{keyword}{const} Scalar* \_rhs, Index rhsStride,
00248     Scalar* res,        Index resStride,
00249     \textcolor{keyword}{const} Scalar& alpha, level3\_blocking<Scalar,Scalar>& blocking);
00250 \};
00251 
00252 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}, \textcolor{keywordtype}{int} Mode,
00253           \textcolor{keywordtype}{int} LhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateLhs,
00254           \textcolor{keywordtype}{int} RhsStorageOrder, \textcolor{keywordtype}{bool} ConjugateRhs, \textcolor{keywordtype}{int} Version>
00255 EIGEN\_DONT\_INLINE \textcolor{keywordtype}{void} product\_triangular\_matrix\_matrix<Scalar,\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},Mode,\textcolor{keyword}{false},
00256                                                         LhsStorageOrder,ConjugateLhs,
00257                                                         RhsStorageOrder,ConjugateRhs,
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor},Version>::run(
00258     Index \_rows, Index \_cols, Index \_depth,
00259     \textcolor{keyword}{const} Scalar* \_lhs, Index lhsStride,
00260     \textcolor{keyword}{const} Scalar* \_rhs, Index rhsStride,
00261     Scalar* \_res,        Index resStride,
00262     \textcolor{keyword}{const} Scalar& alpha, level3\_blocking<Scalar,Scalar>& blocking)
00263   \{
00264     \textcolor{keyword}{const} Index PacketBytes = packet\_traits<Scalar>::size*\textcolor{keyword}{sizeof}(Scalar);
00265     \textcolor{comment}{// strip zeros}
00266     Index diagSize  = (std::min)(\_cols,\_depth);
00267     Index rows      = \_rows;
00268     Index depth     = IsLower ? \_depth : diagSize;
00269     Index cols      = IsLower ? diagSize : \_cols;
00270     
00271     \textcolor{keyword}{typedef} const\_blas\_data\_mapper<Scalar, Index, LhsStorageOrder> LhsMapper;
00272     \textcolor{keyword}{typedef} const\_blas\_data\_mapper<Scalar, Index, RhsStorageOrder> RhsMapper;
00273     \textcolor{keyword}{typedef} blas\_data\_mapper<typename Traits::ResScalar, Index, ColMajor> ResMapper;
00274     LhsMapper lhs(\_lhs,lhsStride);
00275     RhsMapper rhs(\_rhs,rhsStride);
00276     ResMapper res(\_res, resStride);
00277 
00278     Index kc = blocking.kc();                   \textcolor{comment}{// cache block size along the K direction}
00279     Index mc = (std::min)(rows,blocking.mc());  \textcolor{comment}{// cache block size along the M direction}
00280 
00281     std::size\_t sizeA = kc*mc;
00282     std::size\_t sizeB = kc*cols+EIGEN\_MAX\_ALIGN\_BYTES/\textcolor{keyword}{sizeof}(Scalar);
00283 
00284     ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, blockA, sizeA, blocking.blockA());
00285     ei\_declare\_aligned\_stack\_constructed\_variable(Scalar, blockB, sizeB, blocking.blockB());
00286 
00287     Matrix<Scalar,SmallPanelWidth,SmallPanelWidth,RhsStorageOrder> triangularBuffer((
      internal::constructor\_without\_unaligned\_array\_assert()));
00288     triangularBuffer.setZero();
00289     \textcolor{keywordflow}{if}((Mode&ZeroDiag)==ZeroDiag)
00290       triangularBuffer.diagonal().setZero();
00291     \textcolor{keywordflow}{else}
00292       triangularBuffer.diagonal().setOnes();
00293 
00294     gebp\_kernel<Scalar, Scalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> 
      gebp\_kernel;
00295     gemm\_pack\_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack\_lhs;
00296     gemm\_pack\_rhs<Scalar, Index, RhsMapper, Traits::nr,RhsStorageOrder> pack\_rhs;
00297     gemm\_pack\_rhs<Scalar, Index, RhsMapper, Traits::nr,RhsStorageOrder,false,true> pack\_rhs\_panel;
00298 
00299     \textcolor{keywordflow}{for}(Index k2=IsLower ? 0 : depth;
00300         IsLower ? k2<depth  : k2>0;
00301         IsLower ? k2+=kc   : k2-=kc)
00302     \{
00303       Index actual\_kc = (std::min)(IsLower ? depth-k2 : k2, kc);
00304       Index actual\_k2 = IsLower ? k2 : k2-actual\_kc;
00305 
00306       \textcolor{comment}{// align blocks with the end of the triangular part for trapezoidal rhs}
00307       \textcolor{keywordflow}{if}(IsLower && (k2<cols) && (actual\_k2+actual\_kc>cols))
00308       \{
00309         actual\_kc = cols-k2;
00310         k2 = actual\_k2 + actual\_kc - kc;
00311       \}
00312 
00313       \textcolor{comment}{// remaining size}
00314       Index rs = IsLower ? (std::min)(cols,actual\_k2) : cols - k2;
00315       \textcolor{comment}{// size of the triangular part}
00316       Index ts = (IsLower && actual\_k2>=cols) ? 0 : actual\_kc;
00317 
00318       Scalar* geb = blockB+ts*ts;
00319       geb = geb + internal::first\_aligned<PacketBytes>(geb,PacketBytes/\textcolor{keyword}{sizeof}(Scalar));
00320 
00321       pack\_rhs(geb, rhs.getSubMapper(actual\_k2,IsLower ? 0 : k2), actual\_kc, rs);
00322 
00323       \textcolor{comment}{// pack the triangular part of the rhs padding the unrolled blocks with zeros}
00324       \textcolor{keywordflow}{if}(ts>0)
00325       \{
00326         \textcolor{keywordflow}{for} (Index j2=0; j2<actual\_kc; j2+=SmallPanelWidth)
00327         \{
00328           Index actualPanelWidth = std::min<Index>(actual\_kc-j2, SmallPanelWidth);
00329           Index actual\_j2 = actual\_k2 + j2;
00330           Index panelOffset = IsLower ? j2+actualPanelWidth : 0;
00331           Index panelLength = IsLower ? actual\_kc-j2-actualPanelWidth : j2;
00332           \textcolor{comment}{// general part}
00333           pack\_rhs\_panel(blockB+j2*actual\_kc,
00334                          rhs.getSubMapper(actual\_k2+panelOffset, actual\_j2),
00335                          panelLength, actualPanelWidth,
00336                          actual\_kc, panelOffset);
00337 
00338           \textcolor{comment}{// append the triangular part via a temporary buffer}
00339           \textcolor{keywordflow}{for} (Index j=0;j<actualPanelWidth;++j)
00340           \{
00341             \textcolor{keywordflow}{if} (SetDiag)
00342               triangularBuffer.coeffRef(j,j) = rhs(actual\_j2+j,actual\_j2+j);
00343             \textcolor{keywordflow}{for} (Index k=IsLower ? j+1 : 0; IsLower ? k<actualPanelWidth : k<j; ++k)
00344               triangularBuffer.coeffRef(k,j) = rhs(actual\_j2+k,actual\_j2+j);
00345           \}
00346 
00347           pack\_rhs\_panel(blockB+j2*actual\_kc,
00348                          RhsMapper(triangularBuffer.data(), triangularBuffer.outerStride()),
00349                          actualPanelWidth, actualPanelWidth,
00350                          actual\_kc, j2);
00351         \}
00352       \}
00353 
00354       \textcolor{keywordflow}{for} (Index i2=0; i2<rows; i2+=mc)
00355       \{
00356         \textcolor{keyword}{const} Index actual\_mc = (std::min)(mc,rows-i2);
00357         pack\_lhs(blockA, lhs.getSubMapper(i2, actual\_k2), actual\_kc, actual\_mc);
00358 
00359         \textcolor{comment}{// triangular kernel}
00360         \textcolor{keywordflow}{if}(ts>0)
00361         \{
00362           \textcolor{keywordflow}{for} (Index j2=0; j2<actual\_kc; j2+=SmallPanelWidth)
00363           \{
00364             Index actualPanelWidth = std::min<Index>(actual\_kc-j2, SmallPanelWidth);
00365             Index panelLength = IsLower ? actual\_kc-j2 : j2+actualPanelWidth;
00366             Index blockOffset = IsLower ? j2 : 0;
00367 
00368             gebp\_kernel(res.getSubMapper(i2, actual\_k2 + j2),
00369                         blockA, blockB+j2*actual\_kc,
00370                         actual\_mc, panelLength, actualPanelWidth,
00371                         alpha,
00372                         actual\_kc, actual\_kc,  \textcolor{comment}{// strides}
00373                         blockOffset, blockOffset);\textcolor{comment}{// offsets}
00374           \}
00375         \}
00376         gebp\_kernel(res.getSubMapper(i2, IsLower ? 0 : k2),
00377                     blockA, geb, actual\_mc, actual\_kc, rs,
00378                     alpha,
00379                     -1, -1, 0, 0);
00380       \}
00381     \}
00382   \}
00383 
00384 \textcolor{comment}{/***************************************************************************}
00385 \textcolor{comment}{* Wrapper to product\_triangular\_matrix\_matrix}
00386 \textcolor{comment}{***************************************************************************/}
00387 
00388 \} \textcolor{comment}{// end namespace internal}
00389 
00390 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00391 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Mode, \textcolor{keywordtype}{bool} LhsIsTriangular, \textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>
00392 \textcolor{keyword}{struct }triangular\_product\_impl<Mode,LhsIsTriangular,Lhs,false,Rhs,false>
00393 \{
00394   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest> \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(Dest& dst, \textcolor{keyword}{const} Lhs &a\_lhs, \textcolor{keyword}{const} Rhs &a\_rhs, \textcolor{keyword}{const} \textcolor{keyword}{typename} 
      Dest::Scalar& alpha)
00395   \{
00396     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Dest::Scalar     Scalar;
00397     
00398     \textcolor{keyword}{typedef} internal::blas\_traits<Lhs> LhsBlasTraits;
00399     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsBlasTraits::DirectLinearAccessType ActualLhsType;
00400     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ActualLhsType>::type ActualLhsTypeCleaned;
00401     \textcolor{keyword}{typedef} internal::blas\_traits<Rhs> RhsBlasTraits;
00402     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsBlasTraits::DirectLinearAccessType ActualRhsType;
00403     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<ActualRhsType>::type ActualRhsTypeCleaned;
00404     
00405     \textcolor{keyword}{typename} internal::add\_const\_on\_value\_type<ActualLhsType>::type lhs = LhsBlasTraits::extract(a\_lhs);
00406     \textcolor{keyword}{typename} internal::add\_const\_on\_value\_type<ActualRhsType>::type rhs = RhsBlasTraits::extract(a\_rhs);
00407 
00408     Scalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(a\_lhs)
00409                                * RhsBlasTraits::extractScalarFactor(a\_rhs);
00410 
00411     \textcolor{keyword}{typedef} internal::gemm\_blocking\_space<(Dest::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : ColMajor,Scalar,Scalar,
00412               Lhs::MaxRowsAtCompileTime, Rhs::MaxColsAtCompileTime, Lhs::MaxColsAtCompileTime,4> 
      BlockingType;
00413 
00414     \textcolor{keyword}{enum} \{ IsLower = (Mode&\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}) == \hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower} \};
00415     Index stripedRows  = ((!LhsIsTriangular) || (IsLower))  ? lhs.rows() : (std::min)(lhs.rows(),lhs.cols()
      );
00416     Index stripedCols  = ((LhsIsTriangular)  || (!IsLower)) ? rhs.cols() : (std::min)(rhs.cols(),rhs.rows()
      );
00417     Index stripedDepth = LhsIsTriangular ? ((!IsLower) ? lhs.cols() : (std::min)(lhs.cols(),lhs.rows()))
00418                                          : ((IsLower)  ? rhs.rows() : (\hyperlink{namespacestd}{std}::min)(rhs.rows(),rhs.cols()))
      ;
00419 
00420     BlockingType blocking(stripedRows, stripedCols, stripedDepth, 1, \textcolor{keyword}{false});
00421 
00422     internal::product\_triangular\_matrix\_matrix<Scalar, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index},
00423       Mode, LhsIsTriangular,
00424       (internal::traits<ActualLhsTypeCleaned>::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : ColMajor, LhsBlasTraits::NeedToConjugate,
00425       (internal::traits<ActualRhsTypeCleaned>::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}, RhsBlasTraits::NeedToConjugate,
00426       (internal::traits<Dest          >::Flags&\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) ? 
      \hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor} : ColMajor>
00427       ::run(
00428         stripedRows, stripedCols, stripedDepth,   \textcolor{comment}{// sizes}
00429         &lhs.coeffRef(0,0), lhs.outerStride(),    \textcolor{comment}{// lhs info}
00430         &rhs.coeffRef(0,0), rhs.outerStride(),    \textcolor{comment}{// rhs info}
00431         &dst.coeffRef(0,0), dst.outerStride(),    \textcolor{comment}{// result info}
00432         actualAlpha, blocking
00433       );
00434   \}
00435 \};
00436 
00437 \} \textcolor{comment}{// end namespace internal}
00438 
00439 \} \textcolor{comment}{// end namespace Eigen}
00440 
00441 \textcolor{preprocessor}{#endif // EIGEN\_TRIANGULAR\_MATRIX\_MATRIX\_H}
\end{DoxyCode}
