\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_upper_bidiagonalization_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+S\+V\+D/\+Upper\+Bidiagonalization.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_upper_bidiagonalization_8h_source}\index{Upper\+Bidiagonalization.\+h@{Upper\+Bidiagonalization.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2010 Benoit Jacob <jacob.benoit.1@gmail.com>}
00005 \textcolor{comment}{// Copyright (C) 2013-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_BIDIAGONALIZATION\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_BIDIAGONALIZATION\_H}
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00017 \textcolor{comment}{// UpperBidiagonalization will probably be replaced by a Bidiagonalization class, don't want to make it
       stable API.}
00018 \textcolor{comment}{// At the same time, it's useful to keep for now as it's about the only thing that is testing the
       BandMatrix class.}
00019 
00020 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType> \textcolor{keyword}{class }UpperBidiagonalization
00021 \{
00022   \textcolor{keyword}{public}:
00023 
00024     \textcolor{keyword}{typedef} \_MatrixType MatrixType;
00025     \textcolor{keyword}{enum} \{
00026       RowsAtCompileTime = MatrixType::RowsAtCompileTime,
00027       ColsAtCompileTime = MatrixType::ColsAtCompileTime,
00028       ColsAtCompileTimeMinusOne = internal::decrement\_size<ColsAtCompileTime>::ret
00029     \};
00030     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00031     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_upper_bidiagonalization_8h_source_l00032}\hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{00032}     \textcolor{keyword}{typedef} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Eigen::Index} \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index}; 
00033     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, 1, ColsAtCompileTime>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{RowVectorType};
00034     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, RowsAtCompileTime, 1>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{ColVectorType};
00035     \textcolor{keyword}{typedef} 
      \hyperlink{group___core___module}{BandMatrix<RealScalar, ColsAtCompileTime, ColsAtCompileTime, 1, 0, RowMajor>}
       \hyperlink{group___core___module}{BidiagonalType};
00036     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, ColsAtCompileTime, 1>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{DiagVectorType};
00037     \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar, ColsAtCompileTimeMinusOne, 1>} 
      \hyperlink{group___core___module_class_eigen_1_1_matrix}{SuperDiagVectorType};
00038     \textcolor{keyword}{typedef} \hyperlink{group___householder___module_class_eigen_1_1_householder_sequence}{HouseholderSequence}<
00039               \textcolor{keyword}{const} MatrixType,
00040               \textcolor{keyword}{const} \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1remove__all}{internal::remove\_all<typename Diagonal<const MatrixType,0>::ConjugateReturnType}
      >::type
00041             > \hyperlink{group___householder___module_class_eigen_1_1_householder_sequence}{HouseholderUSequenceType};
00042     \textcolor{keyword}{typedef} \hyperlink{group___householder___module_class_eigen_1_1_householder_sequence}{HouseholderSequence}<
00043               \textcolor{keyword}{const} \textcolor{keyword}{typename} 
      \hyperlink{group___sparse_core___module}{internal::remove\_all<typename MatrixType::ConjugateReturnType>::type}
      ,
00044               \hyperlink{group___core___module_class_eigen_1_1_diagonal}{Diagonal<const MatrixType,1>},
00045               \hyperlink{group__enums_ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b}{OnTheRight}
00046             > \hyperlink{group___householder___module_class_eigen_1_1_householder_sequence}{HouseholderVSequenceType};
00047     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_s_v_d_2_upper_bidiagonalization_8h_source_l00054}\hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_aa37a7ca5f5e86e3efbc6907d03d89340}{00054}     \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_aa37a7ca5f5e86e3efbc6907d03d89340}{UpperBidiagonalization}() : m\_householder(), m\_bidiagonal(), m\_isInitialized(false
      ) \{\}
00055 
00056     \textcolor{keyword}{explicit} \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_aa37a7ca5f5e86e3efbc6907d03d89340}{UpperBidiagonalization}(\textcolor{keyword}{const} MatrixType& matrix)
00057       : m\_householder(matrix.rows(), matrix.cols()),
00058         m\_bidiagonal(matrix.cols(), matrix.cols()),
00059         m\_isInitialized(\textcolor{keyword}{false})
00060     \{
00061       compute(matrix);
00062     \}
00063     
00064     \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization}{UpperBidiagonalization}& compute(\textcolor{keyword}{const} MatrixType& matrix);
00065     \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization}{UpperBidiagonalization}& computeUnblocked(\textcolor{keyword}{const} MatrixType& matrix);
00066     
00067     \textcolor{keyword}{const} MatrixType& householder()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_householder; \}
00068     \textcolor{keyword}{const} BidiagonalType& bidiagonal()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_bidiagonal; \}
00069     
00070     \textcolor{keyword}{const} HouseholderUSequenceType householderU()\textcolor{keyword}{ const}
00071 \textcolor{keyword}{    }\{
00072       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"UpperBidiagonalization is not initialized."});
00073       \textcolor{keywordflow}{return} HouseholderUSequenceType(m\_householder, m\_householder.diagonal().conjugate());
00074     \}
00075 
00076     \textcolor{keyword}{const} HouseholderVSequenceType householderV() \textcolor{comment}{// const here gives nasty errors and i'm lazy}
00077     \{
00078       eigen\_assert(m\_isInitialized && \textcolor{stringliteral}{"UpperBidiagonalization is not initialized."});
00079       \textcolor{keywordflow}{return} HouseholderVSequenceType(m\_householder.conjugate(), m\_householder.const\_derived().template 
      diagonal<1>())
00080              .setLength(m\_householder.cols()-1)
00081              .setShift(1);
00082     \}
00083     
00084   \textcolor{keyword}{protected}:
00085     MatrixType m\_householder;
00086     BidiagonalType m\_bidiagonal;
00087     \textcolor{keywordtype}{bool} m\_isInitialized;
00088 \};
00089 
00090 \textcolor{comment}{// Standard upper bidiagonalization without fancy optimizations}
00091 \textcolor{comment}{// This version should be faster for small matrix size}
00092 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00093 \textcolor{keywordtype}{void} upperbidiagonalization\_inplace\_unblocked(MatrixType& mat,
00094                                               \textcolor{keyword}{typename} MatrixType::RealScalar *diagonal,
00095                                               \textcolor{keyword}{typename} MatrixType::RealScalar *upper\_diagonal,
00096                                               \textcolor{keyword}{typename} MatrixType::Scalar* tempData = 0)
00097 \{
00098   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00099 
00100   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} rows = mat.rows();
00101   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} cols = mat.cols();
00102 
00103   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix<Scalar,Dynamic,1,ColMajor,MatrixType::MaxRowsAtCompileTime,1>}
       TempType;
00104   TempType tempVector;
00105   \textcolor{keywordflow}{if}(tempData==0)
00106   \{
00107     tempVector.\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize}(rows);
00108     tempData = tempVector.data();
00109   \}
00110 
00111   \textcolor{keywordflow}{for} (\hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} k = 0; \textcolor{comment}{/* breaks at k==cols-1 below */} ; ++k)
00112   \{
00113     \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} remainingRows = rows - k;
00114     \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} remainingCols = cols - k - 1;
00115 
00116     \textcolor{comment}{// construct left householder transform in-place in A}
00117     mat.col(k).tail(remainingRows)
00118        .makeHouseholderInPlace(mat.coeffRef(k,k), diagonal[k]);
00119     \textcolor{comment}{// apply householder transform to remaining part of A on the left}
00120     mat.bottomRightCorner(remainingRows, remainingCols)
00121        .applyHouseholderOnTheLeft(mat.col(k).tail(remainingRows-1), mat.coeff(k,k), tempData);
00122 
00123     \textcolor{keywordflow}{if}(k == cols-1) \textcolor{keywordflow}{break};
00124 
00125     \textcolor{comment}{// construct right householder transform in-place in mat}
00126     mat.row(k).tail(remainingCols)
00127        .makeHouseholderInPlace(mat.coeffRef(k,k+1), upper\_diagonal[k]);
00128     \textcolor{comment}{// apply householder transform to remaining part of mat on the left}
00129     mat.bottomRightCorner(remainingRows-1, remainingCols)
00130        .applyHouseholderOnTheRight(mat.row(k).tail(remainingCols-1).transpose(), mat.coeff(k,k+1), tempData
      );
00131   \}
00132 \}
00133 
00151 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType>
00152 \textcolor{keywordtype}{void} upperbidiagonalization\_blocked\_helper(MatrixType& \hyperlink{group___core___module_class_eigen_1_1_matrix}{A},
00153                                            \textcolor{keyword}{typename} MatrixType::RealScalar *diagonal,
00154                                            \textcolor{keyword}{typename} MatrixType::RealScalar *upper\_diagonal,
00155                                            \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} bs,
00156                                            \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<\textcolor{keyword}{typename} MatrixType::Scalar, 
      \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00157                                                       \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<MatrixType>::Flags} & 
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}> > X,
00158                                            \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref}<\hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<\textcolor{keyword}{typename} MatrixType::Scalar, 
      \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}, \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00159                                                       \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<MatrixType>::Flags} & 
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}> > Y)
00160 \{
00161   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00162   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::RealScalar RealScalar;
00163   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::Literal} Literal;
00164   \textcolor{keyword}{enum} \{ StorageOrder = \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<MatrixType>::Flags} & 
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} \};
00165   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_inner_stride}{InnerStride<int(StorageOrder) == int(ColMajor) ? 1 : Dynamic>}
       ColInnerStride;
00166   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_inner_stride}{InnerStride<int(StorageOrder) == int(ColMajor) ? Dynamic : 1>}
       RowInnerStride;
00167   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<Matrix<Scalar, Dynamic, 1>}, 0, ColInnerStride>    SubColumnType
      ;
00168   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<Matrix<Scalar, 1, Dynamic>}, 0, RowInnerStride>    SubRowType;
00169   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_ref}{Ref<Matrix<Scalar, Dynamic, Dynamic, StorageOrder >}
       > SubMatType;
00170   
00171   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} brows = A.rows();
00172   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} bcols = A.cols();
00173 
00174   Scalar tau\_u, tau\_u\_prev(0), tau\_v;
00175 
00176   \textcolor{keywordflow}{for}(\hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} k = 0; k < bs; ++k)
00177   \{
00178     \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} remainingRows = brows - k;
00179     \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} remainingCols = bcols - k - 1;
00180 
00181     SubMatType X\_k1( X.block(k,0, remainingRows,k) );
00182     SubMatType V\_k1( A.block(k,0, remainingRows,k) );
00183 
00184     \textcolor{comment}{// 1 - update the k-th column of A}
00185     SubColumnType v\_k = A.col(k).tail(remainingRows);
00186           v\_k -= V\_k1 * Y.row(k).head(k).adjoint();
00187     \textcolor{keywordflow}{if}(k) v\_k -= X\_k1 * A.col(k).head(k);
00188     
00189     \textcolor{comment}{// 2 - construct left Householder transform in-place}
00190     v\_k.makeHouseholderInPlace(tau\_v, diagonal[k]);
00191        
00192     \textcolor{keywordflow}{if}(k+1<bcols)
00193     \{
00194       SubMatType Y\_k  ( Y.block(k+1,0, remainingCols, k+1) );
00195       SubMatType U\_k1 ( A.block(0,k+1, k,remainingCols) );
00196       
00197       \textcolor{comment}{// this eases the application of Householder transforAions}
00198       \textcolor{comment}{// A(k,k) will store tau\_v later}
00199       A(k,k) = Scalar(1);
00200 
00201       \textcolor{comment}{// 3 - Compute y\_k^T = tau\_v * ( A^T*v\_k - Y\_k-1*V\_k-1^T*v\_k - U\_k-1*X\_k-1^T*v\_k )}
00202       \{
00203         SubColumnType y\_k( Y.col(k).tail(remainingCols) );
00204         
00205         \textcolor{comment}{// let's use the begining of column k of Y as a temporary vector}
00206         SubColumnType tmp( Y.col(k).head(k) );
00207         y\_k.noalias()  = A.block(k,k+1, remainingRows,remainingCols).adjoint() * v\_k; \textcolor{comment}{// bottleneck}
00208         tmp.noalias()  = V\_k1.adjoint()  * v\_k;
00209         y\_k.noalias() -= Y\_k.leftCols(k) * tmp;
00210         tmp.noalias()  = X\_k1.adjoint()  * v\_k;
00211         y\_k.noalias() -= U\_k1.adjoint()  * tmp;
00212         y\_k *= numext::conj(tau\_v);
00213       \}
00214 
00215       \textcolor{comment}{// 4 - update k-th row of A (it will become u\_k)}
00216       SubRowType u\_k( A.row(k).tail(remainingCols) );
00217       u\_k = u\_k.conjugate();
00218       \{
00219         u\_k -= Y\_k * A.row(k).head(k+1).adjoint();
00220         \textcolor{keywordflow}{if}(k) u\_k -= U\_k1.adjoint() * X.row(k).head(k).adjoint();
00221       \}
00222 
00223       \textcolor{comment}{// 5 - construct right Householder transform in-place}
00224       u\_k.makeHouseholderInPlace(tau\_u, upper\_diagonal[k]);
00225 
00226       \textcolor{comment}{// this eases the application of Householder transformations}
00227       \textcolor{comment}{// A(k,k+1) will store tau\_u later}
00228       A(k,k+1) = Scalar(1);
00229 
00230       \textcolor{comment}{// 6 - Compute x\_k = tau\_u * ( A*u\_k - X\_k-1*U\_k-1^T*u\_k - V\_k*Y\_k^T*u\_k )}
00231       \{
00232         SubColumnType x\_k ( X.col(k).tail(remainingRows-1) );
00233         
00234         \textcolor{comment}{// let's use the begining of column k of X as a temporary vectors}
00235         \textcolor{comment}{// note that tmp0 and tmp1 overlaps}
00236         SubColumnType tmp0 ( X.col(k).head(k) ),
00237                       tmp1 ( X.col(k).head(k+1) );
00238                     
00239         x\_k.noalias()   = A.block(k+1,k+1, remainingRows-1,remainingCols) * u\_k.transpose(); \textcolor{comment}{// bottleneck}
00240         tmp0.noalias()  = U\_k1 * u\_k.transpose();
00241         x\_k.noalias()  -= X\_k1.bottomRows(remainingRows-1) * tmp0;
00242         tmp1.noalias()  = Y\_k.adjoint() * u\_k.transpose();
00243         x\_k.noalias()  -= A.block(k+1,0, remainingRows-1,k+1) * tmp1;
00244         x\_k *= numext::conj(tau\_u);
00245         tau\_u = numext::conj(tau\_u);
00246         u\_k = u\_k.conjugate();
00247       \}
00248 
00249       \textcolor{keywordflow}{if}(k>0) A.coeffRef(k-1,k) = tau\_u\_prev;
00250       tau\_u\_prev = tau\_u;
00251     \}
00252     \textcolor{keywordflow}{else}
00253       A.coeffRef(k-1,k) = tau\_u\_prev;
00254 
00255     A.coeffRef(k,k) = tau\_v;
00256   \}
00257   
00258   \textcolor{keywordflow}{if}(bs<bcols)
00259     A.coeffRef(bs-1,bs) = tau\_u\_prev;
00260 
00261   \textcolor{comment}{// update A22}
00262   \textcolor{keywordflow}{if}(bcols>bs && brows>bs)
00263   \{
00264     SubMatType A11( A.bottomRightCorner(brows-bs,bcols-bs) );
00265     SubMatType A10( A.block(bs,0, brows-bs,bs) );
00266     SubMatType A01( A.block(0,bs, bs,bcols-bs) );
00267     Scalar tmp = A01(bs-1,0);
00268     A01(bs-1,0) = Literal(1);
00269     A11.noalias() -= A10 * Y.topLeftCorner(bcols,bs).bottomRows(bcols-bs).adjoint();
00270     A11.noalias() -= X.topLeftCorner(brows,bs).bottomRows(brows-bs) * A01;
00271     A01(bs-1,0) = tmp;
00272   \}
00273 \}
00274 
00283 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MatrixType, \textcolor{keyword}{typename} B\textcolor{keywordtype}{id}iagType>
00284 \textcolor{keywordtype}{void} upperbidiagonalization\_inplace\_blocked(MatrixType& A, BidiagType& bidiagonal,
00285                                             \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} maxBlockSize=32,
00286                                             \textcolor{keyword}{typename} MatrixType::Scalar* \textcolor{comment}{/*tempData*/} = 0)
00287 \{
00288   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} MatrixType::Scalar Scalar;
00289   \textcolor{keyword}{typedef} \hyperlink{group___core___module_class_eigen_1_1_block}{Block<MatrixType,Dynamic,Dynamic>} BlockType;
00290 
00291   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} rows = A.rows();
00292   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} cols = A.cols();
00293   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} size = (std::min)(rows, cols);
00294 
00295   \textcolor{comment}{// X and Y are work space}
00296   \textcolor{keyword}{enum} \{ StorageOrder = \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<MatrixType>::Flags} & 
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit} \};
00297   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<Scalar,
00298          MatrixType::RowsAtCompileTime,
00299          \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00300          StorageOrder,
00301          MatrixType::MaxRowsAtCompileTime> X(rows,maxBlockSize);
00302   \hyperlink{group___core___module_class_eigen_1_1_matrix}{Matrix}<Scalar,
00303          MatrixType::ColsAtCompileTime,
00304          \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00305          StorageOrder,
00306          MatrixType::MaxColsAtCompileTime> Y(cols,maxBlockSize);
00307   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} blockSize = (std::min)(maxBlockSize,size);
00308 
00309   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} k = 0;
00310   \textcolor{keywordflow}{for}(k = 0; k < size; k += blockSize)
00311   \{
00312     \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} bs = (std::min)(size-k,blockSize);  \textcolor{comment}{// actual size of the block}
00313     \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} brows = rows - k;                   \textcolor{comment}{// rows of the block}
00314     \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} bcols = cols - k;                   \textcolor{comment}{// columns of the block}
00315 
00316     \textcolor{comment}{// partition the matrix A:}
00317     \textcolor{comment}{// }
00318     \textcolor{comment}{//      | A00 A01 A02 |}
00319     \textcolor{comment}{//      |             |}
00320     \textcolor{comment}{// A  = | A10 A11 A12 |}
00321     \textcolor{comment}{//      |             |}
00322     \textcolor{comment}{//      | A20 A21 A22 |}
00323     \textcolor{comment}{//}
00324     \textcolor{comment}{// where A11 is a bs x bs diagonal block,}
00325     \textcolor{comment}{// and let:}
00326     \textcolor{comment}{//      | A11 A12 |}
00327     \textcolor{comment}{//  B = |         |}
00328     \textcolor{comment}{//      | A21 A22 |}
00329 
00330     BlockType \hyperlink{group___core___module_class_eigen_1_1_matrix}{B} = A.block(k,k,brows,bcols);
00331     
00332     \textcolor{comment}{// This stage performs the bidiagonalization of A11, A21, A12, and updating of A22.}
00333     \textcolor{comment}{// Finally, the algorithm continue on the updated A22.}
00334     \textcolor{comment}{//}
00335     \textcolor{comment}{// However, if B is too small, or A22 empty, then let's use an unblocked strategy}
00336     \textcolor{keywordflow}{if}(k+bs==cols || bcols<48) \textcolor{comment}{// somewhat arbitrary threshold}
00337     \{
00338       upperbidiagonalization\_inplace\_unblocked(B,
00339                                                &(bidiagonal.template diagonal<0>().coeffRef(k)),
00340                                                &(bidiagonal.template diagonal<1>().coeffRef(k)),
00341                                                X.data()
00342                                               );
00343       \textcolor{keywordflow}{break}; \textcolor{comment}{// We're done}
00344     \}
00345     \textcolor{keywordflow}{else}
00346     \{
00347       upperbidiagonalization\_blocked\_helper<BlockType>( B,
00348                                                         &(bidiagonal.template diagonal<0>().coeffRef(k)),
00349                                                         &(bidiagonal.template diagonal<1>().coeffRef(k)),
00350                                                         bs,
00351                                                         X.topLeftCorner(brows,bs),
00352                                                         Y.topLeftCorner(bcols,bs)
00353                                                       );
00354     \}
00355   \}
00356 \}
00357 
00358 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
00359 \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization}{UpperBidiagonalization<\_MatrixType>}& 
      \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization}{UpperBidiagonalization<\_MatrixType>::computeUnblocked}(\textcolor{keyword}{
      const} \_MatrixType& matrix)
00360 \{
00361   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} rows = matrix.rows();
00362   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} cols = matrix.cols();
00363   EIGEN\_ONLY\_USED\_FOR\_DEBUG(cols);
00364 
00365   eigen\_assert(rows >= cols && \textcolor{stringliteral}{"UpperBidiagonalization is only for Arices satisfying rows>=cols."});
00366 
00367   m\_householder = matrix;
00368 
00369   \hyperlink{group___core___module_class_eigen_1_1_matrix}{ColVectorType} temp(rows);
00370 
00371   upperbidiagonalization\_inplace\_unblocked(m\_householder,
00372                                            &(m\_bidiagonal.template diagonal<0>().coeffRef(0)),
00373                                            &(m\_bidiagonal.template diagonal<1>().coeffRef(0)),
00374                                            temp.\hyperlink{class_eigen_1_1_plain_object_base_ac25699535374b1854cf8494e44ad31b2}{data}());
00375 
00376   m\_isInitialized = \textcolor{keyword}{true};
00377   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00378 \}
00379 
00380 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_MatrixType>
00381 \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization}{UpperBidiagonalization<\_MatrixType>}& 
      \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization}{UpperBidiagonalization<\_MatrixType>::compute}(\textcolor{keyword}{const} \_MatrixType&
       matrix)
00382 \{
00383   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} rows = matrix.rows();
00384   \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization_adcb14f3919a3dcc9977ba6b8105087fe}{Index} cols = matrix.cols();
00385   EIGEN\_ONLY\_USED\_FOR\_DEBUG(rows);
00386   EIGEN\_ONLY\_USED\_FOR\_DEBUG(cols);
00387 
00388   eigen\_assert(rows >= cols && \textcolor{stringliteral}{"UpperBidiagonalization is only for Arices satisfying rows>=cols."});
00389 
00390   m\_householder = matrix;
00391   upperbidiagonalization\_inplace\_blocked(m\_householder, m\_bidiagonal);
00392             
00393   m\_isInitialized = \textcolor{keyword}{true};
00394   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00395 \}
00396 
00397 \textcolor{preprocessor}{#if 0}
00398 
00402 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>
00403 \textcolor{keyword}{const} \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization}{UpperBidiagonalization<typename MatrixBase<Derived>::PlainObject}
      >
00404 \hyperlink{group___core___module_class_eigen_1_1_matrix_base}{MatrixBase<Derived>::bidiagonalization}()\textcolor{keyword}{ const}
00405 \textcolor{keyword}{}\{
00406   \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1internal_1_1_upper_bidiagonalization}{UpperBidiagonalization<PlainObject>}(
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}());
00407 \}
00408 \textcolor{preprocessor}{#endif}
00409 
00410 \} \textcolor{comment}{// end namespace internal}
00411 
00412 \} \textcolor{comment}{// end namespace Eigen}
00413 
00414 \textcolor{preprocessor}{#endif // EIGEN\_BIDIAGONALIZATION\_H}
\end{DoxyCode}
