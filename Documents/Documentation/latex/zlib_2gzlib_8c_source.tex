\hypertarget{zlib_2gzlib_8c_source}{}\section{zlib/gzlib.c}
\label{zlib_2gzlib_8c_source}\index{gzlib.\+c@{gzlib.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* gzlib.c -- zlib functions common to reading and writing gzip files}
00002 \textcolor{comment}{ * Copyright (C) 2004-2017 Mark Adler}
00003 \textcolor{comment}{ * For conditions of distribution and use, see copyright notice in zlib.h}
00004 \textcolor{comment}{ */}
00005 
00006 \textcolor{preprocessor}{#include "gzguts.h"}
00007 
00008 \textcolor{preprocessor}{#if defined(\_WIN32) && !defined(\_\_BORLANDC\_\_) && !defined(\_\_MINGW32\_\_)}
00009 \textcolor{preprocessor}{#  define LSEEK \_lseeki64}
00010 \textcolor{preprocessor}{#else}
00011 \textcolor{preprocessor}{#if defined(\_LARGEFILE64\_SOURCE) && \_LFS64\_LARGEFILE-0}
00012 \textcolor{preprocessor}{#  define LSEEK lseek64}
00013 \textcolor{preprocessor}{#else}
00014 \textcolor{preprocessor}{#  define LSEEK lseek}
00015 \textcolor{preprocessor}{#endif}
00016 \textcolor{preprocessor}{#endif}
00017 
00018 \textcolor{comment}{/* Local functions */}
00019 local \textcolor{keywordtype}{void} gz\_reset OF((gz\_statep));
00020 local \hyperlink{structgz_file__s}{gzFile} gz\_open OF((\textcolor{keyword}{const} \textcolor{keywordtype}{void} *, \textcolor{keywordtype}{int}, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *));
00021 
00022 \textcolor{preprocessor}{#if defined UNDER\_CE}
00023 
00024 \textcolor{comment}{/* Map the Windows error number in ERROR to a locale-dependent error message}
00025 \textcolor{comment}{   string and return a pointer to it.  Typically, the values for ERROR come}
00026 \textcolor{comment}{   from GetLastError.}
00027 \textcolor{comment}{}
00028 \textcolor{comment}{   The string pointed to shall not be modified by the application, but may be}
00029 \textcolor{comment}{   overwritten by a subsequent call to gz\_strwinerror}
00030 \textcolor{comment}{}
00031 \textcolor{comment}{   The gz\_strwinerror function does not change the current setting of}
00032 \textcolor{comment}{   GetLastError. */}
00033 \textcolor{keywordtype}{char} ZLIB\_INTERNAL *gz\_strwinerror (error)
00034      DWORD error;
00035 \{
00036     \textcolor{keyword}{static} \textcolor{keywordtype}{char} buf[1024];
00037 
00038     \textcolor{keywordtype}{wchar\_t} *msgbuf;
00039     DWORD lasterr = GetLastError();
00040     DWORD chars = FormatMessage(FORMAT\_MESSAGE\_FROM\_SYSTEM
00041         | FORMAT\_MESSAGE\_ALLOCATE\_BUFFER,
00042         NULL,
00043         error,
00044         0, \textcolor{comment}{/* Default language */}
00045         (LPVOID)&msgbuf,
00046         0,
00047         NULL);
00048     \textcolor{keywordflow}{if} (chars != 0) \{
00049         \textcolor{comment}{/* If there is an \(\backslash\)r\(\backslash\)n appended, zap it.  */}
00050         \textcolor{keywordflow}{if} (chars >= 2
00051             && msgbuf[chars - 2] == \textcolor{charliteral}{'\(\backslash\)r'} && msgbuf[chars - 1] == \textcolor{charliteral}{'\(\backslash\)n'}) \{
00052             chars -= 2;
00053             msgbuf[chars] = 0;
00054         \}
00055 
00056         \textcolor{keywordflow}{if} (chars > \textcolor{keyword}{sizeof} (buf) - 1) \{
00057             chars = \textcolor{keyword}{sizeof} (buf) - 1;
00058             msgbuf[chars] = 0;
00059         \}
00060 
00061         wcstombs(buf, msgbuf, chars + 1);
00062         LocalFree(msgbuf);
00063     \}
00064     \textcolor{keywordflow}{else} \{
00065         sprintf(buf, \textcolor{stringliteral}{"unknown win32 error (%ld)"}, error);
00066     \}
00067 
00068     SetLastError(lasterr);
00069     \textcolor{keywordflow}{return} buf;
00070 \}
00071 
00072 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* UNDER\_CE */}\textcolor{preprocessor}{}
00073 
00074 \textcolor{comment}{/* Reset gzip file state */}
00075 local \textcolor{keywordtype}{void} gz\_reset(\hyperlink{structstate}{state})
00076     gz\_statep \hyperlink{structstate}{state};
00077 \{
00078     state->x.have = 0;              \textcolor{comment}{/* no output data available */}
00079     \textcolor{keywordflow}{if} (state->mode == GZ\_READ) \{   \textcolor{comment}{/* for reading ... */}
00080         state->eof = 0;             \textcolor{comment}{/* not at end of file */}
00081         state->past = 0;            \textcolor{comment}{/* have not read past end yet */}
00082         state->how = LOOK;          \textcolor{comment}{/* look for gzip header */}
00083     \}
00084     state->seek = 0;                \textcolor{comment}{/* no seek request pending */}
00085     gz\_error(state, Z\_OK, NULL);    \textcolor{comment}{/* clear error */}
00086     state->x.pos = 0;               \textcolor{comment}{/* no uncompressed data yet */}
00087     state->strm.avail\_in = 0;       \textcolor{comment}{/* no input data yet */}
00088 \}
00089 
00090 \textcolor{comment}{/* Open a gzip file either by name or file descriptor. */}
00091 local \hyperlink{structgz_file__s}{gzFile} gz\_open(path, fd, mode)
00092     \textcolor{keyword}{const} \textcolor{keywordtype}{void} *path;
00093     \textcolor{keywordtype}{int} fd;
00094     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *mode;
00095 \{
00096     gz\_statep state;
00097     z\_size\_t len;
00098     \textcolor{keywordtype}{int} oflag;
00099 \textcolor{preprocessor}{#ifdef O\_CLOEXEC}
00100     \textcolor{keywordtype}{int} cloexec = 0;
00101 \textcolor{preprocessor}{#endif}
00102 \textcolor{preprocessor}{#ifdef O\_EXCL}
00103     \textcolor{keywordtype}{int} exclusive = 0;
00104 \textcolor{preprocessor}{#endif}
00105 
00106     \textcolor{comment}{/* check input */}
00107     \textcolor{keywordflow}{if} (path == NULL)
00108         \textcolor{keywordflow}{return} NULL;
00109 
00110     \textcolor{comment}{/* allocate gzFile structure to return */}
00111     state = (gz\_statep)malloc(\textcolor{keyword}{sizeof}(\hyperlink{structgz__state}{gz\_state}));
00112     \textcolor{keywordflow}{if} (state == NULL)
00113         \textcolor{keywordflow}{return} NULL;
00114     state->size = 0;            \textcolor{comment}{/* no buffers allocated yet */}
00115     state->want = GZBUFSIZE;    \textcolor{comment}{/* requested buffer size */}
00116     state->msg = NULL;          \textcolor{comment}{/* no error message yet */}
00117 
00118     \textcolor{comment}{/* interpret mode */}
00119     state->mode = GZ\_NONE;
00120     state->level = Z\_DEFAULT\_COMPRESSION;
00121     state->strategy = Z\_DEFAULT\_STRATEGY;
00122     state->direct = 0;
00123     \textcolor{keywordflow}{while} (*mode) \{
00124         \textcolor{keywordflow}{if} (*mode >= \textcolor{charliteral}{'0'} && *mode <= \textcolor{charliteral}{'9'})
00125             state->level = *mode - \textcolor{charliteral}{'0'};
00126         \textcolor{keywordflow}{else}
00127             \textcolor{keywordflow}{switch} (*mode) \{
00128             \textcolor{keywordflow}{case} \textcolor{charliteral}{'r'}:
00129                 state->mode = GZ\_READ;
00130                 \textcolor{keywordflow}{break};
00131 \textcolor{preprocessor}{#ifndef NO\_GZCOMPRESS}
00132             \textcolor{keywordflow}{case} \textcolor{charliteral}{'w'}:
00133                 state->mode = GZ\_WRITE;
00134                 \textcolor{keywordflow}{break};
00135             \textcolor{keywordflow}{case} \textcolor{charliteral}{'a'}:
00136                 state->mode = GZ\_APPEND;
00137                 \textcolor{keywordflow}{break};
00138 \textcolor{preprocessor}{#endif}
00139             \textcolor{keywordflow}{case} \textcolor{charliteral}{'+'}:       \textcolor{comment}{/* can't read and write at the same time */}
00140                 free(state);
00141                 \textcolor{keywordflow}{return} NULL;
00142             \textcolor{keywordflow}{case} \textcolor{charliteral}{'b'}:       \textcolor{comment}{/* ignore -- will request binary anyway */}
00143                 \textcolor{keywordflow}{break};
00144 \textcolor{preprocessor}{#ifdef O\_CLOEXEC}
00145             \textcolor{keywordflow}{case} \textcolor{charliteral}{'e'}:
00146                 cloexec = 1;
00147                 \textcolor{keywordflow}{break};
00148 \textcolor{preprocessor}{#endif}
00149 \textcolor{preprocessor}{#ifdef O\_EXCL}
00150             \textcolor{keywordflow}{case} \textcolor{charliteral}{'x'}:
00151                 exclusive = 1;
00152                 \textcolor{keywordflow}{break};
00153 \textcolor{preprocessor}{#endif}
00154             \textcolor{keywordflow}{case} \textcolor{charliteral}{'f'}:
00155                 state->strategy = Z\_FILTERED;
00156                 \textcolor{keywordflow}{break};
00157             \textcolor{keywordflow}{case} \textcolor{charliteral}{'h'}:
00158                 state->strategy = Z\_HUFFMAN\_ONLY;
00159                 \textcolor{keywordflow}{break};
00160             \textcolor{keywordflow}{case} \textcolor{charliteral}{'R'}:
00161                 state->strategy = Z\_RLE;
00162                 \textcolor{keywordflow}{break};
00163             \textcolor{keywordflow}{case} \textcolor{charliteral}{'F'}:
00164                 state->strategy = Z\_FIXED;
00165                 \textcolor{keywordflow}{break};
00166             \textcolor{keywordflow}{case} \textcolor{charliteral}{'T'}:
00167                 state->direct = 1;
00168                 \textcolor{keywordflow}{break};
00169             \textcolor{keywordflow}{default}:        \textcolor{comment}{/* could consider as an error, but just ignore */}
00170                 ;
00171             \}
00172         mode++;
00173     \}
00174 
00175     \textcolor{comment}{/* must provide an "r", "w", or "a" */}
00176     \textcolor{keywordflow}{if} (state->mode == GZ\_NONE) \{
00177         free(state);
00178         \textcolor{keywordflow}{return} NULL;
00179     \}
00180 
00181     \textcolor{comment}{/* can't force transparent read */}
00182     \textcolor{keywordflow}{if} (state->mode == GZ\_READ) \{
00183         \textcolor{keywordflow}{if} (state->direct) \{
00184             free(state);
00185             \textcolor{keywordflow}{return} NULL;
00186         \}
00187         state->direct = 1;      \textcolor{comment}{/* for empty file */}
00188     \}
00189 
00190     \textcolor{comment}{/* save the path name for error messages */}
00191 \textcolor{preprocessor}{#ifdef WIDECHAR}
00192     \textcolor{keywordflow}{if} (fd == -2) \{
00193         len = wcstombs(NULL, path, 0);
00194         \textcolor{keywordflow}{if} (len == (z\_size\_t)-1)
00195             len = 0;
00196     \}
00197     \textcolor{keywordflow}{else}
00198 \textcolor{preprocessor}{#endif}
00199         len = strlen((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)path);
00200     state->path = (\textcolor{keywordtype}{char} *)malloc(len + 1);
00201     \textcolor{keywordflow}{if} (state->path == NULL) \{
00202         free(state);
00203         \textcolor{keywordflow}{return} NULL;
00204     \}
00205 \textcolor{preprocessor}{#ifdef WIDECHAR}
00206     \textcolor{keywordflow}{if} (fd == -2)
00207         \textcolor{keywordflow}{if} (len)
00208             wcstombs(state->path, path, len + 1);
00209         \textcolor{keywordflow}{else}
00210             *(state->path) = 0;
00211     \textcolor{keywordflow}{else}
00212 \textcolor{preprocessor}{#endif}
00213 \textcolor{preprocessor}{#if !defined(NO\_snprintf) && !defined(NO\_vsnprintf)}
00214         (void)snprintf(state->path, len + 1, \textcolor{stringliteral}{"%s"}, (\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)path);
00215 \textcolor{preprocessor}{#else}
00216         strcpy(state->path, path);
00217 \textcolor{preprocessor}{#endif}
00218 
00219     \textcolor{comment}{/* compute the flags for open() */}
00220     oflag =
00221 \textcolor{preprocessor}{#ifdef O\_LARGEFILE}
00222         O\_LARGEFILE |
00223 \textcolor{preprocessor}{#endif}
00224 \textcolor{preprocessor}{#ifdef O\_BINARY}
00225         O\_BINARY |
00226 \textcolor{preprocessor}{#endif}
00227 \textcolor{preprocessor}{#ifdef O\_CLOEXEC}
00228         (cloexec ? O\_CLOEXEC : 0) |
00229 #endif
00230         (state->mode == GZ\_READ ?
00231          O\_RDONLY :
00232          (O\_WRONLY | O\_CREAT |
00233 #ifdef O\_EXCL
00234           (exclusive ? O\_EXCL : 0) |
00235 #endif
00236           (state->mode == GZ\_WRITE ?
00237            O\_TRUNC :
00238            O\_APPEND)));
00239 
00240     \textcolor{comment}{/* open the file with the appropriate flags (or just use fd) */}
00241     state->fd = fd > -1 ? fd : (
00242 \textcolor{preprocessor}{#ifdef WIDECHAR}
00243         fd == -2 ? \_wopen(path, oflag, 0666) :
00244 #endif
00245         open((const char *)path, oflag, 0666));
00246     \textcolor{keywordflow}{if} (state->fd == -1) \{
00247         free(state->path);
00248         free(state);
00249         \textcolor{keywordflow}{return} NULL;
00250     \}
00251     \textcolor{keywordflow}{if} (state->mode == GZ\_APPEND) \{
00252         LSEEK(state->fd, 0, SEEK\_END);  \textcolor{comment}{/* so gzoffset() is correct */}
00253         state->mode = GZ\_WRITE;         \textcolor{comment}{/* simplify later checks */}
00254     \}
00255 
00256     \textcolor{comment}{/* save the current position for rewinding (only if reading) */}
00257     \textcolor{keywordflow}{if} (state->mode == GZ\_READ) \{
00258         state->start = LSEEK(state->fd, 0, SEEK\_CUR);
00259         \textcolor{keywordflow}{if} (state->start == -1) state->start = 0;
00260     \}
00261 
00262     \textcolor{comment}{/* initialize stream */}
00263     gz\_reset(state);
00264 
00265     \textcolor{comment}{/* return stream */}
00266     \textcolor{keywordflow}{return} (\hyperlink{structgz_file__s}{gzFile})state;
00267 \}
00268 
00269 \textcolor{comment}{/* -- see zlib.h -- */}
00270 \hyperlink{structgz_file__s}{gzFile} ZEXPORT gzopen(path, mode)
00271     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *path;
00272     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *mode;
00273 \{
00274     \textcolor{keywordflow}{return} gz\_open(path, -1, mode);
00275 \}
00276 
00277 \textcolor{comment}{/* -- see zlib.h -- */}
00278 \hyperlink{structgz_file__s}{gzFile} ZEXPORT gzopen64(path, mode)
00279     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *path;
00280     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *mode;
00281 \{
00282     \textcolor{keywordflow}{return} gz\_open(path, -1, mode);
00283 \}
00284 
00285 \textcolor{comment}{/* -- see zlib.h -- */}
00286 \hyperlink{structgz_file__s}{gzFile} ZEXPORT gzdopen(fd, mode)
00287     \textcolor{keywordtype}{int} fd;
00288     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *mode;
00289 \{
00290     \textcolor{keywordtype}{char} *path;         \textcolor{comment}{/* identifier for error messages */}
00291     \hyperlink{structgz_file__s}{gzFile} gz;
00292 
00293     \textcolor{keywordflow}{if} (fd == -1 || (path = (\textcolor{keywordtype}{char} *)malloc(7 + 3 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}))) == NULL)
00294         \textcolor{keywordflow}{return} NULL;
00295 \textcolor{preprocessor}{#if !defined(NO\_snprintf) && !defined(NO\_vsnprintf)}
00296     (void)snprintf(path, 7 + 3 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}), \textcolor{stringliteral}{"<fd:%d>"}, fd);
00297 \textcolor{preprocessor}{#else}
00298     sprintf(path, \textcolor{stringliteral}{"<fd:%d>"}, fd);   \textcolor{comment}{/* for debugging */}
00299 \textcolor{preprocessor}{#endif}
00300     gz = gz\_open(path, fd, mode);
00301     free(path);
00302     \textcolor{keywordflow}{return} gz;
00303 \}
00304 
00305 \textcolor{comment}{/* -- see zlib.h -- */}
00306 \textcolor{preprocessor}{#ifdef WIDECHAR}
00307 \hyperlink{structgz_file__s}{gzFile} ZEXPORT gzopen\_w(path, mode)
00308     \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t} *path;
00309     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *mode;
00310 \{
00311     \textcolor{keywordflow}{return} gz\_open(path, -2, mode);
00312 \}
00313 \textcolor{preprocessor}{#endif}
00314 
00315 \textcolor{comment}{/* -- see zlib.h -- */}
00316 \textcolor{keywordtype}{int} ZEXPORT gzbuffer(\hyperlink{structfile}{file}, size)
00317     \hyperlink{structgz_file__s}{gzFile} \hyperlink{structfile}{file};
00318     \textcolor{keywordtype}{unsigned} size;
00319 \{
00320     gz\_statep state;
00321 
00322     \textcolor{comment}{/* get internal structure and check integrity */}
00323     \textcolor{keywordflow}{if} (file == NULL)
00324         \textcolor{keywordflow}{return} -1;
00325     state = (gz\_statep)file;
00326     \textcolor{keywordflow}{if} (state->mode != GZ\_READ && state->mode != GZ\_WRITE)
00327         \textcolor{keywordflow}{return} -1;
00328 
00329     \textcolor{comment}{/* make sure we haven't already allocated memory */}
00330     \textcolor{keywordflow}{if} (state->size != 0)
00331         \textcolor{keywordflow}{return} -1;
00332 
00333     \textcolor{comment}{/* check and set requested size */}
00334     \textcolor{keywordflow}{if} ((size << 1) < size)
00335         \textcolor{keywordflow}{return} -1;              \textcolor{comment}{/* need to be able to double it */}
00336     \textcolor{keywordflow}{if} (size < 2)
00337         size = 2;               \textcolor{comment}{/* need two bytes to check magic header */}
00338     state->want = size;
00339     \textcolor{keywordflow}{return} 0;
00340 \}
00341 
00342 \textcolor{comment}{/* -- see zlib.h -- */}
00343 \textcolor{keywordtype}{int} ZEXPORT gzrewind(file)
00344     \hyperlink{structgz_file__s}{gzFile} file;
00345 \{
00346     gz\_statep state;
00347 
00348     \textcolor{comment}{/* get internal structure */}
00349     \textcolor{keywordflow}{if} (file == NULL)
00350         \textcolor{keywordflow}{return} -1;
00351     state = (gz\_statep)file;
00352 
00353     \textcolor{comment}{/* check that we're reading and that there's no error */}
00354     \textcolor{keywordflow}{if} (state->mode != GZ\_READ ||
00355             (state->err != Z\_OK && state->err != Z\_BUF\_ERROR))
00356         \textcolor{keywordflow}{return} -1;
00357 
00358     \textcolor{comment}{/* back up and start over */}
00359     \textcolor{keywordflow}{if} (LSEEK(state->fd, state->start, SEEK\_SET) == -1)
00360         \textcolor{keywordflow}{return} -1;
00361     gz\_reset(state);
00362     \textcolor{keywordflow}{return} 0;
00363 \}
00364 
00365 \textcolor{comment}{/* -- see zlib.h -- */}
00366 z\_off64\_t ZEXPORT gzseek64(file, offset, whence)
00367     \hyperlink{structgz_file__s}{gzFile} file;
00368     z\_off64\_t offset;
00369     \textcolor{keywordtype}{int} whence;
00370 \{
00371     \textcolor{keywordtype}{unsigned} n;
00372     z\_off64\_t ret;
00373     gz\_statep state;
00374 
00375     \textcolor{comment}{/* get internal structure and check integrity */}
00376     \textcolor{keywordflow}{if} (file == NULL)
00377         \textcolor{keywordflow}{return} -1;
00378     state = (gz\_statep)file;
00379     \textcolor{keywordflow}{if} (state->mode != GZ\_READ && state->mode != GZ\_WRITE)
00380         \textcolor{keywordflow}{return} -1;
00381 
00382     \textcolor{comment}{/* check that there's no error */}
00383     \textcolor{keywordflow}{if} (state->err != Z\_OK && state->err != Z\_BUF\_ERROR)
00384         \textcolor{keywordflow}{return} -1;
00385 
00386     \textcolor{comment}{/* can only seek from start or relative to current position */}
00387     \textcolor{keywordflow}{if} (whence != SEEK\_SET && whence != SEEK\_CUR)
00388         \textcolor{keywordflow}{return} -1;
00389 
00390     \textcolor{comment}{/* normalize offset to a SEEK\_CUR specification */}
00391     \textcolor{keywordflow}{if} (whence == SEEK\_SET)
00392         offset -= state->x.pos;
00393     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (state->seek)
00394         offset += state->skip;
00395     state->seek = 0;
00396 
00397     \textcolor{comment}{/* if within raw area while reading, just go there */}
00398     \textcolor{keywordflow}{if} (state->mode == GZ\_READ && state->how == COPY &&
00399             state->x.pos + offset >= 0) \{
00400         ret = LSEEK(state->fd, offset - state->x.have, SEEK\_CUR);
00401         \textcolor{keywordflow}{if} (ret == -1)
00402             \textcolor{keywordflow}{return} -1;
00403         state->x.have = 0;
00404         state->eof = 0;
00405         state->past = 0;
00406         state->seek = 0;
00407         gz\_error(state, Z\_OK, NULL);
00408         state->strm.avail\_in = 0;
00409         state->x.pos += offset;
00410         \textcolor{keywordflow}{return} state->x.pos;
00411     \}
00412 
00413     \textcolor{comment}{/* calculate skip amount, rewinding if needed for back seek when reading */}
00414     \textcolor{keywordflow}{if} (offset < 0) \{
00415         \textcolor{keywordflow}{if} (state->mode != GZ\_READ)         \textcolor{comment}{/* writing -- can't go backwards */}
00416             \textcolor{keywordflow}{return} -1;
00417         offset += state->x.pos;
00418         \textcolor{keywordflow}{if} (offset < 0)                     \textcolor{comment}{/* before start of file! */}
00419             \textcolor{keywordflow}{return} -1;
00420         \textcolor{keywordflow}{if} (gzrewind(file) == -1)           \textcolor{comment}{/* rewind, then skip to offset */}
00421             \textcolor{keywordflow}{return} -1;
00422     \}
00423 
00424     \textcolor{comment}{/* if reading, skip what's in output buffer (one less gzgetc() check) */}
00425     \textcolor{keywordflow}{if} (state->mode == GZ\_READ) \{
00426         n = GT\_OFF(state->x.have) || (z\_off64\_t)state->x.have > offset ?
00427             (\textcolor{keywordtype}{unsigned})offset : state->x.have;
00428         state->x.have -= n;
00429         state->x.next += n;
00430         state->x.pos += n;
00431         offset -= n;
00432     \}
00433 
00434     \textcolor{comment}{/* request skip (if not zero) */}
00435     \textcolor{keywordflow}{if} (offset) \{
00436         state->seek = 1;
00437         state->skip = offset;
00438     \}
00439     \textcolor{keywordflow}{return} state->x.pos + offset;
00440 \}
00441 
00442 \textcolor{comment}{/* -- see zlib.h -- */}
00443 z\_off\_t ZEXPORT gzseek(file, offset, whence)
00444     \hyperlink{structgz_file__s}{gzFile} file;
00445     z\_off\_t offset;
00446     \textcolor{keywordtype}{int} whence;
00447 \{
00448     z\_off64\_t ret;
00449 
00450     ret = gzseek64(file, (z\_off64\_t)offset, whence);
00451     \textcolor{keywordflow}{return} ret == (z\_off\_t)ret ? (z\_off\_t)ret : -1;
00452 \}
00453 
00454 \textcolor{comment}{/* -- see zlib.h -- */}
00455 z\_off64\_t ZEXPORT gztell64(file)
00456     \hyperlink{structgz_file__s}{gzFile} file;
00457 \{
00458     gz\_statep state;
00459 
00460     \textcolor{comment}{/* get internal structure and check integrity */}
00461     \textcolor{keywordflow}{if} (file == NULL)
00462         \textcolor{keywordflow}{return} -1;
00463     state = (gz\_statep)file;
00464     \textcolor{keywordflow}{if} (state->mode != GZ\_READ && state->mode != GZ\_WRITE)
00465         \textcolor{keywordflow}{return} -1;
00466 
00467     \textcolor{comment}{/* return position */}
00468     \textcolor{keywordflow}{return} state->x.pos + (state->seek ? state->skip : 0);
00469 \}
00470 
00471 \textcolor{comment}{/* -- see zlib.h -- */}
00472 z\_off\_t ZEXPORT gztell(file)
00473     \hyperlink{structgz_file__s}{gzFile} file;
00474 \{
00475     z\_off64\_t ret;
00476 
00477     ret = gztell64(file);
00478     \textcolor{keywordflow}{return} ret == (z\_off\_t)ret ? (z\_off\_t)ret : -1;
00479 \}
00480 
00481 \textcolor{comment}{/* -- see zlib.h -- */}
00482 z\_off64\_t ZEXPORT gzoffset64(file)
00483     \hyperlink{structgz_file__s}{gzFile} file;
00484 \{
00485     z\_off64\_t offset;
00486     gz\_statep state;
00487 
00488     \textcolor{comment}{/* get internal structure and check integrity */}
00489     \textcolor{keywordflow}{if} (file == NULL)
00490         \textcolor{keywordflow}{return} -1;
00491     state = (gz\_statep)file;
00492     \textcolor{keywordflow}{if} (state->mode != GZ\_READ && state->mode != GZ\_WRITE)
00493         \textcolor{keywordflow}{return} -1;
00494 
00495     \textcolor{comment}{/* compute and return effective offset in file */}
00496     offset = LSEEK(state->fd, 0, SEEK\_CUR);
00497     \textcolor{keywordflow}{if} (offset == -1)
00498         \textcolor{keywordflow}{return} -1;
00499     \textcolor{keywordflow}{if} (state->mode == GZ\_READ)             \textcolor{comment}{/* reading */}
00500         offset -= state->strm.avail\_in;     \textcolor{comment}{/* don't count buffered input */}
00501     \textcolor{keywordflow}{return} offset;
00502 \}
00503 
00504 \textcolor{comment}{/* -- see zlib.h -- */}
00505 z\_off\_t ZEXPORT gzoffset(file)
00506     \hyperlink{structgz_file__s}{gzFile} file;
00507 \{
00508     z\_off64\_t ret;
00509 
00510     ret = gzoffset64(file);
00511     \textcolor{keywordflow}{return} ret == (z\_off\_t)ret ? (z\_off\_t)ret : -1;
00512 \}
00513 
00514 \textcolor{comment}{/* -- see zlib.h -- */}
00515 \textcolor{keywordtype}{int} ZEXPORT gzeof(file)
00516     \hyperlink{structgz_file__s}{gzFile} file;
00517 \{
00518     gz\_statep state;
00519 
00520     \textcolor{comment}{/* get internal structure and check integrity */}
00521     \textcolor{keywordflow}{if} (file == NULL)
00522         \textcolor{keywordflow}{return} 0;
00523     state = (gz\_statep)file;
00524     \textcolor{keywordflow}{if} (state->mode != GZ\_READ && state->mode != GZ\_WRITE)
00525         \textcolor{keywordflow}{return} 0;
00526 
00527     \textcolor{comment}{/* return end-of-file state */}
00528     \textcolor{keywordflow}{return} state->mode == GZ\_READ ? state->past : 0;
00529 \}
00530 
00531 \textcolor{comment}{/* -- see zlib.h -- */}
00532 \textcolor{keyword}{const} \textcolor{keywordtype}{char} * ZEXPORT gzerror(file, errnum)
00533     \hyperlink{structgz_file__s}{gzFile} file;
00534     \textcolor{keywordtype}{int} *errnum;
00535 \{
00536     gz\_statep state;
00537 
00538     \textcolor{comment}{/* get internal structure and check integrity */}
00539     \textcolor{keywordflow}{if} (file == NULL)
00540         \textcolor{keywordflow}{return} NULL;
00541     state = (gz\_statep)file;
00542     \textcolor{keywordflow}{if} (state->mode != GZ\_READ && state->mode != GZ\_WRITE)
00543         \textcolor{keywordflow}{return} NULL;
00544 
00545     \textcolor{comment}{/* return error information */}
00546     \textcolor{keywordflow}{if} (errnum != NULL)
00547         *errnum = state->err;
00548     \textcolor{keywordflow}{return} state->err == Z\_MEM\_ERROR ? \textcolor{stringliteral}{"out of memory"} :
00549                                        (state->msg == NULL ? \textcolor{stringliteral}{""} : state->msg);
00550 \}
00551 
00552 \textcolor{comment}{/* -- see zlib.h -- */}
00553 \textcolor{keywordtype}{void} ZEXPORT gzclearerr(file)
00554     \hyperlink{structgz_file__s}{gzFile} file;
00555 \{
00556     gz\_statep state;
00557 
00558     \textcolor{comment}{/* get internal structure and check integrity */}
00559     \textcolor{keywordflow}{if} (file == NULL)
00560         \textcolor{keywordflow}{return};
00561     state = (gz\_statep)file;
00562     \textcolor{keywordflow}{if} (state->mode != GZ\_READ && state->mode != GZ\_WRITE)
00563         \textcolor{keywordflow}{return};
00564 
00565     \textcolor{comment}{/* clear error and end-of-file */}
00566     \textcolor{keywordflow}{if} (state->mode == GZ\_READ) \{
00567         state->eof = 0;
00568         state->past = 0;
00569     \}
00570     gz\_error(state, Z\_OK, NULL);
00571 \}
00572 
00573 \textcolor{comment}{/* Create an error message in allocated memory and set state->err and}
00574 \textcolor{comment}{   state->msg accordingly.  Free any previous error message already there.  Do}
00575 \textcolor{comment}{   not try to free or allocate space if the error is Z\_MEM\_ERROR (out of}
00576 \textcolor{comment}{   memory).  Simply save the error message as a static string.  If there is an}
00577 \textcolor{comment}{   allocation failure constructing the error message, then convert the error to}
00578 \textcolor{comment}{   out of memory. */}
00579 \textcolor{keywordtype}{void} ZLIB\_INTERNAL gz\_error(state, err, msg)
00580     gz\_statep state;
00581     \textcolor{keywordtype}{int} err;
00582     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg;
00583 \{
00584     \textcolor{comment}{/* free previously allocated message and clear */}
00585     \textcolor{keywordflow}{if} (state->msg != NULL) \{
00586         \textcolor{keywordflow}{if} (state->err != Z\_MEM\_ERROR)
00587             free(state->msg);
00588         state->msg = NULL;
00589     \}
00590 
00591     \textcolor{comment}{/* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */}
00592     \textcolor{keywordflow}{if} (err != Z\_OK && err != Z\_BUF\_ERROR)
00593         state->x.have = 0;
00594 
00595     \textcolor{comment}{/* set error code, and if no message, then done */}
00596     state->err = err;
00597     \textcolor{keywordflow}{if} (msg == NULL)
00598         \textcolor{keywordflow}{return};
00599 
00600     \textcolor{comment}{/* for an out of memory error, return literal string when requested */}
00601     \textcolor{keywordflow}{if} (err == Z\_MEM\_ERROR)
00602         \textcolor{keywordflow}{return};
00603 
00604     \textcolor{comment}{/* construct error message with path */}
00605     \textcolor{keywordflow}{if} ((state->msg = (\textcolor{keywordtype}{char} *)malloc(strlen(state->path) + strlen(msg) + 3)) ==
00606             NULL) \{
00607         state->err = Z\_MEM\_ERROR;
00608         \textcolor{keywordflow}{return};
00609     \}
00610 \textcolor{preprocessor}{#if !defined(NO\_snprintf) && !defined(NO\_vsnprintf)}
00611     (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
00612                    \textcolor{stringliteral}{"%s%s%s"}, state->path, \textcolor{stringliteral}{": "}, msg);
00613 \textcolor{preprocessor}{#else}
00614     strcpy(state->msg, state->path);
00615     strcat(state->msg, \textcolor{stringliteral}{": "});
00616     strcat(state->msg, msg);
00617 \textcolor{preprocessor}{#endif}
00618 \}
00619 
00620 \textcolor{preprocessor}{#ifndef INT\_MAX}
00621 \textcolor{comment}{/* portably return maximum value for an int (when limits.h presumed not}
00622 \textcolor{comment}{   available) -- we need to do this to cover cases where 2's complement not}
00623 \textcolor{comment}{   used, since C standard permits 1's complement and sign-bit representations,}
00624 \textcolor{comment}{   otherwise we could just use ((unsigned)-1) >> 1 */}
00625 \textcolor{keywordtype}{unsigned} ZLIB\_INTERNAL gz\_intmax()
00626 \{
00627     \textcolor{keywordtype}{unsigned} p, q;
00628 
00629     p = 1;
00630     \textcolor{keywordflow}{do} \{
00631         q = p;
00632         p <<= 1;
00633         p++;
00634     \} \textcolor{keywordflow}{while} (p > q);
00635     \textcolor{keywordflow}{return} q >> 1;
00636 \}
00637 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
