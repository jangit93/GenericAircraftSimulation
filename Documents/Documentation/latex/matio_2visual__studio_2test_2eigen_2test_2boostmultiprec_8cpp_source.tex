\hypertarget{matio_2visual__studio_2test_2eigen_2test_2boostmultiprec_8cpp_source}{}\section{matio/visual\+\_\+studio/test/eigen/test/boostmultiprec.cpp}
\label{matio_2visual__studio_2test_2eigen_2test_2boostmultiprec_8cpp_source}\index{boostmultiprec.\+cpp@{boostmultiprec.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2016 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#include <sstream>}
00011 
00012 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_MAX\_SIZE}
00013 \textcolor{preprocessor}{#undef EIGEN\_TEST\_MAX\_SIZE}
00014 \textcolor{preprocessor}{#endif}
00015 
00016 \textcolor{preprocessor}{#define EIGEN\_TEST\_MAX\_SIZE 50}
00017 
00018 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_1}
00019 \textcolor{preprocessor}{#include "cholesky.cpp"}
00020 \textcolor{preprocessor}{#endif}
00021 
00022 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_2}
00023 \textcolor{preprocessor}{#include "lu.cpp"}
00024 \textcolor{preprocessor}{#endif}
00025 
00026 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_3}
00027 \textcolor{preprocessor}{#include "qr.cpp"}
00028 \textcolor{preprocessor}{#endif}
00029 
00030 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_4}
00031 \textcolor{preprocessor}{#include "qr\_colpivoting.cpp"}
00032 \textcolor{preprocessor}{#endif}
00033 
00034 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_5}
00035 \textcolor{preprocessor}{#include "qr\_fullpivoting.cpp"}
00036 \textcolor{preprocessor}{#endif}
00037 
00038 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_6}
00039 \textcolor{preprocessor}{#include "eigensolver\_selfadjoint.cpp"}
00040 \textcolor{preprocessor}{#endif}
00041 
00042 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_7}
00043 \textcolor{preprocessor}{#include "eigensolver\_generic.cpp"}
00044 \textcolor{preprocessor}{#endif}
00045 
00046 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_8}
00047 \textcolor{preprocessor}{#include "eigensolver\_generalized\_real.cpp"}
00048 \textcolor{preprocessor}{#endif}
00049 
00050 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_9}
00051 \textcolor{preprocessor}{#include "jacobisvd.cpp"}
00052 \textcolor{preprocessor}{#endif}
00053 
00054 \textcolor{preprocessor}{#ifdef EIGEN\_TEST\_PART\_10}
00055 \textcolor{preprocessor}{#include "bdcsvd.cpp"}
00056 \textcolor{preprocessor}{#endif}
00057 
00058 \textcolor{preprocessor}{#include <Eigen/Dense>}
00059 
00060 \textcolor{preprocessor}{#undef min}
00061 \textcolor{preprocessor}{#undef max}
00062 \textcolor{preprocessor}{#undef isnan}
00063 \textcolor{preprocessor}{#undef isinf}
00064 \textcolor{preprocessor}{#undef isfinite}
00065 
00066 \textcolor{preprocessor}{#include <boost/multiprecision/cpp\_dec\_float.hpp>}
00067 \textcolor{preprocessor}{#include <boost/multiprecision/number.hpp>}
00068 \textcolor{preprocessor}{#include <boost/math/special\_functions.hpp>}
00069 \textcolor{preprocessor}{#include <boost/math/complex.hpp>}
00070 
00071 \textcolor{keyword}{namespace }\hyperlink{namespaceboost_1_1multiprecision}{mp} = \hyperlink{namespaceboost_1_1multiprecision}{boost::multiprecision};
00072 \textcolor{keyword}{typedef} mp::number<mp::cpp\_dec\_float<100>, mp::et\_on> Real;
00073 
00074 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00075   \textcolor{keyword}{template}<> \textcolor{keyword}{struct }NumTraits<Real> : GenericNumTraits<Real> \{
00076     \textcolor{keyword}{static} \textcolor{keyword}{inline} Real dummy\_precision() \{ \textcolor{keywordflow}{return} 1e-50; \}
00077   \};
00078 
00079   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1,\textcolor{keyword}{typename} T2,\textcolor{keyword}{typename} T3,\textcolor{keyword}{typename} T4,\textcolor{keyword}{typename} T5>
00080   \textcolor{keyword}{struct }NumTraits<\hyperlink{namespaceboost}{boost}::multiprecision::detail::expression<T1,T2,T3,T4,T5> > : NumTraits<Real> \{\};
00081 
00082   \textcolor{keyword}{template}<>
00083   Real test\_precision<Real>() \{ \textcolor{keywordflow}{return} 1e-50; \}
00084 
00085   \textcolor{comment}{// needed in C++93 mode where number does not support explicit cast.}
00086   \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00087     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NewType>
00088     \textcolor{keyword}{struct }cast\_impl<Real,NewType> \{
00089       \textcolor{keyword}{static} \textcolor{keyword}{inline} NewType run(\textcolor{keyword}{const} Real& x) \{
00090         \textcolor{keywordflow}{return} x.template convert\_to<NewType>();
00091       \}
00092     \};
00093 
00094     \textcolor{keyword}{template}<>
00095     \textcolor{keyword}{struct }cast\_impl<Real,\hyperlink{namespacestd}{std}::\hyperlink{structcomplex}{complex}<Real> > \{
00096       \textcolor{keyword}{static} \textcolor{keyword}{inline} std::complex<Real>  run(\textcolor{keyword}{const} Real& x) \{
00097         \textcolor{keywordflow}{return} std::complex<Real>(x);
00098       \}
00099     \};
00100   \}
00101 \}
00102 
00103 \textcolor{keyword}{namespace }\hyperlink{namespaceboost}{boost} \{
00104 \textcolor{keyword}{namespace }multiprecision \{
00105   \textcolor{comment}{// to make ADL works as expected:}
00106   \textcolor{keyword}{using} boost::math::isfinite;
00107   \textcolor{keyword}{using} boost::math::isnan;
00108   \textcolor{keyword}{using} boost::math::isinf;
00109   \textcolor{keyword}{using} boost::math::copysign;
00110   \textcolor{keyword}{using} boost::math::hypot;
00111 
00112   \textcolor{comment}{// The following is needed for std::complex<Real>:}
00113   Real fabs(\textcolor{keyword}{const} Real& a) \{ \textcolor{keywordflow}{return} abs EIGEN\_NOT\_A\_MACRO (a); \}
00114   Real fmax(\textcolor{keyword}{const} Real& a, \textcolor{keyword}{const} Real& b) \{ \textcolor{keyword}{using} std::max; \textcolor{keywordflow}{return} max(a,b); \}
00115 
00116   \textcolor{comment}{// some specialization for the unit tests:}
00117   \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isMuchSmallerThan(\textcolor{keyword}{const} Real& a, \textcolor{keyword}{const} Real& b) \{
00118     \textcolor{keywordflow}{return} internal::isMuchSmallerThan(a, b, test\_precision<Real>());
00119   \}
00120 
00121   \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApprox(\textcolor{keyword}{const} Real& a, \textcolor{keyword}{const} Real& b) \{
00122     \textcolor{keywordflow}{return} internal::isApprox(a, b, test\_precision<Real>());
00123   \}
00124 
00125   \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} test\_isApproxOrLessThan(\textcolor{keyword}{const} Real& a, \textcolor{keyword}{const} Real& b) \{
00126     \textcolor{keywordflow}{return} internal::isApproxOrLessThan(a, b, test\_precision<Real>());
00127   \}
00128 
00129   Real get\_test\_precision(\textcolor{keyword}{const} Real&) \{
00130     \textcolor{keywordflow}{return} test\_precision<Real>();
00131   \}
00132 
00133   Real test\_relative\_error(\textcolor{keyword}{const} Real &a, \textcolor{keyword}{const} Real &b) \{
00134     \textcolor{keyword}{using} Eigen::numext::abs2;
00135     \textcolor{keywordflow}{return} sqrt(abs2<Real>(a-b)/Eigen::numext::mini<Real>(abs2(a),abs2(b)));
00136   \}
00137 \}
00138 \}
00139 
00140 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00141 
00142 \}
00143 
00144 \textcolor{keywordtype}{void} test\_boostmultiprec()
00145 \{
00146   \textcolor{keyword}{typedef} Matrix<Real,Dynamic,Dynamic> \hyperlink{group___core___module}{Mat};
00147   \textcolor{keyword}{typedef} Matrix<std::complex<Real>,\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},Dynamic> MatC;
00148 
00149   std::cout << \textcolor{stringliteral}{"NumTraits<Real>::epsilon()         = "} << NumTraits<Real>::epsilon() << std::endl;
00150   std::cout << \textcolor{stringliteral}{"NumTraits<Real>::dummy\_precision() = "} << NumTraits<Real>::dummy\_precision() << std::endl;
00151   std::cout << \textcolor{stringliteral}{"NumTraits<Real>::lowest()          = "} << NumTraits<Real>::lowest() << std::endl;
00152   std::cout << \textcolor{stringliteral}{"NumTraits<Real>::highest()         = "} << NumTraits<Real>::highest() << std::endl;
00153   std::cout << \textcolor{stringliteral}{"NumTraits<Real>::digits10()        = "} << NumTraits<Real>::digits10() << std::endl;
00154 
00155   \textcolor{comment}{// chekc stream output}
00156   \{
00157     Mat A(10,10);
00158     A.setRandom();
00159     std::stringstream ss;
00160     ss << A;
00161   \}
00162   \{
00163     MatC A(10,10);
00164     A.setRandom();
00165     std::stringstream ss;
00166     ss << A;
00167   \}
00168 
00169   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < g\_repeat; i++) \{
00170     \textcolor{keywordtype}{int} s = internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE);
00171 
00172     CALL\_SUBTEST\_1( cholesky(Mat(s,s)) );
00173 
00174     CALL\_SUBTEST\_2( lu\_non\_invertible<Mat>() );
00175     CALL\_SUBTEST\_2( lu\_invertible<Mat>() );
00176     CALL\_SUBTEST\_2( lu\_non\_invertible<MatC>() );
00177     CALL\_SUBTEST\_2( lu\_invertible<MatC>() );
00178 
00179     CALL\_SUBTEST\_3( qr(Mat(internal::random<int>(1,EIGEN\_TEST\_MAX\_SIZE),internal::random<int>(1,
      EIGEN\_TEST\_MAX\_SIZE))) );
00180     CALL\_SUBTEST\_3( qr\_invertible<Mat>() );
00181 
00182     CALL\_SUBTEST\_4( qr<Mat>() );
00183     CALL\_SUBTEST\_4( cod<Mat>() );
00184     CALL\_SUBTEST\_4( qr\_invertible<Mat>() );
00185 
00186     CALL\_SUBTEST\_5( qr<Mat>() );
00187     CALL\_SUBTEST\_5( qr\_invertible<Mat>() );
00188 
00189     CALL\_SUBTEST\_6( selfadjointeigensolver(Mat(s,s)) );
00190 
00191     CALL\_SUBTEST\_7( eigensolver(Mat(s,s)) );
00192 
00193     CALL\_SUBTEST\_8( generalized\_eigensolver\_real(Mat(s,s)) );
00194 
00195     TEST\_SET\_BUT\_UNUSED\_VARIABLE(s)
00196   \}
00197 
00198   CALL\_SUBTEST\_9(( jacobisvd(Mat(internal::random<int>(EIGEN\_TEST\_MAX\_SIZE/4, EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(EIGEN\_TEST\_MAX\_SIZE/4, EIGEN\_TEST\_MAX\_SIZE/2))) ));
00199   CALL\_SUBTEST\_10(( bdcsvd(Mat(internal::random<int>(EIGEN\_TEST\_MAX\_SIZE/4, EIGEN\_TEST\_MAX\_SIZE), 
      internal::random<int>(EIGEN\_TEST\_MAX\_SIZE/4, EIGEN\_TEST\_MAX\_SIZE/2))) ));
00200 \}
00201 
\end{DoxyCode}
