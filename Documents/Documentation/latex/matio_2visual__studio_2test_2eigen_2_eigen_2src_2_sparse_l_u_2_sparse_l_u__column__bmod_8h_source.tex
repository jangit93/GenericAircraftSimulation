\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u__column__bmod_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+L\+U/\+Sparse\+L\+U\+\_\+column\+\_\+bmod.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_l_u_2_sparse_l_u__column__bmod_8h_source}\index{Sparse\+L\+U\+\_\+column\+\_\+bmod.\+h@{Sparse\+L\+U\+\_\+column\+\_\+bmod.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2012 Désiré Nuentsa-Wakam <desire.nuentsa\_wakam@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2012 Gael Guennebaud <gael.guennebaud@inria.fr>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{comment}{/* }
00012 \textcolor{comment}{ }
00013 \textcolor{comment}{ * NOTE: This file is the modified version of xcolumn\_bmod.c file in SuperLU }
00014 \textcolor{comment}{ }
00015 \textcolor{comment}{ * -- SuperLU routine (version 3.0) --}
00016 \textcolor{comment}{ * Univ. of California Berkeley, Xerox Palo Alto Research Center,}
00017 \textcolor{comment}{ * and Lawrence Berkeley National Lab.}
00018 \textcolor{comment}{ * October 15, 2003}
00019 \textcolor{comment}{ *}
00020 \textcolor{comment}{ * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.}
00021 \textcolor{comment}{ *}
00022 \textcolor{comment}{ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY}
00023 \textcolor{comment}{ * EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.}
00024 \textcolor{comment}{ *}
00025 \textcolor{comment}{ * Permission is hereby granted to use or copy this program for any}
00026 \textcolor{comment}{ * purpose, provided the above notices are retained on all copies.}
00027 \textcolor{comment}{ * Permission to modify the code and to distribute modified code is}
00028 \textcolor{comment}{ * granted, provided the above notices are retained, and a notice that}
00029 \textcolor{comment}{ * the code was modified is included with the above copyright notice.}
00030 \textcolor{comment}{ */}
00031 \textcolor{preprocessor}{#ifndef SPARSELU\_COLUMN\_BMOD\_H}
00032 \textcolor{preprocessor}{#define SPARSELU\_COLUMN\_BMOD\_H}
00033 
00034 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00035 
00036 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00052 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} StorageIndex>
00053 \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} \hyperlink{group___sparse_l_u___module_ae34275602cf12560edfcaf7cd5cbe932}{SparseLUImpl<Scalar,StorageIndex>::column\_bmod}(\textcolor{keyword}{
      const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} jcol, \textcolor{keyword}{const} \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} nseg, BlockScalarVector dense, ScalarVector& tempv,
00054                                                      BlockIndexVector segrep, BlockIndexVector repfnz, 
      \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} fpanelc, GlobalLU\_t& glu)
00055 \{
00056   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}  jsupno, k, ksub, krep, ksupno; 
00057   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lptr, nrow, isub, irow, nextlu, new\_next, ufirst; 
00058   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} fsupc, nsupc, nsupr, luptr, kfnz, no\_zeros; 
00059   \textcolor{comment}{/* krep = representative of current k-th supernode}
00060 \textcolor{comment}{    * fsupc =  first supernodal column}
00061 \textcolor{comment}{    * nsupc = number of columns in a supernode}
00062 \textcolor{comment}{    * nsupr = number of rows in a supernode}
00063 \textcolor{comment}{    * luptr = location of supernodal LU-block in storage}
00064 \textcolor{comment}{    * kfnz = first nonz in the k-th supernodal segment}
00065 \textcolor{comment}{    * no\_zeros = no lf leading zeros in a supernodal U-segment}
00066 \textcolor{comment}{    */}
00067   
00068   jsupno = glu.supno(jcol);
00069   \textcolor{comment}{// For each nonzero supernode segment of U[*,j] in topological order }
00070   k = nseg - 1; 
00071   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} d\_fsupc; \textcolor{comment}{// distance between the first column of the current panel and the }
00072                \textcolor{comment}{// first column of the current snode}
00073   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} fst\_col; \textcolor{comment}{// First column within small LU update}
00074   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} segsize; 
00075   \textcolor{keywordflow}{for} (ksub = 0; ksub < nseg; ksub++)
00076   \{
00077     krep = segrep(k); k--; 
00078     ksupno = glu.supno(krep); 
00079     \textcolor{keywordflow}{if} (jsupno != ksupno )
00080     \{
00081       \textcolor{comment}{// outside the rectangular supernode }
00082       fsupc = glu.xsup(ksupno); 
00083       fst\_col = (std::max)(fsupc, fpanelc); 
00084       
00085       \textcolor{comment}{// Distance from the current supernode to the current panel; }
00086       \textcolor{comment}{// d\_fsupc = 0 if fsupc > fpanelc}
00087       d\_fsupc = fst\_col - fsupc; 
00088       
00089       luptr = glu.xlusup(fst\_col) + d\_fsupc; 
00090       lptr = glu.xlsub(fsupc) + d\_fsupc; 
00091       
00092       kfnz = repfnz(krep); 
00093       kfnz = (std::max)(kfnz, fpanelc); 
00094       
00095       segsize = krep - kfnz + 1; 
00096       nsupc = krep - fst\_col + 1; 
00097       nsupr = glu.xlsub(fsupc+1) - glu.xlsub(fsupc); 
00098       nrow = nsupr - d\_fsupc - nsupc;
00099       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lda = glu.xlusup(fst\_col+1) - glu.xlusup(fst\_col);
00100       
00101       
00102       \textcolor{comment}{// Perform a triangular solver and block update, }
00103       \textcolor{comment}{// then scatter the result of sup-col update to dense}
00104       no\_zeros = kfnz - fst\_col; 
00105       \textcolor{keywordflow}{if}(segsize==1)
00106         LU\_kernel\_bmod<1>::run(segsize, dense, tempv, glu.lusup, luptr, lda, nrow, glu.lsub, lptr, no\_zeros
      );
00107       \textcolor{keywordflow}{else}
00108         LU\_kernel\_bmod<Dynamic>::run(segsize, dense, tempv, glu.lusup, luptr, lda, nrow, glu.lsub, lptr, 
      no\_zeros);
00109     \} \textcolor{comment}{// end if jsupno }
00110   \} \textcolor{comment}{// end for each segment}
00111   
00112   \textcolor{comment}{// Process the supernodal portion of  L\(\backslash\)U[*,j]}
00113   nextlu = glu.xlusup(jcol); 
00114   fsupc = glu.xsup(jsupno);
00115   
00116   \textcolor{comment}{// copy the SPA dense into L\(\backslash\)U[*,j]}
00117   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} mem; 
00118   new\_next = nextlu + glu.xlsub(fsupc + 1) - glu.xlsub(fsupc); 
00119   \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} offset = internal::first\_multiple<Index>(new\_next, internal::packet\_traits<Scalar>::size) - 
      new\_next;
00120   \textcolor{keywordflow}{if}(offset)
00121     new\_next += offset;
00122   \textcolor{keywordflow}{while} (new\_next > glu.nzlumax )
00123   \{
00124     mem = memXpand<ScalarVector>(glu.lusup, glu.nzlumax, nextlu, LUSUP, glu.num\_expansions);  
00125     \textcolor{keywordflow}{if} (mem) \textcolor{keywordflow}{return} mem; 
00126   \}
00127   
00128   \textcolor{keywordflow}{for} (isub = glu.xlsub(fsupc); isub < glu.xlsub(fsupc+1); isub++)
00129   \{
00130     irow = glu.lsub(isub);
00131     glu.lusup(nextlu) = dense(irow);
00132     dense(irow) = Scalar(0.0); 
00133     ++nextlu; 
00134   \}
00135   
00136   \textcolor{keywordflow}{if}(offset)
00137   \{
00138     glu.lusup.segment(nextlu,offset).setZero();
00139     nextlu += offset;
00140   \}
00141   glu.xlusup(jcol + 1) = StorageIndex(nextlu);  \textcolor{comment}{// close L\(\backslash\)U(*,jcol); }
00142   
00143   \textcolor{comment}{/* For more updates within the panel (also within the current supernode),}
00144 \textcolor{comment}{   * should start from the first column of the panel, or the first column}
00145 \textcolor{comment}{   * of the supernode, whichever is bigger. There are two cases:}
00146 \textcolor{comment}{   *  1) fsupc < fpanelc, then fst\_col <-- fpanelc}
00147 \textcolor{comment}{   *  2) fsupc >= fpanelc, then fst\_col <-- fsupc}
00148 \textcolor{comment}{   */}
00149   fst\_col = (std::max)(fsupc, fpanelc); 
00150   
00151   \textcolor{keywordflow}{if} (fst\_col  < jcol)
00152   \{
00153     \textcolor{comment}{// Distance between the current supernode and the current panel}
00154     \textcolor{comment}{// d\_fsupc = 0 if fsupc >= fpanelc}
00155     d\_fsupc = fst\_col - fsupc; 
00156     
00157     lptr = glu.xlsub(fsupc) + d\_fsupc; 
00158     luptr = glu.xlusup(fst\_col) + d\_fsupc; 
00159     nsupr = glu.xlsub(fsupc+1) - glu.xlsub(fsupc); \textcolor{comment}{// leading dimension}
00160     nsupc = jcol - fst\_col; \textcolor{comment}{// excluding jcol }
00161     nrow = nsupr - d\_fsupc - nsupc; 
00162     
00163     \textcolor{comment}{// points to the beginning of jcol in snode L\(\backslash\)U(jsupno) }
00164     ufirst = glu.xlusup(jcol) + d\_fsupc; 
00165     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} lda = glu.xlusup(jcol+1) - glu.xlusup(jcol);
00166     MappedMatrixBlock A( &(glu.lusup.data()[luptr]), nsupc, nsupc, OuterStride<>(lda) );
00167     VectorBlock<ScalarVector> u(glu.lusup, ufirst, nsupc); 
00168     u = A.template triangularView<UnitLower>().solve(u); 
00169     
00170     \textcolor{keyword}{new} (&A) MappedMatrixBlock ( &(glu.lusup.data()[luptr+nsupc]), nrow, nsupc, OuterStride<>(lda) );
00171     VectorBlock<ScalarVector> l(glu.lusup, ufirst+nsupc, nrow); 
00172     l.noalias() -= A * u;
00173     
00174   \} \textcolor{comment}{// End if fst\_col}
00175   \textcolor{keywordflow}{return} 0; 
00176 \}
00177 
00178 \} \textcolor{comment}{// end namespace internal}
00179 \} \textcolor{comment}{// end namespace Eigen}
00180 
00181 \textcolor{preprocessor}{#endif // SPARSELU\_COLUMN\_BMOD\_H}
\end{DoxyCode}
