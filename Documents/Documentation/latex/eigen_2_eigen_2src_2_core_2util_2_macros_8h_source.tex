\hypertarget{eigen_2_eigen_2src_2_core_2util_2_macros_8h_source}{}\section{eigen/\+Eigen/src/\+Core/util/\+Macros.h}
\label{eigen_2_eigen_2src_2_core_2util_2_macros_8h_source}\index{Macros.\+h@{Macros.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2015 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>}
00006 \textcolor{comment}{//}
00007 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00008 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00009 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00010 
00011 \textcolor{preprocessor}{#ifndef EIGEN\_MACROS\_H}
00012 \textcolor{preprocessor}{#define EIGEN\_MACROS\_H}
00013 
00014 \textcolor{preprocessor}{#define EIGEN\_WORLD\_VERSION 3}
00015 \textcolor{preprocessor}{#define EIGEN\_MAJOR\_VERSION 3}
00016 \textcolor{preprocessor}{#define EIGEN\_MINOR\_VERSION 4}
00017 
00018 \textcolor{preprocessor}{#define EIGEN\_VERSION\_AT\_LEAST(x,y,z) (EIGEN\_WORLD\_VERSION>x || (EIGEN\_WORLD\_VERSION>=x && \(\backslash\)}
00019 \textcolor{preprocessor}{                                      (EIGEN\_MAJOR\_VERSION>y || (EIGEN\_MAJOR\_VERSION>=y && \(\backslash\)}
00020 \textcolor{preprocessor}{                                                                 EIGEN\_MINOR\_VERSION>=z))))}
00021 
00022 \textcolor{comment}{// Compiler identification, EIGEN\_COMP\_*}
00023 
00025 \textcolor{preprocessor}{#ifdef \_\_GNUC\_\_}
00026 \textcolor{preprocessor}{  #define EIGEN\_COMP\_GNUC 1}
00027 \textcolor{preprocessor}{#else}
00028 \textcolor{preprocessor}{  #define EIGEN\_COMP\_GNUC 0}
00029 \textcolor{preprocessor}{#endif}
00030 
00032 \textcolor{preprocessor}{#if defined(\_\_clang\_\_)}
00033 \textcolor{preprocessor}{  #define EIGEN\_COMP\_CLANG (\_\_clang\_major\_\_*100+\_\_clang\_minor\_\_)}
00034 \textcolor{preprocessor}{#else}
00035 \textcolor{preprocessor}{  #define EIGEN\_COMP\_CLANG 0}
00036 \textcolor{preprocessor}{#endif}
00037 
00038 
00040 \textcolor{preprocessor}{#if defined(\_\_llvm\_\_)}
00041 \textcolor{preprocessor}{  #define EIGEN\_COMP\_LLVM 1}
00042 \textcolor{preprocessor}{#else}
00043 \textcolor{preprocessor}{  #define EIGEN\_COMP\_LLVM 0}
00044 \textcolor{preprocessor}{#endif}
00045 
00047 \textcolor{preprocessor}{#if defined(\_\_INTEL\_COMPILER)}
00048 \textcolor{preprocessor}{  #define EIGEN\_COMP\_ICC \_\_INTEL\_COMPILER}
00049 \textcolor{preprocessor}{#else}
00050 \textcolor{preprocessor}{  #define EIGEN\_COMP\_ICC 0}
00051 \textcolor{preprocessor}{#endif}
00052 
00054 \textcolor{preprocessor}{#if defined(\_\_MINGW32\_\_)}
00055 \textcolor{preprocessor}{  #define EIGEN\_COMP\_MINGW 1}
00056 \textcolor{preprocessor}{#else}
00057 \textcolor{preprocessor}{  #define EIGEN\_COMP\_MINGW 0}
00058 \textcolor{preprocessor}{#endif}
00059 
00061 \textcolor{preprocessor}{#if defined(\_\_SUNPRO\_CC)}
00062 \textcolor{preprocessor}{  #define EIGEN\_COMP\_SUNCC 1}
00063 \textcolor{preprocessor}{#else}
00064 \textcolor{preprocessor}{  #define EIGEN\_COMP\_SUNCC 0}
00065 \textcolor{preprocessor}{#endif}
00066 
00068 \textcolor{preprocessor}{#if defined(\_MSC\_VER)}
00069 \textcolor{preprocessor}{  #define EIGEN\_COMP\_MSVC \_MSC\_VER}
00070 \textcolor{preprocessor}{#else}
00071 \textcolor{preprocessor}{  #define EIGEN\_COMP\_MSVC 0}
00072 \textcolor{preprocessor}{#endif}
00073 
00074 \textcolor{comment}{// For the record, here is a table summarizing the possible values for EIGEN\_COMP\_MSVC:}
00075 \textcolor{comment}{//  name  ver   MSC\_VER}
00076 \textcolor{comment}{//  2008    9      1500}
00077 \textcolor{comment}{//  2010   10      1600}
00078 \textcolor{comment}{//  2012   11      1700}
00079 \textcolor{comment}{//  2013   12      1800}
00080 \textcolor{comment}{//  2015   14      1900}
00081 \textcolor{comment}{//  "15"   15      1900}
00082 
00084 \textcolor{preprocessor}{#if EIGEN\_COMP\_MSVC && !(EIGEN\_COMP\_ICC || EIGEN\_COMP\_LLVM || EIGEN\_COMP\_CLANG)}
00085 \textcolor{preprocessor}{  #define EIGEN\_COMP\_MSVC\_STRICT \_MSC\_VER}
00086 \textcolor{preprocessor}{#else}
00087 \textcolor{preprocessor}{  #define EIGEN\_COMP\_MSVC\_STRICT 0}
00088 \textcolor{preprocessor}{#endif}
00089 
00091 \textcolor{preprocessor}{#if defined(\_\_IBMCPP\_\_) || defined(\_\_xlc\_\_)}
00092 \textcolor{preprocessor}{  #define EIGEN\_COMP\_IBM 1}
00093 \textcolor{preprocessor}{#else}
00094 \textcolor{preprocessor}{  #define EIGEN\_COMP\_IBM 0}
00095 \textcolor{preprocessor}{#endif}
00096 
00098 \textcolor{preprocessor}{#if defined(\_\_PGI)}
00099 \textcolor{preprocessor}{  #define EIGEN\_COMP\_PGI 1}
00100 \textcolor{preprocessor}{#else}
00101 \textcolor{preprocessor}{  #define EIGEN\_COMP\_PGI 0}
00102 \textcolor{preprocessor}{#endif}
00103 
00105 \textcolor{preprocessor}{#if defined(\_\_CC\_ARM) || defined(\_\_ARMCC\_VERSION)}
00106 \textcolor{preprocessor}{  #define EIGEN\_COMP\_ARM 1}
00107 \textcolor{preprocessor}{#else}
00108 \textcolor{preprocessor}{  #define EIGEN\_COMP\_ARM 0}
00109 \textcolor{preprocessor}{#endif}
00110 
00112 \textcolor{preprocessor}{#if defined(\_\_EMSCRIPTEN\_\_)}
00113 \textcolor{preprocessor}{  #define EIGEN\_COMP\_EMSCRIPTEN 1}
00114 \textcolor{preprocessor}{#else}
00115 \textcolor{preprocessor}{  #define EIGEN\_COMP\_EMSCRIPTEN 0}
00116 \textcolor{preprocessor}{#endif}
00117 
00118 
00120 \textcolor{preprocessor}{#if EIGEN\_COMP\_GNUC && !(EIGEN\_COMP\_CLANG || EIGEN\_COMP\_ICC || EIGEN\_COMP\_MINGW || EIGEN\_COMP\_PGI ||
       EIGEN\_COMP\_IBM || EIGEN\_COMP\_ARM || EIGEN\_COMP\_EMSCRIPTEN)}
00121 \textcolor{preprocessor}{  #define EIGEN\_COMP\_GNUC\_STRICT 1}
00122 \textcolor{preprocessor}{#else}
00123 \textcolor{preprocessor}{  #define EIGEN\_COMP\_GNUC\_STRICT 0}
00124 \textcolor{preprocessor}{#endif}
00125 
00126 
00127 \textcolor{preprocessor}{#if EIGEN\_COMP\_GNUC}
00128 \textcolor{preprocessor}{  #define EIGEN\_GNUC\_AT\_LEAST(x,y) ((\_\_GNUC\_\_==x && \_\_GNUC\_MINOR\_\_>=y) || \_\_GNUC\_\_>x)}
00129 \textcolor{preprocessor}{  #define EIGEN\_GNUC\_AT\_MOST(x,y)  ((\_\_GNUC\_\_==x && \_\_GNUC\_MINOR\_\_<=y) || \_\_GNUC\_\_<x)}
00130 \textcolor{preprocessor}{  #define EIGEN\_GNUC\_AT(x,y)       ( \_\_GNUC\_\_==x && \_\_GNUC\_MINOR\_\_==y )}
00131 \textcolor{preprocessor}{#else}
00132 \textcolor{preprocessor}{  #define EIGEN\_GNUC\_AT\_LEAST(x,y) 0}
00133 \textcolor{preprocessor}{  #define EIGEN\_GNUC\_AT\_MOST(x,y)  0}
00134 \textcolor{preprocessor}{  #define EIGEN\_GNUC\_AT(x,y)       0}
00135 \textcolor{preprocessor}{#endif}
00136 
00137 \textcolor{comment}{// FIXME: could probably be removed as we do not support gcc 3.x anymore}
00138 \textcolor{preprocessor}{#if EIGEN\_COMP\_GNUC && (\_\_GNUC\_\_ <= 3)}
00139 \textcolor{preprocessor}{#define EIGEN\_GCC3\_OR\_OLDER 1}
00140 \textcolor{preprocessor}{#else}
00141 \textcolor{preprocessor}{#define EIGEN\_GCC3\_OR\_OLDER 0}
00142 \textcolor{preprocessor}{#endif}
00143 
00144 
00145 \textcolor{comment}{// Architecture identification, EIGEN\_ARCH\_*}
00146 
00147 \textcolor{preprocessor}{#if defined(\_\_x86\_64\_\_) || defined(\_M\_X64) || defined(\_\_amd64)}
00148 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_x86\_64 1}
00149 \textcolor{preprocessor}{#else}
00150 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_x86\_64 0}
00151 \textcolor{preprocessor}{#endif}
00152 
00153 \textcolor{preprocessor}{#if defined(\_\_i386\_\_) || defined(\_M\_IX86) || defined(\_X86\_) || defined(\_\_i386)}
00154 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_i386 1}
00155 \textcolor{preprocessor}{#else}
00156 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_i386 0}
00157 \textcolor{preprocessor}{#endif}
00158 
00159 \textcolor{preprocessor}{#if EIGEN\_ARCH\_x86\_64 || EIGEN\_ARCH\_i386}
00160 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_i386\_OR\_x86\_64 1}
00161 \textcolor{preprocessor}{#else}
00162 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_i386\_OR\_x86\_64 0}
00163 \textcolor{preprocessor}{#endif}
00164 
00166 \textcolor{preprocessor}{#if defined(\_\_arm\_\_)}
00167 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_ARM 1}
00168 \textcolor{preprocessor}{#else}
00169 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_ARM 0}
00170 \textcolor{preprocessor}{#endif}
00171 
00173 \textcolor{preprocessor}{#if defined(\_\_aarch64\_\_)}
00174 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_ARM64 1}
00175 \textcolor{preprocessor}{#else}
00176 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_ARM64 0}
00177 \textcolor{preprocessor}{#endif}
00178 
00179 \textcolor{preprocessor}{#if EIGEN\_ARCH\_ARM || EIGEN\_ARCH\_ARM64}
00180 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_ARM\_OR\_ARM64 1}
00181 \textcolor{preprocessor}{#else}
00182 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_ARM\_OR\_ARM64 0}
00183 \textcolor{preprocessor}{#endif}
00184 
00186 \textcolor{preprocessor}{#if defined(\_\_mips\_\_) || defined(\_\_mips)}
00187 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_MIPS 1}
00188 \textcolor{preprocessor}{#else}
00189 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_MIPS 0}
00190 \textcolor{preprocessor}{#endif}
00191 
00193 \textcolor{preprocessor}{#if defined(\_\_sparc\_\_) || defined(\_\_sparc)}
00194 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_SPARC 1}
00195 \textcolor{preprocessor}{#else}
00196 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_SPARC 0}
00197 \textcolor{preprocessor}{#endif}
00198 
00200 \textcolor{preprocessor}{#if defined(\_\_ia64\_\_)}
00201 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_IA64 1}
00202 \textcolor{preprocessor}{#else}
00203 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_IA64 0}
00204 \textcolor{preprocessor}{#endif}
00205 
00207 \textcolor{preprocessor}{#if defined(\_\_powerpc\_\_) || defined(\_\_ppc\_\_) || defined(\_M\_PPC)}
00208 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_PPC 1}
00209 \textcolor{preprocessor}{#else}
00210 \textcolor{preprocessor}{  #define EIGEN\_ARCH\_PPC 0}
00211 \textcolor{preprocessor}{#endif}
00212 
00213 
00214 
00215 \textcolor{comment}{// Operating system identification, EIGEN\_OS\_*}
00216 
00218 \textcolor{preprocessor}{#if defined(\_\_unix\_\_) || defined(\_\_unix)}
00219 \textcolor{preprocessor}{  #define EIGEN\_OS\_UNIX 1}
00220 \textcolor{preprocessor}{#else}
00221 \textcolor{preprocessor}{  #define EIGEN\_OS\_UNIX 0}
00222 \textcolor{preprocessor}{#endif}
00223 
00225 \textcolor{preprocessor}{#if defined(\_\_linux\_\_)}
00226 \textcolor{preprocessor}{  #define EIGEN\_OS\_LINUX 1}
00227 \textcolor{preprocessor}{#else}
00228 \textcolor{preprocessor}{  #define EIGEN\_OS\_LINUX 0}
00229 \textcolor{preprocessor}{#endif}
00230 
00232 \textcolor{comment}{// note: ANDROID is defined when using ndk\_build, \_\_ANDROID\_\_ is defined when using a standalone toolchain.}
00233 \textcolor{preprocessor}{#if defined(\_\_ANDROID\_\_) || defined(ANDROID)}
00234 \textcolor{preprocessor}{  #define EIGEN\_OS\_ANDROID 1}
00235 \textcolor{preprocessor}{#else}
00236 \textcolor{preprocessor}{  #define EIGEN\_OS\_ANDROID 0}
00237 \textcolor{preprocessor}{#endif}
00238 
00240 \textcolor{preprocessor}{#if defined(\_\_gnu\_linux\_\_) && !(EIGEN\_OS\_ANDROID)}
00241 \textcolor{preprocessor}{  #define EIGEN\_OS\_GNULINUX 1}
00242 \textcolor{preprocessor}{#else}
00243 \textcolor{preprocessor}{  #define EIGEN\_OS\_GNULINUX 0}
00244 \textcolor{preprocessor}{#endif}
00245 
00247 \textcolor{preprocessor}{#if defined(\_\_FreeBSD\_\_) || defined(\_\_NetBSD\_\_) || defined(\_\_OpenBSD\_\_) || defined(\_\_bsdi\_\_) ||
       defined(\_\_DragonFly\_\_)}
00248 \textcolor{preprocessor}{  #define EIGEN\_OS\_BSD 1}
00249 \textcolor{preprocessor}{#else}
00250 \textcolor{preprocessor}{  #define EIGEN\_OS\_BSD 0}
00251 \textcolor{preprocessor}{#endif}
00252 
00254 \textcolor{preprocessor}{#if defined(\_\_APPLE\_\_)}
00255 \textcolor{preprocessor}{  #define EIGEN\_OS\_MAC 1}
00256 \textcolor{preprocessor}{#else}
00257 \textcolor{preprocessor}{  #define EIGEN\_OS\_MAC 0}
00258 \textcolor{preprocessor}{#endif}
00259 
00261 \textcolor{preprocessor}{#if defined(\_\_QNX\_\_)}
00262 \textcolor{preprocessor}{  #define EIGEN\_OS\_QNX 1}
00263 \textcolor{preprocessor}{#else}
00264 \textcolor{preprocessor}{  #define EIGEN\_OS\_QNX 0}
00265 \textcolor{preprocessor}{#endif}
00266 
00268 \textcolor{preprocessor}{#if defined(\_WIN32)}
00269 \textcolor{preprocessor}{  #define EIGEN\_OS\_WIN 1}
00270 \textcolor{preprocessor}{#else}
00271 \textcolor{preprocessor}{  #define EIGEN\_OS\_WIN 0}
00272 \textcolor{preprocessor}{#endif}
00273 
00275 \textcolor{preprocessor}{#if defined(\_WIN64)}
00276 \textcolor{preprocessor}{  #define EIGEN\_OS\_WIN64 1}
00277 \textcolor{preprocessor}{#else}
00278 \textcolor{preprocessor}{  #define EIGEN\_OS\_WIN64 0}
00279 \textcolor{preprocessor}{#endif}
00280 
00282 \textcolor{preprocessor}{#if defined(\_WIN32\_WCE)}
00283 \textcolor{preprocessor}{  #define EIGEN\_OS\_WINCE 1}
00284 \textcolor{preprocessor}{#else}
00285 \textcolor{preprocessor}{  #define EIGEN\_OS\_WINCE 0}
00286 \textcolor{preprocessor}{#endif}
00287 
00289 \textcolor{preprocessor}{#if defined(\_\_CYGWIN\_\_)}
00290 \textcolor{preprocessor}{  #define EIGEN\_OS\_CYGWIN 1}
00291 \textcolor{preprocessor}{#else}
00292 \textcolor{preprocessor}{  #define EIGEN\_OS\_CYGWIN 0}
00293 \textcolor{preprocessor}{#endif}
00294 
00296 \textcolor{preprocessor}{#if EIGEN\_OS\_WIN && !( EIGEN\_OS\_WINCE || EIGEN\_OS\_CYGWIN )}
00297 \textcolor{preprocessor}{  #define EIGEN\_OS\_WIN\_STRICT 1}
00298 \textcolor{preprocessor}{#else}
00299 \textcolor{preprocessor}{  #define EIGEN\_OS\_WIN\_STRICT 0}
00300 \textcolor{preprocessor}{#endif}
00301 
00303 \textcolor{preprocessor}{#if (defined(sun) || defined(\_\_sun)) && !(defined(\_\_SVR4) || defined(\_\_svr4\_\_))}
00304 \textcolor{preprocessor}{  #define EIGEN\_OS\_SUN 1}
00305 \textcolor{preprocessor}{#else}
00306 \textcolor{preprocessor}{  #define EIGEN\_OS\_SUN 0}
00307 \textcolor{preprocessor}{#endif}
00308 
00310 \textcolor{preprocessor}{#if (defined(sun) || defined(\_\_sun)) && (defined(\_\_SVR4) || defined(\_\_svr4\_\_))}
00311 \textcolor{preprocessor}{  #define EIGEN\_OS\_SOLARIS 1}
00312 \textcolor{preprocessor}{#else}
00313 \textcolor{preprocessor}{  #define EIGEN\_OS\_SOLARIS 0}
00314 \textcolor{preprocessor}{#endif}
00315 
00316 
00317 
00318 \textcolor{preprocessor}{#if EIGEN\_GNUC\_AT\_MOST(4,3) && !EIGEN\_COMP\_CLANG}
00319   \textcolor{comment}{// see bug 89}
00320 \textcolor{preprocessor}{  #define EIGEN\_SAFE\_TO\_USE\_STANDARD\_ASSERT\_MACRO 0}
00321 \textcolor{preprocessor}{#else}
00322 \textcolor{preprocessor}{  #define EIGEN\_SAFE\_TO\_USE\_STANDARD\_ASSERT\_MACRO 1}
00323 \textcolor{preprocessor}{#endif}
00324 
00325 \textcolor{comment}{// This macro can be used to prevent from macro expansion, e.g.:}
00326 \textcolor{comment}{//   std::max EIGEN\_NOT\_A\_MACRO(a,b)}
00327 \textcolor{preprocessor}{#define EIGEN\_NOT\_A\_MACRO}
00328 
00329 \textcolor{preprocessor}{#ifdef EIGEN\_DEFAULT\_TO\_ROW\_MAJOR}
00330 \textcolor{preprocessor}{#define EIGEN\_DEFAULT\_MATRIX\_STORAGE\_ORDER\_OPTION Eigen::RowMajor}
00331 \textcolor{preprocessor}{#else}
00332 \textcolor{preprocessor}{#define EIGEN\_DEFAULT\_MATRIX\_STORAGE\_ORDER\_OPTION Eigen::ColMajor}
00333 \textcolor{preprocessor}{#endif}
00334 
00335 \textcolor{preprocessor}{#ifndef EIGEN\_DEFAULT\_DENSE\_INDEX\_TYPE}
00336 \textcolor{preprocessor}{#define EIGEN\_DEFAULT\_DENSE\_INDEX\_TYPE std::ptrdiff\_t}
00337 \textcolor{preprocessor}{#endif}
00338 
00339 \textcolor{comment}{// Cross compiler wrapper around LLVM's \_\_has\_builtin}
00340 \textcolor{preprocessor}{#ifdef \_\_has\_builtin}
00341 \textcolor{preprocessor}{#  define EIGEN\_HAS\_BUILTIN(x) \_\_has\_builtin(x)}
00342 \textcolor{preprocessor}{#else}
00343 \textcolor{preprocessor}{#  define EIGEN\_HAS\_BUILTIN(x) 0}
00344 \textcolor{preprocessor}{#endif}
00345 
00346 \textcolor{comment}{// A Clang feature extension to determine compiler features.}
00347 \textcolor{comment}{// We use it to determine 'cxx\_rvalue\_references'}
00348 \textcolor{preprocessor}{#ifndef \_\_has\_feature}
00349 \textcolor{preprocessor}{# define \_\_has\_feature(x) 0}
00350 \textcolor{preprocessor}{#endif}
00351 
00352 \textcolor{comment}{// Upperbound on the C++ version to use.}
00353 \textcolor{comment}{// Expected values are 03, 11, 14, 17, etc.}
00354 \textcolor{comment}{// By default, let's use an arbitrarily large C++ version.}
00355 \textcolor{preprocessor}{#ifndef EIGEN\_MAX\_CPP\_VER}
00356 \textcolor{preprocessor}{#define EIGEN\_MAX\_CPP\_VER 99}
00357 \textcolor{preprocessor}{#endif}
00358 
00359 \textcolor{preprocessor}{#if EIGEN\_MAX\_CPP\_VER>=11 && (defined(\_\_cplusplus) && (\_\_cplusplus >= 201103L) || EIGEN\_COMP\_MSVC >= 1900)}
00360 \textcolor{preprocessor}{#define EIGEN\_HAS\_CXX11 1}
00361 \textcolor{preprocessor}{#else}
00362 \textcolor{preprocessor}{#define EIGEN\_HAS\_CXX11 0}
00363 \textcolor{preprocessor}{#endif}
00364 
00365 
00366 \textcolor{comment}{// Do we support r-value references?}
00367 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_RVALUE\_REFERENCES}
00368 \textcolor{preprocessor}{#if EIGEN\_MAX\_CPP\_VER>=11 && \(\backslash\)}
00369 \textcolor{preprocessor}{    (\_\_has\_feature(cxx\_rvalue\_references) || \(\backslash\)}
00370 \textcolor{preprocessor}{    (defined(\_\_cplusplus) && \_\_cplusplus >= 201103L) || \(\backslash\)}
00371 \textcolor{preprocessor}{    (EIGEN\_COMP\_MSVC >= 1600))}
00372 \textcolor{preprocessor}{  #define EIGEN\_HAS\_RVALUE\_REFERENCES 1}
00373 \textcolor{preprocessor}{#else}
00374 \textcolor{preprocessor}{  #define EIGEN\_HAS\_RVALUE\_REFERENCES 0}
00375 \textcolor{preprocessor}{#endif}
00376 \textcolor{preprocessor}{#endif}
00377 
00378 \textcolor{comment}{// Does the compiler support C99?}
00379 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_C99\_MATH}
00380 \textcolor{preprocessor}{#if EIGEN\_MAX\_CPP\_VER>=11 && \(\backslash\)}
00381 \textcolor{preprocessor}{    ((defined(\_\_STDC\_VERSION\_\_) && (\_\_STDC\_VERSION\_\_ >= 199901))       \(\backslash\)}
00382 \textcolor{preprocessor}{  || (defined(\_\_GNUC\_\_) && defined(\_GLIBCXX\_USE\_C99)) \(\backslash\)}
00383 \textcolor{preprocessor}{  || (defined(\_LIBCPP\_VERSION) && !defined(\_MSC\_VER)))}
00384 \textcolor{preprocessor}{  #define EIGEN\_HAS\_C99\_MATH 1}
00385 \textcolor{preprocessor}{#else}
00386 \textcolor{preprocessor}{  #define EIGEN\_HAS\_C99\_MATH 0}
00387 \textcolor{preprocessor}{#endif}
00388 \textcolor{preprocessor}{#endif}
00389 
00390 \textcolor{comment}{// Does the compiler support result\_of?}
00391 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_STD\_RESULT\_OF}
00392 \textcolor{preprocessor}{#if EIGEN\_MAX\_CPP\_VER>=11 && ((\_\_has\_feature(cxx\_lambdas) || (defined(\_\_cplusplus) && \_\_cplusplus >=
       201103L)))}
00393 \textcolor{preprocessor}{#define EIGEN\_HAS\_STD\_RESULT\_OF 1}
00394 \textcolor{preprocessor}{#else}
00395 \textcolor{preprocessor}{#define EIGEN\_HAS\_STD\_RESULT\_OF 0}
00396 \textcolor{preprocessor}{#endif}
00397 \textcolor{preprocessor}{#endif}
00398 
00399 \textcolor{comment}{// Does the compiler support variadic templates?}
00400 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_VARIADIC\_TEMPLATES}
00401 \textcolor{preprocessor}{#if EIGEN\_MAX\_CPP\_VER>=11 && (\_\_cplusplus > 199711L || EIGEN\_COMP\_MSVC >= 1900) \(\backslash\)}
00402 \textcolor{preprocessor}{  && ( !defined(\_\_NVCC\_\_) || !EIGEN\_ARCH\_ARM\_OR\_ARM64 || (defined \_\_CUDACC\_VER\_\_ && \_\_CUDACC\_VER\_\_ >=
       80000) )}
00403     \textcolor{comment}{// ^^ Disable the use of variadic templates when compiling with versions of nvcc older than 8.0 on ARM
       devices:}
00404     \textcolor{comment}{//    this prevents nvcc from crashing when compiling Eigen on Tegra X1}
00405 \textcolor{preprocessor}{#define EIGEN\_HAS\_VARIADIC\_TEMPLATES 1}
00406 \textcolor{preprocessor}{#else}
00407 \textcolor{preprocessor}{#define EIGEN\_HAS\_VARIADIC\_TEMPLATES 0}
00408 \textcolor{preprocessor}{#endif}
00409 \textcolor{preprocessor}{#endif}
00410 
00411 \textcolor{comment}{// Does the compiler fully support const expressions? (as in c++14)}
00412 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_CONSTEXPR}
00413 
00414 \textcolor{preprocessor}{#ifdef \_\_CUDACC\_\_}
00415 \textcolor{comment}{// Const expressions are supported provided that c++11 is enabled and we're using either clang or nvcc 7.5
       or above}
00416 \textcolor{preprocessor}{#if EIGEN\_MAX\_CPP\_VER>=14 && (\_\_cplusplus > 199711L && defined(\_\_CUDACC\_VER\_\_) && (EIGEN\_COMP\_CLANG ||
       \_\_CUDACC\_VER\_\_ >= 70500))}
00417 \textcolor{preprocessor}{  #define EIGEN\_HAS\_CONSTEXPR 1}
00418 \textcolor{preprocessor}{#endif}
00419 \textcolor{preprocessor}{#elif EIGEN\_MAX\_CPP\_VER>=14 && (\_\_has\_feature(cxx\_relaxed\_constexpr) || (defined(\_\_cplusplus) &&
       \_\_cplusplus >= 201402L) || \(\backslash\)}
00420 \textcolor{preprocessor}{  (EIGEN\_GNUC\_AT\_LEAST(4,8) && (\_\_cplusplus > 199711L)))}
00421 \textcolor{preprocessor}{#define EIGEN\_HAS\_CONSTEXPR 1}
00422 \textcolor{preprocessor}{#endif}
00423 
00424 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_CONSTEXPR}
00425 \textcolor{preprocessor}{#define EIGEN\_HAS\_CONSTEXPR 0}
00426 \textcolor{preprocessor}{#endif}
00427 
00428 \textcolor{preprocessor}{#endif}
00429 
00430 \textcolor{comment}{// Does the compiler support C++11 math?}
00431 \textcolor{comment}{// Let's be conservative and enable the default C++11 implementation only if we are sure it exists}
00432 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_CXX11\_MATH}
00433 \textcolor{preprocessor}{  #if EIGEN\_MAX\_CPP\_VER>=11 && ((\_\_cplusplus > 201103L) || (\_\_cplusplus >= 201103L) &&
       (EIGEN\_COMP\_GNUC\_STRICT || EIGEN\_COMP\_CLANG || EIGEN\_COMP\_MSVC || EIGEN\_COMP\_ICC)  \(\backslash\)}
00434 \textcolor{preprocessor}{      && (EIGEN\_ARCH\_i386\_OR\_x86\_64) && (EIGEN\_OS\_GNULINUX || EIGEN\_OS\_WIN\_STRICT || EIGEN\_OS\_MAC))}
00435 \textcolor{preprocessor}{    #define EIGEN\_HAS\_CXX11\_MATH 1}
00436 \textcolor{preprocessor}{  #else}
00437 \textcolor{preprocessor}{    #define EIGEN\_HAS\_CXX11\_MATH 0}
00438 \textcolor{preprocessor}{  #endif}
00439 \textcolor{preprocessor}{#endif}
00440 
00441 \textcolor{comment}{// Does the compiler support proper C++11 containers?}
00442 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_CXX11\_CONTAINERS}
00443 \textcolor{preprocessor}{  #if    EIGEN\_MAX\_CPP\_VER>=11 && \(\backslash\)}
00444 \textcolor{preprocessor}{         ((\_\_cplusplus > 201103L) \(\backslash\)}
00445 \textcolor{preprocessor}{      || ((\_\_cplusplus >= 201103L) && (EIGEN\_COMP\_GNUC\_STRICT || EIGEN\_COMP\_CLANG || EIGEN\_COMP\_ICC>=1400))
       \(\backslash\)}
00446 \textcolor{preprocessor}{      || EIGEN\_COMP\_MSVC >= 1900)}
00447 \textcolor{preprocessor}{    #define EIGEN\_HAS\_CXX11\_CONTAINERS 1}
00448 \textcolor{preprocessor}{  #else}
00449 \textcolor{preprocessor}{    #define EIGEN\_HAS\_CXX11\_CONTAINERS 0}
00450 \textcolor{preprocessor}{  #endif}
00451 \textcolor{preprocessor}{#endif}
00452 
00453 \textcolor{comment}{// Does the compiler support C++11 noexcept?}
00454 \textcolor{preprocessor}{#ifndef EIGEN\_HAS\_CXX11\_NOEXCEPT}
00455 \textcolor{preprocessor}{  #if    EIGEN\_MAX\_CPP\_VER>=11 && \(\backslash\)}
00456 \textcolor{preprocessor}{         (\_\_has\_feature(cxx\_noexcept) \(\backslash\)}
00457 \textcolor{preprocessor}{      || (\_\_cplusplus > 201103L) \(\backslash\)}
00458 \textcolor{preprocessor}{      || ((\_\_cplusplus >= 201103L) && (EIGEN\_COMP\_GNUC\_STRICT || EIGEN\_COMP\_CLANG || EIGEN\_COMP\_ICC>=1400))
       \(\backslash\)}
00459 \textcolor{preprocessor}{      || EIGEN\_COMP\_MSVC >= 1900)}
00460 \textcolor{preprocessor}{    #define EIGEN\_HAS\_CXX11\_NOEXCEPT 1}
00461 \textcolor{preprocessor}{  #else}
00462 \textcolor{preprocessor}{    #define EIGEN\_HAS\_CXX11\_NOEXCEPT 0}
00463 \textcolor{preprocessor}{  #endif}
00464 \textcolor{preprocessor}{#endif}
00465 
00471 \textcolor{preprocessor}{#ifndef EIGEN\_FAST\_MATH}
00472 \textcolor{preprocessor}{#define EIGEN\_FAST\_MATH 1}
00473 \textcolor{preprocessor}{#endif}
00474 
00475 \textcolor{preprocessor}{#define EIGEN\_DEBUG\_VAR(x) std::cerr << #x << " = " << x << std::endl;}
00476 
00477 \textcolor{comment}{// concatenate two tokens}
00478 \textcolor{preprocessor}{#define EIGEN\_CAT2(a,b) a ## b}
00479 \textcolor{preprocessor}{#define EIGEN\_CAT(a,b) EIGEN\_CAT2(a,b)}
00480 
00481 \textcolor{preprocessor}{#define EIGEN\_COMMA ,}
00482 
00483 \textcolor{comment}{// convert a token to a string}
00484 \textcolor{preprocessor}{#define EIGEN\_MAKESTRING2(a) #a}
00485 \textcolor{preprocessor}{#define EIGEN\_MAKESTRING(a) EIGEN\_MAKESTRING2(a)}
00486 
00487 \textcolor{comment}{// EIGEN\_STRONG\_INLINE is a stronger version of the inline, using \_\_forceinline on MSVC,}
00488 \textcolor{comment}{// but it still doesn't use GCC's always\_inline. This is useful in (common) situations where MSVC needs
       forceinline}
00489 \textcolor{comment}{// but GCC is still doing fine with just inline.}
00490 \textcolor{preprocessor}{#if EIGEN\_COMP\_MSVC || EIGEN\_COMP\_ICC}
00491 \textcolor{preprocessor}{#define EIGEN\_STRONG\_INLINE \_\_forceinline}
00492 \textcolor{preprocessor}{#else}
00493 \textcolor{preprocessor}{#define EIGEN\_STRONG\_INLINE inline}
00494 \textcolor{preprocessor}{#endif}
00495 
00496 \textcolor{comment}{// EIGEN\_ALWAYS\_INLINE is the stronget, it has the effect of making the function inline and adding every
       possible}
00497 \textcolor{comment}{// attribute to maximize inlining. This should only be used when really necessary: in particular,}
00498 \textcolor{comment}{// it uses \_\_attribute\_\_((always\_inline)) on GCC, which most of the time is useless and can severely harm
       compile times.}
00499 \textcolor{comment}{// FIXME with the always\_inline attribute,}
00500 \textcolor{comment}{// gcc 3.4.x and 4.1 reports the following compilation error:}
00501 \textcolor{comment}{//   Eval.h:91: sorry, unimplemented: inlining failed in call to 'const Eigen::Eval<Derived>
       Eigen::MatrixBase<Scalar, Derived>::eval() const'}
00502 \textcolor{comment}{//    : function body not available}
00503 \textcolor{comment}{//   See also bug 1367}
00504 \textcolor{preprocessor}{#if EIGEN\_GNUC\_AT\_LEAST(4,2)}
00505 \textcolor{preprocessor}{#define EIGEN\_ALWAYS\_INLINE \_\_attribute\_\_((always\_inline)) inline}
00506 \textcolor{preprocessor}{#else}
00507 \textcolor{preprocessor}{#define EIGEN\_ALWAYS\_INLINE EIGEN\_STRONG\_INLINE}
00508 \textcolor{preprocessor}{#endif}
00509 
00510 \textcolor{preprocessor}{#if EIGEN\_COMP\_GNUC}
00511 \textcolor{preprocessor}{#define EIGEN\_DONT\_INLINE \_\_attribute\_\_((noinline))}
00512 \textcolor{preprocessor}{#elif EIGEN\_COMP\_MSVC}
00513 \textcolor{preprocessor}{#define EIGEN\_DONT\_INLINE \_\_declspec(noinline)}
00514 \textcolor{preprocessor}{#else}
00515 \textcolor{preprocessor}{#define EIGEN\_DONT\_INLINE}
00516 \textcolor{preprocessor}{#endif}
00517 
00518 \textcolor{preprocessor}{#if EIGEN\_COMP\_GNUC}
00519 \textcolor{preprocessor}{#define EIGEN\_PERMISSIVE\_EXPR \_\_extension\_\_}
00520 \textcolor{preprocessor}{#else}
00521 \textcolor{preprocessor}{#define EIGEN\_PERMISSIVE\_EXPR}
00522 \textcolor{preprocessor}{#endif}
00523 
00524 \textcolor{comment}{// this macro allows to get rid of linking errors about multiply defined functions.}
00525 \textcolor{comment}{//  - static is not very good because it prevents definitions from different object files to be merged.}
00526 \textcolor{comment}{//           So static causes the resulting linked executable to be bloated with multiple copies of the
       same function.}
00527 \textcolor{comment}{//  - inline is not perfect either as it unwantedly hints the compiler toward inlining the function.}
00528 \textcolor{preprocessor}{#define EIGEN\_DECLARE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS}
00529 \textcolor{preprocessor}{#define EIGEN\_DEFINE\_FUNCTION\_ALLOWING\_MULTIPLE\_DEFINITIONS inline}
00530 
00531 \textcolor{preprocessor}{#ifdef NDEBUG}
00532 \textcolor{preprocessor}{# ifndef EIGEN\_NO\_DEBUG}
00533 \textcolor{preprocessor}{#  define EIGEN\_NO\_DEBUG}
00534 \textcolor{preprocessor}{# endif}
00535 \textcolor{preprocessor}{#endif}
00536 
00537 \textcolor{comment}{// eigen\_plain\_assert is where we implement the workaround for the assert() bug in GCC <= 4.3, see bug 89}
00538 \textcolor{preprocessor}{#ifdef EIGEN\_NO\_DEBUG}
00539 \textcolor{preprocessor}{  #define eigen\_plain\_assert(x)}
00540 \textcolor{preprocessor}{#else}
00541 \textcolor{preprocessor}{  #if EIGEN\_SAFE\_TO\_USE\_STANDARD\_ASSERT\_MACRO}
00542     \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00543     \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00544     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} copy\_bool(\textcolor{keywordtype}{bool} b) \{ \textcolor{keywordflow}{return} b; \}
00545     \}
00546     \}
00547 \textcolor{preprocessor}{    #define eigen\_plain\_assert(x) assert(x)}
00548 \textcolor{preprocessor}{  #else}
00549     \textcolor{comment}{// work around bug 89}
00550 \textcolor{preprocessor}{    #include <cstdlib>}   \textcolor{comment}{// for abort}
00551 \textcolor{preprocessor}{    #include <iostream>}  \textcolor{comment}{// for std::cerr}
00552 
00553     \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00554     \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00555     \textcolor{comment}{// trivial function copying a bool. Must be EIGEN\_DONT\_INLINE, so we implement it after including Eigen
       headers.}
00556     \textcolor{comment}{// see bug 89.}
00557     \textcolor{keyword}{namespace }\{
00558     EIGEN\_DONT\_INLINE \textcolor{keywordtype}{bool} copy\_bool(\textcolor{keywordtype}{bool} b) \{ \textcolor{keywordflow}{return} b; \}
00559     \}
00560     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} assert\_fail(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *condition, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\textcolor{keyword}{function}, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *
      \hyperlink{structfile}{file}, \textcolor{keywordtype}{int} line)
00561     \{
00562       std::cerr << \textcolor{stringliteral}{"assertion failed: "} << condition << \textcolor{stringliteral}{" in function "} << \textcolor{keyword}{function} << \textcolor{stringliteral}{" at "} << file << \textcolor{stringliteral}{":
      "} << line << std::endl;
00563       abort();
00564     \}
00565     \}
00566     \}
00567 \textcolor{preprocessor}{    #define eigen\_plain\_assert(x) \(\backslash\)}
00568 \textcolor{preprocessor}{      do \{ \(\backslash\)}
00569 \textcolor{preprocessor}{        if(!Eigen::internal::copy\_bool(x)) \(\backslash\)}
00570 \textcolor{preprocessor}{          Eigen::internal::assert\_fail(EIGEN\_MAKESTRING(x), \_\_PRETTY\_FUNCTION\_\_, \_\_FILE\_\_, \_\_LINE\_\_); \(\backslash\)}
00571 \textcolor{preprocessor}{      \} while(false)}
00572 \textcolor{preprocessor}{  #endif}
00573 \textcolor{preprocessor}{#endif}
00574 
00575 \textcolor{comment}{// eigen\_assert can be overridden}
00576 \textcolor{preprocessor}{#ifndef eigen\_assert}
00577 \textcolor{preprocessor}{#define eigen\_assert(x) eigen\_plain\_assert(x)}
00578 \textcolor{preprocessor}{#endif}
00579 
00580 \textcolor{preprocessor}{#ifdef EIGEN\_INTERNAL\_DEBUGGING}
00581 \textcolor{preprocessor}{#define eigen\_internal\_assert(x) eigen\_assert(x)}
00582 \textcolor{preprocessor}{#else}
00583 \textcolor{preprocessor}{#define eigen\_internal\_assert(x)}
00584 \textcolor{preprocessor}{#endif}
00585 
00586 \textcolor{preprocessor}{#ifdef EIGEN\_NO\_DEBUG}
00587 \textcolor{preprocessor}{#define EIGEN\_ONLY\_USED\_FOR\_DEBUG(x) EIGEN\_UNUSED\_VARIABLE(x)}
00588 \textcolor{preprocessor}{#else}
00589 \textcolor{preprocessor}{#define EIGEN\_ONLY\_USED\_FOR\_DEBUG(x)}
00590 \textcolor{preprocessor}{#endif}
00591 
00592 \textcolor{preprocessor}{#ifndef EIGEN\_NO\_DEPRECATED\_WARNING}
00593 \textcolor{preprocessor}{  #if EIGEN\_COMP\_GNUC}
00594 \textcolor{preprocessor}{    #define EIGEN\_DEPRECATED \_\_attribute\_\_((deprecated))}
00595 \textcolor{preprocessor}{  #elif EIGEN\_COMP\_MSVC}
00596 \textcolor{preprocessor}{    #define EIGEN\_DEPRECATED \_\_declspec(deprecated)}
00597 \textcolor{preprocessor}{  #else}
00598 \textcolor{preprocessor}{    #define EIGEN\_DEPRECATED}
00599 \textcolor{preprocessor}{  #endif}
00600 \textcolor{preprocessor}{#else}
00601 \textcolor{preprocessor}{  #define EIGEN\_DEPRECATED}
00602 \textcolor{preprocessor}{#endif}
00603 
00604 \textcolor{preprocessor}{#if EIGEN\_COMP\_GNUC}
00605 \textcolor{preprocessor}{#define EIGEN\_UNUSED \_\_attribute\_\_((unused))}
00606 \textcolor{preprocessor}{#else}
00607 \textcolor{preprocessor}{#define EIGEN\_UNUSED}
00608 \textcolor{preprocessor}{#endif}
00609 
00610 \textcolor{comment}{// Suppresses 'unused variable' warnings.}
00611 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00612   \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00613     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{void} ignore\_unused\_variable(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}&) \{\}
00614   \}
00615 \}
00616 \textcolor{preprocessor}{#define EIGEN\_UNUSED\_VARIABLE(var) Eigen::internal::ignore\_unused\_variable(var);}
00617 
00618 \textcolor{preprocessor}{#if !defined(EIGEN\_ASM\_COMMENT)}
00619 \textcolor{preprocessor}{  #if EIGEN\_COMP\_GNUC && (EIGEN\_ARCH\_i386\_OR\_x86\_64 || EIGEN\_ARCH\_ARM\_OR\_ARM64)}
00620 \textcolor{preprocessor}{    #define EIGEN\_ASM\_COMMENT(X)  \_\_asm\_\_("#" X)}
00621 \textcolor{preprocessor}{  #else}
00622 \textcolor{preprocessor}{    #define EIGEN\_ASM\_COMMENT(X)}
00623 \textcolor{preprocessor}{  #endif}
00624 \textcolor{preprocessor}{#endif}
00625 
00626 
00627 \textcolor{comment}{//------------------------------------------------------------------------------------------}
00628 \textcolor{comment}{// Static and dynamic alignment control}
00629 \textcolor{comment}{//}
00630 \textcolor{comment}{// The main purpose of this section is to define EIGEN\_MAX\_ALIGN\_BYTES and EIGEN\_MAX\_STATIC\_ALIGN\_BYTES}
00631 \textcolor{comment}{// as the maximal boundary in bytes on which dynamically and statically allocated data may be alignment
       respectively.}
00632 \textcolor{comment}{// The values of EIGEN\_MAX\_ALIGN\_BYTES and EIGEN\_MAX\_STATIC\_ALIGN\_BYTES can be specified by the user. If
       not,}
00633 \textcolor{comment}{// a default value is automatically computed based on architecture, compiler, and OS.}
00634 \textcolor{comment}{//}
00635 \textcolor{comment}{// This section also defines macros EIGEN\_ALIGN\_TO\_BOUNDARY(N) and the shortcuts EIGEN\_ALIGN\{8,16,32,\_MAX\}}
00636 \textcolor{comment}{// to be used to declare statically aligned buffers.}
00637 \textcolor{comment}{//------------------------------------------------------------------------------------------}
00638 
00639 
00640 \textcolor{comment}{/* EIGEN\_ALIGN\_TO\_BOUNDARY(n) forces data to be n-byte aligned. This is used to satisfy SIMD requirements.}
00641 \textcolor{comment}{ * However, we do that EVEN if vectorization (EIGEN\_VECTORIZE) is disabled,}
00642 \textcolor{comment}{ * so that vectorization doesn't affect binary compatibility.}
00643 \textcolor{comment}{ *}
00644 \textcolor{comment}{ * If we made alignment depend on whether or not EIGEN\_VECTORIZE is defined, it would be impossible to link}
00645 \textcolor{comment}{ * vectorized and non-vectorized code.}
00646 \textcolor{comment}{ */}
00647 \textcolor{preprocessor}{#if (defined \_\_CUDACC\_\_)}
00648 \textcolor{preprocessor}{  #define EIGEN\_ALIGN\_TO\_BOUNDARY(n) \_\_align\_\_(n)}
00649 \textcolor{preprocessor}{#elif EIGEN\_COMP\_GNUC || EIGEN\_COMP\_PGI || EIGEN\_COMP\_IBM || EIGEN\_COMP\_ARM}
00650 \textcolor{preprocessor}{  #define EIGEN\_ALIGN\_TO\_BOUNDARY(n) \_\_attribute\_\_((aligned(n)))}
00651 \textcolor{preprocessor}{#elif EIGEN\_COMP\_MSVC}
00652 \textcolor{preprocessor}{  #define EIGEN\_ALIGN\_TO\_BOUNDARY(n) \_\_declspec(align(n))}
00653 \textcolor{preprocessor}{#elif EIGEN\_COMP\_SUNCC}
00654   \textcolor{comment}{// FIXME not sure about this one:}
00655 \textcolor{preprocessor}{  #define EIGEN\_ALIGN\_TO\_BOUNDARY(n) \_\_attribute\_\_((aligned(n)))}
00656 \textcolor{preprocessor}{#else}
00657 \textcolor{preprocessor}{  #error Please tell me what is the equivalent of \_\_attribute\_\_((aligned(n))) for your compiler}
00658 \textcolor{preprocessor}{#endif}
00659 
00660 \textcolor{comment}{// If the user explicitly disable vectorization, then we also disable alignment}
00661 \textcolor{preprocessor}{#if defined(EIGEN\_DONT\_VECTORIZE)}
00662 \textcolor{preprocessor}{  #define EIGEN\_IDEAL\_MAX\_ALIGN\_BYTES 0}
00663 \textcolor{preprocessor}{#elif defined(EIGEN\_VECTORIZE\_AVX512)}
00664   \textcolor{comment}{// 64 bytes static alignmeent is preferred only if really required}
00665 \textcolor{preprocessor}{  #define EIGEN\_IDEAL\_MAX\_ALIGN\_BYTES 64}
00666 \textcolor{preprocessor}{#elif defined(\_\_AVX\_\_)}
00667   \textcolor{comment}{// 32 bytes static alignmeent is preferred only if really required}
00668 \textcolor{preprocessor}{  #define EIGEN\_IDEAL\_MAX\_ALIGN\_BYTES 32}
00669 \textcolor{preprocessor}{#else}
00670 \textcolor{preprocessor}{  #define EIGEN\_IDEAL\_MAX\_ALIGN\_BYTES 16}
00671 \textcolor{preprocessor}{#endif}
00672 
00673 
00674 \textcolor{comment}{// EIGEN\_MIN\_ALIGN\_BYTES defines the minimal value for which the notion of explicit alignment makes sense}
00675 \textcolor{preprocessor}{#define EIGEN\_MIN\_ALIGN\_BYTES 16}
00676 
00677 \textcolor{comment}{// Defined the boundary (in bytes) on which the data needs to be aligned. Note}
00678 \textcolor{comment}{// that unless EIGEN\_ALIGN is defined and not equal to 0, the data may not be}
00679 \textcolor{comment}{// aligned at all regardless of the value of this #define.}
00680 
00681 \textcolor{preprocessor}{#if (defined(EIGEN\_DONT\_ALIGN\_STATICALLY) || defined(EIGEN\_DONT\_ALIGN))  &&
       defined(EIGEN\_MAX\_STATIC\_ALIGN\_BYTES) && EIGEN\_MAX\_STATIC\_ALIGN\_BYTES>0}
00682 \textcolor{preprocessor}{#error EIGEN\_MAX\_STATIC\_ALIGN\_BYTES and EIGEN\_DONT\_ALIGN[\_STATICALLY] are both defined with
       EIGEN\_MAX\_STATIC\_ALIGN\_BYTES!=0. Use EIGEN\_MAX\_STATIC\_ALIGN\_BYTES=0 as a synonym of EIGEN\_DONT\_ALIGN\_STATICALLY.}
00683 \textcolor{preprocessor}{#endif}
00684 
00685 \textcolor{comment}{// EIGEN\_DONT\_ALIGN\_STATICALLY and EIGEN\_DONT\_ALIGN are deprectated}
00686 \textcolor{comment}{// They imply EIGEN\_MAX\_STATIC\_ALIGN\_BYTES=0}
00687 \textcolor{preprocessor}{#if defined(EIGEN\_DONT\_ALIGN\_STATICALLY) || defined(EIGEN\_DONT\_ALIGN)}
00688 \textcolor{preprocessor}{  #ifdef EIGEN\_MAX\_STATIC\_ALIGN\_BYTES}
00689 \textcolor{preprocessor}{    #undef EIGEN\_MAX\_STATIC\_ALIGN\_BYTES}
00690 \textcolor{preprocessor}{  #endif}
00691 \textcolor{preprocessor}{  #define EIGEN\_MAX\_STATIC\_ALIGN\_BYTES 0}
00692 \textcolor{preprocessor}{#endif}
00693 
00694 \textcolor{preprocessor}{#ifndef EIGEN\_MAX\_STATIC\_ALIGN\_BYTES}
00695 
00696   \textcolor{comment}{// Try to automatically guess what is the best default value for EIGEN\_MAX\_STATIC\_ALIGN\_BYTES}
00697 
00698   \textcolor{comment}{// 16 byte alignment is only useful for vectorization. Since it affects the ABI, we need to enable}
00699   \textcolor{comment}{// 16 byte alignment on all platforms where vectorization might be enabled. In theory we could always}
00700   \textcolor{comment}{// enable alignment, but it can be a cause of problems on some platforms, so we just disable it in}
00701   \textcolor{comment}{// certain common platform (compiler+architecture combinations) to avoid these problems.}
00702   \textcolor{comment}{// Only static alignment is really problematic (relies on nonstandard compiler extensions),}
00703   \textcolor{comment}{// try to keep heap alignment even when we have to disable static alignment.}
00704 \textcolor{preprocessor}{  #if EIGEN\_COMP\_GNUC && !(EIGEN\_ARCH\_i386\_OR\_x86\_64 || EIGEN\_ARCH\_ARM\_OR\_ARM64 || EIGEN\_ARCH\_PPC ||
       EIGEN\_ARCH\_IA64)}
00705 \textcolor{preprocessor}{  #define EIGEN\_GCC\_AND\_ARCH\_DOESNT\_WANT\_STACK\_ALIGNMENT 1}
00706 \textcolor{preprocessor}{  #elif EIGEN\_ARCH\_ARM\_OR\_ARM64 && EIGEN\_COMP\_GNUC\_STRICT && EIGEN\_GNUC\_AT\_MOST(4, 6)}
00707   \textcolor{comment}{// Old versions of GCC on ARM, at least 4.4, were once seen to have buggy static alignment support.}
00708   \textcolor{comment}{// Not sure which version fixed it, hopefully it doesn't affect 4.7, which is still somewhat in use.}
00709   \textcolor{comment}{// 4.8 and newer seem definitely unaffected.}
00710 \textcolor{preprocessor}{  #define EIGEN\_GCC\_AND\_ARCH\_DOESNT\_WANT\_STACK\_ALIGNMENT 1}
00711 \textcolor{preprocessor}{  #else}
00712 \textcolor{preprocessor}{  #define EIGEN\_GCC\_AND\_ARCH\_DOESNT\_WANT\_STACK\_ALIGNMENT 0}
00713 \textcolor{preprocessor}{  #endif}
00714 
00715   \textcolor{comment}{// static alignment is completely disabled with GCC 3, Sun Studio, and QCC/QNX}
00716 \textcolor{preprocessor}{  #if !EIGEN\_GCC\_AND\_ARCH\_DOESNT\_WANT\_STACK\_ALIGNMENT \(\backslash\)}
00717 \textcolor{preprocessor}{  && !EIGEN\_GCC3\_OR\_OLDER \(\backslash\)}
00718 \textcolor{preprocessor}{  && !EIGEN\_COMP\_SUNCC \(\backslash\)}
00719 \textcolor{preprocessor}{  && !EIGEN\_OS\_QNX}
00720 \textcolor{preprocessor}{    #define EIGEN\_ARCH\_WANTS\_STACK\_ALIGNMENT 1}
00721 \textcolor{preprocessor}{  #else}
00722 \textcolor{preprocessor}{    #define EIGEN\_ARCH\_WANTS\_STACK\_ALIGNMENT 0}
00723 \textcolor{preprocessor}{  #endif}
00724 
00725 \textcolor{preprocessor}{  #if EIGEN\_ARCH\_WANTS\_STACK\_ALIGNMENT}
00726 \textcolor{preprocessor}{    #define EIGEN\_MAX\_STATIC\_ALIGN\_BYTES EIGEN\_IDEAL\_MAX\_ALIGN\_BYTES}
00727 \textcolor{preprocessor}{  #else}
00728 \textcolor{preprocessor}{    #define EIGEN\_MAX\_STATIC\_ALIGN\_BYTES 0}
00729 \textcolor{preprocessor}{  #endif}
00730 
00731 \textcolor{preprocessor}{#endif}
00732 
00733 \textcolor{comment}{// If EIGEN\_MAX\_ALIGN\_BYTES is defined, then it is considered as an upper bound for EIGEN\_MAX\_ALIGN\_BYTES}
00734 \textcolor{preprocessor}{#if defined(EIGEN\_MAX\_ALIGN\_BYTES) && EIGEN\_MAX\_ALIGN\_BYTES<EIGEN\_MAX\_STATIC\_ALIGN\_BYTES}
00735 \textcolor{preprocessor}{#undef EIGEN\_MAX\_STATIC\_ALIGN\_BYTES}
00736 \textcolor{preprocessor}{#define EIGEN\_MAX\_STATIC\_ALIGN\_BYTES EIGEN\_MAX\_ALIGN\_BYTES}
00737 \textcolor{preprocessor}{#endif}
00738 
00739 \textcolor{preprocessor}{#if EIGEN\_MAX\_STATIC\_ALIGN\_BYTES==0 && !defined(EIGEN\_DISABLE\_UNALIGNED\_ARRAY\_ASSERT)}
00740 \textcolor{preprocessor}{  #define EIGEN\_DISABLE\_UNALIGNED\_ARRAY\_ASSERT}
00741 \textcolor{preprocessor}{#endif}
00742 
00743 \textcolor{comment}{// At this stage, EIGEN\_MAX\_STATIC\_ALIGN\_BYTES>0 is the true test whether we want to align arrays on the
       stack or not.}
00744 \textcolor{comment}{// It takes into account both the user choice to explicitly enable/disable alignment (by settting
       EIGEN\_MAX\_STATIC\_ALIGN\_BYTES)}
00745 \textcolor{comment}{// and the architecture config (EIGEN\_ARCH\_WANTS\_STACK\_ALIGNMENT).}
00746 \textcolor{comment}{// Henceforth, only EIGEN\_MAX\_STATIC\_ALIGN\_BYTES should be used.}
00747 
00748 
00749 \textcolor{comment}{// Shortcuts to EIGEN\_ALIGN\_TO\_BOUNDARY}
00750 \textcolor{preprocessor}{#define EIGEN\_ALIGN8  EIGEN\_ALIGN\_TO\_BOUNDARY(8)}
00751 \textcolor{preprocessor}{#define EIGEN\_ALIGN16 EIGEN\_ALIGN\_TO\_BOUNDARY(16)}
00752 \textcolor{preprocessor}{#define EIGEN\_ALIGN32 EIGEN\_ALIGN\_TO\_BOUNDARY(32)}
00753 \textcolor{preprocessor}{#define EIGEN\_ALIGN64 EIGEN\_ALIGN\_TO\_BOUNDARY(64)}
00754 \textcolor{preprocessor}{#if EIGEN\_MAX\_STATIC\_ALIGN\_BYTES>0}
00755 \textcolor{preprocessor}{#define EIGEN\_ALIGN\_MAX EIGEN\_ALIGN\_TO\_BOUNDARY(EIGEN\_MAX\_STATIC\_ALIGN\_BYTES)}
00756 \textcolor{preprocessor}{#else}
00757 \textcolor{preprocessor}{#define EIGEN\_ALIGN\_MAX}
00758 \textcolor{preprocessor}{#endif}
00759 
00760 
00761 \textcolor{comment}{// Dynamic alignment control}
00762 
00763 \textcolor{preprocessor}{#if defined(EIGEN\_DONT\_ALIGN) && defined(EIGEN\_MAX\_ALIGN\_BYTES) && EIGEN\_MAX\_ALIGN\_BYTES>0}
00764 \textcolor{preprocessor}{#error EIGEN\_MAX\_ALIGN\_BYTES and EIGEN\_DONT\_ALIGN are both defined with EIGEN\_MAX\_ALIGN\_BYTES!=0. Use
       EIGEN\_MAX\_ALIGN\_BYTES=0 as a synonym of EIGEN\_DONT\_ALIGN.}
00765 \textcolor{preprocessor}{#endif}
00766 
00767 \textcolor{preprocessor}{#ifdef EIGEN\_DONT\_ALIGN}
00768 \textcolor{preprocessor}{  #ifdef EIGEN\_MAX\_ALIGN\_BYTES}
00769 \textcolor{preprocessor}{    #undef EIGEN\_MAX\_ALIGN\_BYTES}
00770 \textcolor{preprocessor}{  #endif}
00771 \textcolor{preprocessor}{  #define EIGEN\_MAX\_ALIGN\_BYTES 0}
00772 \textcolor{preprocessor}{#elif !defined(EIGEN\_MAX\_ALIGN\_BYTES)}
00773 \textcolor{preprocessor}{  #define EIGEN\_MAX\_ALIGN\_BYTES EIGEN\_IDEAL\_MAX\_ALIGN\_BYTES}
00774 \textcolor{preprocessor}{#endif}
00775 
00776 \textcolor{preprocessor}{#if EIGEN\_IDEAL\_MAX\_ALIGN\_BYTES > EIGEN\_MAX\_ALIGN\_BYTES}
00777 \textcolor{preprocessor}{#define EIGEN\_DEFAULT\_ALIGN\_BYTES EIGEN\_IDEAL\_MAX\_ALIGN\_BYTES}
00778 \textcolor{preprocessor}{#else}
00779 \textcolor{preprocessor}{#define EIGEN\_DEFAULT\_ALIGN\_BYTES EIGEN\_MAX\_ALIGN\_BYTES}
00780 \textcolor{preprocessor}{#endif}
00781 
00782 
00783 \textcolor{preprocessor}{#ifndef EIGEN\_UNALIGNED\_VECTORIZE}
00784 \textcolor{preprocessor}{#define EIGEN\_UNALIGNED\_VECTORIZE 1}
00785 \textcolor{preprocessor}{#endif}
00786 
00787 \textcolor{comment}{//----------------------------------------------------------------------}
00788 
00789 
00790 \textcolor{preprocessor}{#ifdef EIGEN\_DONT\_USE\_RESTRICT\_KEYWORD}
00791 \textcolor{preprocessor}{  #define EIGEN\_RESTRICT}
00792 \textcolor{preprocessor}{#endif}
00793 \textcolor{preprocessor}{#ifndef EIGEN\_RESTRICT}
00794 \textcolor{preprocessor}{  #define EIGEN\_RESTRICT \_\_restrict}
00795 \textcolor{preprocessor}{#endif}
00796 
00797 \textcolor{preprocessor}{#ifndef EIGEN\_STACK\_ALLOCATION\_LIMIT}
00798 \textcolor{comment}{// 131072 == 128 KB}
00799 \textcolor{preprocessor}{#define EIGEN\_STACK\_ALLOCATION\_LIMIT 131072}
00800 \textcolor{preprocessor}{#endif}
00801 
00802 \textcolor{preprocessor}{#ifndef EIGEN\_DEFAULT\_IO\_FORMAT}
00803 \textcolor{preprocessor}{#ifdef EIGEN\_MAKING\_DOCS}
00804 \textcolor{comment}{// format used in Eigen's documentation}
00805 \textcolor{comment}{// needed to define it here as escaping characters in CMake add\_definition's argument seems very
       problematic.}
00806 \textcolor{preprocessor}{#define EIGEN\_DEFAULT\_IO\_FORMAT Eigen::IOFormat(3, 0, " ", "\(\backslash\)n", "", "")}
00807 \textcolor{preprocessor}{#else}
00808 \textcolor{preprocessor}{#define EIGEN\_DEFAULT\_IO\_FORMAT Eigen::IOFormat()}
00809 \textcolor{preprocessor}{#endif}
00810 \textcolor{preprocessor}{#endif}
00811 
00812 \textcolor{comment}{// just an empty macro !}
00813 \textcolor{preprocessor}{#define EIGEN\_EMPTY}
00814 
00815 \textcolor{preprocessor}{#if EIGEN\_COMP\_MSVC\_STRICT && (EIGEN\_COMP\_MSVC < 1900 ||  defined(\_\_CUDACC\_VER\_\_)) // for older MSVC
       versions, as well as 1900 && CUDA 8, using the base operator is sufficient (cf Bugs 1000, 1324)}
00816 \textcolor{preprocessor}{  #define EIGEN\_INHERIT\_ASSIGNMENT\_EQUAL\_OPERATOR(Derived) \(\backslash\)}
00817 \textcolor{preprocessor}{    using Base::operator =;}
00818 \textcolor{preprocessor}{#elif EIGEN\_COMP\_CLANG // workaround clang bug (see http://forum.kde.org/viewtopic.php?f=74&t=102653)}
00819 \textcolor{preprocessor}{  #define EIGEN\_INHERIT\_ASSIGNMENT\_EQUAL\_OPERATOR(Derived) \(\backslash\)}
00820 \textcolor{preprocessor}{    using Base::operator =; \(\backslash\)}
00821 \textcolor{preprocessor}{    EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Derived& operator=(const Derived& other) \{
       Base::operator=(other); return *this; \} \(\backslash\)}
00822 \textcolor{preprocessor}{    template <typename OtherDerived> \(\backslash\)}
00823 \textcolor{preprocessor}{    EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Derived& operator=(const DenseBase<OtherDerived>& other) \{
       Base::operator=(other.derived()); return *this; \}}
00824 \textcolor{preprocessor}{#else}
00825 \textcolor{preprocessor}{  #define EIGEN\_INHERIT\_ASSIGNMENT\_EQUAL\_OPERATOR(Derived) \(\backslash\)}
00826 \textcolor{preprocessor}{    using Base::operator =; \(\backslash\)}
00827 \textcolor{preprocessor}{    EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE Derived& operator=(const Derived& other) \(\backslash\)}
00828 \textcolor{preprocessor}{    \{ \(\backslash\)}
00829 \textcolor{preprocessor}{      Base::operator=(other); \(\backslash\)}
00830 \textcolor{preprocessor}{      return *this; \(\backslash\)}
00831 \textcolor{preprocessor}{    \}}
00832 \textcolor{preprocessor}{#endif}
00833 
00834 
00839 \textcolor{preprocessor}{#define EIGEN\_INHERIT\_ASSIGNMENT\_OPERATORS(Derived) EIGEN\_INHERIT\_ASSIGNMENT\_EQUAL\_OPERATOR(Derived)}
00840 
00849 \textcolor{preprocessor}{#define EIGEN\_GENERIC\_PUBLIC\_INTERFACE(Derived) \(\backslash\)}
00850 \textcolor{preprocessor}{  typedef typename Eigen::internal::traits<Derived>::Scalar Scalar;  \(\backslash\)}
00851 \textcolor{preprocessor}{  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;  \(\backslash\)}
00852 \textcolor{preprocessor}{  typedef typename Base::CoeffReturnType CoeffReturnType;  \(\backslash\)}
00853 \textcolor{preprocessor}{  typedef typename Eigen::internal::ref\_selector<Derived>::type Nested; \(\backslash\)}
00854 \textcolor{preprocessor}{  typedef typename Eigen::internal::traits<Derived>::StorageKind StorageKind; \(\backslash\)}
00855 \textcolor{preprocessor}{  typedef typename Eigen::internal::traits<Derived>::StorageIndex StorageIndex; \(\backslash\)}
00856 \textcolor{preprocessor}{  enum \{ RowsAtCompileTime = Eigen::internal::traits<Derived>::RowsAtCompileTime, \(\backslash\)}
00857 \textcolor{preprocessor}{        ColsAtCompileTime = Eigen::internal::traits<Derived>::ColsAtCompileTime, \(\backslash\)}
00858 \textcolor{preprocessor}{        Flags = Eigen::internal::traits<Derived>::Flags, \(\backslash\)}
00859 \textcolor{preprocessor}{        SizeAtCompileTime = Base::SizeAtCompileTime, \(\backslash\)}
00860 \textcolor{preprocessor}{        MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, \(\backslash\)}
00861 \textcolor{preprocessor}{        IsVectorAtCompileTime = Base::IsVectorAtCompileTime \}; \(\backslash\)}
00862 \textcolor{preprocessor}{  using Base::derived; \(\backslash\)}
00863 \textcolor{preprocessor}{  using Base::const\_cast\_derived;}
00864 
00865 
00866 \textcolor{comment}{// FIXME Maybe the EIGEN\_DENSE\_PUBLIC\_INTERFACE could be removed as importing PacketScalar is rarely needed}
00867 \textcolor{preprocessor}{#define EIGEN\_DENSE\_PUBLIC\_INTERFACE(Derived) \(\backslash\)}
00868 \textcolor{preprocessor}{  EIGEN\_GENERIC\_PUBLIC\_INTERFACE(Derived) \(\backslash\)}
00869 \textcolor{preprocessor}{  typedef typename Base::PacketScalar PacketScalar;}
00870 
00871 
00872 \textcolor{preprocessor}{#define EIGEN\_PLAIN\_ENUM\_MIN(a,b) (((int)a <= (int)b) ? (int)a : (int)b)}
00873 \textcolor{preprocessor}{#define EIGEN\_PLAIN\_ENUM\_MAX(a,b) (((int)a >= (int)b) ? (int)a : (int)b)}
00874 
00875 \textcolor{comment}{// EIGEN\_SIZE\_MIN\_PREFER\_DYNAMIC gives the min between compile-time sizes. 0 has absolute priority,
       followed by 1,}
00876 \textcolor{comment}{// followed by Dynamic, followed by other finite values. The reason for giving Dynamic the priority over}
00877 \textcolor{comment}{// finite values is that min(3, Dynamic) should be Dynamic, since that could be anything between 0 and 3.}
00878 \textcolor{preprocessor}{#define EIGEN\_SIZE\_MIN\_PREFER\_DYNAMIC(a,b) (((int)a == 0 || (int)b == 0) ? 0 \(\backslash\)}
00879 \textcolor{preprocessor}{                           : ((int)a == 1 || (int)b == 1) ? 1 \(\backslash\)}
00880 \textcolor{preprocessor}{                           : ((int)a == Dynamic || (int)b == Dynamic) ? Dynamic \(\backslash\)}
00881 \textcolor{preprocessor}{                           : ((int)a <= (int)b) ? (int)a : (int)b)}
00882 
00883 \textcolor{comment}{// EIGEN\_SIZE\_MIN\_PREFER\_FIXED is a variant of EIGEN\_SIZE\_MIN\_PREFER\_DYNAMIC comparing MaxSizes. The
       difference is that finite values}
00884 \textcolor{comment}{// now have priority over Dynamic, so that min(3, Dynamic) gives 3. Indeed, whatever the actual value is}
00885 \textcolor{comment}{// (between 0 and 3), it is not more than 3.}
00886 \textcolor{preprocessor}{#define EIGEN\_SIZE\_MIN\_PREFER\_FIXED(a,b)  (((int)a == 0 || (int)b == 0) ? 0 \(\backslash\)}
00887 \textcolor{preprocessor}{                           : ((int)a == 1 || (int)b == 1) ? 1 \(\backslash\)}
00888 \textcolor{preprocessor}{                           : ((int)a == Dynamic && (int)b == Dynamic) ? Dynamic \(\backslash\)}
00889 \textcolor{preprocessor}{                           : ((int)a == Dynamic) ? (int)b \(\backslash\)}
00890 \textcolor{preprocessor}{                           : ((int)b == Dynamic) ? (int)a \(\backslash\)}
00891 \textcolor{preprocessor}{                           : ((int)a <= (int)b) ? (int)a : (int)b)}
00892 
00893 \textcolor{comment}{// see EIGEN\_SIZE\_MIN\_PREFER\_DYNAMIC. No need for a separate variant for MaxSizes here.}
00894 \textcolor{preprocessor}{#define EIGEN\_SIZE\_MAX(a,b) (((int)a == Dynamic || (int)b == Dynamic) ? Dynamic \(\backslash\)}
00895 \textcolor{preprocessor}{                           : ((int)a >= (int)b) ? (int)a : (int)b)}
00896 
00897 \textcolor{preprocessor}{#define EIGEN\_LOGICAL\_XOR(a,b) (((a) || (b)) && !((a) && (b)))}
00898 
00899 \textcolor{preprocessor}{#define EIGEN\_IMPLIES(a,b) (!(a) || (b))}
00900 
00901 \textcolor{comment}{// the expression type of a standard coefficient wise binary operation}
00902 \textcolor{preprocessor}{#define EIGEN\_CWISE\_BINARY\_RETURN\_TYPE(LHS,RHS,OPNAME) \(\backslash\)}
00903 \textcolor{preprocessor}{    CwiseBinaryOp< \(\backslash\)}
00904 \textcolor{preprocessor}{      EIGEN\_CAT(EIGEN\_CAT(internal::scalar\_,OPNAME),\_op)< \(\backslash\)}
00905 \textcolor{preprocessor}{          typename internal::traits<LHS>::Scalar, \(\backslash\)}
00906 \textcolor{preprocessor}{          typename internal::traits<RHS>::Scalar \(\backslash\)}
00907 \textcolor{preprocessor}{      >, \(\backslash\)}
00908 \textcolor{preprocessor}{      const LHS, \(\backslash\)}
00909 \textcolor{preprocessor}{      const RHS \(\backslash\)}
00910 \textcolor{preprocessor}{    >}
00911 
00912 \textcolor{preprocessor}{#define EIGEN\_MAKE\_CWISE\_BINARY\_OP(METHOD,OPNAME) \(\backslash\)}
00913 \textcolor{preprocessor}{  template<typename OtherDerived> \(\backslash\)}
00914 \textcolor{preprocessor}{  EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE const EIGEN\_CWISE\_BINARY\_RETURN\_TYPE(Derived,OtherDerived,OPNAME) \(\backslash\)}
00915 \textcolor{preprocessor}{  (METHOD)(const EIGEN\_CURRENT\_STORAGE\_BASE\_CLASS<OtherDerived> &other) const \(\backslash\)}
00916 \textcolor{preprocessor}{  \{ \(\backslash\)}
00917 \textcolor{preprocessor}{    return EIGEN\_CWISE\_BINARY\_RETURN\_TYPE(Derived,OtherDerived,OPNAME)(derived(), other.derived()); \(\backslash\)}
00918 \textcolor{preprocessor}{  \}}
00919 
00920 \textcolor{preprocessor}{#define EIGEN\_SCALAR\_BINARY\_SUPPORTED(OPNAME,TYPEA,TYPEB) \(\backslash\)}
00921 \textcolor{preprocessor}{ 
       (Eigen::internal::has\_ReturnType<Eigen::ScalarBinaryOpTraits<TYPEA,TYPEB,EIGEN\_CAT(EIGEN\_CAT(Eigen::internal::scalar\_,OPNAME),\_op)<TYPEA,TYPEB>  > >::value)}
00922 
00923 \textcolor{preprocessor}{#define EIGEN\_EXPR\_BINARYOP\_SCALAR\_RETURN\_TYPE(EXPR,SCALAR,OPNAME) \(\backslash\)}
00924 \textcolor{preprocessor}{  CwiseBinaryOp<EIGEN\_CAT(EIGEN\_CAT(internal::scalar\_,OPNAME),\_op)<typename
       internal::traits<EXPR>::Scalar,SCALAR>, const EXPR, \(\backslash\)}
00925 \textcolor{preprocessor}{                const typename internal::plain\_constant\_type<EXPR,SCALAR>::type>}
00926 
00927 \textcolor{preprocessor}{#define EIGEN\_SCALAR\_BINARYOP\_EXPR\_RETURN\_TYPE(SCALAR,EXPR,OPNAME) \(\backslash\)}
00928 \textcolor{preprocessor}{  CwiseBinaryOp<EIGEN\_CAT(EIGEN\_CAT(internal::scalar\_,OPNAME),\_op)<SCALAR,typename
       internal::traits<EXPR>::Scalar>, \(\backslash\)}
00929 \textcolor{preprocessor}{                const typename internal::plain\_constant\_type<EXPR,SCALAR>::type, const EXPR>}
00930 
00931 \textcolor{comment}{// Workaround for MSVC 2010 (see ML thread "patch with compile for for MSVC 2010")}
00932 \textcolor{preprocessor}{#if EIGEN\_COMP\_MSVC\_STRICT<=1600}
00933 \textcolor{preprocessor}{#define EIGEN\_MSVC10\_WORKAROUND\_BINARYOP\_RETURN\_TYPE(X) typename internal::enable\_if<true,X>::type}
00934 \textcolor{preprocessor}{#else}
00935 \textcolor{preprocessor}{#define EIGEN\_MSVC10\_WORKAROUND\_BINARYOP\_RETURN\_TYPE(X) X}
00936 \textcolor{preprocessor}{#endif}
00937 
00938 \textcolor{preprocessor}{#define EIGEN\_MAKE\_SCALAR\_BINARY\_OP\_ONTHERIGHT(METHOD,OPNAME) \(\backslash\)}
00939 \textcolor{preprocessor}{  template <typename T> EIGEN\_DEVICE\_FUNC inline \(\backslash\)}
00940 \textcolor{preprocessor}{  EIGEN\_MSVC10\_WORKAROUND\_BINARYOP\_RETURN\_TYPE(const
       EIGEN\_EXPR\_BINARYOP\_SCALAR\_RETURN\_TYPE(Derived,typename internal::promote\_scalar\_arg<Scalar EIGEN\_COMMA T EIGEN\_COMMA
       EIGEN\_SCALAR\_BINARY\_SUPPORTED(OPNAME,Scalar,T)>::type,OPNAME))\(\backslash\)}
00941 \textcolor{preprocessor}{  (METHOD)(const T& scalar) const \{ \(\backslash\)}
00942 \textcolor{preprocessor}{    typedef typename
       internal::promote\_scalar\_arg<Scalar,T,EIGEN\_SCALAR\_BINARY\_SUPPORTED(OPNAME,Scalar,T)>::type PromotedT; \(\backslash\)}
00943 \textcolor{preprocessor}{    return EIGEN\_EXPR\_BINARYOP\_SCALAR\_RETURN\_TYPE(Derived,PromotedT,OPNAME)(derived(), \(\backslash\)}
00944 \textcolor{preprocessor}{           typename internal::plain\_constant\_type<Derived,PromotedT>::type(derived().rows(),
       derived().cols(), internal::scalar\_constant\_op<PromotedT>(scalar))); \(\backslash\)}
00945 \textcolor{preprocessor}{  \}}
00946 
00947 \textcolor{preprocessor}{#define EIGEN\_MAKE\_SCALAR\_BINARY\_OP\_ONTHELEFT(METHOD,OPNAME) \(\backslash\)}
00948 \textcolor{preprocessor}{  template <typename T> EIGEN\_DEVICE\_FUNC inline friend \(\backslash\)}
00949 \textcolor{preprocessor}{  EIGEN\_MSVC10\_WORKAROUND\_BINARYOP\_RETURN\_TYPE(const EIGEN\_SCALAR\_BINARYOP\_EXPR\_RETURN\_TYPE(typename
       internal::promote\_scalar\_arg<Scalar EIGEN\_COMMA T EIGEN\_COMMA
       EIGEN\_SCALAR\_BINARY\_SUPPORTED(OPNAME,T,Scalar)>::type,Derived,OPNAME)) \(\backslash\)}
00950 \textcolor{preprocessor}{  (METHOD)(const T& scalar, const StorageBaseType& matrix) \{ \(\backslash\)}
00951 \textcolor{preprocessor}{    typedef typename
       internal::promote\_scalar\_arg<Scalar,T,EIGEN\_SCALAR\_BINARY\_SUPPORTED(OPNAME,T,Scalar)>::type PromotedT; \(\backslash\)}
00952 \textcolor{preprocessor}{    return EIGEN\_SCALAR\_BINARYOP\_EXPR\_RETURN\_TYPE(PromotedT,Derived,OPNAME)( \(\backslash\)}
00953 \textcolor{preprocessor}{           typename internal::plain\_constant\_type<Derived,PromotedT>::type(matrix.derived().rows(),
       matrix.derived().cols(), internal::scalar\_constant\_op<PromotedT>(scalar)), matrix.derived()); \(\backslash\)}
00954 \textcolor{preprocessor}{  \}}
00955 
00956 \textcolor{preprocessor}{#define EIGEN\_MAKE\_SCALAR\_BINARY\_OP(METHOD,OPNAME) \(\backslash\)}
00957 \textcolor{preprocessor}{  EIGEN\_MAKE\_SCALAR\_BINARY\_OP\_ONTHELEFT(METHOD,OPNAME) \(\backslash\)}
00958 \textcolor{preprocessor}{  EIGEN\_MAKE\_SCALAR\_BINARY\_OP\_ONTHERIGHT(METHOD,OPNAME)}
00959 
00960 
00961 \textcolor{preprocessor}{#ifdef EIGEN\_EXCEPTIONS}
00962 \textcolor{preprocessor}{#  define EIGEN\_THROW\_X(X) throw X}
00963 \textcolor{preprocessor}{#  define EIGEN\_THROW throw}
00964 \textcolor{preprocessor}{#  define EIGEN\_TRY try}
00965 \textcolor{preprocessor}{#  define EIGEN\_CATCH(X) catch (X)}
00966 \textcolor{preprocessor}{#else}
00967 \textcolor{preprocessor}{#  ifdef \_\_CUDA\_ARCH\_\_}
00968 \textcolor{preprocessor}{#    define EIGEN\_THROW\_X(X) asm("trap;")}
00969 \textcolor{preprocessor}{#    define EIGEN\_THROW asm("trap;")}
00970 \textcolor{preprocessor}{#  else}
00971 \textcolor{preprocessor}{#    define EIGEN\_THROW\_X(X) std::abort()}
00972 \textcolor{preprocessor}{#    define EIGEN\_THROW std::abort()}
00973 \textcolor{preprocessor}{#  endif}
00974 \textcolor{preprocessor}{#  define EIGEN\_TRY if (true)}
00975 \textcolor{preprocessor}{#  define EIGEN\_CATCH(X) else}
00976 \textcolor{preprocessor}{#endif}
00977 
00978 
00979 \textcolor{preprocessor}{#if EIGEN\_HAS\_CXX11\_NOEXCEPT}
00980 \textcolor{preprocessor}{#   define EIGEN\_INCLUDE\_TYPE\_TRAITS}
00981 \textcolor{preprocessor}{#   define EIGEN\_NOEXCEPT noexcept}
00982 \textcolor{preprocessor}{#   define EIGEN\_NOEXCEPT\_IF(x) noexcept(x)}
00983 \textcolor{preprocessor}{#   define EIGEN\_NO\_THROW noexcept(true)}
00984 \textcolor{preprocessor}{#   define EIGEN\_EXCEPTION\_SPEC(X) noexcept(false)}
00985 \textcolor{preprocessor}{#else}
00986 \textcolor{preprocessor}{#   define EIGEN\_NOEXCEPT}
00987 \textcolor{preprocessor}{#   define EIGEN\_NOEXCEPT\_IF(x)}
00988 \textcolor{preprocessor}{#   define EIGEN\_NO\_THROW throw()}
00989 \textcolor{preprocessor}{#   define EIGEN\_EXCEPTION\_SPEC(X) throw(X)}
00990 \textcolor{preprocessor}{#endif}
00991 
00992 \textcolor{preprocessor}{#endif // EIGEN\_MACROS\_H}
\end{DoxyCode}
