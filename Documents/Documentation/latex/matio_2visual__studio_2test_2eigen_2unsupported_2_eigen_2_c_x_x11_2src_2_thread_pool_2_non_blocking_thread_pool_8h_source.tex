\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_thread_pool_2_non_blocking_thread_pool_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Thread\+Pool/\+Non\+Blocking\+Thread\+Pool.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_thread_pool_2_non_blocking_thread_pool_8h_source}\index{Non\+Blocking\+Thread\+Pool.\+h@{Non\+Blocking\+Thread\+Pool.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2016 Dmitry Vyukov <dvyukov@google.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_THREADPOOL\_NONBLOCKING\_THREAD\_POOL\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_THREADPOOL\_NONBLOCKING\_THREAD\_POOL\_H}
00012 
00013 
00014 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00015 
00016 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Environment>
00017 \textcolor{keyword}{class }NonBlockingThreadPoolTempl : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_thread_pool_interface}{Eigen::ThreadPoolInterface} \{
00018  \textcolor{keyword}{public}:
00019   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Environment::Task Task;
00020   \textcolor{keyword}{typedef} RunQueue<Task, 1024> Queue;
00021 
00022   NonBlockingThreadPoolTempl(\textcolor{keywordtype}{int} num\_threads, Environment env = Environment())
00023       : env\_(env),
00024         threads\_(num\_threads),
00025         queues\_(num\_threads),
00026         coprimes\_(num\_threads),
00027         waiters\_(num\_threads),
00028         blocked\_(0),
00029         spinning\_(0),
00030         done\_(false),
00031         ec\_(waiters\_) \{
00032     waiters\_.resize(num\_threads);
00033 
00034     \textcolor{comment}{// Calculate coprimes of num\_threads.}
00035     \textcolor{comment}{// Coprimes are used for a random walk over all threads in Steal}
00036     \textcolor{comment}{// and NonEmptyQueueIndex. Iteration is based on the fact that if we take}
00037     \textcolor{comment}{// a walk starting thread index t and calculate num\_threads - 1 subsequent}
00038     \textcolor{comment}{// indices as (t + coprime) % num\_threads, we will cover all threads without}
00039     \textcolor{comment}{// repetitions (effectively getting a presudo-random permutation of thread}
00040     \textcolor{comment}{// indices).}
00041     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i <= num\_threads; i++) \{
00042       \textcolor{keywordtype}{unsigned} a = i;
00043       \textcolor{keywordtype}{unsigned} b = num\_threads;
00044       \textcolor{comment}{// If GCD(a, b) == 1, then a and b are coprimes.}
00045       \textcolor{keywordflow}{while} (b != 0) \{
00046         \textcolor{keywordtype}{unsigned} tmp = a;
00047         a = b;
00048         b = tmp % b;
00049       \}
00050       \textcolor{keywordflow}{if} (a == 1) \{
00051         coprimes\_.push\_back(i);
00052       \}
00053     \}
00054     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_threads; i++) \{
00055       queues\_.push\_back(\textcolor{keyword}{new} Queue());
00056     \}
00057     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_threads; i++) \{
00058       threads\_.push\_back(env\_.CreateThread([\textcolor{keyword}{this}, i]() \{ WorkerLoop(i); \}));
00059     \}
00060   \}
00061 
00062   ~NonBlockingThreadPoolTempl() \{
00063     done\_ = \textcolor{keyword}{true};
00064     \textcolor{comment}{// Now if all threads block without work, they will start exiting.}
00065     \textcolor{comment}{// But note that threads can continue to work arbitrary long,}
00066     \textcolor{comment}{// block, submit new work, unblock and otherwise live full life.}
00067     ec\_.Notify(\textcolor{keyword}{true});
00068 
00069     \textcolor{comment}{// Join threads explicitly to avoid destruction order issues.}
00070     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < threads\_.size(); i++) \textcolor{keyword}{delete} threads\_[i];
00071     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < threads\_.size(); i++) \textcolor{keyword}{delete} queues\_[i];
00072   \}
00073 
00074   \textcolor{keywordtype}{void} Schedule(std::function<\textcolor{keywordtype}{void}()> fn) \{
00075     Task t = env\_.CreateTask(std::move(fn));
00076     PerThread* pt = GetPerThread();
00077     \textcolor{keywordflow}{if} (pt->pool == \textcolor{keyword}{this}) \{
00078       \textcolor{comment}{// Worker thread of this pool, push onto the thread's queue.}
00079       Queue* q = queues\_[pt->thread\_id];
00080       t = q->PushFront(std::move(t));
00081     \} \textcolor{keywordflow}{else} \{
00082       \textcolor{comment}{// A free-standing thread (or worker of another pool), push onto a random}
00083       \textcolor{comment}{// queue.}
00084       Queue* q = queues\_[Rand(&pt->rand) % queues\_.size()];
00085       t = q->PushBack(std::move(t));
00086     \}
00087     \textcolor{comment}{// Note: below we touch this after making w available to worker threads.}
00088     \textcolor{comment}{// Strictly speaking, this can lead to a racy-use-after-free. Consider that}
00089     \textcolor{comment}{// Schedule is called from a thread that is neither main thread nor a worker}
00090     \textcolor{comment}{// thread of this pool. Then, execution of w directly or indirectly}
00091     \textcolor{comment}{// completes overall computations, which in turn leads to destruction of}
00092     \textcolor{comment}{// this. We expect that such scenario is prevented by program, that is,}
00093     \textcolor{comment}{// this is kept alive while any threads can potentially be in Schedule.}
00094     \textcolor{keywordflow}{if} (!t.f)
00095       ec\_.Notify(\textcolor{keyword}{false});
00096     \textcolor{keywordflow}{else}
00097       env\_.ExecuteTask(t);  \textcolor{comment}{// Push failed, execute directly.}
00098   \}
00099 
00100   \textcolor{keywordtype}{int} NumThreads() const final \{
00101     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(threads\_.size());
00102   \}
00103 
00104   \textcolor{keywordtype}{int} CurrentThreadId() const final \{
00105     \textcolor{keyword}{const} PerThread* pt =
00106         \textcolor{keyword}{const\_cast<}NonBlockingThreadPoolTempl*\textcolor{keyword}{>}(\textcolor{keyword}{this})->GetPerThread();
00107     \textcolor{keywordflow}{if} (pt->pool == \textcolor{keyword}{this}) \{
00108       \textcolor{keywordflow}{return} pt->thread\_id;
00109     \} \textcolor{keywordflow}{else} \{
00110       \textcolor{keywordflow}{return} -1;
00111     \}
00112   \}
00113 
00114  \textcolor{keyword}{private}:
00115   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Environment::EnvThread Thread;
00116 
00117   \textcolor{keyword}{struct }PerThread \{
00118     constexpr PerThread() : pool(NULL), rand(0), thread\_id(-1) \{ \}
00119     NonBlockingThreadPoolTempl* pool;  \textcolor{comment}{// Parent pool, or null for normal threads.}
00120     uint64\_t rand;  \textcolor{comment}{// Random generator state.}
00121     \textcolor{keywordtype}{int} thread\_id;  \textcolor{comment}{// Worker thread index in pool.}
00122   \};
00123 
00124   Environment env\_;
00125   MaxSizeVector<Thread*> threads\_;
00126   MaxSizeVector<Queue*> queues\_;
00127   MaxSizeVector<unsigned> coprimes\_;
00128   MaxSizeVector<EventCount::Waiter> waiters\_;
00129   std::atomic<unsigned> blocked\_;
00130   std::atomic<bool> spinning\_;
00131   std::atomic<bool> done\_;
00132   EventCount ec\_;
00133 
00134   \textcolor{comment}{// Main worker thread loop.}
00135   \textcolor{keywordtype}{void} WorkerLoop(\textcolor{keywordtype}{int} thread\_id) \{
00136     PerThread* pt = GetPerThread();
00137     pt->pool = \textcolor{keyword}{this};
00138     pt->rand = std::hash<std::thread::id>()(std::this\_thread::get\_id());
00139     pt->thread\_id = thread\_id;
00140     Queue* q = queues\_[thread\_id];
00141     EventCount::Waiter* waiter = &waiters\_[thread\_id];
00142     \textcolor{keywordflow}{for} (;;) \{
00143       Task t = q->PopFront();
00144       \textcolor{keywordflow}{if} (!t.f) \{
00145         t = Steal();
00146         \textcolor{keywordflow}{if} (!t.f) \{
00147           \textcolor{comment}{// Leave one thread spinning. This reduces latency.}
00148           \textcolor{comment}{// TODO(dvyukov): 1000 iterations is based on fair dice roll, tune it.}
00149           \textcolor{comment}{// Also, the time it takes to attempt to steal work 1000 times depends}
00150           \textcolor{comment}{// on the size of the thread pool. However the speed at which the user}
00151           \textcolor{comment}{// of the thread pool submit tasks is independent of the size of the}
00152           \textcolor{comment}{// pool. Consider a time based limit instead.}
00153           \textcolor{keywordflow}{if} (!spinning\_ && !spinning\_.exchange(\textcolor{keyword}{true})) \{
00154             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 1000 && !t.f; i++) \{
00155               t = Steal();
00156             \}
00157             spinning\_ = \textcolor{keyword}{false};
00158           \}
00159           \textcolor{keywordflow}{if} (!t.f) \{
00160             \textcolor{keywordflow}{if} (!WaitForWork(waiter, &t)) \{
00161               \textcolor{keywordflow}{return};
00162             \}
00163           \}
00164         \}
00165       \}
00166       \textcolor{keywordflow}{if} (t.f) \{
00167         env\_.ExecuteTask(t);
00168       \}
00169     \}
00170   \}
00171 
00172   \textcolor{comment}{// Steal tries to steal work from other worker threads in best-effort manner.}
00173   Task Steal() \{
00174     PerThread* pt = GetPerThread();
00175     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} size = queues\_.size();
00176     \textcolor{keywordtype}{unsigned} r = Rand(&pt->rand);
00177     \textcolor{keywordtype}{unsigned} inc = coprimes\_[r % coprimes\_.size()];
00178     \textcolor{keywordtype}{unsigned} victim = r % size;
00179     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < size; i++) \{
00180       Task t = queues\_[victim]->PopBack();
00181       \textcolor{keywordflow}{if} (t.f) \{
00182         \textcolor{keywordflow}{return} t;
00183       \}
00184       victim += inc;
00185       \textcolor{keywordflow}{if} (victim >= size) \{
00186         victim -= size;
00187       \}
00188     \}
00189     \textcolor{keywordflow}{return} Task();
00190   \}
00191 
00192   \textcolor{comment}{// WaitForWork blocks until new work is available (returns true), or if it is}
00193   \textcolor{comment}{// time to exit (returns false). Can optionally return a task to execute in t}
00194   \textcolor{comment}{// (in such case t.f != nullptr on return).}
00195   \textcolor{keywordtype}{bool} WaitForWork(EventCount::Waiter* waiter, Task* t) \{
00196     eigen\_assert(!t->f);
00197     \textcolor{comment}{// We already did best-effort emptiness check in Steal, so prepare for}
00198     \textcolor{comment}{// blocking.}
00199     ec\_.Prewait(waiter);
00200     \textcolor{comment}{// Now do a reliable emptiness check.}
00201     \textcolor{keywordtype}{int} victim = NonEmptyQueueIndex();
00202     \textcolor{keywordflow}{if} (victim != -1) \{
00203       ec\_.CancelWait(waiter);
00204       *t = queues\_[victim]->PopBack();
00205       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00206     \}
00207     \textcolor{comment}{// Number of blocked threads is used as termination condition.}
00208     \textcolor{comment}{// If we are shutting down and all worker threads blocked without work,}
00209     \textcolor{comment}{// that's we are done.}
00210     blocked\_++;
00211     \textcolor{keywordflow}{if} (done\_ && blocked\_ == threads\_.size()) \{
00212       ec\_.CancelWait(waiter);
00213       \textcolor{comment}{// Almost done, but need to re-check queues.}
00214       \textcolor{comment}{// Consider that all queues are empty and all worker threads are preempted}
00215       \textcolor{comment}{// right after incrementing blocked\_ above. Now a free-standing thread}
00216       \textcolor{comment}{// submits work and calls destructor (which sets done\_). If we don't}
00217       \textcolor{comment}{// re-check queues, we will exit leaving the work unexecuted.}
00218       \textcolor{keywordflow}{if} (NonEmptyQueueIndex() != -1) \{
00219         \textcolor{comment}{// Note: we must not pop from queues before we decrement blocked\_,}
00220         \textcolor{comment}{// otherwise the following scenario is possible. Consider that instead}
00221         \textcolor{comment}{// of checking for emptiness we popped the only element from queues.}
00222         \textcolor{comment}{// Now other worker threads can start exiting, which is bad if the}
00223         \textcolor{comment}{// work item submits other work. So we just check emptiness here,}
00224         \textcolor{comment}{// which ensures that all worker threads exit at the same time.}
00225         blocked\_--;
00226         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00227       \}
00228       \textcolor{comment}{// Reached stable termination state.}
00229       ec\_.Notify(\textcolor{keyword}{true});
00230       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00231     \}
00232     ec\_.CommitWait(waiter);
00233     blocked\_--;
00234     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00235   \}
00236 
00237   \textcolor{keywordtype}{int} NonEmptyQueueIndex() \{
00238     PerThread* pt = GetPerThread();
00239     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} size = queues\_.size();
00240     \textcolor{keywordtype}{unsigned} r = Rand(&pt->rand);
00241     \textcolor{keywordtype}{unsigned} inc = coprimes\_[r % coprimes\_.size()];
00242     \textcolor{keywordtype}{unsigned} victim = r % size;
00243     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < size; i++) \{
00244       \textcolor{keywordflow}{if} (!queues\_[victim]->Empty()) \{
00245         \textcolor{keywordflow}{return} victim;
00246       \}
00247       victim += inc;
00248       \textcolor{keywordflow}{if} (victim >= size) \{
00249         victim -= size;
00250       \}
00251     \}
00252     \textcolor{keywordflow}{return} -1;
00253   \}
00254 
00255   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE PerThread* GetPerThread() \{
00256     EIGEN\_THREAD\_LOCAL PerThread per\_thread\_;
00257     PerThread* pt = &per\_thread\_;
00258     \textcolor{keywordflow}{return} pt;
00259   \}
00260 
00261   \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{unsigned} Rand(uint64\_t* \hyperlink{structstate}{state}) \{
00262     uint64\_t current = *state;
00263     \textcolor{comment}{// Update the internal state}
00264     *state = current * 6364136223846793005ULL + 0xda3e39cb94b95bdbULL;
00265     \textcolor{comment}{// Generate the random output (using the PCG-XSH-RS scheme)}
00266     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}((current ^ (current >> 22)) >> (22 + (current >> 61)));
00267   \}
00268 \};
00269 
00270 \textcolor{keyword}{typedef} NonBlockingThreadPoolTempl<StlThreadEnvironment> NonBlockingThreadPool;
00271 
00272 \}  \textcolor{comment}{// namespace Eigen}
00273 
00274 \textcolor{preprocessor}{#endif  // EIGEN\_CXX11\_THREADPOOL\_NONBLOCKING\_THREAD\_POOL\_H}
\end{DoxyCode}
