\hypertarget{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_device_sycl_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Device\+Sycl.h}
\label{matio_2visual__studio_2test_2eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_device_sycl_8h_source}\index{Tensor\+Device\+Sycl.\+h@{Tensor\+Device\+Sycl.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Mehdi Goli    Codeplay Software Ltd.}
00005 \textcolor{comment}{// Ralph Potter  Codeplay Software Ltd.}
00006 \textcolor{comment}{// Luke Iwanski  Codeplay Software Ltd.}
00007 \textcolor{comment}{// Contact: <eigen@codeplay.com>}
00008 \textcolor{comment}{// Copyright (C) 2016 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00009 
00010 \textcolor{comment}{//}
00011 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00012 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00013 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00014 
00015 \textcolor{preprocessor}{#if defined(EIGEN\_USE\_SYCL) && !defined(EIGEN\_CXX11\_TENSOR\_TENSOR\_DEVICE\_SYCL\_H)}
00016 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_DEVICE\_SYCL\_H}
00017 
00018 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00019 \textcolor{keyword}{struct }SyclDevice \{
00022   \textcolor{keyword}{mutable} cl::sycl::queue m\_queue;
00026   \textcolor{keyword}{mutable} std::map<const void *, std::shared\_ptr<void>> buffer\_map;
00028   \textcolor{keyword}{template}<\textcolor{keyword}{typename} dev\_Selector> SyclDevice(dev\_Selector s)
00029   :
00030 #ifdef EIGEN\_EXCEPTIONS
00031   m\_queue(cl::sycl::queue(s, [=](cl::sycl::exception\_list l) \{
00032     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& e : l) \{
00033       \textcolor{keywordflow}{try} \{
00034         std::rethrow\_exception(e);
00035       \} \textcolor{keywordflow}{catch} (cl::sycl::exception e) \{
00036           std::cout << e.what() << std::endl;
00037         \}
00038     \}
00039   \}))
00040 \textcolor{preprocessor}{#else}
00041   m\_queue(cl::sycl::queue(s))
00042 \textcolor{preprocessor}{#endif}
00043   \{\}
00044   \textcolor{comment}{// destructor}
00045   ~SyclDevice() \{ deallocate\_all(); \}
00046 
00047   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keywordtype}{void} deallocate(\hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *p)\textcolor{keyword}{ const }\{
00048     \textcolor{keyword}{auto} it = buffer\_map.find(p);
00049     \textcolor{keywordflow}{if} (it != buffer\_map.end()) \{
00050       buffer\_map.erase(it);
00051       internal::aligned\_free(p);
00052     \}
00053   \}
00054   \textcolor{keywordtype}{void} deallocate\_all()\textcolor{keyword}{ const }\{
00055     std::map<const void *, std::shared\_ptr<void>>::iterator it=buffer\_map.begin();
00056     \textcolor{keywordflow}{while} (it!=buffer\_map.end()) \{
00057       \textcolor{keyword}{auto} p=it->first;
00058       buffer\_map.erase(it);
00059       internal::aligned\_free(const\_cast<void*>(p));
00060       it=buffer\_map.begin();
00061     \}
00062     buffer\_map.clear();
00063   \}
00064 
00068   \textcolor{keyword}{template} <cl::sycl::access::mode AcMd, \textcolor{keyword}{typename} T> \textcolor{keyword}{inline} cl::sycl::accessor<T, 1, AcMd,
       cl::sycl::access::target::global\_buffer>
00069   get\_sycl\_accessor(\textcolor{keywordtype}{size\_t} num\_bytes, cl::sycl::handler &cgh, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} * ptr)\textcolor{keyword}{ const }\{
00070     \textcolor{keywordflow}{return} (get\_sycl\_buffer<T>(num\_bytes, ptr)->\textcolor{keyword}{template} get\_access<AcMd,
       cl::sycl::access::target::global\_buffer>(cgh));
00071   \}
00072 
00073   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{inline}  std::pair<std::map<const void *, std::shared\_ptr<void>>::iterator,\textcolor{keywordtype}{bool}> 
      add\_sycl\_buffer(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *ptr, \textcolor{keywordtype}{size\_t} num\_bytes)\textcolor{keyword}{ const }\{
00074     \textcolor{keyword}{using} Type = cl::sycl::buffer<T, 1>;
00075     std::pair<std::map<const void *, std::shared\_ptr<void>>::iterator,\textcolor{keywordtype}{bool}> ret = buffer\_map.insert(
      std::pair<\textcolor{keyword}{const} \textcolor{keywordtype}{void} *, std::shared\_ptr<void>>(ptr, std::shared\_ptr<void>(\textcolor{keyword}{new} Type(cl::sycl::range<1>(num\_bytes)),
00076       [](\textcolor{keywordtype}{void} *dataMem) \{ \textcolor{keyword}{delete} \textcolor{keyword}{static\_cast<}Type*\textcolor{keyword}{>}(dataMem); \})));
00077     (\textcolor{keyword}{static\_cast<}Type*\textcolor{keyword}{>}(buffer\_map.at(ptr).get()))->set\_final\_data(\textcolor{keyword}{nullptr});
00078     \textcolor{keywordflow}{return} ret;
00079   \}
00080 
00081   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{inline} cl::sycl::buffer<T, 1>* get\_sycl\_buffer(\textcolor{keywordtype}{size\_t} num\_bytes,\textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} * ptr)\textcolor{keyword}{ const }\{
00082     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}cl::sycl::buffer<T, 1>*\textcolor{keyword}{>}(add\_sycl\_buffer(ptr, num\_bytes).first->second.get());
00083   \}
00084 
00086   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} *allocate(\textcolor{keywordtype}{size\_t})\textcolor{keyword}{ const }\{
00087     \textcolor{keywordflow}{return} internal::aligned\_malloc(8);
00088   \}
00089 
00090   \textcolor{comment}{// some runtime conditions that can be applied here}
00091   \textcolor{keywordtype}{bool} isDeviceSuitable()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}
00092 
00093   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} memcpy(\textcolor{keywordtype}{void} *dst, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *src, \textcolor{keywordtype}{size\_t} n)\textcolor{keyword}{ const }\{
00094     ::memcpy(dst, src, n);
00095   \}
00096 
00097   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} memcpyHostToDevice(
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *dst, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *src, \textcolor{keywordtype}{size\_t} n)\textcolor{keyword}{ const }\{
00098     \textcolor{keyword}{auto} host\_acc= (\textcolor{keyword}{static\_cast<}cl::sycl::buffer<T, 1>*\textcolor{keyword}{>}(add\_sycl\_buffer(dst, n).first->second.get()))-> \textcolor{keyword}{
      template} get\_access<cl::sycl::access::mode::discard\_write, cl::sycl::access::target::host\_buffer>();
00099     memcpy(host\_acc.get\_pointer(), src, n);
00100   \}
00102   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} memcpyDeviceToHost(
      \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *dst, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T} *src, \textcolor{keywordtype}{size\_t} n)\textcolor{keyword}{ const }\{
00103     \textcolor{keyword}{auto} it = buffer\_map.find(src);
00104     \textcolor{keywordflow}{if} (it != buffer\_map.end()) \{
00105       \textcolor{keyword}{auto} host\_acc= (\textcolor{keyword}{static\_cast<}cl::sycl::buffer<T, 1>*\textcolor{keyword}{>}(it->second.get()))-> \textcolor{keyword}{template} 
      get\_access<cl::sycl::access::mode::read, cl::sycl::access::target::host\_buffer>();
00106       memcpy(dst,host\_acc.get\_pointer(),  n);
00107     \} \textcolor{keywordflow}{else}\{
00108       eigen\_assert(\textcolor{stringliteral}{"no device memory found. The memory might be destroyed before creation"});
00109     \}
00110   \}
00111 
00112   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} memset(\textcolor{keywordtype}{void} *buffer, \textcolor{keywordtype}{int} c, \textcolor{keywordtype}{size\_t} n)\textcolor{keyword}{ const }\{
00113     ::memset(buffer, c, n);
00114   \}
00115   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{int} majorDeviceVersion()\textcolor{keyword}{ const }\{
00116   \textcolor{keywordflow}{return} 1;
00117   \}
00118 \};
00119 
00120 \}  \textcolor{comment}{// end namespace Eigen}
00121 
00122 \textcolor{preprocessor}{#endif  // EIGEN\_CXX11\_TENSOR\_TENSOR\_DEVICE\_SYCL\_H}
\end{DoxyCode}
