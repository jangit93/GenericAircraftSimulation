\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_c_u_d_a_2_half_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Core/arch/\+C\+U\+D\+A/\+Half.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_core_2arch_2_c_u_d_a_2_half_8h_source}\index{Half.\+h@{Half.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00005 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00006 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00007 \textcolor{comment}{//}
00008 \textcolor{comment}{// The conversion routines are Copyright (c) Fabian Giesen, 2016.}
00009 \textcolor{comment}{// The original license follows:}
00010 \textcolor{comment}{//}
00011 \textcolor{comment}{// Copyright (c) Fabian Giesen, 2016}
00012 \textcolor{comment}{// All rights reserved.}
00013 \textcolor{comment}{// Redistribution and use in source and binary forms, with or without}
00014 \textcolor{comment}{// modification, are permitted.}
00015 \textcolor{comment}{// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}
00016 \textcolor{comment}{// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}
00017 \textcolor{comment}{// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}
00018 \textcolor{comment}{// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}
00019 \textcolor{comment}{// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}
00020 \textcolor{comment}{// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}
00021 \textcolor{comment}{// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}
00022 \textcolor{comment}{// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}
00023 \textcolor{comment}{// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}
00024 \textcolor{comment}{// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}
00025 \textcolor{comment}{// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}
00026 
00027 
00028 \textcolor{comment}{// Standard 16-bit float type, mostly useful for GPUs. Defines a new}
00029 \textcolor{comment}{// type Eigen::half (inheriting from CUDA's \_\_half struct) with}
00030 \textcolor{comment}{// operator overloads such that it behaves basically as an arithmetic}
00031 \textcolor{comment}{// type. It will be quite slow on CPUs (so it is recommended to stay}
00032 \textcolor{comment}{// in fp32 for CPUs, except for simple parameter conversions, I/O}
00033 \textcolor{comment}{// to disk and the likes), but fast on GPUs.}
00034 
00035 
00036 \textcolor{preprocessor}{#ifndef EIGEN\_HALF\_CUDA\_H}
00037 \textcolor{preprocessor}{#define EIGEN\_HALF\_CUDA\_H}
00038 
00039 \textcolor{preprocessor}{#if \_\_cplusplus > 199711L}
00040 \textcolor{preprocessor}{#define EIGEN\_EXPLICIT\_CAST(tgt\_type) explicit operator tgt\_type()}
00041 \textcolor{preprocessor}{#else}
00042 \textcolor{preprocessor}{#define EIGEN\_EXPLICIT\_CAST(tgt\_type) operator tgt\_type()}
00043 \textcolor{preprocessor}{#endif}
00044 
00045 
00046 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00047 
00048 \textcolor{keyword}{struct }half;
00049 
00050 \textcolor{keyword}{namespace }half\_impl \{
00051 
00052 \textcolor{preprocessor}{#if !defined(EIGEN\_HAS\_CUDA\_FP16)}
00053 
00054 \textcolor{comment}{// Make our own \_\_half definition that is similar to CUDA's.}
00055 \textcolor{keyword}{struct }\_\_half \{
00056   EIGEN\_DEVICE\_FUNC \_\_half() \{\}
00057   \textcolor{keyword}{explicit} EIGEN\_DEVICE\_FUNC \_\_half(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} raw) : x(raw) \{\}
00058   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} x;
00059 \};
00060 
00061 \textcolor{preprocessor}{#endif}
00062 
00063 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \_\_half raw\_uint16\_to\_half(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} x);
00064 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \_\_half float\_to\_half\_rtne(\textcolor{keywordtype}{float} ff);
00065 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{float} half\_to\_float(\_\_half h);
00066 
00067 \textcolor{keyword}{struct }half\_base : \textcolor{keyword}{public} \_\_half \{
00068   EIGEN\_DEVICE\_FUNC half\_base() \{\}
00069   EIGEN\_DEVICE\_FUNC half\_base(\textcolor{keyword}{const} half\_base& h) : \_\_half(h) \{\}
00070   EIGEN\_DEVICE\_FUNC half\_base(\textcolor{keyword}{const} \_\_half& h) : \_\_half(h) \{\}
00071 \};
00072 
00073 \} \textcolor{comment}{// namespace half\_impl}
00074 
00075 \textcolor{comment}{// Class definition.}
00076 \textcolor{keyword}{struct }half : \textcolor{keyword}{public} half\_impl::half\_base \{
00077 \textcolor{preprocessor}{  #if !defined(EIGEN\_HAS\_CUDA\_FP16)}
00078     \textcolor{keyword}{typedef} half\_impl::\_\_half \_\_half;
00079 \textcolor{preprocessor}{  #endif}
00080 
00081   EIGEN\_DEVICE\_FUNC half() \{\}
00082 
00083   EIGEN\_DEVICE\_FUNC half(\textcolor{keyword}{const} \_\_half& h) : half\_impl::half\_base(h) \{\}
00084   EIGEN\_DEVICE\_FUNC half(\textcolor{keyword}{const} half& h) : half\_impl::half\_base(h) \{\}
00085 
00086   \textcolor{keyword}{explicit} EIGEN\_DEVICE\_FUNC half(\textcolor{keywordtype}{bool} b)
00087       : half\_impl::half\_base(half\_impl::raw\_uint16\_to\_half(b ? 0x3c00 : 0)) \{\}
00088   \textcolor{keyword}{template}<\textcolor{keyword}{class} T>
00089   \textcolor{keyword}{explicit} EIGEN\_DEVICE\_FUNC half(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_triplet}{T}& val)
00090       : half\_impl::half\_base(half\_impl::float\_to\_half\_rtne(static\_cast<float>(val))) \{\}
00091   \textcolor{keyword}{explicit} EIGEN\_DEVICE\_FUNC half(\textcolor{keywordtype}{float} f)
00092       : half\_impl::half\_base(half\_impl::float\_to\_half\_rtne(f)) \{\}
00093 
00094   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{bool})\textcolor{keyword}{ const }\{
00095     \textcolor{comment}{// +0.0 and -0.0 become false, everything else becomes true.}
00096     \textcolor{keywordflow}{return} (x & 0x7fff) != 0;
00097   \}
00098   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char})\textcolor{keyword}{ const }\{
00099     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(half\_impl::half\_to\_float(*\textcolor{keyword}{this}));
00100   \}
00101   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char})\textcolor{keyword}{ const }\{
00102     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(half\_impl::half\_to\_float(*\textcolor{keyword}{this}));
00103   \}
00104   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{short})\textcolor{keyword}{ const }\{
00105     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{short}\textcolor{keyword}{>}(half\_impl::half\_to\_float(*\textcolor{keyword}{this}));
00106   \}
00107   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short})\textcolor{keyword}{ const }\{
00108     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}\textcolor{keyword}{>}(half\_impl::half\_to\_float(*\textcolor{keyword}{this}));
00109   \}
00110   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{int})\textcolor{keyword}{ const }\{
00111     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(half\_impl::half\_to\_float(*\textcolor{keyword}{this}));
00112   \}
00113   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})\textcolor{keyword}{ const }\{
00114     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(half\_impl::half\_to\_float(*\textcolor{keyword}{this}));
00115   \}
00116   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{long})\textcolor{keyword}{ const }\{
00117     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long}\textcolor{keyword}{>}(half\_impl::half\_to\_float(*\textcolor{keyword}{this}));
00118   \}
00119   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})\textcolor{keyword}{ const }\{
00120     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(half\_impl::half\_to\_float(*\textcolor{keyword}{this}));
00121   \}
00122   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})\textcolor{keyword}{ const }\{
00123     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(half\_impl::half\_to\_float(*\textcolor{keyword}{this}));
00124   \}
00125   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long})\textcolor{keyword}{ const }\{
00126     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(half\_to\_float(*\textcolor{keyword}{this}));
00127   \}
00128   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{float})\textcolor{keyword}{ const }\{
00129     \textcolor{keywordflow}{return} half\_impl::half\_to\_float(*\textcolor{keyword}{this});
00130   \}
00131   EIGEN\_DEVICE\_FUNC EIGEN\_EXPLICIT\_CAST(\textcolor{keywordtype}{double})\textcolor{keyword}{ const }\{
00132     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(half\_impl::half\_to\_float(*\textcolor{keyword}{this}));
00133   \}
00134 
00135   EIGEN\_DEVICE\_FUNC half& operator=(\textcolor{keyword}{const} half& other) \{
00136     x = other.x;
00137     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00138   \}
00139 \};
00140 
00141 \textcolor{keyword}{namespace }half\_impl \{
00142 
00143 \textcolor{preprocessor}{#if defined(EIGEN\_HAS\_CUDA\_FP16) && defined(\_\_CUDA\_ARCH\_\_) && \_\_CUDA\_ARCH\_\_ >= 530}
00144 
00145 \textcolor{comment}{// Intrinsics for native fp16 support. Note that on current hardware,}
00146 \textcolor{comment}{// these are no faster than fp32 arithmetic (you need to use the half2}
00147 \textcolor{comment}{// versions to get the ALU speed increased), but you do save the}
00148 \textcolor{comment}{// conversion steps back and forth.}
00149 
00150 \_\_device\_\_ half operator + (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00151   \textcolor{keywordflow}{return} \_\_hadd(a, b);
00152 \}
00153 \_\_device\_\_ half \hyperlink{namespace_eigen_a32970f7eb62fe31eeefee72d24a046d0}{operator * }(\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00154   \textcolor{keywordflow}{return} \_\_hmul(a, b);
00155 \}
00156 \_\_device\_\_ half operator - (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00157   \textcolor{keywordflow}{return} \_\_hsub(a, b);
00158 \}
00159 \_\_device\_\_ half operator / (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00160   \textcolor{keywordtype}{float} num = \_\_half2float(a);
00161   \textcolor{keywordtype}{float} denom = \_\_half2float(b);
00162   \textcolor{keywordflow}{return} \_\_float2half(num / denom);
00163 \}
00164 \_\_device\_\_ half operator - (\textcolor{keyword}{const} half& a) \{
00165   \textcolor{keywordflow}{return} \_\_hneg(a);
00166 \}
00167 \_\_device\_\_ half& operator += (half& a, \textcolor{keyword}{const} half& b) \{
00168   a = a + b;
00169   \textcolor{keywordflow}{return} a;
00170 \}
00171 \_\_device\_\_ half& operator *= (half& a, \textcolor{keyword}{const} half& b) \{
00172   a = a * b;
00173   \textcolor{keywordflow}{return} a;
00174 \}
00175 \_\_device\_\_ half& operator -= (half& a, \textcolor{keyword}{const} half& b) \{
00176   a = a - b;
00177   \textcolor{keywordflow}{return} a;
00178 \}
00179 \_\_device\_\_ half& operator /= (half& a, \textcolor{keyword}{const} half& b) \{
00180   a = a / b;
00181   \textcolor{keywordflow}{return} a;
00182 \}
00183 \_\_device\_\_ \textcolor{keywordtype}{bool} operator == (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00184   \textcolor{keywordflow}{return} \_\_heq(a, b);
00185 \}
00186 \_\_device\_\_ \textcolor{keywordtype}{bool} operator != (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00187   \textcolor{keywordflow}{return} \_\_hne(a, b);
00188 \}
00189 \_\_device\_\_ \textcolor{keywordtype}{bool} operator < (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00190   \textcolor{keywordflow}{return} \_\_hlt(a, b);
00191 \}
00192 \_\_device\_\_ \textcolor{keywordtype}{bool} operator <= (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00193   \textcolor{keywordflow}{return} \_\_hle(a, b);
00194 \}
00195 \_\_device\_\_ \textcolor{keywordtype}{bool} operator > (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00196   \textcolor{keywordflow}{return} \_\_hgt(a, b);
00197 \}
00198 \_\_device\_\_ \textcolor{keywordtype}{bool} operator >= (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00199   \textcolor{keywordflow}{return} \_\_hge(a, b);
00200 \}
00201 
00202 \textcolor{preprocessor}{#else  // Emulate support for half floats}
00203 
00204 \textcolor{comment}{// Definitions for CPUs and older CUDA, mostly working through conversion}
00205 \textcolor{comment}{// to/from fp32.}
00206 
00207 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half operator + (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00208   \textcolor{keywordflow}{return} half(\textcolor{keywordtype}{float}(a) + \textcolor{keywordtype}{float}(b));
00209 \}
00210 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half \hyperlink{namespace_eigen_a32970f7eb62fe31eeefee72d24a046d0}{operator * }(\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00211   \textcolor{keywordflow}{return} half(\textcolor{keywordtype}{float}(a) * \textcolor{keywordtype}{float}(b));
00212 \}
00213 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half operator - (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00214   \textcolor{keywordflow}{return} half(\textcolor{keywordtype}{float}(a) - \textcolor{keywordtype}{float}(b));
00215 \}
00216 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half operator / (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00217   \textcolor{keywordflow}{return} half(\textcolor{keywordtype}{float}(a) / \textcolor{keywordtype}{float}(b));
00218 \}
00219 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half operator - (\textcolor{keyword}{const} half& a) \{
00220   half result;
00221   result.x = a.x ^ 0x8000;
00222   \textcolor{keywordflow}{return} result;
00223 \}
00224 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half& operator += (half& a, \textcolor{keyword}{const} half& b) \{
00225   a = half(\textcolor{keywordtype}{float}(a) + \textcolor{keywordtype}{float}(b));
00226   \textcolor{keywordflow}{return} a;
00227 \}
00228 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half& operator *= (half& a, \textcolor{keyword}{const} half& b) \{
00229   a = half(\textcolor{keywordtype}{float}(a) * \textcolor{keywordtype}{float}(b));
00230   \textcolor{keywordflow}{return} a;
00231 \}
00232 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half& operator -= (half& a, \textcolor{keyword}{const} half& b) \{
00233   a = half(\textcolor{keywordtype}{float}(a) - \textcolor{keywordtype}{float}(b));
00234   \textcolor{keywordflow}{return} a;
00235 \}
00236 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half& operator /= (half& a, \textcolor{keyword}{const} half& b) \{
00237   a = half(\textcolor{keywordtype}{float}(a) / \textcolor{keywordtype}{float}(b));
00238   \textcolor{keywordflow}{return} a;
00239 \}
00240 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{bool} operator == (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00241   \textcolor{keywordflow}{return} float(a) == float(b);
00242 \}
00243 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{bool} operator != (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00244   \textcolor{keywordflow}{return} float(a) != float(b);
00245 \}
00246 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{bool} operator < (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00247   \textcolor{keywordflow}{return} float(a) < float(b);
00248 \}
00249 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{bool} operator <= (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00250   \textcolor{keywordflow}{return} float(a) <= float(b);
00251 \}
00252 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{bool} operator > (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00253   \textcolor{keywordflow}{return} float(a) > float(b);
00254 \}
00255 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{bool} operator >= (\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00256   \textcolor{keywordflow}{return} float(a) >= float(b);
00257 \}
00258 
00259 \textcolor{preprocessor}{#endif  // Emulate support for half floats}
00260 
00261 \textcolor{comment}{// Division by an index. Do it in full float precision to avoid accuracy}
00262 \textcolor{comment}{// issues in converting the denominator to half.}
00263 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half operator / (\textcolor{keyword}{const} half& a, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} b) \{
00264   \textcolor{keywordflow}{return} half(static\_cast<float>(a) / static\_cast<float>(b));
00265 \}
00266 
00267 \textcolor{comment}{// Conversion routines, including fallbacks for the host or older CUDA.}
00268 \textcolor{comment}{// Note that newer Intel CPUs (Haswell or newer) have vectorized versions of}
00269 \textcolor{comment}{// these in hardware. If we need more performance on older/other CPUs, they are}
00270 \textcolor{comment}{// also possible to vectorize directly.}
00271 
00272 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \_\_half raw\_uint16\_to\_half(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} x) \{
00273   \_\_half h;
00274   h.x = x;
00275   \textcolor{keywordflow}{return} h;
00276 \}
00277 
00278 \textcolor{keyword}{union }FP32 \{
00279   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} u;
00280   \textcolor{keywordtype}{float} f;
00281 \};
00282 
00283 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \_\_half float\_to\_half\_rtne(\textcolor{keywordtype}{float} ff) \{
00284 \textcolor{preprocessor}{#if defined(EIGEN\_HAS\_CUDA\_FP16) && defined(\_\_CUDA\_ARCH\_\_) && \_\_CUDA\_ARCH\_\_ >= 300}
00285   \textcolor{keywordflow}{return} \_\_float2half(ff);
00286 
00287 \textcolor{preprocessor}{#elif defined(EIGEN\_HAS\_FP16\_C)}
00288   \_\_half h;
00289   h.x = \_cvtss\_sh(ff, 0);
00290   \textcolor{keywordflow}{return} h;
00291 
00292 \textcolor{preprocessor}{#else}
00293   FP32 f; f.f = ff;
00294 
00295   \textcolor{keyword}{const} FP32 f32infty = \{ 255 << 23 \};
00296   \textcolor{keyword}{const} FP32 f16max = \{ (127 + 16) << 23 \};
00297   \textcolor{keyword}{const} FP32 denorm\_magic = \{ ((127 - 15) + (23 - 10) + 1) << 23 \};
00298   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sign\_mask = 0x80000000u;
00299   \_\_half o;
00300   o.x = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}\textcolor{keyword}{>}(0x0u);
00301 
00302   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sign = f.u & sign\_mask;
00303   f.u ^= sign;
00304 
00305   \textcolor{comment}{// NOTE all the integer compares in this function can be safely}
00306   \textcolor{comment}{// compiled into signed compares since all operands are below}
00307   \textcolor{comment}{// 0x80000000. Important if you want fast straight SSE2 code}
00308   \textcolor{comment}{// (since there's no unsigned PCMPGTD).}
00309 
00310   \textcolor{keywordflow}{if} (f.u >= f16max.u) \{  \textcolor{comment}{// result is Inf or NaN (all exponent bits set)}
00311     o.x = (f.u > f32infty.u) ? 0x7e00 : 0x7c00; \textcolor{comment}{// NaN->qNaN and Inf->Inf}
00312   \} \textcolor{keywordflow}{else} \{  \textcolor{comment}{// (De)normalized number or zero}
00313     \textcolor{keywordflow}{if} (f.u < (113 << 23)) \{  \textcolor{comment}{// resulting FP16 is subnormal or zero}
00314       \textcolor{comment}{// use a magic value to align our 10 mantissa bits at the bottom of}
00315       \textcolor{comment}{// the float. as long as FP addition is round-to-nearest-even this}
00316       \textcolor{comment}{// just works.}
00317       f.f += denorm\_magic.f;
00318 
00319       \textcolor{comment}{// and one integer subtract of the bias later, we have our final float!}
00320       o.x = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}\textcolor{keyword}{>}(f.u - denorm\_magic.u);
00321     \} \textcolor{keywordflow}{else} \{
00322       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mant\_odd = (f.u >> 13) & 1; \textcolor{comment}{// resulting mantissa is odd}
00323 
00324       \textcolor{comment}{// update exponent, rounding bias part 1}
00325       f.u += ((\textcolor{keywordtype}{unsigned} int)(15 - 127) << 23) + 0xfff;
00326       \textcolor{comment}{// rounding bias part 2}
00327       f.u += mant\_odd;
00328       \textcolor{comment}{// take the bits!}
00329       o.x = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}\textcolor{keyword}{>}(f.u >> 13);
00330     \}
00331   \}
00332 
00333   o.x |= \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}\textcolor{keyword}{>}(sign >> 16);
00334   \textcolor{keywordflow}{return} o;
00335 \textcolor{preprocessor}{#endif}
00336 \}
00337 
00338 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \textcolor{keywordtype}{float} half\_to\_float(\_\_half h) \{
00339 \textcolor{preprocessor}{#if defined(EIGEN\_HAS\_CUDA\_FP16) && defined(\_\_CUDA\_ARCH\_\_) && \_\_CUDA\_ARCH\_\_ >= 300}
00340   \textcolor{keywordflow}{return} \_\_half2float(h);
00341 
00342 \textcolor{preprocessor}{#elif defined(EIGEN\_HAS\_FP16\_C)}
00343   \textcolor{keywordflow}{return} \_cvtsh\_ss(h.x);
00344 
00345 \textcolor{preprocessor}{#else}
00346   \textcolor{keyword}{const} FP32 magic = \{ 113 << 23 \};
00347   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} shifted\_exp = 0x7c00 << 13; \textcolor{comment}{// exponent mask after shift}
00348   FP32 o;
00349 
00350   o.u = (h.x & 0x7fff) << 13;             \textcolor{comment}{// exponent/mantissa bits}
00351   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} exp = shifted\_exp & o.u;   \textcolor{comment}{// just the exponent}
00352   o.u += (127 - 15) << 23;                \textcolor{comment}{// exponent adjust}
00353 
00354   \textcolor{comment}{// handle exponent special cases}
00355   \textcolor{keywordflow}{if} (exp == shifted\_exp) \{     \textcolor{comment}{// Inf/NaN?}
00356     o.u += (128 - 16) << 23;    \textcolor{comment}{// extra exp adjust}
00357   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (exp == 0) \{        \textcolor{comment}{// Zero/Denormal?}
00358     o.u += 1 << 23;             \textcolor{comment}{// extra exp adjust}
00359     o.f -= magic.f;             \textcolor{comment}{// renormalize}
00360   \}
00361 
00362   o.u |= (h.x & 0x8000) << 16;    \textcolor{comment}{// sign bit}
00363   \textcolor{keywordflow}{return} o.f;
00364 \textcolor{preprocessor}{#endif}
00365 \}
00366 
00367 \textcolor{comment}{// --- standard functions ---}
00368 
00369 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC bool (isinf)(\textcolor{keyword}{const} half& a) \{
00370   \textcolor{keywordflow}{return} (a.x & 0x7fff) == 0x7c00;
00371 \}
00372 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC bool (isnan)(\textcolor{keyword}{const} half& a) \{
00373 \textcolor{preprocessor}{#if defined(EIGEN\_HAS\_CUDA\_FP16) && defined(\_\_CUDA\_ARCH\_\_) && \_\_CUDA\_ARCH\_\_ >= 530}
00374   \textcolor{keywordflow}{return} \_\_hisnan(a);
00375 \textcolor{preprocessor}{#else}
00376   \textcolor{keywordflow}{return} (a.x & 0x7fff) > 0x7c00;
00377 \textcolor{preprocessor}{#endif}
00378 \}
00379 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC bool (isfinite)(\textcolor{keyword}{const} half& a) \{
00380   \textcolor{keywordflow}{return} !(isinf EIGEN\_NOT\_A\_MACRO (a)) && !(isnan EIGEN\_NOT\_A\_MACRO (a));
00381 \}
00382 
00383 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half abs(\textcolor{keyword}{const} half& a) \{
00384   half result;
00385   result.x = a.x & 0x7FFF;
00386   \textcolor{keywordflow}{return} result;
00387 \}
00388 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half exp(\textcolor{keyword}{const} half& a) \{
00389   \textcolor{keywordflow}{return} half(::expf(\textcolor{keywordtype}{float}(a)));
00390 \}
00391 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half \hyperlink{structlog}{log}(\textcolor{keyword}{const} half& a) \{
00392 \textcolor{preprocessor}{#if defined(EIGEN\_HAS\_CUDA\_FP16) && defined \_\_CUDACC\_VER\_\_ && \_\_CUDACC\_VER\_\_ >= 80000 &&
       defined(\_\_CUDA\_ARCH\_\_) && \_\_CUDA\_ARCH\_\_ >= 530}
00393   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(::hlog(a));
00394 \textcolor{preprocessor}{#else}
00395   \textcolor{keywordflow}{return} half(::logf(\textcolor{keywordtype}{float}(a)));
00396 \textcolor{preprocessor}{#endif}
00397 \}
00398 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half log1p(\textcolor{keyword}{const} half& a) \{
00399   \textcolor{keywordflow}{return} half(numext::log1p(\textcolor{keywordtype}{float}(a)));
00400 \}
00401 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half log10(\textcolor{keyword}{const} half& a) \{
00402   \textcolor{keywordflow}{return} half(::log10f(\textcolor{keywordtype}{float}(a)));
00403 \}
00404 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half sqrt(\textcolor{keyword}{const} half& a) \{
00405   \textcolor{keywordflow}{return} half(::sqrtf(\textcolor{keywordtype}{float}(a)));
00406 \}
00407 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half pow(\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00408   \textcolor{keywordflow}{return} half(::powf(\textcolor{keywordtype}{float}(a), \textcolor{keywordtype}{float}(b)));
00409 \}
00410 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half sin(\textcolor{keyword}{const} half& a) \{
00411   \textcolor{keywordflow}{return} half(::sinf(\textcolor{keywordtype}{float}(a)));
00412 \}
00413 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half cos(\textcolor{keyword}{const} half& a) \{
00414   \textcolor{keywordflow}{return} half(::cosf(\textcolor{keywordtype}{float}(a)));
00415 \}
00416 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half tan(\textcolor{keyword}{const} half& a) \{
00417   \textcolor{keywordflow}{return} half(::tanf(\textcolor{keywordtype}{float}(a)));
00418 \}
00419 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half tanh(\textcolor{keyword}{const} half& a) \{
00420   \textcolor{keywordflow}{return} half(::tanhf(\textcolor{keywordtype}{float}(a)));
00421 \}
00422 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half floor(\textcolor{keyword}{const} half& a) \{
00423   \textcolor{keywordflow}{return} half(::floorf(\textcolor{keywordtype}{float}(a)));
00424 \}
00425 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half ceil(\textcolor{keyword}{const} half& a) \{
00426   \textcolor{keywordflow}{return} half(::ceilf(\textcolor{keywordtype}{float}(a)));
00427 \}
00428 
00429 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half (min)(\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00430 \textcolor{preprocessor}{#if defined(EIGEN\_HAS\_CUDA\_FP16) && defined(\_\_CUDA\_ARCH\_\_) && \_\_CUDA\_ARCH\_\_ >= 530}
00431   \textcolor{keywordflow}{return} \_\_hlt(b, a) ? b : a;
00432 \textcolor{preprocessor}{#else}
00433   \textcolor{keyword}{const} \textcolor{keywordtype}{float} f1 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(a);
00434   \textcolor{keyword}{const} \textcolor{keywordtype}{float} f2 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(b);
00435   \textcolor{keywordflow}{return} f2 < f1 ? b : a;
00436 \textcolor{preprocessor}{#endif}
00437 \}
00438 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC half (max)(\textcolor{keyword}{const} half& a, \textcolor{keyword}{const} half& b) \{
00439 \textcolor{preprocessor}{#if defined(EIGEN\_HAS\_CUDA\_FP16) && defined(\_\_CUDA\_ARCH\_\_) && \_\_CUDA\_ARCH\_\_ >= 530}
00440   \textcolor{keywordflow}{return} \_\_hlt(a, b) ? b : a;
00441 \textcolor{preprocessor}{#else}
00442   \textcolor{keyword}{const} \textcolor{keywordtype}{float} f1 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(a);
00443   \textcolor{keyword}{const} \textcolor{keywordtype}{float} f2 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(b);
00444   \textcolor{keywordflow}{return} f1 < f2 ? b : a;
00445 \textcolor{preprocessor}{#endif}
00446 \}
00447 
00448 EIGEN\_ALWAYS\_INLINE std::ostream& operator << (std::ostream& os, \textcolor{keyword}{const} half& v) \{
00449   os << static\_cast<float>(v);
00450   \textcolor{keywordflow}{return} os;
00451 \}
00452 
00453 \} \textcolor{comment}{// end namespace half\_impl}
00454 
00455 \textcolor{comment}{// import Eigen::half\_impl::half into Eigen namespace}
00456 \textcolor{comment}{// using half\_impl::half;}
00457 
00458 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00459 
00460 \textcolor{keyword}{template}<>
00461 \textcolor{keyword}{struct }random\_default\_impl<half, false, false>
00462 \{
00463   \textcolor{keyword}{static} \textcolor{keyword}{inline} half run(\textcolor{keyword}{const} half& x, \textcolor{keyword}{const} half& y)
00464   \{
00465     \textcolor{keywordflow}{return} x + (y-x) * half(\textcolor{keywordtype}{float}(std::rand()) / float(RAND\_MAX));
00466   \}
00467   \textcolor{keyword}{static} \textcolor{keyword}{inline} half run()
00468   \{
00469     \textcolor{keywordflow}{return} run(half(-1.f), half(1.f));
00470   \}
00471 \};
00472 
00473 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }is\_arithmetic<half> \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};
00474 
00475 \} \textcolor{comment}{// end namespace internal}
00476 
00477 \}  \textcolor{comment}{// end namespace Eigen}
00478 
00479 \textcolor{keyword}{namespace }\hyperlink{namespacestd}{std} \{
00480 \textcolor{keyword}{template}<>
00481 \textcolor{keyword}{struct }numeric\_limits<\hyperlink{namespace_eigen}{Eigen}::half> \{
00482   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_specialized = \textcolor{keyword}{true};
00483   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_signed = \textcolor{keyword}{true};
00484   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_integer = \textcolor{keyword}{false};
00485   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_exact = \textcolor{keyword}{false};
00486   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} has\_infinity = \textcolor{keyword}{true};
00487   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} has\_quiet\_NaN = \textcolor{keyword}{true};
00488   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} has\_signaling\_NaN = \textcolor{keyword}{true};
00489   \textcolor{keyword}{static} \textcolor{keyword}{const} float\_denorm\_style has\_denorm = denorm\_present;
00490   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} has\_denorm\_loss = \textcolor{keyword}{false};
00491   \textcolor{keyword}{static} \textcolor{keyword}{const} std::float\_round\_style round\_style = std::round\_to\_nearest;
00492   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_iec559 = \textcolor{keyword}{false};
00493   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_bounded = \textcolor{keyword}{false};
00494   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_modulo = \textcolor{keyword}{false};
00495   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} digits = 11;
00496   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} digits10 = 2;
00497   \textcolor{comment}{//static const int max\_digits10 = ;}
00498   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} radix = 2;
00499   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} min\_exponent = -13;
00500   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} min\_exponent10 = -4;
00501   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_exponent = 16;
00502   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_exponent10 = 4;
00503   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} traps = \textcolor{keyword}{true};
00504   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} tinyness\_before = \textcolor{keyword}{false};
00505 
00506   \textcolor{keyword}{static} \hyperlink{struct_eigen_1_1half}{Eigen::half} (min)() \{ \textcolor{keywordflow}{return} Eigen::half\_impl::raw\_uint16\_to\_half(0x400); \}
00507   \textcolor{keyword}{static} \hyperlink{struct_eigen_1_1half}{Eigen::half} lowest() \{ \textcolor{keywordflow}{return} Eigen::half\_impl::raw\_uint16\_to\_half(0xfbff); \}
00508   \textcolor{keyword}{static} \hyperlink{struct_eigen_1_1half}{Eigen::half} (max)() \{ \textcolor{keywordflow}{return} Eigen::half\_impl::raw\_uint16\_to\_half(0x7bff); \}
00509   \textcolor{keyword}{static} \hyperlink{struct_eigen_1_1half}{Eigen::half} epsilon() \{ \textcolor{keywordflow}{return} Eigen::half\_impl::raw\_uint16\_to\_half(0x0800); \}
00510   \textcolor{keyword}{static} \hyperlink{struct_eigen_1_1half}{Eigen::half} round\_error() \{ \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(0.5); \}
00511   \textcolor{keyword}{static} \hyperlink{struct_eigen_1_1half}{Eigen::half} infinity() \{ \textcolor{keywordflow}{return} Eigen::half\_impl::raw\_uint16\_to\_half(0x7c00); \}
00512   \textcolor{keyword}{static} \hyperlink{struct_eigen_1_1half}{Eigen::half} quiet\_NaN() \{ \textcolor{keywordflow}{return} Eigen::half\_impl::raw\_uint16\_to\_half(0x7e00); \}
00513   \textcolor{keyword}{static} \hyperlink{struct_eigen_1_1half}{Eigen::half} signaling\_NaN() \{ \textcolor{keywordflow}{return} Eigen::half\_impl::raw\_uint16\_to\_half(0x7e00); \}
00514   \textcolor{keyword}{static} \hyperlink{struct_eigen_1_1half}{Eigen::half} denorm\_min() \{ \textcolor{keywordflow}{return} Eigen::half\_impl::raw\_uint16\_to\_half(0x1); \}
00515 \};
00516 \}
00517 
00518 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00519 
00520 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }NumTraits<\hyperlink{namespace_eigen}{Eigen}::half>
00521     : GenericNumTraits<Eigen::half>
00522 \{
00523   \textcolor{keyword}{enum} \{
00524     IsSigned = \textcolor{keyword}{true},
00525     IsInteger = \textcolor{keyword}{false},
00526     IsComplex = \textcolor{keyword}{false},
00527     RequireInitialization = \textcolor{keyword}{false}
00528   \};
00529 
00530   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} epsilon() \{
00531     \textcolor{keywordflow}{return} half\_impl::raw\_uint16\_to\_half(0x0800);
00532   \}
00533   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} dummy\_precision() \{ \textcolor{keywordflow}{return} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}(1e-2f); \}
00534   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} highest() \{
00535     \textcolor{keywordflow}{return} half\_impl::raw\_uint16\_to\_half(0x7bff);
00536   \}
00537   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} lowest() \{
00538     \textcolor{keywordflow}{return} half\_impl::raw\_uint16\_to\_half(0xfbff);
00539   \}
00540   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} infinity() \{
00541     \textcolor{keywordflow}{return} half\_impl::raw\_uint16\_to\_half(0x7c00);
00542   \}
00543   EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} quiet\_NaN() \{
00544     \textcolor{keywordflow}{return} half\_impl::raw\_uint16\_to\_half(0x7c01);
00545   \}
00546 \};
00547 
00548 \} \textcolor{comment}{// end namespace Eigen}
00549 
00550 \textcolor{comment}{// C-like standard mathematical functions and trancendentals.}
00551 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \hyperlink{struct_eigen_1_1half}{Eigen::half} fabsh(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}& a) \{
00552   \hyperlink{struct_eigen_1_1half}{Eigen::half} result;
00553   result.x = a.x & 0x7FFF;
00554   \textcolor{keywordflow}{return} result;
00555 \}
00556 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \hyperlink{struct_eigen_1_1half}{Eigen::half} exph(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}& a) \{
00557   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(::expf(\textcolor{keywordtype}{float}(a)));
00558 \}
00559 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \hyperlink{struct_eigen_1_1half}{Eigen::half} logh(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}& a) \{
00560 \textcolor{preprocessor}{#if defined \_\_CUDACC\_VER\_\_ && \_\_CUDACC\_VER\_\_ >= 80000 && defined(\_\_CUDA\_ARCH\_\_) && \_\_CUDA\_ARCH\_\_ >= 530}
00561   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(::hlog(a));
00562 \textcolor{preprocessor}{#else}
00563   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(::logf(\textcolor{keywordtype}{float}(a)));
00564 \textcolor{preprocessor}{#endif}
00565 \}
00566 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \hyperlink{struct_eigen_1_1half}{Eigen::half} sqrth(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}& a) \{
00567   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(::sqrtf(\textcolor{keywordtype}{float}(a)));
00568 \}
00569 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \hyperlink{struct_eigen_1_1half}{Eigen::half} powh(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}& a, \textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}& b) \{
00570   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(::powf(\textcolor{keywordtype}{float}(a), \textcolor{keywordtype}{float}(b)));
00571 \}
00572 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \hyperlink{struct_eigen_1_1half}{Eigen::half} floorh(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}& a) \{
00573   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(::floorf(\textcolor{keywordtype}{float}(a)));
00574 \}
00575 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \hyperlink{struct_eigen_1_1half}{Eigen::half} ceilh(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}& a) \{
00576   \textcolor{keywordflow}{return} \hyperlink{struct_eigen_1_1half}{Eigen::half}(::ceilf(\textcolor{keywordtype}{float}(a)));
00577 \}
00578 
00579 \textcolor{keyword}{namespace }\hyperlink{namespacestd}{std} \{
00580 
00581 \textcolor{preprocessor}{#if \_\_cplusplus > 199711L}
00582 \textcolor{keyword}{template} <>
00583 \textcolor{keyword}{struct }hash<\hyperlink{namespace_eigen}{Eigen}::half> \{
00584   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE std::size\_t operator()(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}& a)\textcolor{keyword}{ const }\{
00585     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(a.x);
00586   \}
00587 \};
00588 \textcolor{preprocessor}{#endif}
00589 
00590 \} \textcolor{comment}{// end namespace std}
00591 
00592 
00593 \textcolor{comment}{// Add the missing shfl\_xor intrinsic}
00594 \textcolor{preprocessor}{#if defined(\_\_CUDA\_ARCH\_\_) && \_\_CUDA\_ARCH\_\_ >= 300}
00595 \_\_device\_\_ EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1half}{Eigen::half} \_\_shfl\_xor(\hyperlink{struct_eigen_1_1half}{Eigen::half} var, \textcolor{keywordtype}{int} laneMask, \textcolor{keywordtype}{
      int} width=warpSize) \{
00596   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\hyperlink{struct_eigen_1_1half}{Eigen::half}\textcolor{keyword}{>}(\_\_shfl\_xor(static\_cast<float>(var), laneMask, width));
00597 \}
00598 \textcolor{preprocessor}{#endif}
00599 
00600 \textcolor{comment}{// ldg() has an overload for \_\_half, but we also need one for Eigen::half.}
00601 \textcolor{preprocessor}{#if defined(\_\_CUDA\_ARCH\_\_) && \_\_CUDA\_ARCH\_\_ >= 350}
00602 EIGEN\_STRONG\_INLINE EIGEN\_DEVICE\_FUNC \hyperlink{struct_eigen_1_1half}{Eigen::half} \_\_ldg(\textcolor{keyword}{const} 
      \hyperlink{struct_eigen_1_1half}{Eigen::half}* ptr) \{
00603   \textcolor{keywordflow}{return} Eigen::half\_impl::raw\_uint16\_to\_half(
00604       \_\_ldg(reinterpret\_cast<const unsigned short*>(ptr)));
00605 \}
00606 \textcolor{preprocessor}{#endif}
00607 
00608 
00609 \textcolor{preprocessor}{#if defined(\_\_CUDA\_ARCH\_\_)}
00610 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00611 \textcolor{keyword}{namespace }numext \{
00612 
00613 \textcolor{keyword}{template}<>
00614 EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE
00615 bool (isnan)(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}& h) \{
00616   \textcolor{keywordflow}{return} (half\_impl::isnan)(h);
00617 \}
00618 
00619 \textcolor{keyword}{template}<>
00620 EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE
00621 bool (isinf)(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}& h) \{
00622   \textcolor{keywordflow}{return} (half\_impl::isinf)(h);
00623 \}
00624 
00625 \textcolor{keyword}{template}<>
00626 EIGEN\_DEVICE\_FUNC EIGEN\_ALWAYS\_INLINE
00627 bool (isfinite)(\textcolor{keyword}{const} \hyperlink{struct_eigen_1_1half}{Eigen::half}& h) \{
00628   \textcolor{keywordflow}{return} (half\_impl::isfinite)(h);
00629 \}
00630 
00631 \} \textcolor{comment}{// namespace Eigen}
00632 \}  \textcolor{comment}{// namespace numext}
00633 \textcolor{preprocessor}{#endif}
00634 
00635 \textcolor{preprocessor}{#endif // EIGEN\_HALF\_CUDA\_H}
\end{DoxyCode}
