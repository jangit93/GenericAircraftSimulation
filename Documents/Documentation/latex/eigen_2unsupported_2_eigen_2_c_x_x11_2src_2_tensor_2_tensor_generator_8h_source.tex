\hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_generator_8h_source}{}\section{eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Generator.h}
\label{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_generator_8h_source}\index{Tensor\+Generator.\+h@{Tensor\+Generator.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2015 Benoit Steiner <benoit.steiner.goog@gmail.com>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_CXX11\_TENSOR\_TENSOR\_GENERATOR\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_CXX11\_TENSOR\_TENSOR\_GENERATOR\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{
00014 
00022 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00023 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Generator, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_generator_8h_source_l00024}\hyperlink{struct_eigen_1_1internal_1_1traits_3_01_tensor_generator_op_3_01_generator_00_01_xpr_type_01_4_01_4}{00024} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<\hyperlink{class_eigen_1_1_tensor_generator_op}{TensorGeneratorOp}<Generator, XprType> > : \textcolor{keyword}{public} 
      \hyperlink{struct_eigen_1_1internal_1_1traits}{traits}<XprType>
00025 \{
00026   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00027   \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1traits}{traits<XprType>} \hyperlink{struct_eigen_1_1internal_1_1traits}{XprTraits};
00028   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::StorageKind StorageKind;
00029   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprTraits::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00030   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Nested Nested;
00031   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{remove\_reference<Nested>::type} 
      \hyperlink{group___sparse_core___module}{\_Nested};
00032   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDimensions = XprTraits::NumDimensions;
00033   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} Layout = XprTraits::Layout;
00034 \};
00035 
00036 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Generator, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_generator_8h_source_l00037}\hyperlink{struct_eigen_1_1internal_1_1eval_3_01_tensor_generator_op_3_01_generator_00_01_xpr_type_01_4_00_01_eigen_1_1_dense_01_4}{00037} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_generator_op}{TensorGeneratorOp}<Generator, XprType>, \hyperlink{namespace_eigen}{Eigen}::
      \hyperlink{struct_eigen_1_1_dense}{Dense}>
00038 \{
00039   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \hyperlink{class_eigen_1_1_tensor_generator_op}{TensorGeneratorOp<Generator, XprType>}& 
      \hyperlink{class_eigen_1_1_tensor_generator_op}{type};
00040 \};
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Generator, \textcolor{keyword}{typename} XprType>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_generator_8h_source_l00043}\hyperlink{struct_eigen_1_1internal_1_1nested_3_01_tensor_generator_op_3_01_generator_00_01_xpr_type_01_4_0384769220adcc2cd0a85c8ada993f368}{00043} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1internal_1_1nested}{nested}<\hyperlink{class_eigen_1_1_tensor_generator_op}{TensorGeneratorOp}<Generator, XprType>, 1, typename 
      \hyperlink{struct_eigen_1_1internal_1_1eval}{eval}<\hyperlink{class_eigen_1_1_tensor_generator_op}{TensorGeneratorOp}<Generator, XprType> >::\hyperlink{class_eigen_1_1_tensor_generator_op}{type}>
00044 \{
00045   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_generator_op}{TensorGeneratorOp<Generator, XprType>} 
      \hyperlink{class_eigen_1_1_tensor_generator_op}{type};
00046 \};
00047 
00048 \}  \textcolor{comment}{// end namespace internal}
00049 
00050 
00051 
00052 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Generator, \textcolor{keyword}{typename} XprType>
00053 \textcolor{keyword}{class }\hyperlink{class_eigen_1_1_tensor_generator_op}{TensorGeneratorOp} : \textcolor{keyword}{public} \hyperlink{class_eigen_1_1_tensor_base}{TensorBase}<TensorGeneratorOp<Generator, XprType
      >, ReadOnlyAccessors>
00054 \{
00055   \textcolor{keyword}{public}:
00056   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorGeneratorOp>::Scalar}
       Scalar;
00057   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{Eigen::NumTraits<Scalar>::Real} RealScalar;
00058   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00059   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{class_eigen_1_1internal_1_1_tensor_lazy_evaluator_writable}{Eigen::internal::nested<TensorGeneratorOp>::type}
       Nested;
00060   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorGeneratorOp>::StorageKind}
       StorageKind;
00061   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1internal_1_1traits}{Eigen::internal::traits<TensorGeneratorOp>::Index}
       \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00062 
00063   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_generator_op}{TensorGeneratorOp}(\textcolor{keyword}{const} XprType& expr, \textcolor{keyword}{const} 
      Generator& generator)
00064       : m\_xpr(expr), m\_generator(generator) \{\}
00065 
00066     EIGEN\_DEVICE\_FUNC
00067     \textcolor{keyword}{const} Generator& generator()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_generator; \}
00068 
00069     EIGEN\_DEVICE\_FUNC
00070     \textcolor{keyword}{const} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<typename XprType::Nested>::type}
      &
00071     expression()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_xpr; \}
00072 
00073   \textcolor{keyword}{protected}:
00074     \textcolor{keyword}{typename} XprType::Nested m\_xpr;
00075     \textcolor{keyword}{const} Generator m\_generator;
00076 \};
00077 
00078 
00079 \textcolor{comment}{// Eval as rvalue}
00080 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Generator, \textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} Device>
\Hypertarget{eigen_2unsupported_2_eigen_2_c_x_x11_2src_2_tensor_2_tensor_generator_8h_source_l00081}\hyperlink{struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_generator_op_3_01_generator_00_01_arg_type_01_4_00_01_device_01_4}{00081} \textcolor{keyword}{struct }\hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}<const \hyperlink{class_eigen_1_1_tensor_generator_op}{TensorGeneratorOp}<Generator, ArgType>, Device>
00082 \{
00083   \textcolor{keyword}{typedef} \hyperlink{class_eigen_1_1_tensor_generator_op}{TensorGeneratorOp<Generator, ArgType>} 
      \hyperlink{class_eigen_1_1_tensor_generator_op}{XprType};
00084   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Index \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index};
00085   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Dimensions}
       Dimensions;
00086   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} NumDims = \hyperlink{struct_eigen_1_1internal_1_1array__size}{internal::array\_size<Dimensions>::value}
      ;
00087   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar Scalar;
00088   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::CoeffReturnType CoeffReturnType;
00089   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{PacketType<CoeffReturnType, Device>::type} 
      \hyperlink{group___sparse_core___module}{PacketReturnType};
00090   \textcolor{keyword}{enum} \{
00091     IsAligned = \textcolor{keyword}{false},
00092     PacketAccess = (\hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size}
       > 1),
00093     BlockAccess = \textcolor{keyword}{false},
00094     Layout = \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>::Layout},
00095     CoordAccess = \textcolor{keyword}{false},  \textcolor{comment}{// to be implemented}
00096     RawAccess = \textcolor{keyword}{false}
00097   \};
00098 
00099   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator}(\textcolor{keyword}{const} XprType& op, \textcolor{keyword}{const} Device& 
      device)
00100       : m\_generator(op.generator())
00101   \{
00102     \hyperlink{struct_eigen_1_1_tensor_evaluator}{TensorEvaluator<ArgType, Device>} impl(op.expression(), device);
00103     m\_dimensions = impl.dimensions();
00104 
00105     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00106       m\_strides[0] = 1;
00107       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < NumDims; ++i) \{
00108         m\_strides[i] = m\_strides[i - 1] * m\_dimensions[i - 1];
00109       \}
00110     \} \textcolor{keywordflow}{else} \{
00111       m\_strides[NumDims - 1] = 1;
00112       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 2; i >= 0; --i) \{
00113         m\_strides[i] = m\_strides[i + 1] * m\_dimensions[i + 1];
00114       \}
00115     \}
00116   \}
00117 
00118   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{const} Dimensions& dimensions()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_dimensions; \}
00119 
00120   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{bool} evalSubExprsIfNeeded(Scalar* \textcolor{comment}{/*data*/}) \{
00121     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00122   \}
00123   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} cleanup() \{
00124   \}
00125 
00126   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE CoeffReturnType coeff(Index index)\textcolor{keyword}{ const}
00127 \textcolor{keyword}{  }\{
00128     \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} coords;
00129     extract\_coordinates(index, coords);
00130     \textcolor{keywordflow}{return} m\_generator(coords);
00131   \}
00132 
00133   \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>
00134   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE PacketReturnType packet(Index index)\textcolor{keyword}{ const}
00135 \textcolor{keyword}{  }\{
00136     \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetSize = \hyperlink{struct_eigen_1_1internal_1_1unpacket__traits}{internal::unpacket\_traits<PacketReturnType>::size}
      ;
00137     EIGEN\_STATIC\_ASSERT((packetSize > 1), YOU\_MADE\_A\_PROGRAMMING\_MISTAKE)
00138     eigen\_assert(index+packetSize-1 < dimensions().TotalSize());
00139 
00140     EIGEN\_ALIGN\_MAX \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_const<CoeffReturnType>::type}
       values[packetSize];
00141     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < packetSize; ++i) \{
00142       values[i] = coeff(index+i);
00143     \}
00144     PacketReturnType rslt = internal::pload<PacketReturnType>(values);
00145     \textcolor{keywordflow}{return} rslt;
00146   \}
00147 
00148   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}
00149   costPerCoeff(\textcolor{keywordtype}{bool})\textcolor{keyword}{ const }\{
00150     \textcolor{comment}{// TODO(rmlarsen): This is just a placeholder. Define interface to make}
00151     \textcolor{comment}{// generators return their cost.}
00152     \textcolor{keywordflow}{return} \hyperlink{class_eigen_1_1_tensor_op_cost}{TensorOpCost}(0, 0, TensorOpCost::AddCost<Scalar>() +
00153                                   TensorOpCost::MulCost<Scalar>());
00154   \}
00155 
00156   EIGEN\_DEVICE\_FUNC Scalar* data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} NULL; \}
00157 
00158  \textcolor{keyword}{protected}:
00159   EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE
00160   \textcolor{keywordtype}{void} extract\_coordinates(Index index, \hyperlink{class_eigen_1_1array}{array<Index, NumDims>}& coords)\textcolor{keyword}{ const }\{
00161     \textcolor{keywordflow}{if} (static\_cast<int>(Layout) == static\_cast<int>(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor})) \{
00162       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = NumDims - 1; i > 0; --i) \{
00163         \textcolor{keyword}{const} Index idx = index / m\_strides[i];
00164         index -= idx * m\_strides[i];
00165         coords[i] = idx;
00166       \}
00167       coords[0] = index;
00168     \} \textcolor{keywordflow}{else} \{
00169       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < NumDims - 1; ++i) \{
00170         \textcolor{keyword}{const} Index idx = index / m\_strides[i];
00171         index -= idx * m\_strides[i];
00172         coords[i] = idx;
00173       \}
00174       coords[NumDims-1] = index;
00175     \}
00176   \}
00177 
00178   Dimensions m\_dimensions;
00179   \hyperlink{class_eigen_1_1array}{array<Index, NumDims>} m\_strides;
00180   Generator m\_generator;
00181 \};
00182 
00183 \} \textcolor{comment}{// end namespace Eigen}
00184 
00185 \textcolor{preprocessor}{#endif // EIGEN\_CXX11\_TENSOR\_TENSOR\_GENERATOR\_H}
\end{DoxyCode}
