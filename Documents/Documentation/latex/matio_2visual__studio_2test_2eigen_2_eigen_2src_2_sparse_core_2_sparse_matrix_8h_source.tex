\hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source}{}\section{matio/visual\+\_\+studio/test/eigen/\+Eigen/src/\+Sparse\+Core/\+Sparse\+Matrix.h}
\label{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source}\index{Sparse\+Matrix.\+h@{Sparse\+Matrix.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}
00002 \textcolor{comment}{// for linear algebra.}
00003 \textcolor{comment}{//}
00004 \textcolor{comment}{// Copyright (C) 2008-2014 Gael Guennebaud <gael.guennebaud@inria.fr>}
00005 \textcolor{comment}{//}
00006 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}
00007 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}
00008 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}
00009 
00010 \textcolor{preprocessor}{#ifndef EIGEN\_SPARSEMATRIX\_H}
00011 \textcolor{preprocessor}{#define EIGEN\_SPARSEMATRIX\_H}
00012 
00013 \textcolor{keyword}{namespace }\hyperlink{namespace_eigen}{Eigen} \{ 
00014 
00045 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00046 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex>
00047 \textcolor{keyword}{struct }traits<SparseMatrix<\_Scalar, \_Options, \_StorageIndex> >
00048 \{
00049   \textcolor{keyword}{typedef} \_Scalar Scalar;
00050   \textcolor{keyword}{typedef} \_StorageIndex StorageIndex;
00051   \textcolor{keyword}{typedef} Sparse StorageKind;
00052   \textcolor{keyword}{typedef} MatrixXpr XprKind;
00053   \textcolor{keyword}{enum} \{
00054     RowsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00055     ColsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00056     MaxRowsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00057     MaxColsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00058     Flags = \_Options | NestByRefBit | \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit} | \hyperlink{group__flags_gaed0244284da47a2b8661261431173caf}{CompressedAccessBit},
00059     SupportedAccessPatterns = InnerRandomAccessPattern
00060   \};
00061 \};
00062 
00063 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex, \textcolor{keywordtype}{int} DiagIndex>
00064 \textcolor{keyword}{struct }traits<Diagonal<SparseMatrix<\_Scalar, \_Options, \_StorageIndex>, DiagIndex> >
00065 \{
00066   \textcolor{keyword}{typedef} SparseMatrix<\_Scalar, \_Options, \_StorageIndex> MatrixType;
00067   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ref\_selector<MatrixType>::type MatrixTypeNested;
00068   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_reference<MatrixTypeNested>::type \_MatrixTypeNested;
00069 
00070   \textcolor{keyword}{typedef} \_Scalar Scalar;
00071   \textcolor{keyword}{typedef} Dense StorageKind;
00072   \textcolor{keyword}{typedef} \_StorageIndex StorageIndex;
00073   \textcolor{keyword}{typedef} MatrixXpr XprKind;
00074 
00075   \textcolor{keyword}{enum} \{
00076     RowsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00077     ColsAtCompileTime = 1,
00078     MaxRowsAtCompileTime = \hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic},
00079     MaxColsAtCompileTime = 1,
00080     Flags = \hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit}
00081   \};
00082 \};
00083 
00084 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex, \textcolor{keywordtype}{int} DiagIndex>
00085 \textcolor{keyword}{struct }traits<Diagonal<const SparseMatrix<\_Scalar, \_Options, \_StorageIndex>, DiagIndex> >
00086  : \textcolor{keyword}{public} traits<Diagonal<SparseMatrix<\_Scalar, \_Options, \_StorageIndex>, DiagIndex> >
00087 \{
00088   \textcolor{keyword}{enum} \{
00089     Flags = 0
00090   \};
00091 \};
00092 
00093 \} \textcolor{comment}{// end namespace internal}
00094 
00095 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex>
00096 \textcolor{keyword}{class }SparseMatrix
00097   : \textcolor{keyword}{public} SparseCompressedBase<SparseMatrix<\_Scalar, \_Options, \_StorageIndex> >
00098 \{
00099     \textcolor{keyword}{typedef} SparseCompressedBase<SparseMatrix> Base;
00100     \textcolor{keyword}{using} Base::convert\_index;
00101     \textcolor{keyword}{friend} \textcolor{keyword}{class }SparseVector<\_Scalar,0,\_StorageIndex>;
00102   \textcolor{keyword}{public}:
00103     \textcolor{keyword}{using} Base::isCompressed;
00104     \textcolor{keyword}{using} Base::nonZeros;
00105     EIGEN\_SPARSE\_PUBLIC\_INTERFACE(SparseMatrix)
00106     \textcolor{keyword}{using} Base::operator+=;
00107     \textcolor{keyword}{using} Base::operator-=;
00108 
00109     \textcolor{keyword}{typedef} MappedSparseMatrix<Scalar,Flags> Map;
00110     \textcolor{keyword}{typedef} Diagonal<SparseMatrix> DiagonalReturnType;
00111     \textcolor{keyword}{typedef} Diagonal<const SparseMatrix> ConstDiagonalReturnType;
00112     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::InnerIterator InnerIterator;
00113     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::ReverseInnerIterator ReverseInnerIterator;
00114     
00115 
00116     \textcolor{keyword}{using} Base::IsRowMajor;
00117     \textcolor{keyword}{typedef} internal::CompressedStorage<Scalar,StorageIndex> Storage;
00118     \textcolor{keyword}{enum} \{
00119       Options = \_Options
00120     \};
00121 
00122     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::IndexVector IndexVector;
00123     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Base::ScalarVector ScalarVector;
00124   \textcolor{keyword}{protected}:
00125     \textcolor{keyword}{typedef} SparseMatrix<Scalar,(Flags&~RowMajorBit)|(IsRowMajor?RowMajorBit:0)> TransposedSparseMatrix;
00126 
00127     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_outerSize;
00128     \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index} m\_innerSize;
00129     StorageIndex* m\_outerIndex;
00130     StorageIndex* m\_innerNonZeros;     \textcolor{comment}{// optional, if null then the data is compressed}
00131     Storage m\_data;
00132 
00133   \textcolor{keyword}{public}:
00134     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00136}\hyperlink{group___sparse_core___module_a62e61bb861eee306d5b069ce652b5aa5}{00136}     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} \hyperlink{group___sparse_core___module_a62e61bb861eee306d5b069ce652b5aa5}{rows}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_outerSize : m\_innerSize; \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00138}\hyperlink{group___sparse_core___module_aa391750e3c530227e4a5c3c52e959975}{00138}     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} \hyperlink{group___sparse_core___module_aa391750e3c530227e4a5c3c52e959975}{cols}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} IsRowMajor ? m\_innerSize : m\_outerSize; \}
00139 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00141}\hyperlink{group___sparse_core___module_a0f42824d4a06ee1d1f6afbc4551c5896}{00141}     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} \hyperlink{group___sparse_core___module_a0f42824d4a06ee1d1f6afbc4551c5896}{innerSize}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_innerSize; \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00143}\hyperlink{group___sparse_core___module_a4e5f706cfae14d2eaec1ea1e234905f1}{00143}     \textcolor{keyword}{inline} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} \hyperlink{group___sparse_core___module_a4e5f706cfae14d2eaec1ea1e234905f1}{outerSize}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_outerSize; \}
00144     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00148}\hyperlink{group___sparse_core___module_a9d4354d3f4d121d764bbed33cac05329}{00148}     \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar* \hyperlink{group___sparse_core___module_a9d4354d3f4d121d764bbed33cac05329}{valuePtr}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.valuePtr(); \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00152}\hyperlink{group___sparse_core___module_ac2684952b14b5c9b0f68ae3bb8c517a6}{00152}     \textcolor{keyword}{inline} Scalar* \hyperlink{group___sparse_core___module_ac2684952b14b5c9b0f68ae3bb8c517a6}{valuePtr}() \{ \textcolor{keywordflow}{return} m\_data.valuePtr(); \}
00153 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00157}\hyperlink{group___sparse_core___module_ae7b804bd39745156d20ca1611a296b67}{00157}     \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}* \hyperlink{group___sparse_core___module_ae7b804bd39745156d20ca1611a296b67}{innerIndexPtr}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.indexPtr(); \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00161}\hyperlink{group___sparse_core___module_a8e9ef5d399d36fdd860ad05cb7a31455}{00161}     \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}* \hyperlink{group___sparse_core___module_a8e9ef5d399d36fdd860ad05cb7a31455}{innerIndexPtr}() \{ \textcolor{keywordflow}{return} m\_data.indexPtr(); \}
00162 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00166}\hyperlink{group___sparse_core___module_a75506964d86d6badb32d0b4917acf2e2}{00166}     \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}* \hyperlink{group___sparse_core___module_a75506964d86d6badb32d0b4917acf2e2}{outerIndexPtr}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_outerIndex; \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00170}\hyperlink{group___sparse_core___module_a9451af2795c1a5b97678272475e41422}{00170}     \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}* \hyperlink{group___sparse_core___module_a9451af2795c1a5b97678272475e41422}{outerIndexPtr}() \{ \textcolor{keywordflow}{return} m\_outerIndex; \}
00171 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00175}\hyperlink{group___sparse_core___module_a218204b051a24f579c394454786eeda0}{00175}     \textcolor{keyword}{inline} \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}* \hyperlink{group___sparse_core___module_a218204b051a24f579c394454786eeda0}{innerNonZeroPtr}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_innerNonZeros;
       \}
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00179}\hyperlink{group___sparse_core___module_a00efb5c30c29bbc826d156d97e60d870}{00179}     \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}* \hyperlink{group___sparse_core___module_a00efb5c30c29bbc826d156d97e60d870}{innerNonZeroPtr}() \{ \textcolor{keywordflow}{return} m\_innerNonZeros; \}
00180 
00182     \textcolor{keyword}{inline} Storage& data() \{ \textcolor{keywordflow}{return} m\_data; \}
00184     \textcolor{keyword}{inline} \textcolor{keyword}{const} Storage& data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data; \}
00185 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00188}\hyperlink{group___sparse_core___module_a54adf6aa526045f37e67e352da8fd105}{00188}     \textcolor{keyword}{inline} Scalar \hyperlink{group___sparse_core___module_a54adf6aa526045f37e67e352da8fd105}{coeff}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col)\textcolor{keyword}{ const}
00189 \textcolor{keyword}{    }\{
00190       eigen\_assert(row>=0 && row<rows() && col>=0 && col<cols());
00191       
00192       \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer = IsRowMajor ? row : col;
00193       \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} inner = IsRowMajor ? col : row;
00194       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} end = m\_innerNonZeros ? m\_outerIndex[outer] + m\_innerNonZeros[outer] : m\_outerIndex[outer+
      1];
00195       \textcolor{keywordflow}{return} m\_data.atInRange(m\_outerIndex[outer], end, \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}(inner));
00196     \}
00197 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00206}\hyperlink{group___sparse_core___module_a013197b3f598968ff37ed8c97087f1ef}{00206}     \textcolor{keyword}{inline} Scalar& \hyperlink{group___sparse_core___module_a013197b3f598968ff37ed8c97087f1ef}{coeffRef}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col)
00207     \{
00208       eigen\_assert(row>=0 && row<rows() && col>=0 && col<cols());
00209       
00210       \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer = IsRowMajor ? row : col;
00211       \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} inner = IsRowMajor ? col : row;
00212 
00213       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} start = m\_outerIndex[outer];
00214       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} end = m\_innerNonZeros ? m\_outerIndex[outer] + m\_innerNonZeros[outer] : m\_outerIndex[outer+
      1];
00215       eigen\_assert(end>=start && \textcolor{stringliteral}{"you probably called coeffRef on a non finalized matrix"});
00216       \textcolor{keywordflow}{if}(end<=start)
00217         \textcolor{keywordflow}{return} insert(row,col);
00218       \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} p = m\_data.searchLowerIndex(start,end-1,\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}(inner));
00219       \textcolor{keywordflow}{if}((p<end) && (m\_data.index(p)==inner))
00220         \textcolor{keywordflow}{return} m\_data.value(p);
00221       \textcolor{keywordflow}{else}
00222         \textcolor{keywordflow}{return} insert(row,col);
00223     \}
00224 
00240     Scalar& insert(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col);
00241 
00242   \textcolor{keyword}{public}:
00243 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00251}\hyperlink{group___sparse_core___module_ad3c7416090f913e8685523cb3ab7c2f7}{00251}     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_ad3c7416090f913e8685523cb3ab7c2f7}{setZero}()
00252     \{
00253       m\_data.clear();
00254       memset(m\_outerIndex, 0, (m\_outerSize+1)*\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}));
00255       \textcolor{keywordflow}{if}(m\_innerNonZeros)
00256         memset(m\_innerNonZeros, 0, (m\_outerSize)*\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}));
00257     \}
00258 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00262}\hyperlink{group___sparse_core___module_a1518e58ac49bed0e2385b722a034f7d3}{00262}     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_a1518e58ac49bed0e2385b722a034f7d3}{reserve}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} reserveSize)
00263     \{
00264       eigen\_assert(isCompressed() && \textcolor{stringliteral}{"This function does not make sense in non compressed mode."});
00265       m\_data.reserve(reserveSize);
00266     \}
00267     
00268 \textcolor{preprocessor}{    #ifdef EIGEN\_PARSED\_BY\_DOXYGEN}
00269 
00281     \textcolor{keyword}{template}<\textcolor{keyword}{class} SizesType>
00282     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} reserve(\textcolor{keyword}{const} SizesType& reserveSizes);
00283 \textcolor{preprocessor}{    #else}
00284     \textcolor{keyword}{template}<\textcolor{keyword}{class} SizesType>
00285     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} reserve(\textcolor{keyword}{const} SizesType& reserveSizes, \textcolor{keyword}{const} \textcolor{keyword}{typename} SizesType::value\_type& enableif =
00286     #\textcolor{keywordflow}{if} (!EIGEN\_COMP\_MSVC) || (EIGEN\_COMP\_MSVC>=1500) \textcolor{comment}{// MSVC 2005 fails to compile with this typename}
00287         \textcolor{keyword}{typename}
00288     #endif
00289         SizesType::value\_type())
00290     \{
00291       EIGEN\_UNUSED\_VARIABLE(enableif);
00292       reserveInnerVectors(reserveSizes);
00293     \}
00294 \textcolor{preprocessor}{    #endif // EIGEN\_PARSED\_BY\_DOXYGEN}
00295   \textcolor{keyword}{protected}:
00296     \textcolor{keyword}{template}<\textcolor{keyword}{class} SizesType>
00297     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} reserveInnerVectors(\textcolor{keyword}{const} SizesType& reserveSizes)
00298     \{
00299       \textcolor{keywordflow}{if}(isCompressed())
00300       \{
00301         \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} totalReserveSize = 0;
00302         \textcolor{comment}{// turn the matrix into non-compressed mode}
00303         m\_innerNonZeros = \textcolor{keyword}{static\_cast<}\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}*\textcolor{keyword}{>}(std::malloc(m\_outerSize * \textcolor{keyword}{sizeof}(
      \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex})));
00304         \textcolor{keywordflow}{if} (!m\_innerNonZeros) internal::throw\_std\_bad\_alloc();
00305         
00306         \textcolor{comment}{// temporarily use m\_innerSizes to hold the new starting points.}
00307         \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}* newOuterIndex = m\_innerNonZeros;
00308         
00309         \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} count = 0;
00310         \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j=0; j<m\_outerSize; ++j)
00311         \{
00312           newOuterIndex[j] = count;
00313           count += reserveSizes[j] + (m\_outerIndex[j+1]-m\_outerIndex[j]);
00314           totalReserveSize += reserveSizes[j];
00315         \}
00316         m\_data.reserve(totalReserveSize);
00317         \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} previousOuterIndex = m\_outerIndex[m\_outerSize];
00318         \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j=m\_outerSize-1; j>=0; --j)
00319         \{
00320           \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} innerNNZ = previousOuterIndex - m\_outerIndex[j];
00321           \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i=innerNNZ-1; i>=0; --i)
00322           \{
00323             m\_data.index(newOuterIndex[j]+i) = m\_data.index(m\_outerIndex[j]+i);
00324             m\_data.value(newOuterIndex[j]+i) = m\_data.value(m\_outerIndex[j]+i);
00325           \}
00326           previousOuterIndex = m\_outerIndex[j];
00327           m\_outerIndex[j] = newOuterIndex[j];
00328           m\_innerNonZeros[j] = innerNNZ;
00329         \}
00330         m\_outerIndex[m\_outerSize] = m\_outerIndex[m\_outerSize-1] + m\_innerNonZeros[m\_outerSize-1] + 
      reserveSizes[m\_outerSize-1];
00331         
00332         m\_data.resize(m\_outerIndex[m\_outerSize]);
00333       \}
00334       \textcolor{keywordflow}{else}
00335       \{
00336         \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}* newOuterIndex = \textcolor{keyword}{static\_cast<}\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}*\textcolor{keyword}{>}(std::malloc((
      m\_outerSize+1)*\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex})));
00337         \textcolor{keywordflow}{if} (!newOuterIndex) internal::throw\_std\_bad\_alloc();
00338         
00339         \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} count = 0;
00340         \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j=0; j<m\_outerSize; ++j)
00341         \{
00342           newOuterIndex[j] = count;
00343           \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} alreadyReserved = (m\_outerIndex[j+1]-m\_outerIndex[j]) - m\_innerNonZeros[
      j];
00344           \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} toReserve = std::max<StorageIndex>(reserveSizes[j], alreadyReserved);
00345           count += toReserve + m\_innerNonZeros[j];
00346         \}
00347         newOuterIndex[m\_outerSize] = count;
00348         
00349         m\_data.resize(count);
00350         \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j=m\_outerSize-1; j>=0; --j)
00351         \{
00352           \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} offset = newOuterIndex[j] - m\_outerIndex[j];
00353           \textcolor{keywordflow}{if}(offset>0)
00354           \{
00355             \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} innerNNZ = m\_innerNonZeros[j];
00356             \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i=innerNNZ-1; i>=0; --i)
00357             \{
00358               m\_data.index(newOuterIndex[j]+i) = m\_data.index(m\_outerIndex[j]+i);
00359               m\_data.value(newOuterIndex[j]+i) = m\_data.value(m\_outerIndex[j]+i);
00360             \}
00361           \}
00362         \}
00363         
00364         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_outerIndex, newOuterIndex);
00365         std::free(newOuterIndex);
00366       \}
00367       
00368     \}
00369   \textcolor{keyword}{public}:
00370 
00371     \textcolor{comment}{//--- low level purely coherent filling ---}
00372 
00383     \textcolor{keyword}{inline} Scalar& insertBack(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col)
00384     \{
00385       \textcolor{keywordflow}{return} insertBackByOuterInner(IsRowMajor?row:col, IsRowMajor?col:row);
00386     \}
00387 
00390     \textcolor{keyword}{inline} Scalar& insertBackByOuterInner(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} inner)
00391     \{
00392       eigen\_assert(\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(m\_outerIndex[outer+1]) == m\_data.size() && \textcolor{stringliteral}{"Invalid ordered insertion
       (invalid outer index)"});
00393       eigen\_assert( (m\_outerIndex[outer+1]-m\_outerIndex[outer]==0 || m\_data.index(m\_data.size()-1)<inner) &
      & \textcolor{stringliteral}{"Invalid ordered insertion (invalid inner index)"});
00394       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} p = m\_outerIndex[outer+1];
00395       ++m\_outerIndex[outer+1];
00396       m\_data.append(Scalar(0), inner);
00397       \textcolor{keywordflow}{return} m\_data.value(p);
00398     \}
00399 
00402     \textcolor{keyword}{inline} Scalar& insertBackByOuterInnerUnordered(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} inner)
00403     \{
00404       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} p = m\_outerIndex[outer+1];
00405       ++m\_outerIndex[outer+1];
00406       m\_data.append(Scalar(0), inner);
00407       \textcolor{keywordflow}{return} m\_data.value(p);
00408     \}
00409 
00412     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} startVec(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer)
00413     \{
00414       eigen\_assert(m\_outerIndex[outer]==\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(m\_data.size()) && \textcolor{stringliteral}{"You must call startVec for each inner
       vector sequentially"});
00415       eigen\_assert(m\_outerIndex[outer+1]==0 && \textcolor{stringliteral}{"You must call startVec for each inner vector sequentially"})
      ;
00416       m\_outerIndex[outer+1] = m\_outerIndex[outer];
00417     \}
00418 
00422     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} finalize()
00423     \{
00424       \textcolor{keywordflow}{if}(isCompressed())
00425       \{
00426         \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} size = internal::convert\_index<StorageIndex>(m\_data.size());
00427         \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i = m\_outerSize;
00428         \textcolor{comment}{// find the last filled column}
00429         \textcolor{keywordflow}{while} (i>=0 && m\_outerIndex[i]==0)
00430           --i;
00431         ++i;
00432         \textcolor{keywordflow}{while} (i<=m\_outerSize)
00433         \{
00434           m\_outerIndex[i] = size;
00435           ++i;
00436         \}
00437       \}
00438     \}
00439 
00440     \textcolor{comment}{//---}
00441 
00442     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIterators>
00443     \textcolor{keywordtype}{void} setFromTriplets(\textcolor{keyword}{const} InputIterators& begin, \textcolor{keyword}{const} InputIterators& end);
00444 
00445     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIterators,\textcolor{keyword}{typename} DupFunctor>
00446     \textcolor{keywordtype}{void} setFromTriplets(\textcolor{keyword}{const} InputIterators& begin, \textcolor{keyword}{const} InputIterators& end, DupFunctor dup\_func);
00447 
00448     \textcolor{keywordtype}{void} sumupDuplicates() \{ collapseDuplicates(
      \hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal::scalar\_sum\_op<Scalar,Scalar>}()); \}
00449 
00450     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DupFunctor>
00451     \textcolor{keywordtype}{void} collapseDuplicates(DupFunctor dup\_func = DupFunctor());
00452 
00453     \textcolor{comment}{//---}
00454     
00457     Scalar& insertByOuterInner(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i)
00458     \{
00459       \textcolor{keywordflow}{return} insert(IsRowMajor ? j : i, IsRowMajor ? i : j);
00460     \}
00461 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00464}\hyperlink{group___sparse_core___module_a5ff54ffc10296f9466dc81fa888733fd}{00464}     \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_a5ff54ffc10296f9466dc81fa888733fd}{makeCompressed}()
00465     \{
00466       \textcolor{keywordflow}{if}(isCompressed())
00467         \textcolor{keywordflow}{return};
00468       
00469       eigen\_internal\_assert(m\_outerIndex!=0 && m\_outerSize>0);
00470       
00471       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} oldStart = m\_outerIndex[1];
00472       m\_outerIndex[1] = m\_innerNonZeros[0];
00473       \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j=1; j<m\_outerSize; ++j)
00474       \{
00475         \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} nextOldStart = m\_outerIndex[j+1];
00476         \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} offset = oldStart - m\_outerIndex[j];
00477         \textcolor{keywordflow}{if}(offset>0)
00478         \{
00479           \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} k=0; k<m\_innerNonZeros[j]; ++k)
00480           \{
00481             m\_data.index(m\_outerIndex[j]+k) = m\_data.index(oldStart+k);
00482             m\_data.value(m\_outerIndex[j]+k) = m\_data.value(oldStart+k);
00483           \}
00484         \}
00485         m\_outerIndex[j+1] = m\_outerIndex[j] + m\_innerNonZeros[j];
00486         oldStart = nextOldStart;
00487       \}
00488       std::free(m\_innerNonZeros);
00489       m\_innerNonZeros = 0;
00490       m\_data.resize(m\_outerIndex[m\_outerSize]);
00491       m\_data.squeeze();
00492     \}
00493 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00495}\hyperlink{group___sparse_core___module_a7e560ebda035e992d2c99875cc7c3af3}{00495}     \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_a7e560ebda035e992d2c99875cc7c3af3}{uncompress}()
00496     \{
00497       \textcolor{keywordflow}{if}(m\_innerNonZeros != 0)
00498         \textcolor{keywordflow}{return}; 
00499       m\_innerNonZeros = \textcolor{keyword}{static\_cast<}\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}*\textcolor{keyword}{>}(std::malloc(m\_outerSize * \textcolor{keyword}{sizeof}(
      \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex})));
00500       \textcolor{keywordflow}{for} (\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i = 0; i < m\_outerSize; i++)
00501       \{
00502         m\_innerNonZeros[i] = m\_outerIndex[i+1] - m\_outerIndex[i]; 
00503       \}
00504     \}
00505     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00507}\hyperlink{group___sparse_core___module_a08af03b2fc6c371c8be4fcd62509288c}{00507}     \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_a08af03b2fc6c371c8be4fcd62509288c}{prune}(\textcolor{keyword}{const} Scalar& reference, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_aaec8ace6efb785c81d442931c3248d88}{RealScalar}& epsilon = 
      \hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<RealScalar>::dummy\_precision}())
00508     \{
00509       prune(default\_prunning\_func(reference,epsilon));
00510     \}
00511     
00519     \textcolor{keyword}{template}<\textcolor{keyword}{typename} KeepFunc>
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00520}\hyperlink{group___sparse_core___module_a0e5f8cc59ee57207f0cff6b142bcdd0d}{00520}     \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_a0e5f8cc59ee57207f0cff6b142bcdd0d}{prune}(\textcolor{keyword}{const} KeepFunc& keep = KeepFunc())
00521     \{
00522       \textcolor{comment}{// TODO optimize the uncompressed mode to avoid moving and allocating the data twice}
00523       makeCompressed();
00524 
00525       \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} k = 0;
00526       \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j=0; j<m\_outerSize; ++j)
00527       \{
00528         \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} previousStart = m\_outerIndex[j];
00529         m\_outerIndex[j] = k;
00530         \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} end = m\_outerIndex[j+1];
00531         \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i=previousStart; i<end; ++i)
00532         \{
00533           \textcolor{keywordflow}{if}(keep(IsRowMajor?j:m\_data.index(i), IsRowMajor?m\_data.index(i):j, m\_data.value(i)))
00534           \{
00535             m\_data.value(k) = m\_data.value(i);
00536             m\_data.index(k) = m\_data.index(i);
00537             ++k;
00538           \}
00539         \}
00540       \}
00541       m\_outerIndex[m\_outerSize] = k;
00542       m\_data.resize(k,0);
00543     \}
00544 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00553}\hyperlink{group___sparse_core___module_a9dc538b2c1fe9027ba58f31ee83b2ff1}{00553}     \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_a9dc538b2c1fe9027ba58f31ee83b2ff1}{conservativeResize}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} rows, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} cols) 
00554     \{
00555       \textcolor{comment}{// No change}
00556       \textcolor{keywordflow}{if} (this->rows() == rows && this->cols() == cols) \textcolor{keywordflow}{return};
00557       
00558       \textcolor{comment}{// If one dimension is null, then there is nothing to be preserved}
00559       \textcolor{keywordflow}{if}(rows==0 || cols==0) \textcolor{keywordflow}{return} resize(rows,cols);
00560 
00561       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} innerChange = IsRowMajor ? cols - this->cols() : rows - this->rows();
00562       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outerChange = IsRowMajor ? rows - this->rows() : cols - this->cols();
00563       \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} newInnerSize = convert\_index(IsRowMajor ? cols : rows);
00564 
00565       \textcolor{comment}{// Deals with inner non zeros}
00566       \textcolor{keywordflow}{if} (m\_innerNonZeros)
00567       \{
00568         \textcolor{comment}{// Resize m\_innerNonZeros}
00569         \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} *newInnerNonZeros = \textcolor{keyword}{static\_cast<}\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}*\textcolor{keyword}{>}(std::realloc(
      m\_innerNonZeros, (m\_outerSize + outerChange) * \textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex})));
00570         \textcolor{keywordflow}{if} (!newInnerNonZeros) internal::throw\_std\_bad\_alloc();
00571         m\_innerNonZeros = newInnerNonZeros;
00572         
00573         \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i=m\_outerSize; i<m\_outerSize+outerChange; i++)          
00574           m\_innerNonZeros[i] = 0;
00575       \} 
00576       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (innerChange < 0) 
00577       \{
00578         \textcolor{comment}{// Inner size decreased: allocate a new m\_innerNonZeros}
00579         m\_innerNonZeros = \textcolor{keyword}{static\_cast<}\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}*\textcolor{keyword}{>}(std::malloc((m\_outerSize+outerChange+1) * \textcolor{keyword}{
      sizeof}(\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex})));
00580         \textcolor{keywordflow}{if} (!m\_innerNonZeros) internal::throw\_std\_bad\_alloc();
00581         \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i = 0; i < m\_outerSize; i++)
00582           m\_innerNonZeros[i] = m\_outerIndex[i+1] - m\_outerIndex[i];
00583       \}
00584       
00585       \textcolor{comment}{// Change the m\_innerNonZeros in case of a decrease of inner size}
00586       \textcolor{keywordflow}{if} (m\_innerNonZeros && innerChange < 0)
00587       \{
00588         \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i = 0; i < m\_outerSize + (std::min)(outerChange, \hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(0)); i++)
00589         \{
00590           \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} &n = m\_innerNonZeros[i];
00591           \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} start = m\_outerIndex[i];
00592           \textcolor{keywordflow}{while} (n > 0 && m\_data.index(start+n-1) >= newInnerSize) --n; 
00593         \}
00594       \}
00595       
00596       m\_innerSize = newInnerSize;
00597 
00598       \textcolor{comment}{// Re-allocate outer index structure if necessary}
00599       \textcolor{keywordflow}{if} (outerChange == 0)
00600         \textcolor{keywordflow}{return};
00601           
00602       \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} *newOuterIndex = \textcolor{keyword}{static\_cast<}\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}*\textcolor{keyword}{>}(std::realloc(
      m\_outerIndex, (m\_outerSize + outerChange + 1) * \textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex})));
00603       \textcolor{keywordflow}{if} (!newOuterIndex) internal::throw\_std\_bad\_alloc();
00604       m\_outerIndex = newOuterIndex;
00605       \textcolor{keywordflow}{if} (outerChange > 0)
00606       \{
00607         \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} last = m\_outerSize == 0 ? 0 : m\_outerIndex[m\_outerSize];
00608         \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i=m\_outerSize; i<m\_outerSize+outerChange+1; i++)          
00609           m\_outerIndex[i] = last; 
00610       \}
00611       m\_outerSize += outerChange;
00612     \}
00613     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00621}\hyperlink{group___sparse_core___module_af88551f30202341b7cc24cfadabdec5c}{00621}     \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_af88551f30202341b7cc24cfadabdec5c}{resize}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} rows, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} cols)
00622     \{
00623       \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outerSize = IsRowMajor ? rows : cols;
00624       m\_innerSize = IsRowMajor ? cols : rows;
00625       m\_data.clear();
00626       \textcolor{keywordflow}{if} (m\_outerSize != outerSize || m\_outerSize==0)
00627       \{
00628         std::free(m\_outerIndex);
00629         m\_outerIndex = \textcolor{keyword}{static\_cast<}\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}*\textcolor{keyword}{>}(std::malloc((outerSize + 1) * \textcolor{keyword}{sizeof}(
      \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex})));
00630         \textcolor{keywordflow}{if} (!m\_outerIndex) internal::throw\_std\_bad\_alloc();
00631         
00632         m\_outerSize = outerSize;
00633       \}
00634       \textcolor{keywordflow}{if}(m\_innerNonZeros)
00635       \{
00636         std::free(m\_innerNonZeros);
00637         m\_innerNonZeros = 0;
00638       \}
00639       memset(m\_outerIndex, 0, (m\_outerSize+1)*\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}));
00640     \}
00641 
00644     \textcolor{keywordtype}{void} resizeNonZeros(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} size)
00645     \{
00646       m\_data.resize(size);
00647     \}
00648 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00650}\hyperlink{group___sparse_core___module_a4423486f9fd64cbac7be06c748b37e0a}{00650}     \textcolor{keyword}{const} ConstDiagonalReturnType \hyperlink{group___sparse_core___module_a4423486f9fd64cbac7be06c748b37e0a}{diagonal}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} ConstDiagonalReturnType(*\textcolor{keyword}{this}); \}
00651     
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00656}\hyperlink{group___sparse_core___module_af83005640c2771ebd69f98848720ee52}{00656}     DiagonalReturnType \hyperlink{group___sparse_core___module_af83005640c2771ebd69f98848720ee52}{diagonal}() \{ \textcolor{keywordflow}{return} DiagonalReturnType(*\textcolor{keyword}{this}); \}
00657 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00659}\hyperlink{group___sparse_core___module_a68087ee333c9614ea28850ec52069079}{00659}     \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_a68087ee333c9614ea28850ec52069079}{SparseMatrix}()
00660       : m\_outerSize(-1), m\_innerSize(0), m\_outerIndex(0), m\_innerNonZeros(0)
00661     \{
00662       check\_template\_parameters();
00663       resize(0, 0);
00664     \}
00665 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00667}\hyperlink{group___sparse_core___module_a6abf1015a0243be97648e106a17b01ea}{00667}     \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_a6abf1015a0243be97648e106a17b01ea}{SparseMatrix}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} rows, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} cols)
00668       : m\_outerSize(0), m\_innerSize(0), m\_outerIndex(0), m\_innerNonZeros(0)
00669     \{
00670       check\_template\_parameters();
00671       resize(rows, cols);
00672     \}
00673 
00675     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00676}\hyperlink{group___sparse_core___module_a501a50f0d7d58dc4c1d990cd912f581f}{00676}     \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_a501a50f0d7d58dc4c1d990cd912f581f}{SparseMatrix}(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<OtherDerived>}& 
      other)
00677       : m\_outerSize(0), m\_innerSize(0), m\_outerIndex(0), m\_innerNonZeros(0)
00678     \{
00679       EIGEN\_STATIC\_ASSERT((
      \hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, typename OtherDerived::Scalar>::value}
      ),
00680         
      YOU\_MIXED\_DIFFERENT\_NUMERIC\_TYPES\_\_YOU\_NEED\_TO\_USE\_THE\_CAST\_METHOD\_OF\_MATRIXBASE\_TO\_CAST\_NUMERIC\_TYPES\_EXPLICITLY)
00681       check\_template\_parameters();
00682       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} needToTranspose = (Flags & \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) != (
      \hyperlink{struct_eigen_1_1internal_1_1evaluator}{internal::evaluator<OtherDerived>::Flags} & 
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit});
00683       \textcolor{keywordflow}{if} (needToTranspose)
00684         *\textcolor{keyword}{this} = other.derived();
00685       \textcolor{keywordflow}{else}
00686       \{
00687 \textcolor{preprocessor}{        #ifdef EIGEN\_SPARSE\_CREATE\_TEMPORARY\_PLUGIN}
00688           EIGEN\_SPARSE\_CREATE\_TEMPORARY\_PLUGIN
00689 \textcolor{preprocessor}{        #endif}
00690         internal::call\_assignment\_no\_alias(*\textcolor{keyword}{this}, other.derived());
00691       \}
00692     \}
00693     
00695     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} UpLo>
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00696}\hyperlink{group___sparse_core___module_aa755e8ba4ec4a2e39ebdb658228364e5}{00696}     \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_aa755e8ba4ec4a2e39ebdb658228364e5}{SparseMatrix}(\textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_self_adjoint_view}{SparseSelfAdjointView<OtherDerived, UpLo>}& other)
00697       : m\_outerSize(0), m\_innerSize(0), m\_outerIndex(0), m\_innerNonZeros(0)
00698     \{
00699       check\_template\_parameters();
00700       Base::operator=(other);
00701     \}
00702 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00704}\hyperlink{group___sparse_core___module_af0fa64cdba1f30353aac937a31db33f3}{00704}     \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_af0fa64cdba1f30353aac937a31db33f3}{SparseMatrix}(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix}& other)
00705       : Base(), m\_outerSize(0), m\_innerSize(0), m\_outerIndex(0), m\_innerNonZeros(0)
00706     \{
00707       check\_template\_parameters();
00708       *\textcolor{keyword}{this} = other.derived();
00709     \}
00710 
00712     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00713}\hyperlink{group___sparse_core___module_a4e328e4686980219c2b4d2a932670ab0}{00713}     \hyperlink{group___sparse_core___module_a4e328e4686980219c2b4d2a932670ab0}{SparseMatrix}(\textcolor{keyword}{const} \hyperlink{group___core___module_class_eigen_1_1_return_by_value}{ReturnByValue<OtherDerived>}& other)
00714       : Base(), m\_outerSize(0), m\_innerSize(0), m\_outerIndex(0), m\_innerNonZeros(0)
00715     \{
00716       check\_template\_parameters();
00717       initAssignment(other);
00718       other.evalTo(*\textcolor{keyword}{this});
00719     \}
00720     
00722     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00723}\hyperlink{group___sparse_core___module_a1c6fde42fd40e6f753b60f71e8fd88aa}{00723}     \textcolor{keyword}{explicit} \hyperlink{group___sparse_core___module_a1c6fde42fd40e6f753b60f71e8fd88aa}{SparseMatrix}(\textcolor{keyword}{const} \hyperlink{class_eigen_1_1_diagonal_base}{DiagonalBase<OtherDerived>}& other)
00724       : Base(), m\_outerSize(0), m\_innerSize(0), m\_outerIndex(0), m\_innerNonZeros(0)
00725     \{
00726       check\_template\_parameters();
00727       *\textcolor{keyword}{this} = other.derived();
00728     \}
00729 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00732}\hyperlink{group___sparse_core___module_ae9b9ad3524f87276511397d988b7a607}{00732}     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_ae9b9ad3524f87276511397d988b7a607}{swap}(\hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix}& other)
00733     \{
00734       \textcolor{comment}{//EIGEN\_DBG\_SPARSE(std::cout << "SparseMatrix:: swap\(\backslash\)n");}
00735       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_outerIndex, other.m\_outerIndex);
00736       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_innerSize, other.m\_innerSize);
00737       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_outerSize, other.m\_outerSize);
00738       \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{std::swap}(m\_innerNonZeros, other.m\_innerNonZeros);
00739       m\_data.swap(other.m\_data);
00740     \}
00741 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00744}\hyperlink{group___sparse_core___module_a89013d2aa58413672c90932607a0d6f0}{00744}     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_a89013d2aa58413672c90932607a0d6f0}{setIdentity}()
00745     \{
00746       eigen\_assert(rows() == cols() && \textcolor{stringliteral}{"ONLY FOR SQUARED MATRICES"});
00747       this->m\_data.resize(rows());
00748       \hyperlink{group___core___module_class_eigen_1_1_map}{Eigen::Map<IndexVector>}(this->m\_data.indexPtr(), rows()).setLinSpaced(0, 
      \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}(rows()-1));
00749       \hyperlink{group___core___module_class_eigen_1_1_map}{Eigen::Map<ScalarVector>}(this->m\_data.valuePtr(), rows()).setOnes();
00750       \hyperlink{group___core___module_class_eigen_1_1_map}{Eigen::Map<IndexVector>}(this->m\_outerIndex, rows()+1).setLinSpaced(0, 
      \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}(rows()));
00751       std::free(m\_innerNonZeros);
00752       m\_innerNonZeros = 0;
00753     \}
00754     \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix}& operator=(\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix}& other)
00755     \{
00756       \textcolor{keywordflow}{if} (other.isRValue())
00757       \{
00758         \hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(other.const\_cast\_derived());
00759       \}
00760       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(\textcolor{keyword}{this}!=&other)
00761       \{
00762 \textcolor{preprocessor}{        #ifdef EIGEN\_SPARSE\_CREATE\_TEMPORARY\_PLUGIN}
00763           EIGEN\_SPARSE\_CREATE\_TEMPORARY\_PLUGIN
00764 \textcolor{preprocessor}{        #endif}
00765         initAssignment(other);
00766         \textcolor{keywordflow}{if}(other.isCompressed())
00767         \{
00768           internal::smart\_copy(other.m\_outerIndex, other.m\_outerIndex + m\_outerSize + 1, m\_outerIndex);
00769           m\_data = other.m\_data;
00770         \}
00771         \textcolor{keywordflow}{else}
00772         \{
00773           Base::operator=(other);
00774         \}
00775       \}
00776       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
00777     \}
00778 
00779 \textcolor{preprocessor}{#ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
00780     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00781     \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix}& operator=(\textcolor{keyword}{const} \hyperlink{group___core___module_struct_eigen_1_1_eigen_base}{EigenBase<OtherDerived>}& other)
00782     \{ \textcolor{keywordflow}{return} Base::operator=(other.\hyperlink{group___core___module_a324b16961a11d2ecfd2d1b7dd7946545}{derived}()); \}
00783 \textcolor{preprocessor}{#endif // EIGEN\_PARSED\_BY\_DOXYGEN}
00784 
00785     \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
00786     EIGEN\_DONT\_INLINE \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix}& operator=(\textcolor{keyword}{const} 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<OtherDerived>}& other);
00787 
00788     \textcolor{keyword}{friend} std::ostream & operator << (std::ostream & s, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix}& m)
00789     \{
00790       EIGEN\_DBG\_SPARSE(
00791         s << \textcolor{stringliteral}{"Nonzero entries:\(\backslash\)n"};
00792         \textcolor{keywordflow}{if}(m.isCompressed())
00793         \{
00794           \textcolor{keywordflow}{for} (\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i=0; i<m.nonZeros(); ++i)
00795             s << \textcolor{stringliteral}{"("} << m.m\_data.value(i) << \textcolor{stringliteral}{","} << m.m\_data.index(i) << \textcolor{stringliteral}{") "};
00796         \}
00797         \textcolor{keywordflow}{else}
00798         \{
00799           \textcolor{keywordflow}{for} (\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i=0; i<m.outerSize(); ++i)
00800           \{
00801             \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} p = m.m\_outerIndex[i];
00802             \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} pe = m.m\_outerIndex[i]+m.m\_innerNonZeros[i];
00803             \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} k=p;
00804             \textcolor{keywordflow}{for} (; k<pe; ++k) \{
00805               s << \textcolor{stringliteral}{"("} << m.m\_data.value(k) << \textcolor{stringliteral}{","} << m.m\_data.index(k) << \textcolor{stringliteral}{") "};
00806             \}
00807             \textcolor{keywordflow}{for} (; k<m.m\_outerIndex[i+1]; ++k) \{
00808               s << \textcolor{stringliteral}{"(\_,\_) "};
00809             \}
00810           \}
00811         \}
00812         s << std::endl;
00813         s << std::endl;
00814         s << \textcolor{stringliteral}{"Outer pointers:\(\backslash\)n"};
00815         \textcolor{keywordflow}{for} (\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i=0; i<m.outerSize(); ++i) \{
00816           s << m.m\_outerIndex[i] << \textcolor{stringliteral}{" "};
00817         \}
00818         s << \textcolor{stringliteral}{" $"} << std::endl;
00819         \textcolor{keywordflow}{if}(!m.isCompressed())
00820         \{
00821           s << \textcolor{stringliteral}{"Inner non zeros:\(\backslash\)n"};
00822           \textcolor{keywordflow}{for} (\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i=0; i<m.outerSize(); ++i) \{
00823             s << m.m\_innerNonZeros[i] << \textcolor{stringliteral}{" "};
00824           \}
00825           s << \textcolor{stringliteral}{" $"} << std::endl;
00826         \}
00827         s << std::endl;
00828       );
00829       s << static\_cast<const SparseMatrixBase<SparseMatrix>&>(m);
00830       \textcolor{keywordflow}{return} s;
00831     \}
00832 
\Hypertarget{matio_2visual__studio_2test_2eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source_l00834}\hyperlink{group___sparse_core___module_a36835ee4f8e5f273087910ec8063a4f6}{00834}     \textcolor{keyword}{inline} \hyperlink{group___sparse_core___module_a36835ee4f8e5f273087910ec8063a4f6}{~SparseMatrix}()
00835     \{
00836       std::free(m\_outerIndex);
00837       std::free(m\_innerNonZeros);
00838     \}
00839 
00841     Scalar sum() \textcolor{keyword}{const};
00842     
00843 \textcolor{preprocessor}{#   ifdef EIGEN\_SPARSEMATRIX\_PLUGIN}
00844 \textcolor{preprocessor}{#     include EIGEN\_SPARSEMATRIX\_PLUGIN}
00845 \textcolor{preprocessor}{#   endif}
00846 
00847 \textcolor{keyword}{protected}:
00848 
00849     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Other>
00850     \textcolor{keywordtype}{void} initAssignment(\textcolor{keyword}{const} Other& other)
00851     \{
00852       resize(other.rows(), other.cols());
00853       \textcolor{keywordflow}{if}(m\_innerNonZeros)
00854       \{
00855         std::free(m\_innerNonZeros);
00856         m\_innerNonZeros = 0;
00857       \}
00858     \}
00859 
00862     EIGEN\_DONT\_INLINE Scalar& insertCompressed(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col);
00863 
00866     \textcolor{keyword}{class }SingletonVector
00867     \{
00868         \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} m\_index;
00869         \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} m\_value;
00870       \textcolor{keyword}{public}:
00871         \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} \hyperlink{group___sparse_core___module_ac254d3b61718ebc2136d27bac043dcb7}{value\_type};
00872         SingletonVector(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} v)
00873           : m\_index(convert\_index(i)), m\_value(convert\_index(v))
00874         \{\}
00875 
00876         \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} operator[](\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} i==m\_index ? m\_value : 0; \}
00877     \};
00878 
00881     EIGEN\_DONT\_INLINE Scalar& insertUncompressed(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col);
00882 
00883 \textcolor{keyword}{public}:
00886     EIGEN\_STRONG\_INLINE Scalar& insertBackUncompressed(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col)
00887     \{
00888       \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer = IsRowMajor ? row : col;
00889       \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} inner = IsRowMajor ? col : row;
00890 
00891       eigen\_assert(!isCompressed());
00892       eigen\_assert(m\_innerNonZeros[outer]<=(m\_outerIndex[outer+1] - m\_outerIndex[outer]));
00893 
00894       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} p = m\_outerIndex[outer] + m\_innerNonZeros[outer]++;
00895       m\_data.index(p) = convert\_index(inner);
00896       \textcolor{keywordflow}{return} (m\_data.value(p) = 0);
00897     \}
00898 
00899 \textcolor{keyword}{private}:
00900   \textcolor{keyword}{static} \textcolor{keywordtype}{void} check\_template\_parameters()
00901   \{
00902     EIGEN\_STATIC\_ASSERT(\hyperlink{group___core___module_struct_eigen_1_1_num_traits}{NumTraits<StorageIndex>::IsSigned},
      THE\_INDEX\_TYPE\_MUST\_BE\_A\_SIGNED\_TYPE);
00903     EIGEN\_STATIC\_ASSERT((Options&(\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}|\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}))==Options,
      INVALID\_MATRIX\_TEMPLATE\_PARAMETERS);
00904   \}
00905 
00906   \textcolor{keyword}{struct }default\_prunning\_func \{
00907     default\_prunning\_func(\textcolor{keyword}{const} Scalar& ref, \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_aaec8ace6efb785c81d442931c3248d88}{RealScalar}& eps) : reference(ref), epsilon(eps
      ) \{\}
00908     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} operator() (\textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index}&, \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index}&, \textcolor{keyword}{const} Scalar& value)\textcolor{keyword}{ const}
00909 \textcolor{keyword}{    }\{
00910       \textcolor{keywordflow}{return} !internal::isMuchSmallerThan(value, reference, epsilon);
00911     \}
00912     Scalar reference;
00913     \hyperlink{group___sparse_core___module_aaec8ace6efb785c81d442931c3248d88}{RealScalar} epsilon;
00914   \};
00915 \};
00916 
00917 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
00918 
00919 \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIterator, \textcolor{keyword}{typename} SparseMatrixType, \textcolor{keyword}{typename} DupFunctor>
00920 \textcolor{keywordtype}{void} set\_from\_triplets(\textcolor{keyword}{const} InputIterator& begin, \textcolor{keyword}{const} InputIterator& end, SparseMatrixType& mat, 
      DupFunctor dup\_func)
00921 \{
00922   \textcolor{keyword}{enum} \{ IsRowMajor = SparseMatrixType::IsRowMajor \};
00923   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::Scalar Scalar;
00924   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} SparseMatrixType::StorageIndex \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex};
00925   \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar,IsRowMajor?ColMajor:RowMajor,StorageIndex>}
       trMat(mat.rows(),mat.cols());
00926 
00927   \textcolor{keywordflow}{if}(begin!=end)
00928   \{
00929     \textcolor{comment}{// pass 1: count the nnz per inner-vector}
00930     \textcolor{keyword}{typename} SparseMatrixType::IndexVector wi(trMat.outerSize());
00931     wi.\hyperlink{group___sparse_core___module_ad3c7416090f913e8685523cb3ab7c2f7}{setZero}();
00932     \textcolor{keywordflow}{for}(InputIterator it(begin); it!=end; ++it)
00933     \{
00934       eigen\_assert(it->row()>=0 && it->row()<mat.rows() && it->col()>=0 && it->col()<mat.cols());
00935       wi(IsRowMajor ? it->col() : it->row())++;
00936     \}
00937 
00938     \textcolor{comment}{// pass 2: insert all the elements into trMat}
00939     trMat.reserve(wi);
00940     \textcolor{keywordflow}{for}(InputIterator it(begin); it!=end; ++it)
00941       trMat.insertBackUncompressed(it->row(),it->col()) = it->value();
00942 
00943     \textcolor{comment}{// pass 3:}
00944     trMat.collapseDuplicates(dup\_func);
00945   \}
00946 
00947   \textcolor{comment}{// pass 4: transposed copy -> implicit sorting}
00948   mat = trMat;
00949 \}
00950 
00951 \}
00952 
00953 
00991 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex>
00992 \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIterators>
00993 \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_acc35051d698e3973f1de5b9b78dbe345}{SparseMatrix<Scalar,\_Options,\_StorageIndex>::setFromTriplets}
      (\textcolor{keyword}{const} InputIterators& begin, \textcolor{keyword}{const} InputIterators& end)
00994 \{
00995   internal::set\_from\_triplets<InputIterators, SparseMatrix<Scalar,\_Options,\_StorageIndex> >(begin, end, *\textcolor{keyword}{
      this}, \hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal::scalar\_sum\_op<Scalar,Scalar>}());
00996 \}
00997 
01007 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex>
01008 \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIterators,\textcolor{keyword}{typename} DupFunctor>
01009 \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_acc35051d698e3973f1de5b9b78dbe345}{SparseMatrix<Scalar,\_Options,\_StorageIndex>::setFromTriplets}
      (\textcolor{keyword}{const} InputIterators& begin, \textcolor{keyword}{const} InputIterators& end, DupFunctor dup\_func)
01010 \{
01011   internal::set\_from\_triplets<InputIterators, SparseMatrix<Scalar,\_Options,\_StorageIndex>, DupFunctor>(
      begin, end, *\textcolor{keyword}{this}, dup\_func);
01012 \}
01013 
01015 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex>
01016 \textcolor{keyword}{template}<\textcolor{keyword}{typename} DupFunctor>
01017 \textcolor{keywordtype}{void} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar,\_Options,\_StorageIndex>::collapseDuplicates}
      (DupFunctor dup\_func)
01018 \{
01019   eigen\_assert(!isCompressed());
01020   \textcolor{comment}{// TODO, in practice we should be able to use m\_innerNonZeros for that task}
01021   IndexVector wi(innerSize());
01022   wi.fill(-1);
01023   \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} count = 0;
01024   \textcolor{comment}{// for each inner-vector, wi[inner\_index] will hold the position of first element into the index/value
       buffers}
01025   \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j=0; j<outerSize(); ++j)
01026   \{
01027     \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} start   = count;
01028     \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} oldEnd  = m\_outerIndex[j]+m\_innerNonZeros[j];
01029     \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} k=m\_outerIndex[j]; k<oldEnd; ++k)
01030     \{
01031       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} i = m\_data.index(k);
01032       \textcolor{keywordflow}{if}(wi(i)>=start)
01033       \{
01034         \textcolor{comment}{// we already meet this entry => accumulate it}
01035         m\_data.value(wi(i)) = dup\_func(m\_data.value(wi(i)), m\_data.value(k));
01036       \}
01037       \textcolor{keywordflow}{else}
01038       \{
01039         m\_data.value(count) = m\_data.value(k);
01040         m\_data.index(count) = m\_data.index(k);
01041         wi(i) = count;
01042         ++count;
01043       \}
01044     \}
01045     m\_outerIndex[j] = start;
01046   \}
01047   m\_outerIndex[m\_outerSize] = count;
01048 
01049   \textcolor{comment}{// turn the matrix into compressed form}
01050   std::free(m\_innerNonZeros);
01051   m\_innerNonZeros = 0;
01052   m\_data.resize(m\_outerIndex[m\_outerSize]);
01053 \}
01054 
01055 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex>
01056 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>
01057 EIGEN\_DONT\_INLINE \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar,\_Options,\_StorageIndex>}& 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<Scalar,\_Options,\_StorageIndex>::operator=}
      (\textcolor{keyword}{const} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix_base}{SparseMatrixBase<OtherDerived>}& other)
01058 \{
01059   EIGEN\_STATIC\_ASSERT((
      \hyperlink{struct_eigen_1_1internal_1_1is__same}{internal::is\_same<Scalar, typename OtherDerived::Scalar>::value}
      ),
01060         
      YOU\_MIXED\_DIFFERENT\_NUMERIC\_TYPES\_\_YOU\_NEED\_TO\_USE\_THE\_CAST\_METHOD\_OF\_MATRIXBASE\_TO\_CAST\_NUMERIC\_TYPES\_EXPLICITLY)
01061 
01062   \textcolor{preprocessor}{#ifdef EIGEN\_SPARSE\_CREATE\_TEMPORARY\_PLUGIN}
01063     EIGEN\_SPARSE\_CREATE\_TEMPORARY\_PLUGIN
01064 \textcolor{preprocessor}{  #endif}
01065       
01066   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} needToTranspose = (Flags & \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}) != (
      \hyperlink{struct_eigen_1_1internal_1_1evaluator}{internal::evaluator<OtherDerived>::Flags} & 
      \hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit});
01067   \textcolor{keywordflow}{if} (needToTranspose)
01068   \{
01069 \textcolor{preprocessor}{    #ifdef EIGEN\_SPARSE\_TRANSPOSED\_COPY\_PLUGIN}
01070       EIGEN\_SPARSE\_TRANSPOSED\_COPY\_PLUGIN
01071 \textcolor{preprocessor}{    #endif}
01072     \textcolor{comment}{// two passes algorithm:}
01073     \textcolor{comment}{//  1 - compute the number of coeffs per dest inner vector}
01074     \textcolor{comment}{//  2 - do the actual copy/eval}
01075     \textcolor{comment}{// Since each coeff of the rhs has to be evaluated twice, let's evaluate it if needed}
01076     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} 
      \hyperlink{struct_eigen_1_1internal_1_1nested__eval}{internal::nested\_eval<OtherDerived,2,typename internal::plain\_matrix\_type<OtherDerived>::type}
       >::type OtherCopy;
01077     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \hyperlink{group___sparse_core___module}{internal::remove\_all<OtherCopy>::type} \_OtherCopy;
01078     \textcolor{keyword}{typedef} \hyperlink{struct_eigen_1_1internal_1_1evaluator}{internal::evaluator<\_OtherCopy>} OtherCopyEval;
01079     OtherCopy otherCopy(other.derived());
01080     OtherCopyEval otherCopyEval(otherCopy);
01081 
01082     \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix} dest(other.\hyperlink{group___sparse_core___module_a1944e9fa9ce7937bfc3a87b2cb94371f}{rows}(),other.\hyperlink{group___sparse_core___module_aca7ce296424ef6e478ab0fb19547a7ee}{cols}());
01083     \hyperlink{group___core___module_class_eigen_1_1_map}{Eigen::Map<IndexVector>} (dest.m\_outerIndex,dest.outerSize()).setZero();
01084 
01085     \textcolor{comment}{// pass 1}
01086     \textcolor{comment}{// FIXME the above copy could be merged with that pass}
01087     \textcolor{keywordflow}{for} (\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j=0; j<otherCopy.outerSize(); ++j)
01088       \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} OtherCopyEval::InnerIterator it(otherCopyEval, j); it; ++it)
01089         ++dest.m\_outerIndex[it.index()];
01090 
01091     \textcolor{comment}{// prefix sum}
01092     \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} count = 0;
01093     IndexVector positions(dest.outerSize());
01094     \textcolor{keywordflow}{for} (\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j=0; j<dest.outerSize(); ++j)
01095     \{
01096       \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} tmp = dest.m\_outerIndex[j];
01097       dest.m\_outerIndex[j] = count;
01098       positions[j] = count;
01099       count += tmp;
01100     \}
01101     dest.m\_outerIndex[dest.outerSize()] = count;
01102     \textcolor{comment}{// alloc}
01103     dest.m\_data.resize(count);
01104     \textcolor{comment}{// pass 2}
01105     \textcolor{keywordflow}{for} (\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} j=0; j<otherCopy.outerSize(); ++j)
01106     \{
01107       \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} OtherCopyEval::InnerIterator it(otherCopyEval, j); it; ++it)
01108       \{
01109         \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} pos = positions[it.index()]++;
01110         dest.m\_data.index(pos) = j;
01111         dest.m\_data.value(pos) = it.value();
01112       \}
01113     \}
01114     this->\hyperlink{endian_8c_a3ca5ecd34b04d6a243c054ac3a57f68d}{swap}(dest);
01115     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
01116   \}
01117   \textcolor{keywordflow}{else}
01118   \{
01119     \textcolor{keywordflow}{if}(other.isRValue())
01120     \{
01121       initAssignment(other.derived());
01122     \}
01123     \textcolor{comment}{// there is no special optimization}
01124     \textcolor{keywordflow}{return} Base::operator=(other.derived());
01125   \}
01126 \}
01127 
01128 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex>
01129 \textcolor{keyword}{typename} SparseMatrix<\_Scalar,\_Options,\_StorageIndex>::Scalar& 
      \hyperlink{group___sparse_core___module_aae45e3b5fec7f6a0cdd10eec7c6d3666}{SparseMatrix<\_Scalar,\_Options,\_StorageIndex>::insert}(
      \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col)
01130 \{
01131   eigen\_assert(row>=0 && row<rows() && col>=0 && col<cols());
01132   
01133   \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer = IsRowMajor ? row : col;
01134   \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} inner = IsRowMajor ? col : row;
01135   
01136   \textcolor{keywordflow}{if}(isCompressed())
01137   \{
01138     \textcolor{keywordflow}{if}(nonZeros()==0)
01139     \{
01140       \textcolor{comment}{// reserve space if not already done}
01141       \textcolor{keywordflow}{if}(m\_data.allocatedSize()==0)
01142         m\_data.reserve(2*m\_innerSize);
01143       
01144       \textcolor{comment}{// turn the matrix into non-compressed mode}
01145       m\_innerNonZeros = \textcolor{keyword}{static\_cast<}\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}*\textcolor{keyword}{>}(std::malloc(m\_outerSize * \textcolor{keyword}{sizeof}(
      \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex})));
01146       \textcolor{keywordflow}{if}(!m\_innerNonZeros) internal::throw\_std\_bad\_alloc();
01147       
01148       memset(m\_innerNonZeros, 0, (m\_outerSize)*\textcolor{keyword}{sizeof}(\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}));
01149       
01150       \textcolor{comment}{// pack all inner-vectors to the end of the pre-allocated space}
01151       \textcolor{comment}{// and allocate the entire free-space to the first inner-vector}
01152       \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} end = convert\_index(m\_data.allocatedSize());
01153       \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j=1; j<=m\_outerSize; ++j)
01154         m\_outerIndex[j] = end;
01155     \}
01156     \textcolor{keywordflow}{else}
01157     \{
01158       \textcolor{comment}{// turn the matrix into non-compressed mode}
01159       m\_innerNonZeros = \textcolor{keyword}{static\_cast<}\hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex}*\textcolor{keyword}{>}(std::malloc(m\_outerSize * \textcolor{keyword}{sizeof}(
      \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex})));
01160       \textcolor{keywordflow}{if}(!m\_innerNonZeros) internal::throw\_std\_bad\_alloc();
01161       \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j=0; j<m\_outerSize; ++j)
01162         m\_innerNonZeros[j] = m\_outerIndex[j+1]-m\_outerIndex[j];
01163     \}
01164   \}
01165   
01166   \textcolor{comment}{// check whether we can do a fast "push back" insertion}
01167   \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} data\_end = m\_data.allocatedSize();
01168   
01169   \textcolor{comment}{// First case: we are filling a new inner vector which is packed at the end.}
01170   \textcolor{comment}{// We assume that all remaining inner-vectors are also empty and packed to the end.}
01171   \textcolor{keywordflow}{if}(m\_outerIndex[outer]==data\_end)
01172   \{
01173     eigen\_internal\_assert(m\_innerNonZeros[outer]==0);
01174     
01175     \textcolor{comment}{// pack previous empty inner-vectors to end of the used-space}
01176     \textcolor{comment}{// and allocate the entire free-space to the current inner-vector.}
01177     \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} p = convert\_index(m\_data.size());
01178     \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j = outer;
01179     \textcolor{keywordflow}{while}(j>=0 && m\_innerNonZeros[j]==0)
01180       m\_outerIndex[j--] = p;
01181     
01182     \textcolor{comment}{// push back the new element}
01183     ++m\_innerNonZeros[outer];
01184     m\_data.append(Scalar(0), inner);
01185     
01186     \textcolor{comment}{// check for reallocation}
01187     \textcolor{keywordflow}{if}(data\_end != m\_data.allocatedSize())
01188     \{
01189       \textcolor{comment}{// m\_data has been reallocated}
01190       \textcolor{comment}{//  -> move remaining inner-vectors back to the end of the free-space}
01191       \textcolor{comment}{//     so that the entire free-space is allocated to the current inner-vector.}
01192       eigen\_internal\_assert(data\_end < m\_data.allocatedSize());
01193       \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} new\_end = convert\_index(m\_data.allocatedSize());
01194       \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} k=outer+1; k<=m\_outerSize; ++k)
01195         \textcolor{keywordflow}{if}(m\_outerIndex[k]==data\_end)
01196           m\_outerIndex[k] = new\_end;
01197     \}
01198     \textcolor{keywordflow}{return} m\_data.value(p);
01199   \}
01200   
01201   \textcolor{comment}{// Second case: the next inner-vector is packed to the end}
01202   \textcolor{comment}{// and the current inner-vector end match the used-space.}
01203   \textcolor{keywordflow}{if}(m\_outerIndex[outer+1]==data\_end && m\_outerIndex[outer]+m\_innerNonZeros[outer]==m\_data.size())
01204   \{
01205     eigen\_internal\_assert(outer+1==m\_outerSize || m\_innerNonZeros[outer+1]==0);
01206     
01207     \textcolor{comment}{// add space for the new element}
01208     ++m\_innerNonZeros[outer];
01209     m\_data.resize(m\_data.size()+1);
01210     
01211     \textcolor{comment}{// check for reallocation}
01212     \textcolor{keywordflow}{if}(data\_end != m\_data.allocatedSize())
01213     \{
01214       \textcolor{comment}{// m\_data has been reallocated}
01215       \textcolor{comment}{//  -> move remaining inner-vectors back to the end of the free-space}
01216       \textcolor{comment}{//     so that the entire free-space is allocated to the current inner-vector.}
01217       eigen\_internal\_assert(data\_end < m\_data.allocatedSize());
01218       \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} new\_end = convert\_index(m\_data.allocatedSize());
01219       \textcolor{keywordflow}{for}(\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} k=outer+1; k<=m\_outerSize; ++k)
01220         \textcolor{keywordflow}{if}(m\_outerIndex[k]==data\_end)
01221           m\_outerIndex[k] = new\_end;
01222     \}
01223     
01224     \textcolor{comment}{// and insert it at the right position (sorted insertion)}
01225     \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} startId = m\_outerIndex[outer];
01226     \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} p = m\_outerIndex[outer]+m\_innerNonZeros[outer]-1;
01227     \textcolor{keywordflow}{while} ( (p > startId) && (m\_data.index(p-1) > inner) )
01228     \{
01229       m\_data.index(p) = m\_data.index(p-1);
01230       m\_data.value(p) = m\_data.value(p-1);
01231       --p;
01232     \}
01233     
01234     m\_data.index(p) = convert\_index(inner);
01235     \textcolor{keywordflow}{return} (m\_data.value(p) = 0);
01236   \}
01237   
01238   \textcolor{keywordflow}{if}(m\_data.size() != m\_data.allocatedSize())
01239   \{
01240     \textcolor{comment}{// make sure the matrix is compatible to random un-compressed insertion:}
01241     m\_data.resize(m\_data.allocatedSize());
01242     this->reserveInnerVectors(\hyperlink{group___core___module_class_eigen_1_1_array}{Array<StorageIndex,Dynamic,1>::Constant}
      (m\_outerSize, 2));
01243   \}
01244   
01245   \textcolor{keywordflow}{return} insertUncompressed(row,col);
01246 \}
01247     
01248 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex>
01249 EIGEN\_DONT\_INLINE \textcolor{keyword}{typename} SparseMatrix<\_Scalar,\_Options,\_StorageIndex>::Scalar& 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<\_Scalar,\_Options,\_StorageIndex>::insertUncompressed}
      (\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col)
01250 \{
01251   eigen\_assert(!isCompressed());
01252 
01253   \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer = IsRowMajor ? row : col;
01254   \textcolor{keyword}{const} \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} inner = convert\_index(IsRowMajor ? col : row);
01255 
01256   \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} room = m\_outerIndex[outer+1] - m\_outerIndex[outer];
01257   \hyperlink{group___sparse_core___module_a0b540ba724726ebe953f8c0df06081ed}{StorageIndex} innerNNZ = m\_innerNonZeros[outer];
01258   \textcolor{keywordflow}{if}(innerNNZ>=room)
01259   \{
01260     \textcolor{comment}{// this inner vector is full, we need to reallocate the whole buffer :(}
01261     reserve(SingletonVector(outer,std::max<StorageIndex>(2,innerNNZ)));
01262   \}
01263 
01264   \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} startId = m\_outerIndex[outer];
01265   \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} p = startId + m\_innerNonZeros[outer];
01266   \textcolor{keywordflow}{while} ( (p > startId) && (m\_data.index(p-1) > inner) )
01267   \{
01268     m\_data.index(p) = m\_data.index(p-1);
01269     m\_data.value(p) = m\_data.value(p-1);
01270     --p;
01271   \}
01272   eigen\_assert((p<=startId || m\_data.index(p-1)!=inner) && \textcolor{stringliteral}{"you cannot insert an element that already
       exists, you must call coeffRef to this end"});
01273 
01274   m\_innerNonZeros[outer]++;
01275 
01276   m\_data.index(p) = inner;
01277   \textcolor{keywordflow}{return} (m\_data.value(p) = 0);
01278 \}
01279 
01280 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex>
01281 EIGEN\_DONT\_INLINE \textcolor{keyword}{typename} SparseMatrix<\_Scalar,\_Options,\_StorageIndex>::Scalar& 
      \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<\_Scalar,\_Options,\_StorageIndex>::insertCompressed}
      (\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} row, \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} col)
01282 \{
01283   eigen\_assert(isCompressed());
01284 
01285   \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} outer = IsRowMajor ? row : col;
01286   \textcolor{keyword}{const} \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} inner = IsRowMajor ? col : row;
01287 
01288   \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} previousOuter = outer;
01289   \textcolor{keywordflow}{if} (m\_outerIndex[outer+1]==0)
01290   \{
01291     \textcolor{comment}{// we start a new inner vector}
01292     \textcolor{keywordflow}{while} (previousOuter>=0 && m\_outerIndex[previousOuter]==0)
01293     \{
01294       m\_outerIndex[previousOuter] = convert\_index(m\_data.size());
01295       --previousOuter;
01296     \}
01297     m\_outerIndex[outer+1] = m\_outerIndex[outer];
01298   \}
01299 
01300   \textcolor{comment}{// here we have to handle the tricky case where the outerIndex array}
01301   \textcolor{comment}{// starts with: [ 0 0 0 0 0 1 ...] and we are inserted in, e.g.,}
01302   \textcolor{comment}{// the 2nd inner vector...}
01303   \textcolor{keywordtype}{bool} isLastVec = (!(previousOuter==-1 && m\_data.size()!=0))
01304                 && (std::size\_t(m\_outerIndex[outer+1]) == m\_data.size());
01305 
01306   std::size\_t startId = m\_outerIndex[outer];
01307   \textcolor{comment}{// FIXME let's make sure sizeof(long int) == sizeof(std::size\_t)}
01308   std::size\_t p = m\_outerIndex[outer+1];
01309   ++m\_outerIndex[outer+1];
01310 
01311   \textcolor{keywordtype}{double} reallocRatio = 1;
01312   \textcolor{keywordflow}{if} (m\_data.allocatedSize()<=m\_data.size())
01313   \{
01314     \textcolor{comment}{// if there is no preallocated memory, let's reserve a minimum of 32 elements}
01315     \textcolor{keywordflow}{if} (m\_data.size()==0)
01316     \{
01317       m\_data.reserve(32);
01318     \}
01319     \textcolor{keywordflow}{else}
01320     \{
01321       \textcolor{comment}{// we need to reallocate the data, to reduce multiple reallocations}
01322       \textcolor{comment}{// we use a smart resize algorithm based on the current filling ratio}
01323       \textcolor{comment}{// in addition, we use double to avoid integers overflows}
01324       \textcolor{keywordtype}{double} nnzEstimate = double(m\_outerIndex[outer])*double(m\_outerSize)/double(outer+1);
01325       reallocRatio = (nnzEstimate-double(m\_data.size()))/double(m\_data.size());
01326       \textcolor{comment}{// furthermore we bound the realloc ratio to:}
01327       \textcolor{comment}{//   1) reduce multiple minor realloc when the matrix is almost filled}
01328       \textcolor{comment}{//   2) avoid to allocate too much memory when the matrix is almost empty}
01329       reallocRatio = (std::min)((std::max)(reallocRatio,1.5),8.);
01330     \}
01331   \}
01332   m\_data.resize(m\_data.size()+1,reallocRatio);
01333 
01334   \textcolor{keywordflow}{if} (!isLastVec)
01335   \{
01336     \textcolor{keywordflow}{if} (previousOuter==-1)
01337     \{
01338       \textcolor{comment}{// oops wrong guess.}
01339       \textcolor{comment}{// let's correct the outer offsets}
01340       \textcolor{keywordflow}{for} (\hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} k=0; k<=(outer+1); ++k)
01341         m\_outerIndex[k] = 0;
01342       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} k=outer+1;
01343       \textcolor{keywordflow}{while}(m\_outerIndex[k]==0)
01344         m\_outerIndex[k++] = 1;
01345       \textcolor{keywordflow}{while} (k<=m\_outerSize && m\_outerIndex[k]!=0)
01346         m\_outerIndex[k++]++;
01347       p = 0;
01348       --k;
01349       k = m\_outerIndex[k]-1;
01350       \textcolor{keywordflow}{while} (k>0)
01351       \{
01352         m\_data.index(k) = m\_data.index(k-1);
01353         m\_data.value(k) = m\_data.value(k-1);
01354         k--;
01355       \}
01356     \}
01357     \textcolor{keywordflow}{else}
01358     \{
01359       \textcolor{comment}{// we are not inserting into the last inner vec}
01360       \textcolor{comment}{// update outer indices:}
01361       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} j = outer+2;
01362       \textcolor{keywordflow}{while} (j<=m\_outerSize && m\_outerIndex[j]!=0)
01363         m\_outerIndex[j++]++;
01364       --j;
01365       \textcolor{comment}{// shift data of last vecs:}
01366       \hyperlink{group___core___module_a554f30542cc2316add4b1ea0a492ff02}{Index} k = m\_outerIndex[j]-1;
01367       \textcolor{keywordflow}{while} (k>=\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}(p))
01368       \{
01369         m\_data.index(k) = m\_data.index(k-1);
01370         m\_data.value(k) = m\_data.value(k-1);
01371         k--;
01372       \}
01373     \}
01374   \}
01375 
01376   \textcolor{keywordflow}{while} ( (p > startId) && (m\_data.index(p-1) > inner) )
01377   \{
01378     m\_data.index(p) = m\_data.index(p-1);
01379     m\_data.value(p) = m\_data.value(p-1);
01380     --p;
01381   \}
01382 
01383   m\_data.index(p) = inner;
01384   \textcolor{keywordflow}{return} (m\_data.value(p) = 0);
01385 \}
01386 
01387 \textcolor{keyword}{namespace }\hyperlink{namespaceinternal}{internal} \{
01388 
01389 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \_Scalar, \textcolor{keywordtype}{int} \_Options, \textcolor{keyword}{typename} \_StorageIndex>
01390 \textcolor{keyword}{struct }evaluator<SparseMatrix<\_Scalar,\_Options,\_StorageIndex> >
01391   : evaluator<SparseCompressedBase<SparseMatrix<\_Scalar,\_Options,\_StorageIndex> > >
01392 \{
01393   \textcolor{keyword}{typedef} evaluator<SparseCompressedBase<SparseMatrix<\_Scalar,\_Options,\_StorageIndex> > > Base;
01394   \textcolor{keyword}{typedef} \hyperlink{group___sparse_core___module_class_eigen_1_1_sparse_matrix}{SparseMatrix<\_Scalar,\_Options,\_StorageIndex>} 
      SparseMatrixType;
01395   evaluator() : Base() \{\}
01396   \textcolor{keyword}{explicit} evaluator(\textcolor{keyword}{const} SparseMatrixType &mat) : Base(mat) \{\}
01397 \};
01398 
01399 \}
01400 
01401 \} \textcolor{comment}{// end namespace Eigen}
01402 
01403 \textcolor{preprocessor}{#endif // EIGEN\_SPARSEMATRIX\_H}
\end{DoxyCode}
