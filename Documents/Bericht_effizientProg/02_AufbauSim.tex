\chapter{Werkzeuge für effiziente Code-Entwicklung}
In diesem Kapitel werden die verwendeten "Werkzeuge" näher erläutert, die bei der Code-Entwicklung unterstützt haben. Dabei wird auf Aspekte aus \cite{Kessler.Sommersemester2017} eingegangen.

\section{Entwicklungsumgebung und Versionsmanagement}
Wie in \cite{Kessler.Sommersemester2017} beschrieben können Entwicklungsumgebungen bei der Entwicklung und Implementierung von Programmen unterstützen. Aufgrund des Windows-Betriebssystems ist die Entscheidung auf  Microsoft Visual Studio 2017 gefallen. Für die Reproduzierbarkeit wurde ein Repository bei GitHub angelegt. Da es sich bei dieser Arbeit nicht um ein Gruppenprojekt handelt, wurde lediglich ein Trunk angelegt. Es wurde stets darauf geachtet, dass die Version nur eingecheckt wurde, wenn das Programm lauffähig war und zuvor getestet wurde \cite{Kessler.Sommersemester2017}.  
\section{Code Dokumentation und User Manual}
Ein weit verbreitetes Problem ist die Dokumentation von Programmen. Das Problem besteht darin, dass ein zusätzliches Dokument gepflegt werden muss. Um dieses Programm zu dokumentieren wird Doxygen genutzt. Mit speziellen Kommentarzeilen erzeugt Doxygen automatisch ein HTML oder \LaTeX Dokument. Zusätzlich werden die Abhängigkeiten der Klassen zueinander visualisiert. Somit entsteht nur ein geringer Mehraufwand für den Entwickler. \\
Für die Installation und Nutzung der Simulation wurde eigens ein User Manual erstellt. Es soll dem Nutzer die Bedienung der Simulation erläutern. 
\newpage
\section{Verwendung von Open Source Bibliotheken}
\label{sec:OSBib}
Nach  \cite{Kessler.Wintersemester201718}  ist es nicht immer notwendig bei gewissen Funktionalitäten von Grund auf neu zu beginnen, sondern auf bereits bestehendes Aufzubauen.
Da in dieser Arbeit die Simulation im Vordergrund steht und nicht die Implementierung von grundlegenden Funktionen, wurden neben den C++ Standardbibliotheken ebenfalls Open Source Bibliotheken eingebunden.\\ Aufgrund dessen, dass besagte Simulation auf dem Matlab Programm nach \cite{Olucak.15.02.2017} beruht, ist die Lineare Algebra unverzichtbar. Zudem wurden Daten häufig in komprimierten .mat-Files gespeichert. Es liegt also nahe diese grundlegenden Funktionen mithilfe von bereits vorhanden Bibliotheken nach Möglichkeit abzudecken.
\\Die in diesem Projekt verwendeten Open Source Bibliotheken werden in Tabelle \ref{tab:openSource} kurz beschrieben.
\begin{table}[h]
	\centering	\begin{tabular}{l p{10cm}}
		\textbf{Name der Bibliothek} & \textbf{Kurzbeschreibung}\\
		 \textit{eigen} &  C++ Template Bibliothek für lineare Algebra \cite{TuxFamily.2018}\\\\
		 \textit{matio} & C/C++ Bibliothek, die Funktionen bereitstellt, um Daten aus .mat-Files zu lesen und diese zu erstellen \cite{Hulbert.2013}
	\end{tabular}
	\caption{Übersicht über verwendete Open Source Bibliotheken}
	\label{tab:openSource}
\end{table}\\
Wie aus Tabelle \ref{tab:openSource} ersichtlich handelt es sich bei der  \textit{eigen}-Bibliothek um Templates. Nachdem  \textit{eigen} in das Programm eingebunden wird, kann sofort auf die Funktionen zugegriffen werden. Zum Einlesen der .mat-Files wurden aufbauend auf den  Funktionen aus der  \textit{matio}-Bibliothek selbst eine Klasse implementiert, die diese Funktionalität bereitstellt. Um  \textit{matio} zu verwenden werden sei darauf verwiesen, dass zusätzlich noch die Bibliotheken  \textit{HDF5} \cite{HDFGroup.2018} und  \textit{zlib} \cite{Roelofs.2018} benötigt werden. 



\chapter{Simulations-Framework}
\label{ch:Simulations-Framework}
Im Nachfolgenden Kapitel soll die Grundidee des Simulations-Frameworks erläutert werden. Zum Einen soll ein modularer Aufbau umgesetzt werden, sodass im späteren Verlauf die Module nach dem Baukastenprinzip zu einer Gesamtsimulation zusammengesetzt werden und jederzeit um weitere Klassen ergänzt werden können. Zum Anderen soll der Nutzer in der Lage sein, in den Modulen verschiedene Methoden zu nutzen, ohne dabei den Code zu verändern.
\section{Aufbau der Module}
\label{sec:AufbauModule}
Jedes Modul beschreibt eine spezifische Domäne des Flugzeuges und  besitzt mehrere Klassen, die im Nachfolgenden allgemein erläutert werden. Eine Klasse ist für die Auswahl und den Aufruf der gewünschten Modelle zuständig und besitzt den gleichen Namen wie das Modul (Modulklasse). Sie wird im späteren Verlauf in der Simulation aufgerufen und dient sozusagen als Schnittstelle zu den anderen Modulen. Um nun eine gewünschte Methoden aufrufen zu können, ohne dabei den Code zu verändern, wird auf das Prinzip der Vererbung  zurückgegriffen. Die Basisklasse wird in der Modulklasse aufgerufen. Die Kindklassen können sowohl von der Basisklasse als auch von einem anderen Kind abgeleitet werden. Der allgemeine Aufbau eines Moduls wird in Abbildung  \ref{fig:UML_Modul} exemplarisch dargestellt.
 \begin{figure}[h]
 	 \centering\includegraphics[width=0.3\linewidth]{UML_Modul.PNG}
 	 \caption{Allgemeiner Aufbau eins Moduls }
 	 \label{fig:UML_Modul}
 \end{figure} \newpage
Zusätzlich besitzen alle Klassen neben Konstruktor und Destruktor auch Standard-Methoden, die in Tabelle \ref{tab:Standardmethoden} beschrieben werden.
\begin{table}[h]
	\centering	\begin{tabular}{l p{10cm}}
		\textbf{Standard-Methode} & \textbf{Bedeutung}\\
		init(...) & Die für die jeweilige Domäne benötigten Parameter werden aus den Input-Files eingelesen und Variablen initialisiert.\\\\
		update(...) & Methode in der die spezifische Domäne  simuliert wird	\end{tabular}
	\caption{Standard-Methoden der Simulation}
	\label{tab:Standardmethoden}
\end{table}\\
Die Standard-Methoden sollen einen einheitlichen Funktionsaufruf gewährleisten. Neben besagten Standard-Methoden können die Klassen auch noch zusätzliche Methoden besitzen, worauf später noch näher eingegangen wird. \\
Im Speziellen wird hier Polymorphie mithilfe von virtuellen Funktionen genutzt. Dazu werden die Standard-Methoden der Basisklasse als virtuelle Funktionen deklariert, was exemplarisch im Listing \ref{list:Basisklasse} zu sehen ist.\newpage

\begin{lstlisting}[label = {list:Basisklasse}, caption = Aufbau des Header-Files der Basisklasse,captionpos=b]
	virtual initBasisklasse();

	virtual updateBasisklasse();
\end{lstlisting}
Aus diesem Grund lässt sich die Basisklasse auch als polymorphe Klasse bezeichnen \cite{Wolf.2014}. \\
Um nun zu gewährleisten, dass das gewünschte Modell des Moduls ausgewählt wird, wird ein ein Basisklassenzeiger verwendet. Der Zeiger kann auf jedes Objekt adressiert werden, dass von ihm abgeleitet wurde \cite{Wolf.2014}. Die eigentliche Initialisierung findet in der Modulklasse statt. Dazu wird neben den Standard-Methoden noch die Methode \textit{SelectModuleType} implementiert, wobei \textit{Module} für das jeweilige Modul steht, was im Listing \ref{list:ModulAuswahl} zu sehen ist.\\
\begin{lstlisting}[label = {list:ModulAuswahl}, caption = Basisklassenzeiger im Modul.cpp File ,captionpos=b]
void Modulklasse::SelectModuleType(int Type)

switch(Type){
	case 1:
		// Initialisierung der ersten Methode
		BasePtr= new Kindklasse1;
		break;
	
	case 2:
		// Initialisierung der zweiten Methode 
		BasePtr = new Kindklasse2;
		break;
}

\end{lstlisting}
Durch das Schlüsselwort \textbf{virtual} in der Basisklasse wird der Compiler veranlasst, zum entsprechenden Objekt die dazugehörige Methode aufzurufen, wenn das Objekt über den Zeiger auf die Basisklasse angesprochen wird \cite{Wolf.2014}. \newpage
Im nächsten Schritt können nun in der Modulklasse die Standard-Methoden der Basisklasse aufgerufen werden, wie im Lisiting \ref{list:ModulAufruf} dargestellt.
\begin{lstlisting}[label = {list:ModulAufruf}, caption = Aufruf der Standard-Methoden  im Modul.cpp File ,captionpos=b]
void Modulklasse::initModulklasse()
{
	BasePtr->initBasisklasse();
}

void Modulklasse::updateModulklasse()
{
	BasePtr->updateBasisklasse();
}
\end{lstlisting}

Somit können die Methoden der Kind-Klassen, wo die Modelle implementiert wurden, aufgerufen werden, in dem die Standard-Methoden der Modulklasse aufgerufen werden. Der Nutzer muss lediglich den spezifische Modell-Parameter im Input-File ändern, um ein anderes Model auszuwählen. \\Soll ein Modul eine neue zusätzliche Klasse (neues Modell) erhalten, so muss der Nutzer lediglich die Klasse selbst implementieren und in \textit{SelectModuleType} des jeweiligen Moduls einen neuen Case mit der richtigen Initialisierung hinzufügen.
\newpage
\section{Aufbau und Ablauf der Ausbaustufen}
\label{sec:Ausbaustufen}
Durch die Beschreibung der Flugzeugdomänen mithilfe der Module, ist man nun in der Lage die eigentliche Simulation im Baukastenprinzip aufzubauen. Die einzelnen Module werden in eigenen Projektordnern hinterlegt.\\ In Tabelle \ref{tab:Modulbeschreibungen} werden alle Module, die für die Ausbaustufen der Simulation benötigt werden, kurz umschrieben. Dabei wird lediglich die allgemeine Funktion des jeweiligen Moduls beleuchtet, anstatt deren Implementierung, um einen Überblick zu erhalten. 
\begin{table}[h]
	\centering	\begin{tabular}{l p{9cm}}
		\textbf{Modulname} & \textbf{Kurzbeschreibung}\\\\
		Actuator	& Simuliert die Rudermaschinen des Flugzeuges\\\\
		Aerodynamic & Berechnung der aerodynamischen Kräfte und Momente\\\\
		Airframe & Enthält die Bewegungsgleichungen des Flugzeuges\\\\
		Atmosphere & US Standard-Atmosphäre 1976\\\\
		Autopilot & Vorgaberegler\\\\
		Engine & Berechnung der Schubkräfte und -momente\\\\
		GPS & GPS-Modul \\\\
		Guidance & Flugführungssystem\\\\
		IMU & Inertialsensorik\\\\
		Navigation &  Berechung der Navigationslösung für das GNC.
	\end{tabular}
	\caption{Module der generischen Flugzeug-Simulation}
	\label{tab:Modulbeschreibungen}
\end{table}\\
An dieser Stelle sei angemerkt, dass noch weitere Module vorhanden sind , die allerdings vielmehr eine sekundäre Rolle für die eigentliche Simulation einnehmen. Auf besagte Module wird im späteren Verlauf dieser Arbeit noch eingegangen. Zudem sei noch erwähnt, dass nur Domänen implementiert wurden, die für eine nichtlineare flugmechanische Simulation benötigt werden. Eine Erweiterung um weitere Domänen wäre denkbar. \\
Wie bereits in Abschnitt \ref{sec:ausgangslage} beschrieben, werden verschiedene Ausbaustufen der Simulation benötigt. Unter Ausbaustufe ist hierbei die Anzahl an Freiheitsgraden und Detaillierungsgrad gemeint. Die Ausbaustufen werden im Modul \textit{Trajectory} implementiert. Der Aufbau und der Aufruf erfolgt wie in Abschnitt \ref{sec:AufbauModule} beschrieben. Je nach Ausbaustufe werden innerhalb des Trajektorien-Moduls die in Tabelle \ref{tab:Modulbeschreibungen}  beschriebenen Module über ihre Modulklasse aufgerufen.\newpage
Insgesamt sind drei Ausbaustufen vorgesehen, die im Folgenden erläutert werden. Die Aktivitätsdiagramme beziehen sich dabei immer auf einen Zeitschritt und beruhen auf den in \cite{Zipfel.2007} aufgezeigten Simulationen.
Die niedrigste Ausbaustufe ist eine Simulation mit 3 Freiheitsgraden. Es werden nur die translatorischen Bewegungsgleichungen berücksichtigt. Die Aufruf-Reihenfolge wird in Abbildung \ref{fig:3_Dof} aufgezeigt.
\begin{figure}[h]
	\centering\includegraphics[width=0.8\linewidth]{3Dof.PNG}
	\caption{Aktivitätsdiagramm der Trajektorie mit 3 Freiheitsgraden (3 Dof)}
	\label{fig:3_Dof}
\end{figure}\\
Eine solche Ausbaustufe könnte beispielsweise schon sehr früh genutzt werden, wenn zum Beispiel noch keine Trägheitsmomente des Flugzeuges bekannt sind. \\
Die nächst höhere Ausbaustufe besitzt 6 Freiheitsgrade und erbt von der Ausbustufe mit 3 Freiheitsgraden. Der Ablauf ist in Abbildung \ref{fig:6Dof} zu sehen. 
\begin{figure}[h]
	\includegraphics[width=1.0\linewidth]{6Dof.PNG}
	\caption{Aktivitätsdiagramm der Trajektorie mit 6 Freiheitsgraden (6 Dof)}
	\label{fig:6Dof}
\end{figure}\\
Die Kindklasse wird um die rotatorischen Bewegungsgleichungen ergänzt. Außerdem erhält sie ein Flugführungssystem und einen Vorgaberegler. Eine solche Ausbaustufe könnte beispielsweise genutzt werden, um die Flugregelung auf dem nichtlinearen Modell zu testen und zu beurteilen.  In den beiden bisherigen Ausbaustufen wird das Systemverhalten als ideal angesehen. Das bedeutet, dass weder Messfehler durch Sensorik oder Verzögerung durch Aktuatorik berücksichtigt werden. \\
Unabhängig von der Güte der physikalischen und mathematischen Modelle ist es dennoch wichtig, ab einem gewissen Grad des Entwicklungsprozesses Fehlermodelle für Subsysteme zu berücksichtigen. Somit wird eine weiter Ausbaustufe benötigt. Diese ist in Abbildung \ref{fig:realSys} zu sehen.
\begin{figure}[h]
	\includegraphics[width=1.0\linewidth]{realSystem.PNG}
	\caption{Aktivitätsdiagramm der Trajektorie mit 6 Freiheitsgraden unter Berücksichtigung von Fehlermodellen}
	\label{fig:realSys}
\end{figure}\\
Die höchste Ausbaustufe erbt ebenfalls von der ersten Ausbaustufe mit 3 Freiheitsgraden. Anstatt der idealen Integration der Kinematik wird ein Navigations-Modul verwendet. Dort wird im Regelfall eine Navigationslösung erzeugt, in dem die Sensormessungen genutzt werden um durch ein Kalman-Filter Position und Lage zu schätzen. Zudem wird die Messung durch Inertialsensoren berücksichtigt. Verzögerungen, die beispielsweise durch die Rudermaschinen verursacht werden, können im Akutator-Modul modelliert werden. Aktuell sind keine Fehlermodelle implementiert. Für Testzwecke wird das Verhalten dieser Module als fehlerfrei angesehen.

\section{Gesamtsimulation}
Die zuvor beschriebenen Ausbaustufen können genutzt werden, um die Trajektorie eines Flugzeuges zu simulieren. Somit ist es naheliegend das Gesamtflugzeug in einem eigenen Modul zu beschreiben, dem \textit{Aircraft}-Modul.\\
Neben dem Trajektorien-Modul wird dort ebenfalls die Atmosphäre initialisiert. Der Ablauf des Gesamtflugzeuges wird in Abbildung \ref{fig:Aircraft} aufgezeigt, wobei angemerkt sei, dass sämtliche Objekte bereits initialisiert wurden und \textit{updateTrajectory} für die vom Nutzer ausgewählte Ausbaustufe der Simulation steht.
\begin{figure}[h]
	\centering\includegraphics[width=0.8\linewidth]{Aircraft.PNG}
	\caption{Aktivitätsdiagramm der Gesamtflugzeug-Simulation}
	\label{fig:Aircraft}
\end{figure}\\
